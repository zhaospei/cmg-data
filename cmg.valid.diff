@@ -459,6 +459,7 @@ start_play_tune (GstSidDec * siddec) <nl>   <nl>    gst_segment_init (&segment, GST_FORMAT_TIME); <nl>    gst_pad_push_event (siddec->srcpad, gst_event_new_segment (&segment)); <nl> +  siddec->total_bytes = 0; <nl>   <nl>    res = gst_pad_start_task (siddec->srcpad, <nl>        (GstTaskFunction) play_loop, siddec->srcpad, NULL);
@@ -292,6 +292,7 @@ gst_rdt_depay_push (GstRDTDepay * rdtdepay, GstBuffer * buffer) <nl>      rdtdepay->need_newsegment = FALSE; <nl>    } <nl>   <nl> +  buffer = gst_buffer_make_metadata_writable (buffer); <nl>    gst_buffer_set_caps (buffer, GST_PAD_CAPS (rdtdepay->srcpad)); <nl>   <nl>    if (rdtdepay->discont) {
@@ -424,6 +424,9 @@ free_tree (struct tree *t) <nl>  { <nl>    size_t i; <nl>   <nl> +  if (t == NULL) <nl> +    return; <nl> + <nl>    for (i = 0; i < t->nr_files; ++i) { <nl>      free (t->files[i].path); <nl>      guestfs_free_statns (t->files[i].stat);
@@ -281,6 +281,8 @@ main (int argc, char *argv[]) <nl>        name = strrchr (drvs->a.filename, '/'); <nl>        if (name == NULL) <nl>          name = drvs->a.filename; <nl> +      else <nl> +        name++; /* skip '/' character */ <nl>        break; <nl>      case drv_d: <nl>        name = drvs->d.guest;
@@ -320,7 +320,6 @@ check_for_cached_appliance (guestfs_h *g, <nl>    snprintf (filename, len, "%s/checksum", cachedir); <nl>   <nl>    (void) mkdir (cachedir, 0755); <nl> -  (void) utime (cachedir, NULL); <nl>   <nl>    /* See if the cache directory exists and passes some simple checks <nl>     * to make sure it has not been tampered with. <nl> @@ -344,6 +343,8 @@ check_for_cached_appliance (guestfs_h *g, <nl>      return -1; <nl>    } <nl>   <nl> +  (void) utime (cachedir, NULL); <nl> + <nl>    garbage_collect_appliances (cachedir); <nl>   <nl>    /* Try to open and acquire a lock on the checksum file. */
@@ -32,10 +32,11 @@ <nl>   <nl>  #define Val_none (Val_int (0)) <nl>   <nl> -extern value virt_builder_yajl_is_available (value unit); <nl> -extern value virt_builder_yajl_tree_parse (value stringv); <nl> +value virt_builder_yajl_is_available (value unit); <nl>   <nl>  #if HAVE_YAJL <nl> +value virt_builder_yajl_tree_parse (value stringv); <nl> + <nl>  static value <nl>  convert_yajl_value (yajl_val val, int level) <nl>  { <nl> @@ -126,6 +127,7 @@ virt_builder_yajl_tree_parse (value stringv) <nl>  } <nl>   <nl>  #else <nl> +value virt_builder_yajl_tree_parse (value stringv)  __attribute__((noreturn)); <nl>   <nl>  value <nl>  virt_builder_yajl_is_available (value unit) <nl> @@ -135,7 +137,7 @@ virt_builder_yajl_is_available (value unit) <nl>  } <nl>   <nl>  value <nl> -virt_builder_yajl_tree_parse (value stringv) __attribute__((noreturn)) <nl> +virt_builder_yajl_tree_parse (value stringv) <nl>  { <nl>    caml_invalid_argument ("virt-builder was compiled without yajl support"); <nl>  }
@@ -524,11 +524,10 @@ static char *replace_str(const char *str, const char *old, /* {{{ */ <nl>  	} else <nl>  		retlen = strlen(str); <nl>   <nl> -	ret = malloc(retlen + 1); <nl> +	ret = calloc(1, retlen + 1); <nl>  	if (ret == NULL) <nl>  		return NULL; <nl>  	// added to original: not optimized, but keeps valgrind happy. <nl> -	memset(ret, 0, retlen + 1); <nl>   <nl>  	r = ret; <nl>  	p = str;
@@ -943,10 +943,9 @@ static int varnish_init (void) /* {{{ */ <nl>  	if (have_instance) <nl>  		return (0); <nl>   <nl> -	conf = malloc (sizeof (*conf)); <nl> +	conf = calloc (1, sizeof (*conf)); <nl>  	if (conf == NULL) <nl>  		return (ENOMEM); <nl> -	memset (conf, 0, sizeof (*conf)); <nl>   <nl>  	/* Default settings: */ <nl>  	conf->instance = NULL; <nl> @@ -972,10 +971,9 @@ static int varnish_config_instance (const oconfig_item_t *ci) /* {{{ */ <nl>  	char callback_name[DATA_MAX_NAME_LEN]; <nl>  	int i; <nl>   <nl> -	conf = malloc (sizeof (*conf)); <nl> +	conf = calloc (1, sizeof (*conf)); <nl>  	if (conf == NULL) <nl>  		return (ENOMEM); <nl> -	memset (conf, 0, sizeof (*conf)); <nl>  	conf->instance = NULL; <nl>   <nl>  	varnish_config_apply_default (conf);
@@ -52,8 +52,9 @@ typedef struct memcached_s memcached_t; <nl>   <nl>  static _Bool memcached_have_instances = 0; <nl>   <nl> -static void memcached_free (memcached_t *st) <nl> +static void memcached_free (void *arg) <nl>  { <nl> +  memcached_t *st = arg; <nl>    if (st == NULL) <nl>      return; <nl>   <nl> @@ -556,7 +557,7 @@ static int memcached_add_read_callback (memcached_t *st) <nl>   <nl>    memset (&ud, 0, sizeof (ud)); <nl>    ud.data = st; <nl> -  ud.free_func = (void *) memcached_free; <nl> +  ud.free_func = memcached_free; <nl>   <nl>    assert (st->name != NULL); <nl>    ssnprintf (callback_name, sizeof (callback_name), "memcached/%s", st->name);
@@ -259,9 +259,6 @@ static void submit (const char *plugin_instance, /* {{{ */ <nl>      if (strcmp (lookup_table[i].name, pdns_type) == 0) <nl>        break; <nl>   <nl> -  if (lookup_table[i].type == NULL) <nl> -    return; <nl> - <nl>    if (i >= lookup_table_length) <nl>    { <nl>      INFO ("powerdns plugin: submit: Not found in lookup table: %s = %s;", <nl> @@ -269,6 +266,9 @@ static void submit (const char *plugin_instance, /* {{{ */ <nl>      return; <nl>    } <nl>   <nl> +  if (lookup_table[i].type == NULL) <nl> +    return; <nl> + <nl>    type = lookup_table[i].type; <nl>    type_instance = lookup_table[i].type_instance; <nl>  
@@ -64,7 +64,14 @@ bool_t xdr_nullstring(XDR *xdrs, char **objp) <nl>  		    return FALSE; <nl>  	       } <nl>  	  } <nl> -	  return (xdr_opaque(xdrs, *objp, size)); <nl> +	  if (!xdr_opaque(xdrs, *objp, size)) <nl> +		  return FALSE; <nl> +	  /* Check that the unmarshalled bytes are a C string. */ <nl> +	  if ((*objp)[size - 1] != '\0') <nl> +		  return FALSE; <nl> +	  if (memchr(*objp, '\0', size - 1) != NULL) <nl> +		  return FALSE; <nl> +	  return TRUE; <nl>   <nl>       case XDR_ENCODE: <nl>  	  if (size != 0)
@@ -38,7 +38,7 @@ krb5_encrypt_helper(krb5_context context, const krb5_keyblock *key, krb5_keyusag <nl>   <nl>      cipher->ciphertext.length = enclen; <nl>      if ((cipher->ciphertext.data = (char *) malloc(enclen)) == NULL) <nl> -	return(ret); <nl> +	return(ENOMEM); <nl>      ret = krb5_c_encrypt(context, key, usage, 0, plain, cipher); <nl>      if (ret) { <nl>  	free(cipher->ciphertext.data);
@@ -61,7 +61,7 @@ krb5_gss_export_name(OM_uint32 *minor_status, const gss_name_t input_name, <nl>      krb5_free_context(context); <nl>      length = strlen(str); <nl>      exported_name->length = 10 + length + gss_mech_krb5->length; <nl> -    exported_name->value = malloc(exported_name->length); <nl> +    exported_name->value = gssalloc_malloc(exported_name->length); <nl>      if (!exported_name->value) { <nl>          free(str); <nl>          if (minor_status)
@@ -445,6 +445,11 @@ krb5_def_fetch_mkey_list(krb5_context        context, <nl>      if (retval) <nl>          return (retval); <nl>   <nl> +    if (master_entry->n_key_data == 0) { <nl> +        retval = KRB5_KDB_NOMASTERKEY; <nl> +        goto clean_n_exit; <nl> +    } <nl> + <nl>      /* <nl>       * Check if the input mkey is the latest key and if it isn't then find the <nl>       * latest mkey.
@@ -196,8 +196,8 @@ krb5_sname_to_principal(krb5_context context, const char *hostname, const char * <nl>          retval = krb5_build_principal(context, ret_princ, strlen(realm), <nl>                                        realm, sname, remote_host, <nl>                                        (char *)0); <nl> - <nl> -        krb5_princ_type(context, *ret_princ) = type; <nl> +        if (retval == 0) <nl> +            krb5_princ_type(context, *ret_princ) = type; <nl>   <nl>  #ifdef DEBUG_REFERRALS <nl>          printf("krb5_sname_to_principal returning\n");
@@ -87,7 +87,8 @@ ec_verify(krb5_context context, krb5_data *req_pkt, krb5_kdc_req *request, <nl>      } <nl>   <nl>      /* Check for a configured FAST ec auth indicator. */ <nl> -    realmstr = k5memdup0(realm.data, realm.length, &retval); <nl> +    if (retval == 0) <nl> +        realmstr = k5memdup0(realm.data, realm.length, &retval); <nl>      if (realmstr != NULL) <nl>          retval = profile_get_string(context->profile, KRB5_CONF_REALMS, <nl>                                      realmstr,
@@ -864,8 +864,12 @@ krb_error_out: <nl>   <nl>  error_out: <nl>      if (cred != NULL) { <nl> -        if (cred->ccache) <nl> -            krb5_cc_close(context, cred->ccache); <nl> +        if (cred->ccache) { <nl> +            if (cred->destroy_ccache) <nl> +                krb5_cc_destroy(context, cred->ccache); <nl> +            else <nl> +                krb5_cc_close(context, cred->ccache); <nl> +        } <nl>          if (cred->client_keytab) <nl>              krb5_kt_close(context, cred->client_keytab); <nl>  #ifndef LEAN_CLIENT <nl> @@ -876,6 +880,8 @@ error_out: <nl>              krb5_rc_close(context, cred->rcache); <nl>          if (cred->name) <nl>              kg_release_name(context, &cred->name); <nl> +        krb5_free_principal(context, cred->impersonator); <nl> +        zapfreestr(cred->password); <nl>          k5_mutex_destroy(&cred->lock); <nl>          xfree(cred); <nl>      }
@@ -327,7 +327,8 @@ static struct { <nl>    } <nl>   <nl>    void StopTracingAgent() { <nl> -    tracing_agent_->Stop(); <nl> +    if (tracing_agent_) <nl> +      tracing_agent_->Stop(); <nl>    } <nl>   <nl>    tracing::Agent* GetTracingAgent() const {
@@ -5082,10 +5082,10 @@ bool Heap::ConfigureHeap(int max_semi_space_size, int max_old_space_size, <nl>      max_semi_space_size_ = max_semi_space_size * MB; <nl>    } <nl>    if (max_old_space_size > 0) { <nl> -    max_old_generation_size_ = max_old_space_size * MB; <nl> +    max_old_generation_size_ = static_cast<intptr_t>(max_old_space_size) * MB; <nl>    } <nl>    if (max_executable_size > 0) { <nl> -    max_executable_size_ = max_executable_size * MB; <nl> +    max_executable_size_ = static_cast<intptr_t>(max_executable_size) * MB; <nl>    } <nl>   <nl>    // If max space size flags are specified overwrite the configuration. <nl> @@ -5093,10 +5093,11 @@ bool Heap::ConfigureHeap(int max_semi_space_size, int max_old_space_size, <nl>      max_semi_space_size_ = FLAG_max_semi_space_size * MB; <nl>    } <nl>    if (FLAG_max_old_space_size > 0) { <nl> -    max_old_generation_size_ = FLAG_max_old_space_size * MB; <nl> +    max_old_generation_size_ = <nl> +        static_cast<intptr_t>(FLAG_max_old_space_size) * MB; <nl>    } <nl>    if (FLAG_max_executable_size > 0) { <nl> -    max_executable_size_ = FLAG_max_executable_size * MB; <nl> +    max_executable_size_ = static_cast<intptr_t>(FLAG_max_executable_size) * MB; <nl>    } <nl>   <nl>    if (FLAG_stress_compaction) {
@@ -28,8 +28,7 @@ class ExternString: public ResourceType { <nl>    public: <nl>      ~ExternString() override { <nl>        delete[] data_; <nl> -      int64_t change_in_bytes = -static_cast<int64_t>(length_); <nl> -      isolate()->AdjustAmountOfExternalAllocatedMemory(change_in_bytes); <nl> +      isolate()->AdjustAmountOfExternalAllocatedMemory(-byte_length()); <nl>      } <nl>   <nl>      const TypeName* data() const override { <nl> @@ -40,6 +39,10 @@ class ExternString: public ResourceType { <nl>        return length_; <nl>      } <nl>   <nl> +    int64_t byte_length() const { <nl> +      return length() * sizeof(*data()); <nl> +    } <nl> + <nl>      static Local<String> NewFromCopy(Isolate* isolate, <nl>                                       const TypeName* data, <nl>                                       size_t length) { <nl> @@ -69,7 +72,7 @@ class ExternString: public ResourceType { <nl>                                                                       data, <nl>                                                                       length); <nl>        Local<String> str = String::NewExternal(isolate, h_str); <nl> -      isolate->AdjustAmountOfExternalAllocatedMemory(length); <nl> +      isolate->AdjustAmountOfExternalAllocatedMemory(h_str->byte_length()); <nl>   <nl>        return scope.Escape(str); <nl>      }
@@ -2761,6 +2761,10 @@ void SetupProcessObject(Environment* env, <nl>      READONLY_PROPERTY(process, <nl>                        "_preload_modules", <nl>                        array); <nl> + <nl> +    delete[] preload_modules; <nl> +    preload_modules = nullptr; <nl> +    preload_module_count = 0; <nl>    } <nl>   <nl>    // --no-deprecation
@@ -261,7 +261,7 @@ static int ea05(cli_ctx *ctx, const uint8_t *base, char *tmpd) { <nl>        continue; <nl>      } <nl>   <nl> -    if (UNP.csize < sizeof(union unaligned_32)) { <nl> +    if (comp == 1 && UNP.csize < sizeof(union unaligned_32)) { <nl>        cli_dbgmsg("autoit: compressed size too small, skipping\n"); <nl>        continue; <nl>      } <nl> @@ -586,7 +586,7 @@ static int ea06(cli_ctx *ctx, const uint8_t *base, char *tmpd) { <nl>        continue; <nl>      } <nl>   <nl> -    if (UNP.csize < sizeof(union unaligned_32)) { <nl> +    if (comp == 1 && UNP.csize < sizeof(union unaligned_32)) { <nl>        cli_dbgmsg("autoit: compressed size too small, skipping\n"); <nl>        continue; <nl>      }
@@ -1,6 +1,6 @@ <nl>  /* <nl>   *  Interface to libclamunrar <nl> - *  Copyright (C) 2007 Sourcefire, Inc. <nl> + *  Copyright (C) 2007-2013 Sourcefire, Inc. <nl>   *  Authors: Trog, Torok Edvin, Tomasz Kojm <nl>   * <nl>   *  This library is free software; you can redistribute it and/or <nl> @@ -419,7 +419,6 @@ int unrar_extract_next_prepare(unrar_state_t *state, const char *dirname) <nl>  		snprintf(filename, 1024, "%s"PATHSEP"%lu.cmt", state->comment_dir, state->file_count); <nl>  		ofd = open(filename, O_WRONLY|O_CREAT|O_TRUNC|O_BINARY, 0600); <nl>  		if(ofd < 0) { <nl> -		    free(comment_header); <nl>  		    unrar_dbgmsg("UNRAR: ERROR: Failed to open output file\n"); <nl>  		} else { <nl>  		    unrar_dbgmsg("UNRAR: Copying file comment (not packed)\n");
@@ -471,7 +471,7 @@ static int read_tables(int fd, unpack_data_t *unpack_data) <nl>  				rar_addbits(unpack_data, 7); <nl>  			} <nl>  			if (i == 0) { <nl> -				rar_dbgmsg("We cannot have repeat previous code at the first position"); <nl> +				rar_dbgmsg("We cannot have repeat previous code at the first position\n"); <nl>  				return FALSE; <nl>  			} <nl>  			while (n-- > 0 && i < table_size) {
@@ -71,7 +71,7 @@ static inline int bcfail(const char *msg, long a, long b, <nl>  #define CHECK_EQ(a,b) <nl>  #define CHECK_GT(a,b) <nl>  #endif <nl> -#ifdef CL_DEBUG <nl> +#if 0 /* too verbose, use #ifdef CL_DEBUG if needed */ <nl>  #define CHECK_UNREACHABLE do { cli_dbgmsg("bytecode: unreachable executed!\n"); return CL_EBYTECODE; } while(0) <nl>  #define TRACE_PTR(ptr, s) cli_dbgmsg("bytecode trace: ptr %llx, +%x\n", ptr, s); <nl>  #define TRACE_R(x) cli_dbgmsg("bytecode trace: %u, read %llx\n", pc, (long long)x); <nl> @@ -153,7 +153,7 @@ static always_inline void* cli_stack_alloc(struct stack *stack, unsigned bytes) <nl>      /* not enough room here, allocate new chunk */ <nl>      chunk = cli_malloc(sizeof(*stack->chunk)); <nl>      if (!chunk) { <nl> -        cli_warnmsg("cli_stack_alloc: Unable to allocate memory for stack-chunk: bytes: %u!\n", sizeof(*stack->chunk)); <nl> +        cli_warnmsg("cli_stack_alloc: Unable to allocate memory for stack-chunk: bytes: %zu!\n", sizeof(*stack->chunk)); <nl>          return NULL; <nl>      } <nl>  
@@ -52,12 +52,11 @@ static	char	const	rcsid[] = "$Id: uuencode.c,v 1.8 2006/12/11 11:55:11 njh Exp $ <nl>  int <nl>  cli_uuencode(const char *dir, fmap_t *map) <nl>  { <nl> -	int i; <nl>  	message *m; <nl>  	char buffer[RFC2821LENGTH + 1]; <nl>  	size_t at = 0; <nl>   <nl> -	if(fmap_gets(map, buffer, &at, sizeof(buffer) - 1)) { <nl> +	if(!fmap_gets(map, buffer, &at, sizeof(buffer) - 1)) { <nl>  		/* empty message */ <nl>  		return CL_CLEAN; <nl>  	}
@@ -524,6 +524,10 @@ static int cabd_read_headers(struct mspack_system *sys, <nl>      } <nl>      else { <nl>          /* ignore invalid file and continue parsing */ <nl> +        if (file->filename) { <nl> +          sys->free(file->filename); <nl> +          file->filename = NULL; <nl> +        } <nl>          sys->free(file); <nl>          sys->message(fh, "WARNING; omitting file %d of %d from file list", i, num_files); <nl>      }
@@ -172,6 +172,7 @@ static int multiscan(const char *dirname, const struct cl_node *root, const stru <nl>  				closedir(dd); <nl>  				return -1; <nl>  			    } <nl> +			    free(fname); <nl>  			} else { <nl>  			    if(S_ISREG(statbuf.st_mode) || (S_ISLNK(statbuf.st_mode) && (checksymlink(fname) == 2) && cfgopt(copt, "FollowFileSymlinks")->enabled)) { <nl>   <nl> @@ -212,6 +213,8 @@ static int multiscan(const char *dirname, const struct cl_node *root, const stru <nl>  				} <nl>  			    } <nl>  			} <nl> +		    } else { <nl> +			free(fname); <nl>  		    } <nl>  		} <nl>  	    }
@@ -260,8 +260,10 @@ char *pdf_finalize_string(struct pdf_struct *pdf, struct pdf_obj *obj, const cha <nl>      /* TODO: replace the escape sequences directly in the wrkstr   */ <nl>      if (strchr(wrkstr, '\\')) { <nl>          output = cli_calloc(wrklen+1, sizeof(char)); <nl> -        if (!output) <nl> +        if (!output) { <nl> +            free(wrkstr); <nl>              return NULL; <nl> +        } <nl>   <nl>          outlen = 0; <nl>          for (i = 0; i < wrklen; ++i) {
@@ -2490,7 +2490,7 @@ expand_plus_plus(xmlNode * target, const char *name, const char *value) <nl>      int_value += offset; <nl>   <nl>      if (int_value > INFINITY) { <nl> -        int_value = INFINITY; <nl> +        int_value = (int)INFINITY; <nl>      } <nl>   <nl>      crm_xml_add_int(target, name, int_value);
@@ -519,6 +519,10 @@ get_rsc_restart_list(lrmd_rsc_info_t * rsc, lrmd_event_data_t * op) <nl>          key = NULL; <nl>          reload->metadata = get_rsc_metadata(rsc->type, rsc->class, provider); <nl>   <nl> +        if(reload->metadata == NULL) { <nl> +            goto cleanup; <nl> +        } <nl> + <nl>          metadata = string2xml(reload->metadata); <nl>          if (metadata == NULL) { <nl>              crm_err("Metadata for %s::%s:%s is not valid XML",
@@ -1099,6 +1099,7 @@ stonith_cleanup(void) <nl>  static struct crm_option long_options[] = { <nl>      {"stand-alone",         0, 0, 's'}, <nl>      {"stand-alone-w-cpg",   0, 0, 'c'}, <nl> +    {"logfile",             1, 0, 'l'}, <nl>      {"verbose",     0, 0, 'V'}, <nl>      {"version",     0, 0, '$'}, <nl>      {"help",        0, 0, '?'}, <nl> @@ -1200,6 +1201,9 @@ main(int argc, char **argv) <nl>              case 'V': <nl>                  crm_bump_log_level(argc, argv); <nl>                  break; <nl> +            case 'l': <nl> +                crm_add_logfile(optarg); <nl> +                break; <nl>              case 's': <nl>                  stand_alone = TRUE; <nl>                  break;
@@ -211,6 +211,7 @@ typedef GList* GListPtr; <nl>   <nl>  #define do_crm_log(level, fmt, args...) do {				\ <nl>  		if(crm_log_level < (level)) {				\ <nl> +			continue;					\ <nl>  		} else if(level > LOG_DEBUG) {				\ <nl>  			cl_log(LOG_DEBUG, "debug%d: %s: " fmt,		\ <nl>  			       level-LOG_INFO, __PRETTY_FUNCTION__, ##args); \
@@ -1928,7 +1928,7 @@ expand_list(GListPtr list, char **rsc_list, char **node_list) <nl>   <nl>              crm_trace("Adding %s (%dc) at offset %d", rsc_id, len - 2, existing_len); <nl>              *rsc_list = realloc_safe(*rsc_list, len + existing_len); <nl> -            sprintf(*rsc_list + existing_len, "%s ", rsc_id); <nl> +            sprintf(*rsc_list + existing_len, "%s%s", existing_len == 0 ? "":" ", rsc_id); <nl>          } <nl>   <nl>          if (entry->node != NULL) { <nl> @@ -1945,7 +1945,7 @@ expand_list(GListPtr list, char **rsc_list, char **node_list) <nl>   <nl>              crm_trace("Adding %s (%dc) at offset %d", uname, len - 2, existing_len); <nl>              *node_list = realloc_safe(*node_list, len + existing_len); <nl> -            sprintf(*node_list + existing_len, "%s ", uname); <nl> +            sprintf(*node_list + existing_len, "%s%s", existing_len == 0 ? "":" ", uname); <nl>          } <nl>      } <nl>  
@@ -57,7 +57,6 @@ resource_ipc_connection_destroy(gpointer user_data) <nl>      crm_exit(1); <nl>  } <nl>   <nl> -static bool mainloop_running = FALSE; <nl>  static void <nl>  start_mainloop(void) <nl>  { <nl> @@ -65,7 +64,6 @@ start_mainloop(void) <nl>          return; <nl>      } <nl>   <nl> -    mainloop_running = TRUE; <nl>      mainloop = g_main_new(FALSE); <nl>      fprintf(stderr, "Waiting for %d replies from the CRMd", crmd_replies_needed); <nl>      crm_debug("Waiting for %d replies from the CRMd", crmd_replies_needed); <nl> @@ -83,7 +81,7 @@ resource_ipc_callback(const char *buffer, ssize_t length, gpointer userdata) <nl>      crm_log_xml_trace(msg, "[inbound]"); <nl>   <nl>      crmd_replies_needed--; <nl> -    if (crmd_replies_needed == 0 && mainloop_running) { <nl> +    if (crmd_replies_needed == 0 && g_main_loop_is_running(mainloop)) { <nl>          fprintf(stderr, " OK\n"); <nl>          crm_debug("Got all the replies we expected"); <nl>          return crm_exit(pcmk_ok);
@@ -142,12 +142,12 @@ main(int argc, char ** argv) <nl>  		usage(crm_system_name,LSB_EXIT_GENERIC); <nl>  	} <nl>   <nl> -	crm_debug("Init server comms"); <nl>  	if(ipc_server == NULL) { <nl>  		ipc_server = crm_strdup(CRM_SYSTEM_PENGINE); <nl>  	} <nl>   <nl>  	/* find any previous instances and shut them down */ <nl> +	crm_debug("Checking for old instances of %s", crm_system_name); <nl>  	old_instance = init_client_ipc_comms_nodispatch(CRM_SYSTEM_PENGINE); <nl>  	while(old_instance != NULL) { <nl>  	    xmlNode *cmd = create_request( <nl> @@ -163,6 +163,7 @@ main(int argc, char ** argv) <nl>  	    old_instance = init_client_ipc_comms_nodispatch(CRM_SYSTEM_PENGINE); <nl>  	} <nl>  	 <nl> +	crm_debug("Init server comms"); <nl>  	if(init_server_ipc_comms(ipc_server, pe_client_connect, <nl>  				 default_ipc_connection_destroy)) { <nl>  	    crm_err("Couldn't start IPC server");
@@ -233,6 +233,7 @@ update_attr(cib_t *the_cib, int call_options, <nl>  		CRM_CHECK(set_name != NULL, return cib_missing); <nl>  		 <nl>  		if(attr_value == NULL) { <nl> +			free_xml(xml_obj); <nl>  			return cib_missing_data; <nl>  		} <nl>  		 <nl> @@ -267,6 +268,7 @@ update_attr(cib_t *the_cib, int call_options, <nl>  		xml_obj = create_xml_node(xml_obj, XML_TAG_ATTRS); <nl>  		crm_free(local_set_name); <nl>  	} else { <nl> +		free_xml(xml_obj); <nl>  		xml_obj = NULL; <nl>  	} <nl>  
@@ -751,7 +751,7 @@ __subtract_xml_object(xmlNode * target, xmlNode * patch) <nl>      xmlNode *target_child = NULL; <nl>      xmlAttrPtr xIter = NULL; <nl>   <nl> -    const char *id = NULL; <nl> +    char *id = NULL; <nl>      const char *name = NULL; <nl>      const char *value = NULL; <nl>   <nl> @@ -765,17 +765,18 @@ __subtract_xml_object(xmlNode * target, xmlNode * patch) <nl>          subtract_xml_comment(target->parent, target, patch, &dummy); <nl>      } <nl>   <nl> -    id = ID(target); <nl>      name = crm_element_name(target); <nl>      CRM_CHECK(name != NULL, return); <nl>      CRM_CHECK(safe_str_eq(crm_element_name(target), crm_element_name(patch)), return); <nl>      CRM_CHECK(safe_str_eq(ID(target), ID(patch)), return); <nl>   <nl>      /* check for XML_DIFF_MARKER in a child */ <nl> +    id = crm_element_value_copy(target, XML_ATTR_ID); <nl>      value = crm_element_value(patch, XML_DIFF_MARKER); <nl>      if (value != NULL && strcmp(value, "removed:top") == 0) { <nl>          crm_trace("We are the root of the deletion: %s.id=%s", name, id); <nl>          free_xml(target); <nl> +        free(id); <nl>          return; <nl>      } <nl>   <nl> @@ -800,6 +801,7 @@ __subtract_xml_object(xmlNode * target, xmlNode * patch) <nl>   <nl>          __subtract_xml_object(target_child, patch_child); <nl>      } <nl> +    free(id); <nl>  } <nl>   <nl>  static void
@@ -2042,7 +2042,7 @@ complex_migrate_reload(resource_t *rsc, pe_working_set_t *data_set) <nl>  			if(other->optional || other->rsc != NULL) { <nl>  			    continue; <nl>  			} <nl> -			crm_err("Ordering %s before %s (stop)", start->uuid, other_w->action->uuid); <nl> +			crm_debug("Ordering %s before %s (stop)", start->uuid, other_w->action->uuid); <nl>  			order_actions(start, other, other_w->type); <nl>  		    ); <nl>   <nl> @@ -2055,7 +2055,7 @@ complex_migrate_reload(resource_t *rsc, pe_working_set_t *data_set) <nl>  			} else if(other->optional || other->rsc == rsc || other->rsc == rsc->parent) { <nl>  			    continue; <nl>  			} <nl> -			crm_err("Ordering %s before %s (start)", other_w->action->uuid, stop->uuid); <nl> +			crm_debug("Ordering %s before %s (start)", other_w->action->uuid, stop->uuid); <nl>  			order_actions(other, stop, other_w->type); <nl>  		    ); <nl>  		
@@ -121,7 +121,8 @@ int main(int argc, char *argv[]) <nl>      QString locale = QLocale::system().name(); <nl>      QTranslator translator; <nl>      translator.load(":/translations/"+locale); <nl> -    app.installTranslator(&translator); <nl> +    if (!translator.isEmpty()) <nl> +        app.installTranslator(&translator); <nl>   <nl>      QSplashScreen splash(QPixmap(":/images/splash"), 0); <nl>      splash.show();
@@ -155,11 +155,12 @@ SendCoinsRecipient SendCoinsEntry::getValue() <nl>  QWidget *SendCoinsEntry::setupTabChain(QWidget *prev) <nl>  { <nl>      QWidget::setTabOrder(prev, ui->payTo); <nl> -    QWidget::setTabOrder(ui->payTo, ui->addressBookButton); <nl> +    QWidget::setTabOrder(ui->payTo, ui->addAsLabel); <nl> +    QWidget *w = ui->payAmount->setupTabChain(ui->addAsLabel); <nl> +    QWidget::setTabOrder(w, ui->addressBookButton); <nl>      QWidget::setTabOrder(ui->addressBookButton, ui->pasteButton); <nl>      QWidget::setTabOrder(ui->pasteButton, ui->deleteButton); <nl> -    QWidget::setTabOrder(ui->deleteButton, ui->addAsLabel); <nl> -    return ui->payAmount->setupTabChain(ui->addAsLabel); <nl> +    return ui->deleteButton; <nl>  } <nl>   <nl>  void SendCoinsEntry::setValue(const SendCoinsRecipient &value)
@@ -2347,6 +2347,16 @@ static int merge_check_workdir(size_t *conflicts, git_repository *repo, git_inde <nl>   <nl>  	*conflicts = 0; <nl>   <nl> +	/* We need to have merged at least 1 file for the possibility to exist to <nl> +	 * have conflicts with the workdir. Passing 0 as the pathspec count paramter <nl> +	 * will consider all files in the working directory, that is, we may detect <nl> +	 * a conflict if there were untracked files in the workdir prior to starting <nl> +	 * the merge. This typically happens when cherry-picking a commmit whose <nl> +	 * changes have already been applied. <nl> +	 */ <nl> +	if (merged_paths->length == 0) <nl> +		return 0; <nl> + <nl>  	opts.flags |= GIT_DIFF_INCLUDE_UNTRACKED; <nl>   <nl>  	/* Workdir changes may exist iff they do not conflict with changes that
@@ -110,6 +110,7 @@ int git_branch_delete(git_repository *repo, const char *branch_name, git_branch_ <nl>  	git_reference *head = NULL; <nl>  	int error; <nl>   <nl> +	assert(repo && branch_name); <nl>  	assert((branch_type == GIT_BRANCH_LOCAL) || (branch_type == GIT_BRANCH_REMOTE)); <nl>   <nl>  	if ((error = retrieve_branch_reference(&branch, repo, branch_name, branch_type == GIT_BRANCH_REMOTE)) < 0)
@@ -23,6 +23,8 @@ static int run_command(git_cb fn, int argc, char **argv) <nl>  	int error; <nl>  	git_repository *repo; <nl>   <nl> +	git_libgit2_init(); <nl> + <nl>  // Before running the actual command, create an instance of the local <nl>  // repository and pass it to the function. <nl>   <nl> @@ -42,6 +44,8 @@ static int run_command(git_cb fn, int argc, char **argv) <nl>  	if(repo) <nl>  		git_repository_free(repo); <nl>   <nl> +	git_libgit2_shutdown(); <nl> + <nl>  	return !!error; <nl>  } <nl>   <nl> @@ -54,8 +58,6 @@ int main(int argc, char **argv) <nl>  		exit(EXIT_FAILURE); <nl>  	} <nl>   <nl> -	git_libgit2_init(); <nl> - <nl>  	for (i = 0; commands[i].name != NULL; ++i) { <nl>  		if (!strcmp(argv[1], commands[i].name)) <nl>  			return run_command(commands[i].fn, --argc, ++argv);
@@ -188,6 +188,7 @@ void git_index_free(git_index *index) <nl>   <nl>  	git_index_clear(index); <nl>  	git_vector_free(&index->entries); <nl> +	git_vector_free(&index->unmerged); <nl>   <nl>  	free(index->index_file_path); <nl>  	free(index); <nl> @@ -221,7 +222,15 @@ void git_index_clear(git_index *index) <nl>  		free(e); <nl>  	} <nl>   <nl> +	for (i = 0; i < index->unmerged.length; ++i) { <nl> +		git_index_entry_unmerged *e; <nl> +		e = git_vector_get(&index->unmerged, i); <nl> +		free((char *)e->path); <nl> +		free(e); <nl> +	} <nl> + <nl>  	git_vector_clear(&index->entries); <nl> +	git_vector_clear(&index->unmerged); <nl>  	index->last_modified = 0; <nl>   <nl>  	free_tree(index->tree);
@@ -602,13 +602,12 @@ static int http_connect(http_subtransport *t) <nl>  	if ((!error || error == GIT_ECERTIFICATE) && t->owner->certificate_check_cb != NULL && <nl>  	    git_stream_is_encrypted(t->io)) { <nl>  		git_cert *cert; <nl> -		int is_valid; <nl> +		int is_valid = (error == GIT_OK); <nl>   <nl>  		if ((error = git_stream_certificate(&cert, t->io)) < 0) <nl>  			return error; <nl>   <nl>  		giterr_clear(); <nl> -		is_valid = error != GIT_ECERTIFICATE; <nl>  		error = t->owner->certificate_check_cb(cert, is_valid, t->connection_data.host, t->owner->message_cb_payload); <nl>   <nl>  		if (error < 0) {
@@ -21,7 +21,8 @@ uint32_t git_pool__system_page_size(void) <nl>  		size_t page_size; <nl>  		if (git__page_size(&page_size) < 0) <nl>  			page_size = 4096; <nl> -		size = page_size - 2 * sizeof(void *); /* allow space for malloc overhead */ <nl> +		/* allow space for malloc overhead */ <nl> +		size = page_size - (2 * sizeof(void *)) - sizeof(git_pool_page); <nl>  	} <nl>   <nl>  	return size;
@@ -571,7 +571,9 @@ cmsPipeline* DefaultICCintents(cmsContext       ContextID, <nl>          // Concatenate to the output LUT <nl>          if (!cmsPipelineCat(Result, Lut)) <nl>              goto Error; <nl> + <nl>          cmsPipelineFree(Lut); <nl> +        Lut = NULL; <nl>   <nl>          // Update current space <nl>          CurrentColorSpace = ColorSpaceOut; <nl> @@ -581,7 +583,7 @@ cmsPipeline* DefaultICCintents(cmsContext       ContextID, <nl>   <nl>  Error: <nl>   <nl> -    cmsPipelineFree(Lut); <nl> +    if (Lut != NULL) cmsPipelineFree(Lut); <nl>      if (Result != NULL) cmsPipelineFree(Result); <nl>      return NULL; <nl>  
@@ -24,6 +24,10 @@ const char *make_absolute_path(const char *path) <nl>  	char *last_elem = NULL; <nl>  	struct stat st; <nl>   <nl> +	/* We've already done it */ <nl> +	if (path == buf || path == next_buf) <nl> +		return path; <nl> + <nl>  	if (strlcpy(buf, path, PATH_MAX) >= PATH_MAX) <nl>  		die ("Too long path: %.*s", 60, path); <nl>  
@@ -352,6 +352,9 @@ int run_hook(const char *index_file, const char *name, ...) <nl>  	int ret; <nl>  	int i; <nl>   <nl> +	if (access(git_path("hooks/%s", name), X_OK) < 0) <nl> +		return 0; <nl> + <nl>  	va_start(args, name); <nl>  	argv[0] = git_path("hooks/%s", name); <nl>  	i = 0; <nl> @@ -362,9 +365,6 @@ int run_hook(const char *index_file, const char *name, ...) <nl>  	} while (argv[i]); <nl>  	va_end(args); <nl>   <nl> -	if (access(argv[0], X_OK) < 0) <nl> -		return 0; <nl> - <nl>  	memset(&hook, 0, sizeof(hook)); <nl>  	hook.argv = argv; <nl>  	hook.no_stdin = 1;
@@ -226,10 +226,11 @@ static struct commit_list *best_bisection_sorted(struct commit_list *list, int n <nl>  		add_name_decoration(DECORATION_NONE, buf.buf, obj); <nl>   <nl>  		p->item = array[i].commit; <nl> -		p = p->next; <nl> +		if (i < cnt - 1) <nl> +			p = p->next; <nl>  	} <nl> -	if (p) <nl> -		p->next = NULL; <nl> +	free_commit_list(p->next); <nl> +	p->next = NULL; <nl>  	strbuf_release(&buf); <nl>  	free(array); <nl>  	return list;
@@ -362,7 +362,8 @@ static int do_recursive_merge(struct commit *base, struct commit *next, <nl>  	if (active_cache_changed && <nl>  	    (write_cache(index_fd, active_cache, active_nr) || <nl>  	     commit_locked_index(&index_lock))) <nl> -		die("%s: Unable to write new index file", me); <nl> +		/* TRANSLATORS: %s will be "revert" or "cherry-pick" */ <nl> +		die(_("%s: Unable to write new index file"), me); <nl>  	rollback_lock_file(&index_lock); <nl>   <nl>  	if (!clean) { <nl> @@ -469,7 +470,9 @@ static int do_pick_commit(void) <nl>  		return fast_forward_to(commit->object.sha1, head); <nl>   <nl>  	if (parent && parse_commit(parent) < 0) <nl> -		die("%s: cannot parse parent commit %s", <nl> +		/* TRANSLATORS: The first %s will be "revert" or <nl> +		   "cherry-pick", the second %s a SHA1 */ <nl> +		die(_("%s: cannot parse parent commit %s"), <nl>  		    me, sha1_to_hex(parent->object.sha1)); <nl>   <nl>  	if (get_message(commit->buffer, &msg) != 0)
@@ -49,13 +49,14 @@ static inline int is_merge(void) <nl>  	return !access(git_path("MERGE_HEAD"), F_OK); <nl>  } <nl>   <nl> -static int reset_index_file(const unsigned char *sha1, int is_hard_reset) <nl> +static int reset_index_file(const unsigned char *sha1, int is_hard_reset, int quiet) <nl>  { <nl>  	int i = 0; <nl>  	const char *args[6]; <nl>   <nl>  	args[i++] = "read-tree"; <nl> -	args[i++] = "-v"; <nl> +	if (!quiet) <nl> +		args[i++] = "-v"; <nl>  	args[i++] = "--reset"; <nl>  	if (is_hard_reset) <nl>  		args[i++] = "-u"; <nl> @@ -182,7 +183,7 @@ int cmd_reset(int argc, const char **argv, const char *prefix) <nl>  		OPT_SET_INT(0, "hard", &reset_type, <nl>  				"reset HEAD, index and working tree", HARD), <nl>  		OPT_BOOLEAN('q', NULL, &quiet, <nl> -				"disable showing new HEAD in hard reset"), <nl> +				"disable showing new HEAD in hard reset and progress message"), <nl>  		OPT_END() <nl>  	}; <nl>   <nl> @@ -231,7 +232,7 @@ int cmd_reset(int argc, const char **argv, const char *prefix) <nl>  		if (is_merge() || read_cache() < 0 || unmerged_cache()) <nl>  			die("Cannot do a soft reset in the middle of a merge."); <nl>  	} <nl> -	else if (reset_index_file(sha1, (reset_type == HARD))) <nl> +	else if (reset_index_file(sha1, (reset_type == HARD), quiet)) <nl>  		die("Could not reset index file to revision '%s'.", rev); <nl>   <nl>  	/* Any resets update HEAD to the head being switched to,
@@ -65,6 +65,7 @@ static struct oidset gitmodules_done = OIDSET_INIT; <nl>  	FUNC(GITMODULES_NAME, ERROR) \ <nl>  	FUNC(GITMODULES_SYMLINK, ERROR) \ <nl>  	FUNC(GITMODULES_URL, ERROR) \ <nl> +	FUNC(GITMODULES_PATH, ERROR) \ <nl>  	/* warnings */ \ <nl>  	FUNC(BAD_FILEMODE, WARN) \ <nl>  	FUNC(EMPTY_NAME, WARN) \ <nl> @@ -952,6 +953,12 @@ static int fsck_gitmodules_fn(const char *var, const char *value, void *vdata) <nl>  				    FSCK_MSG_GITMODULES_URL, <nl>  				    "disallowed submodule url: %s", <nl>  				    value); <nl> +	if (!strcmp(key, "path") && value && <nl> +	    looks_like_command_line_option(value)) <nl> +		data->ret |= report(data->options, data->obj, <nl> +				    FSCK_MSG_GITMODULES_PATH, <nl> +				    "disallowed submodule path: %s", <nl> +				    value); <nl>  	free(name); <nl>   <nl>  	return 0;
@@ -1231,7 +1231,7 @@ static void setup_progress_signal(void) <nl>  int main(int argc, char **argv) <nl>  { <nl>  	SHA_CTX ctx; <nl> -	char line[PATH_MAX + 20]; <nl> +	char line[40 + 1 + PATH_MAX + 2]; <nl>  	int window = 10, depth = 10, pack_to_stdout = 0; <nl>  	struct object_entry **list; <nl>  	int num_preferred_base = 0;
@@ -1082,7 +1082,6 @@ struct http_pack_request *new_http_pack_request( <nl>  	return preq; <nl>   <nl>  abort: <nl> -	free(filename); <nl>  	free(preq->url); <nl>  	free(preq); <nl>  	return NULL;
@@ -2405,6 +2405,9 @@ int main(int argc, const char **argv) <nl>   <nl>  	git_extract_argv0_path(argv[0]); <nl>   <nl> +	if (argc == 2 && !strcmp(argv[1], "-h")) <nl> +		usage(fast_import_usage); <nl> + <nl>  	setup_git_directory(); <nl>  	git_config(git_pack_config, NULL); <nl>  	if (!pack_compression_seen && core_compression_seen)
@@ -229,10 +229,9 @@ static int add_excludes_from_file_1(const char *fname, <nl>   <nl>  	if (buf_p) <nl>  		*buf_p = buf; <nl> -	buf[size++] = '\n'; <nl>  	entry = buf; <nl> -	for (i = 0; i < size; i++) { <nl> -		if (buf[i] == '\n') { <nl> +	for (i = 0; i <= size; i++) { <nl> +		if (i == size || buf[i] == '\n') { <nl>  			if (entry != buf + i && entry[0] != '#') { <nl>  				buf[i - (i && buf[i-1] == '\r')] = 0; <nl>  				add_exclude(entry, base, baselen, which);
@@ -37,6 +37,9 @@ static void prune_directory(struct dir_struct *dir, const char **pathspec, int p <nl>  			free(entry); <nl>  			continue; <nl>  		} <nl> +		if (entry->ignored_entry) <nl> +			fprintf(stderr, "warning: '%s' is an ignored path.\n", <nl> +				entry->name); <nl>  		*dst++ = entry; <nl>  	} <nl>  	dir->nr = dst - dir->entries;
@@ -583,6 +583,9 @@ static int write_pseudoref(const char *pseudoref, const struct object_id *oid, <nl>  	struct strbuf buf = STRBUF_INIT; <nl>  	int ret = -1; <nl>   <nl> +	if (!oid) <nl> +		return 0; <nl> + <nl>  	strbuf_addf(&buf, "%s\n", oid_to_hex(oid)); <nl>   <nl>  	filename = git_path("%s", pseudoref);
@@ -354,7 +354,7 @@ static int cmd_log(int argc, const char **argv, char **envp) <nl>  	prepare_revision_walk(&rev); <nl>  	setup_pager(); <nl>  	while ((commit = get_revision(&rev)) != NULL) { <nl> -		if (commit_format != CMIT_FMT_ONELINE && shown) <nl> +		if (shown && do_diff && commit_format != CMIT_FMT_ONELINE) <nl>  			putchar('\n'); <nl>  		fputs(commit_prefix, stdout); <nl>  		if (abbrev_commit && abbrev)
@@ -3832,7 +3832,7 @@ static const char *diff_abbrev_oid(const struct object_id *oid, int abbrev) <nl>  		char *hex = oid_to_hex(oid); <nl>  		if (abbrev < 0) <nl>  			abbrev = FALLBACK_DEFAULT_ABBREV; <nl> -		if (abbrev > GIT_SHA1_HEXSZ) <nl> +		if (abbrev > the_hash_algo->hexsz) <nl>  			BUG("oid abbreviation out of range: %d", abbrev); <nl>  		if (abbrev) <nl>  			hex[abbrev] = '\0'; <nl> @@ -4947,7 +4947,7 @@ const char *diff_aligned_abbrev(const struct object_id *oid, int len) <nl>  	const char *abbrev; <nl>   <nl>  	/* Do we want all 40 hex characters? */ <nl> -	if (len == GIT_SHA1_HEXSZ) <nl> +	if (len == the_hash_algo->hexsz) <nl>  		return oid_to_hex(oid); <nl>   <nl>  	/* An abbreviated value is fine, possibly followed by an ellipsis. */ <nl> @@ -4977,7 +4977,7 @@ const char *diff_aligned_abbrev(const struct object_id *oid, int len) <nl>  	 * the automatic sizing is supposed to give abblen that ensures <nl>  	 * uniqueness across all objects (statistically speaking). <nl>  	 */ <nl> -	if (abblen < GIT_SHA1_HEXSZ - 3) { <nl> +	if (abblen < the_hash_algo->hexsz - 3) { <nl>  		static char hex[GIT_MAX_HEXSZ + 1]; <nl>  		if (len < abblen && abblen <= len + 2) <nl>  			xsnprintf(hex, sizeof(hex), "%s%.*s", abbrev, len+3-abblen, "..");
@@ -964,6 +964,12 @@ char *get_relative_cwd(char *buffer, int size, const char *dir) <nl>  	case '/': <nl>  		return cwd + 1; <nl>  	default: <nl> +		/* <nl> +		 * dir can end with a path separator when it's root <nl> +		 * directory. Return proper prefix in that case. <nl> +		 */ <nl> +		if (dir[-1] == '/') <nl> +			return cwd; <nl>  		return NULL; <nl>  	} <nl>  }
@@ -550,7 +550,6 @@ static int fetch_object(struct alt_base *repo, unsigned char *sha1) <nl>  	curl_result = curl_easy_perform(curl); <nl>  	curl_easy_setopt(curl, CURLOPT_HTTPHEADER, no_range_header); <nl>  	if (curl_result != 0) { <nl> -		unlink(tmpfile); <nl>  		return error("%s", curl_errorstr); <nl>  	} <nl>  
@@ -382,6 +382,9 @@ static void imapc_connection_set_state(struct imapc_connection *conn, <nl>   <nl>  		conn->selecting_box = NULL; <nl>  		conn->selected_box = NULL; <nl> + <nl> +		i_free(conn->ips); <nl> +		conn->ips_count = 0; <nl>  		break; <nl>  	default: <nl>  		break;
@@ -47,6 +47,9 @@ void main_unref(void) <nl>  		/* last login finished, close all communications <nl>  		   to master process */ <nl>  		master_close(); <nl> +		/* we might still be proxying. close the connection to <nl> +		   dovecot-auth, since it's not needed anymore. */ <nl> +		auth_client_free(&auth_client); <nl>  	} <nl>  } <nl>   <nl> @@ -336,7 +339,8 @@ static void main_deinit(void) <nl>  	ssl_proxy_deinit(); <nl>  	login_proxy_deinit(); <nl>   <nl> -	auth_client_free(&auth_client); <nl> +	if (auth_client != NULL) <nl> +		auth_client_free(&auth_client); <nl>  	clients_deinit(); <nl>  	master_deinit(); <nl>  
@@ -401,6 +401,11 @@ imapc_sync_send_commands(struct imapc_sync_context *ctx, uint32_t first_uid) <nl>  { <nl>  	string_t *cmd = t_str_new(64); <nl>   <nl> +	if (ctx->mbox->exists_count == 0) { <nl> +		/* empty mailbox - no point in fetching anything */ <nl> +		return; <nl> +	} <nl> + <nl>  	str_printfa(cmd, "UID FETCH %u:* (FLAGS", first_uid); <nl>  	if (imapc_mailbox_has_modseqs(ctx->mbox)) { <nl>  		str_append(cmd, " MODSEQ");
@@ -17,6 +17,8 @@ static void o_stream_metawrap_call_callback(struct metawrap_ostream *mstream) <nl>  	if (write_callback != NULL) { <nl>  		mstream->write_callback = NULL; <nl>  		write_callback(mstream->context); <nl> +		/* metadata headers aren't counted as part of the offset */ <nl> +		mstream->ostream.ostream.offset = 0; <nl>  	} <nl>  } <nl>  
@@ -306,6 +306,13 @@ mail_transaction_log_refresh(struct mail_transaction_log *log, bool nfs_flush) <nl>  							  "stat()"); <nl>  			return -1; <nl>  		} <nl> +		/* see if the whole directory got deleted */ <nl> +		if (nfs_safe_stat(log->index->dir, &st) < 0 && <nl> +		    errno == ENOENT) { <nl> +			log->index->index_deleted = TRUE; <nl> +			return -1; <nl> +		} <nl> + <nl>  		/* the file should always exist at this point. if it doesn't, <nl>  		   someone deleted it manually while the index was open. try to <nl>  		   handle this nicely by creating a new log file. */
@@ -287,6 +287,10 @@ static int dbox_sync_index_rebuild_dir(struct dbox_sync_rebuild_context *ctx, <nl>  	dir = opendir(path); <nl>  	if (dir == NULL) { <nl>  		if (errno == ENOENT) { <nl> +			if (!primary) { <nl> +				/* alt directory doesn't exist, ignore */ <nl> +				return 0; <nl> +			} <nl>  			mailbox_set_deleted(&ctx->mbox->ibox.box); <nl>  			return -1; <nl>  		}
@@ -1374,7 +1374,7 @@ void imapc_connection_connect(struct imapc_connection *conn, <nl>  	unsigned int ips_count; <nl>  	int ret; <nl>   <nl> -	if (conn->fd != -1) { <nl> +	if (conn->fd != -1 || conn->dns_lookup != NULL) { <nl>  		i_assert(login_callback == NULL); <nl>  		return; <nl>  	}
@@ -183,6 +183,7 @@ static const char *find_next_secret(const char *input, const char **secret_r) <nl>  { <nl>  	const char *const *secret; <nl>  	const char *ptr = NULL; <nl> +	*secret_r = NULL; <nl>  	for(secret = secrets; *secret != NULL; secret++) { <nl>  		const char *cptr; <nl>  		if ((cptr = strstr(input, *secret)) != NULL) { <nl> @@ -192,6 +193,7 @@ static const char *find_next_secret(const char *input, const char **secret_r) <nl>  			} <nl>  		} <nl>  	} <nl> +	i_assert(*secret_r != NULL || ptr == NULL); <nl>  	return ptr; <nl>  } <nl>  
@@ -364,7 +364,7 @@ static int mail_modifylog_open_and_verify(MailModifyLog *log, const char *path) <nl>  		(void)unlink(path); <nl>  	} <nl>   <nl> -	if (ret != -1 && hdr.indexid != log->index->indexid) { <nl> +	if (ret > 0 && hdr.indexid != log->index->indexid) { <nl>  		index_set_error(log->index, "IndexID mismatch for modify log " <nl>  				"file %s", path); <nl>  		ret = -1; <nl> @@ -373,12 +373,12 @@ static int mail_modifylog_open_and_verify(MailModifyLog *log, const char *path) <nl>  		(void)unlink(path); <nl>  	} <nl>   <nl> -	if (ret != -1 && hdr.sync_id == SYNC_ID_FULL) { <nl> +	if (ret > 0 && hdr.sync_id == SYNC_ID_FULL) { <nl>  		/* full */ <nl>  		ret = 0; <nl>  	} <nl>   <nl> -	if (ret == 1) { <nl> +	if (ret > 0) { <nl>  		log->fd = fd; <nl>  		log->filepath = i_strdup(path); <nl>  	} else {
@@ -582,6 +582,9 @@ static bool pop3_uidl_assign_by_size(struct mailbox *box) <nl>  	struct imap_msg_map *imap_map; <nl>  	unsigned int i, pop3_count, imap_count, count; <nl>   <nl> +	if (mstorage->skip_size_check) <nl> +		return FALSE; <nl> + <nl>  	pop3_map = array_get_modifiable(&mstorage->pop3_uidl_map, &pop3_count); <nl>  	imap_map = array_get_modifiable(&mbox->imap_msg_map, &imap_count); <nl>  	count = I_MIN(pop3_count, imap_count);
@@ -808,7 +808,7 @@ int mailbox_list_get_storage(struct mailbox_list **list, const char *vname, <nl>  		return (*list)->v.get_storage(list, vname, storage_r); <nl>   <nl>  	set = mailbox_settings_find((*list)->ns->user, vname); <nl> -	if (set != NULL && set->driver[0] != '\0') { <nl> +	if (set != NULL && set->driver != NULL && set->driver[0] != '\0') { <nl>  		return mailbox_list_get_storage_driver(*list, set->driver, <nl>  						       storage_r); <nl>  	}
@@ -16,7 +16,7 @@ int imap_sync(struct client *client, struct mailbox *box, <nl>  	struct mail *mail; <nl>          const struct mail_full_flags *mail_flags; <nl>  	string_t *str; <nl> -	uint32_t seq; <nl> +	uint32_t seq, messages_count; <nl>   <nl>  	if (client->mailbox != box) { <nl>  		/* mailbox isn't selected - we only wish to sync the mailbox <nl> @@ -29,6 +29,7 @@ int imap_sync(struct client *client, struct mailbox *box, <nl>   <nl>  	t_push(); <nl>  	str = t_str_new(256); <nl> +	messages_count = client->messages_count; <nl>   <nl>  	t = mailbox_transaction_begin(box, FALSE); <nl>  	ctx = mailbox_sync_init(box, flags); <nl> @@ -50,6 +51,7 @@ int imap_sync(struct client *client, struct mailbox *box, <nl>  			} <nl>  			break; <nl>  		case MAILBOX_SYNC_TYPE_EXPUNGE: <nl> +			messages_count -= sync_rec.seq2 - sync_rec.seq1 + 1; <nl>  			for (seq = sync_rec.seq2; seq >= sync_rec.seq1; seq--) { <nl>  				str_truncate(str, 0); <nl>  				str_printfa(str, "* %u EXPUNGE", seq); <nl> @@ -67,8 +69,8 @@ int imap_sync(struct client *client, struct mailbox *box, <nl>   <nl>  	mailbox_transaction_commit(t); <nl>   <nl> -	if (status.messages != client->messages_count) { <nl> -                client->messages_count = status.messages; <nl> +	client->messages_count = status.messages; <nl> +	if (status.messages != messages_count) { <nl>  		str_truncate(str, 0); <nl>  		str_printfa(str, "* %u EXISTS", status.messages); <nl>  		client_send_line(client, str_c(str));
@@ -103,6 +103,7 @@ struct maildir_uidlist_sync_ctx { <nl>   <nl>  	unsigned int first_unwritten_pos, first_nouid_pos; <nl>  	unsigned int new_files_count; <nl> +	unsigned int finish_change_counter; <nl>   <nl>  	unsigned int partial:1; <nl>  	unsigned int finished:1; <nl> @@ -931,6 +932,7 @@ static int maildir_uidlist_write_fd(struct maildir_uidlist *uidlist, int fd, <nl>  	} <nl>   <nl>  	iter = maildir_uidlist_iter_init(uidlist); <nl> +	i_assert(first_idx <= array_count(&uidlist->records)); <nl>  	iter->next += first_idx; <nl>   <nl>  	while (maildir_uidlist_iter_next_rec(iter, &rec)) { <nl> @@ -1080,6 +1082,7 @@ static int maildir_uidlist_sync_update(struct maildir_uidlist_sync_ctx *ctx) <nl>   <nl>  	if (ctx->uidlist->recreate || uidlist->fd == -1 || <nl>  	    uidlist->version != 3 || <nl> +	    ctx->finish_change_counter != ctx->uidlist->change_counter || <nl>  	    (uidlist->read_records_count + ctx->new_files_count) * <nl>  	    UIDLIST_COMPRESS_PERCENTAGE / 100 >= array_count(&uidlist->records)) <nl>  		return maildir_uidlist_recreate(uidlist); <nl> @@ -1381,6 +1384,7 @@ static void maildir_uidlist_assign_uids(struct maildir_uidlist_sync_ctx *ctx) <nl>   <nl>          ctx->uidlist->last_seen_uid = ctx->uidlist->next_uid-1; <nl>  	ctx->uidlist->change_counter++; <nl> +	ctx->finish_change_counter = ctx->uidlist->change_counter; <nl>  } <nl>   <nl>  static void maildir_uidlist_swap(struct maildir_uidlist_sync_ctx *ctx) <nl> @@ -1409,9 +1413,9 @@ static void maildir_uidlist_swap(struct maildir_uidlist_sync_ctx *ctx) <nl>  	if (ctx->new_files_count != 0) { <nl>  		ctx->first_nouid_pos = count - ctx->new_files_count; <nl>  		maildir_uidlist_assign_uids(ctx); <nl> +	} else { <nl> +		ctx->uidlist->change_counter++; <nl>  	} <nl> - <nl> -	ctx->uidlist->change_counter++; <nl>  } <nl>   <nl>  void maildir_uidlist_sync_finish(struct maildir_uidlist_sync_ctx *ctx)
@@ -57,6 +57,8 @@ void io_loop_handler_init(struct ioloop *ioloop) <nl>  	data->fd_index = p_new(ioloop->pool, struct io_list *, data->idx_size); <nl>   <nl>  	data->epfd = epoll_create(INITIAL_EPOLL_EVENTS); <nl> +	if (data->epfd < 0) <nl> +		i_panic("epoll_create(): %m"); <nl>  } <nl>   <nl>  void io_loop_handler_deinit(struct ioloop *ioloop)
@@ -542,6 +542,9 @@ index_mail_body_parsed_cache_bodystructure(struct index_mail *mail, <nl>  		} <nl>  	} <nl>   <nl> +	if (!data->parsed_bodystructure) <nl> +		return; <nl> + <nl>  	/* If BODY is fetched first but BODYSTRUCTURE is also wanted, we don't <nl>  	   normally want to first cache BODY and then BODYSTRUCTURE. So check <nl>  	   the wanted_fields also in here. */
@@ -1394,6 +1394,8 @@ imapc_command_begin(imapc_command_callback_t *callback, void *context) <nl>  	struct imapc_command *cmd; <nl>  	pool_t pool; <nl>   <nl> +	i_assert(callback != NULL); <nl> + <nl>  	pool = pool_alloconly_create("imapc command", 2048); <nl>  	cmd = p_new(pool, struct imapc_command, 1); <nl>  	cmd->pool = pool;
@@ -70,7 +70,8 @@ ssize_t i_stream_decrypt_read_header_v1(struct decrypt_istream *stream, <nl>  	buffer_t *key = buffer_create_dynamic(pool_datastack_create(), 256); <nl>   <nl>  	hdr_len = ((data[0] << 8) | data[1]) + 12; <nl> -	if (mlen < hdr_len) { <nl> + <nl> +	if (mlen < hdr_len - pos) { <nl>  		/* try to read more */ <nl>  		return 0; <nl>  	}
@@ -92,6 +92,11 @@ void http_client_request_unref(struct http_client_request **_req) <nl>  	if (--req->refcount > 0) <nl>  		return; <nl>   <nl> +	if (req->destroy_callback != NULL) { <nl> +		req->destroy_callback(req->destroy_context); <nl> +		req->destroy_callback = NULL; <nl> +	} <nl> + <nl>  	/* only decrease pending request counter if this request was submitted */ <nl>  	if (req->state > HTTP_REQUEST_STATE_NEW) <nl>  		req->client->pending_requests--; <nl> @@ -541,9 +546,6 @@ void http_client_request_finish(struct http_client_request **_req) <nl>  	req->callback = NULL; <nl>  	req->state = HTTP_REQUEST_STATE_FINISHED; <nl>   <nl> -	if (req->destroy_callback != NULL) <nl> -		req->destroy_callback(req->destroy_context); <nl> - <nl>  	if (req->payload_wait && req->client->ioloop != NULL) <nl>  		io_loop_stop(req->client->ioloop); <nl>  	http_client_request_unref(_req);
@@ -892,6 +892,7 @@ int mailbox_get_guid(struct mailbox *box, uint8_t guid[MAIL_GUID_128_SIZE]) <nl>  	if (box->v.get_guid == NULL) { <nl>  		mail_storage_set_error(box->storage, MAIL_ERROR_NOTPOSSIBLE, <nl>  				       "Storage doesn't support mailbox GUIDs"); <nl> +		return -1; <nl>  	} <nl>  	if (!box->opened) { <nl>  		if (mailbox_open(box) < 0)
@@ -140,6 +140,7 @@ ssize_t i_stream_read(struct istream *stream) <nl>  			errno = stream->stream_errno; <nl>  		} else { <nl>  			i_assert(stream->eof); <nl> +			i_assert(old_size == _stream->pos - _stream->skip); <nl>  		} <nl>  		break; <nl>  	case 0:
@@ -43,6 +43,7 @@ fts_search_arg_create_or(const struct mail_search_arg *orig_arg, pool_t pool, <nl>  	array_foreach(tokens, tokenp) { <nl>  		arg = p_new(pool, struct mail_search_arg, 1); <nl>  		*arg = *orig_arg; <nl> +		arg->match_not = FALSE; /* we copied this to the parent SUB */ <nl>  		arg->next = NULL; <nl>  		arg->value.str = p_strdup(pool, *tokenp); <nl>  
@@ -186,6 +186,7 @@ void auth_client_request_abort(struct auth_client_request **_request) <nl>   <nl>  	auth_client_send_cancel(request->conn->client, request->id); <nl>  	call_callback(request, AUTH_REQUEST_STATUS_ABORT, NULL, NULL); <nl> +	pool_unref(&request->pool); <nl>  } <nl>   <nl>  unsigned int auth_client_request_get_id(struct auth_client_request *request)
@@ -101,7 +101,8 @@ raw_mail_get_special(struct mail *_mail, enum mail_fetch_field field, <nl>   <nl>  	switch (field) { <nl>  	case MAIL_FETCH_FROM_ENVELOPE: <nl> -		*value_r = mbox->envelope_sender; <nl> +		*value_r = mbox->envelope_sender != NULL ? <nl> +			mbox->envelope_sender : ""; <nl>  		return 0; <nl>  	case MAIL_FETCH_UIDL_FILE_NAME: <nl>  		*value_r = mbox->have_filename ?
@@ -96,7 +96,7 @@ void iostream_rawlog_write(struct rawlog_iostream *rstream, <nl>  		return; <nl>  	} <nl>   <nl> -	do { <nl> +	while (rstream->rawlog_fd != -1 && size > 0) { <nl>  		p = memchr(data, '\n', size); <nl>  		if (p != NULL) { <nl>  			line_ends = TRUE; <nl> @@ -118,7 +118,7 @@ void iostream_rawlog_write(struct rawlog_iostream *rstream, <nl>   <nl>  		data += pos; <nl>  		size -= pos; <nl> -	} while (size > 0); <nl> +	} <nl>  } <nl>   <nl>  void iostream_rawlog_close(struct rawlog_iostream *rstream)
@@ -77,6 +77,9 @@ int mail_cache_expunge_handler(struct mail_index_sync_map_ctx *sync_ctx, <nl>  	if (*cache_offset == 0) <nl>  		return 1; <nl>   <nl> +	if (MAIL_CACHE_IS_UNUSABLE(cache)) <nl> +		return 1; <nl> + <nl>  	ret = mail_cache_handler_init(&ctx, cache); <nl>  	*context = ctx; <nl>  	if (ret <= 0) <nl> @@ -110,6 +113,9 @@ int mail_cache_sync_handler(struct mail_index_sync_map_ctx *sync_ctx, <nl>  		return 1; <nl>  	} <nl>   <nl> +	if (MAIL_CACHE_IS_UNUSABLE(cache)) <nl> +		return 1; <nl> + <nl>  	if (cache->file_cache != NULL) { <nl>  		file_cache_invalidate(cache->file_cache, *new_cache_offset, <nl>  				      (size_t)-1);
@@ -140,7 +140,7 @@ acl_backend_vfile_get_local_dir(struct acl_backend *backend, const char *name) <nl>  		dir = mailbox_list_get_path(ns->list, name, <nl>  					    MAILBOX_LIST_PATH_TYPE_MAILBOX); <nl>  	} <nl> -	if (name == NULL) { <nl> +	if (name == NULL && dir != NULL) { <nl>  		/* verify that the directory isn't same as INBOX's directory. <nl>  		   this is mainly for Maildir. */ <nl>  		inbox = mailbox_list_get_path(ns->list, "INBOX",
@@ -150,6 +150,9 @@ mbox_sync_read_next_mail(struct mbox_sync_context *sync_ctx, <nl>  	i_assert(sync_ctx->input->v_offset != mail_ctx->mail.from_offset || <nl>  		 sync_ctx->input->eof); <nl>   <nl> +	if (istream_raw_mbox_is_corrupted(sync_ctx->input)) <nl> +		return -1; <nl> + <nl>  	mail_ctx->mail.body_size = <nl>  		istream_raw_mbox_get_body_size(sync_ctx->input, <nl>  					       mail_ctx->content_length); <nl> @@ -1167,13 +1170,12 @@ static int mbox_sync_loop(struct mbox_sync_context *sync_ctx, <nl>  			ret = mbox_sync_partial_seek_next(sync_ctx, uid + 1, <nl>  							  &partial, <nl>  							  &skipped_mails); <nl> -			if (ret <= 0) { <nl> -				if (ret < 0) <nl> -					return -1; <nl> +			if (ret <= 0) <nl>  				break; <nl> -			} <nl>  		} <nl>  	} <nl> +	if (ret < 0) <nl> +		return -1; <nl>   <nl>  	if (istream_raw_mbox_is_eof(sync_ctx->input)) { <nl>  		/* rest of the messages in index don't exist -> expunge them */
@@ -768,7 +768,7 @@ int main(int argc, char *argv[]) <nl>  			break; <nl>  		} <nl>  	} <nl> -	i_assert(optind <= argc); <nl> +	i_assert(optind > 0 && optind <= argc); <nl>   <nl>  	if (doveconf_arg != NULL) { <nl>  		const char **args;
@@ -167,7 +167,7 @@ setting_entry_detach(struct master_service_settings_cache *cache, <nl>   <nl>  	if (entry->local_name != NULL) <nl>  		hash_table_remove(cache->local_name_hash, entry->local_name); <nl> -	if (entry->local_ip.family != 0) <nl> +	else if (entry->local_ip.family != 0) <nl>  		hash_table_remove(cache->local_ip_hash, &entry->local_ip); <nl>  	settings_parser_deinit(&entry->parser); <nl>  } <nl> @@ -239,14 +239,17 @@ cache_add(struct master_service_settings_cache *cache, <nl>  			hash_table_create(&cache->local_name_hash, <nl>  					  cache->pool, 0, str_hash, strcmp); <nl>  		} <nl> +		i_assert(hash_table_lookup(cache->local_name_hash, <nl> +					   entry_local_name) == NULL); <nl>  		hash_table_insert(cache->local_name_hash, <nl>  				  entry_local_name, entry); <nl> -	} <nl> -	if (input->local_ip.family != 0) { <nl> +	} else if (input->local_ip.family != 0) { <nl>  		if (!hash_table_is_created(cache->local_ip_hash)) { <nl>  			hash_table_create(&cache->local_ip_hash, cache->pool, 0, <nl>  					  net_ip_hash, net_ip_cmp); <nl>  		} <nl> +		i_assert(hash_table_lookup(cache->local_ip_hash, <nl> +					   &entry->local_ip) == NULL); <nl>  		hash_table_insert(cache->local_ip_hash, <nl>  				  &entry->local_ip, entry); <nl>  	}
@@ -119,7 +119,7 @@ static void <nl>  read_ident_reply(rb_fde_t *F, void *data) <nl>  { <nl>  	struct auth_client *auth = data; <nl> -	char buf[IDENT_BUFSIZE + 1];	/* buffer to read auth reply into */ <nl> +	char buf[IDENT_BUFSIZE + 1] = { 0 }; /* buffer to read auth reply into */ <nl>  	ident_message message = REPORT_FAIL; <nl>  	char *s = NULL; <nl>  	char *t = NULL;
@@ -540,6 +540,9 @@ ms_sjoin(struct Client *client_p, struct Client *source_p, int parc, const char <nl>  	static char empty[] = ""; <nl>  	rb_dlink_node *ptr, *next_ptr; <nl>   <nl> +	if(parc < 5) <nl> +		return 0; <nl> + <nl>  	if(!IsChannelName(parv[2]) || !check_channel_name(parv[2])) <nl>  		return 0; <nl>  
@@ -3640,6 +3640,9 @@ operate(struct Configurable *config, int argc, argv_item_t argv[]) <nl>    long retry_sleep; <nl>   <nl>    char *env; <nl> + <nl> +  memset(&heads, 0, sizeof(struct OutStruct)); <nl> + <nl>  #ifdef CURLDEBUG <nl>    /* this sends all memory debug messages to a logfile named memdump */ <nl>    env = curlx_getenv("CURL_MEMDEBUG"); <nl> @@ -4220,7 +4223,8 @@ operate(struct Configurable *config, int argc, argv_item_t argv[]) <nl>          /* what call to read */ <nl>          my_setopt(curl, CURLOPT_READFUNCTION, my_fread); <nl>   <nl> -        /* libcurl 7.12.3 business: */ <nl> +        /* the ioctl function is at this point only used to rewind files <nl> +           that are posted when using NTLM etc */ <nl>          my_setopt(curl, CURLOPT_IOCTLDATA, &input); <nl>          my_setopt(curl, CURLOPT_IOCTLFUNCTION, my_ioctl); <nl>  
@@ -838,7 +838,7 @@ int cert_stuff(struct connectdata *conn, <nl>        EVP_PKEY_free(pktmp); <nl>      } <nl>   <nl> -#if !defined(OPENSSL_NO_RSA) <nl> +#if !defined(OPENSSL_NO_RSA) && !defined(OPENSSL_IS_BORINGSSL) <nl>      { <nl>        /* If RSA is used, don't check the private key if its flags indicate <nl>         * it doesn't support it. */
@@ -2456,6 +2456,12 @@ static CURLcode ssh_easy_statemach(struct connectdata *conn, <nl>   <nl>      if(Curl_pgrsUpdate(conn)) <nl>        return CURLE_ABORTED_BY_CALLBACK; <nl> +    else { <nl> +      struct timeval now = Curl_tvnow(); <nl> +      result = Curl_speedcheck(data, now); <nl> +      if(result) <nl> +        return result; <nl> +    } <nl>   <nl>      left = Curl_timeleft(data, NULL, duringconnect); <nl>      if(left < 0) {
@@ -72,7 +72,7 @@ int main(void) <nl>   <nl>      if(CURLE_OK != res) <nl>      { <nl> -      printf("Error: %s\n", strerror(res)); <nl> +      printf("Error: %s\n", curl_easy_strerror(res)); <nl>        return 1; <nl>      } <nl>   <nl> @@ -90,7 +90,7 @@ int main(void) <nl>   <nl>      if(CURLE_OK != res) <nl>      { <nl> -      printf("Error: %s\n", strerror(res)); <nl> +      printf("Error: %s\n", curl_easy_strerror(res)); <nl>        return 1; <nl>      } <nl>      puts("Reading response.");
@@ -406,7 +406,6 @@ CURLcode Curl_ntlm_create_type1_message(const char *userp, <nl>      *(dup_domain.tchar_ptr + domlen) = TEXT('\0'); <nl>      ntlm->identity.Domain = dup_domain.tbyte_ptr; <nl>      ntlm->identity.DomainLength = curlx_uztoul(domlen); <nl> -    free(dup_domain.tchar_ptr); <nl>      dup_domain.tchar_ptr = NULL; <nl>   <nl>      Curl_unicodefree(useranddomain.tchar_ptr);
@@ -831,7 +831,7 @@ static CURLcode AddFormData(struct FormData **formp, <nl>           file */ <nl>        if(!strequal("-", newform->line)) { <nl>          struct_stat file; <nl> -        if(!stat(newform->line, &file) && S_ISREG(file.st_mode)) <nl> +        if(!stat(newform->line, &file) && !S_ISDIR(file.st_mode)) <nl>            *size += file.st_size; <nl>          else <nl>            return CURLE_BAD_FUNCTION_ARGUMENT;
@@ -1017,7 +1017,7 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi, <nl>          /* There was no connection available. We will go to the pending <nl>             state and wait for an available connection. */ <nl>          multistate(easy, CURLM_STATE_CONNECT_PEND); <nl> -        easy->result = CURLM_OK; <nl> +        easy->result = CURLE_OK; <nl>          break; <nl>        } <nl>  
@@ -5,7 +5,7 @@ <nl>   *                            | (__| |_| |  _ <| |___ <nl>   *                             \___|\___/|_| \_\_____| <nl>   * <nl> - * Copyright (C) 1998 - 2016, Daniel Stenberg, <daniel@haxx.se>, et al. <nl> + * Copyright (C) 1998 - 2017, Daniel Stenberg, <daniel@haxx.se>, et al. <nl>   * <nl>   * This software is licensed as described in the file COPYING, which <nl>   * you should have received as part of this distribution. The terms <nl> @@ -516,7 +516,8 @@ Curl_addrinfo *Curl_unix2addr(const char *path, bool *longpath, bool abstract) <nl>   <nl>    ai->ai_family = AF_UNIX; <nl>    ai->ai_socktype = SOCK_STREAM; /* assume reliable transport for HTTP */ <nl> -  ai->ai_addrlen = offsetof(struct sockaddr_un, sun_path) + path_len; <nl> +  ai->ai_addrlen = (curl_socklen_t) <nl> +    ((offsetof(struct sockaddr_un, sun_path) + path_len) & 0x7FFFFFFF); <nl>   <nl>    /* Abstract Unix domain socket have NULL prefix instead of suffix */ <nl>    if(abstract)
@@ -310,7 +310,7 @@ int Curl_read(struct connectdata *conn, <nl>      do { <nl>        nread = SSL_read(conn->ssl.handle, buf, buffersize); <nl>   <nl> -      if(nread > 0) <nl> +      if(nread >= 0) <nl>          /* successful read */ <nl>          break; <nl>  
@@ -206,6 +206,8 @@ CURLcode Curl_connecthost(struct connectdata *conn, <nl>        /* get a new timeout for next attempt */ <nl>        after = Curl_tvnow(); <nl>        timeout_ms -= (long)(Curl_tvdiff(after, before)*1000); <nl> +      if(timeout_ms < 0) <nl> +        break; <nl>        before = after; <nl>        continue; <nl>      } <nl> @@ -285,6 +287,8 @@ CURLcode Curl_connecthost(struct connectdata *conn, <nl>        /* get a new timeout for next attempt */ <nl>        after = Curl_tvnow(); <nl>        timeout_ms -= (long)(Curl_tvdiff(after, before)*1000); <nl> +      if(timeout_ms < 0) <nl> +        break; <nl>        before = after; <nl>        continue; /* try next address */ <nl>      }
@@ -42,7 +42,7 @@ <nl>  static const char *telnetoptions[]= <nl>  { <nl>    "BINARY",      "ECHO",           "RCP",           "SUPPRESS GO AHEAD", <nl> -  "NAME",        "STATUS"          "TIMING MARK",   "RCTE", <nl> +  "NAME",        "STATUS",         "TIMING MARK",   "RCTE", <nl>    "NAOL",        "NAOP",           "NAOCRD",        "NAOHTS", <nl>    "NAOHTD",      "NAOFFD",         "NAOVTS",        "NAOVTD", <nl>    "NAOLFD",      "EXTEND ASCII",   "LOGOUT",        "BYTE MACRO",
@@ -344,7 +344,7 @@ static int loop(const unsigned char *pattern, const unsigned char *string) <nl>        else if(*p == '[') { <nl>          unsigned char *pp = p+1; /* cannot handle with pointer to register */ <nl>          if(setcharset(&pp, charset)) { <nl> -          bool found = FALSE; <nl> +          int found = FALSE; <nl>            if(charset[(unsigned int)*s]) <nl>              found = TRUE; <nl>            else if(charset[CURLFNM_ALNUM])
@@ -450,7 +450,13 @@ process_module_file (FILE *module_file, const gchar *module_file_dir) <nl>  	  switch (i) <nl>  	    { <nl>  	    case 0: <nl> -	      if (!g_path_is_absolute (tmp_buf->str)) <nl> +	      if (!g_path_is_absolute (tmp_buf->str) <nl> +#ifdef __APPLE__ <nl> +	          && strncmp (tmp_buf->str, "@executable_path/", 17) <nl> +	          && strncmp (tmp_buf->str, "@loader_path/", 13) <nl> +	          && strncmp (tmp_buf->str, "@rpath/", 7) <nl> +#endif <nl> +	         ) <nl>  		{ <nl>  		  const gchar *lib_dir = pango_get_lib_subdirectory (); <nl>  		  const gchar *abs_file_name = g_build_filename (lib_dir,
@@ -998,6 +998,9 @@ int authorize_socket( <nl>    if (trq_server_addr != NULL) <nl>      free(trq_server_addr); <nl>   <nl> +  if (server_name != NULL) <nl> +    free(server_name); <nl> + <nl>    return(rc); <nl>    } // END authorize_socket()  <nl>  
@@ -51,7 +51,7 @@ START_TEST(test_should_resend_obit) <nl>    pjob.ji_obit_sent = time_now; <nl>   <nl>    // Running jobs shouldn't re-send their obits <nl> -  pjob.ji_qs.ji_substate == JOB_SUBSTATE_RUNNING; <nl> +  pjob.ji_qs.ji_substate = JOB_SUBSTATE_RUNNING; <nl>    fail_unless(should_resend_obit(&pjob, diff) == false); <nl>    pjob.ji_obit_busy_time = time_now - (2 * diff); <nl>    fail_unless(should_resend_obit(&pjob, diff) == false);
@@ -233,11 +233,8 @@ int add_mic_status( <nl>      return(PBSE_NONE); <nl>  #endif <nl>   <nl> -  for (unsigned int i = 0; i < MAX_ENGINES; i++) <nl> -    { <nl> -    memset(engine[i], 0, sizeof(COIENGINE)); <nl> -    memset(mic_stat[i], 0, sizeof(COIENGINE)); <nl> -    } <nl> +  memset(&engine, 0, sizeof(engine)); <nl> +  memset(&mic_stat, 0, sizeof(mic_stat)); <nl>   <nl>    if (COIEngineGetCount(COI_ISA_MIC, &num_engines) != COI_SUCCESS) <nl>      {
@@ -153,7 +153,8 @@ int req_deletearray( <nl>    bool               purge = false; <nl>    extern const char *delpurgestr; <nl>       <nl> -  if (!strncmp(preq->rq_extend, delpurgestr, strlen(delpurgestr))) <nl> +  if ((preq->rq_extend != NULL) && <nl> +      (!strncmp(preq->rq_extend, delpurgestr, strlen(delpurgestr)))) <nl>      purge = true; <nl>   <nl>    pa = get_array(preq->rq_ind.rq_delete.rq_objname);
@@ -1415,6 +1415,11 @@ static int chk_save_file( <nl>    { <nl>    struct stat sb; <nl>   <nl> +  if (*filename == '.') <nl> +    { <nl> +    return(-1); <nl> +    } <nl> + <nl>    if (stat(filename,&sb) == -1) <nl>      { <nl>      return(errno);
@@ -4564,6 +4564,8 @@ int procs_requested( <nl>          if (proplist(&str, &prop, &num_procs, &num_gpus, &num_mics)) <nl>            { <nl>            free(tmp_spec); <nl> +          if (prop != NULL) <nl> +            free_prop(prop); <nl>            return(-1); <nl>            } <nl>          } <nl> @@ -4576,6 +4578,8 @@ int procs_requested( <nl>          { <nl>          /* must be a prop list with no number in front */ <nl>          free(tmp_spec); <nl> +        if (prop != NULL) <nl> +          free_prop(prop); <nl>   <nl>          return(-1); <nl>          }
@@ -99,7 +99,7 @@ static inline struct dlg_var *new_dlg_var(str *key, str *val) <nl>  		LM_ERR("no more shm mem\n"); <nl>  		return NULL; <nl>  	} <nl> -	var->next = NULL; <nl> +	memset(var, 0, sizeof(struct dlg_var)); <nl>  	var->vflags = DLG_FLAG_NEW; <nl>  	/* set key */ <nl>  	var->key.len = key->len; <nl> @@ -113,7 +113,7 @@ static inline struct dlg_var *new_dlg_var(str *key, str *val) <nl>  	var->key.s[var->key.len] = '\0'; <nl>  	/* set value */ <nl>  	var->value.len = val->len; <nl> -	var->value.s = (char*)shm_malloc(var->value.len); <nl> +	var->value.s = (char*)shm_malloc(var->value.len+1); <nl>  	if (var->value.s==NULL) { <nl>  		shm_free(var->key.s);			 <nl>  		shm_free(var);			 <nl> @@ -121,6 +121,7 @@ static inline struct dlg_var *new_dlg_var(str *key, str *val) <nl>  		return NULL; <nl>  	} <nl>  	memcpy(var->value.s, val->s, val->len); <nl> +	var->value.s[var->value.len] = '\0'; <nl>  	return var; <nl>  } <nl>  
@@ -263,6 +263,7 @@ int db_postgres_val2str(const db_con_t* _con, const db_val_t* _v, char* _s, int* <nl>   <nl>  	case DB_BLOB: <nl>  		l = VAL_BLOB(_v).len; <nl> +		/* this estimation is not always correct, thus we need to check later again */ <nl>  		if (*_len < (l * 2 + 3)) { <nl>  			LM_ERR("destination buffer too short for blob\n"); <nl>  			return -7; <nl> @@ -275,6 +276,10 @@ int db_postgres_val2str(const db_con_t* _con, const db_val_t* _v, char* _s, int* <nl>  				LM_ERR("PQescapeBytea failed\n"); <nl>  				return -7; <nl>  			} <nl> +			if (tmp_len > *_len) { <nl> +				LM_ERR("escaped result too long\n"); <nl> +				return -7; <nl> +			} <nl>  			memcpy(_s, tmp_s, tmp_len); <nl>  			PQfreemem(tmp_s); <nl>  			tmp_len = strlen(_s);
@@ -306,7 +306,7 @@ static int rtpproxy_set_store(modparam_t type, void * val){ <nl>  			return -1; <nl>  		} <nl>  	} else {/*realloc to make room for the current set*/ <nl> -		rtpp_strings = (char**)pkg_realloc(rtpp_strings, <nl> +		rtpp_strings = (char**)pkg_reallocxf(rtpp_strings, <nl>  				(rtpp_sets+1)* sizeof(char*)); <nl>  		if(!rtpp_strings){ <nl>  			LM_ERR("no pkg memory left\n");
@@ -552,6 +552,7 @@ int curl_con_query_url_f(struct sip_msg* _m, const str *connection, <nl>  	query_params.cacert = default_tls_cacert; <nl>  	query_params.ciphersuites = conn->ciphersuites; <nl>  	query_params.tlsversion = conn->tlsversion; <nl> +	query_params.useragent = conn->useragent; <nl>  	query_params.verify_peer = conn->verify_peer; <nl>  	query_params.verify_host = conn->verify_host; <nl>  	query_params.timeout = conn->timeout;
@@ -444,6 +444,9 @@ dlg_cell_t *dlg_lookup( unsigned int h_entry, unsigned int h_id) <nl>  	dlg_cell_t *dlg; <nl>  	dlg_entry_t *d_entry; <nl>   <nl> +	if(d_table==NULL) <nl> +		return 0; <nl> + <nl>  	if (h_entry>=d_table->size) <nl>  		goto not_found; <nl>  
@@ -355,6 +355,7 @@ struct sip_msg*  sip_msg_cloner( struct sip_msg *org_msg, int *sip_msg_len ) <nl>  			case HDR_REFER_TO_T: <nl>  			case HDR_SESSION_EXPIRES_T: <nl>  			case HDR_MIN_SE_T: <nl> +			case HDR_PPI_T: <nl>  				/* we ignore them for now even if they have something parsed*/ <nl>  				break; <nl>   <nl> @@ -719,6 +720,11 @@ do { \ <nl>  					new_msg->rpid = new_hdr; <nl>  				} <nl>  				break; <nl> +			case HDR_PPI_T: <nl> +				if (!HOOK_SET(ppi)) { <nl> +					new_msg->ppi = new_hdr; <nl> +				} <nl> +				break; <nl>  			case HDR_REFER_TO_T: <nl>  				if (!HOOK_SET(refer_to)) { <nl>  					new_msg->refer_to = new_hdr;
@@ -59,7 +59,7 @@ int new_urecord(str* _dom, str* _aor, urecord_t** _r) <nl>   <nl>  	(*_r)->aor.s = (char*)shm_malloc(_aor->len); <nl>  	if ((*_r)->aor.s == 0) { <nl> -		LOG(L_ERR, "new_urecord(): No memory left 2\n"); <nl> +		LOG(L_ERR, "new_urecord(): No memory left\n"); <nl>  		shm_free(*_r); <nl>  		return -2; <nl>  	}
@@ -88,10 +88,13 @@ void dtrie_delete(struct dtrie_node_t *root, struct dtrie_node_t *node, <nl>  	if (delete_payload) { <nl>  		delete_payload(node->data); <nl>  	} <nl> + <nl>  	node->data = NULL; <nl> -	 <nl> + <nl>  	if (node != root) { <nl>  		LM_DBG("free node at %p\n", node); <nl> +		shm_free(node->child); <nl> +		node->child = NULL; <nl>  		shm_free(node); <nl>  	} <nl>  } <nl> @@ -102,6 +105,7 @@ void dtrie_destroy(struct dtrie_node_t **root, dt_delete_func_t delete_payload, <nl>  	if ((root!=NULL) && (*root!=NULL)) { <nl>  		dtrie_delete(*root, *root, delete_payload, branches); <nl>  		LM_DBG("free root at %p\n", root); <nl> +		shm_free((*root)->child); <nl>  		shm_free(*root); <nl>  		*root = NULL; <nl>  	}
@@ -504,7 +504,7 @@ error: <nl>   */ <nl>  void remove_sdp(qos_ctx_t *qos_ctx, unsigned int dir, struct sip_msg *_m, unsigned int role, unsigned int other_role) <nl>  { <nl> -	str *cseq_number, *cseq_method; <nl> +	str *cseq_number; <nl>  	int cseq_method_id; <nl>  	qos_sdp_t *qos_sdp; <nl>   <nl> @@ -514,7 +514,6 @@ void remove_sdp(qos_ctx_t *qos_ctx, unsigned int dir, struct sip_msg *_m, unsign <nl>  	} <nl>   <nl>  	cseq_number = &((get_cseq(_m))->number); <nl> -	cseq_method = &((get_cseq(_m))->method); <nl>  	cseq_method_id = (get_cseq(_m))->method_id; <nl>   <nl>  	if (_m->first_line.type == SIP_REPLY) {
@@ -693,8 +693,8 @@ int rval_get_int(struct run_act_ctx* h, struct sip_msg* msg, <nl>  			break; <nl>  		case RV_ACTION_ST: <nl>  			if (rv->v.action) <nl> -				*i=run_actions(h, rv->v.action, msg); <nl> -			else  <nl> +				*i=(run_actions(h, rv->v.action, msg)>0); <nl> +			else <nl>  				*i=0; <nl>  			break; <nl>  		case RV_SEL: <nl> @@ -796,8 +796,8 @@ int rval_get_tmp_str(struct run_act_ctx* h, struct sip_msg* msg, <nl>  			break; <nl>  		case RV_ACTION_ST: <nl>  			if (rv->v.action) <nl> -				i=run_actions(h, rv->v.action, msg); <nl> -			else  <nl> +				i=(run_actions(h, rv->v.action, msg)>0); <nl> +			else <nl>  				i=0; <nl>  			tmpv->s=int2str(i, &tmpv->len); <nl>  			break;
@@ -1115,6 +1115,12 @@ int extract_sdialog_info(subs_t* subs,struct sip_msg* msg, int mexp, <nl>  		LM_ERR("cannot parse contact header\n"); <nl>  		goto error; <nl>  	} <nl> +	if(b->star || b->contacts==NULL) <nl> +	{ <nl> +		LM_ERR("Wrong contact header\n"); <nl> +		goto error; <nl> +	} <nl> + <nl>  	subs->contact = b->contacts->uri; <nl>  	 <nl>  	LM_DBG("subs->contact= %.*s - len = %d\n",subs->contact.len,
@@ -157,6 +157,12 @@ struct module_exports exports = { <nl>  static int mod_init(void) { <nl>  	struct stat fs; <nl>   <nl> +	if(register_mi_mod(exports.name, mi_cmds)!=0) <nl> +	{ <nl> +		LM_ERR("failed to register MI commands\n"); <nl> +		return -1; <nl> +	} <nl> + <nl>  	subscriber_table.len = strlen(subscriber_table.s); <nl>  	subscriber_username_col.len = strlen(subscriber_username_col.s); <nl>  	subscriber_domain_col.len = strlen(subscriber_domain_col.s);
@@ -33,7 +33,7 @@ char* q_col          = "q";                                /* Name of column con <nl>  char* callid_col     = "callid";                           /* Name of column containing callid string */ <nl>  char* cseq_col       = "cseq";                             /* Name of column containing cseq values */ <nl>  char* method_col     = "method";                           /* Name of column containing supported method */ <nl> -char* db_url         = "sql://janakj:heslo@localhost/ser"; /* Database URL */ <nl> +char* db_url         = "sql://ser:heslo@localhost/ser";    /* Database URL */ <nl>  int   timer_interval = 60;                                 /* Timer interval in seconds */ <nl>  int   db_mode        = 0;                                  /* Database sync scheme: 0-no db, 1-write through, 2-write back */ <nl>  
@@ -163,12 +163,15 @@ void free_hostent(struct hostent *dst) <nl>  	int r; <nl>  	if (dst->h_name) pkg_free(dst->h_name); <nl>  	if (dst->h_aliases){ <nl> -		for(r=0; dst->h_aliases[r]; r++)	pkg_free(dst->h_aliases[r]); <nl> -		pkg_free(dst->h_aliases[r]); <nl> +		for(r=0; dst->h_aliases[r]; r++) { <nl> +			pkg_free(dst->h_aliases[r]); <nl> +		} <nl>  		pkg_free(dst->h_aliases); <nl>  	} <nl>  	if (dst->h_addr_list){ <nl> -		for (r=0; dst->h_addr_list[r];r++) pkg_free(dst->h_addr_list[r]); <nl> +		for (r=0; dst->h_addr_list[r];r++) {  <nl> +			pkg_free(dst->h_addr_list[r]); <nl> +		} <nl>  		pkg_free(dst->h_addr_list[r]); <nl>  		pkg_free(dst->h_addr_list); <nl>  	}
@@ -69,6 +69,7 @@ batch_queue_save(RS_QUEUE *queue) <nl>  				xmlTextWriterWriteFormatElement(writer, BAD_CAST "filename", "%s", filename); <nl>  				xmlTextWriterWriteFormatElement(writer, BAD_CAST "snapshot", "%d", setting_id); <nl>  			xmlTextWriterEndElement(writer); <nl> +			g_free(filename); <nl>  		} while(gtk_tree_model_iter_next(queue->list, &iter)); <nl>   <nl>  	xmlTextWriterEndDocument(writer);
@@ -263,6 +263,7 @@ rs_cache_load_quick(const gchar *filename, gint *priority) <nl>  	xmlChar *val; <nl>  	gchar *cachename; <nl>   <nl> +	if (!filename) return; <nl>  	cachename = rs_cache_get_name(filename); <nl>  	if (!cachename) return; <nl>  	if (!g_file_test(cachename, G_FILE_TEST_IS_REGULAR)) return; <nl> @@ -274,7 +275,7 @@ rs_cache_load_quick(const gchar *filename, gint *priority) <nl>  	cur = cur->xmlChildrenNode; <nl>  	while(cur) <nl>  	{ <nl> -		if ((!xmlStrcmp(cur->name, BAD_CAST "priority"))) <nl> +		if (priority && (!xmlStrcmp(cur->name, BAD_CAST "priority"))) <nl>  		{ <nl>  			val = xmlNodeListGetString(doc, cur->xmlChildrenNode, 1); <nl>  			*priority = atoi((gchar *) val);
@@ -1475,12 +1475,7 @@ void <nl>  rs_render_pixel_to_srgb(RS_BLOB *rs, gint x, gint y, guchar *dest) <nl>  { <nl>  	gushort *pixel; <nl> -	if (x>(rs->photo->scaled->w-1)) <nl> -		x = rs->photo->scaled->w-1; <nl> -	if (y>(rs->photo->scaled->h-1)) <nl> -		y = rs->photo->scaled->h-1; <nl> -	pixel = &rs->photo->scaled->pixels[y*rs->photo->scaled->rowstride <nl> -		+ x*rs->photo->scaled->pixelsize]; <nl> +	pixel = rs_image16_get_pixel(rs->photo->scaled, x, y, TRUE); <nl>  	rs_render_pixel(&rs->photo->mat, rs->photo->pre_mul, rs->previewtable8, rs->previewtable16, pixel, dest, rs_cms_get_transform(rs->cms, TRANSFORM_SRGB)); <nl>  	return; <nl>  }
@@ -1108,6 +1108,7 @@ gui_save_file_callback(gpointer callback_data, guint callback_action, GtkWidget <nl>  		if(filetype_str) <nl>  			if (g_str_equal(savers[n].extension, filetype_str)) <nl>  				gtk_combo_box_set_active(GTK_COMBO_BOX(filetype), n); <nl> +		g_free(filetype_str); <nl>  		n++; <nl>  	} <nl>  	if (gtk_combo_box_get_active(GTK_COMBO_BOX(filetype)) == -1)
@@ -720,10 +720,10 @@ static int reconfig(struct vo *vo, struct mp_image_params *fmt, int flags) <nl>      // overides alpha <nl>      // use rgb565 if performance is your main concern <nl>      if (p->use_rgb565) { <nl> -        const struct fmtentry *fmt = <nl> +        const struct fmtentry *entry = <nl>              is_wayland_format_supported(p, WL_SHM_FORMAT_RGB565); <nl> -        if (fmt) <nl> -            p->video_format = fmt; <nl> +        if (entry) <nl> +            p->video_format = entry; <nl>      } <nl>   <nl>      buffer_pool_init(p, &p->video_bufpool, (p->use_triplebuffering ? 3 : 2),
@@ -3075,7 +3075,8 @@ void gl_video_render_frame(struct gl_video *p, struct vo_frame *frame, <nl>                  // texture to speed up subsequent re-draws (if any exist) <nl>                  struct ra_fbo dest_fbo = fbo; <nl>                  if (frame->num_vsyncs > 1 && frame->display_synced && <nl> -                    !p->dumb_mode && (p->ra->caps & RA_CAP_BLIT)) <nl> +                    !p->dumb_mode && (p->ra->caps & RA_CAP_BLIT) && <nl> +                    fbo.tex->params.blit_dst) <nl>                  { <nl>                      // Attempt to use the same format as the destination FBO <nl>                      // if possible. Some RAs use a wrapped dummy format here, <nl> @@ -3095,7 +3096,7 @@ void gl_video_render_frame(struct gl_video *p, struct vo_frame *frame, <nl>              } <nl>   <nl>              // "output tex valid" and "output tex needed" are equivalent <nl> -            if (p->output_tex_valid) { <nl> +            if (p->output_tex_valid && fbo.tex->params.blit_dst) { <nl>                  pass_info_reset(p, true); <nl>                  pass_describe(p, "redraw cached frame"); <nl>                  struct mp_rect src = p->dst_rect;
@@ -531,7 +531,7 @@ static int dict_get_decimal(AVDictionary *dict, const char *entry, int def) <nl>      return def; <nl>  } <nl>   <nl> -static void handle_stream(demuxer_t *demuxer, int i) <nl> +static void handle_new_stream(demuxer_t *demuxer, int i) <nl>  { <nl>      lavf_priv_t *priv = demuxer->priv; <nl>      AVFormatContext *avfc = priv->avfc; <nl> @@ -691,7 +691,7 @@ static void add_new_streams(demuxer_t *demuxer) <nl>  { <nl>      lavf_priv_t *priv = demuxer->priv; <nl>      while (priv->num_streams < priv->avfc->nb_streams) <nl> -        handle_stream(demuxer, priv->num_streams); <nl> +        handle_new_stream(demuxer, priv->num_streams); <nl>  } <nl>   <nl>  static void update_metadata(demuxer_t *demuxer, AVPacket *pkt)
@@ -50,9 +50,12 @@ static inline int check_varlen(uint8_t *ptr, uint8_t *endptr, int len) { <nl>  } <nl>   <nl>  static void asf_descrambling(unsigned char **src,unsigned len, struct asf_priv* asf){ <nl> -  unsigned char *dst=malloc(len); <nl> +  unsigned char *dst; <nl>    unsigned char *s2=*src; <nl>    unsigned i=0,x,y; <nl> +  if (len > UINT_MAX - FF_INPUT_BUFFER_PADDING_SIZE) <nl> +	return; <nl> +  dst = malloc(len + FF_INPUT_BUFFER_PADDING_SIZE); <nl>    while(len>=asf->scrambling_h*asf->scrambling_w*asf->scrambling_b+i){ <nl>  //    mp_msg(MSGT_DEMUX,MSGL_DBG4,"descrambling! (w=%d  b=%d)\n",w,asf_scrambling_b); <nl>  	//i+=asf_scrambling_h*asf_scrambling_w;
@@ -690,6 +690,9 @@ static uint32_t get_image(mp_image_t *mpi) { <nl>    if (mpi->flags & MP_IMGFLAG_READABLE) return VO_FALSE; <nl>    if (ati_hack) { <nl>      int s = 1; <nl> +    // for unexplainable reasons, with width < 512 chroma tends to be messed up <nl> +    // (after ca. 2/3 the previous line repeats all over) <nl> +    if (mpi->width < 512) return VO_FALSE; <nl>      while (s < mpi->width) s *= 2; <nl>      mpi->width = s; <nl>    }
@@ -10,6 +10,7 @@ extern int vo_vm; <nl>  extern int vo_w32_init(void); <nl>  extern void vo_w32_uninit(void); <nl>  extern void vo_w32_ontop(void); <nl> +extern void vo_w32_border(void); <nl>  extern void vo_w32_fullscreen(void); <nl>  extern int vo_w32_check_events(void); <nl>  extern int vo_w32_config(uint32_t, uint32_t, uint32_t);
@@ -641,7 +641,7 @@ static HRESULT enumerate_with_state(char *header, int status, int with_id) { <nl>      IMMDeviceCollection *pDevices = NULL; <nl>      IMMDevice *pDevice = NULL; <nl>      IPropertyStore *pProps = NULL; <nl> -    LPWSTR idStr = NULL; <nl> +    char *defid = NULL; <nl>   <nl>      CoInitialize(NULL); <nl>      hr = CoCreateInstance(&CLSID_MMDeviceEnumerator, NULL, CLSCTX_ALL, <nl> @@ -653,7 +653,7 @@ static HRESULT enumerate_with_state(char *header, int status, int with_id) { <nl>                                                       &pDevice); <nl>      EXIT_ON_ERROR(hr) <nl>   <nl> -    char *defid = get_device_id(pDevice); <nl> +    defid = get_device_id(pDevice); <nl>   <nl>      SAFE_RELEASE(pDevice, IMMDevice_Release(pDevice)); <nl>   <nl> @@ -690,12 +690,13 @@ static HRESULT enumerate_with_state(char *header, int status, int with_id) { <nl>          free(id); <nl>          SAFE_RELEASE(pDevice, IMMDevice_Release(pDevice)); <nl>      } <nl> +    free(defid); <nl>      SAFE_RELEASE(pDevices, IMMDeviceCollection_Release(pDevices)); <nl>      SAFE_RELEASE(pEnumerator, IMMDeviceEnumerator_Release(pEnumerator)); <nl>      return hr; <nl>   <nl>  exit_label: <nl> -    CoTaskMemFree(idStr); <nl> +    free(defid); <nl>      SAFE_RELEASE(pProps, IPropertyStore_Release(pProps)); <nl>      SAFE_RELEASE(pDevice, IMMDevice_Release(pDevice)); <nl>      SAFE_RELEASE(pDevices, IMMDeviceCollection_Release(pDevices));
@@ -161,7 +161,7 @@ static int error_handler(lua_State *L) <nl>      if (luaL_loadstring(L, "return debug.traceback('', 3)") == 0) { // e fn|err <nl>          lua_call(L, 0, 1); // e backtrace <nl>          const char *tr = lua_tostring(L, -1); <nl> -        MP_WARN(ctx, "%s\n", tr); <nl> +        MP_WARN(ctx, "%s\n", tr ? tr : "(unknown)"); <nl>      } <nl>      lua_pop(L, 1); // e <nl>   <nl> @@ -1201,6 +1201,8 @@ static int script_subprocess(lua_State *L) <nl>          lua_pushinteger(L, n + 1); // args n <nl>          lua_gettable(L, -2); // args arg <nl>          args[n] = talloc_strdup(tmp, lua_tostring(L, -1)); <nl> +        if (!args[n]) <nl> +            luaL_error(L, "program arguments must be strings"); <nl>          lua_pop(L, 1); // args <nl>      } <nl>      args[num_args] = NULL;
@@ -164,6 +164,7 @@ int demux_audio_open(demuxer_t* demuxer) { <nl>      w->wBitsPerSample = sh_audio->samplesize = stream_read_word_le(s); <nl>      w->cbSize = 0; <nl>      l -= 16; <nl> +    if(verbose>0) print_wave_header(w); <nl>      if(l) <nl>        stream_skip(s,l); <nl>      do <nl> @@ -175,6 +176,7 @@ int demux_audio_open(demuxer_t* demuxer) { <nl>      } while (chunk_type != mmioFOURCC('d', 'a', 't', 'a')); <nl>      demuxer->movi_start = stream_tell(s); <nl>      demuxer->movi_end = s->end_pos; <nl> +//    printf("wav: %X .. %X\n",(int)demuxer->movi_start,(int)demuxer->movi_end); <nl>    } break; <nl>    } <nl>  
@@ -481,6 +481,9 @@ static void uninit_avctx(struct dec_video *vd) <nl>      vd_ffmpeg_ctx *ctx = vd->priv; <nl>      AVCodecContext *avctx = ctx->avctx; <nl>   <nl> +    flush_all(vd); <nl> +    av_frame_free(&ctx->pic); <nl> + <nl>      if (avctx) { <nl>          if (avctx->codec && avcodec_close(avctx) < 0) <nl>              MP_ERR(vd, "Could not close codec.\n"); <nl> @@ -494,10 +497,6 @@ static void uninit_avctx(struct dec_video *vd) <nl>   <nl>      av_freep(&ctx->avctx); <nl>   <nl> -    av_frame_free(&ctx->pic); <nl> - <nl> -    flush_all(vd); <nl> - <nl>      ctx->hwdec_failed = false; <nl>      ctx->hwdec_fail_count = 0; <nl>      ctx->max_delay_queue = 0;
@@ -466,7 +466,7 @@ struct demux_packet *demux_read_packet(struct sh_stream *sh) <nl>  // packets from the queue. <nl>  double demux_get_next_pts(struct sh_stream *sh) <nl>  { <nl> -    if (sh) { <nl> +    if (sh && sh->ds->selected) { <nl>          ds_get_packets(sh); <nl>          if (sh->ds->head) <nl>              return sh->ds->head->pts;
@@ -386,10 +386,15 @@ static int create(struct gl_hwdec *hw) <nl>      return 0; <nl>  } <nl>   <nl> +static bool test_format(struct gl_hwdec *hw, int imgfmt) <nl> +{ <nl> +    return imgfmt == IMGFMT_MMAL || imgfmt == IMGFMT_420P; <nl> +} <nl> + <nl>  const struct gl_hwdec_driver gl_hwdec_rpi_overlay = { <nl>      .name = "rpi-overlay", <nl>      .api = HWDEC_RPI, <nl> -    .imgfmt = IMGFMT_MMAL, <nl> +    .test_format = test_format, <nl>      .create = create, <nl>      .reinit = reinit, <nl>      .overlay_frame = overlay_frame,
@@ -110,11 +110,11 @@ int mpcodecs_config_vo(sh_video_t *sh, int w, int h, unsigned int preferred_outf <nl>      int screen_size_y=0;//SCREEN_SIZE_Y; <nl>      vo_functions_t* video_out=sh->video_out; <nl>   <nl> -    memset(&vtune,0,sizeof(vo_tune_info_t)); <nl> - <nl>      mp_msg(MSGT_DECVIDEO,MSGL_INFO,"VDec: vo config request - %d x %d, %s  \n", <nl>  	w,h,vo_format_name(preferred_outfmt)); <nl>   <nl> +    if(!video_out) return 1; // temp hack <nl> + <nl>      // check if libvo and codec has common outfmt: <nl>      for(i=0;i<CODECS_MAX_OUTFMT;i++){ <nl>  	out_fmt=sh->codec->outfmt[i]; <nl> @@ -186,6 +186,7 @@ int mpcodecs_config_vo(sh_video_t *sh, int w, int h, unsigned int preferred_outf <nl>                        fullscreen|(vidmode<<1)|(softzoom<<2)|(flip<<3), <nl>                        "MPlayer",out_fmt); <nl>   <nl> +    memset(&vtune,0,sizeof(vo_tune_info_t)); <nl>      if(video_out->config(sh->disp_w,sh->disp_h, <nl>                        screen_size_x,screen_size_y, <nl>                        fullscreen|(vidmode<<1)|(softzoom<<2)|(flip<<3),
@@ -210,7 +210,6 @@ const struct ao_driver audio_out_null = { <nl>      .priv_size = sizeof(struct priv), <nl>      .priv_defaults = &(const struct priv) { <nl>          .bufferlen = 0.2, <nl> -        .latency_sec = 0.5, <nl>          .outburst = 256, <nl>          .speed = 1, <nl>      },
@@ -358,8 +358,8 @@ struct mp_image *video_decode(struct dec_video *d_video, <nl>          pts += frame_time; <nl>      } <nl>   <nl> -    if (d_video->decoded_pts != MP_NOPTS_VALUE && pts < d_video->decoded_pts) { <nl> -        mp_msg(MSGT_DECVIDEO, MSGL_WARN, "Decreasing video pts: %f < %f\n", <nl> +    if (d_video->decoded_pts != MP_NOPTS_VALUE && pts <= d_video->decoded_pts) { <nl> +        mp_msg(MSGT_DECVIDEO, MSGL_WARN, "Non-monotonic video pts: %f <= %f\n", <nl>                 pts, d_video->decoded_pts); <nl>          pts = d_video->decoded_pts; <nl>      }
@@ -272,8 +272,9 @@ static HRESULT STDMETHODCALLTYPE DropTarget_Drop(IDropTarget* This, <nl>      } else if (pDataObj->lpVtbl->GetData(pDataObj, <nl>                                           &fmtetc_url, &medium) == S_OK) { <nl>          // get the URL encoded in US-ASCII <nl> -        char* url = (char*)GlobalLock(medium.hGlobal); <nl> -        if (url != NULL) { <nl> +        wchar_t* wurl = GlobalLock(medium.hGlobal); <nl> +        if (wurl != NULL) { <nl> +            char *url = mp_to_utf8(NULL, wurl); <nl>              if (mp_event_drop_mime_data(t->w32->input_ctx, "text/uri-list", <nl>                                          bstr0(url), action) > 0) { <nl>                  MP_VERBOSE(t->w32, "received dropped URL: %s\n", url); <nl> @@ -281,6 +282,7 @@ static HRESULT STDMETHODCALLTYPE DropTarget_Drop(IDropTarget* This, <nl>                  MP_ERR(t->w32, "error getting dropped URL\n"); <nl>              } <nl>   <nl> +            talloc_free(url); <nl>              GlobalUnlock(medium.hGlobal); <nl>          } <nl>   <nl> @@ -1224,7 +1226,7 @@ static void *gui_thread(void *ptr) <nl>      if (SUCCEEDED(OleInitialize(NULL))) { <nl>          ole_ok = true; <nl>   <nl> -        fmtetc_url.cfFormat = (CLIPFORMAT)RegisterClipboardFormat(TEXT("UniformResourceLocator")); <nl> +        fmtetc_url.cfFormat = (CLIPFORMAT)RegisterClipboardFormat(TEXT("UniformResourceLocatorW")); <nl>          DropTarget* dropTarget = talloc(NULL, DropTarget); <nl>          DropTarget_Init(dropTarget, w32); <nl>          RegisterDragDrop(w32->window, &dropTarget->iface);
@@ -311,8 +311,11 @@ static struct mp_image *dxva2_retrieve_image(struct lavc_ctx *s, <nl>   <nl>      IDirect3DSurface9_GetDesc(surface, &surfaceDesc); <nl>   <nl> +    if (surfaceDesc.Width < img->w || surfaceDesc.Height < img->h) <nl> +        return img; <nl> + <nl>      struct mp_image *sw_img = <nl> -        mp_image_pool_get(ctx->sw_pool, IMGFMT_NV12, img->w, img->h); <nl> +        mp_image_pool_get(ctx->sw_pool, IMGFMT_NV12, surfaceDesc.Width, surfaceDesc.Height); <nl>   <nl>      if (!sw_img) <nl>          return img; <nl> @@ -325,6 +328,7 @@ static struct mp_image *dxva2_retrieve_image(struct lavc_ctx *s, <nl>      } <nl>   <nl>      ctx->copy_nv12(sw_img, LockedRect.pBits, LockedRect.Pitch, surfaceDesc.Height); <nl> +    mp_image_set_size(sw_img, img->w, img->h); <nl>      mp_image_copy_attributes(sw_img, img); <nl>   <nl>      IDirect3DSurface9_UnlockRect(surface);
@@ -232,8 +232,11 @@ static int load_syms_windows(char *path) { <nl>      if(wrvyuv_custom_message && <nl>         wrvyuv_free && <nl>         wrvyuv_init && <nl> -       wrvyuv_transform) <nl> +       wrvyuv_transform) { <nl> +	dll_type = 1; <nl> +	rv_handle = handle; <nl>  	return 1; <nl> +    } <nl>   <nl>      mp_msg(MSGT_DECVIDEO,MSGL_WARN,"Error resolving symbols! (version incompatibility?)\n"); <nl>      FreeLibrary(handle);
@@ -90,6 +90,10 @@ static void free_entry(list_entry_t* entry) { <nl>      free(entry->ok); <nl>    if(entry->cancel) <nl>      free(entry->cancel); <nl> +  if(entry->left) <nl> +    free(entry->left); <nl> +  if(entry->right) <nl> +    free(entry->right); <nl>    free(entry->p.txt); <nl>    free(entry); <nl>  }
@@ -254,6 +254,7 @@ static int update_display_size(struct vo *vo) <nl>      } <nl>      p->sc = gl_sc_create(p->egl.gl, vo->log, vo->global), <nl>      p->osd = mpgl_osd_init(p->egl.gl, vo->log, vo->osd); <nl> +    p->osd_change_counter = -1; // force initial overlay rendering <nl>   <nl>      p->display_fps = 0; <nl>      TV_GET_STATE_RESP_T tvstate;
@@ -950,7 +950,7 @@ static char help_text[]= <nl>  // ======================= VO Video Output drivers ======================== <nl>   <nl>  #define MSGTR_VOincompCodec "The selected video_out device is incompatible with this codec.\n"\ <nl> -                "Also try adding the scale filter, e.g. -vf spp,scale instead of -vf spp.\n" <nl> +                "Try adding the scale filter, e.g. -vf spp,scale instead of -vf spp.\n" <nl>  #define MSGTR_VO_GenericError "This error has occurred" <nl>  #define MSGTR_VO_UnableToAccess "Unable to access" <nl>  #define MSGTR_VO_ExistsButNoDirectory "already exists, but is not a directory."
@@ -143,7 +143,7 @@ struct config xvidencopts_conf[] = { <nl>      { "gmc", &xvidenc_gmc, CONF_TYPE_FLAG, 0, 0, 1, NULL}, <nl>      { "chroma_me", &xvidenc_chroma_me, CONF_TYPE_FLAG, 0, 0, 1, NULL}, <nl>      { "hq_ac", &xvidenc_hqac, CONF_TYPE_FLAG, 0, 0, 1, NULL}, <nl> -    { "vhq", &xvidenc_vhq, CONF_TYPE_INT, CONF_RANGE, 0, 3, NULL}, <nl> +    { "vhq", &xvidenc_vhq, CONF_TYPE_INT, CONF_RANGE, 0, 4, NULL}, <nl>      { "chroma_opt", &xvidenc_chroma_opt, CONF_TYPE_FLAG, 0, 0, 1, NULL}, <nl>  #endif <nl>      { NULL, NULL, 0, 0, 0, 0, NULL} <nl> @@ -279,12 +279,13 @@ config(struct vf_instance_s* vf, <nl>  	fp->enc_frame.motion |= PMV_QUARTERPELREFINE16 | PMV_QUARTERPELREFINE8; <nl>      } <nl>      switch (xvidenc_vhq) { <nl> -    case 3: // wide search <nl> +    case 4: // wide search <nl>  	fp->enc_frame.motion |= EXTSEARCH_BITS | PMV_EXTSEARCH8; <nl> -    case 2: // medium search <nl> +    case 3: // medium search <nl>  	fp->enc_frame.motion |= HALFPELREFINE8_BITS | QUARTERPELREFINE8_BITS | CHECKPREDICTION_BITS; <nl> -    case 1: // limited search <nl> +    case 2: // limited search <nl>  	fp->enc_frame.motion |= HALFPELREFINE16_BITS | QUARTERPELREFINE16_BITS; <nl> +    case 1: // mode decision <nl>  	fp->enc_frame.general |= XVID_MODEDECISION_BITS; <nl>  	break; <nl>      case 0: // off
@@ -94,6 +94,7 @@ static int d_check_file(struct demuxer *demuxer, enum demux_check check) <nl>      *p = (struct priv) { <nl>          .track = track, <nl>      }; <nl> +    demuxer->priv = p; <nl>   <nl>      struct sh_stream *sh = new_sh_stream(demuxer, STREAM_SUB); <nl>      sh->sub->track = track;
@@ -945,6 +945,10 @@ static int mp_property_program(m_option_t * prop, int action, void *arg, <nl>  	     &prog) == DEMUXER_CTRL_NOTIMPL) <nl>  	    return M_PROPERTY_ERROR; <nl>   <nl> +	if (prog.aid < 0 && prog.vid < 0) { <nl> +	    mp_msg(MSGT_CPLAYER, MSGL_ERR, "Selected program contains no audio or video streams!\n"); <nl> +	    return M_PROPERTY_ERROR; <nl> +        } <nl>  	mp_property_do("switch_audio", M_PROPERTY_SET, &prog.aid, mpctx); <nl>  	mp_property_do("switch_video", M_PROPERTY_SET, &prog.vid, mpctx); <nl>  	return M_PROPERTY_OK;
@@ -146,6 +146,11 @@ static int init(sh_audio_t *sh_audio) <nl>    if(sh_audio->wf){ <nl>        // If the decoder uses the wrong number of channels all is lost anyway. <nl>        // sh_audio->channels=sh_audio->wf->nChannels; <nl> +      if (lavc_context->codec_id == CODEC_ID_AAC && <nl> +          sh_audio->samplerate == 2*sh_audio->wf->nSamplesPerSec) { <nl> +          mp_msg(MSGT_DECAUDIO, MSGL_WARN, <nl> +                 "Ignoring broken container sample rate for ACC with SBR\n"); <nl> +      } else <nl>        if (sh_audio->wf->nSamplesPerSec) <nl>        sh_audio->samplerate=sh_audio->wf->nSamplesPerSec; <nl>        if (sh_audio->wf->nAvgBytesPerSec)
@@ -411,6 +411,8 @@ static void handle_stream(demuxer_t *demuxer, AVFormatContext *avfc, int i) { <nl>                  type = 't'; <nl>              else if(codec->codec_id == CODEC_ID_SSA) <nl>                  type = 'a'; <nl> +            else if(codec->codec_id == CODEC_ID_DVD_SUBTITLE) <nl> +                type = 'v'; <nl>              else <nl>                  break; <nl>              sh_sub = new_sh_sub_sid(demuxer, i, priv->sub_streams);
@@ -45,7 +45,7 @@ static int pngRead( unsigned char * fname,txSample * bf ) <nl>   fseek(fp, 0, SEEK_END); <nl>   len = ftell(fp); <nl>   if (len > 50 * 1024 * 1024) return 2; <nl> - data = malloc(len + FF_INPUT_BUFFER_PADDING_SIZE); <nl> + data = av_malloc(len + FF_INPUT_BUFFER_PADDING_SIZE); <nl>   fseek(fp, 0, SEEK_SET); <nl>   fread(data, len, 1, fp); <nl>   fclose(fp); <nl> @@ -74,6 +74,7 @@ static int pngRead( unsigned char * fname,txSample * bf ) <nl>   avcodec_close(avctx); <nl>   av_freep(&frame); <nl>   av_freep(&avctx); <nl> + av_freep(&data); <nl>   <nl>   mp_dbg( MSGT_GPLAYER,MSGL_DBG2,"[png] filename: %s.\n",fname ); <nl>   mp_dbg( MSGT_GPLAYER,MSGL_DBG2,"[png]  size: %dx%d bits: %d\n",bf->Width,bf->Height,bf->BPP );
@@ -114,6 +114,7 @@ struct thread_q; <nl>   <nl>  struct work_restart { <nl>  	volatile unsigned long	restart; <nl> +	char			padding[128 - sizeof(unsigned long)]; <nl>  }; <nl>   <nl>  extern struct work_restart *work_restart;
@@ -193,7 +193,7 @@ int icarus_gets(unsigned char *buf, int fd, struct timeval *tv_finish, struct th <nl>  	}; <nl>  	struct epoll_event evr[2]; <nl>  	int epoll_timeout = ICARUS_READ_FAULT_DECISECONDS * 100; <nl> -	if (thr && thr->work_restart_fd != -1) <nl> +	if (thr && thr->work_restart_fd != -1) { <nl>  	epollfd = epoll_create(2); <nl>  	if (epollfd != -1) { <nl>  		if (-1 == epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &ev)) { <nl> @@ -213,6 +213,7 @@ int icarus_gets(unsigned char *buf, int fd, struct timeval *tv_finish, struct th <nl>  	} <nl>  	else <nl>  		applog(LOG_ERR, "Icarus: Error creating epoll"); <nl> +	} <nl>  #endif <nl>   <nl>  	// Read reply 1 byte at a time to get earliest tv_finish
@@ -323,6 +323,7 @@ static inline void string_elist_del(struct string_elist *item) <nl>  	if (item->free_me) <nl>  		free(item->string); <nl>  	list_del(&item->list); <nl> +	free(item); <nl>  } <nl>   <nl>  
@@ -4268,7 +4268,7 @@ static void *longpoll_thread(void *userdata) <nl>  				block_changed = BLOCK_LP; <nl>  				applog(LOG_WARNING, "LONGPOLL detected new block on network, waiting on fresh work"); <nl>  			} else { <nl> -				applog(LOG_WARNING, "LONGPOLL received after new block already detected"); <nl> +				applog(LOG_INFO, "LONGPOLL received after new block already detected"); <nl>  				block_changed = BLOCK_NONE; <nl>  			} <nl>  
@@ -1100,6 +1100,7 @@ bool initiate_stratum(struct pool *pool) <nl>  		goto out; <nl>  	} <nl>   <nl> +	free(pool->nonce1); <nl>  	pool->nonce1 = strdup(json_string_value(json_array_get(res_val, 1))); <nl>  	if (!pool->nonce1) { <nl>  		applog(LOG_WARNING, "Failed to get nonce1 in initiate_stratum");
@@ -7331,7 +7331,8 @@ static void *watchdog_thread(void __maybe_unused *userdata) <nl>  		for (i = 0; i < total_devices; ++i) { <nl>  			struct cgpu_info *cgpu = devices[i]; <nl>  			struct thr_info *thr; <nl> -			for (int thrid = 0; thrid < cgpu->threads; ++thrid) { <nl> +			int threadobjs = cgpu->threads ?: 1; <nl> +			for (int thrid = 0; thrid < threadobjs; ++thrid) { <nl>  				thr = cgpu->thr[thrid]; <nl>  				if (!thr->q->frozen) <nl>  					break;
@@ -530,6 +530,7 @@ _clState *initCl(unsigned int gpu, char *name, size_t nameSize) <nl>  	find = strstr(extensions, camo); <nl>  	if (find) <nl>  		clState->hasBitAlign = true; <nl> +	free(extensions); <nl>   <nl>  	/* Check for OpenCL >= 1.0 support, needed for global offset parameter usage. */ <nl>  	char * devoclver = malloc(1024); <nl> @@ -543,6 +544,7 @@ _clState *initCl(unsigned int gpu, char *name, size_t nameSize) <nl>  	find = strstr(devoclver, ocl10); <nl>  	if (!find) <nl>  		clState->hasOpenCL11plus = true; <nl> +	free(devoclver); <nl>   <nl>  	status = clGetDeviceInfo(devices[gpu], CL_DEVICE_PREFERRED_VECTOR_WIDTH_INT, sizeof(cl_uint), (void *)&preferred_vwidth, NULL); <nl>  	if (status != CL_SUCCESS) { <nl> @@ -878,6 +880,7 @@ build: <nl>  		char *log = malloc(logSize); <nl>  		status = clGetProgramBuildInfo(clState->program, devices[gpu], CL_PROGRAM_BUILD_LOG, logSize, log, NULL); <nl>  		applog(LOG_ERR, "%s", log); <nl> +		free(log); <nl>  		return NULL; <nl>  	} <nl>   <nl> @@ -1003,6 +1006,7 @@ built: <nl>  			char *log = malloc(logSize); <nl>  			status = clGetProgramBuildInfo(clState->program, devices[gpu], CL_PROGRAM_BUILD_LOG, logSize, log, NULL); <nl>  			applog(LOG_ERR, "%s", log); <nl> +			free(log); <nl>  			return NULL; <nl>  		} <nl>  	}
@@ -494,6 +494,16 @@ AcpiEvGpeDetect ( <nl>   <nl>              GpeRegisterInfo = &GpeBlock->RegisterInfo[i]; <nl>   <nl> +            /* <nl> +             * Optimization: If there are no GPEs enabled within this <nl> +             * register, we can safely ignore the entire register. <nl> +             */ <nl> +            if (!(GpeRegisterInfo->EnableForRun | <nl> +                  GpeRegisterInfo->EnableForWake)) <nl> +            { <nl> +                continue; <nl> +            } <nl> + <nl>              /* Read the Status Register */ <nl>   <nl>              Status = AcpiHwRead (&StatusReg, &GpeRegisterInfo->StatusAddress);
@@ -382,7 +382,7 @@ ACPI_STATUS <nl>  OsGetGlobalLock(void) <nl>  { <nl>      UINT32              GlobalLockReg; <nl> -    ACPI_STATUS         Status; <nl> +    ACPI_STATUS         Status = AE_OK; <nl>   <nl>   <nl>      if (FACS)
@@ -1051,6 +1051,9 @@ AcpiPsGetNextArg ( <nl>   <nl>              if (Arg->Common.AmlOpcode == AML_INT_METHODCALL_OP) <nl>              { <nl> +                /* Free method call op and corresponding namestring sub-ob */ <nl> + <nl> +                AcpiPsFreeOp (Arg->Common.Value.Arg); <nl>                  AcpiPsFreeOp (Arg); <nl>                  Arg = NULL; <nl>                  WalkState->ArgCount = 1;
@@ -1,7 +1,7 @@ <nl>  /****************************************************************************** <nl>   * <nl>   * Name: actypes.h - Common data types for the entire ACPI subsystem <nl> - *       $Revision: 1.134 $ <nl> + *       $Revision: 1.135 $ <nl>   * <nl>   *****************************************************************************/ <nl>   <nl> @@ -355,7 +355,7 @@ typedef UINT8                           OBJECT_TYPE_INTERNAL; <nl>   * This section contains object types that do not relate to the ACPI ObjectType operator. <nl>   * They are used for various internal purposes only.  If new predefined ACPI_TYPEs are <nl>   * added (via the ACPI specification), these internal types must move upwards. <nl> - * Also, values exceeding the largest official ACPI ObjectType must not overlap with  <nl> + * Also, values exceeding the largest official ACPI ObjectType must not overlap with <nl>   * defined AML opcodes. <nl>   */ <nl>  #define INTERNAL_TYPE_BEGIN             17
@@ -1,7 +1,7 @@ <nl>  /******************************************************************************* <nl>   * <nl>   * Module Name: dbdisply - debug display commands <nl> - *              $Revision: 1.81 $ <nl> + *              $Revision: 1.82 $ <nl>   * <nl>   ******************************************************************************/ <nl>   <nl> @@ -843,7 +843,7 @@ AcpiDbDisplayArguments (void) <nl>      AcpiOsPrintf ("Method [%4.4s] has %X arguments, max concurrency = %X\n", <nl>              Node->Name.Ascii, NumArgs, Concurrency); <nl>   <nl> -    for (i = 0; i < NumArgs; i++) <nl> +    for (i = 0; i < MTH_NUM_ARGS; i++) <nl>      { <nl>          ObjDesc = WalkState->Arguments[i].Object; <nl>          AcpiOsPrintf ("Arg%d: ", i);
@@ -1,7 +1,7 @@ <nl>  /****************************************************************************** <nl>   * <nl>   * Module Name: evgpe - General Purpose Event handling and dispatch <nl> - *              $Revision: 1.32 $ <nl> + *              $Revision: 1.34 $ <nl>   * <nl>   *****************************************************************************/ <nl>   <nl> @@ -9,7 +9,7 @@ <nl>   * <nl>   * 1. Copyright Notice <nl>   * <nl> - * Some or all of this work - Copyright (c) 1999 - 2003, Intel Corp. <nl> + * Some or all of this work - Copyright (c) 1999 - 2004, Intel Corp. <nl>   * All rights reserved. <nl>   * <nl>   * 2. License <nl> @@ -228,6 +228,12 @@ AcpiEvGpeDetect ( <nl>   <nl>      ACPI_FUNCTION_NAME ("EvGpeDetect"); <nl>   <nl> +    /* Check for the case where there are no GPEs */ <nl> + <nl> +    if (!GpeXruptList) <nl> +    { <nl> +        return (IntStatus); <nl> +    } <nl>   <nl>      /* Examine all GPE blocks attached to this interrupt level */ <nl>  
@@ -188,8 +188,8 @@ AcpiNsRootInitialize ( <nl>              continue; <nl>          } <nl>   <nl> -        Status = AcpiNsLookup (NULL, (char *) InitVal->Name, InitVal->Type, <nl> -            ACPI_IMODE_LOAD_PASS2, ACPI_NS_NO_UPSEARCH, <nl> +        Status = AcpiNsLookup (NULL, ACPI_CAST_PTR (char, InitVal->Name), <nl> +            InitVal->Type, ACPI_IMODE_LOAD_PASS2, ACPI_NS_NO_UPSEARCH, <nl>              NULL, &NewNode); <nl>          if (ACPI_FAILURE (Status)) <nl>          {
@@ -2,9 +2,8 @@ <nl>   * CDDL HEADER START <nl>   * <nl>   * The contents of this file are subject to the terms of the <nl> - * Common Development and Distribution License, Version 1.0 only <nl> - * (the "License").  You may not use this file except in compliance <nl> - * with the License. <nl> + * Common Development and Distribution License (the "License"). <nl> + * You may not use this file except in compliance with the License. <nl>   * <nl>   * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE <nl>   * or http://www.opensolaris.org/os/licensing. <nl> @@ -19,8 +18,9 @@ <nl>   * <nl>   * CDDL HEADER END <nl>   */ <nl> + <nl>  /* <nl> - * Copyright 2005 Sun Microsystems, Inc.  All rights reserved. <nl> + * Copyright 2006 Sun Microsystems, Inc.  All rights reserved. <nl>   * Use is subject to license terms. <nl>   */ <nl>   <nl> @@ -843,7 +843,7 @@ decpdu(int pdulen, asndefTp ASNDESC, int ctxnum) <nl>  	int		stlv;	/* sub-tlv length */ <nl>  	int		oix;	/* oid table index */ <nl>  	int		effnb;	/* effectively traced octet nb */ <nl> -	int		i, j; <nl> +	int		i = 0, j = 0; <nl>  	int		ai = -2; <nl>  	asndefTp SASNDESC = 0; <nl>  	asndefTp TMPDESC = 0;
@@ -477,6 +477,7 @@ mem_mdesc_fini(topo_mod_t *mod, md_mem_info_t *mem) <nl>  		next = dm->dm_next; <nl>  		topo_mod_strfree(mod, dm->dm_label); <nl>  		topo_mod_strfree(mod, dm->dm_serid); <nl> +		topo_mod_strfree(mod, dm->dm_part); <nl>  		topo_mod_free(mod, dm, sizeof (mem_dimm_map_t)); <nl>  	} <nl>  	for (bm = mem->mem_bank; bm != NULL; bm = cm) { <nl> @@ -487,7 +488,7 @@ mem_mdesc_fini(topo_mod_t *mod, md_mem_info_t *mem) <nl>  		hm = gm->mg_next; <nl>  		topo_mod_free(mod, gm, sizeof (mem_grp_t)); <nl>  	} <nl> -	for (sm = mem->mem_seg; dm != NULL; sm = snext) { <nl> +	for (sm = mem->mem_seg; sm != NULL; sm = snext) { <nl>  		snext = sm->sm_next; <nl>  		topo_mod_free(mod, sm, sizeof (mem_seg_map_t)); <nl>  	}
@@ -20,6 +20,7 @@ <nl>   */ <nl>   <nl>  /* <nl> + * Copyright 2014 Gary Mills <nl>   * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved. <nl>   */ <nl>   <nl> @@ -1767,7 +1768,7 @@ match_prop(xmlNodePtr cur, const xmlChar *attr, char *user_prop) <nl>  		return (B_FALSE); <nl>  	prop_result = xmlStrcmp(gotten_prop, (const xmlChar *) user_prop); <nl>  	xmlFree(gotten_prop); <nl> -	return ((prop_result == 0)); <nl> +	return ((prop_result == 0));	/* empty strings will match */ <nl>  } <nl>   <nl>  static int <nl> @@ -2255,7 +2256,7 @@ zonecfg_delete_nwif_core(zone_dochandle_t handle, struct zone_nwiftab *tabptr) <nl>  		phys_match = match_prop(cur, DTD_ATTR_PHYSICAL, <nl>  		    tabptr->zone_nwif_physical); <nl>   <nl> -		if ((addr_match || allowed_addr_match) && phys_match) { <nl> +		if (addr_match && allowed_addr_match && phys_match) { <nl>  			xmlUnlinkNode(cur); <nl>  			xmlFreeNode(cur); <nl>  			return (Z_OK);
@@ -20,7 +20,7 @@ <nl>   * CDDL HEADER END <nl>   */ <nl>  /* <nl> - * Copyright 2004 Sun Microsystems, Inc.  All rights reserved. <nl> + * Copyright 2005 Sun Microsystems, Inc.  All rights reserved. <nl>   * Use is subject to license terms. <nl>   */ <nl>   <nl> @@ -545,6 +545,7 @@ umem_setup_envvars(int invalid) <nl>  	static volatile enum { <nl>  		STATE_START, <nl>  		STATE_GETENV, <nl> +		STATE_DLOPEN, <nl>  		STATE_DLSYM, <nl>  		STATE_FUNC, <nl>  		STATE_DONE <nl> @@ -569,6 +570,10 @@ umem_setup_envvars(int invalid) <nl>  			where = "during getenv(3C) calls -- " <nl>  			    "getenv(3C) results ignored."; <nl>  			break; <nl> +		case STATE_DLOPEN: <nl> +			where = "during dlopen(3C) call -- " <nl> +			    "_umem_*() results ignored."; <nl> +			break; <nl>  		case STATE_DLSYM: <nl>  			where = "during dlsym(3C) call -- " <nl>  			    "_umem_*() results ignored."; <nl> @@ -609,6 +614,8 @@ umem_setup_envvars(int invalid) <nl>  	} <nl>   <nl>  #ifndef UMEM_STANDALONE <nl> +	state = STATE_DLOPEN; <nl> + <nl>  	/* get a handle to the "a.out" object */ <nl>  	if ((h = dlopen(0, RTLD_FIRST | RTLD_LAZY)) != NULL) { <nl>  		for (cur_env = umem_envvars; cur_env->env_name != NULL;
@@ -433,7 +433,7 @@ void TgtFCHBAPort::sendRLS(uint64_t destWWN, <nl>  	fctio.fctio_obuf = (uint64_t)(uintptr_t)new uchar_t[*pRspBufferSize]; <nl>  	fctio.fctio_olen = *pRspBufferSize; <nl>   <nl> -	if (fctio.fctio_obuf == NULL) { <nl> +	if (fctio.fctio_obuf == 0) { <nl>  	    log.noMemory(); <nl>  	    throw InternalError(); <nl>  	} <nl> @@ -441,7 +441,7 @@ void TgtFCHBAPort::sendRLS(uint64_t destWWN, <nl>  	fct_ioctl(FCTIO_CMD, &fctio); <nl>  	memcpy(pRspBuffer, (uchar_t *)(uintptr_t)fctio.fctio_obuf,  <nl>  	       *pRspBufferSize); <nl> -	if (fctio.fctio_obuf != NULL) { <nl> +	if (fctio.fctio_obuf != 0) { <nl>  	    delete((uchar_t *)(uintptr_t)fctio.fctio_obuf); <nl>  	} <nl>  }
@@ -598,7 +598,7 @@ mutex_init(kmutex_t *mp, char *name, kmutex_type_t type, void *ibc) <nl>  			    "aligned; caller %s+%lx in module %s. " <nl>  			    "This is unsupported and may cause a panic. " <nl>  			    "Please report this to the kernel module supplier.", <nl> -			    lp, MUTEX_ALIGN, <nl> +			    (void *)lp, MUTEX_ALIGN, <nl>  			    funcname ? funcname : "unknown", offset, <nl>  			    mod_containing_pc(caller())); <nl>  			misalign_cnt++;
@@ -162,11 +162,13 @@ auto_lookup_aux(fnnode_t *fnp, char *name, cred_t *cred) <nl>  	bzero(&link, sizeof (link)); <nl>  	error = auto_lookup_request(fnip, name, &link, TRUE, &mountreq, cred); <nl>  	if (!error) { <nl> -		if (link.link != NULL || link.link != '\0') { <nl> +		if (link.link != NULL) { <nl> +			error = ENOENT; <nl>  			/* <nl>  			 * This node should be a symlink <nl>  			 */ <nl> -			error = auto_perform_link(fnp, &link, cred); <nl> +			if (*link.link != '\0') <nl> +				error = auto_perform_link(fnp, &link, cred); <nl>  		} else if (mountreq) { <nl>  			/* <nl>  			 * The automount daemon is requesting a mount,
@@ -601,6 +601,7 @@ getattr_exit: <nl>  	if (pwbuf->pwd) free(pwbuf->pwd); <nl>  	if (pwbuf->pwd_scratch) free(pwbuf->pwd_scratch); <nl>  	if (pwbuf->spwd) free(pwbuf->spwd); <nl> +	if (pwbuf->spwd_scratch) free(pwbuf->spwd_scratch); <nl>  	free(pwbuf); <nl>   <nl>  	return (res);
@@ -2109,6 +2109,14 @@ pmcs_next_sibling(pmcs_phy_t *phyp) <nl>  			break; <nl>  		} <nl>   <nl> +		/* <nl> +		 * If this PHY's sibling is NULL and it's a root phy, <nl> +		 * we're done. <nl> +		 */ <nl> +		if (parent.level == 0) { <nl> +			return (NULL); <nl> +		} <nl> + <nl>  		phyp = phyp->parent; <nl>  	} <nl>  
@@ -208,7 +208,8 @@ slice_get_stats(descriptor_t *dp, int stat_type, int *errp) <nl>  	} <nl>   <nl>  	if ((*errp = add_inuse(dp->name, stats)) != 0) { <nl> -	    return (NULL); <nl> +		nvlist_free(stats); <nl> +		return (NULL); <nl>  	} <nl>   <nl>  	/* if no cluster use, check for a use of the local name */ <nl> @@ -248,6 +249,7 @@ slice_get_stats(descriptor_t *dp, int stat_type, int *errp) <nl>  				sizeof (localpath)); <nl>   <nl>  			    if ((*errp = add_inuse(localpath, stats)) != 0) { <nl> +				nvlist_free(stats); <nl>  				return (NULL); <nl>  			    } <nl>  
@@ -547,6 +547,7 @@ void ppce500_init(PPCE500Params *params) <nl>   <nl>      /* Fixup Memory size on a alignment boundary */ <nl>      ram_size &= ~(RAM_SIZES_ALIGN - 1); <nl> +    params->ram_size = ram_size; <nl>   <nl>      /* Register Memory */ <nl>      memory_region_init_ram(ram, "mpc8544ds.ram", ram_size);
@@ -674,6 +674,7 @@ static int serial_post_load(void *opaque, int version_id) <nl>      } <nl>      /* Initialize fcr via setter to perform essential side-effects */ <nl>      serial_ioport_write(s, 0x02, s->fcr_vmstate); <nl> +    serial_update_parameters(s); <nl>      return 0; <nl>  } <nl>  
@@ -60,7 +60,7 @@ void tlb_fill(CPUCRISState *env, target_ulong addr, int is_write, int mmu_idx, <nl>      int ret; <nl>   <nl>      D_LOG("%s pc=%x tpc=%x ra=%p\n", __func__, <nl> -          env->pc, env->debug1, (void *)retaddr); <nl> +          env->pc, env->pregs[PR_EDA], (void *)retaddr); <nl>      ret = cpu_cris_handle_mmu_fault(env, addr, is_write, mmu_idx); <nl>      if (unlikely(ret)) { <nl>          if (retaddr) {
@@ -146,8 +146,8 @@ static void ide_identify(IDEState *s) <nl>      put_le16(p + 68, 120); <nl>      put_le16(p + 80, 0xf0); /* ata3 -> ata6 supported */ <nl>      put_le16(p + 81, 0x16); /* conforms to ata5 */ <nl> -    /* 14=NOP supported, 0=SMART supported */ <nl> -    put_le16(p + 82, (1 << 14) | 1); <nl> +    /* 14=NOP supported, 5=WCACHE supported, 0=SMART supported */ <nl> +    put_le16(p + 82, (1 << 14) | (1 << 5) | 1); <nl>      /* 13=flush_cache_ext,12=flush_cache,10=lba48 */ <nl>      put_le16(p + 83, (1 << 14) | (1 << 13) | (1 <<12) | (1 << 10)); <nl>      /* 14=set to 1, 1=SMART self test, 0=SMART error logging */
@@ -143,8 +143,8 @@ typedef struct { <nl>   <nl>  static inline int num_effective_busses(XilinxSPIPS *s) <nl>  { <nl> -    return (s->regs[R_LQSPI_STS] & LQSPI_CFG_SEP_BUS && <nl> -            s->regs[R_LQSPI_STS] & LQSPI_CFG_TWO_MEM) ? s->num_busses : 1; <nl> +    return (s->regs[R_LQSPI_CFG] & LQSPI_CFG_SEP_BUS && <nl> +            s->regs[R_LQSPI_CFG] & LQSPI_CFG_TWO_MEM) ? s->num_busses : 1; <nl>  } <nl>   <nl>  static void xilinx_spips_update_cs_lines(XilinxSPIPS *s)
@@ -1059,6 +1059,9 @@ static int mode_sense_page(SCSIDiskState *s, int page, uint8_t **p_outbuf, <nl>   <nl>      case MODE_PAGE_R_W_ERROR: <nl>          length = 10; <nl> +        if (page_control == 1) { /* Changeable Values */ <nl> +            break; <nl> +        } <nl>          p[0] = 0x80; /* Automatic Write Reallocation Enabled */ <nl>          if (s->qdev.type == TYPE_ROM) { <nl>              p[1] = 0x20; /* Read Retry Count */
@@ -146,7 +146,7 @@ static void ga_log(const gchar *domain, GLogLevelFlags level, <nl>      } <nl>   <nl>      level &= G_LOG_LEVEL_MASK; <nl> -    if (g_strcmp0(domain, "syslog") == 0) { <nl> +    if (domain && strcmp(domain, "syslog") == 0) { <nl>          syslog(LOG_INFO, "%s: %s", level_str, msg); <nl>      } else if (level & s->log_level) { <nl>          g_get_current_time(&time);
@@ -479,6 +479,9 @@ static uint16_t nvme_get_feature(NvmeCtrl *n, NvmeCmd *cmd, NvmeRequest *req) <nl>          req->cqe.result = <nl>              cpu_to_le32((n->num_queues - 1) | ((n->num_queues - 1) << 16)); <nl>          break; <nl> +    case NVME_VOLATILE_WRITE_CACHE: <nl> +        req->cqe.result = cpu_to_le32(1); <nl> +        break; <nl>      default: <nl>          return NVME_INVALID_FIELD | NVME_DNR; <nl>      }
@@ -630,9 +630,7 @@ static void spapr_populate_cpu_dt(CPUState *cs, void *fdt, int offset, <nl>      uint32_t cpufreq = kvm_enabled() ? kvmppc_get_clockfreq() : 1000000000; <nl>      uint32_t page_sizes_prop[64]; <nl>      size_t page_sizes_prop_size; <nl> -    QemuOpts *opts = qemu_opts_find(qemu_find_opts("smp-opts"), NULL); <nl> -    unsigned sockets = opts ? qemu_opt_get_number(opts, "sockets", 0) : 0; <nl> -    uint32_t cpus_per_socket = sockets ? (smp_cpus / sockets) : 1; <nl> +    uint32_t vcpus_per_socket = smp_threads * smp_cores; <nl>      uint32_t pft_size_prop[] = {0, cpu_to_be32(spapr->htab_shift)}; <nl>   <nl>      _FDT((fdt_setprop_cell(fdt, offset, "reg", index))); <nl> @@ -701,7 +699,7 @@ static void spapr_populate_cpu_dt(CPUState *cs, void *fdt, int offset, <nl>      } <nl>   <nl>      _FDT((fdt_setprop_cell(fdt, offset, "ibm,chip-id", <nl> -                           cs->cpu_index / cpus_per_socket))); <nl> +                           cs->cpu_index / vcpus_per_socket))); <nl>   <nl>      _FDT((fdt_setprop(fdt, offset, "ibm,pft-size", <nl>                        pft_size_prop, sizeof(pft_size_prop))));
@@ -3171,7 +3171,8 @@ static const MonitorDef monitor_defs[] = { <nl>      { NULL }, <nl>  }; <nl>   <nl> -static void expr_error(Monitor *mon, const char *fmt, ...) <nl> +static void GCC_FMT_ATTR(2, 3) QEMU_NORETURN <nl> +expr_error(Monitor *mon, const char *fmt, ...) <nl>  { <nl>      va_list ap; <nl>      va_start(ap, fmt);
@@ -442,6 +442,7 @@ static void smc91c111_writeb(void *opaque, hwaddr offset, <nl>              return; <nl>          case 12: /* Early receive.  */ <nl>              s->ercv = value & 0x1f; <nl> +            return; <nl>          case 13: <nl>              /* Ignore.  */ <nl>              return;
@@ -134,6 +134,8 @@ petalogix_ml605_init(QEMUMachineInitArgs *args) <nl>      dma = qdev_create(NULL, "xlnx.axi-dma"); <nl>   <nl>      /* FIXME: attach to the sysbus instead */ <nl> +    object_property_add_child(qdev_get_machine(), "xilinx-eth", OBJECT(eth0), <nl> +                              NULL); <nl>      object_property_add_child(qdev_get_machine(), "xilinx-dma", OBJECT(dma), <nl>                                NULL); <nl>  
@@ -2918,6 +2918,7 @@ out: <nl>      g_free(dummy); <nl>      if (err) { <nl>          qerror_report_err(err); <nl> +        error_free(err); <nl>          return -1; <nl>      } <nl>      return 0;
@@ -1184,7 +1184,7 @@ static int64_t coroutine_fn vmdk_co_get_block_status(BlockDriverState *bs, <nl>          break; <nl>      case VMDK_OK: <nl>          ret = BDRV_BLOCK_DATA; <nl> -        if (extent->file == bs->file) { <nl> +        if (extent->file == bs->file && !extent->compressed) { <nl>              ret |= BDRV_BLOCK_OFFSET_VALID | offset; <nl>          } <nl>  
@@ -15540,9 +15540,10 @@ static void decode_opc (CPUMIPSState *env, DisasContext *ctx, int *is_branch) <nl>  } <nl>   <nl>  static inline void <nl> -gen_intermediate_code_internal (CPUMIPSState *env, TranslationBlock *tb, <nl> -                                int search_pc) <nl> +gen_intermediate_code_internal(MIPSCPU *cpu, TranslationBlock *tb, <nl> +                               bool search_pc) <nl>  { <nl> +    CPUMIPSState *env = &cpu->env; <nl>      DisasContext ctx; <nl>      target_ulong pc_start; <nl>      uint16_t *gen_opc_end; <nl> @@ -15698,12 +15699,12 @@ done_generating: <nl>   <nl>  void gen_intermediate_code (CPUMIPSState *env, struct TranslationBlock *tb) <nl>  { <nl> -    gen_intermediate_code_internal(env, tb, 0); <nl> +    gen_intermediate_code_internal(mips_env_get_cpu(env), tb, false); <nl>  } <nl>   <nl>  void gen_intermediate_code_pc (CPUMIPSState *env, struct TranslationBlock *tb) <nl>  { <nl> -    gen_intermediate_code_internal(env, tb, 1); <nl> +    gen_intermediate_code_internal(mips_env_get_cpu(env), tb, true); <nl>  } <nl>   <nl>  static void fpu_dump_state(CPUMIPSState *env, FILE *f, fprintf_function fpu_fprintf,
@@ -539,6 +539,7 @@ static void kbd_write_mouse(KBDState *s, int val) <nl>              s->mouse_sample_rate = 100; <nl>              s->mouse_resolution = 2; <nl>              s->mouse_status = 0; <nl> +            s->mouse_type = 0; <nl>              kbd_queue(s, AUX_ACK, 1); <nl>              kbd_queue(s, 0xaa, 1); <nl>              kbd_queue(s, s->mouse_type, 1);
@@ -479,6 +479,13 @@ void qmp_migrate_set_cache_size(int64_t value, Error **errp) <nl>          return; <nl>      } <nl>   <nl> +    /* Cache should not be larger than guest ram size */ <nl> +    if (value > ram_bytes_total()) { <nl> +        error_set(errp, QERR_INVALID_PARAMETER_VALUE, "cache size", <nl> +                  "exceeds guest ram size "); <nl> +        return; <nl> +    } <nl> + <nl>      new_size = xbzrle_cache_resize(value); <nl>      if (new_size < 0) { <nl>          error_set(errp, QERR_INVALID_PARAMETER_VALUE, "cache size",
@@ -1878,6 +1878,7 @@ static void framebuffer_update_request(VncState *vs, int incremental, <nl>          return; <nl>      } <nl>   <nl> +    vs->force_update = 1; <nl>      vnc_set_area_dirty(vs->dirty, width, height, x, y, w, h); <nl>  } <nl>  
@@ -2452,6 +2452,7 @@ static gint machine_class_cmp(gconstpointer a, gconstpointer b) <nl>          mc = find_machine(name); <nl>      } <nl>      if (mc) { <nl> +        g_slist_free(machines); <nl>          return mc; <nl>      } <nl>      if (name && !is_help_option(name)) {
@@ -62,7 +62,6 @@ static void <nl>  petalogix_s3adsp1800_init(MachineState *machine) <nl>  { <nl>      ram_addr_t ram_size = machine->ram_size; <nl> -    const char *cpu_model = machine->cpu_model; <nl>      DeviceState *dev; <nl>      MicroBlazeCPU *cpu; <nl>      DriveInfo *dinfo; <nl> @@ -73,11 +72,8 @@ petalogix_s3adsp1800_init(MachineState *machine) <nl>      qemu_irq irq[32]; <nl>      MemoryRegion *sysmem = get_system_memory(); <nl>   <nl> -    /* init CPUs */ <nl> -    if (cpu_model == NULL) { <nl> -        cpu_model = "microblaze"; <nl> -    } <nl> -    cpu = cpu_mb_init(cpu_model); <nl> +    cpu = MICROBLAZE_CPU(object_new(TYPE_MICROBLAZE_CPU)); <nl> +    object_property_set_bool(OBJECT(cpu), true, "realized", &error_abort); <nl>   <nl>      /* Attach emulated BRAM through the LMB.  */ <nl>      memory_region_init_ram(phys_lmb_bram, NULL,
@@ -352,11 +352,19 @@ static void ebus_mmio_mapfunc(PCIDevice *pci_dev, int region_num, <nl>      } <nl>  } <nl>   <nl> +static void dummy_isa_irq_handler(void *opaque, int n, int level) <nl> +{ <nl> +} <nl> + <nl>  /* EBUS (Eight bit bus) bridge */ <nl>  static void <nl>  pci_ebus_init(PCIBus *bus, int devfn) <nl>  { <nl> +    qemu_irq *isa_irq; <nl> + <nl>      pci_create_simple(bus, devfn, "ebus"); <nl> +    isa_irq = qemu_allocate_irqs(dummy_isa_irq_handler, NULL, 16); <nl> +    isa_bus_irqs(isa_irq); <nl>  } <nl>   <nl>  static int
@@ -125,21 +125,21 @@ static inline void tcg_out8(TCGContext *s, uint8_t v) <nl>  static inline void tcg_out16(TCGContext *s, uint16_t v) <nl>  { <nl>      uint8_t *p = s->code_ptr; <nl> -    *(uint16_t *)p = v; <nl> +    memcpy(p, &v, sizeof(v)); <nl>      s->code_ptr = p + 2; <nl>  } <nl>   <nl>  static inline void tcg_out32(TCGContext *s, uint32_t v) <nl>  { <nl>      uint8_t *p = s->code_ptr; <nl> -    *(uint32_t *)p = v; <nl> +    memcpy(p, &v, sizeof(v)); <nl>      s->code_ptr = p + 4; <nl>  } <nl>   <nl>  static inline void tcg_out64(TCGContext *s, uint64_t v) <nl>  { <nl>      uint8_t *p = s->code_ptr; <nl> -    *(uint64_t *)p = v; <nl> +    memcpy(p, &v, sizeof(v)); <nl>      s->code_ptr = p + 8; <nl>  } <nl>  
@@ -2255,6 +2255,8 @@ static CharDriverState *qemu_chr_open_udp(QemuOpts *opts) <nl>   <nl>      fd = inet_dgram_opts(opts, &local_err); <nl>      if (fd < 0) { <nl> +        qerror_report_err(local_err); <nl> +        error_free(local_err); <nl>          return NULL; <nl>      } <nl>      return qemu_chr_open_udp_fd(fd);
@@ -186,6 +186,7 @@ static void leon3_generic_hw_init(MachineState *machine) <nl>          fprintf(stderr, "Can't read bios image %s\n", filename); <nl>          exit(1); <nl>      } <nl> +    g_free(filename); <nl>   <nl>      /* Can directly load an application. */ <nl>      if (kernel_filename != NULL) {
@@ -108,6 +108,11 @@ static int qcow2_read_extensions(BlockDriverState *bs, uint64_t start_offset, <nl>  #ifdef DEBUG_EXT <nl>          printf("ext.magic = 0x%x\n", ext.magic); <nl>  #endif <nl> +        if (ext.len > end_offset - offset) { <nl> +            error_report("Header extension too large"); <nl> +            return -EINVAL; <nl> +        } <nl> + <nl>          switch (ext.magic) { <nl>          case QCOW2_EXT_MAGIC_END: <nl>              return 0;
@@ -110,8 +110,8 @@ static void *qpa_thread_out (void *arg) <nl>              return NULL; <nl>          } <nl>   <nl> +        pa->live = 0; <nl>          pa->rpos = rpos; <nl> -        pa->live -= decr; <nl>          pa->decr += decr; <nl>      } <nl>  
@@ -559,7 +559,7 @@ static void baum_chr_read(void *opaque) <nl>      if (ret == -1 && (brlapi_errno != BRLAPI_ERROR_LIBCERR || errno != EINTR)) { <nl>          brlapi_perror("baum: brlapi_readKey"); <nl>          brlapi__closeConnection(baum->brlapi); <nl> -        free(baum->brlapi); <nl> +        qemu_free(baum->brlapi); <nl>          baum->brlapi = NULL; <nl>      } <nl>  } <nl> @@ -622,8 +622,8 @@ fail: <nl>      qemu_free_timer(baum->cellCount_timer); <nl>      brlapi__closeConnection(handle); <nl>  fail_handle: <nl> -    free(handle); <nl> -    free(chr); <nl> -    free(baum); <nl> +    qemu_free(handle); <nl> +    qemu_free(chr); <nl> +    qemu_free(baum); <nl>      return NULL; <nl>  }
@@ -322,7 +322,7 @@ static VMStateInfo vmstate_info_pci_config = { <nl>   <nl>  static int get_pci_irq_state(QEMUFile *f, void *pv, size_t size) <nl>  { <nl> -    PCIDevice *s = container_of(pv, PCIDevice, config); <nl> +    PCIDevice *s = container_of(pv, PCIDevice, irq_state); <nl>      uint32_t irq_state[PCI_NUM_PINS]; <nl>      int i; <nl>      for (i = 0; i < PCI_NUM_PINS; ++i) { <nl> @@ -344,7 +344,7 @@ static int get_pci_irq_state(QEMUFile *f, void *pv, size_t size) <nl>  static void put_pci_irq_state(QEMUFile *f, void *pv, size_t size) <nl>  { <nl>      int i; <nl> -    PCIDevice *s = container_of(pv, PCIDevice, config); <nl> +    PCIDevice *s = container_of(pv, PCIDevice, irq_state); <nl>   <nl>      for (i = 0; i < PCI_NUM_PINS; ++i) { <nl>          qemu_put_be32(f, pci_irq_state(s, i));
@@ -889,7 +889,7 @@ static int aio_flush_request(void *opaque) <nl>      return !QLIST_EMPTY(&s->outstanding_aio_head); <nl>  } <nl>   <nl> -#ifdef _WIN32 <nl> +#if !defined(SOL_TCP) || !defined(TCP_CORK) <nl>   <nl>  static int set_cork(int fd, int v) <nl>  {
@@ -82,12 +82,13 @@ struct m_hdr { <nl>  struct mbuf { <nl>  	struct	m_hdr m_hdr; <nl>  	Slirp *slirp; <nl> +	bool	arp_requested; <nl> +	uint64_t expiration_date; <nl> +	/* start of dynamic buffer area, must be last element */ <nl>  	union M_dat { <nl>  		char	m_dat_[1]; /* ANSI don't like 0 sized arrays */ <nl>  		char	*m_ext_; <nl>  	} M_dat; <nl> -    bool     arp_requested; <nl> -    uint64_t expiration_date; <nl>  }; <nl>   <nl>  #define m_next		m_hdr.mh_next
@@ -2209,10 +2209,12 @@ void tlb_set_page(CPUState *env, target_ulong vaddr, <nl>         watchpoint trap routines.  */ <nl>      QTAILQ_FOREACH(wp, &env->watchpoints, entry) { <nl>          if (vaddr == (wp->vaddr & TARGET_PAGE_MASK)) { <nl> -            iotlb = io_mem_watch + paddr; <nl> -            /* TODO: The memory case can be optimized by not trapping <nl> -               reads of pages with a write breakpoint.  */ <nl> -            address |= TLB_MMIO; <nl> +            /* Avoid trapping reads of pages with a write breakpoint. */ <nl> +            if ((prot & PAGE_WRITE) || (wp->flags & BP_MEM_READ)) { <nl> +                iotlb = io_mem_watch + paddr; <nl> +                address |= TLB_MMIO; <nl> +                break; <nl> +            } <nl>          } <nl>      } <nl>  
@@ -661,6 +661,10 @@ static int vmdk_open_vmdk4(BlockDriverState *bs, <nl>      } <nl>      extent->compressed = <nl>          le16_to_cpu(header.compressAlgorithm) == VMDK4_COMPRESSION_DEFLATE; <nl> +    if (extent->compressed) { <nl> +        g_free(s->create_type); <nl> +        s->create_type = g_strdup("streamOptimized"); <nl> +    } <nl>      extent->has_marker = le32_to_cpu(header.flags) & VMDK4_FLAG_MARKER; <nl>      extent->version = le32_to_cpu(header.version); <nl>      extent->has_zero_grain = le32_to_cpu(header.flags) & VMDK4_FLAG_ZERO_GRAIN;
@@ -37,7 +37,7 @@ void *__lzma_wrap_alloc(void *unused, size_t size) { <nl>  	return NULL; <nl>      } <nl>   <nl> -    return cli_malloc(size); <nl> +    return cli_calloc(1, size); <nl>  } <nl>  void __lzma_wrap_free(void *unused, void *freeme) { <nl>      UNUSEDPARAM(unused);
@@ -2,6 +2,7 @@ <nl>   *  Extract RAR archives <nl>   * <nl>   *  Copyright (C) 2005-2006 trog@uncon.org <nl> + *  Patches added by Sourcefire, Inc. Copyright (C) 2007-2013 <nl>   * <nl>   *  This code is based on the work of Alexander L. Roshal (C) <nl>   * <nl> @@ -994,6 +995,9 @@ static void rarvm_optimize(struct rarvm_prepared_program *prg) <nl>  			default: /* make gcc happy */ <nl>  				break; <nl>  		} <nl> +		if (cmd->op_code > VM_PRINT) { <nl> +			continue; /* don't re-optimize, unlikely anyway */ <nl> +		} <nl>  		if ((vm_cmdflags[cmd->op_code] & VMCF_CHFLAGS) == 0) { <nl>  			continue; <nl>  		}
@@ -1101,6 +1101,7 @@ int rar_unpack(int fd, int method, int solid, unpack_data_t *unpack_data) <nl>  	default: <nl>  		retval = rar_unpack29(fd, solid, unpack_data); <nl>  		if(retval == FALSE) { <nl> +		    rarvm_free(&unpack_data->rarvm_data); <nl>  		    retval = rar_unpack20(fd, solid, unpack_data); <nl>  		    if(retval == FALSE) <nl>  			retval = rar_unpack15(fd, solid, unpack_data);
@@ -175,7 +175,7 @@ static void vba56_test_middle(int fd) <nl>  		cli_dbgmsg("middle found\n"); <nl>  } <nl>   <nl> -/* return count of valid strings found */ <nl> +/* return count of valid strings found, 0 on error */ <nl>  static int <nl>  vba_read_project_strings(int fd, int big_endian) <nl>  { <nl> @@ -189,8 +189,10 @@ vba_read_project_strings(int fd, int big_endian) <nl>          char *name; <nl>   <nl>          /* if no initial name length, exit */ <nl> -        if(getnewlength && !read_uint16(fd, &length, big_endian)) <nl> -            return 0; <nl> +        if(getnewlength && !read_uint16(fd, &length, big_endian)) { <nl> +            ret = 0; <nl> +            break; <nl> +        } <nl>          getnewlength = 0; <nl>   <nl>          /* if too short, break */
@@ -1881,6 +1881,10 @@ int qtm_decompress(struct qtm_stream *qtm, uint32_t out_bytes) { <nl>      if ((frame_start + QTM_FRAME_SIZE) < frame_end) { <nl>        frame_end = frame_start + QTM_FRAME_SIZE; <nl>      } <nl> +    if (frame_end < window_posn) { <nl> +	cli_dbgmsg("qtm_decompress: window position beyond end of frame\n"); <nl> +	return qtm->error = CL_EFORMAT; <nl> +    } <nl>   <nl>      while (window_posn < frame_end) { <nl>        QTM_GET_SYMBOL(qtm->model7, selector);
@@ -921,7 +921,7 @@ int cli_fmap_scandesc(cli_ctx *ctx, cli_file_t ftype, uint8_t ftonly, struct cli <nl>                      type = ret; <nl>              } <nl>   <nl> -            if(hdb && !SCAN_ALL) { <nl> +            if(hdb) { <nl>                  const void *data = buff + maxpatlen * (offset!=0); <nl>                  uint32_t data_len = bytes - maxpatlen * (offset!=0); <nl>  
@@ -1696,7 +1696,6 @@ int cli_bytecode_runhook(cli_ctx *cctx, const struct cl_engine *engine, struct c <nl>  	cli_dbgmsg("Bytecode %u returned %u\n", bc->id, ret); <nl>  	if (!ret) { <nl>  	    char *tempfile; <nl> -	    cli_ctx *cctx = ctx->ctx; <nl>  	    int fd = cli_bytecode_context_getresult_file(ctx, &tempfile); <nl>  	    if (fd != -1) { <nl>  		if (cctx && cctx->engine->keeptmp) <nl> @@ -1806,7 +1805,7 @@ void cli_bytecode_describe(const struct cli_bc *bc) <nl>      } <nl>      printf("\tnumber of functions: %u\n\tnumber of types: %u\n", <nl>  	   bc->num_func, bc->num_types); <nl> -    printf("\tnumber of global constants: %u\n", bc->num_globals); <nl> +    printf("\tnumber of global constants: %u\n", (unsigned)bc->num_globals); <nl>      printf("\tnumber of debug nodes: %u\n", bc->dbgnode_cnt); <nl>      printf("\tbytecode APIs used:"); <nl>      cols = 0; /* remaining */
@@ -175,6 +175,7 @@ int cli_parse_add(struct cli_matcher *root, const char *virname, const char *hex <nl>  		if((n = cli_strtok(pt, 2, "-"))) { /* strict check */ <nl>  		    error = 1; <nl>  		    free(n); <nl> +		    break; <nl>  		} <nl>  	    } <nl>  	}
@@ -445,8 +445,12 @@ messageAddArgument(message *m, const char *arg) <nl>  			 * FIXME: Bounce message handling is corrupting the in <nl>  			 * core copies of headers <nl>  			 */ <nl> -			cli_dbgmsg("Possible data corruption fixed\n"); <nl> -			p[8] = '='; <nl> +                        if (strlen(p) > 8) { <nl> +                            cli_dbgmsg("Possible data corruption fixed\n"); <nl> +                            p[8] = '='; <nl> +                        } else { <nl> +                            cli_dbgmsg("Possible data corruption not fixed\n"); <nl> +                        } <nl>  		} else { <nl>  			if(*p) <nl>  				cli_dbgmsg("messageAddArgument, '%s' contains no '='\n", p); <nl> @@ -682,7 +686,7 @@ messageFindArgument(const message *m, const char *variable) <nl>  				cli_dbgmsg("messageFindArgument: no '=' sign found in MIME header '%s' (%s)\n", variable, messageGetArgument(m, i)); <nl>  				return NULL; <nl>  			} <nl> -			if((*++ptr == '"') && (strchr(&ptr[1], '"') != NULL)) { <nl> +			if((strlen(ptr) > 2) && (*++ptr == '"') && (strchr(&ptr[1], '"') != NULL)) { <nl>  				/* Remove any quote characters */ <nl>  				char *ret = cli_strdup(++ptr); <nl>  				char *p;
@@ -317,8 +317,8 @@ bool Silf::runGraphite(Segment *seg, uint8 firstPass, uint8 lastPass) const <nl>   <nl>      if (dbgout) <nl>      { <nl> -    	char version[16]; <nl> -    	snprintf(version, sizeof version, "%d.%d.%d", <nl> +    	char version[64]; <nl> +    	sprintf(version, "%d.%d.%d", <nl>      			GR2_VERSION_MAJOR, GR2_VERSION_MINOR, GR2_VERSION_BUGFIX); <nl>      	*dbgout << json::object <nl>      				<< "version"	<< version
@@ -565,9 +565,10 @@ int fdisk_assign_device(struct fdisk_context *cxt, <nl>   <nl>  	fd = open(fname, (readonly ? O_RDONLY : O_RDWR ) | O_CLOEXEC); <nl>  	if (fd < 0) <nl> -		return -errno; <nl> +		goto fail; <nl>   <nl> -	fstat(fd, &cxt->dev_st); <nl> +	if (fstat(fd, &cxt->dev_st) != 0) <nl> +		goto fail; <nl>   <nl>  	cxt->readonly = readonly; <nl>  	cxt->dev_fd = fd; <nl> @@ -597,6 +598,8 @@ int fdisk_assign_device(struct fdisk_context *cxt, <nl>  			      fname, readonly ? "READ-ONLY" : "READ-WRITE")); <nl>  	return 0; <nl>  fail: <nl> +	if (fd >= 0) <nl> +		close(fd); <nl>  	DBG(CXT, ul_debugobj(cxt, "failed to assign device")); <nl>  	return -errno; <nl>  }
@@ -983,8 +983,15 @@ int main(int argc, char **argv) <nl>  		free(device); <nl>  		device = disk; <nl>  		disk = NULL; <nl> -	} else <nl> +	} else { <nl> +		struct stat st; <nl> + <nl> +		if (stat(device, &st) != 0 || !S_ISBLK(st.st_mode)) <nl> +			errx(EXIT_FAILURE, _("%s: not found mountpoint or device " <nl> +					"with the given name"), device); <nl> + <nl>  		verbose(_("%s: is whole-disk device"), device); <nl> +	} <nl>   <nl>  	if (F_option == 0 && is_hotpluggable(device) == 0) <nl>  		errx(EXIT_FAILURE, _("%s: is not hot-pluggable device"), device);
@@ -199,7 +199,7 @@ static FILE *dump(FILE *in, const char *filename, int follow, FILE *out) <nl>  	struct utmp ut; <nl>   <nl>  	if (follow) <nl> -		fseek(in, -10 * sizeof(ut), SEEK_END); <nl> +		ignore_result( fseek(in, -10 * sizeof(ut), SEEK_END) ); <nl>   <nl>  	while (fread(&ut, sizeof(ut), 1, in) == 1) <nl>  		print_utline(ut, out);
@@ -66,6 +66,8 @@ static char *bindirs[] = { <nl>     "/usr/etc", <nl>     "/lib", <nl>     "/usr/lib", <nl> +   "/lib64", <nl> +   "/usr/lib64", <nl>     "/usr/games", <nl>     "/usr/games/bin", <nl>     "/usr/games/lib", <nl> @@ -74,7 +76,7 @@ static char *bindirs[] = { <nl>     "/usr/TeX/bin", <nl>     "/usr/tex/bin", <nl>     "/usr/interviews/bin/LINUX", <nl> -    <nl> + <nl>     "/usr/X11R6/bin", <nl>     "/usr/X386/bin", <nl>     "/usr/bin/X11", <nl> @@ -149,7 +151,6 @@ main(int argc, char **argv) { <nl>  	setlocale(LC_ALL, ""); <nl>  	bindtextdomain(PACKAGE, LOCALEDIR); <nl>  	textdomain(PACKAGE); <nl> -	 <nl>   <nl>  	argc--, argv++; <nl>  	if (argc == 0) { <nl> @@ -328,7 +329,7 @@ findin(char *dir, char *cp) { <nl>  		goto noglob; <nl>   <nl>  	l = strlen(dir); <nl> -	if (l < sizeof(dirbuf)) { 	/* refuse excessively long names */ <nl> +	if (l < sizeof(dirbuf)) {	/* refuse excessively long names */ <nl>  		strcpy (dirbuf, dir); <nl>  		d = index(dirbuf, '*'); <nl>  		*d = 0;
@@ -218,7 +218,9 @@ long old_style_option(int *argc, char **argv) <nl>  			lines = strtol_or_err(argv[i] + 1, <nl>  					_("failed to parse number of lines")); <nl>  			nargs--; <nl> -			memmove(argv + i, argv + i + 1, sizeof(char *) * nargs); <nl> +			if (nargs - i) <nl> +				memmove(argv + i, argv + i + 1, <nl> +						sizeof(char *) * (nargs - i)); <nl>  		} else <nl>  			i++; <nl>  	}
@@ -985,7 +985,7 @@ static void open_tty(char *tty, struct termios *tp, struct options *op) <nl>  	 * In case of a virtual console the ioctl TIOCMGET fails and <nl>  	 * the error number will be set to EINVAL. <nl>  	 */ <nl> -	if (ioctl(STDIN_FILENO, TIOCMGET, &serial) < 0 && (errno = EINVAL)) { <nl> +	if (ioctl(STDIN_FILENO, TIOCMGET, &serial) < 0 && (errno == EINVAL)) { <nl>  		op->flags |= F_VCONSOLE; <nl>  		if (!op->term) <nl>  			op->term = DEFAULT_VCTERM;
@@ -218,7 +218,7 @@ static void get_sem_elements(struct sem_data *p) <nl>  { <nl>  	size_t i; <nl>   <nl> -	if (!p || !p->sem_nsems || p->sem_perm.id < 0) <nl> +	if (!p || !p->sem_nsems || p->sem_nsems > SIZE_MAX || p->sem_perm.id < 0) <nl>  		return; <nl>   <nl>  	p->elements = xcalloc(p->sem_nsems, sizeof(struct sem_elem));
@@ -337,6 +337,7 @@ static int prepare_helper_from_options(struct libmnt_context *cxt, <nl>  	char *suffix = NULL; <nl>  	const char *opts; <nl>  	size_t valsz; <nl> +	int rc; <nl>   <nl>  	if (mnt_context_is_nohelpers(cxt)) <nl>  		return 0; <nl> @@ -354,7 +355,10 @@ static int prepare_helper_from_options(struct libmnt_context *cxt, <nl>   <nl>  	DBG(CXT, ul_debugobj(cxt, "umount: umount.%s %s requested", suffix, name)); <nl>   <nl> -	return mnt_context_prepare_helper(cxt, "umount", suffix); <nl> +	rc = mnt_context_prepare_helper(cxt, "umount", suffix); <nl> +	free(suffix); <nl> + <nl> +	return rc; <nl>  } <nl>   <nl>  /*
@@ -321,7 +321,7 @@ void SearchEngine::on_search_button_clicked(){ <nl>    // Reload environment variables (proxy) <nl>    searchProcess->setEnvironment(QProcess::systemEnvironment()); <nl>   <nl> -  QString pattern = search_pattern->text().trimmed(); <nl> +  const QString pattern = search_pattern->text().trimmed(); <nl>    // No search pattern entered <nl>    if(pattern.isEmpty()){ <nl>      QMessageBox::critical(0, tr("Empty search pattern"), tr("Please type a search pattern first")); <nl> @@ -331,7 +331,9 @@ void SearchEngine::on_search_button_clicked(){ <nl>    currentSearchTab=new SearchTab(this); <nl>    connect(currentSearchTab->header(), SIGNAL(sectionResized(int, int, int)), this, SLOT(propagateSectionResized(int,int,int))); <nl>    all_tab.append(currentSearchTab); <nl> -  tabWidget->addTab(currentSearchTab, pattern); <nl> +  QString tabName = pattern; <nl> +  tabName.replace(QRegExp("&{1}"), "&&"); <nl> +  tabWidget->addTab(currentSearchTab, tabName); <nl>    tabWidget->setCurrentWidget(currentSearchTab); <nl>  #if QT_VERSION < 0x040500 <nl>    closeTab_button->setEnabled(true);
@@ -332,8 +332,8 @@ protected slots: <nl>    } <nl>   <nl>    void torrentAdded(QModelIndex index) { <nl> +    Q_ASSERT(index.isValid()); <nl>      if(!index.isValid()) return; <nl> -    //Q_ASSERT(index.isValid()); <nl>      QString label = transferList->getSourceModel()->index(index.row(), TR_LABEL).data(Qt::DisplayRole).toString().trimmed(); <nl>      qDebug("New torrent was added with label: %s", label.toLocal8Bit().data()); <nl>      if(!label.isEmpty()) { <nl> @@ -357,6 +357,7 @@ protected slots: <nl>    } <nl>   <nl>    void torrentAboutToBeDeleted(QModelIndex index) { <nl> +    if(!index.isValid()) return; <nl>      Q_ASSERT(index.isValid()); <nl>      QString label = transferList->model()->index(index.row(), TR_LABEL).data(Qt::DisplayRole).toString().trimmed(); <nl>      if(!label.isEmpty()) {
@@ -866,7 +866,7 @@ void MainWindow::createKeyboardShortcuts() <nl>      connect(switchRSSShortcut, &QShortcut::activated, this, static_cast<Func>(&MainWindow::displayRSSTab)); <nl>      QShortcut *switchExecutionLogShortcut = new QShortcut(Qt::ALT + Qt::Key_4, this); <nl>      connect(switchExecutionLogShortcut, &QShortcut::activated, this, &MainWindow::displayExecutionLogTab); <nl> -    QShortcut *switchSearchFilterShortcut = new QShortcut(QKeySequence::Find, this); <nl> +    QShortcut *switchSearchFilterShortcut = new QShortcut(QKeySequence::Find, m_transferListWidget); <nl>      connect(switchSearchFilterShortcut, &QShortcut::activated, this, &MainWindow::focusSearchFilter); <nl>   <nl>      m_ui->actionDocumentation->setShortcut(QKeySequence::HelpContents);
@@ -76,7 +76,7 @@ static int trylock(const std::multimap<std::wstring, unsigned long long int> &pi <nl>  	rotptr = pModule + 0x62F81C; <nl>  	// stateptr = pModule + 0x690A3C; <nl>  	 <nl> -	if (avatar_pos[1] == 0) <nl> +	if (posptr[1] == 0) <nl>  		return true; <nl>   <nl>  	float pos[3];
@@ -266,6 +266,7 @@ void ServerHandler::hostnameResolved() { <nl>  	// error code in case our hostname lookup failed. <nl>  	if (records.isEmpty()) { <nl>  		exit(-1); <nl> +		return; <nl>  	} <nl>   <nl>  	// Create the list of target host:port pairs
@@ -590,9 +590,12 @@ bool AudioOutput::mix(void *outbuff, unsigned int nsamp) { <nl>  			if (validListener && ((aop->fPos[0] != 0.0f) || (aop->fPos[1] != 0.0f) || (aop->fPos[2] != 0.0f))) { <nl>  				float dir[3] = { aop->fPos[0] - g.p->fPosition[0], aop->fPos[1] - g.p->fPosition[1], aop->fPos[2] - g.p->fPosition[2] }; <nl>  				float len = sqrtf(dir[0] * dir[0] + dir[1] * dir[1] + dir[2] * dir[2]); <nl> -				dir[0] /= len; <nl> -				dir[1] /= len; <nl> -				dir[2] /= len; <nl> +				if(len > 0.0f) <nl> +				{ <nl> +					dir[0] /= len; <nl> +					dir[1] /= len; <nl> +					dir[2] /= len; <nl> +				} <nl>  				/* <nl>  								qWarning("Voice pos: %f %f %f", aop->fPos[0], aop->fPos[1], aop->fPos[2]); <nl>  								qWarning("Voice dir: %f %f %f", dir[0], dir[1], dir[2]);
@@ -790,7 +790,7 @@ void MainWindow::on_qmUser_aboutToShow() { <nl>  	qmUser->addAction(qaUserComment); <nl>  	qmUser->addAction(qaUserTextMessage); <nl>   <nl> -	if (p && (p->iId < 0) & (g.pPermissions & (ChanACL::Register | ChanACL::Write))) { <nl> +	if (p && (p->iId < 0) && (g.pPermissions & (ChanACL::Register | ChanACL::Write))) { <nl>  		qmUser->addSeparator(); <nl>  		qmUser->addAction(qaUserRegister); <nl>  	}
@@ -256,8 +256,8 @@ int BandwidthRecord::bytesPerSec() { <nl>   <nl>  void Server::run() { <nl>  	qint32 len; <nl> -	char encrypted[65535]; <nl> -	char buffer[65535]; <nl> +	char encrypted[65536]; <nl> +	char buffer[65536]; <nl>   <nl>  	quint32 msgType = 0; <nl>  	unsigned int uiSession = 0;
@@ -650,7 +650,7 @@ static int fsmUtime(const char *path, mode_t mode, time_t mtime) <nl>      return rc; <nl>  } <nl>   <nl> -static int fsmVerify(const char *path, rpmfi fi) <nl> +static int fsmVerify(const char *path, rpmfi fi, const struct stat *fsb) <nl>  { <nl>      int rc; <nl>      int saveerrno = errno; <nl> @@ -675,11 +675,14 @@ static int fsmVerify(const char *path, rpmfi fi) <nl>      } else if (S_ISDIR(mode)) { <nl>          if (S_ISDIR(dsb.st_mode)) return 0; <nl>          if (S_ISLNK(dsb.st_mode)) { <nl> +	    uid_t luid = dsb.st_uid; <nl>              rc = fsmStat(path, 0, &dsb); <nl>              if (rc == RPMERR_ENOENT) rc = 0; <nl>              if (rc) return rc; <nl>              errno = saveerrno; <nl> -            if (S_ISDIR(dsb.st_mode)) return 0; <nl> +	    /* Only permit directory symlinks by target owner and root */ <nl> +            if (S_ISDIR(dsb.st_mode) && (luid == 0 || luid == fsb->st_uid)) <nl> +		    return 0; <nl>          } <nl>      } else if (S_ISLNK(mode)) { <nl>          if (S_ISLNK(dsb.st_mode)) { <nl> @@ -921,7 +924,7 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files, <nl>  	    } <nl>  	    /* Assume file does't exist when tmp suffix is in use */ <nl>  	    if (!suffix) { <nl> -		rc = fsmVerify(fpath, fi); <nl> +		rc = fsmVerify(fpath, fi, &sb); <nl>  	    } else { <nl>  		rc = (action == FA_TOUCH) ? 0 : RPMERR_ENOENT; <nl>  	    }
@@ -273,14 +273,8 @@ static int compareMacros(const void *ap, const void *bp) <nl>  static void expandMacroTable(struct MacroContext *mc) <nl>  { <nl>      mc->macrosAllocated += MACRO_CHUNK_SIZE; <nl> -    if (! mc->macrosAllocated) { <nl> -	mc->macroTable = malloc(sizeof(*(mc->macroTable)) * <nl> -				mc->macrosAllocated); <nl> -	mc->firstFree = 0; <nl> -    } else { <nl> -	mc->macroTable = realloc(mc->macroTable, sizeof(*(mc->macroTable)) * <nl> -				 mc->macrosAllocated); <nl> -    } <nl> +    mc->macroTable = realloc(mc->macroTable, sizeof(*(mc->macroTable)) * <nl> +			     mc->macrosAllocated); <nl>  } <nl>   <nl>  /***********************************************************************/
@@ -39,6 +39,9 @@ int rpmvercmp(const char * a, const char * b) <nl>  	while (*one && !xisalnum(*one)) one++; <nl>  	while (*two && !xisalnum(*two)) two++; <nl>   <nl> +	/* If we ran to the end of either, we are finished with the loop */ <nl> +	if (!(*one && *two)) break; <nl> + <nl>  	str1 = one; <nl>  	str2 = two; <nl>   <nl> @@ -64,9 +67,13 @@ int rpmvercmp(const char * a, const char * b) <nl>  	*str2 = '\0'; <nl>  /*@=boundswrite@*/ <nl>   <nl> +	/* this cannot happen, as we previously tested to make sure that */ <nl> +	/* the first string has a non-null segment */ <nl> +	if (one == str1) return -1;	/* arbitrary */ <nl> + <nl>  	/* take care of the case where the two version segments are */ <nl>  	/* different types: one numeric, the other alpha (i.e. empty) */ <nl> -	if (one == str1) return -1;	/* arbitrary */ <nl> +	/* numeric segments are always newer than alpha segments */ <nl>  	/* XXX See patch #60884 (and details) from bugzilla #50977. */ <nl>  	if (two == str2) return (isnum ? 1 : -1); <nl>  
@@ -40,7 +40,7 @@ <nl>   * <nl>   */ <nl>  /* <nl> - * $Id: mboxlist.c,v 1.183 2002/04/08 01:46:38 leg Exp $ <nl> + * $Id: mboxlist.c,v 1.184 2002/04/08 21:01:04 rjs3 Exp $ <nl>   */ <nl>   <nl>  #include <config.h> <nl> @@ -822,7 +822,7 @@ int mboxlist_deletemailbox(const char *name, int isadmin, char *userid, <nl>   <nl>      /* remove from mupdate */ <nl>      /* xxx this can lead to inconsistancies if the later stuff fails */ <nl> -    if (!r && !local_only && config_mupdate_server) { <nl> +    if (!r && !isremote && !local_only && config_mupdate_server) { <nl>  	/* delete the mailbox in MUPDATE */ <nl>  	r = mupdate_connect(config_mupdate_server, NULL, &mupdate_h, NULL); <nl>  	if(r) {
@@ -39,7 +39,7 @@ <nl>   * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. <nl>   */ <nl>   <nl> -/* $Id: proxyd.c,v 1.42 2000/09/30 01:17:54 leg Exp $ */ <nl> +/* $Id: proxyd.c,v 1.43 2000/10/09 03:28:50 leg Exp $ */ <nl>   <nl>  #include <config.h> <nl>   <nl> @@ -788,15 +788,17 @@ static struct backend *proxyd_findinboxserver(void) <nl>  { <nl>      char inbox[MAX_MAILBOX_NAME]; <nl>      int r; <nl> -    char *server; <nl> -    struct backend *s; <nl> +    char *server = NULL; <nl> +    struct backend *s = NULL; <nl>   <nl>      if (strlen(proxyd_userid) > MAX_MAILBOX_NAME - 30) return NULL; <nl>      strcpy(inbox, "user."); <nl>      strcat(inbox, proxyd_userid); <nl>  	 <nl>      r = mlookup(inbox, &server, NULL, NULL); <nl> -    s = proxyd_findserver(server); <nl> +    if (!r) { <nl> +	s = proxyd_findserver(server); <nl> +    } <nl>   <nl>      return s; <nl>  }
@@ -933,6 +933,8 @@ EXPORTED void jmap_closembox(jmap_req_t *req, struct mailbox **mboxp) <nl>      struct _mboxcache_rec *rec = NULL; <nl>      int i; <nl>   <nl> +    if (!mboxp || !*mboxp) return; <nl> + <nl>      for (i = 0; i < req->mboxes->count; i++) { <nl>          rec = (struct _mboxcache_rec*) ptrarray_nth(req->mboxes, i); <nl>          if (rec->mbox == *mboxp)
@@ -5188,6 +5188,7 @@ int sync_update_mailbox(struct sync_folder *local, <nl>      flags |= SYNC_FLAG_ISREPEAT; <nl>   <nl>      if (r == IMAP_AGAIN) { <nl> +        local->batchsize = 0; /* don't batch the re-update, means sync to 2.4 will still work after fullsync */ <nl>          r = mailbox_full_update(local, reserve_list, sync_be, flags); <nl>          if (!r) r = update_mailbox_once(local, remote, topart, <nl>                                          reserve_list, sync_be, flags);
@@ -1977,19 +1977,19 @@ static unsigned propcmp(icalcomponent *oldical, icalcomponent *newical, <nl>   <nl>          do { <nl>              str = icalproperty_get_value_as_string(oldprop); <nl> -            old_crc ^= crc32_cstring(str); <nl> +            if (str) old_crc ^= crc32_cstring(str); <nl>          } while ((oldprop = icalcomponent_get_next_property(oldical, kind))); <nl>   <nl>          do { <nl>              str = icalproperty_get_value_as_string(newprop); <nl> -            new_crc ^= crc32_cstring(str); <nl> +            if (str) new_crc ^= crc32_cstring(str); <nl>          } while ((newprop = icalcomponent_get_next_property(newical, kind))); <nl>   <nl>          return (old_crc != new_crc); <nl>      } <nl>      else { <nl> -        return (strcmp(icalproperty_get_value_as_string(oldprop), <nl> -                       icalproperty_get_value_as_string(newprop)) != 0); <nl> +        return (strcmpsafe(icalproperty_get_value_as_string(oldprop), <nl> +                           icalproperty_get_value_as_string(newprop)) != 0); <nl>      } <nl>  } <nl>  
@@ -1239,7 +1239,7 @@ struct body *body; <nl>  } <nl>   <nl>  /* Append character 'c' to 'ibuf' */ <nl> -#define PUTIBUF(ibuf,c) (((ibuf)->left || message_ibuf_ensure((ibuf),1)),(*((ibuf)->end)++ = (c))) <nl> +#define PUTIBUF(ibuf,c) (((ibuf)->left || message_ibuf_ensure((ibuf),1)),((ibuf)->left--),(*((ibuf)->end)++ = (c))) <nl>   <nl>  /* <nl>   * Write the IMAP envelope for 'body' to 'ibuf' <nl> @@ -1871,7 +1871,7 @@ int len; <nl>  { <nl>      char *s; <nl>   <nl> -    if (len >= ibuf->left) return; <nl> +    if (len <= ibuf->left) return; <nl>      if (len < IBUFGROWSIZE) len = IBUFGROWSIZE; <nl>   <nl>      s = ibuf->start - sizeof(bit32);
@@ -8896,6 +8896,9 @@ static void _email_bulkupdate_exec_setflags(struct email_bulkupdate *bulk) <nl>                          if (!seqset_ismember(del_seenseq, uid)) <nl>                              seqset_add(new_seenseq, uid, 1); <nl>                  } <nl> +                else { <nl> +                    seqset_join(new_seenseq, plan->old_seenseq); <nl> +                } <nl>                  if (add_seenseq->len) <nl>                      seqset_join(new_seenseq, add_seenseq); <nl>                  struct seendata sd = SEENDATA_INITIALIZER;
@@ -2773,6 +2773,10 @@ int mailbox_create(const char *name, <nl>      mailbox->i.options = options; <nl>      mailbox->i.highestmodseq = 1; <nl>   <nl> +    /* initialise header size field so appends calculate the <nl> +     * correct map size */ <nl> +    mailbox->index_size = INDEX_HEADER_SIZE; <nl> + <nl>      mailbox->header_dirty = 1; <nl>      if (!uniqueid) { <nl>  	mailbox_make_uniqueid(mailbox);
@@ -284,8 +284,8 @@ int service_main(int argc, char **argv, <nl>      struct io_count *io_count_stop; <nl>   <nl>      if (config_iolog) { <nl> -	io_count_start = malloc (sizeof (struct io_count)); <nl> -	io_count_stop = malloc (sizeof (struct io_count)); <nl> +	io_count_start = xmalloc (sizeof (struct io_count)); <nl> +	io_count_stop = xmalloc (sizeof (struct io_count)); <nl>  	read_io_count(io_count_start); <nl>      } <nl>  
@@ -756,6 +756,9 @@ EXPORTED void buf_ensure(struct buf *buf, size_t n) <nl>      /* protect against wrap */ <nl>      assert(newlen >= buf->len); <nl>   <nl> +    if (buf->alloc >= newlen) <nl> +	return; <nl> + <nl>      if (buf->alloc) { <nl>  	buf->s = xrealloc(buf->s, newlen); <nl>      }
@@ -1191,6 +1191,7 @@ struct apply_rock { <nl>      void *data; <nl>      char lastname[MAX_MAILBOX_PATH+1]; <nl>      int sawuser; <nl> +    unsigned int nseen; <nl>  }; <nl>   <nl>  static int apply_cb(char *name, int matchlen, <nl> @@ -1236,6 +1237,7 @@ static int apply_cb(char *name, int matchlen, <nl>  	goto out; <nl>   <nl>      r = arock->proc(state, arock->data); <nl> +    arock->nseen++; <nl>   <nl>  out: <nl>      annotate_state_unset_scope(state); <nl> @@ -1268,6 +1270,9 @@ int annotate_apply_mailboxes(annotate_state_t *state, <nl>  					   state->auth_state, <nl>  					   apply_cb, &arock); <nl>   <nl> +    if (!r && !arock.nseen) <nl> +	r = IMAP_MAILBOX_NONEXISTENT; <nl> + <nl>      return r; <nl>  } <nl>  
@@ -2177,7 +2177,7 @@ static int getContactList(struct jmap_req *req) <nl>      /* Prepare response. */ <nl>      json_t *contactList = json_pack("{}"); <nl>      json_object_set_new(contactList, "accountId", json_string(req->userid)); <nl> -    json_object_set_new(contactList, "state", jmap_getstate(MBTYPE_CALENDAR, req)); <nl> +    json_object_set_new(contactList, "state", jmap_getstate(MBTYPE_ADDRESSBOOK, req)); <nl>      json_object_set_new(contactList, "position", json_integer(rock.position)); <nl>      json_object_set_new(contactList, "total", json_integer(rock.total)); <nl>      json_object_set(contactList, "contactIds", rock.contacts);
@@ -39,7 +39,7 @@ <nl>   * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING <nl>   * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. <nl>   * <nl> - * $Id: sync_support.c,v 1.22 2009/03/31 04:11:20 brong Exp $ <nl> + * $Id: sync_support.c,v 1.23 2009/12/15 03:30:33 brong Exp $ <nl>   */ <nl>   <nl>  #include <config.h> <nl> @@ -330,6 +330,9 @@ void sync_flags_meta_to_list(struct sync_flags_meta *meta, char **flagname) <nl>              !strcmp(flagname[n], meta->flagname[n])) <nl>              continue; <nl>           <nl> +	if (flagname[n]) <nl> +	    free(flagname[n]); <nl> + <nl>          if (meta->flagname[n]) <nl>              flagname[n] = xstrdup(meta->flagname[n]); <nl>          else
@@ -92,6 +92,12 @@ EXPORTED void seqset_add(struct seqset *seq, unsigned num, int ismember) <nl>  { <nl>      if (!seq) return; <nl>   <nl> +    /* there are some cases where we want to make sure something is added <nl> +     * as an initial value and then re-add it again later, so if we get <nl> +     * the same number multiple times, that's OK */ <nl> +    if (ismember && num == seq->prev && seq->len && seq->set[seq->len-1].high == num) <nl> +        return; <nl> + <nl>      if (num <= seq->prev) <nl>          fatal("numbers out of order", EC_SOFTWARE); <nl>  
@@ -140,9 +140,9 @@ void free_test(test_t *t) <nl>  	break; <nl>   <nl>      case HEADER: <nl> +	free(t->u.h.comparator); <nl>  	strarray_free(t->u.h.sl); <nl>  	strarray_free(t->u.h.pl); <nl> -	 <nl>  	break; <nl>   <nl>      case ADDRESS: <nl> @@ -153,6 +153,7 @@ void free_test(test_t *t) <nl>  	break; <nl>   <nl>      case BODY: <nl> +	free(t->u.b.comparator); <nl>  	strarray_free(t->u.b.content_types); <nl>  	strarray_free(t->u.b.pl); <nl>  	break;
@@ -39,7 +39,7 @@ <nl>   * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. <nl>   */ <nl>   <nl> -/* $Id: proxyd.c,v 1.39 2000/06/20 18:10:36 leg Exp $ */ <nl> +/* $Id: proxyd.c,v 1.40 2000/07/03 20:16:09 leg Exp $ */ <nl>   <nl>  #include <config.h> <nl>   <nl> @@ -3005,7 +3005,7 @@ void cmd_find(char *tag, char *namespace, char *pattern) <nl>   <nl>      if (!strcmp(namespace, "mailboxes")) { <nl>  	mboxlist_findsub(pattern, proxyd_userisadmin, proxyd_userid, <nl> -			 proxyd_authstate, mailboxdata, NULL); <nl> +			 proxyd_authstate, mailboxdata, NULL, 1); <nl>      } else if (!strcmp(namespace, "all.mailboxes")) { <nl>  	mboxlist_findall(pattern, proxyd_userisadmin, proxyd_userid, <nl>  			 proxyd_authstate, mailboxdata, NULL);
@@ -3604,6 +3604,8 @@ static int usersubs_cb(void *rock, const char *key, size_t keylen, <nl>          mboxname_userownsmailbox(mbrock->userid, mboxname)) return 0; <nl>   <nl>      r = mboxlist_lookup(mboxname, &mbrock->mbentry, NULL); <nl> +    if (r == IMAP_MAILBOX_NONEXISTENT) return 0; <nl> + <nl>      if (r) { <nl>          syslog(LOG_INFO, "mboxlist_lookup(%s) failed: %s", <nl>                 mboxname, error_message(r));
@@ -5113,6 +5113,7 @@ int meth_mkcol(struct transaction_t *txn, void *params) <nl>          /* Start construction of our mkcol/mkcalendar response */ <nl>          buf_appendcstr(&txn->buf, "-response"); <nl>          root = init_xml_response(buf_cstring(&txn->buf), NS_REQ_ROOT, root, ns); <nl> +        buf_reset(&txn->buf); <nl>          if (!root) { <nl>              ret = HTTP_SERVER_ERROR; <nl>              txn->error.desc = "Unable to create XML response\r\n";
@@ -1,4 +1,4 @@ <nl> -/* $Id: acconfig.h,v 1.31 2002/03/18 15:14:16 ken3 Exp $ */ <nl> +/* $Id: acconfig.h,v 1.32 2002/04/05 19:12:54 rjs3 Exp $ */ <nl>  /*  <nl>   * Copyright (c) 2000 Carnegie Mellon University.  All rights reserved. <nl>   * <nl> @@ -173,6 +173,7 @@ typedef int rlim_t; <nl>   <nl>  /* getaddrinfo things */ <nl>  #include <netdb.h> <nl> +#include <sys/types.h> <nl>  #include <sys/socket.h> <nl>   <nl>  #ifndef HAVE_GETADDRINFO
@@ -3321,14 +3321,17 @@ void clusterCron(void) { <nl>          int changed = 0; <nl>   <nl>          if (prev_ip == NULL && curr_ip != NULL) changed = 1; <nl> -        if (prev_ip != NULL && curr_ip == NULL) changed = 1; <nl> -        if (prev_ip && curr_ip && strcmp(prev_ip,curr_ip)) changed = 1; <nl> +        else if (prev_ip != NULL && curr_ip == NULL) changed = 1; <nl> +        else if (prev_ip && curr_ip && strcmp(prev_ip,curr_ip)) changed = 1; <nl>   <nl>          if (changed) { <nl>              if (prev_ip) zfree(prev_ip); <nl> - <nl>              prev_ip = curr_ip; <nl> + <nl>              if (curr_ip) { <nl> +                /* We always take a copy of the previous IP address, by <nl> +                 * duplicating the string. This way later we can check if <nl> +                 * the address really changed. */ <nl>                  prev_ip = zstrdup(prev_ip); <nl>                  strncpy(myself->ip,server.cluster_announce_ip,NET_IP_STR_LEN); <nl>                  myself->ip[NET_IP_STR_LEN-1] = '\0';
@@ -1236,6 +1236,7 @@ int RM_ZsetIncrby(RedisModuleKey *key, double score, RedisModuleString *ele, int <nl>      if (key->value && key->value->type != OBJ_ZSET) return REDISMODULE_ERR; <nl>      if (key->value == NULL) moduleCreateEmptyKey(key,REDISMODULE_KEYTYPE_ZSET); <nl>      if (flagsptr) flags = RM_ZsetAddFlagsToCoreFlags(*flagsptr); <nl> +    flags |= ZADD_INCR; <nl>      if (zsetAdd(key->value,score,ele->ptr,&flags,newscore) == 0) { <nl>          if (flagsptr) *flagsptr = 0; <nl>          return REDISMODULE_ERR;
@@ -398,6 +398,7 @@ void clusterNodeDelFailureReport(clusterNode *node, clusterNode *sender) { <nl>   <nl>      /* Remove the failure report. */ <nl>      listDelNode(l,ln); <nl> +    clusterNodeCleanupFailureReports(node); <nl>  } <nl>   <nl>  /* Remove failure reports that are too old, where too old means reasonably
@@ -1344,7 +1344,9 @@ static void repl(void) { <nl>                      } <nl>   <nl>                      elapsed = mstime()-start_time; <nl> -                    if (elapsed >= 500) { <nl> +                    if (elapsed >= 500 && <nl> +                        config.output == OUTPUT_STANDARD) <nl> +                    { <nl>                          printf("(%.2fs)\n",(double)elapsed/1000); <nl>                      } <nl>                  }
@@ -99,7 +99,7 @@ int rdbSaveLen(rio *rdb, uint32_t len) { <nl>          buf[0] = (REDIS_RDB_32BITLEN<<6); <nl>          if (rdbWriteRaw(rdb,buf,1) == -1) return -1; <nl>          len = htonl(len); <nl> -        if (rdbWriteRaw(rdb,&len,4) == -4) return -1; <nl> +        if (rdbWriteRaw(rdb,&len,4) == -1) return -1; <nl>          nwritten = 1+4; <nl>      } <nl>      return nwritten;
@@ -818,7 +818,7 @@ void sentinelCallClientReconfScript(sentinelRedisInstance *master, int role, cha <nl>  sentinelRedisInstance *createSentinelRedisInstance(char *name, int flags, char *hostname, int port, int quorum, sentinelRedisInstance *master) { <nl>      sentinelRedisInstance *ri; <nl>      sentinelAddr *addr; <nl> -    dict *table; <nl> +    dict *table = NULL; <nl>      char slavename[128], *sdsname; <nl>   <nl>      redisAssert(flags & (SRI_MASTER|SRI_SLAVE|SRI_SENTINEL));
@@ -346,14 +346,19 @@ void msetnxCommand(redisClient *c) { <nl>  } <nl>   <nl>  void incrDecrCommand(redisClient *c, long long incr) { <nl> -    long long value; <nl> +    long long value, oldvalue; <nl>      robj *o; <nl>   <nl>      o = lookupKeyWrite(c->db,c->argv[1]); <nl>      if (o != NULL && checkType(c,o,REDIS_STRING)) return; <nl>      if (getLongLongFromObjectOrReply(c,o,&value,NULL) != REDIS_OK) return; <nl>   <nl> +    oldvalue = value; <nl>      value += incr; <nl> +    if ((incr < 0 && value > oldvalue) || (incr > 0 && value < oldvalue)) { <nl> +        addReplyError(c,"increment or decrement would overflow"); <nl> +        return; <nl> +    } <nl>      o = createStringObjectFromLongLong(value); <nl>      dbReplace(c->db,c->argv[1],o); <nl>      touchWatchedKey(c->db,c->argv[1]);
@@ -443,6 +443,7 @@ void redisProcessCallbacks(redisAsyncContext *ac) { <nl>              if (((redisReply*)reply)->type == REDIS_REPLY_ERROR) { <nl>                  c->err = REDIS_ERR_OTHER; <nl>                  snprintf(c->errstr,sizeof(c->errstr),"%s",((redisReply*)reply)->str); <nl> +                c->reader->fn->freeObject(reply); <nl>                  __redisAsyncDisconnect(ac); <nl>                  return; <nl>              }
@@ -353,6 +353,7 @@ void loadServerConfigFromString(char *config) { <nl>                  goto loaderr; <nl>              } <nl>          } else if (!strcasecmp(argv[0],"masterauth") && argc == 2) { <nl> +            zfree(server.masterauth); <nl>              server.masterauth = zstrdup(argv[1]); <nl>          } else if (!strcasecmp(argv[0],"slave-serve-stale-data") && argc == 2) { <nl>              if ((server.repl_serve_stale_data = yesnotoi(argv[1])) == -1) {
@@ -49,6 +49,7 @@ get_next: <nl>              if(len<=0){ <nl>                  i=END_NOT_FOUND; <nl>              }else{ <nl> +                s->state=0; <nl>                  i-= s->header_size -1; <nl>                  s->remaining_size = len; <nl>                  if(!new_frame_start || pc->index+i<=0){
@@ -230,10 +230,9 @@ static int flashsv_encode_frame(AVCodecContext *avctx, uint8_t *buf, <nl>          pfptr = s->previous_frame; <nl>   <nl>      /* Check the placement of keyframes */ <nl> -    if (avctx->gop_size > 0) { <nl> -        if (avctx->frame_number >= s->last_key_frame + avctx->gop_size) { <nl> -            I_frame = 1; <nl> -        } <nl> +    if (avctx->gop_size > 0 && <nl> +        avctx->frame_number >= s->last_key_frame + avctx->gop_size) { <nl> +        I_frame = 1; <nl>      } <nl>   <nl>      if (buf_size < s->image_width * s->image_height * 3) {
@@ -519,7 +519,7 @@ static int udp_open(URLContext *h, const char *uri, int flags) <nl>              goto fail; <nl>      } <nl>   <nl> -    if ((s->is_multicast || !s->local_port) && (h->flags & AVIO_FLAG_READ)) <nl> +    if ((s->is_multicast || s->local_port < 0) && (h->flags & AVIO_FLAG_READ)) <nl>          s->local_port = port; <nl>   <nl>      if (localaddr[0])
@@ -88,7 +88,7 @@ static int mpjpeg_read_probe(AVProbeData *p) <nl>          return AVERROR(ENOMEM); <nl>   <nl>      if (p->buf_size < 2 || p->buf[0] != '-' || p->buf[1] != '-') <nl> -        return 0; <nl> +        goto end; <nl>   <nl>      while (!pb->eof_reached) { <nl>          ret = get_line(pb, line, sizeof(line)); <nl> @@ -101,7 +101,7 @@ static int mpjpeg_read_probe(AVProbeData *p) <nl>              break; <nl>          } <nl>      } <nl> - <nl> +end: <nl>      av_free(pb); <nl>   <nl>      return ret;
@@ -1858,7 +1858,8 @@ static int mov_write_ilst_tag(AVIOContext *pb, MOVMuxContext *mov, <nl>      mov_write_string_metadata(s, pb, "\251wrt", "composer" , 1); <nl>      mov_write_string_metadata(s, pb, "\251alb", "album"    , 1); <nl>      mov_write_string_metadata(s, pb, "\251day", "date"     , 1); <nl> -    mov_write_string_tag(pb, "\251too", LIBAVFORMAT_IDENT, 0, 1); <nl> +    if (!mov_write_string_metadata(s, pb, "\251too", "encoding_tool", 1)) <nl> +        mov_write_string_tag(pb, "\251too", LIBAVFORMAT_IDENT, 0, 1); <nl>      mov_write_string_metadata(s, pb, "\251cmt", "comment"  , 1); <nl>      mov_write_string_metadata(s, pb, "\251gen", "genre"    , 1); <nl>      mov_write_string_metadata(s, pb, "\251cpy", "copyright", 1);
@@ -1758,7 +1758,7 @@ static void estimate_timings_from_bit_rate(AVFormatContext *ic) <nl>          for(i=0;i<ic->nb_streams;i++) { <nl>              st = ic->streams[i]; <nl>              if (st->codec->bit_rate > 0) { <nl> -                if (INT_MAX - st->codec->bit_rate > bit_rate) { <nl> +                if (INT_MAX - st->codec->bit_rate < bit_rate) { <nl>                      bit_rate = 0; <nl>                      break; <nl>                  }
@@ -1661,7 +1661,11 @@ static int mov_finalize_stsd_codec(MOVContext *c, AVIOContext *pb, <nl>      switch (st->codec->codec_id) { <nl>  #if CONFIG_DV_DEMUXER <nl>      case AV_CODEC_ID_DVAUDIO: <nl> -        c->dv_fctx  = avformat_alloc_context(); <nl> +        c->dv_fctx = avformat_alloc_context(); <nl> +        if (!c->dv_fctx) { <nl> +            av_log(c->fc, AV_LOG_ERROR, "dv demux context alloc error\n"); <nl> +            return AVERROR(ENOMEM); <nl> +        } <nl>          c->dv_demux = avpriv_dv_init_demux(c->dv_fctx); <nl>          if (!c->dv_demux) { <nl>              av_log(c->fc, AV_LOG_ERROR, "dv demux context init error\n");
@@ -132,10 +132,10 @@ static int wv_read_header(AVFormatContext *s, <nl>      WVContext *wc = s->priv_data; <nl>      AVStream *st; <nl>   <nl> +    wc->block_parsed = 0; <nl>      if(wv_read_block_header(s, pb) < 0) <nl>          return -1; <nl>   <nl> -    wc->block_parsed = 0; <nl>      /* now we are ready: build format streams */ <nl>      st = av_new_stream(s, 0); <nl>      if (!st)
@@ -1832,9 +1832,9 @@ static int mjpeg_decode_frame(AVCodecContext *avctx, <nl>  			*(dst++) = x; <nl>  			if (x == 0xff) <nl>  			{ <nl> -			    while(*src == 0xff) src++; <nl> +                            while(src<buf_end && x == 0xff) <nl> +                                x = *(src++); <nl>   <nl> -			    x = *(src++); <nl>  			    if (x >= 0xd0 && x <= 0xd7) <nl>  				*(dst++) = x; <nl>  			    else if (x)
@@ -495,6 +495,8 @@ static void blend_subrect(AVPicture *dst, const AVSubtitleRect *rect, int imgw, <nl>              lum[0] = ALPHA_BLEND(a, lum[0], y, 0); <nl>              cb[0] = ALPHA_BLEND(a >> 2, cb[0], u, 0); <nl>              cr[0] = ALPHA_BLEND(a >> 2, cr[0], v, 0); <nl> +            p++; <nl> +            lum++; <nl>          } <nl>          p += wrap3 + (wrap3 - dstw * BPP); <nl>          lum += wrap + (wrap - dstw - dstx);
@@ -1529,6 +1529,8 @@ static int mov_read_stss(MOVContext *c, AVIOContext *pb, MOVAtom atom) <nl>   <nl>      av_dlog(c->fc, "keyframe_count = %d\n", entries); <nl>   <nl> +    if (!entries) <nl> +        return 0; <nl>      if (entries >= UINT_MAX / sizeof(int)) <nl>          return AVERROR_INVALIDDATA; <nl>      sc->keyframes = av_malloc(entries * sizeof(int));
@@ -2268,6 +2268,7 @@ static void stream_component_close(VideoState *is, int stream_index) <nl>          SDL_CloseAudio(); <nl>   <nl>          packet_queue_end(&is->audioq); <nl> +        av_free_packet(&is->audio_pkt); <nl>          if (is->reformat_ctx) <nl>              av_audio_convert_free(is->reformat_ctx); <nl>          is->reformat_ctx = NULL;
@@ -7507,6 +7507,15 @@ static int decode_nal_units(H264Context *h, uint8_t *buf, int buf_size){ <nl>          nalsize = 0; <nl>          for(i = 0; i < h->nal_length_size; i++) <nl>              nalsize = (nalsize << 8) | buf[buf_index++]; <nl> +        if(nalsize <= 1){ <nl> +            if(nalsize == 1){ <nl> +                buf_index++; <nl> +                continue; <nl> +            }else{ <nl> +                av_log(h->s.avctx, AV_LOG_ERROR, "AVC: nal size %d\n", nalsize); <nl> +                break; <nl> +            } <nl> +        } <nl>        } else { <nl>          // start code prefix search <nl>          for(; buf_index + 3 < buf_size; buf_index++){
@@ -3033,6 +3033,9 @@ static int alloc_tables(H264Context *h){ <nl>   <nl>      s->obmc_scratchpad = NULL; <nl>   <nl> +    if(!h->dequant4_coeff[0]) <nl> +        init_dequant_tables(h); <nl> + <nl>      return 0; <nl>  fail: <nl>      free_tables(h); <nl> @@ -3051,6 +3054,9 @@ static void common_init(H264Context *h){ <nl>      h->dequant_coeff_pps= -1; <nl>      s->unrestricted_mv=1; <nl>      s->decode=1; //FIXME <nl> + <nl> +    memset(h->pps.scaling_matrix4, 16, 6*16*sizeof(uint8_t)); <nl> +    memset(h->pps.scaling_matrix8, 16, 2*64*sizeof(uint8_t)); <nl>  } <nl>   <nl>  static int decode_init(AVCodecContext *avctx){
@@ -746,7 +746,8 @@ static void mpegts_write_pes(AVFormatContext *s, AVStream *st, <nl>                      *q++ = 0xe0; <nl>              } else if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO && <nl>                         (st->codec->codec_id == CODEC_ID_MP2 || <nl> -                        st->codec->codec_id == CODEC_ID_MP3)) { <nl> +                        st->codec->codec_id == CODEC_ID_MP3 || <nl> +                        st->codec->codec_id == CODEC_ID_AAC)) { <nl>                  *q++ = 0xc0; <nl>              } else { <nl>                  *q++ = 0xbd;
@@ -28,6 +28,8 @@ <nl>  #include "get_bits.h" <nl>  #include "internal.h" <nl>   <nl> +#define PCX_HEADER_SIZE 128 <nl> + <nl>  /** <nl>   * @return advanced src pointer <nl>   */ <nl> @@ -85,6 +87,11 @@ static int pcx_decode_frame(AVCodecContext *avctx, void *data, int *got_frame, <nl>      uint8_t *scanline; <nl>      int ret = -1; <nl>   <nl> +    if (buf_size < PCX_HEADER_SIZE) { <nl> +        av_log(avctx, AV_LOG_ERROR, "Packet too small\n"); <nl> +        return AVERROR_INVALIDDATA; <nl> +    } <nl> + <nl>      if (buf[0] != 0x0a || buf[1] > 5) { <nl>          av_log(avctx, AV_LOG_ERROR, "this is not PCX encoded data\n"); <nl>          return AVERROR_INVALIDDATA;
@@ -125,7 +125,7 @@ static int tta_read_packet(AVFormatContext *s, AVPacket *pkt) <nl>      int size, ret; <nl>   <nl>      // FIXME! <nl> -    if (c->currentframe > c->totalframes) <nl> +    if (c->currentframe >= c->totalframes) <nl>          return -1; <nl>   <nl>      size = st->index_entries[c->currentframe].size;
@@ -2329,8 +2329,10 @@ static int mpeg_decode_frame(AVCodecContext *avctx, <nl>                  if(s2->last_picture_ptr==NULL){ <nl>                  /* Skip B-frames if we do not have reference frames. */ <nl>                      if(s2->pict_type==B_TYPE) break; <nl> +                } <nl> +                if(s2->next_picture_ptr==NULL){ <nl>                  /* Skip P-frames if we do not have reference frame no valid header. */ <nl> -//                    if(s2->pict_type==P_TYPE && s2->first_field && !s2->first_slice) break; <nl> +                    if(s2->pict_type==P_TYPE && (s2->first_field || s2->picture_structure==PICT_FRAME)) break; <nl>                  } <nl>                  /* Skip B-frames if we are in a hurry. */ <nl>                  if(avctx->hurry_up && s2->pict_type==B_TYPE) break;
@@ -632,6 +632,8 @@ static int mkv_write_header(AVFormatContext *s) <nl>      // currently defined level 1 element <nl>      mkv->main_seekhead    = mkv_start_seekhead(pb, mkv->segment_offset, 10); <nl>      mkv->cluster_seekhead = mkv_start_seekhead(pb, mkv->segment_offset, 0); <nl> +    if (mkv->main_seekhead == NULL || mkv->cluster_seekhead == NULL) <nl> +        return AVERROR(ENOMEM); <nl>   <nl>      if (mkv_add_seekhead_entry(mkv->main_seekhead, MATROSKA_ID_INFO, url_ftell(pb)) < 0) <nl>          return -1;
@@ -903,6 +903,8 @@ static int matroska_probe(AVProbeData *p) <nl>       * Not fully fool-proof, but good enough. */ <nl>      for (i = 0; i < FF_ARRAY_ELEMS(matroska_doctypes); i++) { <nl>          int probelen = strlen(matroska_doctypes[i]); <nl> +        if (total < probelen) <nl> +            continue; <nl>          for (n = 4+size; n <= 4+size+total-probelen; n++) <nl>              if (!memcmp(p->buf+n, matroska_doctypes[i], probelen)) <nl>                  return AVPROBE_SCORE_MAX;
@@ -320,8 +320,7 @@ static int handle_file(struct Tracks *tracks, const char *file, int split) <nl>          track->bitrate   = st->codec->bit_rate; <nl>          track->track_id  = st->id; <nl>          track->timescale = st->time_base.den; <nl> -        track->duration  = av_rescale_rnd(ctx->duration, track->timescale, <nl> -                                          AV_TIME_BASE, AV_ROUND_UP); <nl> +        track->duration  = st->duration; <nl>          track->is_audio  = st->codec->codec_type == AVMEDIA_TYPE_AUDIO; <nl>          track->is_video  = st->codec->codec_type == AVMEDIA_TYPE_VIDEO; <nl>  
@@ -1044,7 +1044,7 @@ typedef struct AVPanScan{ <nl>       * - encoding: Set by libavcodec.\ <nl>       * - decoding: Set by libavcodec.\ <nl>       */\ <nl> -    void *thread_opaque; <nl> +    void *thread_opaque;\ <nl>   <nl>  #define FF_QSCALE_TYPE_MPEG1 0 <nl>  #define FF_QSCALE_TYPE_MPEG2 1
@@ -213,13 +213,13 @@ static int rv40_decode_mb_info(RV34DecContext *r) <nl>      if(--r->s.mb_skip_run) <nl>           return RV34_MB_SKIP; <nl>   <nl> -    if(r->avail[0]) <nl> +    if(r->avail_cache[5-1]) <nl>          blocks[r->mb_type[mb_pos - 1]]++; <nl> -    if(r->avail[1]){ <nl> +    if(r->avail_cache[5-4]){ <nl>          blocks[r->mb_type[mb_pos - s->mb_stride]]++; <nl> -        if(r->avail[2]) <nl> +        if(r->avail_cache[5-2]) <nl>              blocks[r->mb_type[mb_pos - s->mb_stride + 1]]++; <nl> -        if(r->avail[3]) <nl> +        if(r->avail_cache[5-5]) <nl>              blocks[r->mb_type[mb_pos - s->mb_stride - 1]]++; <nl>      } <nl>  
@@ -434,7 +434,9 @@ int ff_audio_resample(ResampleContext *c, AudioData *dst, AudioData *src) <nl>          int bps = av_get_bytes_per_sample(c->avr->internal_sample_fmt); <nl>          int i; <nl>   <nl> -        ret = ff_audio_data_realloc(c->buffer, in_samples + c->padding_size); <nl> +        ret = ff_audio_data_realloc(c->buffer, <nl> +                                    FFMAX(in_samples, in_leftover) + <nl> +                                    c->padding_size); <nl>          if (ret < 0) { <nl>              av_log(c->avr, AV_LOG_ERROR, "Error reallocating resampling buffer\n"); <nl>              return AVERROR(ENOMEM);
@@ -922,7 +922,7 @@ static int mxf_read_local_tags(MXFContext *mxf, KLVPacket *klv, int (*read_child <nl>          int tag = get_be16(pb); <nl>          int size = get_be16(pb); /* KLV specified by 0x53 */ <nl>          uint64_t next = url_ftell(pb) + size; <nl> -        UID uid; <nl> +        UID uid = {0}; <nl>   <nl>          if (!size) { /* ignore empty tag, needed for some files with empty UMID tag */ <nl>              av_log(mxf->fc, AV_LOG_ERROR, "local tag 0x%04X with 0 size\n", tag);
@@ -1048,6 +1048,11 @@ static void vc1_mc_4mv_chroma4(VC1Context *v) <nl>              mquant = v->altpq;                                 \ <nl>          if ((edges&8) && s->mb_y == (s->mb_height - 1))        \ <nl>              mquant = v->altpq;                                 \ <nl> +        if (!mquant || mquant > 31) {                          \ <nl> +            av_log(v->s.avctx, AV_LOG_ERROR,                   \ <nl> +                   "Overriding invalid mquant %d\n", mquant);  \ <nl> +            mquant = 1;                                        \ <nl> +        }                                                      \ <nl>      } <nl>   <nl>  /**
@@ -565,6 +565,10 @@ static void fill_buffer(AVIOContext *s) <nl>      int len= s->buffer_size - (dst - s->buffer); <nl>      int max_buffer_size = s->max_packet_size ? s->max_packet_size : IO_BUFFER_SIZE; <nl>   <nl> +    /* can't fill the buffer without read_packet, just set EOF if appropiate */ <nl> +    if (!s->read_packet && s->buf_ptr >= s->buf_end) <nl> +        s->eof_reached = 1; <nl> + <nl>      /* no need to do anything if EOF already reached */ <nl>      if (s->eof_reached) <nl>          return;
@@ -180,9 +180,14 @@ av_cold int ff_dct_init(DCTContext *s, int nbits, enum DCTTransformType inverse) <nl>      int n = 1 << nbits; <nl>      int i; <nl>   <nl> +    memset(s, 0, sizeof(*s)); <nl> + <nl>      s->nbits    = nbits; <nl>      s->inverse  = inverse; <nl>   <nl> +    if (inverse == DCT_II && nbits == 5) { <nl> +        s->dct_calc = dct32_func; <nl> +    } else { <nl>      ff_init_ff_cos_tabs(nbits+2); <nl>   <nl>      s->costab = ff_cos_tabs[nbits+2]; <nl> @@ -203,9 +208,7 @@ av_cold int ff_dct_init(DCTContext *s, int nbits, enum DCTTransformType inverse) <nl>      case DCT_III: s->dct_calc = ff_dct_calc_III_c; break; <nl>      case DST_I  : s->dct_calc = ff_dst_calc_I_c; break; <nl>      } <nl> - <nl> -    if (inverse == DCT_II && nbits == 5) <nl> -        s->dct_calc = dct32_func; <nl> +    } <nl>   <nl>      s->dct32 = dct32; <nl>      if (HAVE_MMX)     ff_dct_init_mmx(s);
@@ -464,8 +464,6 @@ int main(int argc, char **argv) <nl>          audio_st = add_audio_stream(oc, fmt->audio_codec); <nl>      } <nl>   <nl> -    av_dump_format(oc, 0, filename, 1); <nl> - <nl>      /* now that all the parameters are set, we can open the audio and <nl>         video codecs and allocate the necessary encode buffers */ <nl>      if (video_st) <nl> @@ -473,6 +471,8 @@ int main(int argc, char **argv) <nl>      if (audio_st) <nl>          open_audio(oc, audio_st); <nl>   <nl> +    av_dump_format(oc, 0, filename, 1); <nl> + <nl>      /* open the output file, if needed */ <nl>      if (!(fmt->flags & AVFMT_NOFILE)) { <nl>          if (avio_open(&oc->pb, filename, AVIO_FLAG_WRITE) < 0) {
@@ -149,6 +149,11 @@ static void put_audio_specific_config(AVCodecContext *avctx) <nl>      put_bits(&pb, 1, 0); //frame length - 1024 samples <nl>      put_bits(&pb, 1, 0); //does not depend on core coder <nl>      put_bits(&pb, 1, 0); //is not extension <nl> + <nl> +    //Explicitly Mark SBR absent <nl> +    put_bits(&pb, 11, 0x27b); //sync extension <nl> +    put_bits(&pb, 5,  AOT_SBR); <nl> +    put_bits(&pb, 1,  0); <nl>      flush_put_bits(&pb); <nl>  } <nl>   <nl> @@ -193,8 +198,8 @@ static av_cold int aac_encode_init(AVCodecContext *avctx) <nl>   <nl>      s->samples            = av_malloc(2 * 1024 * avctx->channels * sizeof(s->samples[0])); <nl>      s->cpe                = av_mallocz(sizeof(ChannelElement) * aac_chan_configs[avctx->channels-1][0]); <nl> -    avctx->extradata      = av_mallocz(2 + FF_INPUT_BUFFER_PADDING_SIZE); <nl> -    avctx->extradata_size = 2; <nl> +    avctx->extradata      = av_mallocz(5 + FF_INPUT_BUFFER_PADDING_SIZE); <nl> +    avctx->extradata_size = 5; <nl>      put_audio_specific_config(avctx); <nl>   <nl>      sizes[0]   = swb_size_1024[i];
@@ -37,6 +37,7 @@ <nl>  #define XAVS_PART_B8X8 0x100 /* Analyze b16x8, b*/ <nl>   <nl>  typedef struct XavsContext { <nl> +    AVClass        *class; <nl>      xavs_param_t    params; <nl>      xavs_t         *enc; <nl>      xavs_picture_t  pic;
@@ -54,6 +54,11 @@ static int decode_frame(AVCodecContext *avctx, <nl>      if(p->data[0]) <nl>          avctx->release_buffer(avctx, p); <nl>   <nl> +    if(buf_size/avctx->height < avctx->width) { <nl> +        av_log(avctx, AV_LOG_ERROR, "Resolution larger than buffer size. Invalid header?\n"); <nl> +        return -1; <nl> +    } <nl> + <nl>      p->reference= 0; <nl>      if(avctx->get_buffer(avctx, p) < 0){ <nl>          av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n");
@@ -129,7 +129,8 @@ static int xan_unpack(uint8_t *dest, const int dest_len, <nl>                  if (size + size2 > dest_end - dest) <nl>                      break; <nl>              } <nl> -            if (src + size > src_end || dest + size + size2 > dest_end) <nl> +            if (src + size > src_end || dest + size + size2 > dest_end || <nl> +                dest - orig_dest + size < back) <nl>                  return -1; <nl>              bytestream_get_buffer(&src, dest, size); <nl>              dest += size;
@@ -307,7 +307,7 @@ av_cold int ff_dvvideo_init(AVCodecContext *avctx) <nl>      /* 248DCT setup */ <nl>      s->fdct[1]     = dsp.fdct248; <nl>      s->idct_put[1] = ff_simple_idct248_put;  // FIXME: need to add it to DSP <nl> -    memcpy(s->dv_zigzag[1], ff_dv_zigzag248_direct, 64); <nl> +    memcpy(s->dv_zigzag[1], ff_dv_zigzag248_direct, sizeof(s->dv_zigzag[1])); <nl>   <nl>      s->avctx = avctx; <nl>      avctx->chroma_sample_location = AVCHROMA_LOC_TOPLEFT;
@@ -832,6 +832,12 @@ static int flush_packet(AVFormatContext *ctx, int stream_index, <nl>   <nl>          if (stuffing_size < 0) <nl>              stuffing_size = 0; <nl> + <nl> +        if (startcode == PRIVATE_STREAM_1 && id >= 0xa0) { <nl> +            if (payload_size < av_fifo_size(stream->fifo)) <nl> +                stuffing_size += payload_size % stream->lpcm_align; <nl> +        } <nl> + <nl>          if (stuffing_size > 16) {    /*<=16 for MPEG-1, <=32 for MPEG-2*/ <nl>              pad_packet_bytes += stuffing_size; <nl>              packet_size      -= stuffing_size;
@@ -76,7 +76,12 @@ int ff_xvmc_field_start(MpegEncContext*s, AVCodecContext *avctx) <nl>      render->picture_structure = s->picture_structure; <nl>      render->flags             = s->first_field ? 0 : XVMC_SECOND_FIELD; <nl>   <nl> -    assert(render->filled_mv_blocks_num == 0); <nl> +    if(render->filled_mv_blocks_num){ <nl> +        av_log(avctx, AV_LOG_ERROR, <nl> +                "Rendering surface contains %i unprocessed blocks\n", <nl> +                render->filled_mv_blocks_num); <nl> +        assert(0); <nl> +    } <nl>   <nl>      render->p_future_surface = NULL; <nl>      render->p_past_surface   = NULL;
@@ -87,7 +87,7 @@ static unsigned int mszh_decomp(unsigned char * srcptr, int srclen, unsigned cha <nl>              continue; <nl>          } <nl>          if ((mask & (1 << (--maskbit))) == 0) { <nl> -            if (destptr + 4 > destptr_end) <nl> +            if (destptr_end - destptr < 4) <nl>                  break; <nl>              memcpy(destptr, srcptr, 4); <nl>              srclen -= 4; <nl> @@ -101,7 +101,7 @@ static unsigned int mszh_decomp(unsigned char * srcptr, int srclen, unsigned cha <nl>              ofs &= 0x7ff; <nl>              srclen -= 2; <nl>              cnt *= 4; <nl> -            if (destptr + cnt > destptr_end) { <nl> +            if (destptr_end - destptr < cnt) { <nl>                  cnt =  destptr_end - destptr; <nl>              } <nl>              for (; cnt > 0; cnt--) {
@@ -1399,7 +1399,7 @@ static int rtsp_read_packet(AVFormatContext *s, <nl>      case RTSP_LOWER_TRANSPORT_UDP: <nl>      case RTSP_LOWER_TRANSPORT_UDP_MULTICAST: <nl>          len = udp_read_packet(s, &rtsp_st, buf, sizeof(buf)); <nl> -        if (len >=0 && rtsp_st->tx_ctx) <nl> +        if (len >=0 && rtsp_st->tx_ctx && rt->transport == RTSP_TRANSPORT_RTP) <nl>              rtp_check_and_send_back_rr(rtsp_st->tx_ctx, len); <nl>          break; <nl>      }
@@ -157,9 +157,9 @@ const static int8_t vlcdec_lookup[9][64] = { <nl>         -67,  67,  -66,  66,  -65,  65,  -64,  64, }, <nl>  }; <nl>   <nl> -static int vlc_decode_block(MimicContext *ctx, DCTELEM *block, int num_coeffs, <nl> -                            int qscale) <nl> +static int vlc_decode_block(MimicContext *ctx, int num_coeffs, int qscale) <nl>  { <nl> +    DCTELEM *block = ctx->dct_block; <nl>      unsigned int pos; <nl>   <nl>      memset(block, 0, 64 * sizeof(DCTELEM)); <nl> @@ -227,8 +227,7 @@ static int decode(MimicContext *ctx, int quality, int num_coeffs, <nl>                       * Chroma planes don't use backreferences. */ <nl>                      if(is_chroma || is_iframe || !get_bits1(&ctx->gb)) { <nl>   <nl> -                        if(!vlc_decode_block(ctx, ctx->dct_block, <nl> -                                             num_coeffs, qscale)) <nl> +                        if(!vlc_decode_block(ctx, num_coeffs, qscale)) <nl>                              return 0; <nl>                          ctx->dsp.idct_put(dst, stride, ctx->dct_block); <nl>                      } else {
@@ -3619,8 +3619,11 @@ static int decode_slice_header(H264Context *h, H264Context *h0) <nl>              av_log(h->avctx, AV_LOG_DEBUG, "Frame num gap %d %d\n", <nl>                     h->frame_num, h->prev_frame_num); <nl>              ret = h264_frame_start(h); <nl> -            if (ret < 0) <nl> +            if (ret < 0) { <nl> +                h0->first_field = 0; <nl>                  return ret; <nl> +            } <nl> + <nl>              h->prev_frame_num++; <nl>              h->prev_frame_num        %= 1 << h->sps.log2_max_frame_num; <nl>              h->cur_pic_ptr->frame_num = h->prev_frame_num;
@@ -688,7 +688,7 @@ static const int tc0_table[52*3][3] = { <nl>   <nl>  /* Cabac pre state table */ <nl>   <nl> -static const int cabac_context_init_I[460][2] = <nl> +static const int8_t cabac_context_init_I[460][2] = <nl>  { <nl>      /* 0 - 10 */ <nl>      { 20, -15 }, {  2, 54 },  {  3,  74 }, { 20, -15 }, <nl> @@ -857,7 +857,7 @@ static const int cabac_context_init_I[460][2] = <nl>      {  29,   9 }, {  35,  20 }, {  29,  36 }, {  14,  67 } <nl>  }; <nl>   <nl> -static const int cabac_context_init_PB[3][460][2] = <nl> +static const int8_t cabac_context_init_PB[3][460][2] = <nl>  { <nl>      /* i_cabac_init_idc == 0 */ <nl>      {
@@ -291,7 +291,7 @@ static int cmp_qpel(MpegEncContext *s, const int x, const int y, const int subx, <nl>  #include "motion_est_template.c" <nl>   <nl>  static int zero_cmp(MpegEncContext *s, uint8_t *a, uint8_t *b, <nl> -                    int stride, int h) <nl> +                    ptrdiff_t stride, int h) <nl>  { <nl>      return 0; <nl>  }
@@ -364,7 +364,7 @@ static int mp3_read_probe(AVProbeData *p) <nl>   <nl>      max_frames = 0; <nl>      buf = buf0; <nl> -    end = buf + p->buf_size - sizeof(uint32_t); <nl> +    end = p->buf + p->buf_size - sizeof(uint32_t); <nl>   <nl>      for(; buf < end; buf= buf2+1) { <nl>          buf2 = buf;
@@ -210,7 +210,9 @@ static int vaapi_encode_h264_write_extra_header(AVCodecContext *avctx, <nl>   <nl>      if (priv->sei_needed) { <nl>          if (priv->aud_needed) { <nl> -            vaapi_encode_h264_add_nal(avctx, au, &priv->aud); <nl> +            err = vaapi_encode_h264_add_nal(avctx, au, &priv->aud); <nl> +            if (err < 0) <nl> +                goto fail; <nl>              priv->aud_needed = 0; <nl>          } <nl>  
@@ -5941,7 +5941,7 @@ static int vc1_decode_frame(AVCodecContext *avctx, void *data, <nl>   <nl>      /* skip B-frames if we don't have reference frames */ <nl>      if (s->last_picture_ptr == NULL && (s->pict_type == AV_PICTURE_TYPE_B || s->droppable)) { <nl> -        goto err; <nl> +        goto end; <nl>      } <nl>      if ((avctx->skip_frame >= AVDISCARD_NONREF && s->pict_type == AV_PICTURE_TYPE_B) || <nl>          (avctx->skip_frame >= AVDISCARD_NONKEY && s->pict_type != AV_PICTURE_TYPE_I) ||
@@ -870,6 +870,9 @@ static int handle_connection(HTTPContext *c) <nl>          } <nl>          if (http_send_data(c) < 0) <nl>              return -1; <nl> +        /* close connection if trailer sent */ <nl> +        if (c->state == HTTPSTATE_SEND_DATA_TRAILER) <nl> +            return -1; <nl>          break; <nl>      case HTTPSTATE_RECEIVE_DATA: <nl>          /* no need to read if no events */
@@ -2331,6 +2331,12 @@ AP_CORE_DECLARE_NONSTD(const char *) ap_limit_section(cmd_parms *cmd, <nl>              /* method has not been registered yet, but resource restriction <nl>               * is always checked before method handling, so register it. <nl>               */ <nl> +            if (cmd->pool == cmd->temp_pool) { <nl> +                /* In .htaccess, we can't globally register new methods. */ <nl> +                return apr_psprintf(cmd->pool, "Could not register method '%s' " <nl> +                                   "for %s from .htaccess configuration", <nl> +                                    method, cmd->cmd->name); <nl> +            } <nl>              methnum = ap_method_register(cmd->pool, <nl>                                           apr_pstrdup(cmd->pool, method)); <nl>          }
@@ -137,6 +137,10 @@ cmd_connect(gchar **args, struct cmd_help_t help) <nl>                  if(stream){ <nl>                      // Limit to READ_BUF_SIZE bytes to prevent overflows in the case of a poorly chosen command <nl>                      account->password = g_malloc(READ_BUF_SIZE); <nl> +                    if(!account->password){ <nl> +                        log_error("Failed to allocate enough memory to read eval_password output"); <nl> +                        return TRUE; <nl> +                    } <nl>                      account->password = fgets(account->password, READ_BUF_SIZE, stream); <nl>                      pclose(stream); <nl>                  } else {
@@ -212,6 +212,7 @@ wins_get_plugin(const char *const tag) <nl>          if (window->type == WIN_PLUGIN) { <nl>              ProfPluginWin *pluginwin = (ProfPluginWin*)window; <nl>              if (g_strcmp0(pluginwin->tag, tag) == 0) { <nl> +                g_list_free(values); <nl>                  return pluginwin; <nl>              } <nl>          }
@@ -365,9 +365,9 @@ static char * <nl>  _c_plugin_name(const char *filename) <nl>  { <nl>      GString *plugin_name_str = g_string_new(""); <nl> -    char *name = strndup(filename, strlen(filename)-1); <nl> +    gchar *name = g_strndup(filename, strlen(filename)-1); <nl>      g_string_append(plugin_name_str, name); <nl> -    free(name); <nl> +    g_free(name); <nl>      g_string_append(plugin_name_str, "so"); <nl>      char *result = plugin_name_str->str; <nl>      g_string_free(plugin_name_str, FALSE);
@@ -273,6 +273,15 @@ int proxy_send(REQUEST *request) <nl>  		return RLM_MODULE_NOOP; <nl>  	} <nl>   <nl> +	/* <nl> +	 *	If the server has already decided to reject the request, <nl> +	 *	then don't try to proxy it. <nl> +	 */ <nl> +	if (request->reply->code == PW_AUTHENTICATION_REJECT) { <nl> +		DEBUG2("Cancelling proxy as request was already rejected"); <nl> +		return RLM_MODULE_REJECT; <nl> +	} <nl> + <nl>  	/* <nl>  	 *	Length == 0 means it exists, but there's no realm. <nl>  	 *	Don't proxy it.
@@ -430,20 +430,24 @@ static int passwd_instantiate(CONF_SECTION *conf, void **instance) <nl>  	}while(*s); <nl>  	if(keyfield < 0) { <nl>  		radlog(L_ERR, "rlm_passwd: no field market as key in format: %s", inst->format); <nl> +		free(lf); <nl>  		return -1; <nl>  	} <nl>  	if (! (inst->ht = build_hash_table (inst->filename, nfields, keyfield, listable, inst->hashsize, inst->ignorenislike, *inst->delimiter)) ){ <nl>  		radlog(L_ERR, "rlm_passwd: can't build hashtable from passwd file"); <nl> +		free(lf); <nl>  		return -1; <nl>  	} <nl>  	if (! (inst->pwdfmt = mypasswd_malloc(inst->format, nfields, &len)) ){ <nl>  		radlog(L_ERR, "rlm_passwd: memory allocation failed"); <nl>  		release_ht(inst->ht); <nl> +		free(lf); <nl>  		return -1; <nl>  	} <nl>  	if (!string_to_entry(inst->format, nfields, ':', inst->pwdfmt , len)) { <nl>  		radlog(L_ERR, "rlm_passwd: unable to convert format entry"); <nl>  		release_ht(inst->ht); <nl> +		free(lf); <nl>  		return -1; <nl>  	} <nl>  
@@ -2688,6 +2688,8 @@ static void request_proxied(REQUEST *request, int action) <nl>   <nl>  	switch (action) { <nl>  	case FR_ACTION_DUP: <nl> +		if (!request->proxy_listener) return; <nl> + <nl>  		if ((home->state == HOME_STATE_IS_DEAD) || <nl>  		    (request->proxy_listener->status != RAD_LISTEN_STATUS_KNOWN)) { <nl>  			request_proxy_anew(request);
@@ -352,15 +352,15 @@ static int process_eap_start(RADIUS_PACKET *req, <nl>  		 */ <nl>  		newvp = paircreate(ATTRIBUTE_EAP_SIM_BASE+PW_EAP_SIM_NONCE_MT, <nl>  				   PW_TYPE_OCTETS); <nl> -		newvp->vp_strvalue[0]=0; <nl> -		newvp->vp_strvalue[1]=0; <nl> +		newvp->vp_octets[0]=0; <nl> +		newvp->vp_octets[1]=0; <nl>  		newvp->length = 18;  /* 16 bytes of nonce + padding */ <nl>   <nl>  		nonce[0]=lrad_rand(); <nl>  		nonce[1]=lrad_rand(); <nl>  		nonce[2]=lrad_rand(); <nl>  		nonce[3]=lrad_rand(); <nl> -		memcpy(&newvp->vp_strvalue[2], nonce, 16); <nl> +		memcpy(&newvp->vp_octets[2], nonce, 16); <nl>  		pairreplace(&(rep->vps), newvp); <nl>   <nl>  		/* also keep a copy of the nonce! */
@@ -317,7 +317,8 @@ static int sql_close(SQLSOCK * sqlsocket, SQL_CONFIG *config) { <nl>   <nl>  	rlm_sql_mysql_sock *mysql_sock = sqlsocket->conn; <nl>   <nl> -	mysql_close(mysql_sock->sock); <nl> +	if (mysql_sock->sock) <nl> +		mysql_close(mysql_sock->sock); <nl>  	mysql_sock->sock = NULL; <nl>   <nl>  	return 0;
@@ -714,7 +714,7 @@ int fr_dhcp_decode(RADIUS_PACKET *packet) <nl>  			} <nl>   <nl>  			*tail = vp; <nl> -			while (*tail) tail = &vp->next; <nl> +			while (*tail) tail = &(*tail)->next; <nl>  			p += alen; <nl>  		} /* loop over array entries */ <nl>  	} /* loop over the entire packet */
@@ -1964,6 +1964,11 @@ int rad_decode(RADIUS_PACKET *packet, RADIUS_PACKET *original, <nl>  		 *	over-ride this one. <nl>  		 */ <nl>  	create_pair: <nl> +		/* <nl> +		 *	Ignore VSAs that have no data. <nl> +		 */ <nl> +		if (attrlen == 0) goto next; <nl> + <nl>  		pair = rad_attr2vp(packet, original, secret, <nl>  				 attribute, attrlen, ptr); <nl>  		if (!pair) { <nl> @@ -1976,6 +1981,7 @@ int rad_decode(RADIUS_PACKET *packet, RADIUS_PACKET *original, <nl>  		*tail = pair; <nl>  		tail = &pair->next; <nl>   <nl> +	next: <nl>  		ptr += attrlen; <nl>  		packet_length -= attrlen; <nl>  	}
@@ -1496,6 +1496,9 @@ int free_mainconfig(void) <nl>  	cf_section_free(&mainconfig.config); <nl>  	realm_free(mainconfig.realms); <nl>  	clients_free(mainconfig.clients); <nl> +	read_naslist_file(NULL); <nl> + <nl> +	dict_free(); <nl>   <nl>  	return 0; <nl>  }
@@ -229,12 +229,10 @@ static int rad_sendto(int sockfd, void *data, size_t data_len, int flags, <nl>   <nl>  #ifdef WITH_UDPFROMTO <nl>  	/* <nl> -	 *	Only IPv4 is supported for udpfromto. <nl> -	 * <nl>  	 *	And if they don't specify a source IP address, don't <nl>  	 *	use udpfromto. <nl>  	 */ <nl> -	if ((dst_ipaddr->af == AF_INET) && <nl> +	if (((dst_ipaddr->af == AF_INET) || (dst_ipaddr->af == AF_INET6)) && <nl>  	    (src_ipaddr->af != AF_UNSPEC)) { <nl>  		return sendfromto(sockfd, data, data_len, flags, <nl>  				  (struct sockaddr *)&src, sizeof_src, <nl> @@ -245,7 +243,7 @@ static int rad_sendto(int sockfd, void *data, size_t data_len, int flags, <nl>  #endif <nl>   <nl>  	/* <nl> -	 *	No udpfromto, OR an IPv6 socket, fail gracefully. <nl> +	 *	No udpfromto, fail gracefully. <nl>  	 */ <nl>  	return sendto(sockfd, data, data_len, flags, <nl>  		      (struct sockaddr *) &dst, sizeof_dst); <nl> @@ -416,14 +414,14 @@ static ssize_t rad_recvfrom(int sockfd, uint8_t **pbuf, int flags, <nl>  	 *	packet after "len" bytes. <nl>  	 */ <nl>  #ifdef WITH_UDPFROMTO <nl> -	if (dst.ss_family == AF_INET) { <nl> +	if ((dst.ss_family == AF_INET) || (dst.ss_family == AF_INET6)) { <nl>  		data_len = recvfromto(sockfd, buf, len, flags, <nl>  				      (struct sockaddr *)&src, &sizeof_src, <nl>  				      (struct sockaddr *)&dst, &sizeof_dst); <nl>  	} else <nl>  #endif <nl>  		/* <nl> -		 *	No udpfromto, OR an IPv6 socket.  Fail gracefully. <nl> +		 *	No udpfromto, fail gracefully. <nl>  		 */ <nl>  		data_len = recvfrom(sockfd, buf, len, flags, <nl>  				    (struct sockaddr *)&src, &sizeof_src);
@@ -2361,6 +2361,8 @@ lt_dlexit () <nl>  	  LT_DLMEM_REASSIGN (loader, next); <nl>  	} <nl>        loaders = 0; <nl> + <nl> +      LT_DLFREE (user_search_path); <nl>      } <nl>   <nl>   done: <nl> @@ -3062,6 +3064,7 @@ try_dlopen (phandle, filename) <nl>    char *	name		= 0; <nl>    int		errors		= 0; <nl>    lt_dlhandle	newhandle; <nl> +  int		free_base_name  = 0; <nl>   <nl>    assert (phandle); <nl>    assert (*phandle == 0); <nl> @@ -3119,8 +3122,10 @@ try_dlopen (phandle, filename) <nl>   <nl>        ++base_name; <nl>      } <nl> -  else <nl> +  else { <nl>      base_name = canonical; <nl> +    free_base_name = 1; <nl> +  } <nl>   <nl>    assert (base_name && *base_name); <nl>   <nl> @@ -3421,6 +3426,7 @@ try_dlopen (phandle, filename) <nl>    LT_DLFREE (dir); <nl>    LT_DLFREE (name); <nl>    LT_DLFREE (canonical); <nl> +  if (free_base_name) LT_DLFREE (base_name); <nl>   <nl>    return errors; <nl>  }
@@ -272,9 +272,17 @@ static int unix_getpw(UNUSED void *instance, REQUEST *request, <nl>  	/* <nl>  	 *      Check if password has expired. <nl>  	 */ <nl> +	if (spwd && spwd->sp_lstchg > 0 && spwd->sp_max >= 0 && <nl> +	    (request->timestamp / 86400) > (spwd->sp_lstchg + spwd->sp_max)) { <nl> +		radlog_request(L_AUTH, 0, request, "[%s]: password has expired", name); <nl> +		return RLM_MODULE_REJECT; <nl> +	} <nl> +	/* <nl> +	 *      Check if account has expired. <nl> +	 */ <nl>  	if (spwd && spwd->sp_expire > 0 && <nl>  	    (request->timestamp / 86400) > spwd->sp_expire) { <nl> -		radlog_request(L_AUTH, 0, request, "[%s]: password has expired", name); <nl> +		radlog_request(L_AUTH, 0, request, "[%s]: account has expired", name); <nl>  		return RLM_MODULE_REJECT; <nl>  	} <nl>  #endif
@@ -208,6 +208,14 @@ int eaptype_select(rlm_eap_t *inst, EAP_HANDLER *handler) <nl>  		return EAP_INVALID; <nl>  	} <nl>   <nl> +	/* <nl> +	 *	Multiple levels of nesting are invalid. <nl> +	 */ <nl> +	if (handler->request->parent && handler->request->parent->parent) { <nl> +		DEBUG2(" rlm_eap: Multiple levels of TLS nesting is invalid."); <nl> +		return EAP_INVALID; <nl> +	} <nl> + <nl>  	/* <nl>  	 *	Figure out what to do. <nl>  	 */
@@ -622,6 +622,7 @@ static int load_component_section(CONF_SECTION *cs, <nl>  			} else { <nl>  				modrefname = cf_section_name2(scs); <nl>  				if (!modrefname) { <nl> +					modcallable_free(&this); <nl>  					cf_log_err(cf_sectiontoitem(cs), <nl>  						   "Errors parsing %s sub-section.\n", <nl>  						   cf_section_name1(scs)); <nl> @@ -635,6 +636,7 @@ static int load_component_section(CONF_SECTION *cs, <nl>  				 *	It's a section, but nothing we <nl>  				 *	recognize.  Die! <nl>  				 */ <nl> +				modcallable_free(&this); <nl>  				cf_log_err(cf_sectiontoitem(cs), <nl>  					   "Unknown Auth-Type \"%s\" in %s sub-section.", <nl>  					   modrefname, section_type_value[comp].section);
@@ -556,12 +556,15 @@ static int ippool_postauth(void *instance, REQUEST *request) <nl>  	 * If there is a Framed-IP-Address attribute in the reply, check for override <nl>  	 */ <nl>  	if (pairfind(request->reply->vps, PW_FRAMED_IP_ADDRESS) != NULL) { <nl> +		DEBUG("rlm_ippool: Found Framed-IP-Address attribute in reply attribute list."); <nl>  		if (data->override) <nl>  		{ <nl>  			/* Override supplied Framed-IP-Address */ <nl> +			DEBUG("rlm_ippool: override is set to yes. Override the existing Framed-IP-Address attribute."); <nl>  			pairdelete(&request->reply->vps, PW_FRAMED_IP_ADDRESS); <nl>  		} else { <nl>  			/* Abort */ <nl> +			DEBUG("rlm_ippool: override is set to no. Return NOOP."); <nl>  			return RLM_MODULE_NOOP; <nl>  		} <nl>  	}
@@ -30,7 +30,7 @@ file_transfer_t *imcb_file_send_start(struct im_connection *ic, char *handle, ch <nl>  	bee_t *bee = ic->bee; <nl>  	bee_user_t *bu = bee_user_by_handle(bee, ic, handle); <nl>   <nl> -	if (bee->ui->ft_in_start) { <nl> +	if (bee->ui->ft_in_start && bu) { <nl>  		return bee->ui->ft_in_start(bee, bu, file_name, file_size); <nl>  	} else { <nl>  		return NULL;
@@ -145,6 +145,10 @@ static gboolean prplcb_xfer_new_send_cb(gpointer data, gint fd, b_input_conditio <nl>  	/* TODO(wilmer): After spreading some more const goodness in BitlBee, <nl>  	   remove the evil cast below. */ <nl>  	px->ft = imcb_file_send_start(ic, (char *) who, xfer->filename, xfer->size); <nl> + <nl> +	if (!px->ft) { <nl> +		return FALSE; <nl> +	} <nl>  	px->ft->data = px; <nl>   <nl>  	px->ft->accept = prpl_xfer_accept;
@@ -292,9 +292,11 @@ int jabber_si_handle_request( struct im_connection *ic, struct xt_node *node, st <nl>  			requestok = FALSE; <nl>  		} <nl>   <nl> -		*s = '/'; <nl> +		if( s ) <nl> +			*s = '/'; <nl>  	} <nl> -	else <nl> +	 <nl> +	if( !requestok ) <nl>  	{  <nl>  		reply = jabber_make_error_packet( node, "item-not-found", "cancel", NULL ); <nl>  		if (!jabber_write_packet( ic, reply ))
@@ -636,6 +636,7 @@ static gboolean bee_irc_chat_msg( bee_t *bee, struct groupchat *c, bee_user_t *b <nl>  	wrapped = word_wrap( msg, 425 ); <nl>  	irc_send_msg( iu, "PRIVMSG", ic->name, wrapped, ts ); <nl>  	g_free( ts ); <nl> +	g_free( wrapped ); <nl>  	 <nl>  	return TRUE; <nl>  }
@@ -637,7 +637,7 @@ static void register_mibs(void) { <nl>  				hf_register_info hf; <nl>   <nl>  				hf.p_id                     = &(oid_data->value_hfid); <nl> -				hf.hfinfo.name              = oid_data->name; <nl> +				hf.hfinfo.name              = g_strdup(oid_data->name); <nl>  				hf.hfinfo.abbrev            = alnumerize(oid_data->name); <nl>  				hf.hfinfo.type              = typedata->ft_type; <nl>  				hf.hfinfo.display           = typedata->display;
@@ -2775,7 +2775,7 @@ static int <nl>  dissect_dnp3_al(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) <nl>  { <nl>    guint8        al_ctl, al_seq, al_func, al_class = 0, i; <nl> -  guint16       bytes, obj_type; <nl> +  guint16       bytes, obj_type = 0; <nl>    guint         data_len = 0, offset = 0; <nl>    proto_item   *ti, *tc, *t_robj; <nl>    proto_tree   *al_tree, *field_tree, *robj_tree;
@@ -536,7 +536,9 @@ dissect_websocket_frame(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, voi <nl>      if (http_conv) { <nl>        websocket_conv->subprotocol = http_conv->websocket_protocol; <nl>        websocket_conv->server_port = http_conv->server_port; <nl> -      websocket_parse_extensions(websocket_conv, http_conv->websocket_extensions); <nl> +      if ( http_conv->websocket_extensions) { <nl> +        websocket_parse_extensions(websocket_conv, http_conv->websocket_extensions); <nl> +      } <nl>      } <nl>   <nl>      conversation_add_proto_data(conv, proto_websocket, websocket_conv);
@@ -5073,7 +5073,10 @@ static int dissect_cip_attribute(packet_info *pinfo, proto_tree *tree, proto_ite <nl>        /* Convert to nstime epoch */ <nl>        computed_time = CIP_TIMEBASE+(temp_data*60*60*24); <nl>        date = gmtime(&computed_time); <nl> -      strftime(date_str, 20, "%b %d, %Y", date); <nl> +      if (date != NULL) <nl> +          strftime(date_str, 20, "%b %d, %Y", date); <nl> +      else <nl> +          g_strlcpy(date_str, "Not representable", sizeof date_str); <nl>        proto_tree_add_uint_format_value(tree, *(attr->phf), tvb, offset, 2, temp_data, "%s", date_str); <nl>        consumed = 2; <nl>        break;
@@ -47,8 +47,8 @@ typedef union _EslFlagsUnion <nl>          guint16    extended     : 1; <nl>          guint16    port11       : 1; <nl>          guint16    port10       : 1; <nl> -        guint16    crcError     : 1; <nl>          guint16    alignError   : 1; <nl> +        guint16    crcError     : 1; <nl>          guint16    timeStampEna : 1; <nl>          guint16    port9        : 1; <nl>          guint16    port8        : 1; <nl> @@ -73,8 +73,8 @@ typedef union _EslFlagsUnion <nl>  #define esl_extended_bitmask     0x0100 <nl>  #define esl_port11_bitmask       0x0200 <nl>  #define esl_port10_bitmask       0x0400 <nl> -#define esl_crcError_bitmask     0x0800 <nl> -#define esl_alignError_bitmask   0x1000 <nl> +#define esl_alignError_bitmask   0x0800 <nl> +#define esl_crcError_bitmask     0x1000 <nl>  #define esl_timeStampEna_bitmask 0x2000 <nl>  #define esl_port9_bitmask        0x4000 <nl>  #define esl_port8_bitmask        0x8000 <nl> @@ -192,8 +192,9 @@ dissect_esl_header(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void <nl>              flags =  tvb_get_letohs(tvb, offset); <nl>              proto_tree_add_uint(esl_header_tree, hf_esl_port, tvb, offset, 2, flags_to_port(flags)); <nl>   <nl> -            proto_tree_add_item(esl_header_tree, hf_esl_crcerror, tvb, offset, 2, ENC_LITTLE_ENDIAN); <nl>              proto_tree_add_item(esl_header_tree, hf_esl_alignerror, tvb, offset, 2, ENC_LITTLE_ENDIAN); <nl> +            proto_tree_add_item(esl_header_tree, hf_esl_crcerror, tvb, offset, 2, ENC_LITTLE_ENDIAN); <nl> + <nl>              offset+=2; <nl>   <nl>              proto_tree_add_item(esl_header_tree, hf_esl_timestamp, tvb, offset, 8, ENC_LITTLE_ENDIAN);
@@ -471,7 +471,7 @@ sync_pipe_start(capture_options *capture_opts) { <nl>        execv(argv[0], (gpointer)argv); <nl>        g_snprintf(errmsg, sizeof errmsg, "Couldn't run %s in child process: %s", <nl>  		argv[0], strerror(errno)); <nl> -      sync_pipe_errmsg_to_parent(errmsg, ""); <nl> +      sync_pipe_errmsg_to_parent(1, errmsg, ""); <nl>   <nl>        /* Exit with "_exit()", so that we don't close the connection <nl>           to the X server (and cause stuff buffered up by our parent but <nl> @@ -887,7 +887,11 @@ sync_interface_stats_open(int *read_fd, int *fork_child, gchar **msg) { <nl>   <nl>  /* Close down the stats process */ <nl>  int <nl> -sync_interface_stats_close(int *read_fd, int *fork_child, gchar **msg) { <nl> +sync_interface_stats_close(int *read_fd, int *fork_child <nl> +#ifndef _WIN32 <nl> +_U_ <nl> +#endif <nl> +, gchar **msg) { <nl>  #ifdef _WIN32 <nl>      return sync_pipe_close_command(read_fd, fork_child, msg); <nl>  #else
@@ -191,10 +191,12 @@ dlg_button_row_new(const gchar *stock_id_first, ...) <nl>      gtk_box_pack_end(GTK_BOX(hbox), button_hbox, TRUE, TRUE, 0); <nl>      g_object_set_data(G_OBJECT(hbox), BUTTON_HBOX_KEY, button_hbox); <nl>      gtk_widget_show(button_hbox); <nl> +    gtk_button_box_set_spacing(GTK_BUTTON_BOX(button_hbox), 5); <nl>   <nl>      help_hbox = gtk_hbutton_box_new(); <nl>      gtk_box_pack_end(GTK_BOX(hbox), help_hbox, FALSE, FALSE, 0); <nl>      gtk_widget_show(help_hbox); <nl> +    gtk_button_box_set_spacing(GTK_BUTTON_BOX(help_hbox), 5); <nl>   <nl>      if (buttons == 0) { <nl>          /* if no buttons wanted, simply do nothing */ <nl> @@ -230,7 +232,6 @@ dlg_button_row_new(const gchar *stock_id_first, ...) <nl>      /* if more than one button, sort buttons from left to right */ <nl>      /* (the whole button cluster will then be right aligned) */ <nl>      gtk_button_box_set_layout (GTK_BUTTON_BOX(button_hbox), GTK_BUTTONBOX_END); <nl> -    gtk_button_box_set_spacing(GTK_BUTTON_BOX(button_hbox), 5); <nl>   <nl>  /* GTK+ 1.3 and later - on Win32, we use 1.3[.x] or 2.x, not 1.2[.x] */ <nl>  #if !defined(_WIN32) <nl> @@ -364,8 +365,6 @@ dlg_button_row_new(const gchar *stock_id_first, ...) <nl>      if (close   != NULL) dlg_button_new(hbox, button_hbox, close); <nl>      if (cancel  != NULL) dlg_button_new(hbox, button_hbox, cancel); <nl>   <nl> -    /* GTK2: we don't know that button combination, add it to the above list! */ <nl> -    /* g_assert_not_reached(); */ <nl>      return hbox; <nl>  } <nl>  
@@ -225,6 +225,8 @@ static int FieldInfo_get_range(lua_State* L) { <nl>      r->tvb = ep_new(struct _wslua_tvb); <nl>   <nl>      r->tvb->ws_tvb = fi->ds_tvb; <nl> +    r->tvb->expired = FALSE; <nl> +    r->tvb->need_free = FALSE; <nl>      r->offset = fi->start; <nl>      r->len = fi->length; <nl>  
@@ -2228,6 +2228,7 @@ tvb_uncompress(tvbuff_t *tvb, int offset, int comprlen) <nl>  	compr = tvb_memdup(tvb, offset, comprlen); <nl>   <nl>  	if (!compr) { <nl> +		g_free(strm); <nl>  		return NULL; <nl>  	} <nl>   <nl> @@ -2257,6 +2258,7 @@ tvb_uncompress(tvbuff_t *tvb, int offset, int comprlen) <nl>   <nl>  	if(strmbuf == NULL) { <nl>  		g_free(compr); <nl> +		g_free(strm); <nl>  		return NULL; <nl>  	} <nl>  
@@ -3005,7 +3005,7 @@ create_conv_and_add_proto_data(packet_info *pinfo, guint64 service_id, <nl>      conversation_add_proto_data(conv, proto_infiniband, proto_data); <nl>   <nl>      /* next, register the conversation using the LIDs */ <nl> -    set_address(addr, AT_IB, sizeof(guint16), &lid); <nl> +    set_address(addr, AT_IB, sizeof(guint16), wmem_memdup(pinfo->pool, &lid, sizeof lid)); <nl>      conv = conversation_new(pinfo->num, addr, addr, <nl>                              PT_IBQP, port, port, options); <nl>      conversation_add_proto_data(conv, proto_infiniband, proto_data);
@@ -1,6 +1,6 @@ <nl>  /* follow.c <nl>   * <nl> - * $Id: follow.c,v 1.3 1998/10/10 03:32:09 gerald Exp $ <nl> + * $Id: follow.c,v 1.4 1998/10/28 01:29:16 guy Exp $ <nl>   * <nl>   * Copyright 1998 Mike Hall <mlh@io.com> <nl>   * <nl> @@ -142,7 +142,7 @@ reassemble_tcp( u_long sequence, u_long length, const char* data, int synflag, u <nl>        tmp_frag->data = (u_char *)malloc( length ); <nl>        tmp_frag->seq = sequence; <nl>        tmp_frag->len = length; <nl> -      bcopy( data, tmp_frag->data, length ); <nl> +      memcpy( tmp_frag->data, data, length ); <nl>        if( frags[src_index] ) { <nl>  	tmp_frag->next = frags[src_index]; <nl>        } else {
@@ -1,7 +1,7 @@ <nl>  /* proto.c <nl>   * Routines for protocol tree <nl>   * <nl> - * $Id: proto.c,v 1.59 2000/04/04 06:17:29 guy Exp $ <nl> + * $Id: proto.c,v 1.60 2000/04/04 17:07:07 gram Exp $ <nl>   * <nl>   * Ethereal - Network traffic analyzer <nl>   * By Gerald Combs <gerald@zing.org> <nl> @@ -506,7 +506,8 @@ proto_tree_add_bytes_format(proto_tree *tree, int hfindex, gint start, gint leng <nl>  static void <nl>  proto_tree_set_bytes(field_info *fi, const guint8* start_ptr, gint length) <nl>  { <nl> - <nl> +	g_assert(start_ptr != NULL); <nl> +	g_assert(length > 0); <nl>  	/* This g_malloc'ed memory is freed in <nl>  	   proto_tree_free_node() */ <nl>  	fi->value.bytes = g_malloc(length); <nl> @@ -834,6 +835,7 @@ proto_tree_add_field_info(int hfindex, gint start, gint length, int visible) <nl>   <nl>  	fi = g_mem_chunk_alloc(gmc_field_info); <nl>   <nl> +	g_assert(hfindex >= 0 && hfindex < gpa_hfinfo->len); <nl>  	fi->hfinfo = proto_registrar_get_nth(hfindex); <nl>  	g_assert(fi->hfinfo != NULL); <nl>  	fi->start = start;
@@ -1503,7 +1503,9 @@ dissect_icqv5Client(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) <nl>       * bytes in the buffer. <nl>       */ <nl>      rounded_size = ((((capturedsize - ICQ5_CL_SESSIONID) + 3)/4)*4) + ICQ5_CL_SESSIONID; <nl> -    decr_pd = tvb_memdup(tvb, 0, capturedsize); <nl> +    /* rounded_size might exceed the tvb bounds so we can't just use tvb_memdup here. */ <nl> +    decr_pd = g_malloc(rounded_size); <nl> +    tvb_memcpy(tvb, decr_pd, 0, capturedsize); <nl>      decrypt_v5(decr_pd, rounded_size, key); <nl>   <nl>      /* Allocate a new tvbuff, referring to the decrypted data. */
@@ -53,6 +53,13 @@ gboolean ws_strtou64(const gchar* str, guint64* cint) <nl>  	gchar* endptr; <nl>  	guint64 val; <nl>   <nl> +	if (str[0] == '-' || str[0] == '+') { <nl> +		/* <nl> +		 * Unsigned numbers don't have a sign. <nl> +		 */ <nl> +		errno = EINVAL; <nl> +		return FALSE; <nl> +	} <nl>  	errno = 0; <nl>  	val = g_ascii_strtoull(str, &endptr, 10); <nl>  	if ((val == 0 && endptr == str) || (*endptr != 0)) {
@@ -4520,7 +4520,7 @@ dissect_sigcomp_tcp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *_ <nl>   <nl>      col_clear(pinfo->cinfo, COL_INFO); <nl>   <nl> -    length = tvb_captured_length_remaining(tvb,offset); <nl> +    length = tvb_reported_length(tvb); <nl>   <nl>  try_again: <nl>      /* create display subtree for the protocol */
@@ -1466,7 +1466,7 @@ dissect_sip_contact_item(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gi <nl>  	gint current_offset; <nl>  	gint queried_offset; <nl>  	gint contact_params_start_offset = -1; <nl> -	gint contact_param_end_offset = -1; <nl> +	/*gint contact_param_end_offset = -1;*/ <nl>  	uri_offset_info uri_offsets; <nl>   <nl>  	/* skip Spaces and Tabs */
@@ -2816,6 +2816,8 @@ ssl_association_remove(GTree* associations, SslAssociation *assoc) <nl>    if (assoc->handle) <nl>      dissector_delete((assoc->tcp)?"tcp.port":"udp.port", assoc->ssl_port, assoc->handle); <nl>   <nl> +  g_free(assoc->info); <nl> + <nl>    g_tree_remove(associations, assoc); <nl>    g_free(assoc); <nl>  }
@@ -555,7 +555,14 @@ extern int dissect_snmp_VarBind(gboolean implicit_tag _U_, <nl>   <nl>  	add_oid_debug_subtree(oid_info,pt_name); <nl>   <nl> -	if (subids && oid_matched+oid_left) { <nl> +	if (!subids) { <nl> +		proto_item* pi = proto_tree_add_text(pt_name,tvb, 0, 0, "invalid oid: %s", oid_bytes); <nl> +		pt = proto_item_add_subtree(pi, ett_decoding_error); <nl> +		expert_add_info_format(actx->pinfo, pi, PI_MALFORMED, PI_WARN, "invalid oid: %s", oid_bytes); <nl> +		return dissect_unknown_ber(actx->pinfo, tvb, name_offset, pt); <nl> +	} <nl> + <nl> +	if (oid_matched+oid_left) { <nl>  		oid_string = oid_subid2string(subids,oid_matched+oid_left); <nl>  	} <nl>  
@@ -7961,7 +7961,7 @@ dissect_extended_capabilities_ie(packet_info *pinfo, proto_tree *tree, <nl>      expert_add_info_format(pinfo, ti_len, PI_MALFORMED, PI_ERROR, "Tag length %u too short, must be greater than 0", tag_len); <nl>      return offset; <nl>    } <nl> -  proto_item_append_text(ti, " (%d octets)", tag_len); <nl> +  proto_item_append_text(ti, " (%u octet%s)", tag_len, plurality(tag_len, "", "s")); <nl>   <nl>    /* Extended Capability octet 1 */ <nl>    ti_ex_cap = proto_tree_add_item(tree, hf_ieee80211_tag_extended_capabilities, tvb, offset, 1, ENC_NA); <nl> @@ -11427,7 +11427,7 @@ add_tagged_field(packet_info *pinfo, proto_tree *tree, tvbuff_t *tvb, int offset <nl>                               " (%s) code not implemented, Contact" <nl>                               " Wireshark developers if you want this supported", val_to_str_ext(tag_no, <nl>                                              &tag_num_vals_ext, "(%d)")); <nl> -      proto_item_append_text(ti, ": Tag %u Len %u", tag_no, tag_len); <nl> +      proto_item_append_text(ti, ": Undecoded"); <nl>        break; <nl>    } <nl>    if (offset < tag_end) {
@@ -1138,12 +1138,15 @@ reassemble_octet_string(asn1_ctx_t *actx, proto_tree *tree, gint hf_id, tvbuff_t <nl>   <nl>    /* so we need to consume octet strings for the given length */ <nl>   <nl> -  /* not sure we need this */ <nl> -  actx->pinfo->fragmented = TRUE; <nl> - <nl>    if(out_tvb) <nl>      *out_tvb=NULL; <nl>   <nl> +  if (con_len == 0) /* Zero encodings (8.7.3) */ <nl> +    return offset; <nl> + <nl> +  /* not sure we need this */ <nl> +  actx->pinfo->fragmented = TRUE; <nl> + <nl>    while(!fd_head) { <nl>   <nl>      offset = dissect_ber_octet_string(FALSE, actx, NULL, tvb, offset, hf_id, &next_tvb);
@@ -3502,8 +3502,9 @@ static int decode_bgp_link_nlri_prefix_descriptors(tvbuff_t *tvb, <nl>              break; <nl>   <nl>              case BGP_NLRI_TLV_IP_REACHABILITY_INFORMATION: <nl> -                decode_prefix4(tlv_sub_tree, pinfo, tlv_sub_item, hf_bgp_ls_nlri_ip_reachability_prefix_ip, <nl> -                               tvb, offset + 4, 0, "Reachability"); <nl> +                if (decode_prefix4(tlv_sub_tree, pinfo, tlv_sub_item, hf_bgp_ls_nlri_ip_reachability_prefix_ip, <nl> +                               tvb, offset + 4, 0, "Reachability") == -1) <nl> +                    return diss_length; <nl>              break; <nl>          } <nl>  
@@ -4616,6 +4616,7 @@ create_main_window (gint pl_size, gint tv_size, gint bv_size, e_prefs *prefs) <nl>              channel_list = g_list_append(channel_list, ieee80211_mhz_to_str(airpcap_if_active->pSupportedChannels[i].Frequency)); <nl>          } <nl>          gtk_combo_set_popdown_strings( GTK_COMBO(channel_cm), channel_list); <nl> +        g_list_free(channel_list); <nl>      } <nl>   <nl>      gtk_tooltips_set_tip(airpcap_tooltips, GTK_WIDGET(GTK_COMBO(channel_cm)->entry), <nl> @@ -4695,6 +4696,7 @@ create_main_window (gint pl_size, gint tv_size, gint bv_size, e_prefs *prefs) <nl>      linktype_list = g_list_append(linktype_list, AIRPCAP_VALIDATION_TYPE_NAME_CORRUPT); <nl>   <nl>      gtk_combo_set_popdown_strings( GTK_COMBO(wrong_crc_cm), linktype_list) ; <nl> +    g_list_free(linktype_list); <nl>      gtk_tooltips_set_tip(airpcap_tooltips, GTK_WIDGET(GTK_COMBO(wrong_crc_cm)->entry), <nl>  	"Select the 802.11 FCS filter that the wireless adapter will apply.", <nl>          NULL);
@@ -1473,8 +1473,6 @@ dissect_spnego_supportedMech(tvbuff_t *tvb, int offset, packet_info *pinfo _U_, <nl>  	  proto_tree_add_text(tree, tvb, offset, nbytes, "supportedMech: %s", <nl>  			      oid_string); <nl>   <nl> -	g_free(oid_string); <nl> - <nl>  	offset += nbytes; <nl>   <nl>  	/* Should check for an unrecognized OID ... */
@@ -8,7 +8,7 @@ <nl>   *          PKT-SP-EC-MGCP-I09-040113, January 13, 2004, Cable Television  <nl>   *          Laboratories, Inc., http://www.PacketCable.com/ <nl>   * <nl> - * $Id: packet-mgcp.c,v 1.46 2004/05/30 17:58:35 etxrab Exp $ <nl> + * $Id: packet-mgcp.c,v 1.47 2004/05/31 19:31:14 etxrab Exp $ <nl>   * <nl>   * Copyright (c) 2000 by Ed Warnicke <hagbard@physics.rutgers.edu> <nl>   * Copyright (c) 2004 by Thomas Anders <thomas.anders [AT] blue-cable.de> <nl> @@ -1512,6 +1512,9 @@ dissect_mgcp_connectionparams(proto_tree *parent_tree, tvbuff_t *tvb, gint offse <nl>      } <nl>      offset += tokenlen+1; /* 1 extra for the delimiter */ <nl>    } <nl> +  g_strfreev(typval); <nl> +  g_strfreev(tokens); <nl> + <nl>  } <nl>   <nl>  /*
@@ -155,6 +155,7 @@ proto_register_xot(void) <nl>  	proto_xot = proto_register_protocol("X.25 over TCP", "XOT", "xot"); <nl>  	proto_register_field_array(proto_xot, hf, array_length(hf)); <nl>  	proto_register_subtree_array(ett, array_length(ett)); <nl> +	register_dissector("xot", dissect_xot, proto_xot); <nl>   <nl>  	xot_module = prefs_register_protocol(proto_xot, NULL); <nl>  	prefs_register_bool_preference(xot_module, "desegment",
@@ -3681,6 +3681,14 @@ ssl_find_private_key(SslDecryptSession *ssl_session, GHashTable *key_hash, GTree <nl>      ssl_debug_printf("ssl_find_private_key server %s:%u\n", <nl>                       ep_address_to_str(&dummy.addr),dummy.port); <nl>   <nl> +    if (g_hash_table_size(key_hash) == 0) { <nl> +        ssl_debug_printf("ssl_find_private_key: no keys found\n"); <nl> +        return; <nl> +    } else { <nl> +        ssl_debug_printf("ssl_find_private_key: testing %i keys\n", <nl> +            g_hash_table_size(key_hash)); <nl> +    } <nl> + <nl>      /* try to retrieve private key for this service. Do it now 'cause pinfo <nl>       * is not always available <nl>       * Note that with HAVE_LIBGNUTLS undefined private_key is allways 0
@@ -2508,6 +2508,7 @@ capture_loop_init_output(capture_options *capture_opts, loop_data *ld, char *err <nl>                                  -1,                          /* section_length */ <nl>                                  &ld->bytes_written, <nl>                                  &err); <nl> +            g_string_free(cpu_info_str, TRUE); <nl>              g_free(appname); <nl>   <nl>              for (i = 0; successful && (i < capture_opts->ifaces->len); i++) { <nl> @@ -3009,6 +3010,7 @@ do_file_switch_or_stop(capture_options *capture_opts, <nl>                                  -1,                          /* section_length */ <nl>                                  &(global_ld.bytes_written), <nl>                                  &global_ld.err); <nl> +                g_string_free(cpu_info_str, TRUE); <nl>                  g_free(appname); <nl>   <nl>                  for (i = 0; successful && (i < capture_opts->ifaces->len); i++) {
@@ -68,7 +68,7 @@ register_all_protocols(register_cb cb, gpointer cb_data) <nl>      } <nl>      g_thread_join(rapw_thread); <nl>      if (cb && !called_back) { <nl> -            cb(RA_REGISTER, "Registration finished", cb_data); <nl> +        cb(RA_REGISTER, "finished", cb_data); <nl>      } <nl>  } <nl>   <nl> @@ -104,7 +104,7 @@ register_all_protocol_handoffs(register_cb cb, gpointer cb_data) <nl>      } <nl>      g_thread_join(raphw_thread); <nl>      if (cb && !called_back) { <nl> -            cb(RA_HANDOFF, "Registration finished", cb_data); <nl> +        cb(RA_HANDOFF, "finished", cb_data); <nl>      } <nl>      g_async_queue_unref(register_cb_done_q); <nl>  
@@ -4778,7 +4778,7 @@ dissect_dcerpc_cn_bs_body(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) <nl>                   * it was just too short to tell and ask the TCP layer for more <nl>                   * data. */ <nl>                  pinfo->desegment_offset = offset; <nl> -                pinfo->desegment_len = sizeof(e_dce_cn_common_hdr_t) - tvb_length_remaining(tvb, offset); <nl> +                pinfo->desegment_len = (guint32)(sizeof(e_dce_cn_common_hdr_t) - tvb_length_remaining(tvb, offset)); <nl>              } else { <nl>                  /* Really not DCE-RPC */ <nl>                  break;
@@ -4103,6 +4103,9 @@ be_field_element_dissect(tvbuff_t *tvb, proto_tree *tree, guint32 offset, guint <nl>          str = match_strval_idx((guint32) oct, bssmap_field_element_ids, &idx); <nl>          ie_len = tvb_get_guint8(tvb, curr_offset++); <nl>   <nl> +	if (!str) <nl> +	    str = "Unknown"; <nl> + <nl>          /* <nl>           * add Field Element name <nl>           */
@@ -514,6 +514,9 @@ main_filter_packets(capture_file *cf, const gchar *dftext, gboolean force) <nl>    char      *s; <nl>    cf_status_t cf_status; <nl>   <nl> +  /* we'll crash later on if dftext is NULL */ <nl> +  g_assert(dftext != NULL); <nl> +   <nl>    s = g_strdup(dftext); <nl>   <nl>    /* GtkCombos don't let us get at their list contents easily, so we maintain
@@ -36,7 +36,6 @@ <nl>  #include "wireshark_application.h" <nl>   <nl>  // To do: <nl> -// - Use a different icon? <nl>  // - Add an NSProgressIndicator to the dock icon on OS X. <nl>  // - Start adding the progress bar to dialogs. <nl>  // - Don't complain so loudly when the user stops a capture. <nl> @@ -81,7 +80,9 @@ static const int app_update_freq_ = 100; // ms <nl>  void <nl>  update_progress_dlg(progdlg_t *dlg, gfloat percentage, const gchar *) <nl>  { <nl> -    if (!dlg || dlg->elapsed_timer->elapsed() < app_update_freq_) return; <nl> +    if (!dlg) return; <nl> +    if (dlg->elapsed_timer->isValid() && !dlg->elapsed_timer->hasExpired(app_update_freq_)) return; <nl> +    dlg->elapsed_timer->restart(); <nl>   <nl>      dlg->progress_frame->setValue(percentage * 100); <nl>   <nl> @@ -89,7 +90,6 @@ update_progress_dlg(progdlg_t *dlg, gfloat percentage, const gchar *) <nl>       * Flush out the update and process any input events. <nl>       */ <nl>      WiresharkApplication::processEvents(); <nl> -    dlg->elapsed_timer->restart(); <nl>   <nl>      /* Redraw so the progress bar shows the update */ <nl>      dlg->progress_frame->update(); <nl> @@ -170,7 +170,7 @@ struct progdlg *ProgressFrame::showProgress(bool animate, bool terminate_is_stop <nl>  { <nl>      setMaximumValue(100); <nl>      ui->progressBar->setValue(value); <nl> -    progress_dialog_.elapsed_timer->start(); <nl> +    progress_dialog_.elapsed_timer->invalidate(); <nl>      emit showRequested(animate, terminate_is_stop, stop_flag); <nl>      return &progress_dialog_; <nl>  }
@@ -623,6 +623,7 @@ pcapng_read_section_header_block(FILE_T fh, pcapng_block_header_t *bh, <nl>          bytes_read = pcapng_read_option(fh, pn, &oh, option_content, opt_cont_buf_len, to_read, err, err_info, "section_header"); <nl>          if (bytes_read <= 0) { <nl>              pcapng_debug("pcapng_read_section_header_block: failed to read option"); <nl> +            g_free(option_content); <nl>              return PCAPNG_BLOCK_ERROR; <nl>          } <nl>          to_read -= bytes_read;
@@ -159,6 +159,8 @@ int ieee80211_radiotap_iterator_init( <nl>   <nl>  	/* find payload start allowing for extended bitmap(s) */ <nl>  	if (iterator->_bitmap_shifter & (1<<IEEE80211_RADIOTAP_EXT)) { <nl> +		if (!ITERATOR_VALID(iterator, sizeof(guint32))) <nl> +			return -EINVAL; <nl>  		while (get_unaligned_le32(iterator->_arg) & <nl>  					(1 << IEEE80211_RADIOTAP_EXT)) { <nl>  			iterator->_arg += sizeof(guint32);
@@ -106,6 +106,7 @@ static void php_sqlite_function_callback(sqlite_func *func, int argc, const char <nl>  	zval ***zargs; <nl>  	zval funcname; <nl>  	int i, res; <nl> +	char *callable = NULL, *errbuf=NULL; <nl>   <nl>  	/* sanity check the args */ <nl>  	if (argc == 0) { <nl> @@ -115,10 +116,14 @@ static void php_sqlite_function_callback(sqlite_func *func, int argc, const char <nl>  	 <nl>  	ZVAL_STRING(&funcname, (char*)argv[0], 0); <nl>   <nl> -	if (!zend_is_callable(&funcname, 0, NULL)) { <nl> -		sqlite_set_result_error(func, "function is not callable", -1); <nl> +	if (!zend_is_callable(&funcname, 0, &callable)) { <nl> +		spprintf(&errbuf, 0, "function `%s' is not callable", callable); <nl> +		sqlite_set_result_error(func, errbuf, -1); <nl> +		efree(errbuf); <nl> +		efree(callable); <nl>  		return; <nl>  	} <nl> +	efree(callable); <nl>  	 <nl>  	if (argc > 1) { <nl>  		zargs = (zval ***)emalloc((argc - 1) * sizeof(zval **));
@@ -169,6 +169,11 @@ PHP_FUNCTION(shmop_open) <nl>  			goto err; <nl>  	} <nl>   <nl> +	if (shmop->size < 1) { <nl> +		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Shared memory segment size must be greater then zero."); <nl> +		goto err; <nl> +	} <nl> + <nl>  	shmop->shmid = shmget(shmop->key, shmop->size, shmop->shmflg); <nl>  	if (shmop->shmid == -1) { <nl>  		php_error_docref(NULL TSRMLS_CC, E_WARNING, "unable to attach or create shared memory segment");
@@ -250,6 +250,7 @@ ZEND_API int zend_register_constant(zend_constant *c ELS_DC) <nl>   <nl>  	zend_str_tolower(lowercase_name, c->name_len); <nl>  	if (zend_hash_add(EG(zend_constants), lowercase_name, c->name_len, (void *) c, sizeof(zend_constant), NULL)==FAILURE) { <nl> +		free(c->name); <nl>  		zval_dtor(&c->value); <nl>  		zend_error(E_NOTICE,"Constant %s already defined",lowercase_name); <nl>  		ret = FAILURE;
@@ -1578,6 +1578,11 @@ static int _php_ibase_def_trans(ibase_db_link * ib_link, int trans_n) <nl>  { <nl>  	TSRMLS_FETCH(); <nl>  	 <nl> +	if (ib_link == NULL) { <nl> +		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid database link"); <nl> +		return FAILURE; <nl> +	} <nl> + <nl>  	if (trans_n == 0 && ib_link->trans[0] == NULL) {  <nl>  		if (isc_start_transaction(IB_STATUS, &ib_link->trans[0], 1, &ib_link->link, 0, NULL)) { <nl>  			_php_ibase_error(TSRMLS_C); <nl> @@ -1615,6 +1620,11 @@ static void _php_ibase_trans_end(INTERNAL_FUNCTION_PARAMETERS, int commit) <nl>  			break; <nl>  	} <nl>   <nl> +	if (ib_link == NULL) { <nl> +		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid database link"); <nl> +		RETURN_FALSE; <nl> +	} <nl> + <nl>  	if (ib_link->trans[trans_n] == NULL) { <nl>  		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Trying to commit or rollback an already handled transaction"); <nl>  		RETURN_FALSE;
@@ -1708,11 +1708,11 @@ static void exif_iif_add_value(image_info_type *image_info, int section_index, c <nl>  			if (!length) <nl>  				break; <nl>  		case TAG_FMT_UNDEFINED: <nl> -			if (tag == TAG_MAKER_NOTE) { <nl> -				length = MIN(length, strlen(value)); <nl> -			} <nl> - <nl>  			if (value) { <nl> +				if (tag == TAG_MAKER_NOTE) { <nl> +					length = MIN(length, strlen(value)); <nl> +				} <nl> + <nl>  				/* do not recompute length here */ <nl>  				info_value->s = estrndup(value, length); <nl>  				info_data->length = length;
@@ -508,9 +508,9 @@ static void php_dba_open(INTERNAL_FUNCTION_PARAMETERS, int persistent) <nl>  		RETURN_FALSE; <nl>  	} <nl>  			 <nl> -	info = emalloc(sizeof(dba_info)); <nl> +	info = pemalloc(sizeof(dba_info), persistent); <nl>  	memset(info, 0, sizeof(dba_info)); <nl> -	info->path = estrdup(Z_STRVAL_PP(args[0])); <nl> +	info->path = pestrdup(Z_STRVAL_PP(args[0]), persistent); <nl>  	info->mode = modenr; <nl>  	info->argc = ac - 3; <nl>  	info->argv = args + 3; <nl> @@ -533,7 +533,7 @@ static void php_dba_open(INTERNAL_FUNCTION_PARAMETERS, int persistent) <nl>   <nl>  	if (!error && lock_mode) { <nl>  		if (lock_dbf) { <nl> -			info->lock.name = estrdup(info->path); <nl> +			info->lock.name = pestrdup(info->path, persistent); <nl>  			lock_file_mode = file_mode; <nl>  		} else { <nl>  			spprintf(&info->lock.name, 0, "%s.lck", info->path);
@@ -597,8 +597,9 @@ ZEND_METHOD(Generator, __wakeup) <nl>  static void zend_generator_iterator_dtor(zend_object_iterator *iterator TSRMLS_DC) /* {{{ */ <nl>  { <nl>  	zend_generator *generator = (zend_generator*)Z_OBJ(iterator->data); <nl> -	zval_ptr_dtor(&iterator->data); <nl>  	generator->iterator = NULL; <nl> +	zval_ptr_dtor(&iterator->data); <nl> +	zend_iterator_dtor(iterator TSRMLS_CC); <nl>  } <nl>  /* }}} */ <nl>  
@@ -612,6 +612,11 @@ int make_http_soap_request(zval  *this_ptr, <nl>  						smart_str_append_const(&soap_headers, "\", opaque=\""); <nl>  						smart_str_appendl(&soap_headers, Z_STRVAL_PP(tmp), Z_STRLEN_PP(tmp)); <nl>  					} <nl> +					if (zend_hash_find(Z_ARRVAL_PP(digest), "algorithm", sizeof("algorithm"), (void **)&tmp) == SUCCESS && <nl> +						Z_TYPE_PP(tmp) == IS_STRING) { <nl> +						smart_str_append_const(&soap_headers, "\", algorithm=\""); <nl> +						smart_str_appendl(&soap_headers, Z_STRVAL_PP(tmp), Z_STRLEN_PP(tmp)); <nl> +					} <nl>  					smart_str_append_const(&soap_headers, "\"\r\n"); <nl>  				} <nl>  			} else {
@@ -356,7 +356,7 @@ int PostHeader(char *RPath, char *Subject, char *mailTo, char *xheaders) <nl>  					 tm->tm_hour, <nl>  					 tm->tm_min, <nl>  					 tm->tm_sec, <nl> -					 (_timezone > 0) ? "+" : (_timezone < 0) ? "-" : "", <nl> +					 (_timezone <= 0) ? "+" : (_timezone > 0) ? "-" : "", <nl>  					 zoneh, <nl>  					 zonem); <nl>  	}
@@ -1273,6 +1273,7 @@ PHP_FUNCTION(yaz_connect) <nl>  #if USE_ZOOM <nl>  		if (persistent && as && !as->in_use && <nl>  			!strcmp_null(option_get(as, "host"), zurl_str) && <nl> +			!strcmp_null(option_get(as, "proxy"), proxy_str) && <nl>  			!strcmp_null(option_get(as, "user"), user_str) && <nl>  			!strcmp_null(option_get(as, "group"), group_str) && <nl>  			!strcmp_null(option_get(as, "pass"), pass_str) &&
@@ -800,8 +800,9 @@ PHP_FUNCTION(tempnam) <nl>  	zval **arg1, **arg2; <nl>  	char *d; <nl>  	char *opened_path; <nl> -	char p[64]; <nl> +	char *p; <nl>  	int fd; <nl> +	size_t p_len; <nl>   <nl>  	if (ZEND_NUM_ARGS() != 2 || zend_get_parameters_ex(2, &arg1, &arg2) == FAILURE) { <nl>  		WRONG_PARAM_COUNT; <nl> @@ -814,7 +815,11 @@ PHP_FUNCTION(tempnam) <nl>  	} <nl>  	 <nl>  	d = estrndup(Z_STRVAL_PP(arg1), Z_STRLEN_PP(arg1)); <nl> -	strlcpy(p, Z_STRVAL_PP(arg2), sizeof(p)); <nl> + <nl> +	php_basename(Z_STRVAL_PP(arg2), Z_STRLEN_PP(arg2), NULL, 0, &p, &p_len TSRMLS_CC); <nl> +	if (p_len > 64) { <nl> +		p[63] = '\0'; <nl> +	} <nl>   <nl>  	if ((fd = php_open_temporary_fd(d, p, &opened_path TSRMLS_CC)) >= 0) { <nl>  		close(fd); <nl> @@ -825,6 +830,7 @@ PHP_FUNCTION(tempnam) <nl>  	} else { <nl>  		RETVAL_FALSE; <nl>  	} <nl> +	efree(p); <nl>  	efree(d); <nl>  } <nl>  /* }}} */
@@ -590,6 +590,9 @@ PHPAPI size_t _php_stream_read(php_stream *stream, char *buf, size_t size TSRMLS <nl>  			/* EOF, or temporary end of data (for non-blocking mode). */ <nl>  			break; <nl>  		} <nl> + <nl> +		/* just break anyway, to avoid greedy read */ <nl> +		break; <nl>  	} <nl>   <nl>  	if (didread > 0) {
@@ -530,6 +530,10 @@ TSRM_API FILE *popen_ex(const char *command, const char *type, const char *cwd, <nl>  	} <nl>   <nl>  	cmd = (char*)malloc(strlen(command)+strlen(TWG(comspec))+sizeof(" /c ")+2); <nl> +	if (!cmd) { <nl> +		return NULL; <nl> +	} <nl> + <nl>  	sprintf(cmd, "%s /c \"%s\"", TWG(comspec), command); <nl>  	if (asuser) { <nl>  		res = CreateProcessAsUser(token_user, NULL, cmd, &security, &security, security.bInheritHandle, dwCreateFlags, env, cwd, &startup, &process);
@@ -153,7 +153,7 @@ PHPAPI int php_uudecode(char *src, int src_len, char **dest) /* {{{ */ <nl>  		while (s < ee) { <nl>  			if(s+4 > e) { <nl>  				goto err; <nl> -			}  <nl> +			} <nl>  			*p++ = PHP_UU_DEC(*s) << 2 | PHP_UU_DEC(*(s + 1)) >> 4; <nl>  			*p++ = PHP_UU_DEC(*(s + 1)) << 4 | PHP_UU_DEC(*(s + 2)) >> 2; <nl>  			*p++ = PHP_UU_DEC(*(s + 2)) << 6 | PHP_UU_DEC(*(s + 3)); <nl> @@ -188,7 +188,7 @@ PHPAPI int php_uudecode(char *src, int src_len, char **dest) /* {{{ */ <nl>  } <nl>  /* }}} */ <nl>   <nl> -/* {{{ proto string convert_uuencode(string data)  <nl> +/* {{{ proto string convert_uuencode(string data) <nl>     uuencode a string */ <nl>  PHP_FUNCTION(convert_uuencode) <nl>  { <nl> @@ -200,6 +200,11 @@ PHP_FUNCTION(convert_uuencode) <nl>  	} <nl>   <nl>  	dst_len = php_uuencode(src, src_len, &dst); <nl> +	if (dst_len < 0) { <nl> +		php_error_docref(NULL TSRMLS_CC, E_WARNING, "String too long, max length is %d", INT_MAX); <nl> +		efree(dst); <nl> +		RETURN_FALSE; <nl> +	} <nl>   <nl>  	RETURN_STRINGL(dst, dst_len, 0); <nl>  }
@@ -860,11 +860,11 @@ static void php_var_serialize_class(smart_str *buf, zval *struc, zval *retval_pt <nl>  							} else { <nl>  								php_var_serialize_string(buf, priv_name.s, prop_name_length); <nl>  							} <nl> -							efree(priv_name.v); <nl> +							pefree(priv_name.v, ce->type & ZEND_INTERNAL_CLASS); <nl>  							php_var_serialize_intern(buf, *d, var_hash TSRMLS_CC); <nl>  							break; <nl>  						} <nl> -						efree(priv_name.v); <nl> +						pefree(priv_name.v, ce->type & ZEND_INTERNAL_CLASS); <nl>  						zend_u_mangle_property_name(&prot_name, &prop_name_length, Z_TYPE_PP(name), star, 1, Z_UNIVAL_PP(name), Z_UNILEN_PP(name), ce->type & ZEND_INTERNAL_CLASS); <nl>  						if (zend_u_hash_find(Z_OBJPROP_P(struc), Z_TYPE_PP(name), prot_name, prop_name_length+1, (void *) &d) == SUCCESS) { <nl>  							if (Z_TYPE_PP(name) == IS_UNICODE) { <nl> @@ -872,11 +872,11 @@ static void php_var_serialize_class(smart_str *buf, zval *struc, zval *retval_pt <nl>  							} else { <nl>  								php_var_serialize_string(buf, prot_name.s, prop_name_length); <nl>  							} <nl> -							efree(prot_name.v); <nl> +							pefree(prot_name.v, ce->type & ZEND_INTERNAL_CLASS); <nl>  							php_var_serialize_intern(buf, *d, var_hash TSRMLS_CC); <nl>  							break; <nl>  						} <nl> -						efree(prot_name.v); <nl> +						pefree(prot_name.v, ce->type & ZEND_INTERNAL_CLASS); <nl>  						php_error_docref(NULL TSRMLS_CC, E_NOTICE, "\"%R\" returned as member variable from __sleep() but does not exist", Z_TYPE_PP(name), Z_UNIVAL_PP(name)); <nl>  						if (Z_TYPE_PP(name) == IS_UNICODE) { <nl>  							php_var_serialize_unicode(buf, Z_USTRVAL_PP(name), Z_USTRLEN_PP(name));
@@ -1768,7 +1768,7 @@ PHP_FUNCTION(ncurses_termname) <nl>  	 <nl>  	IS_NCURSES_INITIALIZED(); <nl>   <nl> -	strncpy(temp, termname(), sizeof(temp) - 1); <nl> +	strlcpy(temp, termname(), sizeof(temp) - 1); <nl>  	temp[sizeof(temp) - 1] = '\0'; <nl>   <nl>  	RETURN_STRINGL (temp, strlen(temp), 1); <nl> @@ -1783,7 +1783,7 @@ PHP_FUNCTION(ncurses_longname) <nl>   <nl>  	IS_NCURSES_INITIALIZED(); <nl>   <nl> -	strncpy(temp, longname(), sizeof(temp) - 1); <nl> +	strlcpy(temp, longname(), sizeof(temp) - 1); <nl>  	temp[sizeof(temp) - 1] = '\0'; <nl>   <nl>  	RETURN_STRINGL (temp, strlen(temp), 1);
@@ -30,6 +30,9 @@ ZEND_EXTERN_MODULE_GLOBALS(phpdbg); <nl>   <nl>  int phpdbg_is_numeric(const char *str) /* {{{ */ <nl>  { <nl> +    if (!str) <nl> +        return 0; <nl> + <nl>  	for (; *str; str++) { <nl>  		if (isspace(*str)) { <nl>  			continue; <nl> @@ -41,6 +44,9 @@ int phpdbg_is_numeric(const char *str) /* {{{ */ <nl>   <nl>  int phpdbg_is_empty(const char *str) /* {{{ */ <nl>  { <nl> +    if (!str) <nl> +        return 1; <nl> +     <nl>  	for (; *str; str++) { <nl>  		if (isspace(*str)) { <nl>  			continue;
@@ -143,7 +143,7 @@ static int php_iconv_string(char *in_p, unsigned int in_len, <nl>  	  I added 15 extra bytes for safety. <yohgaki@php.net> <nl>  	*/ <nl>      out_size = in_len * sizeof(ucs4_t) + 16; <nl> -    out_buffer = (char *) emalloc(out_size); <nl> +    out_buffer = (char *) ecalloc(1, out_size); <nl>   <nl>  	*out = out_buffer; <nl>      out_p = out_buffer;
@@ -1320,7 +1320,10 @@ void phpdbg_clean(zend_bool full TSRMLS_DC) /* {{{ */ <nl>  	} <nl>   <nl>  	if (full) { <nl> -		phpdbg_exec = strdup(PHPDBG_G(exec)); /* preserve exec, don't reparse that from cmd */ <nl> +		if (PHPDBG_G(exec)) { <nl> +			phpdbg_exec = strdup(PHPDBG_G(exec)); /* preserve exec, don't reparse that from cmd */ <nl> +		} <nl> + <nl>  		PHPDBG_G(flags) |= PHPDBG_IS_CLEANING; <nl>   <nl>  		zend_bailout();
@@ -1270,8 +1270,8 @@ MYSQLND_METHOD(mysqlnd_res, store_result_fetch_data)(MYSQLND * const conn, MYSQL <nl>  		/* libmysql's documentation says it should be so for SELECT statements */ <nl>  		conn->upsert_status.affected_rows = set->row_count; <nl>  	} <nl> -	DBG_INF_FMT("ret=%s row_count=%u warnings=%u server_status=%u", ret == PASS? "PASS":"FAIL", <nl> -				set->row_count, conn->upsert_status.warning_count, conn->upsert_status.server_status); <nl> +	DBG_INF_FMT("ret=%s row_count="MYSQLND_LLU_SPEC" warnings=%u server_status=%u", <nl> +				ret == PASS? "PASS":"FAIL", (uint) set->row_count, conn->upsert_status.warning_count, conn->upsert_status.server_status); <nl>  end: <nl>  	PACKET_FREE(row_packet); <nl>  
@@ -1303,7 +1303,7 @@ static size_t exif_convert_any_to_int(void *value, int format, int motorola_inte <nl>  			if (s_den == 0) { <nl>  				return 0; <nl>  			} else { <nl> -				return php_ifd_get32s(value, motorola_intel) / s_den; <nl> +				return (size_t)((double)php_ifd_get32s(value, motorola_intel) / s_den); <nl>  			} <nl>   <nl>  		case TAG_FMT_SSHORT:    return php_ifd_get16u(value, motorola_intel);
@@ -415,7 +415,7 @@ php_stream * php_stream_url_wrap_ftp(php_stream_wrapper *wrapper, char *path, ch <nl>  	php_stream_notify_progress_init(context, 0, file_size); <nl>   <nl>  #if HAVE_OPENSSL_EXT <nl> -	if (use_ssl_on_data && php_stream_sock_ssl_activate_with_method(datastream, 1, SSLv23_method(), reuseid) == FAILURE)	{ <nl> +	if (use_ssl_on_data && php_stream_sock_ssl_activate_with_method(datastream, 1, SSLv23_method(), reuseid TSRMLS_CC) == FAILURE)	{ <nl>  		php_stream_wrapper_log_error(wrapper, options TSRMLS_CC, "Unable to activate SSL mode"); <nl>  		php_stream_close(datastream); <nl>  		datastream = NULL;
@@ -1224,12 +1224,12 @@ static void zend_add_trait_method(zend_class_entry *ce, const char *name, zend_s <nl>  		} <nl>  	} <nl>   <nl> +	function_add_ref(fn); <nl>  	if (UNEXPECTED(fn->type == ZEND_INTERNAL_FUNCTION)) { <nl>  		new_fn = zend_arena_alloc(&CG(arena), sizeof(zend_internal_function)); <nl>  		memcpy(new_fn, fn, sizeof(zend_internal_function)); <nl>  		new_fn->common.fn_flags |= ZEND_ACC_ARENA_ALLOCATED; <nl>  	} else { <nl> -		function_add_ref(fn); <nl>  		new_fn = zend_arena_alloc(&CG(arena), sizeof(zend_op_array)); <nl>  		memcpy(new_fn, fn, sizeof(zend_op_array)); <nl>  	}
@@ -185,7 +185,7 @@ PDO_API int php_pdo_register_driver(pdo_driver_t *driver) <nl>  			driver->driver_name, driver->api_version, PDO_DRIVER_API); <nl>  		return FAILURE; <nl>  	} <nl> -	if (!zend_hash_exists(&module_registry, "PDO", sizeof("PDO"))) { <nl> +	if (!zend_hash_exists(&module_registry, "pdo", sizeof("pdo"))) { <nl>  		zend_error(E_ERROR, "You MUST load PDO before loading any PDO drivers"); <nl>  		return FAILURE;	/* NOTREACHED */ <nl>  	} <nl> @@ -196,7 +196,7 @@ PDO_API int php_pdo_register_driver(pdo_driver_t *driver) <nl>   <nl>  PDO_API void php_pdo_unregister_driver(pdo_driver_t *driver) <nl>  { <nl> -	if (!zend_hash_exists(&module_registry, "PDO", sizeof("PDO"))) { <nl> +	if (!zend_hash_exists(&module_registry, "pdo", sizeof("pdo"))) { <nl>  		return; <nl>  	} <nl>  
@@ -1713,6 +1713,7 @@ PHP_FUNCTION(fd_set) <nl>                  FD_SET(fd, &readfd); <nl>                  if(fd > max_fd) max_fd = fd; <nl>  		} <nl> +	efree(args); <nl>  	} <nl>  	RETURN_LONG(1); <nl>  }
@@ -869,6 +869,7 @@ PHP_FUNCTION(socket_read) <nl>  			php_sock->error = errno; <nl>  			SOCKETS_G(last_error) = errno; <nl>  		} else { <nl> +			efree(tmpbuf); <nl>  			PHP_SOCKET_ERROR(php_sock, "unable to read from socket", errno); <nl>  		} <nl>  
@@ -1245,6 +1245,9 @@ PHP_FUNCTION(gettype) <nl>  		WRONG_PARAM_COUNT; <nl>  	} <nl>  	switch (arg->type) { <nl> +		case IS_BOOL: <nl> +			RETVAL_STRING("boolean",1); <nl> +			break; <nl>  		case IS_LONG: <nl>  			RETVAL_STRING("integer",1); <nl>  			break;
@@ -1214,7 +1214,7 @@ PHP_FUNCTION(mysqli_options) <nl>  	long  			ret; <nl>  	PR_MYSQL		*prmysql; <nl>   <nl> -	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Oslz", &mysql_link, mysqli_link_class_entry, &mysql_option, &mysql_value) == FAILURE) { <nl> +	if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "Olz", &mysql_link, mysqli_link_class_entry, &mysql_option, &mysql_value) == FAILURE) { <nl>  		return; <nl>  	} <nl>  	MYSQLI_FETCH_RESOURCE(mysql, MYSQL *, prmysql, PR_MYSQL *, &mysql_link, "mysqli_link");
@@ -52,7 +52,9 @@ static size_t dummy_encoding_converter(unsigned char **to, size_t *to_length, co <nl>   <nl>  static int dummy_encoding_list_parser(const char *encoding_list, size_t encoding_list_len, const zend_encoding ***return_list, size_t *return_size, int persistent TSRMLS_DC) <nl>  { <nl> -	return FAILURE; <nl> +	*return_list = pemalloc(0, persistent); <nl> +	return_size = 0; <nl> +	return SUCCESS; <nl>  } <nl>   <nl>  static const zend_encoding *dummy_internal_encoding_getter(TSRMLS_D)
@@ -606,6 +606,7 @@ PHP_METHOD(Phar, webPhar) <nl>  	} <nl>   <nl>  	if ((strlen(sapi_module.name) == sizeof("cgi-fcgi")-1 && !strncmp(sapi_module.name, "cgi-fcgi", sizeof("cgi-fcgi")-1)) <nl> +		|| (strlen(sapi_module.name) == sizeof("fpm-fcgi")-1 && !strncmp(sapi_module.name, "fpm-fcgi", sizeof("fpm-fcgi")-1)) <nl>  		|| (strlen(sapi_module.name) == sizeof("cgi")-1 && !strncmp(sapi_module.name, "cgi", sizeof("cgi")-1))) { <nl>   <nl>  		if (PG(http_globals)[TRACK_VARS_SERVER]) {
@@ -35,7 +35,7 @@ int fpm_unix_resolve_socket_premissions(struct fpm_worker_pool_s *wp) /* {{{ */ <nl>  	/* uninitialized */ <nl>  	wp->socket_uid = -1; <nl>  	wp->socket_gid = -1; <nl> -	wp->socket_mode = 0666; <nl> +	wp->socket_mode = 0660; <nl>   <nl>  	if (!c) { <nl>  		return 0;
@@ -277,7 +277,10 @@ static void allocate_new_resource(tsrm_tls_entry **thread_resources_ptr, THREAD_ <nl>   <nl>  	TSRM_ERROR((TSRM_ERROR_LEVEL_CORE, "Creating data structures for thread %x", thread_id)); <nl>  	(*thread_resources_ptr) = (tsrm_tls_entry *) malloc(sizeof(tsrm_tls_entry)); <nl> -	(*thread_resources_ptr)->storage = (void **) malloc(sizeof(void *)*id_count); <nl> +	(*thread_resources_ptr)->storage = NULL; <nl> +	if (id_count > 0) { <nl> +		(*thread_resources_ptr)->storage = (void **) malloc(sizeof(void *)*id_count); <nl> +	} <nl>  	(*thread_resources_ptr)->count = id_count; <nl>  	(*thread_resources_ptr)->thread_id = thread_id; <nl>  	(*thread_resources_ptr)->next = NULL;
@@ -1758,6 +1758,12 @@ PHPAPI PHP_FUNCTION(fread) <nl>  		RETURN_FALSE; <nl>  	} <nl>   <nl> +	if (len > INT_MAX) { <nl> +		/* string length is int in 5.x so we can not read more than int */ <nl> +		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Length parameter must be no more than %d", INT_MAX); <nl> +		RETURN_FALSE; <nl> +	} <nl> + <nl>  	Z_STRVAL_P(return_value) = emalloc(len + 1); <nl>  	Z_STRLEN_P(return_value) = php_stream_read(stream, Z_STRVAL_P(return_value), len); <nl>  
@@ -1125,6 +1125,9 @@ ZEND_API zend_mm_heap *zend_mm_startup(void) <nl>  		if (zend_mm_low_bit(seg_size) != zend_mm_high_bit(seg_size)) { <nl>  			fprintf(stderr, "ZEND_MM_SEG_SIZE must be a power of two\n"); <nl>  			exit(255); <nl> +		} else if (seg_size < ZEND_MM_ALIGNED_SEGMENT_SIZE + ZEND_MM_ALIGNED_HEADER_SIZE) { <nl> +			fprintf(stderr, "ZEND_MM_SEG_SIZE is too small\n"); <nl> +			exit(255); <nl>  		} <nl>  	} else { <nl>  		seg_size = ZEND_MM_SEG_SIZE;
@@ -335,6 +335,8 @@ PHP_FUNCTION(stream_get_meta_data) <nl>  	 <nl>  	add_assoc_long(return_value, "unread_bytes", stream->writepos - stream->readpos); <nl>   <nl> +	add_assoc_bool(return_value, "seekable", (stream->ops->seek) && (stream->flags & PHP_STREAM_FLAG_NO_SEEK) == 0); <nl> + <nl>  	if (!php_stream_populate_meta_data(stream, return_value)) { <nl>  		add_assoc_bool(return_value, "timed_out", 0); <nl>  		add_assoc_bool(return_value, "blocked", 1);
@@ -1,5 +1,5 @@ <nl>  #include "config.w32.h" <nl> -#if (_WIN32_WINNT < 0x0600) /* Vita/2k8 have these functions */ <nl> +#if (_WIN32_WINNT < 0x0600) /* Vista/2k8 have these functions */ <nl>  #include "php.h" <nl>  #include <winsock2.h> <nl>  #include <windows.h> <nl> @@ -7,8 +7,7 @@ <nl>   <nl>  #include "inet.h" <nl>   <nl> -PHPAPI int <nl> -inet_pton(int af, const char* src, void* dst) <nl> +PHPAPI int inet_pton(int af, const char* src, void* dst) <nl>  { <nl>  	int address_length; <nl>  	struct sockaddr_storage sa;
@@ -160,6 +160,7 @@ static int php_zip_extract_file(struct zip * za, char *dest, char *file, int fil <nl>  	 * safemode status as its parent folder? <nl>  	 */ <nl>  	if (OPENBASEDIR_CHECKPATH(fullpath)) { <nl> +		efree(fullpath); <nl>  		efree(file_dirname_fullpath); <nl>  		efree(file_basename); <nl>  		return 0;
@@ -71,7 +71,7 @@ void *fs_get(size_t size); <nl>  int imap_mail(char *to, char *subject, char *message, char *headers, char *cc, char *bcc, char *rpath); <nl>   <nl>   <nl> -void mail_close_it(zend_rsrc_list_entry *rsrc); <nl> +void mail_close_it (zend_rsrc_list_entry *rsrc); <nl>  #ifdef OP_RELOGIN <nl>  /* AJS: close persistent connection */ <nl>  void mail_userlogout_it(zend_rsrc_list_entry *rsrc); <nl> @@ -184,6 +184,9 @@ void mail_close_it(zend_rsrc_list_entry *rsrc) <nl>  { <nl>  	pils *imap_le_struct = (pils *)rsrc->ptr; <nl>  	mail_close_full(imap_le_struct->imap_stream, imap_le_struct->flags); <nl> + <nl> +	efree(IMAPG(imap_user)); <nl> +	efree(IMAPG(imap_password)); <nl>  	efree(imap_le_struct); <nl>  } <nl>   <nl> @@ -766,8 +769,6 @@ void imap_do_open(INTERNAL_FUNCTION_PARAMETERS, int persistent) <nl>  	} else { <nl>  #endif <nl>  		imap_stream = mail_open(NIL, Z_STRVAL_PP(mailbox), flags); <nl> -		efree(IMAPG(imap_user)); <nl> -		efree(IMAPG(imap_password)); <nl>   <nl>  		if (imap_stream == NIL) { <nl>  			php_error(E_WARNING, "Couldn't open stream %s\n", (*mailbox)->value.str.val);
@@ -743,13 +743,8 @@ SAPI_API int sapi_header_op(sapi_header_op_enum op, void *arg TSRMLS_DC) <nl>  		/* new line/NUL character safety check */ <nl>  		int i; <nl>  		for (i = 0; i < header_line_len; i++) { <nl> -			/* RFC 2616 allows new lines if followed by SP or HT */ <nl> -			int illegal_break = <nl> -					(header_line[i+1] != ' ' && header_line[i+1] != '\t') <nl> -					&& ( <nl> -						header_line[i] == '\n' <nl> -						|| (header_line[i] == '\r' && header_line[i+1] != '\n')); <nl> -			if (illegal_break) { <nl> +			/* RFC 7230 ch. 3.2.4 deprecates folding support */ <nl> +			if (header_line[i] == '\n' || header_line[i] == '\r') { <nl>  				efree(header_line); <nl>  				sapi_module.sapi_error(E_WARNING, "Header may not contain " <nl>  						"more than a single header, new line detected");
@@ -120,7 +120,7 @@ int mbfl_filt_conv_html_enc(int c, mbfl_convert_filter *filter) <nl>  		} <nl>   <nl>  		{ <nl> -			int *p = tmp + sizeof(tmp); <nl> +			int *p = tmp + sizeof(tmp) / sizeof(tmp[0]); <nl>   <nl>  			CK((*filter->output_function)('#', filter->data)); <nl>  
@@ -817,7 +817,7 @@ int spl_dual_it_call_method(char *method, INTERNAL_FUNCTION_PARAMETERS) <nl>   <nl>  #define SPL_CHECK_CTOR(intern, classname) \ <nl>  	if (intern->dit_type == DIT_Unknown) { \ <nl> -		zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, "Classes derived from %v must call %v::__construct()", \ <nl> +		zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, "Classes derived from %v must call %s::__construct()", \ <nl>  				(spl_ce_##classname)->name, (spl_ce_##classname)->name); \ <nl>  		return; \ <nl>  	} <nl> @@ -836,7 +836,7 @@ static spl_dual_it_object* spl_dual_it_construct(INTERNAL_FUNCTION_PARAMETERS, z <nl>  	intern = (spl_dual_it_object*)zend_object_store_get_object(getThis() TSRMLS_CC); <nl>  	 <nl>  	if (intern->dit_type != DIT_Unknown) { <nl> -		zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, "%v::getIterator() must be called exactly once per instance", ce_base->name); <nl> +		zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, "%s::getIterator() must be called exactly once per instance", ce_base->name); <nl>  		return NULL; <nl>  	} <nl>  
@@ -451,6 +451,10 @@ void cgi_php_import_environment_variables(zval *array_ptr TSRMLS_DC) <nl>  	    zval_copy_ctor(array_ptr); <nl>  	    return; <nl>  	} <nl> + <nl> +	/* call php's original import as a catch-all */ <nl> +	php_php_import_environment_variables(array_ptr TSRMLS_CC); <nl> + <nl>  	if (fcgi_is_fastcgi()) { <nl>  		fcgi_request *request = (fcgi_request*) SG(server_context); <nl>  		HashPosition pos; <nl> @@ -466,8 +470,6 @@ void cgi_php_import_environment_variables(zval *array_ptr TSRMLS_DC) <nl>  			php_register_variable(var.s, *val, array_ptr TSRMLS_CC); <nl>  		} <nl>  	} <nl> -	/* call php's original import as a catch-all */ <nl> -	php_php_import_environment_variables(array_ptr TSRMLS_CC); <nl>  } <nl>   <nl>  static void sapi_cgi_register_variables(zval *track_vars_array TSRMLS_DC)
@@ -119,7 +119,7 @@ static void _php_curl_close(zend_rsrc_list_entry *rsrc TSRMLS_DC); <nl>  			RETURN_FALSE; 																		\ <nl>  		} 																						\ <nl>  																								\ <nl> -		if (tmp_url->query || php_check_open_basedir(tmp_url->path TSRMLS_CC) || 									\ <nl> +		if (tmp_url->query || tmp_url->fragment || php_check_open_basedir(tmp_url->path TSRMLS_CC) || 									\ <nl>  			(PG(safe_mode) && !php_checkuid(tmp_url->path, "rb+", CHECKUID_CHECK_MODE_PARAM))	\ <nl>  		) { 																					\ <nl>  			php_url_free(tmp_url); 																\
@@ -260,14 +260,14 @@ static int php_stream_memory_set_option(php_stream *stream, int option, int valu <nl>  					if (newsize <= ms->fsize) { <nl>  						if (newsize < ms->fpos) { <nl>  							ms->fpos = newsize; <nl> -						} else { <nl> -							ms->data = erealloc(ms->data, newsize); <nl> -							memset(ms->data+ms->fsize, 0, newsize - ms->fsize); <nl> -							ms->fsize = newsize; <nl>  						} <nl> +					} else { <nl> +						ms->data = erealloc(ms->data, newsize); <nl> +						memset(ms->data+ms->fsize, 0, newsize - ms->fsize); <nl>  						ms->fsize = newsize; <nl> -						return PHP_STREAM_OPTION_RETURN_OK; <nl>  					} <nl> +					ms->fsize = newsize; <nl> +					return PHP_STREAM_OPTION_RETURN_OK; <nl>  			} <nl>  		default: <nl>  			return PHP_STREAM_OPTION_RETURN_NOTIMPL;
@@ -952,7 +952,17 @@ SAPI_API SAPI_POST_HANDLER_FUNC(rfc1867_post_handler) <nl>  #else <nl>  					safe_php_register_variable(param, value, new_val_len, array_ptr, 0 TSRMLS_CC); <nl>  #endif <nl> +				} else if (php_rfc1867_callback != NULL) { <nl> +					multipart_event_formdata event_formdata; <nl> + <nl> +					event_formdata.post_bytes_processed = SG(read_post_bytes); <nl> +					event_formdata.name = param; <nl> +					event_formdata.value = &value; <nl> +					event_formdata.length = value_len; <nl> +					event_formdata.newlength = NULL; <nl> +					php_rfc1867_callback(MULTIPART_EVENT_FORMDATA, &event_formdata, &event_extra_data TSRMLS_CC); <nl>  				} <nl> + <nl>  				if (!strcasecmp(param, "MAX_FILE_SIZE")) { <nl>  					max_file_size = atol(value); <nl>  				}
@@ -174,12 +174,14 @@ flatpak_builtin_info (int argc, char **argv, GCancellable *cancellable, GError * <nl>    if (friendly) <nl>      { <nl>        g_autoptr(GVariant) commit_v = NULL; <nl> +      g_autoptr(GVariant) commit_metadata = NULL; <nl>        guint64 timestamp; <nl>        g_autofree char *formatted_timestamp = NULL; <nl>        const gchar *subject = NULL; <nl>        const gchar *body = NULL; <nl>        g_autofree char *parent = NULL; <nl>        const char *latest; <nl> +      const char *collection_id = NULL; <nl>   <nl>        latest = flatpak_dir_read_latest (dir, origin, ref, NULL, NULL, NULL); <nl>        if (latest == NULL) <nl> @@ -192,6 +194,12 @@ flatpak_builtin_info (int argc, char **argv, GCancellable *cancellable, GError * <nl>            parent = ostree_commit_get_parent (commit_v); <nl>            timestamp = ostree_commit_get_timestamp (commit_v); <nl>            formatted_timestamp = format_timestamp (timestamp); <nl> + <nl> +          commit_metadata = g_variant_get_child_value (commit_v, 0); <nl> + <nl> +#ifdef FLATPAK_ENABLE_P2P <nl> +          g_variant_lookup (commit_metadata, "ostree.collection-binding", "&s", &collection_id); <nl> +#endif <nl>          } <nl>   <nl>        g_print ("%s%s%s %s\n", on, _("Ref:"), off, ref); <nl> @@ -199,6 +207,8 @@ flatpak_builtin_info (int argc, char **argv, GCancellable *cancellable, GError * <nl>        g_print ("%s%s%s %s\n", on, _("Arch:"), off, parts[2]); <nl>        g_print ("%s%s%s %s\n", on, _("Branch:"), off, parts[3]); <nl>        g_print ("%s%s%s %s\n", on, _("Origin:"), off, origin ? origin : "-"); <nl> +      if (collection_id) <nl> +        g_print ("%s%s%s %s\n", on, _("Collection ID:"), off, collection_id); <nl>        if (formatted_timestamp) <nl>          g_print ("%s%s%s %s\n", on, _("Date:"), off, formatted_timestamp); <nl>        if (subject)
@@ -255,6 +255,7 @@ flatpak_installation_drop_caches (FlatpakInstallation *self, <nl>      { <nl>        priv->dir_unlocked = clone; <nl>        g_object_unref (old); <nl> +      res = TRUE; <nl>      } <nl>   <nl>    G_UNLOCK (dir);
@@ -2945,6 +2945,12 @@ setup_seccomp (FlatpakBwrap   *bwrap, <nl>   <nl>      /* Don't allow faking input to the controlling tty (CVE-2017-5226) */ <nl>      {SCMP_SYS (ioctl), EPERM, &SCMP_A1 (SCMP_CMP_MASKED_EQ, 0xFFFFFFFFu, (int) TIOCSTI)}, <nl> + <nl> +    /* seccomp can't look into clone3()'s struct clone_args to check whether <nl> +     * the flags are OK, so we have no choice but to block clone3(). <nl> +     * Return ENOSYS so user-space will fall back to clone(). <nl> +     * (GHSA-67h7-w3jq-vh4q; see also https://github.com/moby/moby/commit/9f6b562d) */ <nl> +    {SCMP_SYS (clone3), ENOSYS}, <nl>    }; <nl>   <nl>    struct
@@ -7139,6 +7139,8 @@ export_desktop_file (const char         *app, <nl>                  g_string_append_printf (new_exec, " @@ %s @@", arg); <nl>                else if (strcasecmp (arg, "%u") == 0) <nl>                  g_string_append_printf (new_exec, " @@u %s @@", arg); <nl> +              else if (strcmp (arg, "@@") == 0 || strcmp (arg, "@@u") == 0) <nl> +                g_print (_("Skipping invalid Exec argument %s\n"), arg); <nl>                else <nl>                  g_string_append_printf (new_exec, " %s", arg); <nl>              }
@@ -670,6 +670,9 @@ BOOL license_read_scope_list(wStream* s, SCOPE_LIST* scopeList) <nl>   <nl>  	Stream_Read_UINT32(s, scopeCount); /* ScopeCount (4 bytes) */ <nl>   <nl> +        if (Stream_GetRemainingLength(s) / sizeof(LICENSE_BLOB) < scopeCount) <nl> +                return FALSE;  /* Avoid overflow in malloc */ <nl> + <nl>  	scopeList->count = scopeCount; <nl>  	scopeList->array = (LICENSE_BLOB*) malloc(sizeof(LICENSE_BLOB) * scopeCount); <nl>  
@@ -430,6 +430,7 @@ char** crypto_cert_subject_alt_name(X509* xcert, int* count, int** lengths) <nl>  		*lengths = NULL ; <nl>  		return NULL; <nl>  	} <nl> +	GENERAL_NAMES_free(subject_alt_names); <nl>   <nl>  	return strings; <nl>  }
@@ -179,13 +179,16 @@ static void* printer_thread_func(void* arg) <nl>  { <nl>  	IRP* irp; <nl>  	PRINTER_DEVICE* printer_dev = (PRINTER_DEVICE*) arg; <nl> +	HANDLE obj[] = {printer_dev->event, printer_dev->stopEvent}; <nl>   <nl>  	while (1) <nl>  	{ <nl> -		WaitForSingleObject(printer_dev->event, INFINITE); <nl> +		DWORD rc = WaitForMultipleObjects(2, obj, FALSE, INFINITE); <nl>   <nl> -		if (WaitForSingleObject(printer_dev->stopEvent, 0) == WAIT_OBJECT_0) <nl> +		if (rc == WAIT_OBJECT_0 + 1) <nl>  			break; <nl> +		else if( rc != WAIT_OBJECT_0 ) <nl> +			continue; <nl>   <nl>  		ResetEvent(printer_dev->event); <nl>  
@@ -390,6 +390,10 @@ static void nbns_spoof(struct packet_object *po) <nl>   <nl>  	SAFE_CALLOC(response, NBNS_MSGLEN_QUERY_RESPONSE, sizeof(u_char)); <nl>   <nl> +   if (po->DATA.len > 70) { <nl> +       SAFE_FREE(response); <nl> +       return; <nl> +   } <nl>  	memset(response, 0, NBNS_MSGLEN_QUERY_RESPONSE); <nl>   <nl>  	memcpy(response, po->DATA.data, po->DATA.len);
@@ -48,7 +48,7 @@ IODeviceSocket::~IODeviceSocket() <nl>          proc->kill(); <nl>      } <nl>   <nl> -    delete d; <nl> +    d->deleteLater(); <nl>  } <nl>   <nl>  bool IODeviceSocket::canReadLine()
@@ -557,7 +557,7 @@ List::List(const Kind _kind, const QByteArray &line, int &start): <nl>   <nl>      ++start; <nl>   <nl> -    if (start >= line.size()) <nl> +    if (start >= line.size() - 2) <nl>          throw NoData(line, start);   // no mailbox <nl>   <nl>      mailbox = LowLevelParser::getMailbox(line, start);
@@ -196,6 +196,7 @@ bool SQLCache::childMailboxesFresh( const QString& mailbox ) const <nl>   <nl>  void SQLCache::setChildMailboxes( const QString& mailbox, const QList<MailboxMetadata>& data ) <nl>  { <nl> +    TransactionHelper txn(&db); <nl>      QString myMailbox = mailbox.isEmpty() ? QString::fromAscii("") : mailbox; <nl>      QVariantList mailboxFields, parentFields, separatorFields, flagsFelds; <nl>      Q_FOREACH( const MailboxMetadata& item, data ) { <nl> @@ -220,6 +221,7 @@ void SQLCache::setChildMailboxes( const QString& mailbox, const QList<MailboxMet <nl>          emitError( tr("Query querySetChildMailboxesFresh failed"), querySetChildMailboxesFresh ); <nl>          return; <nl>      } <nl> +    txn.commit(); <nl>  } <nl>   <nl>  void SQLCache::forgetChildMailboxes( const QString& mailbox )
@@ -233,9 +233,11 @@ int devnode_acl_all(struct udev *udev, <nl>          if (r < 0) <nl>                  goto finish; <nl>   <nl> -        r = udev_enumerate_add_match_tag(e, seat); <nl> -        if (r < 0) <nl> -                goto finish; <nl> +        if (!streq(seat, "seat0")) { <nl> +                r = udev_enumerate_add_match_tag(e, seat); <nl> +                if (r < 0) <nl> +                        goto finish; <nl> +        } <nl>   <nl>          r = udev_enumerate_scan_devices(e); <nl>          if (r < 0)
@@ -27,6 +27,7 @@ <nl>  #include <libaudit.h> <nl>  #include <stdbool.h> <nl>   <nl> +#include "capability-util.h" <nl>  #include "fd-util.h" <nl>  #include "log.h" <nl>  #include "util.h" <nl> @@ -37,6 +38,13 @@ static int audit_fd; <nl>  int get_audit_fd(void) { <nl>   <nl>          if (!initialized) { <nl> +                if (have_effective_cap(CAP_AUDIT_WRITE) == 0) { <nl> +                        audit_fd = -EPERM; <nl> +                        initialized = true; <nl> + <nl> +                        return audit_fd; <nl> +                } <nl> + <nl>                  audit_fd = audit_open(); <nl>   <nl>                  if (audit_fd < 0) {
@@ -1332,7 +1332,10 @@ int manager_startup(Manager *m, FILE *serialization, FDSet *fds) { <nl>          if (r < 0) <nl>                  return r; <nl>   <nl> -        if (m->first_boot && m->unit_file_scope == UNIT_FILE_SYSTEM) { <nl> +        if (m->first_boot > 0 && <nl> +            m->unit_file_scope == UNIT_FILE_SYSTEM && <nl> +            !m->test_run) { <nl> + <nl>                  q = unit_file_preset_all(UNIT_FILE_SYSTEM, 0, NULL, UNIT_FILE_PRESET_ENABLE_ONLY, NULL, 0); <nl>                  if (q < 0) <nl>                          log_full_errno(q == -EEXIST ? LOG_NOTICE : LOG_WARNING, q, "Failed to populate /etc with preset unit settings, ignoring: %m");
@@ -117,6 +117,8 @@ static int bus_message_setup_kmsg(sd_bus_message *m) { <nl>          if (!m->kdbus) <nl>                  return -ENOMEM; <nl>   <nl> +        memset(m->kdbus, 0, sz); <nl> + <nl>          m->kdbus->flags = <nl>                  ((m->header->flags & SD_BUS_MESSAGE_NO_REPLY_EXPECTED) ? 0 : KDBUS_MSG_FLAGS_EXPECT_REPLY) | <nl>                  ((m->header->flags & SD_BUS_MESSAGE_NO_AUTO_START) ? KDBUS_MSG_FLAGS_NO_AUTO_START : 0);
@@ -673,6 +673,10 @@ static int create_item(Item *i) { <nl>   <nl>          case CREATE_FILE: <nl>          case TRUNCATE_FILE: <nl> +                r = write_one_file(i, i->path); <nl> +                if (r < 0) <nl> +                        return r; <nl> +                break; <nl>          case WRITE_FILE: <nl>                  r = glob_item(i, write_one_file); <nl>                  if (r < 0)
@@ -1806,6 +1806,9 @@ void manager_send_unit_plymouth(Manager *m, Unit *u) { <nl>          if (m->running_as != SYSTEMD_SYSTEM) <nl>                  return; <nl>   <nl> +        if (detect_container(NULL) > 0) <nl> +                return; <nl> + <nl>          if (u->type != UNIT_SERVICE && <nl>              u->type != UNIT_MOUNT && <nl>              u->type != UNIT_SWAP)
@@ -808,8 +808,8 @@ static int mount_tmpfs(const char *dest) { <nl>                          return log_oom(); <nl>   <nl>                  r = mkdir_label(where, 0755); <nl> -                if (r < 0 && errno != EEXIST) <nl> -                        return log_error_errno(r, "creating mount point for tmpfs %s failed: %m", where); <nl> +                if (r < 0 && r != -EEXIST) <nl> +                        return log_error_errno(r, "Creating mount point for tmpfs %s failed: %m", where); <nl>   <nl>                  if (mount("tmpfs", where, "tmpfs", MS_NODEV|MS_STRICTATIME, *o) < 0) <nl>                          return log_error_errno(errno, "tmpfs mount to %s failed: %m", where);
@@ -667,6 +667,16 @@ int manager_read_resolv_conf(Manager *m) { <nl>                  if (s->marked) <nl>                          dns_server_free(s); <nl>   <nl> +        /* Whenever /etc/resolv.conf changes, start using the first <nl> +         * DNS server of it. This is useful to deal with broken <nl> +         * network managing implementations (like NetworkManager), <nl> +         * that when connecting to a VPN place both the VPN DNS <nl> +         * servers and the local ones in /etc/resolv.conf. Without <nl> +         * resetting the DNS server to use back to the first entry we <nl> +         * will continue to use the local one thus being unable to <nl> +         * resolve VPN domains. */ <nl> +        manager_set_dns_server(m, m->dns_servers); <nl> + <nl>          return 0; <nl>   <nl>  clear:
@@ -2988,7 +2988,7 @@ int columns(void) { <nl>                  struct winsize ws; <nl>                  zero(ws); <nl>   <nl> -                if (ioctl(STDIN_FILENO, TIOCGWINSZ, &ws) >= 0) <nl> +                if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &ws) >= 0) <nl>                          parsed_columns = ws.ws_col; <nl>          } <nl>  
@@ -175,7 +175,7 @@ static int stdout_stream_line(StdoutStream *s, char *p) { <nl>   <nl>          case STDOUT_STREAM_PRIORITY: <nl>                  r = safe_atoi(p, &s->priority); <nl> -                if (r < 0 || s->priority <= 0 || s->priority >= 999) { <nl> +                if (r < 0 || s->priority < 0 || s->priority >= 999) { <nl>                          log_warning("Failed to parse log priority line."); <nl>                          return -EINVAL; <nl>                  }
@@ -2525,7 +2525,7 @@ static void print_status_info( <nl>   <nl>                  printf("   CGroup: %s\n", i->control_group); <nl>   <nl> -                if (arg_transport == BUS_TRANSPORT_LOCAL) { <nl> +                if (arg_transport == BUS_TRANSPORT_LOCAL || arg_transport == BUS_TRANSPORT_CONTAINER) { <nl>                          unsigned k = 0; <nl>                          pid_t extra[2]; <nl>                          char prefix[] = "           ";
@@ -298,7 +298,15 @@ static void bus_method_resolve_address_complete(DnsQuery *q) { <nl>                  goto finish; <nl>          } <nl>   <nl> -        /* We don't process CNAME for PTR lookups. */ <nl> +        r = dns_query_process_cname(q); <nl> +        if (r == -ELOOP) { <nl> +                r = sd_bus_reply_method_errorf(q->request, BUS_ERROR_CNAME_LOOP, "CNAME loop detected, or CNAME resolving disabled on '%s'", dns_question_name(q->question)); <nl> +                goto finish; <nl> +        } <nl> +        if (r < 0) <nl> +                goto finish; <nl> +        if (r > 0) /* This was a cname, and the query was restarted. */ <nl> +                return; <nl>   <nl>          r = sd_bus_message_new_method_return(q->request, &reply); <nl>          if (r < 0)
@@ -2344,6 +2344,11 @@ int manager_reload(Manager *m) { <nl>          fclose(f); <nl>          f = NULL; <nl>   <nl> +        /* Re-register notify_fd as event source */ <nl> +        q = manager_setup_notify(m); <nl> +        if (q < 0) <nl> +                r = q; <nl> + <nl>          /* Third, fire things up! */ <nl>          q = manager_coldplug(m); <nl>          if (q < 0)
@@ -1180,6 +1180,7 @@ static int do_switch_root(const char *switch_root) { <nl>          int i; <nl>          int cfd = -1; <nl>          struct stat switch_root_stat, sb; <nl> +        bool remove_old_root; <nl>   <nl>          if (path_equal(switch_root, "/")) <nl>                  return 0; <nl> @@ -1190,6 +1191,8 @@ static int do_switch_root(const char *switch_root) { <nl>                  goto fail; <nl>          } <nl>   <nl> +        remove_old_root = in_initrd(); <nl> + <nl>          for (i = 0; umounts[i] != NULL; i++) { <nl>                  char newmount[PATH_MAX]; <nl>   <nl> @@ -1215,7 +1218,8 @@ static int do_switch_root(const char *switch_root) { <nl>                  goto fail; <nl>          } <nl>   <nl> -        cfd = open("/", O_RDONLY); <nl> +        if (remove_old_root) <nl> +                cfd = open("/", O_RDONLY); <nl>   <nl>          if (mount(switch_root, "/", NULL, MS_MOVE, NULL) < 0) { <nl>                  r = -errno;
@@ -839,7 +839,13 @@ static int service_load_pid_file(Service *s) { <nl>          if ((unsigned long) (pid_t) p != p) <nl>                  return -ERANGE; <nl>   <nl> -        s->main_pid = p; <nl> +        if (kill((pid_t) p, 0) < 0 && errno != EPERM) { <nl> +                log_warning("PID %llu read from file %s does not exist. Your service or init script might be broken.", <nl> +                            (unsigned long long) p, s->pid_file); <nl> +                return -ESRCH; <nl> +        } <nl> + <nl> +        s->main_pid = (pid_t) p; <nl>          s->main_pid_known = true; <nl>   <nl>          return 0;
@@ -1371,7 +1371,7 @@ bool ignore_file(const char *filename) { <nl>          assert(filename); <nl>   <nl>          if (endswith(filename, "~")) <nl> -                return false; <nl> +                return true; <nl>   <nl>          return ignore_file_allow_backup(filename); <nl>  }
@@ -198,7 +198,7 @@ struct udev *udev_new(void) <nl>  			} <nl>   <nl>  			if (strcasecmp(key, "udev_log") == 0) { <nl> -				udev->log_priority = util_log_priority(val); <nl> +				udev_set_log_priority(udev, util_log_priority(val)); <nl>  				continue; <nl>  			} <nl>  			if (strcasecmp(key, "udev_root") == 0) {
@@ -52,7 +52,7 @@ int udevdb_add_dev(const char *path, const struct udevice *dev) <nl>  	if ((path == NULL) || (dev == NULL)) <nl>  		return -ENODEV; <nl>   <nl> -	memset(keystr, 0, NAME_SIZE); <nl> +	memset(keystr, 0, SYSFS_PATH_MAX); <nl>  	strfieldcpy(keystr, path); <nl>  	key.dptr = keystr; <nl>  	key.dsize = strlen(keystr) + 1;
@@ -349,6 +349,10 @@ bool socket_address_equal(const SocketAddress *a, const SocketAddress *b) { <nl>                  break; <nl>   <nl>          case AF_UNIX: <nl> +                if (a->size <= offsetof(struct sockaddr_un, sun_path) || <nl> +                    b->size <= offsetof(struct sockaddr_un, sun_path)) <nl> +                        return false; <nl> + <nl>                  if ((a->sockaddr.un.sun_path[0] == 0) != (b->sockaddr.un.sun_path[0] == 0)) <nl>                          return false; <nl>  
@@ -241,9 +241,9 @@ int main(int argc, char *argv[]) { <nl>                                                  goto finish; <nl>                                  } <nl>   <nl> -                                r = cg_split_spec(*name, &c, &p); <nl> -                                if (r < 0) { <nl> -                                        log_error_errno(r, "Failed to split argument %s: %m", *name); <nl> +                                q = cg_split_spec(*name, &c, &p); <nl> +                                if (q < 0) { <nl> +                                        log_error_errno(q, "Failed to split argument %s: %m", *name); <nl>                                          goto failed; <nl>                                  } <nl>  
@@ -382,8 +382,8 @@ int link_config_apply(link_config_ctx *ctx, link_config *config, <nl>          if (ctx->enable_name_policy && config->name_policy) { <nl>                  NamePolicy *policy; <nl>   <nl> -                for (policy = config->name_policy; !respect_predictable && !new_name && <nl> -                                                   *policy != _NAMEPOLICY_INVALID; policy++) { <nl> +                for (policy = config->name_policy; <nl> +                     !new_name && *policy != _NAMEPOLICY_INVALID; policy++) { <nl>                          switch (*policy) { <nl>                                  case NAMEPOLICY_KERNEL: <nl>                                          respect_predictable = true;
@@ -402,8 +402,8 @@ static int unit_create_cgroups(Unit *u, CGroupControllerMask mask) { <nl>                  is_in_hash = true; <nl>   <nl>          if (r < 0) { <nl> -                free(path); <nl>                  log_error("cgroup %s exists already: %s", path, strerror(-r)); <nl> +                free(path); <nl>                  return r; <nl>          } <nl>  
@@ -254,6 +254,8 @@ subst: <nl>                                                  cpos++; <nl>                                          while (isspace(cpos[0])) <nl>                                                  cpos++; <nl> +                                        if (cpos[0] == '\0') <nl> +                                                break; <nl>                                  } <nl>                                  if (i > 0) { <nl>                                          log_error("requested part of result string not found");
@@ -737,7 +737,7 @@ static int import_program_into_properties(struct udev_device *dev, const char *p <nl>  { <nl>  	struct udev *udev = udev_device_get_udev(dev); <nl>  	char **envp; <nl> -	char result[2048]; <nl> +	char result[4096]; <nl>  	size_t reslen; <nl>  	char *line; <nl>  
@@ -201,6 +201,8 @@ static int detect_vm_xen(void) { <nl>          r = read_one_line_file("/proc/xen/capabilities", &domcap); <nl>          if (r == -ENOENT) <nl>                  return VIRTUALIZATION_NONE; <nl> +        if (r < 0) <nl> +                return r; <nl>   <nl>          i = domcap; <nl>          while ((cap = strsep(&i, ",")))
@@ -63,6 +63,7 @@ struct SocketPeer { <nl>   <nl>          Socket *socket; <nl>          union sockaddr_union peer; <nl> +        socklen_t peer_salen; <nl>  }; <nl>   <nl>  static const UnitActiveState state_translation_table[_SOCKET_STATE_MAX] = { <nl> @@ -488,8 +489,10 @@ static void peer_address_hash_func(const void *p, struct siphash *state) { <nl>   <nl>          if (s->peer.sa.sa_family == AF_INET) <nl>                  siphash24_compress(&s->peer.in.sin_addr, sizeof(s->peer.in.sin_addr), state); <nl> -        else <nl> +        else if (s->peer.sa.sa_family == AF_INET6) <nl>                  siphash24_compress(&s->peer.in6.sin6_addr, sizeof(s->peer.in6.sin6_addr), state); <nl> +        else <nl> +                assert_not_reached("Unknown address family."); <nl>  } <nl>   <nl>  static int peer_address_compare_func(const void *a, const void *b) { <nl> @@ -607,6 +610,7 @@ int socket_acquire_peer(Socket *s, int fd, SocketPeer **p) { <nl>                  return log_oom(); <nl>   <nl>          remote->peer = sa.peer; <nl> +        remote->peer_salen = salen; <nl>   <nl>          r = set_put(s->peers_by_address, remote); <nl>          if (r < 0) <nl> @@ -2189,7 +2193,7 @@ static void socket_enter_running(Socket *s, int cfd) { <nl>                          } else if (r > 0 && p->n_ref > s->max_connections_per_source) { <nl>                                  _cleanup_free_ char *t = NULL; <nl>   <nl> -                                sockaddr_pretty(&p->peer.sa, FAMILY_ADDRESS_SIZE(p->peer.sa.sa_family), true, false, &t); <nl> +                                (void) sockaddr_pretty(&p->peer.sa, p->peer_salen, true, false, &t); <nl>   <nl>                                  log_unit_warning(UNIT(s), <nl>                                                   "Too many incoming connections (%u) from source %s, dropping connection.",
@@ -236,6 +236,7 @@ CurlGlue *curl_glue_unref(CurlGlue *g) { <nl>   <nl>          sd_event_source_unref(g->timer); <nl>          sd_event_unref(g->event); <nl> +        free(g); <nl>   <nl>          return NULL; <nl>  }
@@ -56,7 +56,7 @@ void xor_buf(uint8_t out[], <nl>               const uint8_t in2[], <nl>               size_t length) <nl>     { <nl> -   while(length >= 8) <nl> +   while(length >= 16) <nl>        { <nl>        out[0] = in[0] ^ in2[0]; <nl>        out[1] = in[1] ^ in2[1];
@@ -86,7 +86,7 @@ void Channel::change_cipher_spec_reader(Connection_Side side) <nl>     side = (side == CLIENT) ? SERVER : CLIENT; <nl>   <nl>     m_read_cipherstate.reset( <nl> -      new Connection_Cipher_State(current_protocol_version(), <nl> +      new Connection_Cipher_State(m_pending_state->version(), <nl>                                    side, <nl>                                    m_pending_state->ciphersuite(), <nl>                                    m_pending_state->session_keys()) <nl> @@ -109,13 +109,13 @@ void Channel::change_cipher_spec_writer(Connection_Side side) <nl>   <nl>     For DTLS, increment the epoch <nl>     */ <nl> -   if(current_protocol_version().is_datagram_protocol()) <nl> +   if(m_pending_state->version().is_datagram_protocol()) <nl>        m_write_seq_no = ((m_write_seq_no >> 48) + 1) << 48; <nl>     else <nl>        m_write_seq_no = 0; <nl>   <nl>     m_write_cipherstate.reset( <nl> -      new Connection_Cipher_State(current_protocol_version(), <nl> +      new Connection_Cipher_State(m_pending_state->version(), <nl>                                    side, <nl>                                    m_pending_state->ciphersuite(), <nl>                                    m_pending_state->session_keys())
@@ -232,6 +232,11 @@ dns_lookup(char *domain, char *type_name) <nl>      return NULL; <nl>  } <nl>   <nl> +void <nl> +dns_free_data(struct dns_reply *r) <nl> +{ <nl> +} <nl> + <nl>  #endif <nl>   <nl>  #ifdef TEST
@@ -251,6 +251,8 @@ krb5_free_context(krb5_context context) <nl>  { <nl>      if (context->default_cc_name) <nl>  	free(context->default_cc_name); <nl> +    if (context->default_cc_name_env) <nl> +	free(context->default_cc_name_env); <nl>      free(context->etypes); <nl>      free(context->etypes_des); <nl>      krb5_free_host_realm (context, context->default_realms);
@@ -29,7 +29,7 @@ char * <nl>  hstrerror(int herr) <nl>  { <nl>    if (0 <= herr && herr < h_nerr) <nl> -    return h_errlist[herr]; <nl> +    return (char *) h_errlist[herr]; <nl>    else <nl>      return "Error number out of range (hstrerror)"; <nl>  }
@@ -522,7 +522,7 @@ KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL <nl>  krb5_ret_int16(krb5_storage *sp, <nl>  	       int16_t *value) <nl>  { <nl> -    int32_t v; <nl> +    int32_t v = 0; <nl>      int ret; <nl>      ret = krb5_ret_int(sp, &v, 2); <nl>      if(ret)
@@ -375,6 +375,9 @@ pid_file_delete (char **); <nl>  int ROKEN_LIB_FUNCTION <nl>  read_environment(const char *file, char ***env); <nl>   <nl> +void ROKEN_LIB_FUNCTION <nl> +free_environment(char **, int); <nl> + <nl>  void ROKEN_LIB_FUNCTION <nl>  warnerr(int doerrno, const char *fmt, va_list ap) <nl>      __attribute__ ((format (printf, 2, 0)));
@@ -68,7 +68,8 @@ afs_verify(char *name, <nl>  	      "%s%d_%d", TKT_ROOT, <nl>  	      (unsigned)pwd->pw_uid, (unsigned)getpid()); <nl>      krb_set_tkt_string (tkt_string); <nl> -    ret = krb_verify_user (name, "", lrealm, password, 1, NULL); <nl> +    ret = krb_verify_user (name, "", lrealm, password, <nl> +			   KRB_VERIFY_SECURE, NULL); <nl>      if (ret == KSUCCESS) { <nl>        if (k_hasafs()) { <nl>  	k_setpag ();
@@ -44,6 +44,7 @@ krb5_auth_con_free(krb5_context context, <nl>  	free(auth_context->remote_address); <nl>      } <nl>      free_EncryptionKey(&auth_context->key); <nl> +    free_EncryptionKey(&auth_context->remote_subkey); <nl>      free (auth_context); <nl>      return 0; <nl>  }
@@ -100,7 +100,10 @@ _gss_acquire_mech_cred(OM_uint32 *minor_status, <nl>  	mc= NULL; <nl>      } <nl>   <nl> -    *output_cred_handle = mc; <nl> +    if (major_status != GSS_S_COMPLETE) <nl> +        free(mc); <nl> +    else <nl> +        *output_cred_handle = mc; <nl>      return major_status; <nl>  } <nl>  
@@ -54,6 +54,10 @@ recv_loop (int fd, <nl>       int ret; <nl>       int nbytes; <nl>   <nl> +     if (fd >= FD_SETSIZE) { <nl> +	 return -1; <nl> +     } <nl> + <nl>       krb5_data_zero(rep); <nl>       do { <nl>  	 FD_ZERO(&fdset);
@@ -423,6 +423,10 @@ cms_create_sd(struct cms_create_sd_options *opt, int argc, char **argv) <nl>  	if (ret) <nl>  	    hx509_err(context, 1, ret, "hx509_certs_find"); <nl>      } <nl> +    if (!opt->embedded_certs_flag) <nl> +	flags |= HX509_CMS_SIGNATURE_NO_CERTS; <nl> +    if (opt->embed_leaf_only_flag) <nl> +	flags |= HX509_CMS_SIGNATURE_LEAF_ONLY; <nl>   <nl>      ret = rk_undumpdata(infile, &p, &sz); <nl>      if (ret)
@@ -42,6 +42,7 @@ krb5_free_ticket(krb5_context context, <nl>      free_EncTicketPart(&ticket->ticket); <nl>      krb5_free_principal(context, ticket->client); <nl>      krb5_free_principal(context, ticket->server); <nl> +    free(ticket); <nl>      return 0; <nl>  } <nl>  
@@ -63,7 +63,7 @@ extern int	require_SecurID; <nl>  #if	defined(AUTHENTICATION) <nl>  extern int	auth_level; <nl>  #endif <nl> - <nl> +extern char *new_login; <nl>   <nl>  extern slcfun	slctab[NSLC + 1];	/* slc mapping table */ <nl>  
@@ -82,6 +82,11 @@ del_enctype(void *opt, int argc, char **argv) <nl>  	goto out2; <nl>      } <nl>   <nl> +    if (kadm5_all_keys_are_bogus(princ.n_key_data, princ.key_data)) { <nl> +	krb5_warnx(context, "user lacks get-keys privilege"); <nl> +	goto out; <nl> +    } <nl> + <nl>      new_key_data   = malloc(princ.n_key_data * sizeof(*new_key_data)); <nl>      if (new_key_data == NULL && princ.n_key_data != 0) { <nl>  	krb5_warnx (context, "out of memory");
@@ -1,5 +1,5 @@ <nl>  /* <nl> - * Copyright (c) 1997, 1998 Kungliga Tekniska Hgskolan <nl> + * Copyright (c) 1997 - 2000 Kungliga Tekniska Hgskolan <nl>   * (Royal Institute of Technology, Stockholm, Sweden).  <nl>   * All rights reserved.  <nl>   * <nl> @@ -63,6 +63,6 @@ void com_err __P((const char *, long, const char *, ...)); <nl>  errf set_com_err_hook __P((errf)); <nl>  errf reset_com_err_hook __P((void)); <nl>   <nl> -const char *error_table_name(int num); <nl> +const char *error_table_name  __P((int num)); <nl>   <nl>  #endif /* __COM_ERR_H__ */
@@ -38,7 +38,7 @@ void winpr_HexDump(const char* tag, int level, const BYTE* data, int length) <nl>  	const BYTE* p = data; <nl>  	int i, line, offset = 0; <nl>  	const size_t llen = (length > WINPR_HEXDUMP_LINE_LENGTH) ? WINPR_HEXDUMP_LINE_LENGTH : length; <nl> -	size_t blen = 5 + llen * 5; <nl> +	size_t blen = 7 + WINPR_HEXDUMP_LINE_LENGTH * 5; <nl>  	size_t pos = 0; <nl>  	char* buffer = malloc(blen); <nl>  
@@ -360,6 +360,9 @@ BOOL tls_accept(rdpTls* tls, const char* cert_file, const char* privatekey_file) <nl>   <nl>  BOOL tls_disconnect(rdpTls* tls) <nl>  { <nl> +	if (!tls) <nl> +		return FALSE; <nl> + <nl>  	if (tls->ssl) <nl>  		SSL_shutdown(tls->ssl); <nl>  
@@ -290,6 +290,8 @@ HANDLE CreateNamedPipeA(LPCSTR lpName, DWORD dwOpenMode, DWORD dwPipeMode, DWORD <nl>   <nl>  	WINPR_HANDLE_SET_TYPE(pNamedPipe, HANDLE_TYPE_NAMED_PIPE); <nl>   <nl> +	pNamedPipe->serverfd = -1; <nl> +	pNamedPipe->clientfd = -1; <nl>  	if (!(pNamedPipe->name = _strdup(lpName))) <nl>  		goto out; <nl>  
@@ -124,6 +124,9 @@ void ntlm_print_version_info(NTLM_VERSION_INFO* versionInfo) <nl>  static int ntlm_read_ntlm_v2_client_challenge(wStream* s, NTLMv2_CLIENT_CHALLENGE* challenge) <nl>  { <nl>  	size_t size; <nl> +	if (Stream_GetRemainingLength(s) < 28) <nl> +		return -1; <nl> + <nl>  	Stream_Read_UINT8(s, challenge->RespType); <nl>  	Stream_Read_UINT8(s, challenge->HiRespType); <nl>  	Stream_Read_UINT16(s, challenge->Reserved1); <nl> @@ -163,6 +166,8 @@ static int ntlm_write_ntlm_v2_client_challenge(wStream* s, NTLMv2_CLIENT_CHALLEN <nl>   <nl>  int ntlm_read_ntlm_v2_response(wStream* s, NTLMv2_RESPONSE* response) <nl>  { <nl> +	if (Stream_GetRemainingLength(s) < 16) <nl> +		return -1; <nl>  	Stream_Read(s, response->Response, 16); <nl>  	return ntlm_read_ntlm_v2_client_challenge(s, &(response->Challenge)); <nl>  }
@@ -80,12 +80,12 @@ static gboolean tsmf_gstreamer_seek_data(GstAppSrc *src, guint64 offset, gpointe <nl>  	DEBUG_TSMF("%s offset=%llu", get_type(mdecoder), offset); <nl>   <nl>  	if (!mdecoder->paused) <nl> -		gst_element_set_state(mdecoder->pipe, GST_STATE_PAUSED); <nl> +		tsmf_gstreamer_pipeline_set_state(mdecoder, GST_STATE_PAUSED); <nl>   <nl>  	gst_app_src_end_of_stream((GstAppSrc *)mdecoder->src); <nl>   <nl>  	if (!mdecoder->paused) <nl> -		gst_element_set_state(mdecoder->pipe, GST_STATE_PLAYING); <nl> +		tsmf_gstreamer_pipeline_set_state(mdecoder, GST_STATE_PLAYING); <nl>   <nl>  	if (mdecoder->sync_cb) <nl>  		mdecoder->sync_cb(mdecoder->stream); <nl> @@ -419,7 +419,7 @@ void tsmf_gstreamer_clean_up(TSMFGstreamerDecoder *mdecoder) <nl>   <nl>  	if (mdecoder->pipe && GST_OBJECT_REFCOUNT_VALUE(mdecoder->pipe) > 0) <nl>  	{ <nl> -		gst_element_set_state(mdecoder->pipe, GST_STATE_NULL); <nl> +		tsmf_gstreamer_pipeline_set_state(mdecoder, GST_STATE_NULL); <nl>  		gst_object_unref(mdecoder->pipe); <nl>  	} <nl>   <nl> @@ -770,7 +770,7 @@ static BOOL tsmf_gstreamer_decodeEx(ITSMFDecoder *decoder, const BYTE *data, UIN <nl>   <nl>  	if (GST_STATE(mdecoder->pipe) != GST_STATE_PLAYING) <nl>  	{ <nl> -		DEBUG_TSMF("state=%s", gst_element_state_get_name(GST_STATE(mdecoder->pipe))); <nl> +		DEBUG_TSMF("%s: state=%s", get_type(mdecoder), gst_element_state_get_name(GST_STATE(mdecoder->pipe))); <nl>   <nl>  		if (!mdecoder->paused && !mdecoder->shutdown && mdecoder->ready) <nl>  			tsmf_gstreamer_pipeline_set_state(mdecoder, GST_STATE_PLAYING);
@@ -271,8 +271,8 @@ NSC_CONTEXT* nsc_context_new(void) <nl>  	NSC_CONTEXT* nsc_context; <nl>  	UINT8 i; <nl>   <nl> -	nsc_context = (NSC_CONTEXT*) malloc(sizeof(NSC_CONTEXT)); <nl> -	nsc_context->priv = (NSC_CONTEXT_PRIV*) malloc(sizeof(NSC_CONTEXT_PRIV)); <nl> +	nsc_context = (NSC_CONTEXT*) calloc(1, sizeof(NSC_CONTEXT)); <nl> +	nsc_context->priv = (NSC_CONTEXT_PRIV*) calloc(1, sizeof(NSC_CONTEXT_PRIV)); <nl>  	for (i=0; i < 5; ++i) <nl>  	{ <nl>  		nsc_context->priv->plane_buf[i] = NULL;
@@ -657,6 +657,15 @@ int transport_write(rdpTransport* transport, wStream* s) <nl>  	int status = -1; <nl>  	int writtenlength = 0; <nl>   <nl> +	if (!transport) <nl> +		return -1; <nl> + <nl> +	if (!transport->frontBio) <nl> +	{ <nl> +		transport->layer = TRANSPORT_LAYER_CLOSED; <nl> +		return -1; <nl> +	} <nl> + <nl>  	EnterCriticalSection(&(transport->WriteLock)); <nl>   <nl>  	length = Stream_GetPosition(s);
@@ -207,9 +207,13 @@ int main(int argc, char** argv) { <nl>   <nl>  	{ <nl>  		set<CModInfo> ssGlobalMods; <nl> +		set<CModInfo> ssUserMods; <nl> +		set<CModInfo> ssNetworkMods; <nl>  		CUtils::PrintAction("Checking for list of available modules"); <nl>  		pZNC->GetModules().GetAvailableMods(ssGlobalMods, CModInfo::GlobalModule); <nl> -		if (ssGlobalMods.empty()) { <nl> +		pZNC->GetModules().GetAvailableMods(ssUserMods, CModInfo::UserModule); <nl> +		pZNC->GetModules().GetAvailableMods(ssNetworkMods, CModInfo::NetworkModule); <nl> +		if (ssGlobalMods.empty() && ssUserMods.empty() && ssNetworkMods.empty()) { <nl>  			CUtils::PrintStatus(false, ""); <nl>  			CUtils::PrintError("No modules found. Perhaps you didn't install ZNC properly?"); <nl>  			CUtils::PrintError("Read http://wiki.znc.in/Installation for instructions.");
@@ -173,6 +173,12 @@ public: <nl>  		return CONTINUE; <nl>  	} <nl>   <nl> +	void OnNick(const CNick& Nick, const CString& sNewNick, const std::vector<CChan*>& vChans) override { <nl> +		for (CChan* pChan : vChans) { <nl> +			Message(*pChan); <nl> +		} <nl> +	} <nl> + <nl>  	void ShowCommand(const CString& sLine) { <nl>  		PutModule("Current limit is " + CString(m_iThresholdMsgs) + " lines " <nl>  				"in " + CString(m_iThresholdSecs) + " secs.");
@@ -276,7 +276,7 @@ static int dynamicGetbuf(gdIOCtxPtr ctx, void *buf, int len) <nl>  	if(remain >= len) { <nl>  		rlen = len; <nl>  	} else { <nl> -		if(remain == 0) { <nl> +		if(remain <= 0) { <nl>  			/* 2.0.34: EOF is incorrect. We use 0 for <nl>  			 * errors and EOF, just like fileGetbuf, <nl>  			 * which is a simple fread() wrapper.
@@ -47,6 +47,9 @@ BGD_DECLARE(gdImagePtr) gdImageCreateFromXpm (char *filename) <nl>      return 0; <nl>   <nl>    number = image.ncolors; <nl> +	if (overflow2(sizeof (int), number)) { <nl> +		return 0; <nl> +	} <nl>    colors = (int *) gdMalloc (sizeof (int) * number); <nl>    if (colors == NULL) <nl>      return (0);
@@ -1063,6 +1063,7 @@ namespace mongo { <nl>          // Because the planner doesn't yet set up 2D index bounds, do it ourselves here <nl>          const string s2Field = _nearParams->nearQuery->field; <nl>          const int s2FieldPosition = getFieldPosition(_s2Index, s2Field); <nl> +        fassert(28677, s2FieldPosition >= 0); <nl>          OrderedIntervalList* coveredIntervals = &scanParams.bounds.fields[s2FieldPosition]; <nl>          coveredIntervals->intervals.clear(); <nl>   <nl> @@ -1266,6 +1267,7 @@ namespace mongo { <nl>          // Because the planner doesn't yet set up 2D index bounds, do it ourselves here <nl>          const string s2Field = _nearParams.nearQuery->field; <nl>          const int s2FieldPosition = getFieldPosition(_s2Index, s2Field); <nl> +        fassert(28678, s2FieldPosition >= 0); <nl>          scanParams.bounds.fields[s2FieldPosition].intervals.clear(); <nl>          OrderedIntervalList* coveredIntervals = &scanParams.bounds.fields[s2FieldPosition]; <nl>  
@@ -70,7 +70,10 @@ namespace mongo { <nl>          if( boost::filesystem::exists(nsPath) ) {  <nl>  			p = f.map(pathString.c_str()); <nl>  			len = f.length(); <nl> -			uassert( "bad .ns file length, cannot open database", len % (1024*1024) == 0 ); <nl> +            if ( len % (1024*1024) != 0 ){ <nl> +                log() << "bad .ns file: " << pathString << endl; <nl> +                uassert( "bad .ns file length, cannot open database", len % (1024*1024) == 0 ); <nl> +            } <nl>  		} <nl>  		else { <nl>  			// use lenForNewNsFiles, we are making a new database
@@ -1677,6 +1677,11 @@ void ReplicationCoordinatorImpl::_setMaintenanceMode_helper( <nl>          return; <nl>      } <nl>   <nl> +    if (_topCoord->getRole() == TopologyCoordinator::Role::candidate) { <nl> +        *result = Status(ErrorCodes::NotMaster, "currently running for election"); <nl> +        return; <nl> +    } <nl> + <nl>      stdx::unique_lock<stdx::mutex> lk(_mutex); <nl>      if (_getMemberState_inlock().primary()) { <nl>          *result = Status(ErrorCodes::NotSecondary, "primaries can't modify maintenance mode");
@@ -192,10 +192,11 @@ namespace mongo { <nl>                  Local< v8::Function > f = v8::Function::Cast( *(scope->mongoToV8Element(args.firstElement(), true)) ); <nl>                  int argc = args.nFields() - 1; <nl>   <nl> -                Local<Value> argv[argc]; <nl> +                // TODO SERVER-8016: properly allocate handles on the stack <nl> +                Local<Value> argv[24]; <nl>                  BSONObjIterator it(args); <nl>                  it.next(); <nl> -                for(int i = 0; i < argc; ++i) { <nl> +                for(int i = 0; i < argc && i < 24; ++i) { <nl>                      argv[i] = Local< Value >::New(scope->mongoToV8Element(*it, true)); <nl>                      it.next(); <nl>                  }
@@ -261,7 +261,7 @@ namespace mongo { <nl>              } <nl>          } <nl>   <nl> -        if( _master >= 0 ) {  <nl> +        if( _master >= 0 && _nodes[_master].ok ) { <nl>              assert( static_cast<unsigned>(_master) < _nodes.size() ); <nl>              LOG(2) << "dbclient_rs getSlave no member in secondary state found, returning primary " << _nodes[ _master ] << endl; <nl>              return _nodes[_master].addr;
@@ -121,7 +121,9 @@ namespace boost { <nl>          } obj_ref; <nl>   <nl>          // To relax aliasing constraints <nl> -        mutable char data; <nl> +        mutable char data[sizeof(bound_memfunc_ptr_t)]; <nl> +        static_assert(sizeof(bound_memfunc_ptr_t) >= sizeof(obj_ref_t), <nl> +                      "sizeof(bound_memfunc_ptr_t) >= sizeof(obj_ref_t)"); <nl>        }; <nl>   <nl>        /**
@@ -1895,6 +1895,8 @@ namespace mongo { <nl>   <nl>          BackgroundOperation::assertNoBgOpInProgForDb(dbName); <nl>   <nl> +        dur::TempDisableDurability holder; // SyncAndTruncate before computing freeSpace <nl> + <nl>          boost::intmax_t totalSize = dbSize( dbName ); <nl>          boost::intmax_t freeSize = freeSpace( repairpath ); <nl>          if ( freeSize > -1 && freeSize < totalSize ) { <nl> @@ -1930,6 +1932,8 @@ namespace mongo { <nl>              return false; <nl>          } <nl>   <nl> +        MongoFile::flushAll(true); <nl> + <nl>          Client::Context ctx( dbName ); <nl>          Database::closeDatabase( dbName, dbpath ); <nl>  
@@ -300,6 +300,11 @@ namespace mongo { <nl>              lenToAlloc = std::min( r->lengthWithHeaders(), <nl>                                     NamespaceDetails::quantizeAllocationSpace( lenToAlloc ) ); <nl>              left = regionlen - lenToAlloc; <nl> + <nl> +            if ( left < 24 ) { <nl> +                // you get the whole thing. <nl> +                return loc; <nl> +            } <nl>          } <nl>   <nl>          /* split off some for further use. */
@@ -115,6 +115,9 @@ namespace mongo { <nl>      void DBConfig::enableSharding() { <nl>          if ( _shardingEnabled ) <nl>              return; <nl> +         <nl> +        assert( _name != "config" ); <nl> + <nl>          scoped_lock lk( _lock ); <nl>          _shardingEnabled = true; <nl>          _save();
@@ -247,6 +247,10 @@ Status CollectionOptions::parse(const BSONObj& options) { <nl>              pipeline = e.Obj().getOwned(); <nl>          } else if (fieldName == "writeConcern") { <nl>              continue; <nl> +        } else if (fieldName == "maxTimeMS") { <nl> +            // TODO SERVER-26457: Remove in 3.6. This is needed in 3.4 because a 3.2 mongos can <nl> +            // attach maxTimeMS to a create command on the config servers. <nl> +            continue; <nl>          } else { <nl>              return Status(ErrorCodes::InvalidOptions, <nl>                            str::stream() << "The field '" << fieldName
@@ -438,7 +438,7 @@ namespace mongo { <nl>      DBClientConnection * DBClientReplicaSet::checkMaster() { <nl>          HostAndPort h = _monitor->getMaster(); <nl>   <nl> -        if ( h == _masterHost ) { <nl> +        if ( h == _masterHost && _master ) { <nl>              // a master is selected.  let's just make sure connection didn't die <nl>              if ( ! _master->isFailed() ) <nl>                  return _master.get(); <nl> @@ -459,7 +459,7 @@ namespace mongo { <nl>      DBClientConnection * DBClientReplicaSet::checkSlave() { <nl>          HostAndPort h = _monitor->getSlave( _slaveHost ); <nl>   <nl> -        if ( h == _slaveHost ) { <nl> +        if ( h == _slaveHost && _slave ) { <nl>              if ( ! _slave->isFailed() ) <nl>                  return _slave.get(); <nl>              _monitor->notifySlaveFailure( _slaveHost );
@@ -208,7 +208,7 @@ RuntimeDyldImpl::loadObjectImpl(const object::ObjectFile &Obj) { <nl>          { <nl>            GlobalSymbolTable[Name] = SymbolInfo(SectionID, SectOffset, Vis); <nl>          } else { <nl> -          if (object::SymbolRef::ST_Data) { <nl> +          if (SymType == object::SymbolRef::ST_Data) { <nl>              WeakDataSymbolTable[Name] = SymbolInfo(SectionID, SectOffset, Vis); <nl>            } else { <nl>              WeakFuncSymbolTable[Name] = SymbolInfo(SectionID, SectOffset, Vis);
@@ -149,7 +149,8 @@ namespace cling { <nl>    Interpreter::Interpreter(int argc, const char* const *argv, <nl>                             const char* llvmdir /*= 0*/) : <nl>      m_UniqueCounter(0), m_PrintDebug(false), <nl> -    m_DynamicLookupEnabled(false), m_RawInputEnabled(false) { <nl> +    m_DynamicLookupEnabled(false), m_RawInputEnabled(false), <nl> +    m_LastCustomPragmaDiagPopPoint(){ <nl>   <nl>      m_LLVMContext.reset(new llvm::LLVMContext); <nl>      std::vector<unsigned> LeftoverArgsIdx;
@@ -430,11 +430,7 @@ public: <nl>     ROOT::NewFunc_t    GetNew() const; <nl>     ROOT::NewArrFunc_t GetNewArray() const; <nl>     Int_t              GetNmethods(); <nl> -#ifdef __CINT__ <nl> -   TClass           **GetPersistentRef() const { return fPersistentRef; } <nl> -#else <nl>     TClass      *const*GetPersistentRef() const { return fPersistentRef; } <nl> -#endif <nl>     TRealData         *GetRealData(const char *name) const; <nl>     TVirtualRefProxy  *GetReferenceProxy()  const   {  return fRefProxy; } <nl>     const ROOT::Detail::TSchemaRuleSet *GetSchemaRules() const;
@@ -44,7 +44,7 @@ namespace cling { <nl>        return; <nl>   <nl>      Token Tok = lookAhead(1); <nl> -    while (Tok.isNot(stopAt) && Tok.isNot(tok::eof) && Tok.isNot(tok::comment)){ <nl> +    while (Tok.isNot(stopAt) && Tok.isNot(tok::eof)){ <nl>        //MergedTok.setLength(MergedTok.getLength() + Tok.getLength()); <nl>        m_TokenCache.erase(m_TokenCache.begin() + 1); <nl>        Tok = lookAhead(1); <nl> @@ -82,7 +82,7 @@ namespace cling { <nl>   <nl>    bool MetaParser::isCommand() { <nl>      consumeToken(); <nl> -    return isLCommand() || isxCommand() || isXCommand() || isqCommand()  <nl> +    return isLCommand() || isxCommand() /*|| isXCommand() */|| isqCommand()  <nl>        || isUCommand() || isICommand() || israwInputCommand()  <nl>        || isprintASTCommand() || isdynamicExtensionsCommand() || ishelpCommand() <nl>        || isfileExCommand() || isfilesCommand(); <nl> @@ -115,7 +115,8 @@ namespace cling { <nl>    // ExtraArgList := AnyString [, ExtraArgList] <nl>    bool MetaParser::isxCommand() { <nl>      bool result = false; <nl> -    if (getCurTok().is(tok::ident) && getCurTok().getIdent().equals("x")) { <nl> +    if (getCurTok().is(tok::ident) && (getCurTok().getIdent().equals("x") <nl> +                                       || getCurTok().getIdent().equals("X"))) { <nl>        // There might be ArgList <nl>        consumeAnyStringToken(tok::l_paren); <nl>        llvm::sys::Path file(getCurTok().getIdent());
@@ -348,7 +348,9 @@ XrdSysMutex XrdOucAppleBonjour::SingletonMutex; <nl>   <nl>  XrdOucAppleBonjour::XrdOucAppleBonjour() <nl>  { <nl> -   putenv("AVAHI_COMPAT_NOWARN=1"); <nl> +   char *env = new char[22]; <nl> +   strcpy(env, "AVAHI_COMPAT_NOWARN=1"); <nl> +   putenv(env); <nl>  } <nl>   <nl>  XrdOucAppleBonjour::~XrdOucAppleBonjour() { }
@@ -814,6 +814,7 @@ namespace cling { <nl>          m_Consumer->HandleTopLevelDecl(ADecl.get()); <nl>      }; <nl>   <nl> +#ifdef LLVM_ON_WIN32 <nl>      // Microsoft-specific: <nl>      // Late parsed templates can leave unswallowed "macro"-like tokens. <nl>      // They will seriously confuse the Parser when entering the next <nl> @@ -822,6 +823,13 @@ namespace cling { <nl>      do { <nl>        PP.Lex(Tok); <nl>      } while (Tok.isNot(tok::eof)); <nl> +#endif <nl> + <nl> +#ifndef NDEBUG <nl> +    Token AssertTok; <nl> +    PP.Lex(AssertTok); <nl> +    assert(AssertTok.is(tok::eof) && "Lexer must be EOF when starting incremental parse!"); <nl> +#endif <nl>   <nl>      if (IgnorePromptDiags) { <nl>        SourceLocation Loc = SM.getLocForEndOfFile(m_MemoryBuffers.back().second);
@@ -102,6 +102,11 @@ public: <nl>     void     SetParam(Long64_t ll); <nl>     void     SetParam(ULong64_t ull); <nl>   <nl> +   template <typename... T> void SetParams(const T&... params) { <nl> +      if (!fFunc) return; <nl> +      gInterpreter->CallFunc_SetArguments(fFunc,params...); <nl> +   } <nl> + <nl>     void     Execute(void *object); <nl>     void     Execute(void *object, const char *params); <nl>     void     Execute(void *object, Long_t &retLong);
@@ -591,7 +591,7 @@ static void setup_window(AVFormatContext *s) <nl>      uint32_t values[] = { 1, <nl>                            XCB_EVENT_MASK_EXPOSURE | <nl>                            XCB_EVENT_MASK_STRUCTURE_NOTIFY }; <nl> -    xcb_rectangle_t rect = { 0, 0, c->width, c->height }; <nl> +    av_unused xcb_rectangle_t rect = { 0, 0, c->width, c->height }; <nl>   <nl>      c->window = xcb_generate_id(c->conn); <nl>  
@@ -305,8 +305,12 @@ static av_always_inline void predict(PredictorState *ps, int *coef, <nl>      if (output_enable) { <nl>          int shift = 28 - pv.exp; <nl>   <nl> -        if (shift < 31) <nl> -            *coef += (pv.mant + (1 << (shift - 1))) >> shift; <nl> +        if (shift < 31) { <nl> +            if (shift > 0) { <nl> +                *coef += (pv.mant + (1 << (shift - 1))) >> shift; <nl> +            } else <nl> +                *coef += pv.mant << -shift; <nl> +        } <nl>      } <nl>   <nl>      e0 = av_int2sf(*coef, 2);
@@ -29,7 +29,6 @@ <nl>  #include "avformat.h" <nl>  #include "internal.h" <nl>   <nl> -#include "libavutil/avassert.h" <nl>  #include "libavutil/log.h" <nl>  #include "libavutil/opt.h" <nl>  #include "libavutil/avstring.h" <nl> @@ -274,13 +273,18 @@ static int parse_times(void *log_ctx, int64_t **times, int *nb_times, <nl>      for (i = 0; i < *nb_times; i++) { <nl>          int64_t t; <nl>          char *tstr = av_strtok(p, ",", &saveptr); <nl> -        av_assert0(tstr); <nl>          p = NULL; <nl>   <nl> +        if (!tstr || !tstr[0]) { <nl> +            av_log(log_ctx, AV_LOG_ERROR, "Empty time specification in times list %s\n", <nl> +                   times_str); <nl> +            FAIL(AVERROR(EINVAL)); <nl> +        } <nl> + <nl>          ret = av_parse_time(&t, tstr, 1); <nl>          if (ret < 0) { <nl>              av_log(log_ctx, AV_LOG_ERROR, <nl> -                   "Invalid time duration specification in %s\n", p); <nl> +                   "Invalid time duration specification '%s' in times list %s\n", tstr, times_str); <nl>              FAIL(AVERROR(EINVAL)); <nl>          } <nl>          (*times)[i] = t;
@@ -651,6 +651,11 @@ static int read_var_block_data(ALSDecContext *ctx, ALSBlockData *bd) <nl>          for (k = 1; k < sub_blocks; k++) <nl>              s[k] = s[k - 1] + decode_rice(gb, 0); <nl>      } <nl> +    for (k = 1; k < sub_blocks; k++) <nl> +        if (s[k] > 32) { <nl> +            av_log(avctx, AV_LOG_ERROR, "k invalid for rice code.\n"); <nl> +            return AVERROR_INVALIDDATA; <nl> +        } <nl>   <nl>      if (get_bits1(gb)) <nl>          *bd->shift_lsbs = get_bits(gb, 4) + 1;
@@ -406,7 +406,7 @@ static void ogg_write_pages(AVFormatContext *s, int flush) <nl>          if (oggstream->page_count < 2 && !flush) <nl>              break; <nl>          ogg_write_page(s, &p->page, <nl> -                       flush && oggstream->page_count == 1 ? 4 : 0); // eos <nl> +                       flush == 1 && oggstream->page_count == 1 ? 4 : 0); // eos <nl>          next = p->next; <nl>          av_freep(&p); <nl>          p = next; <nl> @@ -550,7 +550,7 @@ static int ogg_write_header(AVFormatContext *s) <nl>   <nl>      oggstream->page.start_granule = AV_NOPTS_VALUE; <nl>   <nl> -    ogg_write_pages(s, 1); <nl> +    ogg_write_pages(s, 2); <nl>   <nl>      return 0; <nl>  }
@@ -221,6 +221,7 @@ vorbis_header (AVFormatContext * s, int idx) <nl>      if (os->buf[os->pstart] == 1) { <nl>          const uint8_t *p = os->buf + os->pstart + 7; /* skip "\001vorbis" tag */ <nl>          unsigned blocksize, bs0, bs1; <nl> +        int srate; <nl>   <nl>          if (os->psize != 30) <nl>              return -1; <nl> @@ -229,7 +230,7 @@ vorbis_header (AVFormatContext * s, int idx) <nl>              return -1; <nl>   <nl>          st->codec->channels = bytestream_get_byte(&p); <nl> -        st->codec->sample_rate = bytestream_get_le32(&p); <nl> +        srate = bytestream_get_le32(&p); <nl>          p += 4; // skip maximum bitrate <nl>          st->codec->bit_rate = bytestream_get_le32(&p); // nominal bitrate <nl>          p += 4; // skip minimum bitrate <nl> @@ -249,8 +250,11 @@ vorbis_header (AVFormatContext * s, int idx) <nl>          st->codec->codec_type = AVMEDIA_TYPE_AUDIO; <nl>          st->codec->codec_id = CODEC_ID_VORBIS; <nl>   <nl> -        st->time_base.num = 1; <nl> -        st->time_base.den = st->codec->sample_rate; <nl> +        if (srate > 0) { <nl> +            st->codec->sample_rate = srate; <nl> +            st->time_base.num = 1; <nl> +            st->time_base.den = srate; <nl> +        } <nl>      } else if (os->buf[os->pstart] == 3) { <nl>          if (os->psize > 8) <nl>              ff_vorbis_comment (s, &st->metadata, os->buf + os->pstart + 7, os->psize - 8);
@@ -140,7 +140,7 @@ static int rprobe(AVFormatContext *s, uint8_t *enc_header, const uint8_t *r_val) <nl>      return memcmp(&enc_header[pos], oc->sm_val, 8) ? -1 : 0; <nl>  } <nl>   <nl> -static int nprobe(AVFormatContext *s, uint8_t *enc_header, const uint8_t *n_val) <nl> +static int nprobe(AVFormatContext *s, uint8_t *enc_header, int size, const uint8_t *n_val) <nl>  { <nl>      OMAContext *oc = s->priv_data; <nl>      uint32_t pos, taglen, datalen; <nl> @@ -159,6 +159,9 @@ static int nprobe(AVFormatContext *s, uint8_t *enc_header, const uint8_t *n_val) <nl>      taglen = AV_RB32(&enc_header[pos+32]); <nl>      datalen = AV_RB32(&enc_header[pos+36]) >> 4; <nl>   <nl> +    if(taglen + (((uint64_t)datalen)<<4) + 44 > size) <nl> +        return -1; <nl> + <nl>      pos += 44 + taglen; <nl>   <nl>      av_des_init(&av_des, n_val, 192, 1); <nl> @@ -229,14 +232,14 @@ static int decrypt_init(AVFormatContext *s, ID3v2ExtraMeta *em, uint8_t *header) <nl>      } <nl>      if (!memcmp(oc->r_val, (const uint8_t[8]){0}, 8) || <nl>          rprobe(s, gdata, oc->r_val) < 0 && <nl> -        nprobe(s, gdata, oc->n_val) < 0) { <nl> +        nprobe(s, gdata, geob->datasize, oc->n_val) < 0) { <nl>          int i; <nl>          for (i = 0; i < FF_ARRAY_ELEMS(leaf_table); i += 2) { <nl>              uint8_t buf[16]; <nl>              AV_WL64(buf, leaf_table[i]); <nl>              AV_WL64(&buf[8], leaf_table[i+1]); <nl>              kset(s, buf, buf, 16); <nl> -            if (!rprobe(s, gdata, oc->r_val) || !nprobe(s, gdata, oc->n_val)) <nl> +            if (!rprobe(s, gdata, oc->r_val) || !nprobe(s, gdata, geob->datasize, oc->n_val)) <nl>                  break; <nl>          } <nl>          if (i >= sizeof(leaf_table)) {
@@ -299,7 +299,7 @@ static av_cold int initFilter(int16_t **outFilter, int32_t **filterPos, <nl>          FF_ALLOC_OR_GOTO(NULL, filter, <nl>                           dstW * sizeof(*filter) * filterSize, fail); <nl>   <nl> -        xDstInSrc = ((dstPos*(int64_t)xInc)>>8) - ((srcPos*0x8000)>>7); <nl> +        xDstInSrc = ((dstPos*(int64_t)xInc)>>8) - ((srcPos*0x8000LL)>>7); <nl>          for (i = 0; i < dstW; i++) { <nl>              int xx = (xDstInSrc - ((filterSize - 1) << 15) + (1 << 15)) >> 16; <nl>   <nl> @@ -315,7 +315,7 @@ static av_cold int initFilter(int16_t **outFilter, int32_t **filterPos, <nl>          FF_ALLOC_OR_GOTO(NULL, filter, <nl>                           dstW * sizeof(*filter) * filterSize, fail); <nl>   <nl> -        xDstInSrc = ((dstPos*(int64_t)xInc)>>8) - ((srcPos*0x8000)>>7); <nl> +        xDstInSrc = ((dstPos*(int64_t)xInc)>>8) - ((srcPos*0x8000LL)>>7); <nl>          for (i = 0; i < dstW; i++) { <nl>              int xx = (xDstInSrc - ((filterSize - 1) << 15) + (1 << 15)) >> 16; <nl>              int j; <nl> @@ -366,7 +366,7 @@ static av_cold int initFilter(int16_t **outFilter, int32_t **filterPos, <nl>          FF_ALLOC_OR_GOTO(NULL, filter, <nl>                           dstW * sizeof(*filter) * filterSize, fail); <nl>   <nl> -        xDstInSrc = ((dstPos*(int64_t)xInc)>>7) - ((srcPos*0x10000)>>7); <nl> +        xDstInSrc = ((dstPos*(int64_t)xInc)>>7) - ((srcPos*0x10000LL)>>7); <nl>          for (i = 0; i < dstW; i++) { <nl>              int xx = (xDstInSrc - ((filterSize - 2) << 16)) / (1 << 17); <nl>              int j;
@@ -1095,13 +1095,13 @@ static void json_print_section_header(WriterContext *wctx) <nl>          json->indent_level++; <nl>          if (section->flags & SECTION_FLAG_IS_ARRAY) { <nl>              printf("\"%s\": [\n", buf.str); <nl> -        } else if (!(parent_section->flags & SECTION_FLAG_IS_ARRAY)) { <nl> +        } else if (parent_section && !(parent_section->flags & SECTION_FLAG_IS_ARRAY)) { <nl>              printf("\"%s\": {%s", buf.str, json->item_start_end); <nl>          } else { <nl>              printf("{%s", json->item_start_end); <nl>   <nl>              /* this is required so the parser can distinguish between packets and frames */ <nl> -            if (parent_section->id == SECTION_ID_PACKETS_AND_FRAMES) { <nl> +            if (parent_section && parent_section->id == SECTION_ID_PACKETS_AND_FRAMES) { <nl>                  if (!json->compact) <nl>                      JSON_INDENT(); <nl>                  printf("\"type\": \"%s\"%s", section->name, json->item_sep);
@@ -1270,10 +1270,12 @@ again: <nl>                  av_log(h->avctx, AV_LOG_ERROR, "decode_slice_header error\n"); <nl>              sl->ref_count[0] = sl->ref_count[1] = sl->list_count = 0; <nl>          } else if (err == SLICE_SINGLETHREAD) { <nl> -            ret = ff_h264_execute_decode_slices(h, context_count); <nl> -            if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE)) <nl> -                goto end; <nl> -            context_count = 0; <nl> +            if (context_count > 0) { <nl> +                ret = ff_h264_execute_decode_slices(h, context_count); <nl> +                if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE)) <nl> +                    goto end; <nl> +                context_count = 0; <nl> +            } <nl>              /* Slice could not be decoded in parallel mode, restart. Note <nl>               * that rbsp_buffer is not transferred, but since we no longer <nl>               * run in parallel mode this should not be an issue. */
@@ -253,6 +253,10 @@ static void pred_spatial_direct_motion(H264Context * const h, int *mb_type){ <nl>              mb_type_col[1] = h->ref_list[1][0].f.mb_type[mb_xy + s->mb_stride]; <nl>              b8_stride = 2+4*s->mb_stride; <nl>              b4_stride *= 6; <nl> +            if (IS_INTERLACED(mb_type_col[0]) != IS_INTERLACED(mb_type_col[1])) { <nl> +                mb_type_col[0] &= ~MB_TYPE_INTERLACED; <nl> +                mb_type_col[1] &= ~MB_TYPE_INTERLACED; <nl> +            } <nl>   <nl>              sub_mb_type |= MB_TYPE_16x16|MB_TYPE_DIRECT2; /* B_SUB_8x8 */ <nl>              if(    (mb_type_col[0] & MB_TYPE_16x16_OR_INTRA) <nl> @@ -439,6 +443,10 @@ static void pred_temp_direct_motion(H264Context * const h, int *mb_type){ <nl>              mb_type_col[1] = h->ref_list[1][0].f.mb_type[mb_xy + s->mb_stride]; <nl>              b8_stride = 2+4*s->mb_stride; <nl>              b4_stride *= 6; <nl> +            if (IS_INTERLACED(mb_type_col[0]) != IS_INTERLACED(mb_type_col[1])) { <nl> +                mb_type_col[0] &= ~MB_TYPE_INTERLACED; <nl> +                mb_type_col[1] &= ~MB_TYPE_INTERLACED; <nl> +            } <nl>   <nl>              sub_mb_type = MB_TYPE_16x16|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; /* B_SUB_8x8 */ <nl>  
@@ -1373,6 +1373,14 @@ static void alloc_picture(void *opaque) <nl>      vp->bmp = SDL_CreateYUVOverlay(vp->width, vp->height, <nl>                                     SDL_YV12_OVERLAY, <nl>                                     screen); <nl> +    if (!vp->bmp || vp->bmp->pitches[0] < vp->width) { <nl> +        /* SDL allocates a buffer smaller than requested if the video <nl> +         * overlay hardware is unable to support the requested size. */ <nl> +        fprintf(stderr, "Error: the video system does not support an image\n" <nl> +                        "size of %dx%d pixels. Try using -vf \"scale=w:h\"\n" <nl> +                        "to reduce the image size.\n", vp->width, vp->height ); <nl> +        do_exit(); <nl> +    } <nl>   <nl>      SDL_LockMutex(is->pictq_mutex); <nl>      vp->allocated = 1;
@@ -522,7 +522,7 @@ static void assert_codec_experimental(AVCodecContext *c, int encoder) <nl>          av_log(NULL, AV_LOG_ERROR, "%s '%s' is experimental and might produce bad " <nl>                  "results.\nAdd '-strict experimental' if you want to use it.\n", <nl>                  codec_string, c->codec->name); <nl> -        codec = encoder ? avcodec_find_encoder(codec->id) : avcodec_find_decoder(codec->id); <nl> +        codec = encoder ? avcodec_find_encoder(c->codec->id) : avcodec_find_decoder(c->codec->id); <nl>          if (!(codec->capabilities & CODEC_CAP_EXPERIMENTAL)) <nl>              av_log(NULL, AV_LOG_ERROR, "Or use the non experimental %s '%s'.\n", <nl>                     codec_string, codec->name);
@@ -1123,7 +1123,7 @@ static void print_report(int is_last_report, int64_t timer_start, int64_t cur_ti <nl>                  for (j = 0; j < 32; j++) <nl>                      snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "%X", (int)lrintf(log2(qp_histogram[j] + 1))); <nl>              } <nl> -            if (enc->flags&CODEC_FLAG_PSNR) { <nl> +            if ((enc->flags&CODEC_FLAG_PSNR) && (enc->coded_frame || is_last_report)) { <nl>                  int j; <nl>                  double error, error_sum = 0; <nl>                  double scale, scale_sum = 0;
@@ -129,8 +129,7 @@ static int allocate_buffers(ShortenContext *s) <nl>              av_log(s->avctx, AV_LOG_ERROR, "nmean too large\n"); <nl>              return AVERROR_INVALIDDATA; <nl>          } <nl> -        if (s->blocksize + s->nwrap >= UINT_MAX / sizeof(int32_t) || <nl> -            s->blocksize + s->nwrap <= (unsigned)s->nwrap) { <nl> +        if (s->blocksize + (uint64_t)s->nwrap >= UINT_MAX / sizeof(int32_t)) { <nl>              av_log(s->avctx, AV_LOG_ERROR, <nl>                     "s->blocksize + s->nwrap too large\n"); <nl>              return AVERROR_INVALIDDATA;
@@ -92,7 +92,7 @@ static int tcp_write_packet(AVFormatContext *s, RTSPStream *rtsp_st) <nl>          interleave_header[0] = '$'; <nl>          interleave_header[1] = id; <nl>          AV_WB16(interleave_header + 2, packet_len); <nl> -        url_write(rt->rtsp_hd, interleaved_packet, 4 + packet_len); <nl> +        url_write(rt->rtsp_hd_out, interleaved_packet, 4 + packet_len); <nl>          ptr += packet_len; <nl>          size -= packet_len; <nl>      }
@@ -322,7 +322,6 @@ static int vorbis_packet(AVFormatContext *s, int idx) <nl>          s->streams[idx]->start_time = os->lastpts + first_duration; <nl>          if (s->streams[idx]->duration) <nl>              s->streams[idx]->duration -= s->streams[idx]->start_time; <nl> -        s->streams[idx]->cur_dts    = AV_NOPTS_VALUE; <nl>          priv->final_pts             = AV_NOPTS_VALUE; <nl>          avpriv_vorbis_parse_reset(&priv->vp); <nl>      }
@@ -1442,6 +1442,10 @@ int ff_mjpeg_decode_frame(AVCodecContext *avctx, <nl>   <nl>                      s->restart_count = 0; <nl>                      /* nothing to do on SOI */ <nl> +                    if (s->got_picture) { <nl> +                        av_log(avctx, AV_LOG_WARNING, "EOI missing, emulating\n"); <nl> +                        goto eoi_parser; <nl> +                    } <nl>                      break; <nl>                  case DQT: <nl>                      ff_mjpeg_decode_dqt(s);
@@ -221,6 +221,12 @@ static int decode_residuals(FLACContext *s, int32_t *decoded, int pred_order) <nl>      rice_order = get_bits(&s->gb, 4); <nl>   <nl>      samples= s->blocksize >> rice_order; <nl> +    if (samples << rice_order != s->blocksize) { <nl> +        av_log(s->avctx, AV_LOG_ERROR, "invalid rice order: %i blocksize %i\n", <nl> +               rice_order, s->blocksize); <nl> +        return AVERROR_INVALIDDATA; <nl> +    } <nl> + <nl>      if (pred_order > samples) { <nl>          av_log(s->avctx, AV_LOG_ERROR, "invalid predictor order: %i > %i\n", <nl>                 pred_order, samples);
@@ -267,8 +267,12 @@ static int cine_read_header(AVFormatContext *avctx) <nl>   <nl>      /* parse image offsets */ <nl>      avio_seek(pb, offImageOffsets, SEEK_SET); <nl> -    for (i = 0; i < st->duration; i++) <nl> +    for (i = 0; i < st->duration; i++) { <nl> +        if (avio_feof(pb)) <nl> +            return AVERROR_INVALIDDATA; <nl> + <nl>          av_add_index_entry(st, avio_rl64(pb), i, 0, 0, AVINDEX_KEYFRAME); <nl> +    } <nl>   <nl>      return 0; <nl>  }
@@ -108,7 +108,7 @@ static int pic_arrays_init(HEVCContext *s, const HEVCSPS *sps) <nl>      if (!s->tab_ipm || !s->cbf_luma || !s->is_pcm) <nl>          goto fail; <nl>   <nl> -    s->filter_slice_edges = av_malloc(ctb_count); <nl> +    s->filter_slice_edges = av_mallocz(ctb_count); <nl>      s->tab_slice_address  = av_malloc_array(pic_size_in_ctb, <nl>                                        sizeof(*s->tab_slice_address)); <nl>      s->qp_y_tab           = av_malloc_array(pic_size_in_ctb,
@@ -84,6 +84,8 @@ int main(int argc, char **argv) <nl>          pd.buf      = av_realloc(pd.buf, size + AVPROBE_PADDING_SIZE); <nl>          pd.filename = ""; <nl>   <nl> +        memset(pd.buf, 0, size + AVPROBE_PADDING_SIZE); <nl> + <nl>          fprintf(stderr, "testing size=%d\n", size); <nl>   <nl>          for (retry = 0; retry < retry_count; retry += FFMAX(size, 32)) {
@@ -725,7 +725,10 @@ void ff_compute_frame_duration(int *pnum, int *pden, AVStream *st, <nl>              *pnum = st->codec->time_base.num; <nl>              *pden = st->codec->time_base.den; <nl>              if (pc && pc->repeat_pict) { <nl> -                *pnum = (*pnum) * (1 + pc->repeat_pict); <nl> +                if (*pnum > INT_MAX / (1 + pc->repeat_pict)) <nl> +                    *pden /= 1 + pc->repeat_pict; <nl> +                else <nl> +                    *pnum *= 1 + pc->repeat_pict; <nl>              } <nl>              //If this codec can be interlaced or progressive then we need a parser to compute duration of a packet <nl>              //Thus if we have no parser in such case leave duration undefined.
@@ -295,6 +295,7 @@ static int query_formats(AVFilterContext *ctx) <nl>      case FLAT:    in_pix_fmts = in_flat_pix_fmts;    break; <nl>      case ACOLOR: <nl>      case COLOR:   in_pix_fmts = in_color_pix_fmts;   break; <nl> +    default: return AVERROR_BUG; <nl>      } <nl>   <nl>      if (!ctx->inputs[0]->out_formats) {
@@ -1915,6 +1915,7 @@ static int mxf_read_close(AVFormatContext *s) <nl>   <nl>      for (i = 0; i < mxf->nb_index_tables; i++) { <nl>          av_freep(&mxf->index_tables[i].segments); <nl> +        av_freep(&mxf->index_tables[i].ptses); <nl>          av_freep(&mxf->index_tables[i].fake_index); <nl>      } <nl>      av_freep(&mxf->index_tables);
@@ -78,6 +78,7 @@ struct x11grab { <nl>      int  show_region;        /**< set by a private option. */ <nl>      char *framerate;         /**< Set by a private option. */ <nl>   <nl> +    Cursor c; <nl>      Window region_win;       /**< This is used by show_region option. */ <nl>  }; <nl>   <nl> @@ -353,7 +354,6 @@ paint_mouse_pointer(XImage *image, struct x11grab *s) <nl>       * Anyone who performs further investigation of the xlib API likely risks <nl>       * permanent brain damage. */ <nl>      uint8_t *pix = image->data; <nl> -    Cursor c; <nl>      Window w; <nl>      XSetWindowAttributes attr; <nl>   <nl> @@ -361,9 +361,10 @@ paint_mouse_pointer(XImage *image, struct x11grab *s) <nl>      if (image->bits_per_pixel != 24 && image->bits_per_pixel != 32) <nl>          return; <nl>   <nl> -    c = XCreateFontCursor(dpy, XC_left_ptr); <nl> +    if(!s->c) <nl> +        s->c = XCreateFontCursor(dpy, XC_left_ptr); <nl>      w = DefaultRootWindow(dpy); <nl> -    attr.cursor = c; <nl> +    attr.cursor = s->c; <nl>      XChangeWindowAttributes(dpy, w, CWCursor, &attr); <nl>   <nl>      xcim = XFixesGetCursorImage(dpy);
@@ -489,8 +489,10 @@ static av_cold int truemotion1_decode_init(AVCodecContext *avctx) <nl>      /* there is a vertical predictor for each pixel in a line; each vertical <nl>       * predictor is 0 to start with */ <nl>      av_fast_malloc(&s->vert_pred, &s->vert_pred_size, s->avctx->width * sizeof(unsigned int)); <nl> -    if (!s->vert_pred) <nl> +    if (!s->vert_pred) { <nl> +        av_frame_free(&s->frame); <nl>          return AVERROR(ENOMEM); <nl> +    } <nl>   <nl>      return 0; <nl>  }
@@ -1862,8 +1862,10 @@ static int handle_packet(MpegTSContext *ts, const uint8_t *packet) <nl>          return 0; <nl>   <nl>      pos = avio_tell(ts->stream->pb); <nl> -    av_assert0(pos >= TS_PACKET_SIZE); <nl> -    ts->pos47_full = pos - TS_PACKET_SIZE; <nl> +    if (pos >= 0) { <nl> +        av_assert0(pos >= TS_PACKET_SIZE); <nl> +        ts->pos47_full = pos - TS_PACKET_SIZE; <nl> +    } <nl>   <nl>      if (tss->type == MPEGTS_SECTION) { <nl>          if (is_start) {
@@ -104,7 +104,7 @@ int ff_rtp_get_payload_type(AVFormatContext *fmt, <nl>      for (i = 0; rtp_payload_types[i].pt >= 0; ++i) <nl>          if (rtp_payload_types[i].codec_id == codec->codec_id) { <nl>              if (codec->codec_id == AV_CODEC_ID_H263 && (!fmt || <nl> -                !fmt->oformat->priv_class || <nl> +                !fmt->oformat->priv_class || !fmt->priv_data || <nl>                  !av_opt_flag_is_set(fmt->priv_data, "rtpflags", "rfc2190"))) <nl>                  continue; <nl>              /* G722 has 8000 as nominal rate even if the sample rate is 16000,
@@ -707,7 +707,10 @@ static int rv10_decode_frame(AVCodecContext *avctx, <nl>              offset + FFMAX(size, size2) > buf_size) <nl>              return AVERROR_INVALIDDATA; <nl>   <nl> -        if (rv10_decode_packet(avctx, buf + offset, size, size2) > 8 * size) <nl> +        if ((ret = rv10_decode_packet(avctx, buf + offset, size, size2)) < 0) <nl> +            return ret; <nl> + <nl> +        if (ret > 8 * size) <nl>              i++; <nl>      } <nl>  
@@ -211,6 +211,12 @@ static int rscc_decode_frame(AVCodecContext *avctx, void *data, <nl>          ctx->tiles[i].y = bytestream2_get_le16(gbc); <nl>          ctx->tiles[i].h = bytestream2_get_le16(gbc); <nl>   <nl> +        if (pixel_size + ctx->tiles[i].w * (int64_t)ctx->tiles[i].h * ctx->component_size > INT_MAX) { <nl> +            av_log(avctx, AV_LOG_ERROR, "Invalid tile dimensions\n"); <nl> +            ret = AVERROR_INVALIDDATA; <nl> +            goto end; <nl> +        } <nl> + <nl>          pixel_size += ctx->tiles[i].w * ctx->tiles[i].h * ctx->component_size; <nl>   <nl>          ff_dlog(avctx, "tile %d orig(%d,%d) %dx%d.\n", i,
@@ -272,7 +272,7 @@ static int eval_refl(const int16_t *coefs, int *refl, RA144Context *ractx) <nl>   <nl>      if (u + 0x1000 > 0x1fff) { <nl>          av_log(ractx, AV_LOG_ERROR, "Overflow. Broken sample?\n"); <nl> -        return 0; <nl> +        return 1; <nl>      } <nl>   <nl>      for (c=8; c >= 0; c--) {
@@ -462,6 +462,7 @@ int ff_h264_decode_picture_parameter_set(H264Context *h, int bit_length){ <nl>      unsigned int pps_id= get_ue_golomb(&s->gb); <nl>      PPS *pps; <nl>      const int qp_bd_offset = 6*(h->sps.bit_depth_luma-8); <nl> +    int bits_left; <nl>   <nl>      if(pps_id >= MAX_PPS_COUNT) { <nl>          av_log(h->s.avctx, AV_LOG_ERROR, "pps_id (%d) out of range\n", pps_id); <nl> @@ -538,7 +539,9 @@ int ff_h264_decode_picture_parameter_set(H264Context *h, int bit_length){ <nl>      memcpy(pps->scaling_matrix4, h->sps_buffers[pps->sps_id]->scaling_matrix4, sizeof(pps->scaling_matrix4)); <nl>      memcpy(pps->scaling_matrix8, h->sps_buffers[pps->sps_id]->scaling_matrix8, sizeof(pps->scaling_matrix8)); <nl>   <nl> -    if(get_bits_count(&s->gb) < bit_length){ <nl> +    bits_left = bit_length - get_bits_count(&s->gb); <nl> +    if (bits_left && (bits_left > 8 || <nl> +                      show_bits(&s->gb, bits_left) != 1 << (bits_left - 1))) { <nl>          pps->transform_8x8_mode= get_bits1(&s->gb); <nl>          decode_scaling_matrices(h, h->sps_buffers[pps->sps_id], pps, 0, pps->scaling_matrix4, pps->scaling_matrix8); <nl>          pps->chroma_qp_index_offset[1]= get_se_golomb(&s->gb); //second_chroma_qp_index_offset
@@ -163,6 +163,8 @@ static int avs_read_packet(AVFormatContext * s, AVPacket * pkt) <nl>              sub_type = avio_r8(s->pb); <nl>              type = avio_r8(s->pb); <nl>              size = avio_rl16(s->pb); <nl> +            if (size < 4) <nl> +                return AVERROR_INVALIDDATA; <nl>              avs->remaining_frame_size -= size; <nl>   <nl>              switch (type) {
@@ -1232,8 +1232,8 @@ int MPV_frame_start(MpegEncContext *s, AVCodecContext *avctx) <nl>                  return -1; <nl>   <nl>              if(s->codec_id == CODEC_ID_FLV1 || s->codec_id == CODEC_ID_H263){ <nl> -                for(i=0; i<s->height; i++) <nl> -                    memset(s->last_picture_ptr->f.data[0] + s->last_picture_ptr->f.linesize[0]*i, 16, s->width); <nl> +                for(i=0; i<avctx->height; i++) <nl> +                    memset(s->last_picture_ptr->f.data[0] + s->last_picture_ptr->f.linesize[0]*i, 16, avctx->width); <nl>              } <nl>   <nl>              ff_thread_report_progress((AVFrame*)s->last_picture_ptr, INT_MAX, 0);
@@ -685,6 +685,8 @@ av_cold int avcodec_close(AVCodecContext *avctx) <nl>          avctx->codec->close(avctx); <nl>      avcodec_default_free_buffers(avctx); <nl>      av_freep(&avctx->priv_data); <nl> +    if(avctx->codec->encode) <nl> +        av_freep(&avctx->extradata); <nl>      avctx->codec = NULL; <nl>      entangled_thread_counter--; <nl>  
@@ -141,7 +141,7 @@ static av_always_inline float quantize_and_encode_band_cost_template( <nl>              if (BT_ESC) { <nl>                  for (j = 0; j < 2; j++) { <nl>                      if (ff_aac_codebook_vectors[cb-1][curidx*2+j] == 64.0f) { <nl> -                        int coef = av_clip_uintp2(quant(fabsf(in[i+j]), Q, ROUNDING), 13); <nl> +                        int coef = av_clip(quant(fabsf(in[i+j]), Q, ROUNDING), 0, (1 << 13) - 1); <nl>                          int len = av_log2(coef); <nl>   <nl>                          put_bits(pb, len - 4 + 1, (1 << (len - 4 + 1)) - 2);
@@ -1556,11 +1556,8 @@ static void mov_build_index(MOVContext *mov, AVStream *st) <nl>   <nl>  static int mov_open_dref(ByteIOContext **pb, char *src, MOVDref *ref) <nl>  { <nl> -    /* try absolute path */ <nl> -    if (!url_fopen(pb, ref->path, URL_RDONLY)) <nl> -        return 0; <nl> - <nl> -    /* try relative path */ <nl> +    /* try relative path, we do not try the absolute because it can leak information about our <nl> +       system to an attacker */ <nl>      if (ref->nlvl_to > 0 && ref->nlvl_from > 0) { <nl>          char filename[1024]; <nl>          char *src_path;
@@ -148,7 +148,7 @@ static int pcx_decode_frame(AVCodecContext *avctx, void *data, int *got_frame, <nl>      ptr    = p->data[0]; <nl>      stride = p->linesize[0]; <nl>   <nl> -    scanline = av_malloc(bytes_per_scanline); <nl> +    scanline = av_malloc(bytes_per_scanline + AV_INPUT_BUFFER_PADDING_SIZE); <nl>      if (!scanline) <nl>          return AVERROR(ENOMEM); <nl>  
@@ -963,7 +963,7 @@ static int unpack_modes(Vp3DecodeContext *s, GetBitContext *gb) <nl>   */ <nl>  static int unpack_vectors(Vp3DecodeContext *s, GetBitContext *gb) <nl>  { <nl> -    int i, j, k; <nl> +    int i, j, k, l; <nl>      int coding_mode; <nl>      int motion_x[6]; <nl>      int motion_y[6]; <nl> @@ -1047,6 +1047,10 @@ static int unpack_vectors(Vp3DecodeContext *s, GetBitContext *gb) <nl>                       * Y fragment, then average for the C fragment vectors */ <nl>                      motion_x[4] = motion_y[4] = 0; <nl>                      for (k = 0; k < 4; k++) { <nl> +                        for (l = 0; l < s->coded_fragment_list_index; l++) <nl> +                            if (s->coded_fragment_list[l] == s->macroblock_fragments[6*current_macroblock + k]) <nl> +                                break; <nl> +                        if (l < s->coded_fragment_list_index) { <nl>                          if (coding_mode == 0) { <nl>                              motion_x[k] = motion_vector_table[get_vlc2(gb, s->motion_vector_vlc.table, 6, 2)]; <nl>                              motion_y[k] = motion_vector_table[get_vlc2(gb, s->motion_vector_vlc.table, 6, 2)]; <nl> @@ -1056,6 +1060,10 @@ static int unpack_vectors(Vp3DecodeContext *s, GetBitContext *gb) <nl>                          } <nl>                          last_motion_x = motion_x[k]; <nl>                          last_motion_y = motion_y[k]; <nl> +                        } else { <nl> +                            motion_x[k] = 0; <nl> +                            motion_y[k] = 0; <nl> +                        } <nl>                          motion_x[4] += motion_x[k]; <nl>                          motion_y[4] += motion_y[k]; <nl>                      }
@@ -76,7 +76,8 @@ void uninit_opts(void) <nl>      av_freep(&avformat_opts->key); <nl>      av_freep(&avformat_opts); <nl>  #if CONFIG_SWSCALE <nl> -    av_freep(&sws_opts); <nl> +    sws_freeContext(sws_opts); <nl> +    sws_opts = NULL; <nl>  #endif <nl>      for (i = 0; i < opt_name_count; i++) { <nl>          //opt_values are only stored for codec-specific options in which case
@@ -269,7 +269,7 @@ static int16_t g726_decode(G726Context* c, int I) <nl>          c->se += mult(i2f(c->a[i] >> 2, &f), &c->sr[i]); <nl>      c->se >>= 1; <nl>   <nl> -    return av_clip(re_signal << 2, -0xffff, 0xffff); <nl> +    return av_clip(re_signal * 4, -0xffff, 0xffff); <nl>  } <nl>   <nl>  static av_cold int g726_reset(G726Context *c)
@@ -99,7 +99,7 @@ void ff_spatial_idwt_slice2(DWTContext *d, int y); <nl>      (b1 + ((b0 + b2 + 1) >> 1)) <nl>   <nl>  #define COMPOSE_DD97iH0(b0, b1, b2, b3, b4)\ <nl> -    (b2 + ((-b0 + 9*b1 + 9*b3 - b4 + 8) >> 4)) <nl> +    (b2 + ((int)(-b0 + 9U*b1 + 9U*b3 - b4 + 8) >> 4)) <nl>   <nl>  #define COMPOSE_DD137iL0(b0, b1, b2, b3, b4)\ <nl>      (b2 - ((-b0 + 9*b1 + 9*b3 - b4 + 16) >> 5))
@@ -48,8 +48,11 @@ static int query_formats(AVFilterContext *ctx) <nl>      static const enum AVPixelFormat out_fmts[] = {AV_PIX_FMT_RGB32, AV_PIX_FMT_NONE}; <nl>      AVFilterFormats *in  = ff_make_format_list(in_fmts); <nl>      AVFilterFormats *out = ff_make_format_list(out_fmts); <nl> -    if (!in || !out) <nl> +    if (!in || !out) { <nl> +        av_freep(&in); <nl> +        av_freep(&out); <nl>          return AVERROR(ENOMEM); <nl> +    } <nl>      ff_formats_ref(in,  &ctx->inputs[0]->out_formats); <nl>      ff_formats_ref(out, &ctx->outputs[0]->in_formats); <nl>      return 0;
@@ -160,7 +160,7 @@ static int encode_block(SVQ1Context *s, uint8_t *src, uint8_t *ref, uint8_t *dec <nl>      } <nl>   <nl>      best_count=0; <nl> -    best_score -= ((block_sum[0]*block_sum[0])>>(level+3)); <nl> +    best_score -= (int)(((unsigned)block_sum[0]*block_sum[0])>>(level+3)); <nl>      best_mean= (block_sum[0] + (size>>1)) >> (level+3); <nl>   <nl>      if(level<4){
@@ -136,7 +136,7 @@ static unsigned int mszh_decomp(unsigned char * srcptr, int srclen, unsigned cha <nl>          } else { <nl>              ofs = *(srcptr++); <nl>              cnt = *(srcptr++); <nl> -            ofs += cnt * 256;; <nl> +            ofs += cnt * 256; <nl>              cnt = ((cnt >> 3) & 0x1f) + 1; <nl>              ofs &= 0x7ff; <nl>              srclen -= 2; <nl> @@ -302,7 +302,7 @@ static int decode_frame(AVCodecContext *avctx, void *data, int *data_size, const <nl>              } <nl>          } <nl>          encoded = c->decomp_buf; <nl> -        len = c->decomp_size;; <nl> +        len = c->decomp_size; <nl>  #else <nl>          av_log(avctx, AV_LOG_ERROR, "BUG! Zlib support not compiled in frame decoder.\n"); <nl>          return -1;
@@ -643,9 +643,9 @@ static int get_cookies(HTTPContext *s, char **cookies, const char *path, <nl>          } <nl>   <nl>          done_cookie: <nl> -        av_free(cdomain); <nl> -        av_free(cpath); <nl> -        av_free(cvalue); <nl> +        av_freep(&cdomain); <nl> +        av_freep(&cpath); <nl> +        av_freep(&cvalue); <nl>          if (ret < 0) { <nl>              if (*cookies) av_freep(cookies); <nl>              av_free(cset_cookies);
@@ -1712,10 +1712,6 @@ static void imdct_and_windowing(AACContext *ac, SingleChannelElement *sce, float <nl>   <nl>      // imdct <nl>      if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) { <nl> -        if (ics->window_sequence[1] == ONLY_LONG_SEQUENCE || ics->window_sequence[1] == LONG_STOP_SEQUENCE) <nl> -            av_log(ac->avctx, AV_LOG_WARNING, <nl> -                   "Transition from an ONLY_LONG or LONG_STOP to an EIGHT_SHORT sequence detected. " <nl> -                   "If you heard an audible artifact, please submit the sample to the FFmpeg developers.\n"); <nl>          for (i = 0; i < 1024; i += 128) <nl>              ff_imdct_half(&ac->mdct_small, buf + i, in + i); <nl>      } else
@@ -463,6 +463,9 @@ void av_frame_unref(AVFrame *frame) <nl>  { <nl>      int i; <nl>   <nl> +    if (!frame) <nl> +        return; <nl> + <nl>      wipe_side_data(frame); <nl>   <nl>      for (i = 0; i < FF_ARRAY_ELEMS(frame->buf); i++)
@@ -107,7 +107,7 @@ AVCodec ff_sp5x_decoder = { <nl>      sp5x_decode_frame, <nl>      CODEC_CAP_DR1, <nl>      NULL, <nl> -    .max_lowres = 5, <nl> +    .max_lowres = 3, <nl>      .long_name = NULL_IF_CONFIG_SMALL("Sunplus JPEG (SP5X)"), <nl>  }; <nl>  
@@ -182,7 +182,7 @@ static int hls_write_header(AVFormatContext *s) <nl>      int ret, i; <nl>      char *p; <nl>      const char *pattern = "%d.ts"; <nl> -    int basename_size = strlen(s->filename) + strlen(pattern); <nl> +    int basename_size = strlen(s->filename) + strlen(pattern) + 1; <nl>   <nl>      hls->number      = 0; <nl>  
@@ -1574,7 +1574,7 @@ static void mov_parse_stsd_audio(MOVContext *c, AVIOContext *pb, <nl>   <nl>  static void mov_parse_stsd_subtitle(MOVContext *c, AVIOContext *pb, <nl>                                      AVStream *st, MOVStreamContext *sc, <nl> -                                    int size) <nl> +                                    int64_t size) <nl>  { <nl>      // ttxt stsd contains display flags, justification, background <nl>      // color, fonts, and default styles, so fake an atom to read it <nl> @@ -1639,10 +1639,10 @@ static int mov_rewrite_dvd_sub_extradata(AVStream *st) <nl>   <nl>  static int mov_parse_stsd_data(MOVContext *c, AVIOContext *pb, <nl>                                  AVStream *st, MOVStreamContext *sc, <nl> -                                int size) <nl> +                                int64_t size) <nl>  { <nl>      if (st->codec->codec_tag == MKTAG('t','m','c','d')) { <nl> -        if (ff_get_extradata(st->codec, pb, size) < 0) <nl> +        if ((int)size != size || ff_get_extradata(st->codec, pb, size) < 0) <nl>              return AVERROR(ENOMEM); <nl>          if (size > 16) { <nl>              MOVStreamContext *tmcd_ctx = st->priv_data;
@@ -30,6 +30,12 @@ <nl>   <nl>  static av_cold int encode_init(AVCodecContext *avctx) <nl>  { <nl> +    if (avctx->width > 65535 || avctx->height > 65535) { <nl> +        av_log(avctx, AV_LOG_ERROR, <nl> +               "Unsupported resolution %dx%d.\n", avctx->width, avctx->height); <nl> +        return AVERROR_INVALIDDATA; <nl> +    } <nl> + <nl>      avctx->coded_frame = av_frame_alloc(); <nl>      if (!avctx->coded_frame) <nl>          return AVERROR(ENOMEM);
@@ -122,6 +122,8 @@ int av_bitstream_filter_filter(AVBitStreamFilterContext *bsfc, <nl>                  shorthand[0] = opt->name; <nl>   <nl>              ret = av_opt_set_from_string(priv->ctx->priv_data, bsfc->args, shorthand, "=", ":"); <nl> +            if (ret < 0) <nl> +                return ret; <nl>          } <nl>   <nl>          ret = av_bsf_init(priv->ctx);
@@ -993,8 +993,10 @@ static int mov_read_extradata(MOVContext *c, AVIOContext *pb, MOVAtom atom, <nl>      size= (uint64_t)st->codec->extradata_size + atom.size + 8 + FF_INPUT_BUFFER_PADDING_SIZE; <nl>      if (size > INT_MAX || (uint64_t)atom.size > INT_MAX) <nl>          return AVERROR_INVALIDDATA; <nl> -    if ((err = av_reallocp(&st->codec->extradata, size)) < 0) <nl> +    if ((err = av_reallocp(&st->codec->extradata, size)) < 0) { <nl> +        st->codec->extradata_size = 0; <nl>          return err; <nl> +    } <nl>      buf = st->codec->extradata + st->codec->extradata_size; <nl>      st->codec->extradata_size= size - FF_INPUT_BUFFER_PADDING_SIZE; <nl>      AV_WB32(       buf    , atom.size + 8);
@@ -331,6 +331,9 @@ static int decompress_i(AVCodecContext *avctx, uint32_t *dst, int linesize) <nl>          clr = (b << 16) + (g << 8) + r; <nl>          k += run; <nl>          while (run-- > 0) { <nl> +            if (y >= avctx->height) <nl> +                return AVERROR_INVALIDDATA; <nl> + <nl>              dst[y * linesize + x] = clr; <nl>              lx = x; <nl>              ly = y;
@@ -491,6 +491,7 @@ static int submit_packet(PerThreadContext *p, AVPacket *avpkt) <nl>      } <nl>   <nl>      fctx->prev_thread = p; <nl> +    fctx->next_decoding++; <nl>   <nl>      return 0; <nl>  } <nl> @@ -513,8 +514,6 @@ int ff_thread_decode_frame(AVCodecContext *avctx, <nl>      err = submit_packet(p, avpkt); <nl>      if (err) return err; <nl>   <nl> -    fctx->next_decoding++; <nl> - <nl>      /* <nl>       * If we're still receiving the initial packets, don't return a frame. <nl>       */
@@ -72,6 +72,7 @@ typedef struct PerThreadContext { <nl>      struct FrameThreadContext *parent; <nl>   <nl>      pthread_t      thread; <nl> +    int thread_created; <nl>      pthread_cond_t input_cond;      ///< Used to wait for a new packet from the main thread. <nl>      pthread_cond_t progress_cond;   ///< Used by child threads to wait for progress to change. <nl>      pthread_cond_t output_cond;     ///< Used by the main thread to wait for frames to finish. <nl> @@ -658,8 +659,9 @@ static void frame_thread_free(AVCodecContext *avctx, int thread_count) <nl>          pthread_cond_signal(&p->input_cond); <nl>          pthread_mutex_unlock(&p->mutex); <nl>   <nl> -        if (p->thread) <nl> +        if (p->thread_created) <nl>              pthread_join(p->thread, NULL); <nl> +        p->thread_created=0; <nl>   <nl>          if (codec->close) <nl>              codec->close(p->avctx); <nl> @@ -763,7 +765,7 @@ static int frame_thread_init(AVCodecContext *avctx) <nl>   <nl>          if (err) goto error; <nl>   <nl> -        pthread_create(&p->thread, NULL, frame_worker_thread, p); <nl> +        p->thread_created= !pthread_create(&p->thread, NULL, frame_worker_thread, p); <nl>      } <nl>   <nl>      return 0;
@@ -58,7 +58,7 @@ int avpriv_adx_decode_header(AVCodecContext *avctx, const uint8_t *buf, <nl>   <nl>      /* channels */ <nl>      avctx->channels = buf[7]; <nl> -    if (avctx->channels > 2) <nl> +    if (avctx->channels <= 0 || avctx->channels > 2) <nl>          return AVERROR_INVALIDDATA; <nl>   <nl>      /* sample rate */
@@ -52,7 +52,10 @@ static void decode_nal_sei_decoded_picture_hash(HEVCContext *s) <nl>  static void decode_nal_sei_frame_packing_arrangement(HEVCContext *s) <nl>  { <nl>      GetBitContext *gb = &s->HEVClc->gb; <nl> -    int cancel, type, quincunx, content; <nl> +    int cancel; <nl> +    int quincunx =  0; <nl> +    int content  = -1; <nl> +    int type     = -1; <nl>   <nl>      get_ue_golomb(gb);                  // frame_packing_arrangement_id <nl>      cancel = get_bits1(gb);             // frame_packing_cancel_flag
@@ -146,7 +146,7 @@ static int parse_strk(AVFormatContext *s, <nl>   <nl>      if (fourxm->tracks[track].channels    <= 0 || <nl>          fourxm->tracks[track].sample_rate <= 0 || <nl> -        fourxm->tracks[track].bits        < 0) { <nl> +        fourxm->tracks[track].bits        <= 0) { <nl>          av_log(s, AV_LOG_ERROR, "audio header invalid\n"); <nl>          return AVERROR_INVALIDDATA; <nl>      }
@@ -170,7 +170,7 @@ typedef struct { <nl>      /// I/O data <nl>      const uint8_t *compressed_data; <nl>      int compressed_size; <nl> -    float output_buffer[QDM2_MAX_FRAME_SIZE * 2]; <nl> +    float output_buffer[QDM2_MAX_FRAME_SIZE * MPA_MAX_CHANNELS * 2]; <nl>   <nl>      /// Synthesis filter <nl>      MPADSPContext mpadsp; <nl> @@ -1896,6 +1896,9 @@ static int qdm2_decode (QDM2Context *q, const uint8_t *in, int16_t *out) <nl>      int ch, i; <nl>      const int frame_size = (q->frame_size * q->channels); <nl>   <nl> +    if((unsigned)frame_size > FF_ARRAY_ELEMS(q->output_buffer)/2) <nl> +        return -1; <nl> + <nl>      /* select input buffer */ <nl>      q->compressed_data = in; <nl>      q->compressed_size = q->checksum_size;
@@ -370,6 +370,10 @@ static int decode_p_block(FourXContext *f, uint16_t *dst, uint16_t *src, <nl>                                    log2w, log2h, stride)) < 0) <nl>              return ret; <nl>      } else if (code == 3 && f->version < 2) { <nl> +        if (start > src || src > end) { <nl> +            av_log(f->avctx, AV_LOG_ERROR, "mv out of pic\n"); <nl> +            return AVERROR_INVALIDDATA; <nl> +        } <nl>          mcdc(dst, src, log2w, h, stride, 1, 0); <nl>      } else if (code == 4) { <nl>          src += f->mv[bytestream2_get_byte(&f->g)]; <nl> @@ -379,6 +383,10 @@ static int decode_p_block(FourXContext *f, uint16_t *dst, uint16_t *src, <nl>          } <nl>          mcdc(dst, src, log2w, h, stride, 1, bytestream2_get_le16(&f->g2)); <nl>      } else if (code == 5) { <nl> +        if (start > src || src > end) { <nl> +            av_log(f->avctx, AV_LOG_ERROR, "mv out of pic\n"); <nl> +            return AVERROR_INVALIDDATA; <nl> +        } <nl>          mcdc(dst, src, log2w, h, stride, 0, bytestream2_get_le16(&f->g2)); <nl>      } else if (code == 6) { <nl>          if (log2w) {
@@ -508,7 +508,7 @@ int av_packet_unpack_dictionary(const uint8_t *data, int size, AVDictionary **di <nl>          const uint8_t *key = data; <nl>          const uint8_t *val = data + strlen(key) + 1; <nl>   <nl> -        if (val >= end) <nl> +        if (val >= end || !*key) <nl>              return AVERROR_INVALIDDATA; <nl>   <nl>          ret = av_dict_set(dict, key, val, 0);
@@ -83,7 +83,7 @@ int main(int argc, char *argv[]) <nl>      uint64_t atom_offset = 0; <nl>      uint64_t last_offset; <nl>      unsigned char *moov_atom = NULL; <nl> -    unsigned char *ftyp_atom = 0; <nl> +    unsigned char *ftyp_atom = NULL; <nl>      uint64_t moov_atom_size; <nl>      uint64_t ftyp_atom_size = 0; <nl>      uint64_t i, j;
@@ -975,7 +975,7 @@ static int asf_read_frame_header(AVFormatContext *s, AVIOContext *pb){ <nl>              case 0x54: <nl>                  aspect.num = avio_r8(pb); <nl>                  aspect.den = avio_r8(pb); <nl> -                if (aspect.num > 0 && aspect.den > 0) { <nl> +                if (aspect.num > 0 && aspect.den > 0 && asf->stream_index >= 0) { <nl>                      s->streams[asf->stream_index]->sample_aspect_ratio = aspect; <nl>                  } <nl>                  break;
@@ -139,9 +139,10 @@ static int tqi_decode_frame(AVCodecContext *avctx, <nl>      for (s->mb_x=0; s->mb_x<(avctx->width+15)/16; s->mb_x++) <nl>      { <nl>          if(tqi_decode_mb(s, t->block) < 0) <nl> -            break; <nl> +            goto end; <nl>          tqi_idct_put(t, t->block); <nl>      } <nl> +    end: <nl>   <nl>      *data_size = sizeof(AVFrame); <nl>      *(AVFrame*)data = t->frame;
@@ -203,6 +203,10 @@ static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPac <nl>                  ; <nl>              } else if (c->flags & FLAG_MULTITHREAD) { <nl>                  mthread_inlen = AV_RL32(encoded); <nl> +                if (len < 8) { <nl> +                    av_log(avctx, AV_LOG_ERROR, "len %d is too small\n", len); <nl> +                    return AVERROR_INVALIDDATA; <nl> +                } <nl>                  mthread_inlen = FFMIN(mthread_inlen, len - 8); <nl>                  mthread_outlen = AV_RL32(encoded+4); <nl>                  mthread_outlen = FFMIN(mthread_outlen, c->decomp_size);
@@ -4245,7 +4245,6 @@ static void vc1_decode_b_mb_intfi(VC1Context *v) <nl>      int dmv_x[2], dmv_y[2], pred_flag[2]; <nl>      int bmvtype = BMV_TYPE_BACKWARD; <nl>      int idx_mbmode; <nl> -    int av_uninit(interpmvp); <nl>   <nl>      mquant      = v->pq; /* Lossy initialization */ <nl>      s->mb_intra = 0; <nl> @@ -4298,6 +4297,7 @@ static void vc1_decode_b_mb_intfi(VC1Context *v) <nl>          else <nl>              fwd = v->forward_mb_plane[mb_pos]; <nl>          if (idx_mbmode <= 5) { // 1-MV <nl> +            int interpmvp = 0; <nl>              dmv_x[0]     = dmv_x[1] = dmv_y[0] = dmv_y[1] = 0; <nl>              pred_flag[0] = pred_flag[1] = 0; <nl>              if (fwd) <nl> @@ -4320,7 +4320,7 @@ static void vc1_decode_b_mb_intfi(VC1Context *v) <nl>              if (bmvtype != BMV_TYPE_DIRECT && idx_mbmode & 1) { <nl>                  get_mvdata_interlaced(v, &dmv_x[bmvtype == BMV_TYPE_BACKWARD], &dmv_y[bmvtype == BMV_TYPE_BACKWARD], &pred_flag[bmvtype == BMV_TYPE_BACKWARD]); <nl>              } <nl> -            if (bmvtype == BMV_TYPE_INTERPOLATED && interpmvp) { <nl> +            if (interpmvp) { <nl>                  get_mvdata_interlaced(v, &dmv_x[1], &dmv_y[1], &pred_flag[1]); <nl>              } <nl>              if (bmvtype == BMV_TYPE_DIRECT) {
@@ -2454,7 +2454,11 @@ static int mov_write_tkhd_tag(AVIOContext *pb, MOVMuxContext *mov, <nl>              if (!track_width_1616 || <nl>                  track->height != track->par->height || <nl>                  track_width_1616 > UINT32_MAX) <nl> -                track_width_1616 = track->par->width * 0x10000U; <nl> +                track_width_1616 = track->par->width * 0x10000ULL; <nl> +            if (track_width_1616 > UINT32_MAX) { <nl> +                av_log(mov->fc, AV_LOG_WARNING, "track width too large\n"); <nl> +                track_width_1616 = 0; <nl> +            } <nl>              avio_wb32(pb, track_width_1616); <nl>              avio_wb32(pb, track->height * 0x10000U); <nl>          }
@@ -805,7 +805,7 @@ static int dca_subframe_header(DCAContext *s, int base_channel, int block_index) <nl>                         "Invalid channel mode %d\n", am); <nl>                  return AVERROR_INVALIDDATA; <nl>              } <nl> -            for (j = base_channel; j < s->prim_channels; j++) { <nl> +            for (j = base_channel; j < FFMIN(s->prim_channels, FF_ARRAY_ELEMS(dca_default_coeffs[am])); j++) { <nl>                  s->downmix_coef[j][0] = dca_default_coeffs[am][j][0]; <nl>                  s->downmix_coef[j][1] = dca_default_coeffs[am][j][1]; <nl>              }
@@ -71,12 +71,16 @@ static int sdl_write_trailer(AVFormatContext *s) <nl>   <nl>      if (sdl->overlay) <nl>          SDL_FreeYUVOverlay(sdl->overlay); <nl> +    sdl->overlay = NULL; <nl>      if (sdl->event_thread) <nl>          SDL_WaitThread(sdl->event_thread, NULL); <nl> +    sdl->event_thread = NULL; <nl>      if (sdl->mutex) <nl>          SDL_DestroyMutex(sdl->mutex); <nl> +    sdl->mutex = NULL; <nl>      if (sdl->init_cond) <nl>          SDL_DestroyCond(sdl->init_cond); <nl> +    sdl->init_cond = NULL; <nl>   <nl>      if (!sdl->sdl_was_already_inited) <nl>          SDL_Quit();
@@ -41,10 +41,10 @@ <nl>   <nl>  #define BE_16(x) ((((uint8_t*)(x))[0] <<  8) | ((uint8_t*)(x))[1]) <nl>   <nl> -#define BE_32(x) ((((uint8_t*)(x))[0] << 24) |  \ <nl> -                  (((uint8_t*)(x))[1] << 16) |  \ <nl> -                  (((uint8_t*)(x))[2] <<  8) |  \ <nl> -                   ((uint8_t*)(x))[3]) <nl> +#define BE_32(x) (((uint32_t)(((uint8_t*)(x))[0]) << 24) |  \ <nl> +                             (((uint8_t*)(x))[1]  << 16) |  \ <nl> +                             (((uint8_t*)(x))[2]  <<  8) |  \ <nl> +                              ((uint8_t*)(x))[3]) <nl>   <nl>  #define BE_64(x) (((uint64_t)(((uint8_t*)(x))[0]) << 56) |  \ <nl>                    ((uint64_t)(((uint8_t*)(x))[1]) << 48) |  \ <nl> @@ -123,7 +123,7 @@ int main(int argc, char *argv[]) <nl>          if (fread(atom_bytes, ATOM_PREAMBLE_SIZE, 1, infile) != 1) { <nl>              break; <nl>          } <nl> -        atom_size = (uint32_t) BE_32(&atom_bytes[0]); <nl> +        atom_size = BE_32(&atom_bytes[0]); <nl>          atom_type = BE_32(&atom_bytes[4]); <nl>   <nl>          /* keep ftyp atom */
@@ -103,6 +103,7 @@ av_cold int ff_mjpeg_decode_init(AVCodecContext *avctx) <nl>      s->first_picture = 1; <nl>      s->org_height    = avctx->coded_height; <nl>      avctx->chroma_sample_location = AVCHROMA_LOC_CENTER; <nl> +    avctx->colorspace = AVCOL_SPC_BT470BG; <nl>   <nl>      build_basic_mjpeg_vlc(s); <nl>  
@@ -157,10 +157,13 @@ static int xwd_decode_frame(AVCodecContext *avctx, void *data, <nl>      switch (vclass) { <nl>      case XWD_STATIC_GRAY: <nl>      case XWD_GRAY_SCALE: <nl> -        if (bpp != 1) <nl> +        if (bpp != 1 && bpp != 8) <nl>              return AVERROR_INVALIDDATA; <nl> -        if (pixdepth == 1) <nl> +        if (pixdepth == 1) { <nl>              avctx->pix_fmt = PIX_FMT_MONOWHITE; <nl> +        } else if (pixdepth == 8) { <nl> +            avctx->pix_fmt = PIX_FMT_GRAY8; <nl> +        } <nl>          break; <nl>      case XWD_STATIC_COLOR: <nl>      case XWD_PSEUDO_COLOR:
@@ -91,6 +91,12 @@ static int init(AVFilterContext *ctx, const char *args) <nl>      eval->class = &aevalsrc_class; <nl>      av_opt_set_defaults(eval); <nl>   <nl> +    if (!args1) { <nl> +        av_log(ctx, AV_LOG_ERROR, "Argument is empty\n"); <nl> +        ret = args ? AVERROR(ENOMEM) : AVERROR(EINVAL); <nl> +        goto end; <nl> +    } <nl> + <nl>      /* parse expressions */ <nl>      buf = args1; <nl>      i = 0;
@@ -216,7 +216,7 @@ static int RENAME(dct_quantize)(MpegEncContext *s, <nl>          "psubusw "MM"1, "MM"4               \n\t" <nl>          "packuswb "MM"4, "MM"4              \n\t" <nl>  #if COMPILE_TEMPLATE_SSE2 <nl> -        "packuswb "MM"4, "MM"4              \n\t" <nl> +        "packsswb "MM"4, "MM"4              \n\t" <nl>  #endif <nl>          "movd "MM"4, %0                     \n\t" // *overflow <nl>          : "=g" (*overflow)
@@ -274,6 +274,9 @@ static int cinepak_decode_strip (CinepakContext *s, <nl>      while ((data + 4) <= eod) { <nl>          chunk_id   = BE_16 (&data[0]); <nl>          chunk_size = BE_16 (&data[2]) - 4; <nl> +        if(chunk_size < 0) <nl> +            return -1; <nl> + <nl>          data      += 4; <nl>          chunk_size = ((data + chunk_size) > eod) ? (eod - data) : chunk_size; <nl>  
@@ -1196,7 +1196,7 @@ static int rtsp_read_packet(AVFormatContext *s, <nl>          break; <nl>      } <nl>      if (len < 0) <nl> -        return AVERROR(EIO); <nl> +        return len; <nl>      ret = rtp_parse_packet(rtsp_st->rtp_ctx, pkt, buf, len); <nl>      if (ret < 0) <nl>          goto redo;
@@ -216,6 +216,8 @@ static int cinvideo_decode_frame(AVCodecContext *avctx, <nl>      bitmap_frame_size = buf_size - 4; <nl>   <nl>      /* handle palette */ <nl> +    if (bitmap_frame_size < palette_colors_count * (3 + (palette_type != 0))) <nl> +        return AVERROR_INVALIDDATA; <nl>      if (palette_type == 0) { <nl>          for (i = 0; i < palette_colors_count; ++i) { <nl>              cin->palette[i] = bytestream_get_le24(&buf);
@@ -518,7 +518,7 @@ static int hds_write_packet(AVFormatContext *s, AVPacket *pkt) <nl>      HDSContext *c = s->priv_data; <nl>      AVStream *st = s->streams[pkt->stream_index]; <nl>      OutputStream *os = &c->streams[s->streams[pkt->stream_index]->id]; <nl> -    int64_t end_dts = (os->fragment_index) * c->min_frag_duration; <nl> +    int64_t end_dts = (os->fragment_index) * (int64_t)c->min_frag_duration; <nl>      int ret; <nl>   <nl>      if (st->first_dts == AV_NOPTS_VALUE)
@@ -1457,6 +1457,7 @@ static int asf_read_close(AVFormatContext *s) <nl>          av_dict_free(&asf->asf_sd[i].asf_met); <nl>      } <nl>   <nl> +    asf->nb_streams = 0; <nl>      return 0; <nl>  } <nl>  
@@ -90,6 +90,9 @@ static void mm_decode_intra(MmContext * s, int half_horiz, int half_vert, const <nl>      while(i<buf_size) { <nl>          int run_length, color; <nl>   <nl> +        if (y >= s->avctx->height) <nl> +            return; <nl> + <nl>          if (buf[i] & 0x80) { <nl>              run_length = 1; <nl>              color = buf[i]; <nl> @@ -138,6 +141,9 @@ static void mm_decode_inter(MmContext * s, int half_horiz, int half_vert, const <nl>              continue; <nl>          } <nl>   <nl> +        if (y + half_vert >= s->avctx->height) <nl> +            return; <nl> + <nl>          for(i=0; i<length; i++) { <nl>              for(j=0; j<8; j++) { <nl>                  int replace = (buf[r+i] >> (7-j)) & 1;
@@ -889,7 +889,7 @@ static int tak_decode_frame(AVCodecContext *avctx, void *data, <nl>              uint8_t *samples = (uint8_t *)frame->extended_data[chan]; <nl>              int32_t *decoded = s->decoded[chan]; <nl>              for (i = 0; i < s->nb_samples; i++) <nl> -                samples[i] = decoded[i] + 0x80; <nl> +                samples[i] = decoded[i] + 0x80U; <nl>          } <nl>          break; <nl>      case AV_SAMPLE_FMT_S16P:
@@ -86,7 +86,6 @@ static int sp5x_decode_frame(AVCodecContext *avctx, <nl>      recoded[j++] = 0xFF; <nl>      recoded[j++] = 0xD9; <nl>   <nl> -    avctx->flags &= ~CODEC_FLAG_EMU_EDGE; <nl>      av_init_packet(&avpkt_recoded); <nl>      avpkt_recoded.data = recoded; <nl>      avpkt_recoded.size = j; <nl> @@ -121,6 +120,6 @@ AVCodec ff_amv_decoder = { <nl>      NULL, <nl>      ff_mjpeg_decode_end, <nl>      sp5x_decode_frame, <nl> -    CODEC_CAP_DR1, <nl> +    0, <nl>      .long_name = NULL_IF_CONFIG_SMALL("AMV Video"), <nl>  };
@@ -435,6 +435,12 @@ static int compute_pkt_fields2(AVFormatContext *s, AVStream *st, AVPacket *pkt) <nl>      av_dlog(s, "compute_pkt_fields2: pts:%s dts:%s cur_dts:%s b:%d size:%d st:%d\n", <nl>              av_ts2str(pkt->pts), av_ts2str(pkt->dts), av_ts2str(st->cur_dts), delay, pkt->size, pkt->stream_index); <nl>   <nl> +    if (pkt->duration < 0 && st->codec->codec_type != AVMEDIA_TYPE_SUBTITLE) { <nl> +        av_log(s, AV_LOG_WARNING, "Packet with invalid duration %d in stream %d\n", <nl> +               pkt->duration, pkt->stream_index); <nl> +        pkt->duration = 0; <nl> +    } <nl> + <nl>      /* duration field */ <nl>      if (pkt->duration == 0) { <nl>          ff_compute_frame_duration(&num, &den, st, NULL, pkt);
@@ -572,7 +572,8 @@ static int asf_read_metadata_obj(AVFormatContext *s, const GUIDParseTable *g) <nl>                  if ((ret = process_metadata(s, name, name_len, val_len, type, <nl>                                              &asf->asf_sd[st_num].asf_met)) < 0) <nl>                      break; <nl> -            } <nl> +            } else <nl> +                av_freep(&name); <nl>          } <nl>      } <nl>  
@@ -497,6 +497,8 @@ int av_read_packet(AVFormatContext *s, AVPacket *pkt) <nl>      AVStream *st; <nl>      av_init_packet(pkt); <nl>      ret= s->iformat->read_packet(s, pkt); <nl> +    if (ret < 0) <nl> +        return ret; <nl>      st= s->streams[pkt->stream_index]; <nl>   <nl>      switch(st->codec->codec_type){
@@ -3185,6 +3185,7 @@ static int rtp_new_av_stream(HTTPContext *c, <nl>                 c->stream->feed->streams[c->stream->feed_streams[stream_index]], <nl>                 sizeof(AVStream)); <nl>      } <nl> +    st->priv_data = NULL; <nl>   <nl>      /* build destination RTP address */ <nl>      ipaddr = inet_ntoa(dest_addr->sin_addr);
@@ -1939,7 +1939,8 @@ static int decode_frame_mp3on4(AVCodecContext *avctx, void *data, <nl>   <nl>          avpriv_mpegaudio_decode_header((MPADecodeHeader *)m, header); <nl>   <nl> -        if (ch + m->nb_channels > avctx->channels) { <nl> +        if (ch + m->nb_channels > avctx->channels || <nl> +            s->coff[fr] + m->nb_channels > avctx->channels) { <nl>              av_log(avctx, AV_LOG_ERROR, "frame channel count exceeds codec " <nl>                                          "channel count\n"); <nl>              return AVERROR_INVALIDDATA;
@@ -429,7 +429,7 @@ static int handle_eac3(MOVMuxContext *mov, AVPacket *pkt, MOVTrack *track) <nl>   <nl>              if (hdr->substreamid == info->num_ind_sub + 1) { <nl>                  //info->num_ind_sub++; <nl> -                avpriv_request_sample(track->par, "Multiple independent substreams"); <nl> +                avpriv_request_sample(mov->fc, "Multiple independent substreams"); <nl>                  ret = AVERROR_PATCHWELCOME; <nl>                  goto end; <nl>              } else if (hdr->substreamid < info->num_ind_sub ||
@@ -59,7 +59,7 @@ static int vdpau_vc1_start_frame(AVCodecContext *avctx, <nl>      else <nl>          info->picture_type  = s->pict_type - 1 + s->pict_type / 3; <nl>   <nl> -    info->frame_coding_mode = v->fcm; <nl> +    info->frame_coding_mode = v->fcm ? v->fcm + 1 : 0; <nl>      info->postprocflag      = v->postprocflag; <nl>      info->pulldown          = v->broadcast; <nl>      info->interlace         = v->interlace;
@@ -1762,7 +1762,7 @@ int avformat_seek_file(AVFormatContext *s, int stream_index, int64_t min_ts, int <nl>      //Fallback to old API if new is not implemented but old is <nl>      //Note the old has somewat different sematics <nl>      if(s->iformat->read_seek || 1) <nl> -        return av_seek_frame(s, stream_index, ts, flags | (ts - min_ts > (uint64_t)(max_ts - ts) ? AVSEEK_FLAG_BACKWARD : 0)); <nl> +        return av_seek_frame(s, stream_index, ts, flags | ((uint64_t)ts - min_ts > (uint64_t)max_ts - ts ? AVSEEK_FLAG_BACKWARD : 0)); <nl>   <nl>      // try some generic seek like seek_frame_generic() but with new ts semantics <nl>  }
@@ -266,6 +266,8 @@ static int qdm2_parse_packet(AVFormatContext *s, PayloadContext *qdm, <nl>               * to the decoder that it is OK to initialize. */ <nl>              st->codec->codec_id = CODEC_ID_QDM2; <nl>          } <nl> +        if (st->codec->codec_id == CODEC_ID_NONE) <nl> +            return AVERROR(EAGAIN); <nl>   <nl>          /* subpackets */ <nl>          while (end - p >= 4) {
@@ -122,7 +122,7 @@ int ff_raw_read_partial_packet(AVFormatContext *s, AVPacket *pkt) <nl>          av_free_packet(pkt); <nl>          return ret; <nl>      } <nl> -    pkt->size = ret; <nl> +    av_shrink_packet(pkt, ret); <nl>      return ret; <nl>  } <nl>  
@@ -1071,7 +1071,8 @@ static int tiff_decode_tag(TiffContext *s, AVFrame *frame) <nl>              s->geotag_count = count / 4 - 1; <nl>              av_log(s->avctx, AV_LOG_WARNING, "GeoTIFF key directory buffer shorter than specified\n"); <nl>          } <nl> -        if (bytestream2_get_bytes_left(&s->gb) < s->geotag_count * sizeof(int16_t) * 4) { <nl> +        if (   bytestream2_get_bytes_left(&s->gb) < s->geotag_count * sizeof(int16_t) * 4 <nl> +            || s->geotag_count == 0) { <nl>              s->geotag_count = 0; <nl>              return -1; <nl>          }
@@ -438,6 +438,7 @@ static const AVCodecTag mp4_audio_types[] = { <nl>  int ff_mp4_read_dec_config_descr(AVFormatContext *fc, AVStream *st, AVIOContext *pb) <nl>  { <nl>      int len, tag; <nl> +    int ret; <nl>      int object_type_id = avio_r8(pb); <nl>      avio_r8(pb); /* stream type */ <nl>      avio_rb24(pb); /* buffer size db */ <nl> @@ -459,7 +460,8 @@ int ff_mp4_read_dec_config_descr(AVFormatContext *fc, AVStream *st, AVIOContext <nl>          av_free(st->codec->extradata); <nl>          if (ff_alloc_extradata(st->codec, len)) <nl>              return AVERROR(ENOMEM); <nl> -        avio_read(pb, st->codec->extradata, len); <nl> +        if ((ret = avio_read(pb, st->codec->extradata, len)) != len) <nl> +            return ret < 0 ? ret : AVERROR_INVALIDDATA; <nl>          if (st->codec->codec_id == AV_CODEC_ID_AAC) { <nl>              MPEG4AudioConfig cfg = {0}; <nl>              avpriv_mpeg4audio_get_config(&cfg, st->codec->extradata,
@@ -147,15 +147,16 @@ static int roq_dpcm_encode_frame(AVCodecContext *avctx, AVPacket *avpkt, <nl>              context->input_frames++; <nl>              return 0; <nl>          } <nl> -        in = context->frame_buffer; <nl>      } <nl> +    if (context->input_frames < 8) <nl> +        in = context->frame_buffer; <nl>   <nl>      if (stereo) { <nl>          context->lastSample[0] &= 0xFF00; <nl>          context->lastSample[1] &= 0xFF00; <nl>      } <nl>   <nl> -    if (context->input_frames == 7 || !in) <nl> +    if (context->input_frames == 7) <nl>          data_size = avctx->channels * context->buffered_samples; <nl>      else <nl>          data_size = avctx->channels * avctx->frame_size;
@@ -369,6 +369,10 @@ static inline uint64_t get_bits64(GetBitContext *s, int n) <nl>   */ <nl>  static inline int get_sbits_long(GetBitContext *s, int n) <nl>  { <nl> +    // sign_extend(x, 0) is undefined <nl> +    if (!n) <nl> +        return 0; <nl> + <nl>      return sign_extend(get_bits_long(s, n), n); <nl>  } <nl>  
@@ -94,8 +94,8 @@ typedef struct RTMPContext { <nl>      int           flv_nb_packets;             ///< number of flv packets published <nl>      RTMPPacket    out_pkt;                    ///< rtmp packet, created from flv a/v or metadata (for output) <nl>      uint32_t      client_report_size;         ///< number of bytes after which client should report to server <nl> -    uint32_t      bytes_read;                 ///< number of bytes read from server <nl> -    uint32_t      last_bytes_read;            ///< number of bytes read last reported to server <nl> +    uint64_t      bytes_read;                 ///< number of bytes read from server <nl> +    uint64_t      last_bytes_read;            ///< number of bytes read last reported to server <nl>      uint32_t      last_timestamp;             ///< last timestamp received in a packet <nl>      int           skip_bytes;                 ///< number of bytes to skip from the input FLV stream in the next write call <nl>      int           has_audio;                  ///< presence of audio data
@@ -111,7 +111,10 @@ static inline av_const SoftFloat av_mul_sf(SoftFloat a, SoftFloat b){ <nl>  static inline av_const SoftFloat av_div_sf(SoftFloat a, SoftFloat b){ <nl>      a.exp -= b.exp; <nl>      a.mant = ((int64_t)a.mant<<(ONE_BITS+1)) / b.mant; <nl> -    return av_normalize1_sf(a); <nl> +    a = av_normalize1_sf(a); <nl> +    if (!a.mant || a.exp < MIN_EXP) <nl> +        return FLOAT_0; <nl> +    return a; <nl>  } <nl>   <nl>  static inline av_const int av_cmp_sf(SoftFloat a, SoftFloat b){
@@ -88,7 +88,7 @@ typedef struct AMRContext { <nl>  } AMRContext; <nl>   <nl>  static const AVOption options[] = { <nl> -    { "dtx", "Allow DTX (generate comfort noise)", offsetof(AMRContext, enc_dtx), FF_OPT_TYPE_INT, 0, 0, 1, AV_OPT_FLAG_AUDIO_PARAM | AV_OPT_FLAG_ENCODING_PARAM }, <nl> +    { "dtx", "Allow DTX (generate comfort noise)", offsetof(AMRContext, enc_dtx), FF_OPT_TYPE_INT, { 0 }, 0, 1, AV_OPT_FLAG_AUDIO_PARAM | AV_OPT_FLAG_ENCODING_PARAM }, <nl>      { NULL } <nl>  }; <nl>  
@@ -569,7 +569,7 @@ static int read_extra_header(FFV1Context *f) <nl>      } <nl>   <nl>      f->quant_table_count = get_symbol(c, state, 0); <nl> -    if (f->quant_table_count > (unsigned)MAX_QUANT_TABLES) <nl> +    if (f->quant_table_count > (unsigned)MAX_QUANT_TABLES || !f->quant_table_count) <nl>          return AVERROR_INVALIDDATA; <nl>   <nl>      for (i = 0; i < f->quant_table_count; i++) {
@@ -116,8 +116,7 @@ static int codec_reinit(AVCodecContext *avctx, int width, int height, int qualit <nl>              return 0; <nl>          avctx->width = c->width = width; <nl>          avctx->height = c->height = height; <nl> -        c->decomp_size = c->height * c->width * 3 / 2; <nl> -        c->decomp_buf = av_realloc(c->decomp_buf, c->decomp_size + AV_LZO_OUTPUT_PADDING); <nl> +        av_fast_malloc(&c->decomp_buf, &c->decomp_size, c->height * c->width * 3 / 2); <nl>          if (!c->decomp_buf) { <nl>              av_log(avctx, AV_LOG_ERROR, "Can't allocate decompression buffer.\n"); <nl>              return 0;
@@ -426,8 +426,8 @@ static av_always_inline int small_diamond_search(MpegEncContext * s, int *best, <nl>      chroma_cmpf = s->mecc.me_cmp[size + 1]; <nl>   <nl>      { /* ensure that the best point is in the MAP as h/qpel refinement needs it */ <nl> -        const unsigned key = (best[1]<<ME_MAP_MV_BITS) + best[0] + map_generation; <nl> -        const int index= ((best[1]<<ME_MAP_SHIFT) + best[0])&(ME_MAP_SIZE-1); <nl> +        const unsigned key = ((unsigned)best[1]<<ME_MAP_MV_BITS) + best[0] + map_generation; <nl> +        const int index= (((unsigned)best[1]<<ME_MAP_SHIFT) + best[0])&(ME_MAP_SIZE-1); <nl>          if(map[index]!=key){ //this will be executed only very rarey <nl>              score_map[index]= cmp(s, best[0], best[1], 0, 0, size, h, ref_index, src_index, cmpf, chroma_cmpf, flags); <nl>              map[index]= key;
@@ -562,7 +562,7 @@ static void expand_filename_template(AVBPrint *bp, const char *template, <nl>   <nl>  static int init_report(const char *env) <nl>  { <nl> -    const char *filename_template = "%p-%t.log"; <nl> +    char *filename_template = NULL; <nl>      char *key, *val; <nl>      int ret, count = 0; <nl>      time_t now; <nl> @@ -586,6 +586,7 @@ static int init_report(const char *env) <nl>              env++; <nl>          count++; <nl>          if (!strcmp(key, "file")) { <nl> +            av_free(filename_template); <nl>              filename_template = val; <nl>              val = NULL; <nl>          } else { <nl> @@ -596,7 +597,9 @@ static int init_report(const char *env) <nl>      } <nl>   <nl>      av_bprint_init(&filename, 0, 1); <nl> -    expand_filename_template(&filename, filename_template, tm); <nl> +    expand_filename_template(&filename, <nl> +                             av_x_if_null(filename_template, "%p-%t.log"), tm); <nl> +    av_free(filename_template); <nl>      if (!av_bprint_is_complete(&filename)) { <nl>          av_log(NULL, AV_LOG_ERROR, "Out of memory building report file name\n"); <nl>          return AVERROR(ENOMEM);
@@ -1355,7 +1355,7 @@ static void FUNC(put_hevc_epel_bi_w_h)(uint8_t *_dst, ptrdiff_t _dststride, uint <nl>      for (y = 0; y < height; y++) { <nl>          for (x = 0; x < width; x++) <nl>              dst[x] = av_clip_pixel(((EPEL_FILTER(src, 1) >> (BIT_DEPTH - 8)) * wx1 + src2[x] * wx0 + <nl> -                                    ((ox0 + ox1 + 1) << log2Wd)) >> (log2Wd + 1)); <nl> +                                    ((ox0 + ox1 + 1) * (1 << log2Wd))) >> (log2Wd + 1)); <nl>          src  += srcstride; <nl>          dst  += dststride; <nl>          src2 += MAX_PB_SIZE;
@@ -703,7 +703,7 @@ av_cold void ff_snow_common_end(SnowContext *s) <nl>      for(i=0; i<MAX_REF_FRAMES; i++){ <nl>          av_freep(&s->ref_mvs[i]); <nl>          av_freep(&s->ref_scores[i]); <nl> -        if(s->last_picture[i]->data[0]) { <nl> +        if(s->last_picture[i] && s->last_picture[i]->data[0]) { <nl>              av_assert0(s->last_picture[i]->data[0] != s->current_picture->data[0]); <nl>          } <nl>          av_frame_free(&s->last_picture[i]);
@@ -78,7 +78,7 @@ static int extract_extradata_h2645(AVBSFContext *ctx, AVPacket *pkt, <nl>      ret = ff_h2645_packet_split(&h2645_pkt, pkt->data, pkt->size, <nl>                                  ctx, 0, 0, ctx->par_in->codec_id, 1); <nl>      if (ret < 0) <nl> -        return ret; <nl> +        goto fail; <nl>   <nl>      for (i = 0; i < h2645_pkt.nb_nals; i++) { <nl>          H2645NAL *nal = &h2645_pkt.nals[i];
@@ -81,7 +81,7 @@ static int rtp_write_header(AVFormatContext *s1) <nl>          } <nl>          if (st->codec->codec_type == CODEC_TYPE_VIDEO) { <nl>              /* FIXME: We should round down here... */ <nl> -            s->max_frames_per_packet = av_rescale_q(s1->max_delay, AV_TIME_BASE_Q, st->codec->time_base); <nl> +            s->max_frames_per_packet = av_rescale_q(s1->max_delay, (AVRational){1, 1000000}, st->codec->time_base); <nl>          } <nl>      } <nl>   <nl> @@ -126,7 +126,7 @@ static void rtcp_send_sr(AVFormatContext *s1, int64_t ntp_time) <nl>   <nl>      if (s->first_rtcp_ntp_time == AV_NOPTS_VALUE) s->first_rtcp_ntp_time = ntp_time; <nl>      s->last_rtcp_ntp_time = ntp_time; <nl> -    rtp_ts = av_rescale_q(ntp_time - s->first_rtcp_ntp_time, AV_TIME_BASE_Q, <nl> +    rtp_ts = av_rescale_q(ntp_time - s->first_rtcp_ntp_time, (AVRational){1, 1000000}, <nl>                            s1->streams[0]->time_base) + s->base_timestamp; <nl>      put_byte(s1->pb, (RTP_VERSION << 6)); <nl>      put_byte(s1->pb, 200);
@@ -4246,7 +4246,8 @@ static void vc1_decode_b_mb_intfi(VC1Context *v) <nl>      int fwd; <nl>      int dmv_x[2], dmv_y[2], pred_flag[2]; <nl>      int bmvtype = BMV_TYPE_BACKWARD; <nl> -    int idx_mbmode, interpmvp; <nl> +    int idx_mbmode; <nl> +    int av_uninit(interpmvp); <nl>   <nl>      mquant      = v->pq; /* Lossy initialization */ <nl>      s->mb_intra = 0;
@@ -205,7 +205,8 @@ static void decode_mb(MadContext *t, int inter) <nl>      for (j=0; j<6; j++) { <nl>          if (mv_map & (1<<j)) {  // mv_x and mv_y are guarded by mv_map <nl>              int add = 2*decode_motion(&s->gb); <nl> -            comp_block(t, s->mb_x, s->mb_y, j, mv_x, mv_y, add); <nl> +            if (t->last_frame.data[0]) <nl> +                comp_block(t, s->mb_x, s->mb_y, j, mv_x, mv_y, add); <nl>          } else { <nl>              s->dsp.clear_block(t->block); <nl>              decode_block_intra(t, t->block);
@@ -110,7 +110,7 @@ static av_cold int init(AVFilterContext *ctx) <nl>  { <nl>      InterleaveContext *s = ctx->priv; <nl>      const AVFilterPad *outpad = &ctx->filter->outputs[0]; <nl> -    int i; <nl> +    int i, ret; <nl>   <nl>      s->queues = av_calloc(s->nb_inputs, sizeof(s->queues[0])); <nl>      if (!s->queues) <nl> @@ -133,7 +133,10 @@ static av_cold int init(AVFilterContext *ctx) <nl>          default: <nl>              av_assert0(0); <nl>          } <nl> -        ff_insert_inpad(ctx, i, &inpad); <nl> +        if ((ret = ff_insert_inpad(ctx, i, &inpad)) < 0) { <nl> +            av_freep(&inpad.name); <nl> +            return ret; <nl> +        } <nl>      } <nl>   <nl>      return 0;
@@ -243,7 +243,7 @@ static int seek_test(const char *input_filename, const char *start, const char * <nl>          return AVERROR(ENOMEM); <nl>      } <nl>   <nl> -    result = compute_crc_of_packets(fmt_ctx, video_stream, ctx, fr, i, j, 1); <nl> +    result = compute_crc_of_packets(fmt_ctx, video_stream, ctx, fr, 0, 0, 1); <nl>      if (result != 0) <nl>          return -1; <nl>  
@@ -494,7 +494,7 @@ void ff_formats_changeref(AVFilterFormats **oldref, AVFilterFormats **newref) <nl>  } <nl>   <nl>  #define SET_COMMON_FORMATS(ctx, fmts, in_fmts, out_fmts, ref, list) \ <nl> -{                                                                   \ <nl> +if (fmts) {                                                         \ <nl>      int count = 0, i;                                               \ <nl>                                                                      \ <nl>      for (i = 0; i < ctx->nb_inputs; i++) {                          \
@@ -1153,7 +1153,7 @@ static int mjpeg_decode_scan(MJpegDecodeContext *s, int nb_components, int Ah, <nl>      uint8_t *data[MAX_COMPONENTS]; <nl>      const uint8_t *reference_data[MAX_COMPONENTS]; <nl>      int linesize[MAX_COMPONENTS]; <nl> -    GetBitContext mb_bitmask_gb; <nl> +    GetBitContext mb_bitmask_gb = {0}; // initialize to silence gcc warning <nl>      int bytes_per_pixel = 1 + (s->bits > 8); <nl>   <nl>      if (mb_bitmask) {
@@ -419,7 +419,7 @@ static int join_request_frame(AVFilterLink *outlink) <nl>      JoinBufferPriv *priv; <nl>      int linesize   = INT_MAX; <nl>      int perms      = ~0; <nl> -    int nb_samples; <nl> +    int nb_samples = 0; <nl>      int i, j, ret; <nl>   <nl>      /* get a frame on each input */ <nl> @@ -448,6 +448,7 @@ static int join_request_frame(AVFilterLink *outlink) <nl>          perms     &= cur_buf->perms; <nl>      } <nl>   <nl> +    av_assert0(nb_samples > 0); <nl>      buf = avfilter_get_audio_buffer_ref_from_arrays(s->data, linesize, perms, <nl>                                                      nb_samples, outlink->format, <nl>                                                      outlink->channel_layout);
@@ -658,7 +658,8 @@ static int rm_assemble_video_frame(AVFormatContext *s, AVIOContext *pb, <nl>                                     AVPacket *pkt, int len, int *pseq, <nl>                                     int64_t *timestamp) <nl>  { <nl> -    int hdr, seq, pic_num, len2, pos; <nl> +    int hdr; <nl> +    int seq = 0, pic_num = 0, len2 = 0, pos = 0; //init to silcense compiler warning <nl>      int type; <nl>   <nl>      hdr = avio_r8(pb); len--; <nl> @@ -874,7 +875,7 @@ ff_rm_retrieve_cache (AVFormatContext *s, AVIOContext *pb, <nl>  static int rm_read_packet(AVFormatContext *s, AVPacket *pkt) <nl>  { <nl>      RMDemuxContext *rm = s->priv_data; <nl> -    AVStream *st; <nl> +    AVStream *st = NULL; // init to silence compiler warning <nl>      int i, len, res, seq = 1; <nl>      int64_t timestamp, pos; <nl>      int flags;
@@ -165,7 +165,7 @@ static int filter_frame(AVFilterLink *inlink, AVFrame *in) <nl>      const int H = s->histogram_h; <nl>      const int w = s->w; <nl>      int c, y, n, p, bin; <nl> -    uint64_t acmax = 0; <nl> +    uint64_t acmax = 1; <nl>   <nl>      if (!s->out || s->out->width  != outlink->w || <nl>                     s->out->height != outlink->h) {
@@ -2018,17 +2018,19 @@ static int vp3_decode_frame(AVCodecContext *avctx, <nl>              vp3_decode_end(avctx); <nl>              ret = theora_decode_header(avctx, &gb); <nl>   <nl> +            if (ret >= 0) <nl> +                ret = vp3_decode_init(avctx); <nl>              if (ret < 0) { <nl>                  vp3_decode_end(avctx); <nl> -            } else <nl> -                ret = vp3_decode_init(avctx); <nl> +            } <nl>              return ret; <nl>          } else if (type == 2) { <nl>              ret = theora_decode_tables(avctx, &gb); <nl> +            if (ret >= 0) <nl> +                ret = vp3_decode_init(avctx); <nl>              if (ret < 0) { <nl>                  vp3_decode_end(avctx); <nl> -            } else <nl> -                ret = vp3_decode_init(avctx); <nl> +            } <nl>              return ret; <nl>          } <nl>  
@@ -316,7 +316,7 @@ static int buffer_needs_copy(PadContext *s, AVFrame *frame, AVBufferRef *buf) <nl>              return 1; <nl>   <nl>  #define SIGN(x) ((x) > 0 ? 1 : -1) <nl> -        for (j = 0; j < FF_ARRAY_ELEMS(planes) & planes[j] >= 0; j++) { <nl> +        for (j = 0; j < FF_ARRAY_ELEMS(planes) && planes[j] >= 0; j++) { <nl>              int hsub1 = (planes[j] == 1 || planes[j] == 2) ? s->hsub : 0; <nl>              uint8_t *start1 = frame->data[planes[j]]; <nl>              uint8_t *end1   = start1 + (frame->height >> hsub1) *
@@ -864,6 +864,10 @@ static int asf_read_frame_header(AVFormatContext *s, AVIOContext *pb){ <nl>          } <nl>          //printf("Fragsize %d\n", asf->packet_frag_size); <nl>      } else { <nl> +        if (rsize > asf->packet_size_left) { <nl> +            av_log(s, AV_LOG_ERROR, "packet_replic_size is invalid\n"); <nl> +            return -1; <nl> +        } <nl>          asf->packet_frag_size = asf->packet_size_left - rsize; <nl>          //printf("Using rest  %d %d %d\n", asf->packet_frag_size, asf->packet_size_left, rsize); <nl>      }
@@ -553,13 +553,16 @@ static int decode_frame_ilbm(AVCodecContext *avctx, <nl>                  memcpy(row, buf, FFMIN(avctx->width, buf_end - buf)); <nl>                  buf += avctx->width + (avctx->width % 2); // padding if odd <nl>              } <nl> -        } else { // IFF-PBM: HAM to PIX_FMT_BGR32 <nl> +        } else if (s->ham) { // IFF-PBM: HAM to PIX_FMT_BGR32 <nl>              for (y = 0; y < avctx->height; y++) { <nl>                  uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ]; <nl>                  memcpy(s->ham_buf, buf, FFMIN(avctx->width, buf_end - buf)); <nl>                  buf += avctx->width + (avctx->width & 1); // padding if odd <nl>                  decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize); <nl>              } <nl> +        } else { <nl> +            av_log_ask_for_sample(avctx, "unsupported bpp\n"); <nl> +            return AVERROR_INVALIDDATA; <nl>          } <nl>      } <nl>  
@@ -719,7 +719,8 @@ static int create_filtergraph(AVFilterContext *ctx, <nl>      s->yuv2yuv_fastmode = s->rgb2rgb_passthrough && fmt_identical; <nl>      s->yuv2yuv_passthrough = s->yuv2yuv_fastmode && s->in_rng == s->out_rng && <nl>                               !memcmp(s->in_lumacoef, s->out_lumacoef, <nl> -                                     sizeof(*s->in_lumacoef)); <nl> +                                     sizeof(*s->in_lumacoef)) && <nl> +                             in_desc->comp[0].depth == out_desc->comp[0].depth; <nl>      if (!s->yuv2yuv_passthrough) { <nl>          if (redo_yuv2rgb) { <nl>              double rgb2yuv[3][3], (*yuv2rgb)[3] = s->yuv2rgb_dbl_coeffs; <nl> @@ -937,7 +938,9 @@ static int filter_frame(AVFilterLink *link, AVFrame *in) <nl>      td.in_ss_h = av_pix_fmt_desc_get(in->format)->log2_chroma_h; <nl>      td.out_ss_h = av_pix_fmt_desc_get(out->format)->log2_chroma_h; <nl>      if (s->yuv2yuv_passthrough) { <nl> -        av_frame_copy(out, in); <nl> +        res = av_frame_copy(out, in); <nl> +        if (res < 0) <nl> +            return res; <nl>      } else { <nl>          ctx->internal->execute(ctx, convert, &td, NULL, <nl>                                 FFMIN((in->height + 1) >> 1, ctx->graph->nb_threads));
@@ -650,6 +650,9 @@ static int avi_read_packet(AVFormatContext *s, AVPacket *pkt) <nl>                  best_stream_index= i; <nl>              } <nl>          } <nl> +        if(!best_st) <nl> +            return -1; <nl> + <nl>          best_ast = best_st->priv_data; <nl>          best_ts= av_rescale(best_ts, best_st->time_base.den, AV_TIME_BASE * (int64_t)best_st->time_base.num); //FIXME a little ugly <nl>          if(best_ast->remaining)
@@ -182,7 +182,7 @@ FF_ENABLE_DEPRECATION_WARNINGS <nl>   <nl>                  if (mxg->soi_ptr - mxg->buffer > mxg->cache_size) { <nl>                      if (mxg->cache_size > 0) { <nl> -                        memcpy(mxg->buffer, mxg->buffer_ptr, mxg->cache_size); <nl> +                        memmove(mxg->buffer, mxg->buffer_ptr, mxg->cache_size); <nl>                      } <nl>   <nl>                      mxg->buffer_ptr = mxg->buffer;
@@ -367,7 +367,7 @@ static enum AVPixelFormat get_format(HEVCContext *s, const HEVCSPS *sps) <nl>      *fmt++ = sps->pix_fmt; <nl>      *fmt = AV_PIX_FMT_NONE; <nl>   <nl> -    return ff_get_format(s->avctx, pix_fmts); <nl> +    return ff_thread_get_format(s->avctx, pix_fmts); <nl>  } <nl>   <nl>  static int set_sps(HEVCContext *s, const HEVCSPS *sps,
@@ -198,10 +198,16 @@ static void selfTest(uint8_t *ref[4], int refStride[4], int w, int h) <nl>      enum PixelFormat srcFormat, dstFormat; <nl>   <nl>      for (srcFormat = 0; srcFormat < PIX_FMT_NB; srcFormat++) { <nl> +        if (!sws_isSupportedInput(srcFormat)) <nl> +            continue; <nl> + <nl>          for (dstFormat = 0; dstFormat < PIX_FMT_NB; dstFormat++) { <nl>              int i, j, k; <nl>              int res = 0; <nl>   <nl> +            if (!sws_isSupportedOutput(dstFormat)) <nl> +                continue; <nl> + <nl>              printf("%s -> %s\n", <nl>                     sws_format_name(srcFormat), <nl>                     sws_format_name(dstFormat));
@@ -195,6 +195,8 @@ static int query_formats(AVFilterContext *ctx) <nl>          main_formats    = ff_make_format_list(main_pix_fmts_rgb); <nl>          overlay_formats = ff_make_format_list(overlay_pix_fmts_rgb); <nl>          break; <nl> +    default: <nl> +        av_assert0(0); <nl>      } <nl>   <nl>      ff_formats_ref(main_formats,    &ctx->inputs [MAIN   ]->out_formats);
@@ -656,7 +656,6 @@ static int udp_close(URLContext *h) <nl>      if (s->is_multicast && (h->flags & AVIO_FLAG_READ)) <nl>          udp_leave_multicast_group(s->udp_fd, (struct sockaddr *)&s->dest_addr); <nl>      closesocket(s->udp_fd); <nl> -    av_fifo_free(s->fifo); <nl>  #if HAVE_PTHREAD_CANCEL <nl>      if (s->thread_started) { <nl>          pthread_cancel(s->circular_buffer_thread); <nl> @@ -668,6 +667,7 @@ static int udp_close(URLContext *h) <nl>      pthread_mutex_destroy(&s->mutex); <nl>      pthread_cond_destroy(&s->cond); <nl>  #endif <nl> +    av_fifo_free(s->fifo); <nl>      return 0; <nl>  } <nl>  
@@ -184,8 +184,10 @@ static int compand_nodelay(AVFilterContext *ctx, AVFrame *frame) <nl>          out_frame = frame; <nl>      } else { <nl>          out_frame = ff_get_audio_buffer(inlink, nb_samples); <nl> -        if (!out_frame) <nl> +        if (!out_frame) { <nl> +            av_frame_free(&frame); <nl>              return AVERROR(ENOMEM); <nl> +        } <nl>          av_frame_copy_props(out_frame, frame); <nl>      } <nl>   <nl> @@ -235,8 +237,10 @@ static int compand_delay(AVFilterContext *ctx, AVFrame *frame) <nl>              if (count >= s->delay_samples) { <nl>                  if (!out_frame) { <nl>                      out_frame = ff_get_audio_buffer(inlink, nb_samples - i); <nl> -                    if (!out_frame) <nl> +                    if (!out_frame) { <nl> +                        av_frame_free(&frame); <nl>                          return AVERROR(ENOMEM); <nl> +                    } <nl>                      av_frame_copy_props(out_frame, frame); <nl>                      out_frame->pts = s->pts; <nl>                      s->pts += av_rescale_q(nb_samples - i, (AVRational){1, inlink->sample_rate}, inlink->time_base);
@@ -1351,6 +1351,9 @@ static int vp8_lossy_decode_frame(AVCodecContext *avctx, AVFrame *p, <nl>      ret = ff_vp8_decode_frame(avctx, p, got_frame, &pkt); <nl>      if (ret < 0) <nl>          return ret; <nl> + <nl> +    update_canvas_size(avctx, avctx->width, avctx->height); <nl> + <nl>      if (s->has_alpha) { <nl>          ret = vp8_lossy_decode_alpha(avctx, p, s->alpha_data, <nl>                                       s->alpha_data_size);
@@ -333,7 +333,7 @@ int ff_h2645_packet_split(H2645Packet *pkt, const uint8_t *buf, int length, <nl>              ret = hevc_parse_nal_header(nal, logctx); <nl>          else <nl>              ret = h264_parse_nal_header(nal, logctx); <nl> -        if (ret <= 0) { <nl> +        if (ret <= 0 || nal->size <= 0) { <nl>              if (ret < 0) { <nl>                  av_log(logctx, AV_LOG_ERROR, "Invalid NAL unit %d, skipping.\n", <nl>                         nal->type);
@@ -527,6 +527,8 @@ static void ffmpeg_cleanup(int ret) <nl>          av_freep(&ost->audio_channels_map); <nl>          ost->audio_channels_mapped = 0; <nl>   <nl> +        av_dict_free(&ost->sws_dict); <nl> + <nl>          avcodec_free_context(&ost->enc_ctx); <nl>   <nl>          av_freep(&output_streams[i]);
@@ -424,6 +424,8 @@ static int filter_packet(void *log_ctx, AVPacket *pkt, <nl>          } <nl>   <nl>          if (ret > 0) { <nl> +            pkt->side_data = NULL; <nl> +            pkt->side_data_elems = 0; <nl>              av_packet_unref(pkt); <nl>              new_pkt.buf = av_buffer_create(new_pkt.data, new_pkt.size, <nl>                                             av_buffer_default_free, NULL, 0);
@@ -154,19 +154,22 @@ static void final(const short *i1, const short *i2, <nl>   <nl>      for (i=0; i<len; i++) { <nl>          int sum = 0; <nl> +        int new_val; <nl>   <nl>          for(x=0; x<10; x++) <nl>              sum += i1[9-x] * ptr[x]; <nl>   <nl>          sum >>= 12; <nl>   <nl> -        if (ptr[10] - sum < -32768 || ptr[10] - sum > 32767) { <nl> +        new_val = ptr[10] - sum; <nl> + <nl> +        if (new_val < -32768 || new_val > 32767) { <nl>              memset(out, 0, len * 2); <nl>              memset(statbuf, 0, 20); <nl>              return; <nl>          } <nl>   <nl> -        ptr[10] -= sum; <nl> +        ptr[10] = new_val; <nl>          ptr++; <nl>      } <nl>  
@@ -1102,8 +1102,10 @@ end: <nl>  free_and_end: <nl>      av_dict_free(&tmp); <nl>      av_freep(&avctx->priv_data); <nl> -    if (avctx->internal) <nl> +    if (avctx->internal) { <nl> +        av_frame_free(&avctx->internal->to_free); <nl>          av_freep(&avctx->internal->pool); <nl> +    } <nl>      av_freep(&avctx->internal); <nl>      avctx->codec = NULL; <nl>      goto end;
@@ -519,7 +519,7 @@ static int decode_mb_info(IVI4DecContext *ctx, IVIBandDesc *band, <nl>                  } <nl>   <nl>                  mb->mv_x = mb->mv_y = 0; /* no motion vector coded */ <nl> -                if (band->inherit_mv) { <nl> +                if (band->inherit_mv && ref_mb) { <nl>                      /* motion vector inheritance */ <nl>                      if (mv_scale) { <nl>                          mb->mv_x = ivi_scale_mv(ref_mb->mv_x, mv_scale); <nl> @@ -553,7 +553,7 @@ static int decode_mb_info(IVI4DecContext *ctx, IVIBandDesc *band, <nl>                  if (!mb->type) { <nl>                      mb->mv_x = mb->mv_y = 0; /* there is no motion vector in intra-macroblocks */ <nl>                  } else { <nl> -                    if (band->inherit_mv) { <nl> +                    if (band->inherit_mv && ref_mb) { <nl>                          /* motion vector inheritance */ <nl>                          if (mv_scale) { <nl>                              mb->mv_x = ivi_scale_mv(ref_mb->mv_x, mv_scale);
@@ -21,6 +21,7 @@ <nl>   <nl>  #include "avcodec.h" <nl>  #include "bytestream.h" <nl> +#include "libavutil/avassert.h" <nl>   <nl>  enum BMVFlags{ <nl>      BMV_NOP = 0, <nl> @@ -52,7 +53,7 @@ typedef struct BMVDecContext { <nl>   <nl>  static int decode_bmv_frame(const uint8_t *source, int src_len, uint8_t *frame, int frame_off) <nl>  { <nl> -    int val, saved_val = 0; <nl> +    unsigned val, saved_val = 0; <nl>      int tmplen = src_len; <nl>      const uint8_t *src, *source_end = source + src_len; <nl>      uint8_t *frame_end = frame + SCREEN_WIDE * SCREEN_HIGH; <nl> @@ -98,6 +99,8 @@ static int decode_bmv_frame(const uint8_t *source, int src_len, uint8_t *frame, <nl>          } <nl>          if (!(val & 0xC)) { <nl>              for (;;) { <nl> +                if(shift>22) <nl> +                    return -1; <nl>                  if (!read_two_nibbles) { <nl>                      if (src < source || src >= source_end) <nl>                          return -1; <nl> @@ -131,6 +134,7 @@ static int decode_bmv_frame(const uint8_t *source, int src_len, uint8_t *frame, <nl>          } <nl>          advance_mode = val & 1; <nl>          len = (val >> 1) - 1; <nl> +        av_assert0(len>0); <nl>          mode += 1 + advance_mode; <nl>          if (mode >= 4) <nl>              mode -= 3;
@@ -3454,7 +3454,7 @@ unsigned int avpriv_toupper4(unsigned int x) <nl>      return av_toupper(x & 0xFF) + <nl>            (av_toupper((x >>  8) & 0xFF) << 8)  + <nl>            (av_toupper((x >> 16) & 0xFF) << 16) + <nl> -          (av_toupper((x >> 24) & 0xFF) << 24); <nl> +((unsigned)av_toupper((x >> 24) & 0xFF) << 24); <nl>  } <nl>   <nl>  int ff_thread_ref_frame(ThreadFrame *dst, ThreadFrame *src)
@@ -249,7 +249,11 @@ static int analyze_chunk(AVFormatContext *s, const uint8_t *chunk) <nl>       * in MPEG packets to determine tivo_type */ <nl>      if (ty->tivo_type == TIVO_TYPE_UNKNOWN) { <nl>          uint32_t data_offset = 16 * num_recs; <nl> + <nl>          for (i = 0; i < num_recs; i++) { <nl> +            if (data_offset + hdrs[i].rec_size > CHUNK_SIZE) <nl> +                break; <nl> + <nl>              if ((hdrs[i].subrec_type << 0x08 | hdrs[i].rec_type) == 0x3c0 && hdrs[i].rec_size > 15) { <nl>                  /* first make sure we're aligned */ <nl>                  int pes_offset = find_es_header(ty_MPEGAudioPacket,
@@ -943,13 +943,7 @@ static int video_open(VideoState *is){ <nl>      if(screen && is->width == screen->w && screen->w == w <nl>         && is->height== screen->h && screen->h == h) <nl>          return 0; <nl> - <nl> -#ifndef __APPLE__ <nl>      screen = SDL_SetVideoMode(w, h, 0, flags); <nl> -#else <nl> -    /* setting bits_per_pixel = 0 or 32 causes blank video on OS X */ <nl> -    screen = SDL_SetVideoMode(w, h, 24, flags); <nl> -#endif <nl>      if (!screen) { <nl>          fprintf(stderr, "SDL: could not set video mode - exiting\n"); <nl>          do_exit(is);
@@ -248,6 +248,7 @@ static int img_read_packet(AVFormatContext *s1, AVPacket *pkt) <nl>          av_free_packet(pkt); <nl>          return AVERROR_IO; /* signal EOF */ <nl>      } else { <nl> +        pkt->size = ret; <nl>          s->img_count++; <nl>          s->img_number++; <nl>          return 0;
@@ -245,7 +245,7 @@ static int rm_read_audio_stream_info(AVFormatContext *s, ByteIOContext *pb, <nl>                  } <nl>                  st->codec->block_align = ast->sub_packet_size; <nl>              } <nl> -            if ((ret = rm_read_extradata(s->pb, st->codec, codecdata_length)) < 0) <nl> +            if ((ret = rm_read_extradata(pb, st->codec, codecdata_length)) < 0) <nl>                  return ret; <nl>   <nl>              if(ast->audio_framesize >= UINT_MAX / sub_packet_h){ <nl> @@ -267,7 +267,7 @@ static int rm_read_audio_stream_info(AVFormatContext *s, ByteIOContext *pb, <nl>              } <nl>              if (codecdata_length >= 1) { <nl>                  get_byte(pb); <nl> -                if ((ret = rm_read_extradata(s->pb, st->codec, codecdata_length - 1)) < 0) <nl> +                if ((ret = rm_read_extradata(pb, st->codec, codecdata_length - 1)) < 0) <nl>                      return ret; <nl>              } <nl>              break; <nl> @@ -321,7 +321,7 @@ ff_rm_read_mdpr_codecdata (AVFormatContext *s, ByteIOContext *pb, <nl>          fps2= get_be16(pb); <nl>          get_be16(pb); <nl>   <nl> -        if ((ret = rm_read_extradata(s->pb, st->codec, codec_data_size - (url_ftell(pb) - codec_pos))) < 0) <nl> +        if ((ret = rm_read_extradata(pb, st->codec, codec_data_size - (url_ftell(pb) - codec_pos))) < 0) <nl>              return ret; <nl>   <nl>  //        av_log(s, AV_LOG_DEBUG, "fps= %d fps2= %d\n", fps, fps2);
@@ -607,6 +607,9 @@ static int init_input(AVFormatContext *s, const char *filename) <nl>      int ret; <nl>      AVProbeData pd = {filename, NULL, 0}; <nl>   <nl> +    if(s->iformat && !strlen(filename)) <nl> +        return 0; <nl> + <nl>      if (s->pb) { <nl>          s->flags |= AVFMT_FLAG_CUSTOM_IO; <nl>          if (!s->iformat)
@@ -1272,7 +1272,7 @@ static int mjpeg_decode_scan_progressive_ac(MJpegDecodeContext *s, int ss, <nl>      } <nl>   <nl>      if (!Al) { <nl> -        s->coefs_finished[c] |= (2LL << se) - (1LL << ss); <nl> +        s->coefs_finished[c] |= (2ULL << se) - (1ULL << ss); <nl>          last_scan = !~s->coefs_finished[c]; <nl>      } <nl>  
@@ -713,7 +713,7 @@ static int xvid_encode_frame(AVCodecContext *avctx, AVPacket *pkt, <nl>      xvid_enc_frame_t xvid_enc_frame = { 0 }; <nl>      xvid_enc_stats_t xvid_enc_stats = { 0 }; <nl>   <nl> -    if ((ret = ff_alloc_packet2(avctx, pkt, mb_width*mb_height*MAX_MB_BYTES + FF_MIN_BUFFER_SIZE)) < 0) <nl> +    if ((ret = ff_alloc_packet2(avctx, pkt, mb_width*(int64_t)mb_height*MAX_MB_BYTES + FF_MIN_BUFFER_SIZE)) < 0) <nl>          return ret; <nl>   <nl>      /* Start setting up the frame */
@@ -190,7 +190,9 @@ static void echo_samples_## name ##p(AudioEchoContext *ctx,                 \ <nl>      const double in_gain = ctx->in_gain;                                    \ <nl>      const int nb_echoes = ctx->nb_echoes;                                   \ <nl>      const int max_samples = ctx->max_samples;                               \ <nl> -    int i, j, chan, index;                                                  \ <nl> +    int i, j, chan, av_uninit(index);                                       \ <nl> +                                                                            \ <nl> +    av_assert1(channels > 0); /* would corrupt delay_index */               \ <nl>                                                                              \ <nl>      for (chan = 0; chan < channels; chan++) {                               \ <nl>          const type *s = (type *)src[chan];                                  \
@@ -49,7 +49,7 @@ static void RENAME(vertical_compose53iL0)(uint8_t *_b0, uint8_t *_b1, uint8_t *_ <nl>      TYPE *b1 = (TYPE *)_b1; <nl>      TYPE *b2 = (TYPE *)_b2; <nl>      for (i = 0; i < width; i++) <nl> -        b1[i] -= (b0[i] + b2[i] + 2) >> 2; <nl> +        b1[i] -= (int)(b0[i] + (unsigned)b2[i] + 2) >> 2; <nl>  } <nl>   <nl>  static av_always_inline void RENAME(interleave)(TYPE *dst, TYPE *src0, TYPE *src1, int w2,
@@ -47,7 +47,7 @@ typedef struct SplitContext { <nl>  static av_cold int split_init(AVFilterContext *ctx) <nl>  { <nl>      SplitContext *s = ctx->priv; <nl> -    int i; <nl> +    int i, ret; <nl>   <nl>      for (i = 0; i < s->nb_outputs; i++) { <nl>          char name[32]; <nl> @@ -59,7 +59,10 @@ static av_cold int split_init(AVFilterContext *ctx) <nl>          if (!pad.name) <nl>              return AVERROR(ENOMEM); <nl>   <nl> -        ff_insert_outpad(ctx, i, &pad); <nl> +        if ((ret = ff_insert_outpad(ctx, i, &pad)) < 0) { <nl> +            av_freep(&pad.name); <nl> +            return ret; <nl> +        } <nl>      } <nl>   <nl>      return 0;
@@ -532,6 +532,7 @@ static char *sdp_write_media_attributes(char *buff, int size, AVCodecContext *c, <nl>                  break; <nl>              default: <nl>                  av_log(c, AV_LOG_ERROR, "Unsupported pixel format.\n"); <nl> +                av_free(config); <nl>                  return NULL; <nl>              } <nl>  
@@ -118,7 +118,7 @@ static int amr_read_packet(AVFormatContext *s, <nl>                            AVPacket *pkt) <nl>  { <nl>      AVCodecContext *enc = s->streams[0]->codec; <nl> -    int read, size, toc, mode; <nl> +    int read, size = 0, toc, mode; <nl>   <nl>      if (url_feof(&s->pb)) <nl>      {
@@ -783,7 +783,7 @@ static int vobsub_read_header(AVFormatContext *s) <nl>   <nl>              while (*p == ' ') <nl>                  p++; <nl> -            av_log(s, AV_LOG_DEBUG, "IDX stream[%d] name=%s\n", st->id, p); <nl> +            av_log(s, AV_LOG_DEBUG, "IDX stream[%d] name=%s\n", stream_id, p); <nl>              av_strlcpy(alt, p, sizeof(alt)); <nl>              header_parsed = 1; <nl>  
@@ -367,6 +367,12 @@ static int mpeg4_decode_sprite_trajectory(Mpeg4DecContext *ctx, GetBitContext *g <nl>      } else { <nl>          int shift_y = 16 - ctx->sprite_shift[0]; <nl>          int shift_c = 16 - ctx->sprite_shift[1]; <nl> + <nl> +        if (shift_c < 0 || shift_y < 0) { <nl> +            avpriv_request_sample(s->avctx, "Too large sprite shift"); <nl> +            return AVERROR_PATCHWELCOME; <nl> +        } <nl> + <nl>          for (i = 0; i < 2; i++) { <nl>              s->sprite_offset[0][i] *= 1 << shift_y; <nl>              s->sprite_offset[1][i] *= 1 << shift_c;
@@ -50,7 +50,7 @@ void ff_rtp_send_h263(AVFormatContext *s1, const uint8_t *buf1, int size) <nl>   <nl>      while (size > 0) { <nl>          q = s->buf; <nl> -        if ((buf1[0] == 0) && (buf1[1] == 0)) { <nl> +        if (size >= 2 && (buf1[0] == 0) && (buf1[1] == 0)) { <nl>              *q++ = 0x04; <nl>              buf1 += 2; <nl>              size -= 2;
@@ -2202,7 +2202,8 @@ static av_cold void RENAME(sws_init_swScale)(SwsContext *c) <nl>      enum PixelFormat srcFormat = c->srcFormat, <nl>                       dstFormat = c->dstFormat; <nl>   <nl> -    if (!is16BPS(dstFormat) && !is9_OR_10BPS(dstFormat)) { <nl> +    if (!is16BPS(dstFormat) && !is9_OR_10BPS(dstFormat) && <nl> +        dstFormat != PIX_FMT_NV12 && dstFormat != PIX_FMT_NV21) { <nl>          if (!(c->flags & SWS_BITEXACT)) { <nl>              if (c->flags & SWS_ACCURATE_RND) { <nl>                  c->yuv2yuv1 = RENAME(yuv2yuv1_ar    );
@@ -27,6 +27,8 @@ <nl>  #include "avformat.h" <nl>  #include "rawenc.h" <nl>   <nl> +#define MAX_EXTRADATA_SIZE 1024 <nl> + <nl>  typedef struct { <nl>      AVClass *av_class; <nl>      int off; <nl> @@ -53,6 +55,10 @@ static int latm_decode_extradata(LATMContext *ctx, uint8_t *buf, int size) <nl>  { <nl>      MPEG4AudioConfig m4ac; <nl>   <nl> +    if (size > MAX_EXTRADATA_SIZE) { <nl> +        av_log(ctx, AV_LOG_ERROR, "Extradata is larger than currently supported.\n"); <nl> +        return AVERROR_INVALIDDATA; <nl> +    } <nl>      ctx->off = avpriv_mpeg4audio_get_config(&m4ac, buf, size * 8, 1); <nl>      if (ctx->off < 0) <nl>          return ctx->off; <nl> @@ -152,11 +158,11 @@ static int latm_write_packet(AVFormatContext *s, AVPacket *pkt) <nl>      if (pkt->size > 0x1fff) <nl>          goto too_large; <nl>   <nl> -    buf = av_malloc(pkt->size+1024); <nl> +    buf = av_malloc(pkt->size+1024+MAX_EXTRADATA_SIZE); <nl>      if (!buf) <nl>          return AVERROR(ENOMEM); <nl>   <nl> -    init_put_bits(&bs, buf, pkt->size+1024); <nl> +    init_put_bits(&bs, buf, pkt->size+1024+MAX_EXTRADATA_SIZE); <nl>   <nl>      latm_write_frame_header(s, &bs); <nl>  
@@ -56,6 +56,11 @@ static av_cold int truespeech_decode_init(AVCodecContext * avctx) <nl>  { <nl>  //    TSContext *c = avctx->priv_data; <nl>   <nl> +    if (avctx->channels != 1) { <nl> +        av_log_ask_for_sample(avctx, "Unsupported channel count: %d\n", avctx->channels); <nl> +        return AVERROR(EINVAL); <nl> +    } <nl> + <nl>      avctx->sample_fmt = AV_SAMPLE_FMT_S16; <nl>      return 0; <nl>  }
@@ -150,7 +150,7 @@ static int bfi_read_packet(AVFormatContext * s, AVPacket * pkt) <nl>              return ret; <nl>   <nl>          pkt->pts          = bfi->video_frame; <nl> -        bfi->video_frame += ret / bfi->video_size; <nl> +        bfi->video_frame += bfi->video_size ? ret / bfi->video_size : 1; <nl>   <nl>          /* One less frame to read. A cursory decrement. */ <nl>          bfi->nframes--;
@@ -2547,7 +2547,7 @@ static void update_stream_timings(AVFormatContext *ic) <nl>              end_time1 = av_rescale_q_rnd(st->duration, st->time_base, <nl>                                           AV_TIME_BASE_Q, <nl>                                           AV_ROUND_NEAR_INF|AV_ROUND_PASS_MINMAX); <nl> -            if (end_time1 != AV_NOPTS_VALUE && start_time1 <= INT64_MAX - end_time1) { <nl> +            if (end_time1 != AV_NOPTS_VALUE && (end_time1 > 0 ? start_time1 <= INT64_MAX - end_time1 : start_time1 >= INT64_MIN - end_time1)) { <nl>                  end_time1 += start_time1; <nl>                  end_time = FFMAX(end_time, end_time1); <nl>              }
@@ -3757,6 +3757,7 @@ static int decode_nal_units(H264Context *h, const uint8_t *buf, int buf_size) <nl>      int pass = !(avctx->active_thread_type & FF_THREAD_FRAME); <nl>      int nals_needed = 0; ///< number of NALs that need decoding before the next frame thread starts <nl>      int nal_index; <nl> +    int idr_cleared=0; <nl>   <nl>      h->nal_unit_type= 0; <nl>   <nl> @@ -3900,7 +3901,9 @@ again: <nl>                      buf_index = -1; <nl>                      goto end; <nl>                  } <nl> -                idr(h); // FIXME ensure we don't lose some frames if there is reordering <nl> +                if(!idr_cleared) <nl> +                    idr(h); // FIXME ensure we don't lose some frames if there is reordering <nl> +                idr_cleared = 1; <nl>              case NAL_SLICE: <nl>                  init_get_bits(&hx->s.gb, ptr, bit_length); <nl>                  hx->intra_gb_ptr        =
@@ -4563,12 +4563,16 @@ static int mov_create_timecode_track(AVFormatContext *s, int index, int src_inde <nl>   <nl>      /* encode context: tmcd data stream */ <nl>      track->enc = avcodec_alloc_context3(NULL); <nl> +    if (!track->enc) <nl> +        return AVERROR(ENOMEM); <nl>      track->enc->codec_type = AVMEDIA_TYPE_DATA; <nl>      track->enc->codec_tag  = track->tag; <nl>      track->enc->time_base  = av_inv_q(rate); <nl>   <nl>      /* the tmcd track just contains one packet with the frame number */ <nl>      pkt.data = av_malloc(pkt.size); <nl> +    if (!pkt.data) <nl> +        return AVERROR(ENOMEM); <nl>      AV_WB32(pkt.data, tc.start); <nl>      ret = ff_mov_write_packet(s, &pkt); <nl>      av_free(pkt.data);
@@ -647,9 +647,12 @@ static int rv10_decode_frame(AVCodecContext *avctx, <nl>          slice_count = avctx->slice_count; <nl>   <nl>      for(i=0; i<slice_count; i++){ <nl> -        int offset= get_slice_offset(avctx, slices_hdr, i); <nl> +        unsigned offset = get_slice_offset(avctx, slices_hdr, i); <nl>          int size, size2; <nl>   <nl> +        if (offset >= buf_size) <nl> +            return AVERROR_INVALIDDATA; <nl> + <nl>          if(i+1 == slice_count) <nl>              size= buf_size - offset; <nl>          else <nl> @@ -660,6 +663,10 @@ static int rv10_decode_frame(AVCodecContext *avctx, <nl>          else <nl>              size2= get_slice_offset(avctx, slices_hdr, i+2) - offset; <nl>   <nl> +        if (size <= 0 || size2 <= 0 || <nl> +            offset + FFMAX(size, size2) > buf_size) <nl> +            return AVERROR_INVALIDDATA; <nl> + <nl>          if(rv10_decode_packet(avctx, buf+offset, size, size2) > 8*size) <nl>              i++; <nl>      }
@@ -3171,17 +3171,22 @@ static int transcode_init(void) <nl>              const char *in_codec_name  = "?"; <nl>              const char *encoder_name   = "?"; <nl>              const char *out_codec_name = "?"; <nl> +            const AVCodecDescriptor *desc; <nl>   <nl>              if (in_codec) { <nl>                  decoder_name  = in_codec->name; <nl> -                in_codec_name = avcodec_descriptor_get(in_codec->id)->name; <nl> +                desc = avcodec_descriptor_get(in_codec->id); <nl> +                if (desc) <nl> +                    in_codec_name = desc->name; <nl>                  if (!strcmp(decoder_name, in_codec_name)) <nl>                      decoder_name = "native"; <nl>              } <nl>   <nl>              if (out_codec) { <nl>                  encoder_name   = out_codec->name; <nl> -                out_codec_name = avcodec_descriptor_get(out_codec->id)->name; <nl> +                desc = avcodec_descriptor_get(out_codec->id); <nl> +                if (desc) <nl> +                    out_codec_name = desc->name; <nl>                  if (!strcmp(encoder_name, out_codec_name)) <nl>                      encoder_name = "native"; <nl>              }
@@ -965,7 +965,7 @@ int ffio_open_dyn_packet_buf(AVIOContext **s, int max_packet_size) <nl>   <nl>  int avio_close_dyn_buf(AVIOContext *s, uint8_t **pbuffer) <nl>  { <nl> -    DynBuffer *d = s->opaque; <nl> +    DynBuffer *d; <nl>      int size; <nl>      static const char padbuf[FF_INPUT_BUFFER_PADDING_SIZE] = {0}; <nl>      int padding = 0; <nl> @@ -983,6 +983,7 @@ int avio_close_dyn_buf(AVIOContext *s, uint8_t **pbuffer) <nl>   <nl>      avio_flush(s); <nl>   <nl> +    d = s->opaque; <nl>      *pbuffer = d->buffer; <nl>      size = d->size; <nl>      av_free(d);
@@ -980,6 +980,11 @@ static int dirac_unpack_idwt_params(DiracContext *s) <nl>          s->lowdelay.bytes.num = svq3_get_ue_golomb(gb); <nl>          s->lowdelay.bytes.den = svq3_get_ue_golomb(gb); <nl>   <nl> +        if (s->lowdelay.bytes.den <= 0) { <nl> +            av_log(s->avctx,AV_LOG_ERROR,"Invalid lowdelay.bytes.den\n"); <nl> +            return AVERROR_INVALIDDATA; <nl> +        } <nl> + <nl>          /* [DIRAC_STD] 11.3.5 Quantisation matrices (low-delay syntax). quant_matrix() */ <nl>          if (get_bits1(gb)) { <nl>              av_log(s->avctx,AV_LOG_DEBUG,"Low Delay: Has Custom Quantization Matrix!\n");
@@ -269,6 +269,7 @@ static int svq1_encode_plane(SVQ1Context *s, int plane, unsigned char *src_plane <nl>      int block_width, block_height; <nl>      int level; <nl>      int threshold[6]; <nl> +    uint8_t *src = s->scratchbuf + stride * 16; <nl>      const int lambda= (s->picture.quality*s->picture.quality) >> (2*FF_LAMBDA_SHIFT); <nl>   <nl>      /* figure out the acceptable level thresholds in advance */ <nl> @@ -327,8 +328,6 @@ static int svq1_encode_plane(SVQ1Context *s, int plane, unsigned char *src_plane <nl>          s->m.me.dia_size= s->avctx->dia_size; <nl>          s->m.first_slice_line=1; <nl>          for (y = 0; y < block_height; y++) { <nl> -            uint8_t src[stride*16]; <nl> - <nl>              s->m.new_picture.data[0]= src - y*16*stride; //ugly <nl>              s->m.mb_y= y; <nl>   <nl> @@ -356,8 +355,6 @@ static int svq1_encode_plane(SVQ1Context *s, int plane, unsigned char *src_plane <nl>   <nl>      s->m.first_slice_line=1; <nl>      for (y = 0; y < block_height; y++) { <nl> -        uint8_t src[stride*16]; <nl> - <nl>          for(i=0; i<16 && i + 16*y<height; i++){ <nl>              memcpy(&src[i*stride], &src_plane[(i+16*y)*src_stride], width); <nl>              for(x=width; x<16*block_width; x++) <nl> @@ -521,7 +518,7 @@ static int svq1_encode_frame(AVCodecContext *avctx, unsigned char *buf, <nl>      if(!s->current_picture.data[0]){ <nl>          avctx->get_buffer(avctx, &s->current_picture); <nl>          avctx->get_buffer(avctx, &s->last_picture); <nl> -        s->scratchbuf = av_malloc(s->current_picture.linesize[0] * 16); <nl> +        s->scratchbuf = av_malloc(s->current_picture.linesize[0] * 16 * 2); <nl>      } <nl>   <nl>      temp= s->current_picture;
@@ -651,6 +651,8 @@ start: <nl>                      c->seek_timestamp = AV_NOPTS_VALUE; <nl>                      break; <nl>                  } <nl> +                av_free_packet(&var->pkt); <nl> +                reset_packet(&var->pkt); <nl>              } <nl>          } <nl>          /* Check if this stream still is on an earlier segment number, or
@@ -5521,6 +5521,11 @@ static int vc1_decode_frame(AVCodecContext *avctx, void *data, <nl>          goto err; <nl>      } <nl>   <nl> +    if ((s->mb_height >> v->field_mode) == 0) { <nl> +        av_log(v->s.avctx, AV_LOG_ERROR, "image too short\n"); <nl> +        goto err; <nl> +    } <nl> + <nl>      // process pulldown flags <nl>      s->current_picture_ptr->f.repeat_pict = 0; <nl>      // Pulldown flags are only valid when 'broadcast' has been set.
@@ -1374,6 +1374,14 @@ static int mpegts_read_close(AVFormatContext *s) <nl>      int i; <nl>      for(i=0;i<NB_PID_MAX;i++) <nl>          if (ts->pids[i]) mpegts_close_filter(ts, ts->pids[i]); <nl> + <nl> +    for(i = 0; i < ts->nb_services; i++){ <nl> +        av_free(ts->services[i]->provider_name); <nl> +        av_free(ts->services[i]->name); <nl> +        av_free(ts->services[i]); <nl> +    } <nl> +    av_freep(&ts->services); <nl> + <nl>      return 0; <nl>  } <nl>  
@@ -29,6 +29,7 @@ static void mpegvideo_extract_headers(AVCodecParserContext *s, <nl>  { <nl>      ParseContext1 *pc = s->priv_data; <nl>      const uint8_t *buf_end; <nl> +    const uint8_t *buf_start= buf; <nl>      uint32_t start_code; <nl>      int frame_rate_index, ext_type, bytes_left; <nl>      int frame_rate_ext_n, frame_rate_ext_d; <nl> @@ -43,6 +44,8 @@ static void mpegvideo_extract_headers(AVCodecParserContext *s, <nl>          bytes_left = buf_end - buf; <nl>          switch(start_code) { <nl>          case PICTURE_START_CODE: <nl> +            ff_fetch_timestamp(s, buf-buf_start-4, 1); <nl> + <nl>              if (bytes_left >= 2) { <nl>                  s->pict_type = (buf[1] >> 3) & 7; <nl>              }
@@ -1011,6 +1011,10 @@ static int matroska_decode_buffer(uint8_t** buf, int* buf_size, <nl>   <nl>      switch (encodings[0].compression.algo) { <nl>      case MATROSKA_TRACK_ENCODING_COMP_HEADERSTRIP: <nl> +        if (encodings[0].compression.settings.size && !encodings[0].compression.settings.data) { <nl> +            av_log(0, AV_LOG_ERROR, "Compression size but no data in headerstrip\n"); <nl> +            return -1; <nl> +        } <nl>          return encodings[0].compression.settings.size; <nl>      case MATROSKA_TRACK_ENCODING_COMP_LZO: <nl>          do {
@@ -145,6 +145,10 @@ static void mpc8_parse_seektable(AVFormatContext *s, int64_t off) <nl>          av_log(s, AV_LOG_ERROR, "No seek table at given position\n"); <nl>          return; <nl>      } <nl> +    if (size > INT_MAX/10 || size<=0) { <nl> +        av_log(s, AV_LOG_ERROR, "Seek table size is invalid\n"); <nl> +        return; <nl> +    } <nl>      if(!(buf = av_malloc(size + FF_INPUT_BUFFER_PADDING_SIZE))) <nl>          return; <nl>      avio_read(s->pb, buf, size);
@@ -910,7 +910,7 @@ int attribute_align_arg sws_scale(struct SwsContext *c, <nl>          src2[0] = base; <nl>      } <nl>   <nl> -    if (!srcSliceY && (c->flags & SWS_BITEXACT) && (c->flags & SWS_ERROR_DIFFUSION)) <nl> +    if (!srcSliceY && (c->flags & SWS_BITEXACT) && (c->flags & SWS_ERROR_DIFFUSION) && c->dither_error[0]) <nl>          for (i = 0; i < 4; i++) <nl>              memset(c->dither_error[i], 0, sizeof(c->dither_error[0][0]) * (c->dstW+2)); <nl>  
@@ -2001,7 +2001,7 @@ static void lumRangeToJpeg16_c(int16_t *_dst, int width) <nl>      int i; <nl>      int32_t *dst = (int32_t *) _dst; <nl>      for (i = 0; i < width; i++) <nl> -        dst[i] = (FFMIN(dst[i],30189<<4)*19077 - (39057361<<4))>>14; <nl> +        dst[i] = (FFMIN(dst[i],30189<<4)*4769 - (39057361<<2))>>12; <nl>  } <nl>  static void lumRangeFromJpeg16_c(int16_t *_dst, int width) <nl>  {
@@ -2224,7 +2224,7 @@ static int theora_decode_header(AVCodecContext *avctx, GetBitContext *gb) <nl>   <nl>      fps.num = get_bits_long(gb, 32); <nl>      fps.den = get_bits_long(gb, 32); <nl> -    if (fps.num && fps.den) { <nl> +    if (fps.num>0 && fps.den>0) { <nl>          av_reduce(&avctx->time_base.num, &avctx->time_base.den, <nl>                    fps.den, fps.num, 1<<30); <nl>      }
@@ -1961,7 +1961,7 @@ static void mov_build_index(MOVContext *mov, AVStream *st) <nl>          unsigned int rap_group_index = 0; <nl>          unsigned int rap_group_sample = 0; <nl>          int rap_group_present = sc->rap_group_count && sc->rap_group; <nl> -        int key_off = (sc->keyframe_count && sc->keyframes[0] > 0) || (sc->stps_data && sc->stps_data[0] > 0); <nl> +        int key_off = (sc->keyframe_count && sc->keyframes[0] > 0) || (sc->stps_count && sc->stps_data[0] > 0); <nl>   <nl>          current_dts -= sc->dts_shift; <nl>  
@@ -110,7 +110,8 @@ ogm_header(AVFormatContext *s, int idx) <nl>                  size -= 52; <nl>                  if (bytestream2_get_bytes_left(&p) < size) <nl>                      return AVERROR_INVALIDDATA; <nl> -                ff_alloc_extradata(st->codecpar, size); <nl> +                if (ff_alloc_extradata(st->codecpar, size) < 0) <nl> +                    return AVERROR(ENOMEM); <nl>                  bytestream2_get_buffer(&p, st->codecpar->extradata, st->codecpar->extradata_size); <nl>              } <nl>          }
@@ -1961,10 +1961,10 @@ static void matroska_clear_queue(MatroskaDemuxContext *matroska) <nl>  } <nl>   <nl>  static int matroska_parse_laces(MatroskaDemuxContext *matroska, uint8_t **buf, <nl> -                                int size, int type, <nl> +                                int* buf_size, int type, <nl>                                  uint32_t **lace_buf, int *laces) <nl>  { <nl> -    int res = 0, n; <nl> +    int res = 0, n, size = *buf_size; <nl>      uint8_t *data = *buf; <nl>      uint32_t *lace_size; <nl>   <nl> @@ -2062,6 +2062,7 @@ static int matroska_parse_laces(MatroskaDemuxContext *matroska, uint8_t **buf, <nl>   <nl>      *buf      = data; <nl>      *lace_buf = lace_size; <nl> +    *buf_size = size; <nl>   <nl>      return res; <nl>  } <nl> @@ -2299,7 +2300,7 @@ static int matroska_parse_block(MatroskaDemuxContext *matroska, uint8_t *data, <nl>              matroska->skip_to_keyframe = 0; <nl>      } <nl>   <nl> -    res = matroska_parse_laces(matroska, &data, size, (flags & 0x06) >> 1, <nl> +    res = matroska_parse_laces(matroska, &data, &size, (flags & 0x06) >> 1, <nl>                                 &lace_size, &laces); <nl>   <nl>      if (res)
@@ -225,7 +225,7 @@ int ff_lpc_calc_coefs(LPCContext *s, <nl>   <nl>                  if(pass){ <nl>                      double eval, inv, rinv; <nl> -                    eval= m[(pass-1)&1].evaluate_lls(&m[(pass-1)&1], var+1, max_order-1); <nl> +                    eval= m[pass&1].evaluate_lls(&m[(pass-1)&1], var+1, max_order-1); <nl>                      eval= (512>>pass) + fabs(eval - var[0]); <nl>                      inv = 1/eval; <nl>                      rinv = sqrt(inv);
@@ -931,7 +931,7 @@ int ff_mpeg_update_thread_context(AVCodecContext *dst, <nl>  #define UPDATE_PICTURE(pic)\ <nl>  do {\ <nl>      ff_mpeg_unref_picture(s, &s->pic);\ <nl> -    if (s1->pic.f->buf[0])\ <nl> +    if (s1->pic.f && s1->pic.f->buf[0])\ <nl>          ret = ff_mpeg_ref_picture(s, &s->pic, &s1->pic);\ <nl>      else\ <nl>          ret = update_picture_tables(&s->pic, &s1->pic);\
@@ -3787,9 +3787,6 @@ int av_write_trailer(AVFormatContext *s) <nl>      if (s->oformat->write_trailer) <nl>          ret = s->oformat->write_trailer(s); <nl>   <nl> -    if (!(s->oformat->flags & AVFMT_NOFILE)) <nl> -        avio_flush(s->pb); <nl> - <nl>  fail: <nl>      if (s->pb) <nl>         avio_flush(s->pb);
@@ -43,7 +43,7 @@ <nl>   <nl>  #define SMKTREE_BITS 9 <nl>  #define SMK_NODE 0x80000000 <nl> - <nl> +#define SMKTREE_DECODE_MAX_RECURSION 32 <nl>   <nl>  typedef struct SmackVContext { <nl>      AVCodecContext *avctx; <nl> @@ -97,6 +97,11 @@ enum SmkBlockTypes { <nl>  static int smacker_decode_tree(BitstreamContext *bc, HuffContext *hc, <nl>                                 uint32_t prefix, int length) <nl>  { <nl> +    if (length > SMKTREE_DECODE_MAX_RECURSION) { <nl> +        av_log(NULL, AV_LOG_ERROR, "Maximum tree recursion level exceeded.\n"); <nl> +        return AVERROR_INVALIDDATA; <nl> +    } <nl> + <nl>      if (!bitstream_read_bit(bc)) { // Leaf <nl>          if(hc->current >= 256){ <nl>              av_log(NULL, AV_LOG_ERROR, "Tree size exceeded!\n");
@@ -701,7 +701,7 @@ static int read_filter_params(MLPDecodeContext *m, GetBitContext *gbp, <nl>              /* TODO: Check validity of state data. */ <nl>   <nl>              for (i = 0; i < order; i++) <nl> -                fp->state[i] = state_bits ? get_sbits(gbp, state_bits) << state_shift : 0; <nl> +                fp->state[i] = state_bits ? get_sbits(gbp, state_bits) * (1 << state_shift) : 0; <nl>          } <nl>      } <nl>  
@@ -54,7 +54,7 @@ typedef struct JVDemuxContext { <nl>   <nl>  static int read_probe(AVProbeData *pd) <nl>  { <nl> -    if (pd->buf[0] == 'J' && pd->buf[1] == 'V' && strlen(MAGIC) <= pd->buf_size - 4 && <nl> +    if (pd->buf[0] == 'J' && pd->buf[1] == 'V' && strlen(MAGIC) + 4 <= pd->buf_size && <nl>          !memcmp(pd->buf + 4, MAGIC, strlen(MAGIC))) <nl>          return AVPROBE_SCORE_MAX; <nl>      return 0;
@@ -2670,7 +2670,7 @@ reconnect: <nl>          // audio or video packet arrives. <nl>          while (!rt->has_audio && !rt->has_video && !rt->received_metadata) { <nl>              if ((ret = get_packet(s, 0)) < 0) <nl> -               return ret; <nl> +               goto fail; <nl>          } <nl>   <nl>          // Either after we have read the metadata or (if there is none) the
@@ -256,7 +256,7 @@ static int decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPac <nl>          c->pic.key_frame = !(compr & 1); <nl>          c->pic.pict_type = (compr & 1) ? AV_PICTURE_TYPE_P : AV_PICTURE_TYPE_I; <nl>          for(j = 0; j < avctx->height; j++){ <nl> -            if(compr & 1){ <nl> +            if((compr & 1) && tmpptr){ <nl>                  for(i = 0; i < avctx->width; i++) <nl>                      outptr[i] = srcptr[i] ^ tmpptr[i]; <nl>                  tmpptr += stride;
@@ -956,7 +956,7 @@ static void formant_postfilter(G723_1_Context *p, int16_t *lpc, int16_t *buf) <nl>      signal_ptr = filter_signal + LPC_ORDER; <nl>      for (i = 0; i < SUBFRAMES; i++) { <nl>          int16_t temp_vector[SUBFRAME_LEN]; <nl> -        int16_t temp; <nl> +        int temp; <nl>          int auto_corr[2]; <nl>          int scale, energy; <nl>   <nl> @@ -975,7 +975,7 @@ static void formant_postfilter(G723_1_Context *p, int16_t *lpc, int16_t *buf) <nl>              temp = (auto_corr[0] >> 2) / temp; <nl>          } <nl>          p->reflection_coef = (3 * p->reflection_coef + temp + 2) >> 2; <nl> -        temp = (p->reflection_coef * 0xffffc >> 3) & 0xfffc; <nl> +        temp = -p->reflection_coef >> 1 & ~3; <nl>   <nl>          /* Compensation filter */ <nl>          for (j = 0; j < SUBFRAME_LEN; j++) {
@@ -512,6 +512,10 @@ static int wma_decode_block(WMACodecContext *s) <nl>         coef escape coding */ <nl>      total_gain = 1; <nl>      for(;;) { <nl> +        if (get_bits_left(&s->gb) < 7) { <nl> +            av_log(s->avctx, AV_LOG_ERROR, "total_gain overread\n"); <nl> +            return AVERROR_INVALIDDATA; <nl> +        } <nl>          a = get_bits(&s->gb, 7); <nl>          total_gain += a; <nl>          if (a != 127)
@@ -492,7 +492,7 @@ static int read_connect(URLContext *s, RTMPContext *rt) <nl>          return ret; <nl>   <nl>      // Chunk size <nl> -    if ((ret = ff_rtmp_packet_create(&pkt, RTMP_SYSTEM_CHANNEL, <nl> +    if ((ret = ff_rtmp_packet_create(&pkt, RTMP_NETWORK_CHANNEL, <nl>                                       RTMP_PT_CHUNK_SIZE, 0, 4)) < 0) <nl>          return ret; <nl>  
@@ -347,7 +347,7 @@ static void ff_h264_idct8_dc_add_mmx2(uint8_t *dst, int16_t *block, int stride) <nl>          "pxor    %%mm1              , %%mm4 \n\t"\ <nl>          "pavgb   %%mm2              , %%mm4 \n\t" /* (q0 - p0 + 256)>>1*/\ <nl>          "pavgb   %%mm5              , %%mm3 \n\t"\ <nl> -        "paddb   %%mm4              , %%mm3 \n\t" /* d+128+33*/\ <nl> +        "paddusb %%mm4              , %%mm3 \n\t" /* d+128+33*/\ <nl>          "movq    "MANGLE(ff_pb_A1)" , %%mm6 \n\t"\ <nl>          "psubusb %%mm3              , %%mm6 \n\t"\ <nl>          "psubusb "MANGLE(ff_pb_A1)" , %%mm3 \n\t"\
@@ -144,6 +144,8 @@ static int decode_dds1(GetByteContext *gb, uint8_t *frame, int width, int height <nl>      int mask = 0x10000, bitbuf = 0; <nl>      int i, v, offset, count, segments; <nl>   <nl> +    if ((width | height) & 1) <nl> +        return AVERROR_INVALIDDATA; <nl>      segments = bytestream2_get_le16(gb); <nl>      while (segments--) { <nl>          if (bytestream2_get_bytes_left(gb) < 2) <nl> @@ -171,7 +173,7 @@ static int decode_dds1(GetByteContext *gb, uint8_t *frame, int width, int height <nl>                  return AVERROR_INVALIDDATA; <nl>              frame += v; <nl>          } else { <nl> -            if (frame_end - frame < width + 3) <nl> +            if (width < 4 || frame_end - frame < width + 4) <nl>                  return AVERROR_INVALIDDATA; <nl>              frame[0] = frame[1] = <nl>              frame[width] = frame[width + 1] =  bytestream2_get_byte(gb);
@@ -448,7 +448,7 @@ static void check_loopfilter(void) <nl>      static const char *const dir_name[2] = { "h", "v" }; <nl>      static const int E[2] = { 20, 28 }, I[2] = { 10, 16 }; <nl>      static const int H[2] = { 7, 11 }, F[2] = { 1, 1 }; <nl> -    declare_func(void, uint8_t *dst, ptrdiff_t stride, int E, int I, int H); <nl> +    declare_func_emms(AV_CPU_FLAG_MMX | AV_CPU_FLAG_MMXEXT, void, uint8_t *dst, ptrdiff_t stride, int E, int I, int H); <nl>   <nl>      for (bit_depth = 8; bit_depth <= 12; bit_depth += 2) { <nl>          ff_vp9dsp_init(&dsp, bit_depth, 0);
@@ -312,7 +312,8 @@ static int r3d_read_reda(AVFormatContext *s, AVPacket *pkt, Atom *atom) <nl>   <nl>      pkt->stream_index = 1; <nl>      pkt->dts = dts; <nl> -    pkt->duration = av_rescale(samples, st->time_base.den, st->codec->sample_rate); <nl> +    if (st->codec->sample_rate) <nl> +        pkt->duration = av_rescale(samples, st->time_base.den, st->codec->sample_rate); <nl>      av_dlog(s, "pkt dts %"PRId64" duration %d samples %d sample rate %d\n", <nl>              pkt->dts, pkt->duration, samples, st->codec->sample_rate); <nl>  
@@ -188,9 +188,17 @@ simple_round: <nl>   <nl>  int64_t av_add_stable(AVRational ts_tb, int64_t ts, AVRational inc_tb, int64_t inc) <nl>  { <nl> +    int64_t m, d; <nl> + <nl>      if (inc != 1) <nl>          inc_tb = av_mul_q(inc_tb, (AVRational) {inc, 1}); <nl>   <nl> +    m = inc_tb.num * (int64_t)ts_tb.den; <nl> +    d = inc_tb.den * (int64_t)ts_tb.num; <nl> + <nl> +    if (m % d == 0) <nl> +        return ts + m / d; <nl> + <nl>      if (av_cmp_q(inc_tb, ts_tb) < 0) { <nl>          //increase step is too small for even 1 step to be representable <nl>          return ts;
@@ -209,8 +209,8 @@ typedef struct H264Context{ <nl>       */ <nl>      int block_offset[2*(16+8)]; <nl>       <nl> -    uint16_t *mb2b_xy; //FIXME are these 4 a good idea? <nl> -    uint16_t *mb2b8_xy; <nl> +    uint32_t *mb2b_xy; //FIXME are these 4 a good idea? <nl> +    uint32_t *mb2b8_xy; <nl>      int b_stride; //FIXME use s->b4_stride <nl>      int b8_stride; <nl>   <nl> @@ -2667,8 +2667,8 @@ static int alloc_tables(H264Context *h){ <nl>      memset(h->slice_table_base, -1, big_mb_num  * sizeof(uint8_t)); <nl>      h->slice_table= h->slice_table_base + s->mb_stride + 1; <nl>   <nl> -    CHECKED_ALLOCZ(h->mb2b_xy  , big_mb_num * sizeof(uint16_t)); <nl> -    CHECKED_ALLOCZ(h->mb2b8_xy , big_mb_num * sizeof(uint16_t)); <nl> +    CHECKED_ALLOCZ(h->mb2b_xy  , big_mb_num * sizeof(uint32_t)); <nl> +    CHECKED_ALLOCZ(h->mb2b8_xy , big_mb_num * sizeof(uint32_t)); <nl>      for(y=0; y<s->mb_height; y++){ <nl>          for(x=0; x<s->mb_width; x++){ <nl>              const int mb_xy= x + y*s->mb_stride;
@@ -2069,6 +2069,11 @@ static int matroska_read_packet(AVFormatContext *s, AVPacket *pkt) <nl>          ret = matroska_parse_cluster(matroska); <nl>      } <nl>   <nl> +    if (ret == AVERROR_INVALIDDATA) { <nl> +        pkt->flags |= AV_PKT_FLAG_CORRUPT; <nl> +        return 0; <nl> +    } <nl> + <nl>      return ret; <nl>  } <nl>  
@@ -273,7 +273,7 @@ static inline int get_ur_golomb_jpegls(GetBitContext *gb, int k, int limit, int <nl>   <nl>      log= av_log2(buf); <nl>   <nl> -    if(log - k >= 32-MIN_CACHE_BITS && 32-log < limit){ <nl> +    if(log - k >= 32-MIN_CACHE_BITS+(MIN_CACHE_BITS==32) && 32-log < limit){ <nl>          buf >>= log - k; <nl>          buf += (30-log)<<k; <nl>          LAST_SKIP_BITS(re, gb, 32 + k - log);
@@ -443,6 +443,7 @@ static void start_children(FFServerStream *feed) <nl>          feed->pid = fork(); <nl>          if (feed->pid < 0) { <nl>              http_log("Unable to create children: %s\n", strerror(errno)); <nl> +            av_free (pathname); <nl>              exit(EXIT_FAILURE); <nl>          } <nl>  
@@ -1633,6 +1633,7 @@ static void do_video_out(AVFormatContext *s, OutputStream *ost, <nl>                  write_frame(s, &pkt, ost); <nl>                  frame_size = pkt.size; <nl>                  video_size += pkt.size; <nl> +                av_free_packet(&pkt); <nl>   <nl>                  /* if two pass, output log */ <nl>                  if (ost->logfile && enc->stats_out) {
@@ -467,7 +467,8 @@ int main(int argc, char **argv) <nl>          return 1; <nl>      } <nl>   <nl> -    frame->pts = 0; <nl> +    if (frame) <nl> +        frame->pts = 0; <nl>      for (;;) { <nl>          /* Compute current audio and video time. */ <nl>          if (audio_st)
@@ -62,6 +62,9 @@ static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame, <nl>      h = (buf[1] + 1) * 8; <nl>      buf += 2; <nl>   <nl> +    if (avpkt->size < 2 + w*h / 513) <nl> +        return AVERROR_INVALIDDATA; <nl> + <nl>      if (w != avctx->width || h != avctx->height) { <nl>          av_freep(&c->frame_buffer); <nl>          av_freep(&c->last_frame_buffer);
@@ -100,6 +100,7 @@ int ff_raw_audio_read_header(AVFormatContext *s, <nl>      st->codec->codec_type = AVMEDIA_TYPE_AUDIO; <nl>      st->codec->codec_id = s->iformat->value; <nl>      st->need_parsing = AVSTREAM_PARSE_FULL; <nl> +    st->start_time = 0; <nl>      /* the parameters will be extracted from the compressed bitstream */ <nl>   <nl>      return 0;
@@ -207,7 +207,7 @@ static av_cold int rl2_decode_end(AVCodecContext *avctx) <nl>  { <nl>      Rl2Context *s = avctx->priv_data; <nl>   <nl> -    av_free(s->back_frame); <nl> +    av_freep(&s->back_frame); <nl>   <nl>      return 0; <nl>  }
@@ -948,8 +948,8 @@ static int mpeg_decode_mb(MpegEncContext *s, int16_t block[12][64]) <nl>                          dmy = get_dmv(s); <nl>   <nl>   <nl> -                        s->last_mv[i][0][1] = my << my_shift; <nl> -                        s->last_mv[i][1][1] = my << my_shift; <nl> +                        s->last_mv[i][0][1] = my * (1 << my_shift); <nl> +                        s->last_mv[i][1][1] = my * (1 << my_shift); <nl>   <nl>                          s->mv[i][0][0] = mx; <nl>                          s->mv[i][0][1] = my;
@@ -272,7 +272,7 @@ int avfilter_graph_send_command(AVFilterGraph *graph, const char *target, const <nl>   <nl>      for (i = 0; i < graph->filter_count; i++) { <nl>          AVFilterContext *filter = graph->filters[i]; <nl> -        if(!strcmp(target, "all") || !strcmp(target, filter->name) || !strcmp(target, filter->filter->name)){ <nl> +        if(!strcmp(target, "all") || (filter->name && !strcmp(target, filter->name)) || !strcmp(target, filter->filter->name)){ <nl>              r = avfilter_process_command(filter, cmd, arg, res, res_len, flags); <nl>              if(r != AVERROR(ENOSYS)) { <nl>                  if((flags & AVFILTER_CMD_FLAG_ONE) || r<0)
@@ -1887,6 +1887,7 @@ static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame_ptr, <nl>  static av_cold int decode_end(AVCodecContext *avctx) <nl>  { <nl>      ALSDecContext *ctx = avctx->priv_data; <nl> +    int i; <nl>   <nl>      av_freep(&ctx->sconf.chan_pos); <nl>   <nl> @@ -1920,7 +1921,12 @@ static av_cold int decode_end(AVCodecContext *avctx) <nl>      av_freep(&ctx->last_acf_mantissa); <nl>      av_freep(&ctx->shift_value); <nl>      av_freep(&ctx->last_shift_value); <nl> -    av_freep(&ctx->raw_mantissa); <nl> +    if (ctx->raw_mantissa) { <nl> +        for (i = 0; i < avctx->channels; i++) { <nl> +            av_freep(&ctx->raw_mantissa[i]); <nl> +        } <nl> +        av_freep(&ctx->raw_mantissa); <nl> +    } <nl>      av_freep(&ctx->larray); <nl>      av_freep(&ctx->nbits); <nl>   <nl> @@ -2064,7 +2070,7 @@ static av_cold int decode_init(AVCodecContext *avctx) <nl>          ctx->shift_value       = av_malloc_array(avctx->channels, sizeof(*ctx->shift_value)); <nl>          ctx->last_shift_value  = av_malloc_array(avctx->channels, sizeof(*ctx->last_shift_value)); <nl>          ctx->last_acf_mantissa = av_malloc_array(avctx->channels, sizeof(*ctx->last_acf_mantissa)); <nl> -        ctx->raw_mantissa      = av_malloc_array(avctx->channels, sizeof(*ctx->raw_mantissa)); <nl> +        ctx->raw_mantissa      = av_mallocz_array(avctx->channels, sizeof(*ctx->raw_mantissa)); <nl>   <nl>          ctx->larray = av_malloc_array(ctx->cur_frame_length * 4, sizeof(*ctx->larray)); <nl>          ctx->nbits  = av_malloc_array(ctx->cur_frame_length, sizeof(*ctx->nbits));
@@ -1598,6 +1598,9 @@ end: <nl>          frame->height = avctx->height; <nl>      } <nl>   <nl> +    if (ret < 0) <nl> +        av_frame_unref(frame); <nl> + <nl>      return ret; <nl>  } <nl>  
@@ -1217,6 +1217,7 @@ exit_loop: <nl>          } <nl>      } <nl>      ff_thread_report_progress(&s->picture, INT_MAX, 0); <nl> +    ff_thread_report_progress(&s->previous_picture, INT_MAX, 0); <nl>   <nl>      av_frame_set_metadata(p, metadata); <nl>      metadata   = NULL; <nl> @@ -1225,6 +1226,7 @@ exit_loop: <nl>  fail: <nl>      av_dict_free(&metadata); <nl>      ff_thread_report_progress(&s->picture, INT_MAX, 0); <nl> +    ff_thread_report_progress(&s->previous_picture, INT_MAX, 0); <nl>      return ret; <nl>  } <nl>  
@@ -208,8 +208,9 @@ static void lumRangeToJpeg16_c(int16_t *_dst, int width) <nl>  { <nl>      int i; <nl>      int32_t *dst = (int32_t *) _dst; <nl> -    for (i = 0; i < width; i++) <nl> -        dst[i] = (FFMIN(dst[i], 30189 << 4) * 4769 - (39057361 << 2)) >> 12; <nl> +    for (i = 0; i < width; i++) { <nl> +        dst[i] = ((int)(FFMIN(dst[i], 30189 << 4) * 4769U - (39057361 << 2))) >> 12; <nl> +    } <nl>  } <nl>   <nl>  static void lumRangeFromJpeg16_c(int16_t *_dst, int width)
@@ -3041,7 +3041,7 @@ static void compute_chapters_end(AVFormatContext *s) <nl>      unsigned int i, j; <nl>      int64_t max_time = 0; <nl>   <nl> -    if (s->duration > 0) <nl> +    if (s->duration > 0 && s->start_time < INT64_MAX - s->duration) <nl>          max_time = s->duration + <nl>                         ((s->start_time == AV_NOPTS_VALUE) ? 0 : s->start_time); <nl>  
@@ -679,7 +679,7 @@ static int matroska_ebmlnum_uint(MatroskaDemuxContext *matroska, <nl>  { <nl>      ByteIOContext pb; <nl>      init_put_byte(&pb, data, size, 0, NULL, NULL, NULL, NULL); <nl> -    return ebml_read_num(matroska, &pb, 8, num); <nl> +    return ebml_read_num(matroska, &pb, FFMIN(size, 8), num); <nl>  } <nl>   <nl>  /*
@@ -144,7 +144,8 @@ static int X264_frame(AVCodecContext *ctx, uint8_t *buf, <nl>      } <nl>   <nl>      x4->out_pic.key_frame = pic_out.b_keyframe; <nl> -    x4->out_pic.quality   = (pic_out.i_qpplus1 - 1) * FF_QP2LAMBDA; <nl> +    if (bufsize) <nl> +        x4->out_pic.quality = (pic_out.i_qpplus1 - 1) * FF_QP2LAMBDA; <nl>   <nl>      return bufsize; <nl>  }
@@ -1055,7 +1055,7 @@ matroska_probe (AVProbeData *p) <nl>       * we don't parse the whole header but simply check for the <nl>       * availability of that array of characters inside the header. <nl>       * Not fully fool-proof, but good enough. */ <nl> -    for (n = 4 + size; n < 4 + size + total - sizeof(probe_data); n++) <nl> +    for (n = 4 + size; n <= 4 + size + total - sizeof(probe_data); n++) <nl>          if (!memcmp (&p->buf[n], probe_data, sizeof(probe_data))) <nl>              return AVPROBE_SCORE_MAX; <nl>  
@@ -559,7 +559,7 @@ static int ism_write_packet(AVFormatContext *s, AVPacket *pkt) <nl>      SmoothStreamingContext *c = s->priv_data; <nl>      AVStream *st = s->streams[pkt->stream_index]; <nl>      OutputStream *os = &c->streams[pkt->stream_index]; <nl> -    int64_t end_dts = (c->nb_fragments + 1) * c->min_frag_duration; <nl> +    int64_t end_dts = (c->nb_fragments + 1LL) * c->min_frag_duration; <nl>      int ret; <nl>   <nl>      if (st->first_dts == AV_NOPTS_VALUE)
@@ -338,8 +338,8 @@ static int channelmap_filter_samples(AVFilterLink *inlink, AVFilterBufferRef *bu <nl>              if (buf->extended_data == buf->data) { <nl>                  buf->extended_data = new_extended_data; <nl>              } else { <nl> -                buf->extended_data = new_extended_data; <nl>                  av_free(buf->extended_data); <nl> +                buf->extended_data = new_extended_data; <nl>              } <nl>          } else if (buf->extended_data != buf->data) { <nl>              av_free(buf->extended_data);
@@ -215,6 +215,9 @@ av_cold int ff_dcaadpcm_init(DCAADPCMEncContext *s) <nl>          return -1; <nl>   <nl>      s->private_data = av_malloc(sizeof(premultiplied_coeffs) * DCA_ADPCM_VQCODEBOOK_SZ); <nl> +    if (!s->private_data) <nl> +        return AVERROR(ENOMEM); <nl> + <nl>      precalc(s->private_data); <nl>      return 0; <nl>  }
@@ -194,7 +194,10 @@ static int read_header(AVFormatContext *s) <nl>              return ret; <nl>      } <nl>   <nl> -    avio_seek(pb, vst->index_entries[0].pos, SEEK_SET); <nl> +    if (vst->index_entries) <nl> +        avio_seek(pb, vst->index_entries[0].pos, SEEK_SET); <nl> +    else <nl> +        avio_skip(pb, 4); <nl>   <nl>      bink->current_track = -1; <nl>      return 0;
@@ -82,6 +82,13 @@ static int speex_header(AVFormatContext *s, int idx) { <nl>   <nl>          spxp->packet_size  = AV_RL32(p + 56); <nl>          frames_per_packet  = AV_RL32(p + 64); <nl> +        if (spxp->packet_size < 0 || <nl> +            frames_per_packet < 0 || <nl> +            spxp->packet_size * (int64_t)frames_per_packet > INT32_MAX / 256) { <nl> +            av_log(s, AV_LOG_ERROR, "invalid packet_size, frames_per_packet %d %d\n", spxp->packet_size, frames_per_packet); <nl> +            spxp->packet_size = 0; <nl> +            return AVERROR_INVALIDDATA; <nl> +        } <nl>          if (frames_per_packet) <nl>              spxp->packet_size *= frames_per_packet; <nl>  
@@ -954,7 +954,8 @@ static void print_report(AVFormatContext **output_files, <nl>          enc = ost->st->codec; <nl>          if (vid && enc->codec_type == CODEC_TYPE_VIDEO) { <nl>              snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "q=%2.1f ", <nl> -                    enc->coded_frame->quality/(float)FF_QP2LAMBDA); <nl> +                     enc->coded_frame && !ost->st->stream_copy ? <nl> +                     enc->coded_frame->quality/(float)FF_QP2LAMBDA : -1); <nl>          } <nl>          if (!vid && enc->codec_type == CODEC_TYPE_VIDEO) { <nl>              float t = (av_gettime()-timer_start) / 1000000.0; <nl> @@ -962,7 +963,8 @@ static void print_report(AVFormatContext **output_files, <nl>              frame_number = ost->frame_number; <nl>              snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "frame=%5d fps=%3d q=%3.1f ", <nl>                       frame_number, (t>1)?(int)(frame_number/t+0.5) : 0, <nl> -                     enc->coded_frame ? enc->coded_frame->quality/(float)FF_QP2LAMBDA : -1); <nl> +                     enc->coded_frame && !ost->st->stream_copy ? <nl> +                     enc->coded_frame->quality/(float)FF_QP2LAMBDA : -1); <nl>              if(is_last_report) <nl>                  snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "L"); <nl>              if(qp_hist && enc->coded_frame){
@@ -825,6 +825,8 @@ int vc1_parse_frame_header_adv(VC1Context *v, GetBitContext* gb) <nl>      int scale, shift, i; /* for initializing LUT for intensity compensation */ <nl>   <nl>      v->numref=0; <nl> +    v->fcm=0; <nl> +    v->field_mode=0; <nl>      v->p_frame_skipped = 0; <nl>      if (v->second_field) { <nl>          v->s.pict_type = (v->fptype & 1) ? AV_PICTURE_TYPE_P : AV_PICTURE_TYPE_I;
@@ -68,11 +68,11 @@ static int hq_decode_block(HQContext *c, GetBitContext *gb, int16_t block[64], <nl>      memset(block, 0, 64 * sizeof(*block)); <nl>   <nl>      if (!is_hqa) { <nl> -        block[0] = get_sbits(gb, 9) << 6; <nl> +        block[0] = get_sbits(gb, 9) * 64; <nl>          q = ff_hq_quants[qsel][is_chroma][get_bits(gb, 2)]; <nl>      } else { <nl>          q = ff_hq_quants[qsel][is_chroma][get_bits(gb, 2)]; <nl> -        block[0] = get_sbits(gb, 9) << 6; <nl> +        block[0] = get_sbits(gb, 9) * 64; <nl>      } <nl>   <nl>      for (;;) {
@@ -45,8 +45,8 @@ static void vc1_v_overlap_c(uint8_t* src, int stride) <nl>          d2 = (a - d + b - c + 4 - rnd) >> 3; <nl>   <nl>          src[-2*stride] = a - d1; <nl> -        src[-stride] = b - d2; <nl> -        src[0] = c + d2; <nl> +        src[-stride] = av_clip_uint8(b - d2); <nl> +        src[0] = av_clip_uint8(c + d2); <nl>          src[stride] = d + d1; <nl>          src++; <nl>          rnd = !rnd; <nl> @@ -70,8 +70,8 @@ static void vc1_h_overlap_c(uint8_t* src, int stride) <nl>          d2 = (a - d + b - c + 4 - rnd) >> 3; <nl>   <nl>          src[-2] = a - d1; <nl> -        src[-1] = b - d2; <nl> -        src[0] = c + d2; <nl> +        src[-1] = av_clip_uint8(b - d2); <nl> +        src[0] = av_clip_uint8(c + d2); <nl>          src[1] = d + d1; <nl>          src += stride; <nl>          rnd = !rnd;
@@ -321,7 +321,7 @@ static int check_n_master(AVCodecContext *avctx, int n_master, int bs_xover_band <nl>  static int sbr_make_f_master(AACContext *ac, SpectralBandReplication *sbr, <nl>                               SpectrumParameters *spectrum) <nl>  { <nl> -    unsigned int temp, max_qmf_subbands; <nl> +    unsigned int temp, max_qmf_subbands = 0; <nl>      unsigned int start_min, stop_min; <nl>      int k; <nl>      const int8_t *sbr_offset_ptr;
@@ -862,7 +862,7 @@ static int tak_decode_frame(AVCodecContext *avctx, void *data, <nl>   <nl>              if (s->sample_shift[chan] > 0) <nl>                  for (i = 0; i < s->nb_samples; i++) <nl> -                    decoded[i] <<= s->sample_shift[chan]; <nl> +                    decoded[i] *= 1 << s->sample_shift[chan]; <nl>          } <nl>      } <nl>  
@@ -33,6 +33,8 @@ <nl>   <nl>   <nl>  typedef struct { <nl> +    AVCodecContext *avctx; <nl> + <nl>      unsigned int     old_energy;        ///< previous frame energy <nl>   <nl>      unsigned int     lpc_tables[2][10]; <nl> @@ -55,6 +57,8 @@ static av_cold int ra144_decode_init(AVCodecContext * avctx) <nl>  { <nl>      RA144Context *ractx = avctx->priv_data; <nl>   <nl> +    ractx->avctx = avctx; <nl> + <nl>      ractx->lpc_coef[0] = ractx->lpc_tables[0]; <nl>      ractx->lpc_coef[1] = ractx->lpc_tables[1]; <nl>   <nl> @@ -226,7 +230,7 @@ static void int_to_int16(int16_t *out, const int *inp) <nl>   * @return 1 if one of the reflection coefficients is greater than <nl>   *         4095, 0 if not. <nl>   */ <nl> -static int eval_refl(int *refl, const int16_t *coefs, RA144Context *ractx) <nl> +static int eval_refl(int *refl, const int16_t *coefs, AVCodecContext *avctx) <nl>  { <nl>      int b, i, j; <nl>      int buffer1[10]; <nl> @@ -240,7 +244,7 @@ static int eval_refl(int *refl, const int16_t *coefs, RA144Context *ractx) <nl>      refl[9] = bp2[9]; <nl>   <nl>      if ((unsigned) bp2[9] + 0x1000 > 0x1fff) { <nl> -        av_log(ractx, AV_LOG_ERROR, "Overflow. Broken sample?\n"); <nl> +        av_log(avctx, AV_LOG_ERROR, "Overflow. Broken sample?\n"); <nl>          return 1; <nl>      } <nl>   <nl> @@ -275,7 +279,7 @@ static int interp(RA144Context *ractx, int16_t *out, int a, <nl>      for (i=0; i<30; i++) <nl>          out[i] = (a * ractx->lpc_coef[0][i] + b * ractx->lpc_coef[1][i])>> 2; <nl>   <nl> -    if (eval_refl(work, out, ractx)) { <nl> +    if (eval_refl(work, out, ractx->avctx)) { <nl>          // The interpolated coefficients are unstable, copy either new or old <nl>          // coefficients. <nl>          int_to_int16(out, ractx->lpc_coef[copyold]);
@@ -1059,11 +1059,11 @@ static int dwa_uncompress(EXRContext *s, const uint8_t *src, int compressed_size <nl>          bytestream2_skip(&gb, ac_size); <nl>      } <nl>   <nl> -    if (dc_size > 0) { <nl> +    { <nl>          unsigned long dest_len = dc_count * 2LL; <nl>          GetByteContext agb = gb; <nl>   <nl> -        if (dc_count > (6LL * td->xsize * td->ysize + 63) / 64) <nl> +        if (dc_count != dc_w * dc_h * 3) <nl>              return AVERROR_INVALIDDATA; <nl>   <nl>          av_fast_padded_malloc(&td->dc_data, &td->dc_size, FFALIGN(dest_len, 64) * 2);
@@ -1992,18 +1992,18 @@ static int matroska_parse_laces(MatroskaDemuxContext *matroska, uint8_t **buf, <nl>          uint32_t total = 0; <nl>          for (n = 0; res == 0 && n < *laces - 1; n++) { <nl>              while (1) { <nl> -                if (size == 0) { <nl> +                if (size <= total) { <nl>                      res = AVERROR_INVALIDDATA; <nl>                      break; <nl>                  } <nl>                  temp = *data; <nl> +                total += temp; <nl>                  lace_size[n] += temp; <nl>                  data += 1; <nl>                  size -= 1; <nl>                  if (temp != 0xff) <nl>                      break; <nl>              } <nl> -            total += lace_size[n]; <nl>          } <nl>          if (size <= total) { <nl>              res = AVERROR_INVALIDDATA;
@@ -137,7 +137,8 @@ int attribute_align_arg av_buffersink_get_frame_flags(AVFilterContext *ctx, AVFr <nl>   <nl>      if (flags & AV_BUFFERSINK_FLAG_PEEK) { <nl>          cur_frame = *((AVFrame **)av_fifo_peek2(buf->fifo, 0)); <nl> -        av_frame_ref(frame, cur_frame); /* TODO check failure */ <nl> +        if ((ret = av_frame_ref(frame, cur_frame)) < 0) <nl> +            return ret; <nl>      } else { <nl>          av_fifo_generic_read(buf->fifo, &cur_frame, sizeof(cur_frame), NULL); <nl>          av_frame_move_ref(frame, cur_frame);
@@ -1406,7 +1406,7 @@ static const uint8_t *decode_nal(H264Context *h, const uint8_t *src, int *dst_le <nl>      } <nl>   <nl>      bufidx = h->nal_unit_type == NAL_DPC ? 1 : 0; // use second escape buffer for inter data <nl> -    h->rbsp_buffer[bufidx]= av_fast_realloc(h->rbsp_buffer[bufidx], &h->rbsp_buffer_size[bufidx], length); <nl> +    h->rbsp_buffer[bufidx]= av_fast_realloc(h->rbsp_buffer[bufidx], &h->rbsp_buffer_size[bufidx], length+FF_INPUT_BUFFER_PADDING_SIZE); <nl>      dst= h->rbsp_buffer[bufidx]; <nl>   <nl>      if (dst == NULL){ <nl> @@ -1430,6 +1430,8 @@ static const uint8_t *decode_nal(H264Context *h, const uint8_t *src, int *dst_le <nl>          dst[di++]= src[si++]; <nl>      } <nl>   <nl> +    memset(dst+di, 0, FF_INPUT_BUFFER_PADDING_SIZE); <nl> + <nl>      *dst_length= di; <nl>      *consumed= si + 1;//+1 for the header <nl>  //FIXME store exact number of bits in the getbitcontext (it is needed for decoding)
@@ -1082,6 +1082,8 @@ static int dvbsub_parse_clut_segment(AVCodecContext *avctx, <nl>   <nl>      if (!clut) { <nl>          clut = av_malloc(sizeof(DVBSubCLUT)); <nl> +        if (!clut) <nl> +            return AVERROR(ENOMEM); <nl>   <nl>          memcpy(clut, &default_clut, sizeof(DVBSubCLUT)); <nl>   <nl> @@ -1169,6 +1171,8 @@ static void dvbsub_parse_region_segment(AVCodecContext *avctx, <nl>   <nl>      if (!region) { <nl>          region = av_mallocz(sizeof(DVBSubRegion)); <nl> +        if (!region) <nl> +            return; <nl>   <nl>          region->id = region_id; <nl>          region->version = -1;
@@ -188,7 +188,7 @@ void updateMMXDitherTables(SwsContext *c, int dstY, int lumBufIndex, int chrBufI <nl>                  *(const void**)&lumMmxFilter[4*i+0]= lumSrcPtr[i]; <nl>                  lumMmxFilter[4*i+2]= <nl>                  lumMmxFilter[4*i+3]= <nl> -                ((uint16_t)vLumFilter[dstY*vLumFilterSize + i])*0x10001; <nl> +                ((uint16_t)vLumFilter[dstY*vLumFilterSize + i])*0x10001U; <nl>                  if (CONFIG_SWSCALE_ALPHA && alpPixBuf) { <nl>                      *(const void**)&alpMmxFilter[4*i+0]= alpSrcPtr[i]; <nl>                      alpMmxFilter[4*i+2]= <nl> @@ -199,7 +199,7 @@ void updateMMXDitherTables(SwsContext *c, int dstY, int lumBufIndex, int chrBufI <nl>                  *(const void**)&chrMmxFilter[4*i+0]= chrUSrcPtr[i]; <nl>                  chrMmxFilter[4*i+2]= <nl>                  chrMmxFilter[4*i+3]= <nl> -                ((uint16_t)vChrFilter[chrDstY*vChrFilterSize + i])*0x10001; <nl> +                ((uint16_t)vChrFilter[chrDstY*vChrFilterSize + i])*0x10001U; <nl>              } <nl>          } <nl>      }
@@ -668,6 +668,11 @@ static int read_var_block_data(ALSDecContext *ctx, ALSBlockData *bd) <nl>              int opt_order_length = av_ceil_log2(av_clip((bd->block_length >> 3) - 1, <nl>                                                  2, sconf->max_order + 1)); <nl>              *bd->opt_order       = get_bits(gb, opt_order_length); <nl> +            if (*bd->opt_order > sconf->max_order) { <nl> +                *bd->opt_order = sconf->max_order; <nl> +                av_log(avctx, AV_LOG_ERROR, "Predictor order too large!\n"); <nl> +                return AVERROR_INVALIDDATA; <nl> +            } <nl>          } else { <nl>              *bd->opt_order = sconf->max_order; <nl>          }
@@ -1457,7 +1457,7 @@ static int mxf_parse_physical_source_package(MXFContext *mxf, MXFTrack *source_t <nl>              break; <nl>   <nl>          /* the name of physical source package is name of the reel or tape */ <nl> -        if (physical_package->name[0]) <nl> +        if (physical_package->name && physical_package->name[0]) <nl>              av_dict_set(&st->metadata, "reel_name", physical_package->name, 0); <nl>   <nl>          /* the source timecode is calculated by adding the start_position of the sourceclip from the file source package track
@@ -1359,13 +1359,9 @@ int ff_mjpeg_find_marker(MJpegDecodeContext *s, <nl>      int start_code; <nl>      start_code = find_marker(buf_ptr, buf_end); <nl>   <nl> -    if ((buf_end - *buf_ptr) > s->buffer_size) { <nl> -        av_free(s->buffer); <nl> -        s->buffer_size = buf_end - *buf_ptr; <nl> -        s->buffer      = av_malloc(s->buffer_size + FF_INPUT_BUFFER_PADDING_SIZE); <nl> -        av_log(s->avctx, AV_LOG_DEBUG, <nl> -               "buffer too small, expanding to %d bytes\n", s->buffer_size); <nl> -    } <nl> +    av_fast_padded_malloc(&s->buffer, &s->buffer_size, buf_end - *buf_ptr); <nl> +    if (!s->buffer) <nl> +        return AVERROR(ENOMEM); <nl>   <nl>      /* unescape buffer of SOS, use special treatment for JPEG-LS */ <nl>      if (start_code == SOS && !s->ls) {
@@ -209,9 +209,9 @@ static void fic_draw_cursor(AVCodecContext *avctx, int cur_x, int cur_y) <nl>   <nl>      /* Convert to YUVA444. */ <nl>      for (i = 0; i < 1024; i++) { <nl> -        planes[0][i] = av_clip_uint8((( 25 * ptr[0] + 129 * ptr[1] +  66 * ptr[2]) / 255) + 16); <nl> -        planes[1][i] = av_clip_uint8(((-38 * ptr[0] + 112 * ptr[1] + -74 * ptr[2]) / 255) + 128); <nl> -        planes[2][i] = av_clip_uint8(((-18 * ptr[0] + 112 * ptr[1] + -94 * ptr[2]) / 255) + 128); <nl> +        planes[0][i] = (( 25 * ptr[0] + 129 * ptr[1] +  66 * ptr[2]) / 255) + 16; <nl> +        planes[1][i] = ((-38 * ptr[0] + 112 * ptr[1] + -74 * ptr[2]) / 255) + 128; <nl> +        planes[2][i] = ((-18 * ptr[0] + 112 * ptr[1] + -94 * ptr[2]) / 255) + 128; <nl>          planes[3][i] = ptr[3]; <nl>   <nl>          ptr += 4;
@@ -519,6 +519,11 @@ static int nut_write_header(AVFormatContext *s) <nl>      AVCodecContext *codec; <nl>      int i, j, tmp_time, tmp_flags,tmp_stream, tmp_mul, tmp_size, tmp_fields; <nl>   <nl> +    if (strcmp(s->filename, "./data/b-libav.nut")) { <nl> +        av_log(s, AV_LOG_ERROR, " libavformat NUT is non-compliant and disabled\n"); <nl> +        return -1; <nl> +    } <nl> + <nl>      nut->avf= s; <nl>   <nl>      nut->stream =
@@ -186,8 +186,17 @@ static int config_input(AVFilterLink *inlink) <nl>   <nl>      s->start_duration = av_rescale(s->start_duration, inlink->sample_rate, <nl>                                     AV_TIME_BASE); <nl> +    if (s->start_duration < 0) { <nl> +        av_log(ctx, AV_LOG_WARNING, "start duration must be non-negative\n"); <nl> +        s->start_duration = -s->start_duration; <nl> +    } <nl> + <nl>      s->stop_duration  = av_rescale(s->stop_duration, inlink->sample_rate, <nl>                                     AV_TIME_BASE); <nl> +    if (s->stop_duration < 0) { <nl> +        av_log(ctx, AV_LOG_WARNING, "stop duration must be non-negative\n"); <nl> +        s->stop_duration = -s->stop_duration; <nl> +    } <nl>   <nl>      s->start_holdoff = av_malloc_array(FFMAX(s->start_duration, 1), <nl>                                         sizeof(*s->start_holdoff) *
@@ -126,6 +126,7 @@ static int daala_header(AVFormatContext *s, int idx) <nl>          if (hdr->gpshift >= 32) { <nl>              av_log(s, AV_LOG_ERROR, "Too large gpshift %d (>= 32).\n", <nl>                     hdr->gpshift); <nl> +            hdr->gpshift = 0; <nl>              return AVERROR_INVALIDDATA; <nl>          } <nl>          hdr->gpmask  = (1U << hdr->gpshift) - 1;
@@ -20,6 +20,7 @@ <nl>   */ <nl>   <nl>  #include "libavutil/intreadwrite.h" <nl> +#include "libavutil/avassert.h" <nl>  #include "avformat.h" <nl>  #include "internal.h" <nl>  #include "wtv.h" <nl> @@ -137,6 +138,7 @@ static void write_chunk_header(AVFormatContext *s, const ff_asf_guid *guid, int <nl>   <nl>      if ((stream_id & 0x80000000) && guid != &index_guid) { <nl>          WtvChunkEntry *t = wctx->index + wctx->nb_index; <nl> +        av_assert0(wctx->nb_index < MAX_NB_INDEX); <nl>          t->pos       = wctx->last_chunk_pos; <nl>          t->serial    = wctx->serial; <nl>          t->guid      = guid; <nl> @@ -607,6 +609,8 @@ static int finish_file(AVFormatContext *s, enum WtvFileIndex index, int64_t star <nl>      int64_t end_pos = avio_tell(pb); <nl>      int sector_bits, nb_sectors, pad; <nl>   <nl> +    av_assert0(index < WTV_FILES); <nl> + <nl>      w->length = (end_pos - start_pos); <nl>   <nl>      // determine optimal fat table depth, sector_bits, nb_sectors
@@ -20,6 +20,7 @@ <nl>   */ <nl>   <nl>  #include "libavutil/bswap.h" <nl> +#include "libavcodec/internal.h" <nl>  #include "avformat.h" <nl>  #include "internal.h" <nl>   <nl> @@ -68,7 +69,7 @@ static int xvag_read_header(AVFormatContext *s) <nl>   <nl>      if (st->codecpar->sample_rate <= 0) <nl>          return AVERROR_INVALIDDATA; <nl> -    if (st->codecpar->channels <= 0) <nl> +    if (st->codecpar->channels <= 0 || st->codecpar->channels > FF_SANE_NB_CHANNELS) <nl>          return AVERROR_INVALIDDATA; <nl>   <nl>      switch (codec) {
@@ -78,6 +78,7 @@ static int decode_frame(AVCodecContext *avctx, <nl>          av_log(avctx, AV_LOG_ERROR, "Cannot allocate temporary buffer\n"); <nl>          return AVERROR(ENOMEM); <nl>      } <nl> +    memset(rbuf + buf_size, 0, FF_INPUT_BUFFER_PADDING_SIZE); <nl>   <nl>      if ((ret = ff_get_buffer(avctx, p, 0)) < 0) { <nl>          av_free(rbuf);
@@ -61,10 +61,6 @@ static int sunrast_decode_frame(AVCodecContext *avctx, void *data, <nl>          av_log(avctx, AV_LOG_ERROR, "invalid (compression) type\n"); <nl>          return AVERROR_INVALIDDATA; <nl>      } <nl> -    if (av_image_check_size(w, h, 0, avctx)) { <nl> -        av_log(avctx, AV_LOG_ERROR, "invalid image size\n"); <nl> -        return AVERROR_INVALIDDATA; <nl> -    } <nl>      if (maptype == RMT_RAW) { <nl>          avpriv_request_sample(avctx, "Unknown colormap type"); <nl>          return AVERROR_PATCHWELCOME; <nl> @@ -90,8 +86,10 @@ static int sunrast_decode_frame(AVCodecContext *avctx, void *data, <nl>              return AVERROR_INVALIDDATA; <nl>      } <nl>   <nl> -    if (w != avctx->width || h != avctx->height) <nl> -        avcodec_set_dimensions(avctx, w, h); <nl> +    ret = ff_set_dimensions(avctx, w, h); <nl> +    if (ret < 0) <nl> +        return ret; <nl> + <nl>      if ((ret = ff_get_buffer(avctx, p, 0)) < 0) { <nl>          av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n"); <nl>          return ret;
@@ -43,6 +43,7 @@ static int parse(AVCodecParserContext *ctx, <nl>                   const uint8_t *data, int size) <nl>  { <nl>      VP9ParseContext *s = ctx->priv_data; <nl> +    int full_size = size; <nl>      int marker; <nl>   <nl>      if (size <= 0) { <nl> @@ -77,12 +78,12 @@ static int parse(AVCodecParserContext *ctx, <nl>                      idx += a; \ <nl>                      if (sz > size) { \ <nl>                          s->n_frames = 0; \ <nl> -                        *out_size = 0; \ <nl> +                        *out_size = size; \ <nl>                          *out_data = data; \ <nl>                          av_log(avctx, AV_LOG_ERROR, \ <nl>                                 "Superframe packet size too big: %u > %d\n", \ <nl>                                 sz, size); \ <nl> -                        return size; \ <nl> +                        return full_size; \ <nl>                      } \ <nl>                      if (first) { \ <nl>                          first = 0; \
@@ -56,13 +56,14 @@ static int build_huff(const uint8_t *src, VLC *vlc, int *fsym) <nl>          *fsym = he[0].sym; <nl>          return 0; <nl>      } <nl> -    if (he[0].len > 32) <nl> -        return -1; <nl>   <nl>      last = 255; <nl>      while (he[last].len == 255 && last) <nl>          last--; <nl>   <nl> +    if (he[last].len > 32) <nl> +        return -1; <nl> + <nl>      code = 1; <nl>      for (i = last; i >= 0; i--) { <nl>          codes[i] = code >> (32 - he[i].len);
@@ -910,6 +910,8 @@ static int decode_codestream(J2kDecoderContext *s) <nl>          } <nl>   <nl>          marker = bytestream_get_be16(&s->buf); <nl> +        if(s->avctx->debug & FF_DEBUG_STARTCODE) <nl> +            av_log(s->avctx, AV_LOG_DEBUG, "marker 0x%.4X at pos 0x%x\n", marker, s->buf - s->buf_start - 4); <nl>          oldbuf = s->buf; <nl>   <nl>          if (marker == J2K_SOD){
@@ -153,7 +153,6 @@ static int decode_frame(AVCodecContext *avctx, <nl>   <nl>      bytestream2_init(&gbc, avpkt->data, avpkt->size); <nl>      if (   bytestream2_get_bytes_left(&gbc) >= 552 <nl> -           && !check_header(gbc.buffer      , bytestream2_get_bytes_left(&gbc)) <nl>             &&  check_header(gbc.buffer + 512, bytestream2_get_bytes_left(&gbc) - 512) <nl>         ) <nl>          bytestream2_skip(&gbc, 512);
@@ -470,16 +470,16 @@ int MPV_encode_picture(AVCodecContext *avctx, <nl>              h >>= 1; <nl>          } <nl>   <nl> -	if(s->intra_only && dest_wrap==src_wrap){ <nl> -	    s->current_picture[i] = pict->data[i]; <nl> +	if(dest_wrap==src_wrap){ <nl> +	    s->new_picture[i] = pict->data[i]; <nl>  	}else { <nl>              for(j=0;j<h;j++) { <nl>                  memcpy(dest, src, w); <nl>                  dest += dest_wrap; <nl>                  src += src_wrap; <nl>              } <nl> +            s->new_picture[i] = s->current_picture[i]; <nl>  	} <nl> -        s->new_picture[i] = s->current_picture[i]; <nl>      } <nl>   <nl>      encode_picture(s, s->picture_number);
@@ -1636,7 +1636,7 @@ static int read_interval_packets(WriterContext *w, AVFormatContext *fmt_ctx, <nl>      AVPacket pkt, pkt1; <nl>      AVFrame frame; <nl>      int ret = 0, i = 0, frame_count = 0; <nl> -    int64_t start, end = interval->end; <nl> +    int64_t start = -INT64_MAX, end = interval->end; <nl>      int has_start = 0, has_end = interval->has_end && !interval->end_is_offset; <nl>   <nl>      av_init_packet(&pkt);
@@ -996,6 +996,11 @@ static int tiff_decode_tag(TiffContext *s, AVFrame *frame) <nl>          bytestream2_skip(&pal_gb[2], count / 3 * off * 2); <nl>   <nl>          off = (type_sizes[type] - 1) << 3; <nl> +        if (off > 31U) { <nl> +            av_log(s->avctx, AV_LOG_ERROR, "palette shift %d is out of range\n", off); <nl> +            return AVERROR_INVALIDDATA; <nl> +        } <nl> + <nl>          for (i = 0; i < count / 3; i++) { <nl>              uint32_t p = 0xFF000000; <nl>              p |= (ff_tget(&pal_gb[0], type, s->le) >> off) << 16;
@@ -2527,7 +2527,7 @@ static int h264_slice_header_init(H264Context *h, int reinit) <nl>              return ret; <nl>          } <nl>      } else { <nl> -        if ((ret = ff_MPV_common_init(s) < 0)) { <nl> +        if ((ret = ff_MPV_common_init(s)) < 0) { <nl>              av_log(h->s.avctx, AV_LOG_ERROR, "ff_MPV_common_init() failed.\n"); <nl>              return ret; <nl>          }
@@ -32,6 +32,8 @@ typedef struct OggVorbisDecContext { <nl>      ogg_packet op;                      /**< ogg packet                     */ <nl>  } OggVorbisDecContext; <nl>   <nl> +static int oggvorbis_decode_close(AVCodecContext *avccontext); <nl> + <nl>  static int oggvorbis_decode_init(AVCodecContext *avccontext) { <nl>      OggVorbisDecContext *context = avccontext->priv_data ; <nl>      uint8_t *p= avccontext->extradata; <nl> @@ -110,8 +112,7 @@ static int oggvorbis_decode_init(AVCodecContext *avccontext) { <nl>      return 0 ; <nl>   <nl>    error: <nl> -    vorbis_info_clear(&context->vi); <nl> -    vorbis_comment_clear(&context->vc) ; <nl> +    oggvorbis_decode_close(avccontext); <nl>      return ret; <nl>  } <nl>   <nl> @@ -187,6 +188,8 @@ static int oggvorbis_decode_frame(AVCodecContext *avccontext, void *data, <nl>  static int oggvorbis_decode_close(AVCodecContext *avccontext) { <nl>      OggVorbisDecContext *context = avccontext->priv_data ; <nl>   <nl> +    vorbis_block_clear(&context->vb); <nl> +    vorbis_dsp_clear(&context->vd); <nl>      vorbis_info_clear(&context->vi) ; <nl>      vorbis_comment_clear(&context->vc) ; <nl>  
@@ -68,21 +68,25 @@ static int sunrast_decode_frame(AVCodecContext *avctx, void *data, <nl>      type      = AV_RB32(buf+20); <nl>      maptype   = AV_RB32(buf+24); <nl>      maplength = AV_RB32(buf+28); <nl> +    buf      += 32; <nl>   <nl>      if (type == RT_FORMAT_TIFF || type == RT_FORMAT_IFF) { <nl>          av_log(avctx, AV_LOG_ERROR, "unsupported (compression) type\n"); <nl>          return -1; <nl>      } <nl> -    if (type > RT_FORMAT_IFF) { <nl> +    if (type < RT_OLD || type > RT_FORMAT_IFF) { <nl>          av_log(avctx, AV_LOG_ERROR, "invalid (compression) type\n"); <nl>          return -1; <nl>      } <nl> +    if (av_image_check_size(w, h, 0, avctx)) { <nl> +        av_log(avctx, AV_LOG_ERROR, "invalid image size\n"); <nl> +        return -1; <nl> +    } <nl>      if (maptype & ~1) { <nl>          av_log(avctx, AV_LOG_ERROR, "invalid colormap type\n"); <nl>          return -1; <nl>      } <nl>   <nl> -    buf += 32; <nl>   <nl>      switch (depth) { <nl>          case 1: <nl> @@ -102,8 +106,6 @@ static int sunrast_decode_frame(AVCodecContext *avctx, void *data, <nl>      if (p->data[0]) <nl>          avctx->release_buffer(avctx, p); <nl>   <nl> -    if (av_image_check_size(w, h, 0, avctx)) <nl> -        return -1; <nl>      if (w != avctx->width || h != avctx->height) <nl>          avcodec_set_dimensions(avctx, w, h); <nl>      if (avctx->get_buffer(avctx, p) < 0) {
@@ -4267,8 +4267,7 @@ static void mov_write_uuidprof_tag(AVIOContext *pb, AVFormatContext *s) <nl>      AVCodecParameters *video_par = s->streams[0]->codecpar; <nl>      AVCodecParameters *audio_par = s->streams[1]->codecpar; <nl>      int audio_rate = audio_par->sample_rate; <nl> -    // TODO: should be avg_frame_rate <nl> -    int frame_rate = ((video_st->time_base.den) * (0x10000)) / (video_st->time_base.num); <nl> +    int64_t frame_rate = (video_st->avg_frame_rate.num * 0x10000LL) / video_st->avg_frame_rate.den; <nl>      int audio_kbitrate = audio_par->bit_rate / 1000; <nl>      int video_kbitrate = FFMIN(video_par->bit_rate / 1000, 800 - audio_kbitrate); <nl>  
@@ -191,7 +191,9 @@ static int lag_read_prob_header(lag_rac *rac, GetBitContext *gb) <nl>          } <nl>   <nl>          scale_factor++; <nl> -        cumulative_target = 1 << scale_factor; <nl> +        if (scale_factor >= 32U) <nl> +            return AVERROR_INVALIDDATA; <nl> +        cumulative_target = 1U << scale_factor; <nl>   <nl>          if (scaled_cumul_prob > cumulative_target) { <nl>              av_log(rac->avctx, AV_LOG_ERROR,
@@ -713,7 +713,7 @@ FF_ENABLE_DEPRECATION_WARNINGS <nl>      /* Encode a dummy frame to get the extradata immediately */ <nl>      if (x->quicktime_format) { <nl>          AVFrame *picture; <nl> -        AVPacket packet; <nl> +        AVPacket packet = {0}; <nl>          int size, got_packet, ret; <nl>   <nl>          av_init_packet(&packet);
@@ -276,7 +276,7 @@ static int decode_subframe_fixed(FLACContext *s, int channel, int pred_order) <nl>  { <nl>      const int blocksize = s->blocksize; <nl>      int32_t *decoded = s->decoded[channel]; <nl> -    int a, b, c, d, i; <nl> +    int av_uninit(a), av_uninit(b), av_uninit(c), av_uninit(d), i; <nl>   <nl>      /* warm up samples */ <nl>      for (i = 0; i < pred_order; i++) {
@@ -695,7 +695,7 @@ static int compat_decode(AVCodecContext *avctx, AVFrame *frame, <nl>                           int *got_frame, const AVPacket *pkt) <nl>  { <nl>      AVCodecInternal *avci = avctx->internal; <nl> -    int ret; <nl> +    int ret = 0; <nl>   <nl>      av_assert0(avci->compat_decode_consumed == 0); <nl>  
@@ -347,7 +347,8 @@ static void ra144_encode_subblock(RA144Context *ractx, <nl>      float zero[BLOCKSIZE], cba[BLOCKSIZE], cb1[BLOCKSIZE], cb2[BLOCKSIZE]; <nl>      int16_t cba_vect[BLOCKSIZE]; <nl>      int cba_idx, cb1_idx, cb2_idx, gain; <nl> -    int i, n, m[3]; <nl> +    int i, n; <nl> +    unsigned m[3]; <nl>      float g[3]; <nl>      float error, best_error; <nl>  
@@ -70,6 +70,11 @@ static int decode_frame(AVCodecContext *avctx, <nl>      int prev_y = 0, prev_u = 0, prev_v = 0; <nl>      uint8_t *rbuf; <nl>   <nl> +    if(buf_size<=8) { <nl> +        av_log(avctx, AV_LOG_ERROR, "buf_size %d is too small\n", buf_size); <nl> +        return AVERROR_INVALIDDATA; <nl> +    } <nl> + <nl>      rbuf = av_malloc(buf_size + FF_INPUT_BUFFER_PADDING_SIZE); <nl>      if(!rbuf){ <nl>          av_log(avctx, AV_LOG_ERROR, "Cannot allocate temporary buffer\n");
@@ -113,6 +113,8 @@ AVIOContext *avio_alloc_context( <nl>                    int64_t (*seek)(void *opaque, int64_t offset, int whence)) <nl>  { <nl>      AVIOContext *s = av_mallocz(sizeof(AVIOContext)); <nl> +    if (!s) <nl> +        return NULL; <nl>      ffio_init_context(s, buffer, buffer_size, write_flag, opaque, <nl>                    read_packet, write_packet, seek); <nl>      return s;
@@ -1274,6 +1274,9 @@ static av_cold int common_end(AVCodecContext *avctx){ <nl>      FFV1Context *s = avctx->priv_data; <nl>      int i, j; <nl>   <nl> +    if (avctx->codec->decode && s->picture.data[0]) <nl> +        avctx->release_buffer(avctx, &s->picture); <nl> + <nl>      for(j=0; j<s->slice_count; j++){ <nl>          FFV1Context *fs= s->slice_context[j]; <nl>          for(i=0; i<s->plane_count; i++){ <nl> @@ -1712,6 +1715,10 @@ static int decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPac <nl>   <nl>      AVFrame *picture = data; <nl>   <nl> +    /* release previously stored data */ <nl> +    if (p->data[0]) <nl> +        avctx->release_buffer(avctx, p); <nl> + <nl>      ff_init_range_decoder(c, buf, buf_size); <nl>      ff_build_rac_states(c, 0.05*(1LL<<32), 256-8); <nl>   <nl> @@ -1774,9 +1781,6 @@ static int decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPac <nl>      f->picture_number++; <nl>   <nl>      *picture= *p; <nl> - <nl> -    avctx->release_buffer(avctx, p); //FIXME <nl> - <nl>      *data_size = sizeof(AVFrame); <nl>   <nl>      return buf_size;
@@ -805,6 +805,7 @@ int check_stream_specifier(AVFormatContext *s, AVStream *st, const char *spec) <nl>          case 'a': type = AVMEDIA_TYPE_AUDIO;    break; <nl>          case 's': type = AVMEDIA_TYPE_SUBTITLE; break; <nl>          case 'd': type = AVMEDIA_TYPE_DATA;     break; <nl> +        default: abort(); // never reached, silence warning <nl>          } <nl>          if (type != st->codec->codec_type) <nl>              return 0;
@@ -398,8 +398,11 @@ static av_cold int init(AVFilterContext *ctx) <nl>              return err; <nl>          } <nl>   <nl> -        if (!(s->text = av_malloc(textbuf_size+1))) <nl> +        if (textbuf_size > SIZE_MAX - 1 || <nl> +            !(s->text = av_malloc(textbuf_size + 1))) { <nl> +            av_file_unmap(textbuf, textbuf_size); <nl>              return AVERROR(ENOMEM); <nl> +        } <nl>          memcpy(s->text, textbuf, textbuf_size); <nl>          s->text[textbuf_size] = 0; <nl>          av_file_unmap(textbuf, textbuf_size);
@@ -846,9 +846,9 @@ static int wavpack_decode_block(AVCodecContext *avctx, int block_no, <nl>                  continue; <nl>              } <nl>              bytestream2_get_buffer(&gb, val, 4); <nl> -            if (val[0] > 31) { <nl> +            if (val[0] > 30) { <nl>                  av_log(avctx, AV_LOG_ERROR, <nl> -                       "Invalid INT32INFO, extra_bits = %d (> 32)\n", val[0]); <nl> +                       "Invalid INT32INFO, extra_bits = %d (> 30)\n", val[0]); <nl>                  continue; <nl>              } else if (val[0]) { <nl>                  s->extra_bits = val[0];
@@ -90,6 +90,9 @@ enum AudioObjectType { <nl>      AOT_ER_AAC_ELD,            ///< N                       Error Resilient Enhanced Low Delay <nl>      AOT_SMR_SIMPLE,            ///< N                       Symbolic Music Representation Simple <nl>      AOT_SMR_MAIN,              ///< N                       Symbolic Music Representation Main <nl> +    AOT_USAC_NOSBR,            ///< N                       Unified Speech and Audio Coding (no SBR) <nl> +    AOT_SAOC,                  ///< N                       Spatial Audio Object Coding <nl> +    AOT_USAC             = 45, ///< N                       Unified Speech and Audio Coding <nl>  }; <nl>   <nl>  #define MAX_PCE_SIZE 304 ///<Maximum size of a PCE including the 3-bit ID_PCE
@@ -1763,8 +1763,10 @@ static int process_output_surface(AVCodecContext *avctx, AVPacket *pkt, NvencSur <nl>      } <nl>      slice_offsets = av_mallocz(slice_mode_data * sizeof(*slice_offsets)); <nl>   <nl> -    if (!slice_offsets) <nl> +    if (!slice_offsets) { <nl> +        res = AVERROR(ENOMEM); <nl>          goto error; <nl> +    } <nl>   <nl>      lock_params.version = NV_ENC_LOCK_BITSTREAM_VER; <nl>  
@@ -310,9 +310,9 @@ static void compute_rematrixing_strategy(AC3EncodeContext *s) <nl>   <nl>      nb_coefs = FFMIN(s->nb_coefs[0], s->nb_coefs[1]); <nl>   <nl> -    s->blocks[0].new_rematrixing_strategy = 1; <nl>      for (blk = 0; blk < AC3_MAX_BLOCKS; blk++) { <nl>          block = &s->blocks[blk]; <nl> +        block->new_rematrixing_strategy = !blk; <nl>          for (bnd = 0; bnd < 4; bnd++) { <nl>              /* calculate calculate sum of squared coeffs for one band in one block */ <nl>              int start = ff_ac3_rematrix_band_tab[bnd]; <nl> @@ -337,7 +337,6 @@ static void compute_rematrixing_strategy(AC3EncodeContext *s) <nl>   <nl>              /* determine if new rematrixing flags will be sent */ <nl>              if (blk && <nl> -                !block->new_rematrixing_strategy && <nl>                  block->rematrixing_flags[bnd] != block0->rematrixing_flags[bnd]) { <nl>                  block->new_rematrixing_strategy = 1; <nl>              }
@@ -52,8 +52,8 @@ static void CONV_FUNC_NAME(ofmt, ifmt)(uint8_t *po, const uint8_t *pi, int is, i <nl>   <nl>  //FIXME put things below under ifdefs so we do not waste space for cases no codec will need <nl>  CONV_FUNC(AV_SAMPLE_FMT_U8 , uint8_t, AV_SAMPLE_FMT_U8 ,  *(const uint8_t*)pi) <nl> -CONV_FUNC(AV_SAMPLE_FMT_S16, int16_t, AV_SAMPLE_FMT_U8 , (*(const uint8_t*)pi - 0x80)<<8) <nl> -CONV_FUNC(AV_SAMPLE_FMT_S32, int32_t, AV_SAMPLE_FMT_U8 , (*(const uint8_t*)pi - 0x80)<<24) <nl> +CONV_FUNC(AV_SAMPLE_FMT_S16, int16_t, AV_SAMPLE_FMT_U8 , (*(const uint8_t*)pi - 0x80U)<<8) <nl> +CONV_FUNC(AV_SAMPLE_FMT_S32, int32_t, AV_SAMPLE_FMT_U8 , (*(const uint8_t*)pi - 0x80U)<<24) <nl>  CONV_FUNC(AV_SAMPLE_FMT_FLT, float  , AV_SAMPLE_FMT_U8 , (*(const uint8_t*)pi - 0x80)*(1.0f/ (1<<7))) <nl>  CONV_FUNC(AV_SAMPLE_FMT_DBL, double , AV_SAMPLE_FMT_U8 , (*(const uint8_t*)pi - 0x80)*(1.0 / (1<<7))) <nl>  CONV_FUNC(AV_SAMPLE_FMT_U8 , uint8_t, AV_SAMPLE_FMT_S16, (*(const int16_t*)pi>>8) + 0x80)
@@ -1805,10 +1805,16 @@ static int hls_coding_quadtree(HEVCContext *s, int x0, int y0, <nl>          if (more_data < 0) <nl>              return more_data; <nl>   <nl> -        if (more_data && x1 < s->sps->width) <nl> +        if (more_data && x1 < s->sps->width) { <nl>              more_data = hls_coding_quadtree(s, x1, y0, log2_cb_size - 1, cb_depth + 1); <nl> -        if (more_data && y1 < s->sps->height) <nl> +            if (more_data < 0) <nl> +                return more_data; <nl> +        } <nl> +        if (more_data && y1 < s->sps->height) { <nl>              more_data = hls_coding_quadtree(s, x0, y1, log2_cb_size - 1, cb_depth + 1); <nl> +            if (more_data < 0) <nl> +                return more_data; <nl> +        } <nl>          if (more_data && x1 < s->sps->width && <nl>              y1 < s->sps->height) { <nl>              return hls_coding_quadtree(s, x1, y1, log2_cb_size - 1, cb_depth + 1);
@@ -593,6 +593,11 @@ av_cold int ff_msmpeg4_decode_init(AVCodecContext *avctx) <nl>      int i; <nl>      MVTable *mv; <nl>   <nl> +    if(avctx->width<=0 || avctx->height<=0) { <nl> +        av_log(avctx, AV_LOG_ERROR, "invalid dimensions\n"); <nl> +        return -1; <nl> +    } <nl> + <nl>      if (ff_h263_decode_init(avctx) < 0) <nl>          return -1; <nl>  
@@ -39,12 +39,15 @@ static av_cold int ptx_init(AVCodecContext *avctx) { <nl>  static int ptx_decode_frame(AVCodecContext *avctx, void *data, int *data_size, <nl>                              AVPacket *avpkt) { <nl>      const uint8_t *buf = avpkt->data; <nl> +    const uint8_t *buf_end = avpkt->data + avpkt->size; <nl>      PTXContext * const s = avctx->priv_data; <nl>      AVFrame *picture = data; <nl>      AVFrame * const p = &s->picture; <nl>      unsigned int offset, w, h, y, stride, bytes_per_pixel; <nl>      uint8_t *ptr; <nl>   <nl> +    if (buf_end - buf < 14) <nl> +        return AVERROR_INVALIDDATA; <nl>      offset          = AV_RL16(buf); <nl>      w               = AV_RL16(buf+8); <nl>      h               = AV_RL16(buf+10); <nl> @@ -57,6 +60,9 @@ static int ptx_decode_frame(AVCodecContext *avctx, void *data, int *data_size, <nl>   <nl>      avctx->pix_fmt = PIX_FMT_RGB555; <nl>   <nl> + <nl> +    if (buf_end - buf < offset) <nl> +        return AVERROR_INVALIDDATA; <nl>      if (offset != 0x2c) <nl>          av_log_ask_for_sample(avctx, "offset != 0x2c\n"); <nl>   <nl> @@ -80,6 +86,8 @@ static int ptx_decode_frame(AVCodecContext *avctx, void *data, int *data_size, <nl>      stride = p->linesize[0]; <nl>   <nl>      for (y=0; y<h; y++) { <nl> +        if (buf_end - buf < w * bytes_per_pixel) <nl> +            break; <nl>  #if HAVE_BIGENDIAN <nl>          unsigned int x; <nl>          for (x=0; x<w*bytes_per_pixel; x+=bytes_per_pixel)
@@ -2053,6 +2053,7 @@ static int matroska_parse_block(MatroskaDemuxContext *matroska, uint8_t *data, <nl>                      offset = matroska_decode_buffer(&pkt_data,&pkt_size, track); <nl>                      if (offset < 0) <nl>                          continue; <nl> +                    av_assert0(offset + pkt_size >= pkt_size); <nl>                  } <nl>   <nl>                  pkt = av_mallocz(sizeof(AVPacket));
@@ -220,7 +220,9 @@ int ff_listen_bind(int fd, const struct sockaddr *addr, <nl>      int ret; <nl>      int reuse = 1; <nl>      struct pollfd lp = { fd, POLLIN, 0 }; <nl> -    setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(reuse)); <nl> +    if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(reuse))) { <nl> +        av_log(NULL, AV_LOG_WARNING, "setsockopt(SO_REUSEADDR) failed\n"); <nl> +    } <nl>      ret = bind(fd, addr, addrlen); <nl>      if (ret) <nl>          return ff_neterrno();
@@ -138,6 +138,10 @@ static av_cold int vqa_decode_init(AVCodecContext *avctx) <nl>      /* load up the VQA parameters from the header */ <nl>      vqa_header = (unsigned char *)s->avctx->extradata; <nl>      s->vqa_version = vqa_header[0]; <nl> +    if (s->vqa_version < 1 || s->vqa_version > 3) { <nl> +        av_log(s->avctx, AV_LOG_ERROR, "  VQA video: unsupported version %d\n", s->vqa_version); <nl> +        return -1; <nl> +    } <nl>      s->width = AV_RL16(&vqa_header[6]); <nl>      s->height = AV_RL16(&vqa_header[8]); <nl>      if(av_image_check_size(s->width, s->height, 0, avctx)){
@@ -376,6 +376,11 @@ static int encode_superframe(AVCodecContext *avctx, AVPacket *avpkt, <nl>   <nl>      while(total_gain <= 128 && error > 0) <nl>          error = encode_frame(s, s->coefs, avpkt->data, avpkt->size, total_gain++); <nl> +    if (error > 0) { <nl> +        av_log(avctx, AV_LOG_ERROR, "Invalid input data or requested bitrate too low, cannot encode\n"); <nl> +        avpkt->size = 0; <nl> +        return AVERROR(EINVAL); <nl> +    } <nl>      av_assert0((put_bits_count(&s->pb) & 7) == 0); <nl>      i= avctx->block_align - (put_bits_count(&s->pb)+7)/8; <nl>      av_assert0(i>=0);
@@ -575,7 +575,7 @@ static int Rgb16ToPlanarRgb16Wrapper(SwsContext *c, const uint8_t *src[], <nl>      case AV_PIX_FMT_RGB48BE: <nl>      case AV_PIX_FMT_RGBA64LE: <nl>      case AV_PIX_FMT_RGBA64BE: <nl> -        packed16togbra16(src[0] + srcSliceY * srcStride[0], srcStride[0], <nl> +        packed16togbra16(src[0], srcStride[0], <nl>                           dst2013, stride2013, srcSliceH, alpha, swap, <nl>                           16 - bpc, c->srcW); <nl>          break; <nl> @@ -583,7 +583,7 @@ static int Rgb16ToPlanarRgb16Wrapper(SwsContext *c, const uint8_t *src[], <nl>      case AV_PIX_FMT_BGR48BE: <nl>      case AV_PIX_FMT_BGRA64LE: <nl>      case AV_PIX_FMT_BGRA64BE: <nl> -        packed16togbra16(src[0] + srcSliceY * srcStride[0], srcStride[0], <nl> +        packed16togbra16(src[0], srcStride[0], <nl>                           dst1023, stride1023, srcSliceH, alpha, swap, <nl>                           16 - bpc, c->srcW); <nl>          break;
@@ -299,6 +299,8 @@ int ff_init_vlc_sparse(VLC *vlc, int nb_bits, int nb_codes, <nl>      av_dlog(NULL, "build table nb_codes=%d\n", nb_codes); <nl>   <nl>      buf = av_malloc((nb_codes + 1) * sizeof(VLCcode)); <nl> +    if (!buf) <nl> +        return AVERROR(ENOMEM); <nl>   <nl>      av_assert0(symbols_size <= 2 || !symbols); <nl>      j = 0;
@@ -330,7 +330,7 @@ static int gdv_decode_frame(AVCodecContext *avctx, void *data, <nl>              unsigned r = bytestream2_get_byte(gb); <nl>              unsigned g = bytestream2_get_byte(gb); <nl>              unsigned b = bytestream2_get_byte(gb); <nl> -            gdv->pal[i] = 0xFF << 24 | r << 18 | g << 10 | b << 2; <nl> +            gdv->pal[i] = 0xFFU << 24 | r << 18 | g << 10 | b << 2; <nl>          } <nl>          break; <nl>      case 3:
@@ -117,8 +117,8 @@ int ff_h261_handle_packet(AVFormatContext *ctx, PayloadContext *data, <nl>      sbit  =  (buf[0] >> 5) & 0x07; <nl>      ebit  =  (buf[0] >> 2) & 0x07; <nl>      gobn  =  (buf[1] >> 4) & 0x0f; <nl> -    mbap  = ((buf[1] << 1) & 0x1e) | ((buf[1] >> 7) & 0x01); <nl> -    quant =  (buf[1] >> 4) & 0x0f; <nl> +    mbap  = ((buf[1] << 1) & 0x1e) | ((buf[2] >> 7) & 0x01); <nl> +    quant =  (buf[2] >> 2) & 0x1f; <nl>   <nl>      /* pass the H.261 payload header and continue with the actual payload */ <nl>      buf += RTP_H261_PAYLOAD_HEADER_SIZE;
@@ -917,6 +917,9 @@ pp_context *pp_get_context(int width, int height, int cpuCaps){ <nl>      int stride= FFALIGN(width, 16);  //assumed / will realloc if needed <nl>      int qpStride= (width+15)/16 + 2; //assumed / will realloc if needed <nl>   <nl> +    if (!c) <nl> +        return NULL; <nl> + <nl>      c->av_class = &av_codec_context_class; <nl>      if(cpuCaps&PP_FORMAT){ <nl>          c->hChromaSubSample= cpuCaps&0x3;
@@ -2275,7 +2275,9 @@ static int http_prepare_data(HTTPContext *c) <nl>      av_freep(&c->pb_buffer); <nl>      switch(c->state) { <nl>      case HTTPSTATE_SEND_DATA_HEADER: <nl> -        memset(&c->fmt_ctx, 0, sizeof(c->fmt_ctx)); <nl> +        ctx = avformat_alloc_context(); <nl> +        c->fmt_ctx = *ctx; <nl> +        av_freep(&ctx); <nl>          av_dict_copy(&(c->fmt_ctx.metadata), c->stream->metadata, 0); <nl>          c->fmt_ctx.streams = av_mallocz(sizeof(AVStream *) * c->stream->nb_streams); <nl>   <nl> @@ -3818,7 +3820,7 @@ static void build_feed_streams(void) <nl>              } <nl>          } <nl>          if (avio_check(feed->feed_filename, AVIO_FLAG_WRITE) <= 0) { <nl> -            AVFormatContext s1 = {0}, *s = &s1; <nl> +            AVFormatContext *s = avformat_alloc_context(); <nl>   <nl>              if (feed->readonly) { <nl>                  http_log("Unable to create feed file '%s' as it is marked readonly\n", <nl> @@ -3842,6 +3844,9 @@ static void build_feed_streams(void) <nl>              /* XXX: need better api */ <nl>              av_freep(&s->priv_data); <nl>              avio_close(s->pb); <nl> +            s->streams = NULL; <nl> +            s->nb_streams = 0; <nl> +            avformat_free_context(s); <nl>          } <nl>          /* get feed size and write index */ <nl>          fd = open(feed->feed_filename, O_RDONLY);
@@ -488,7 +488,7 @@ static void dwt_decode97_int(DWTContext *s, int32_t *t) <nl>      line += 5; <nl>   <nl>      for (i = 0; i < w * h; i++) <nl> -        data[i] <<= I_PRESHIFT; <nl> +        data[i] *= 1 << I_PRESHIFT; <nl>   <nl>      for (lev = 0; lev < s->ndeclevels; lev++) { <nl>          int lh = s->linelen[lev][0],
@@ -522,8 +522,8 @@ int ff_generate_sliding_window_mmcos(H264Context *h, int first_slice) <nl>                 (mmco_index != h->mmco_index || <nl>                  (i = check_opcodes(h->mmco, mmco_temp, mmco_index)))) { <nl>          av_log(h->s.avctx, AV_LOG_ERROR, <nl> -               "Inconsistent MMCO state between slices [%d, %d, %d]\n", <nl> -               mmco_index, h->mmco_index, i); <nl> +               "Inconsistent MMCO state between slices [%d, %d]\n", <nl> +               mmco_index, h->mmco_index); <nl>          return AVERROR_INVALIDDATA; <nl>      } <nl>      return 0;
@@ -487,7 +487,10 @@ static int mxf_read_partition_pack(void *arg, AVIOContext *pb, int tag, int size <nl>      partition->index_sid = avio_rb32(pb); <nl>      avio_skip(pb, 8); <nl>      partition->body_sid = avio_rb32(pb); <nl> -    avio_read(pb, op, sizeof(UID)); <nl> +    if (avio_read(pb, op, sizeof(UID)) != sizeof(UID)) { <nl> +        av_log(mxf->fc, AV_LOG_ERROR, "Failed reading UID\n"); <nl> +        return AVERROR_INVALIDDATA; <nl> +    } <nl>      nb_essence_containers = avio_rb32(pb); <nl>   <nl>      /* some files don'thave FooterPartition set in every partition */
@@ -73,6 +73,7 @@ typedef struct FifoContext { <nl>      int restart_with_keyframe; <nl>   <nl>      pthread_mutex_t overflow_flag_lock; <nl> +    int overflow_flag_lock_initialized; <nl>      /* Value > 0 signals queue overflow */ <nl>      volatile uint8_t overflow_flag; <nl>   <nl> @@ -515,6 +516,7 @@ static int fifo_init(AVFormatContext *avf) <nl>      ret = pthread_mutex_init(&fifo->overflow_flag_lock, NULL); <nl>      if (ret < 0) <nl>          return AVERROR(ret); <nl> +    fifo->overflow_flag_lock_initialized = 1; <nl>   <nl>      return 0; <nl>  } <nl> @@ -601,7 +603,8 @@ static void fifo_deinit(AVFormatContext *avf) <nl>      av_dict_free(&fifo->format_options); <nl>      avformat_free_context(fifo->avf); <nl>      av_thread_message_queue_free(&fifo->queue); <nl> -    pthread_mutex_destroy(&fifo->overflow_flag_lock); <nl> +    if (fifo->overflow_flag_lock_initialized) <nl> +        pthread_mutex_destroy(&fifo->overflow_flag_lock); <nl>  } <nl>   <nl>  #define OFFSET(x) offsetof(FifoContext, x)
@@ -883,6 +883,12 @@ int ff_hevc_parse_sps(HEVCSPS *sps, GetBitContext *gb, unsigned int *sps_id, <nl>      sps->long_term_ref_pics_present_flag = get_bits1(gb); <nl>      if (sps->long_term_ref_pics_present_flag) { <nl>          sps->num_long_term_ref_pics_sps = get_ue_golomb_long(gb); <nl> +        if (sps->num_long_term_ref_pics_sps > HEVC_MAX_LONG_TERM_REF_PICS) { <nl> +            av_log(avctx, AV_LOG_ERROR, "Too many long term ref pics: %d.\n", <nl> +                   sps->num_long_term_ref_pics_sps); <nl> +            ret = AVERROR_INVALIDDATA; <nl> +            goto err; <nl> +        } <nl>          for (i = 0; i < sps->num_long_term_ref_pics_sps; i++) { <nl>              sps->lt_ref_pic_poc_lsb_sps[i]       = get_bits(gb, sps->log2_max_poc_lsb); <nl>              sps->used_by_curr_pic_lt_sps_flag[i] = get_bits1(gb);
@@ -430,7 +430,7 @@ static int oma_read_packet(AVFormatContext *s, AVPacket *pkt) <nl>   <nl>      pkt->stream_index = 0; <nl>   <nl> -    if (pos > 0) { <nl> +    if (pos > 0 && byte_rate > 0) { <nl>          pkt->pts = <nl>          pkt->dts = av_rescale(pos, st->time_base.den, <nl>                                byte_rate * (int64_t)st->time_base.num);
@@ -196,8 +196,8 @@ static int parse_keyframes_index(AVFormatContext *s, AVIOContext *ioc, AVStream <nl>          } <nl>      } <nl>   <nl> -    if (timeslen == fileposlen) <nl> -         for(i = 0; i < arraylen; i++) <nl> +    if (!ret && timeslen == fileposlen) <nl> +         for (i = 0; i < fileposlen; i++) <nl>               av_add_index_entry(vstream, filepositions[i], times[i]*1000, 0, 0, AVINDEX_KEYFRAME); <nl>      else <nl>          av_log(s, AV_LOG_WARNING, "Invalid keyframes object, skipping.\n");
@@ -139,9 +139,10 @@ int swr_convert_frame(SwrContext *s, <nl>   <nl>      if (out) { <nl>          if (!out->linesize[0]) { <nl> -            out->nb_samples =   swr_get_delay(s, s->out_sample_rate) <nl> -                              + in->nb_samples*(int64_t)s->out_sample_rate / s->in_sample_rate <nl> -                              + 3; <nl> +            out->nb_samples = swr_get_delay(s, s->out_sample_rate) + 3; <nl> +            if (in) { <nl> +                out->nb_samples += in->nb_samples*(int64_t)s->out_sample_rate / s->in_sample_rate; <nl> +            } <nl>              if ((ret = av_frame_get_buffer(out, 0)) < 0) { <nl>                  if (setup) <nl>                      swr_close(s);
@@ -2052,12 +2052,12 @@ the_end: <nl>                  h = FF_CEIL_RSHIFT(h, vshift); <nl>              } <nl>              if(dst){ <nl> -                uint8_t *dst2 = dst + s->linesize[index]*(h-1); <nl> +                uint8_t *dst2 = dst + s->picture_ptr->linesize[index]*(h-1); <nl>                  for (i=0; i<h/2; i++) { <nl>                      for (j=0; j<w; j++) <nl>                          FFSWAP(int, dst[j], dst2[j]); <nl> -                    dst  += s->linesize[index]; <nl> -                    dst2 -= s->linesize[index]; <nl> +                    dst  += s->picture_ptr->linesize[index]; <nl> +                    dst2 -= s->picture_ptr->linesize[index]; <nl>                  } <nl>              } <nl>          }
@@ -32,6 +32,9 @@ static int noise(AVBitStreamFilterContext *bsfc, AVCodecContext *avctx, const ch <nl>      int amount= args ? atoi(args) : (*state % 10001+1); <nl>      int i; <nl>   <nl> +    if(amount <= 0) <nl> +        return AVERROR(EINVAL); <nl> + <nl>      *poutbuf= av_malloc(buf_size + FF_INPUT_BUFFER_PADDING_SIZE); <nl>   <nl>      memcpy(*poutbuf, buf, buf_size + FF_INPUT_BUFFER_PADDING_SIZE);
@@ -2438,14 +2438,13 @@ static int http_start_receive_data(HTTPContext *c) <nl>          ftruncate(c->feed_fd, FFM_PACKET_SIZE); <nl>          http_log("Truncating feed file '%s'\n", c->stream->feed_filename); <nl>      } else { <nl> -    if ((c->stream->feed_write_index = ffm_read_write_index(fd)) < 0) { <nl> -        http_log("Error reading write index from feed file: %s\n", strerror(errno)); <nl> -        return -1; <nl> -    } <nl> +        if ((c->stream->feed_write_index = ffm_read_write_index(fd)) < 0) { <nl> +            http_log("Error reading write index from feed file: %s\n", strerror(errno)); <nl> +            return -1; <nl> +        } <nl>      } <nl>   <nl>      c->stream->feed_write_index = FFMAX(ffm_read_write_index(fd), FFM_PACKET_SIZE); <nl> - <nl>      c->stream->feed_size = lseek(fd, 0, SEEK_END); <nl>      lseek(fd, 0, SEEK_SET); <nl>  
@@ -158,7 +158,7 @@ static int decode_frame(AVCodecContext *avctx, <nl>      AVFrame *const p = &s->picture; <nl>      uint8_t *ptr; <nl>   <nl> -    int x, y, stride, magic_number, version_flag; <nl> +    int i, x, y, stride, magic_number, version_flag; <nl>      int w = 0; <nl>      int h = 0; <nl>      unsigned int xmin   = ~0; <nl> @@ -329,7 +329,7 @@ static int decode_frame(AVCodecContext *avctx, <nl>          } <nl>   <nl>          // Process unknown variables <nl> -        for (int i = 0; i < 2; i++) { <nl> +        for (i = 0; i < 2; i++) { <nl>              // Skip variable name/type <nl>              while (++buf < buf_end) <nl>                  if (buf[0] == 0x0)
@@ -203,6 +203,8 @@ static void qpeg_decode_inter(const uint8_t *src, uint8_t *dst, int size, <nl>                      filled = 0; <nl>                      dst -= stride; <nl>                      height--; <nl> +                    if(height < 0) <nl> +                        break; <nl>                  } <nl>              } <nl>          } else if(code >= 0xC0) { /* copy code: 0xC0..0xDF */ <nl> @@ -214,6 +216,8 @@ static void qpeg_decode_inter(const uint8_t *src, uint8_t *dst, int size, <nl>                      filled = 0; <nl>                      dst -= stride; <nl>                      height--; <nl> +                    if(height < 0) <nl> +                        break; <nl>                  } <nl>              } <nl>              size -= code + 1;
@@ -20,7 +20,10 @@ <nl>   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA <nl>   */ <nl>   <nl> +#include <stddef.h> <nl> + <nl>  #include "config.h" <nl> +#include "libavutil/error.h" <nl>  #include "libavutil/mem.h" <nl>   <nl>  #include "d3d11va.h" <nl> @@ -28,6 +31,8 @@ <nl>  AVD3D11VAContext *av_d3d11va_alloc_context(void) <nl>  { <nl>      AVD3D11VAContext* res = av_mallocz(sizeof(AVD3D11VAContext)); <nl> +    if (!res) <nl> +        return NULL; <nl>      res->context_mutex = INVALID_HANDLE_VALUE; <nl>      return res; <nl>  }
@@ -831,11 +831,13 @@ static av_always_inline int mvd_decode(HEVCContext *s) <nl>      int k = 1; <nl>   <nl>      while (k < CABAC_MAX_BIN && get_cabac_bypass(&s->HEVClc->cc)) { <nl> -        ret += 1 << k; <nl> +        ret += 1U << k; <nl>          k++; <nl>      } <nl> -    if (k == CABAC_MAX_BIN) <nl> +    if (k == CABAC_MAX_BIN) { <nl>          av_log(s->avctx, AV_LOG_ERROR, "CABAC_MAX_BIN : %d\n", k); <nl> +        return 0; <nl> +    } <nl>      while (k--) <nl>          ret += get_cabac_bypass(&s->HEVClc->cc) << k; <nl>      return get_cabac_bypass_sign(&s->HEVClc->cc, -ret); <nl> @@ -973,8 +975,10 @@ static av_always_inline int coeff_abs_level_remaining_decode(HEVCContext *s, int <nl>   <nl>      while (prefix < CABAC_MAX_BIN && get_cabac_bypass(&s->HEVClc->cc)) <nl>          prefix++; <nl> -    if (prefix == CABAC_MAX_BIN) <nl> +    if (prefix == CABAC_MAX_BIN) { <nl>          av_log(s->avctx, AV_LOG_ERROR, "CABAC_MAX_BIN : %d\n", prefix); <nl> +        return 0; <nl> +    } <nl>      if (prefix < 3) { <nl>          for (i = 0; i < rc_rice_param; i++) <nl>              suffix = (suffix << 1) | get_cabac_bypass(&s->HEVClc->cc);
@@ -242,6 +242,10 @@ static int ape_read_header(AVFormatContext * s, AVFormatParameters * ap) <nl>              avio_seek(pb, ape->wavheaderlength, SEEK_CUR); <nl>      } <nl>   <nl> +    if(!ape->totalframes){ <nl> +        av_log(s, AV_LOG_ERROR, "No frames in the file!\n"); <nl> +        return AVERROR(EINVAL); <nl> +    } <nl>      if(ape->totalframes > UINT_MAX / sizeof(APEFrame)){ <nl>          av_log(s, AV_LOG_ERROR, "Too many frames: %d\n", ape->totalframes); <nl>          return -1;
@@ -460,8 +460,8 @@ static uint8_t *bgmc_lut_getp(uint8_t *lut, int *lut_status, int delta) <nl>  av_cold int ff_bgmc_init(AVCodecContext *avctx, <nl>                           uint8_t **cf_lut, int **cf_lut_status) <nl>  { <nl> -    *cf_lut        = av_malloc(sizeof(*cf_lut)        * LUT_BUFF * 16 * LUT_SIZE); <nl> -    *cf_lut_status = av_malloc(sizeof(*cf_lut_status) * LUT_BUFF); <nl> +    *cf_lut        = av_malloc(sizeof(**cf_lut)        * LUT_BUFF * 16 * LUT_SIZE); <nl> +    *cf_lut_status = av_malloc(sizeof(**cf_lut_status) * LUT_BUFF); <nl>   <nl>      if (!*cf_lut || !*cf_lut_status) { <nl>          ff_bgmc_end(cf_lut, cf_lut_status); <nl> @@ -469,7 +469,7 @@ av_cold int ff_bgmc_init(AVCodecContext *avctx, <nl>          return AVERROR(ENOMEM); <nl>      } else { <nl>          // initialize lut_status buffer to a value never used to compare against <nl> -        memset(*cf_lut_status, -1, sizeof(*cf_lut_status) * LUT_BUFF); <nl> +        memset(*cf_lut_status, -1, sizeof(**cf_lut_status) * LUT_BUFF); <nl>      } <nl>   <nl>      return 0;
@@ -184,6 +184,8 @@ static int thp_read_packet(AVFormatContext *s, <nl>          pkt->stream_index = thp->video_stream_index; <nl>      } else { <nl>          ret = av_get_packet(pb, pkt, thp->audiosize); <nl> +        if (ret < 0) <nl> +            return ret; <nl>          if (ret != thp->audiosize) { <nl>              av_free_packet(pkt); <nl>              return AVERROR(EIO);
@@ -207,6 +207,12 @@ static int dv_extract_audio_info(DVDemuxContext* c, uint8_t* frame) <nl>      stype = (as_pack[3] & 0x1f);      /* 0 - 2CH, 2 - 4CH, 3 - 8CH */ <nl>      quant =  as_pack[4] & 0x07;       /* 0 - 16bit linear, 1 - 12bit nonlinear */ <nl>   <nl> +    if (stype > 3) { <nl> +        av_log(c->fctx, AV_LOG_ERROR, "stype %d is invalid\n", stype); <nl> +        c->ach = 0; <nl> +        return 0; <nl> +    } <nl> + <nl>      /* note: ach counts PAIRS of channels (i.e. stereo channels) */ <nl>      ach = ((int[4]){  1,  0,  2,  4})[stype]; <nl>      if (ach == 1 && quant && freq == 2)
@@ -224,10 +224,13 @@ static int tiff_unpack_strip(TiffContext *s, uint8_t *dst, int stride, <nl>              break; <nl>          case TIFF_PACKBITS: <nl>              for (pixels = 0; pixels < width;) { <nl> +                if (ssrc + size - src < 2) <nl> +                    return AVERROR_INVALIDDATA; <nl>                  code = (int8_t) *src++; <nl>                  if (code >= 0) { <nl>                      code++; <nl> -                    if (pixels + code > width) { <nl> +                    if (pixels + code > width || <nl> +                        ssrc + size - src < code) { <nl>                          av_log(s->avctx, AV_LOG_ERROR, <nl>                                 "Copy went out of bounds\n"); <nl>                          return AVERROR_INVALIDDATA;
@@ -3156,11 +3156,11 @@ static int fill_default_ref_list(H264Context *h){ <nl>       <nl>      if(h->slice_type==B_TYPE){ <nl>          int out_i; <nl> -        int limit= -1; <nl> +        int limit= INT_MIN; <nl>   <nl>          /* sort frame according to poc in B slice */ <nl>          for(out_i=0; out_i<h->short_ref_count; out_i++){ <nl> -            int best_i=-1; <nl> +            int best_i=INT_MIN; <nl>              int best_poc=INT_MAX; <nl>   <nl>              for(i=0; i<h->short_ref_count; i++){ <nl> @@ -3171,7 +3171,7 @@ static int fill_default_ref_list(H264Context *h){ <nl>                  } <nl>              } <nl>               <nl> -            assert(best_i != -1); <nl> +            assert(best_i != INT_MIN); <nl>               <nl>              limit= best_poc; <nl>              sorted_short_ref[out_i]= *h->short_ref[best_i];
@@ -264,8 +264,8 @@ static av_always_inline int sbr_hf_apply_noise(int (*Y)[2], <nl>      int m; <nl>   <nl>      for (m = 0; m < m_max; m++) { <nl> -        int y0 = Y[m][0]; <nl> -        int y1 = Y[m][1]; <nl> +        unsigned y0 = Y[m][0]; <nl> +        unsigned y1 = Y[m][1]; <nl>          noise = (noise + 1) & 0x1ff; <nl>          if (s_m[m].mant) { <nl>              int shift, round;
@@ -387,7 +387,7 @@ static int filter_frame(AVFilterLink *inlink, AVFrame *buf) <nl>          av_frame_free(&buf); <nl>   <nl>  end: <nl> -    vol->var_values[VAR_NB_CONSUMED_SAMPLES] += buf->nb_samples; <nl> +    vol->var_values[VAR_NB_CONSUMED_SAMPLES] += out_buf->nb_samples; <nl>      return ff_filter_frame(outlink, out_buf); <nl>  } <nl>  
@@ -424,9 +424,9 @@ int ff_jpeg2000_init_component(Jpeg2000Component *comp, <nl>                  if (!prec->zerobits) <nl>                      return AVERROR(ENOMEM); <nl>   <nl> -                prec->cblk = av_malloc_array(prec->nb_codeblocks_width * <nl> -                                             (uint64_t)prec->nb_codeblocks_height, <nl> -                                             sizeof(*prec->cblk)); <nl> +                prec->cblk = av_mallocz_array(prec->nb_codeblocks_width * <nl> +                                              (uint64_t)prec->nb_codeblocks_height, <nl> +                                              sizeof(*prec->cblk)); <nl>                  if (!prec->cblk) <nl>                      return AVERROR(ENOMEM); <nl>                  for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) {
@@ -1157,7 +1157,7 @@ static int ljpeg_decode_yuv_scan(MJpegDecodeContext *s, int predictor, <nl>                              if (s->interlaced && s->bottom_field) <nl>                                  ptr16 += linesize >> 1; <nl>                              pred &= mask; <nl> -                            *ptr16= pred + (dc << point_transform); <nl> +                            *ptr16= pred + ((unsigned)dc << point_transform); <nl>                          } <nl>                          if (++x == h) { <nl>                              x = 0;
@@ -2047,9 +2047,9 @@ static int get_delayed_pic(DiracContext *s, AVFrame *picture, int *got_frame) <nl>   <nl>      if (out) { <nl>          out->reference ^= DELAYED_PIC_REF; <nl> -        *got_frame = 1; <nl>          if((ret = av_frame_ref(picture, out->avframe)) < 0) <nl>              return ret; <nl> +        *got_frame = 1; <nl>      } <nl>   <nl>      return 0;
@@ -2185,7 +2185,7 @@ static int recode_subtitle(AVCodecContext *avctx, <nl>          goto end; <nl>      } <nl>      outpkt->size -= outl; <nl> -    outpkt->data[outpkt->size - 1] = '\0'; <nl> +    memset(outpkt->data + outpkt->size, 0, outl); <nl>   <nl>  end: <nl>      if (cd != (iconv_t)-1)
@@ -657,6 +657,10 @@ FF_ENABLE_DEPRECATION_WARNINGS <nl>  static int write_packet(AVFormatContext *s, AVPacket *pkt) <nl>  { <nl>      int ret, did_split; <nl> +    int64_t pts_backup, dts_backup; <nl> + <nl> +    pts_backup = pkt->pts; <nl> +    dts_backup = pkt->dts; <nl>   <nl>      if (s->output_ts_offset) { <nl>          AVStream *st = s->streams[pkt->stream_index]; <nl> @@ -743,6 +747,11 @@ fail: <nl>      if (did_split) <nl>          av_packet_merge_side_data(pkt); <nl>   <nl> +    if (ret < 0) { <nl> +        pkt->pts = pts_backup; <nl> +        pkt->dts = dts_backup; <nl> +    } <nl> + <nl>      return ret; <nl>  } <nl>  
@@ -280,7 +280,7 @@ static void ff_eac3_decode_transform_coeffs_aht_ch(AC3DecodeContext *s, int ch) <nl>                      mant += ((ff_eac3_gaq_remap_2_4_a[hebap-8][log_gain-1] * (int64_t)mant) >> 15) + b; <nl>                  } else { <nl>                      /* small mantissa, no GAQ, or Gk=1 */ <nl> -                    mant <<= 24 - bits; <nl> +                    mant *= (1 << 24 - bits); <nl>                      if (!log_gain) { <nl>                          /* remap mantissa value for no GAQ or Gk=1 */ <nl>                          mant += (ff_eac3_gaq_remap_1[hebap-8] * (int64_t)mant) >> 15;
@@ -278,11 +278,12 @@ static void get_tag(AVFormatContext *s, const char *key, int type, int len, int <nl>  { <nl>      char *value; <nl>      int64_t off = avio_tell(s->pb); <nl> +#define LEN 22 <nl>   <nl> -    if ((unsigned)len >= (UINT_MAX - 1) / 2) <nl> +    if ((unsigned)len >= (UINT_MAX - LEN) / 2) <nl>          return; <nl>   <nl> -    value = av_malloc(2 * len + 1); <nl> +    value = av_malloc(2 * len + LEN); <nl>      if (!value) <nl>          goto finish; <nl>   <nl> @@ -302,7 +303,7 @@ static void get_tag(AVFormatContext *s, const char *key, int type, int len, int <nl>          goto finish; <nl>      } else if (type > 1 && type <= 5) {  // boolean or DWORD or QWORD or WORD <nl>          uint64_t num = get_value(s->pb, type, type2_size); <nl> -        snprintf(value, len, "%"PRIu64, num); <nl> +        snprintf(value, LEN, "%"PRIu64, num); <nl>      } else if (type == 6) { // (don't) handle GUID <nl>          av_log(s, AV_LOG_DEBUG, "Unsupported GUID value in tag %s.\n", key); <nl>          goto finish;
@@ -487,7 +487,11 @@ int ff_wma_run_level_decode(AVCodecContext *avctx, GetBitContext *gb, <nl>      } <nl>      /** NOTE: EOB can be omitted */ <nl>      if (offset > num_coefs) { <nl> -        av_log(avctx, AV_LOG_ERROR, "overflow in spectral RLE, ignoring\n"); <nl> +        av_log(avctx, AV_LOG_ERROR, <nl> +               "overflow (%d > %d) in spectral RLE, ignoring\n", <nl> +               offset, <nl> +               num_coefs <nl> +              ); <nl>          return -1; <nl>      } <nl>  
@@ -314,7 +314,7 @@ static void vc1_inv_trans_4x4_c(DCTELEM block[64], int n) <nl>   <nl>  /** Filter used to interpolate fractional pel values <nl>   */ <nl> -static always_inline uint8_t vc1_mspel_filter(const uint8_t *src, int stride, int mode, int r) <nl> +static always_inline int vc1_mspel_filter(const uint8_t *src, int stride, int mode, int r) <nl>  { <nl>      switch(mode){ <nl>      case 0: //no shift <nl> @@ -343,7 +343,7 @@ static void vc1_mspel_mc(uint8_t *dst, const uint8_t *src, int stride, int mode, <nl>      tptr = tmp; <nl>      for(j = 0; j < 11; j++) { <nl>          for(i = 0; i < 8; i++) <nl> -            tptr[i] = vc1_mspel_filter(src + i, 1, m, r); <nl> +            tptr[i] = clip_uint8(vc1_mspel_filter(src + i, 1, m, r)); <nl>          src += stride; <nl>          tptr += 8; <nl>      } <nl> @@ -353,7 +353,7 @@ static void vc1_mspel_mc(uint8_t *dst, const uint8_t *src, int stride, int mode, <nl>      tptr = tmp + 8; <nl>      for(j = 0; j < 8; j++) { <nl>          for(i = 0; i < 8; i++) <nl> -            dst[i] = vc1_mspel_filter(tptr + i, 8, m, r); <nl> +            dst[i] = clip_uint8(vc1_mspel_filter(tptr + i, 8, m, r)); <nl>          dst += stride; <nl>          tptr += 8; <nl>      }
@@ -2250,8 +2250,8 @@ static int mpeg_decode_slice(Mpeg1Context *s1, int mb_y, <nl>      s->resync_mb_x= <nl>      s->resync_mb_y= -1; <nl>   <nl> -    if (mb_y >= s->mb_height){ <nl> -        av_log(s->avctx, AV_LOG_ERROR, "slice below image (%d >= %d)\n", s->mb_y, s->mb_height); <nl> +    if (mb_y<<field_pic >= s->mb_height){ <nl> +        av_log(s->avctx, AV_LOG_ERROR, "slice below image (%d >= %d)\n", mb_y, s->mb_height); <nl>          return -1; <nl>      } <nl>      
@@ -454,7 +454,8 @@ static inline int coeff_unpack_golomb(GetBitContext *gb, int qfactor, int qoffse <nl>      static inline void coeff_unpack_arith_##n(DiracArith *c, int qfactor, int qoffset, \ <nl>                                                SubBand *b, type *buf, int x, int y) \ <nl>      { \ <nl> -        int coeff, sign, sign_pred = 0, pred_ctx = CTX_ZPZN_F1; \ <nl> +        int sign, sign_pred = 0, pred_ctx = CTX_ZPZN_F1; \ <nl> +        unsigned coeff; \ <nl>          const int mstride = -(b->stride >> (1+b->pshift)); \ <nl>          if (b->parent) { \ <nl>              const type *pbuf = (type *)b->parent->ibuf; \
@@ -1490,7 +1490,7 @@ static void mpeg_decode_sequence_extension(Mpeg1Context *s1) <nl>      s->width  |= (horiz_size_ext << 12); <nl>      s->height |= (vert_size_ext  << 12); <nl>      bit_rate_ext = get_bits(&s->gb, 12);  /* XXX: handle it */ <nl> -    s->bit_rate += (bit_rate_ext << 18) * 400; <nl> +    s->bit_rate += (bit_rate_ext << 18) * 400LL; <nl>      check_marker(&s->gb, "after bit rate extension"); <nl>      s->avctx->rc_buffer_size += get_bits(&s->gb, 8) * 1024 * 16 << 10; <nl>   <nl> @@ -2175,7 +2175,7 @@ static int mpeg1_decode_sequence(AVCodecContext *avctx, <nl>                 "frame_rate_index %d is invalid\n", s->frame_rate_index); <nl>          s->frame_rate_index = 1; <nl>      } <nl> -    s->bit_rate = get_bits(&s->gb, 18) * 400; <nl> +    s->bit_rate = get_bits(&s->gb, 18) * 400LL; <nl>      if (check_marker(&s->gb, "in sequence header") == 0) { <nl>          return AVERROR_INVALIDDATA; <nl>      }
@@ -273,6 +273,7 @@ static int rtmp_packet_read_one_chunk(URLContext *h, RTMPPacket *p, <nl>         prev->data = p->data; <nl>         prev->read = p->read; <nl>         prev->offset = p->offset; <nl> +       p->data      = NULL; <nl>         return AVERROR(EAGAIN); <nl>      } <nl>  
@@ -1038,7 +1038,8 @@ static void compute_stereo(MPADecodeContext *s, GranuleDef *g0, GranuleDef *g1) <nl>  { <nl>      int i, j, k, l; <nl>      int sf_max, sf, len, non_zero_found; <nl> -    INTFLOAT (*is_tab)[16], *tab0, *tab1, tmp0, tmp1, v1, v2; <nl> +    INTFLOAT (*is_tab)[16], *tab0, *tab1, v1, v2; <nl> +    SUINTFLOAT tmp0, tmp1; <nl>      int non_zero_found_short[3]; <nl>   <nl>      /* intensity stereo */
@@ -1173,7 +1173,10 @@ int ff_h264_decode_slice_header(H264Context *h, H264SliceContext *sl) <nl>   <nl>      if (first_mb_in_slice == 0) { // FIXME better field boundary detection <nl>          if (h->current_slice) { <nl> -            av_assert0(!h->setup_finished); <nl> +            if (h->setup_finished) { <nl> +                av_log(h->avctx, AV_LOG_ERROR, "Too many fields\n"); <nl> +                return AVERROR_INVALIDDATA; <nl> +            } <nl>              if (h->cur_pic_ptr && FIELD_PICTURE(h) && h->first_field) { <nl>                  ret = ff_h264_field_end(h, h->slice_ctx, 1); <nl>                  h->current_slice = 0;
@@ -1558,7 +1558,7 @@ void ff_estimate_b_frame_motion(MpegEncContext * s, <nl>              score=fbmin; <nl>              type= MB_TYPE_BIDIR; <nl>          } <nl> -        score= (score*score + 128*256)>>16; <nl> +        score= ((unsigned)(score*score + 128*256))>>16; <nl>          s->mc_mb_var_sum += score; <nl>          s->mc_mb_var[mb_y*s->mb_width + mb_x] = score; //FIXME use SSD <nl>      }
@@ -402,6 +402,10 @@ static av_cold void uninit(AVFilterContext *ctx) <nl>      DrawTextContext *s = ctx->priv; <nl>      int i; <nl>   <nl> +    av_expr_free(s->x_pexpr); <nl> +    av_expr_free(s->y_pexpr); <nl> +    av_expr_free(s->d_pexpr); <nl> +    s->x_pexpr = s->y_pexpr = s->d_pexpr = NULL; <nl>      av_freep(&s->expanded_text); <nl>      av_freep(&s->positions); <nl>      av_tree_enumerate(s->glyphs, NULL, NULL, glyph_enu_free); <nl> @@ -573,6 +577,10 @@ static int config_input(AVFilterLink *inlink) <nl>   <nl>      av_lfg_init(&s->prng, av_get_random_seed()); <nl>   <nl> +    av_expr_free(s->x_pexpr); <nl> +    av_expr_free(s->y_pexpr); <nl> +    av_expr_free(s->d_pexpr); <nl> +    s->x_pexpr = s->y_pexpr = s->d_pexpr = NULL; <nl>      if ((ret = av_expr_parse(&s->x_pexpr, s->x_expr, var_names, <nl>                               NULL, NULL, fun2_names, fun2, 0, ctx)) < 0 || <nl>          (ret = av_expr_parse(&s->y_pexpr, s->y_expr, var_names,
@@ -223,7 +223,7 @@ static int filter_frame(AVFilterLink *inlink, AVFilterBufferRef *in) <nl>      AVFilterBufferRef *out; <nl>      int hsub0 = desc->log2_chroma_w; <nl>      int vsub0 = desc->log2_chroma_h; <nl> -    int direct; <nl> +    int direct = 0; <nl>      int plane; <nl>   <nl>      if ((in->perms & AV_PERM_WRITE) && !(in->perms & AV_PERM_PRESERVE)) {
@@ -421,7 +421,7 @@ static int mxf_read_primer_pack(void *arg, AVIOContext *pb, int tag, int size, U <nl>          avpriv_request_sample(pb, "Primer pack item length %d", item_len); <nl>          return AVERROR_PATCHWELCOME; <nl>      } <nl> -    if (item_num > 65536) { <nl> +    if (item_num > 65536 || item_num < 0) { <nl>          av_log(mxf->fc, AV_LOG_ERROR, "item_num %d is too large\n", item_num); <nl>          return AVERROR_INVALIDDATA; <nl>      }
@@ -233,6 +233,9 @@ static inline void ls_decode_line(JLSState *state, MJpegDecodeContext *s, <nl>      while (x < w) { <nl>          int err, pred; <nl>   <nl> +        if (get_bits_left(&s->gb) <= 0) <nl> +            return; <nl> + <nl>          /* compute gradients */ <nl>          Ra = x ? R(dst, x - stride) : R(last, x); <nl>          Rb = R(last, x);
@@ -363,6 +363,7 @@ static void encode_block(NellyMoserEncodeContext *s, unsigned char *output, int <nl>      } <nl>   <nl>      flush_put_bits(&pb); <nl> +    memset(put_bits_ptr(&pb), 0, output + output_size - put_bits_ptr(&pb)); <nl>  } <nl>   <nl>  static int encode_frame(AVCodecContext *avctx, uint8_t *frame, int buf_size, void *data)
@@ -223,6 +223,10 @@ static int mpc8_read_header(AVFormatContext *s) <nl>      while(!avio_feof(pb)){ <nl>          pos = avio_tell(pb); <nl>          mpc8_get_chunk_header(pb, &tag, &size); <nl> +        if (size < 0) { <nl> +            av_log(s, AV_LOG_ERROR, "Invalid chunk length\n"); <nl> +            return AVERROR_INVALIDDATA; <nl> +        } <nl>          if(tag == TAG_STREAMHDR) <nl>              break; <nl>          mpc8_handle_chunk(s, tag, pos, size);
@@ -414,7 +414,11 @@ int ff_rm_read_mdpr_codecdata(AVFormatContext *s, AVIOContext *pb, <nl>  skip: <nl>      /* skip codec info */ <nl>      size = avio_tell(pb) - codec_pos; <nl> -    avio_skip(pb, codec_data_size - size); <nl> +    if (codec_data_size >= size) { <nl> +        avio_skip(pb, codec_data_size - size); <nl> +    } else { <nl> +        av_log(s, AV_LOG_WARNING, "codec_data_size %u < size %d\n", codec_data_size, size); <nl> +    } <nl>   <nl>      return 0; <nl>  }
@@ -592,15 +592,15 @@ static int64_t ogg_read_timestamp(AVFormatContext *s, int stream_index, <nl>                                    int64_t *pos_arg, int64_t pos_limit) <nl>  { <nl>      struct ogg *ogg = s->priv_data; <nl> -    struct ogg_stream *os = ogg->streams + stream_index; <nl>      AVIOContext *bc = s->pb; <nl>      int64_t pts = AV_NOPTS_VALUE; <nl> -    int i; <nl> +    int i = -1; <nl>      avio_seek(bc, *pos_arg, SEEK_SET); <nl>      ogg_reset(ogg); <nl>   <nl>      while (avio_tell(bc) < pos_limit && !ogg_packet(s, &i, NULL, NULL, pos_arg)) { <nl>          if (i == stream_index) { <nl> +            struct ogg_stream *os = ogg->streams + stream_index; <nl>              pts = ogg_calc_pts(s, i, NULL); <nl>              if (os->keyframe_seek && !(os->pflags & AV_PKT_FLAG_KEY)) <nl>                  pts = AV_NOPTS_VALUE; <nl> @@ -626,6 +626,7 @@ static int ogg_read_seek(AVFormatContext *s, int stream_index, <nl>          os->keyframe_seek = 1; <nl>   <nl>      ret = av_seek_frame_binary(s, stream_index, timestamp, flags); <nl> +    os = ogg->streams + stream_index; <nl>      if (ret < 0) <nl>          os->keyframe_seek = 0; <nl>      return ret;
@@ -138,10 +138,9 @@ static int read_uncompressed_sgi(unsigned char* out_buf, SgiState *s) <nl>      for (y = s->height - 1; y >= 0; y--) { <nl>          out_end = out_buf + (y * s->linesize); <nl>          if (s->bytes_per_channel == 1) { <nl> -            for (x = s->width; x > 0; x--) { <nl> -                bytestream2_get_bufferu(&gp[z], out_end, s->depth); <nl> -                out_end += s->depth; <nl> -            } <nl> +            for (x = s->width; x > 0; x--) <nl> +                for (z = 0; z < s->depth; z++) <nl> +                    *out_end++ = bytestream2_get_byteu(&gp[z]); <nl>          } else { <nl>              uint16_t *out16 = (uint16_t *)out_end; <nl>              for (x = s->width; x > 0; x--)
@@ -1255,6 +1255,14 @@ int ff_hevc_decode_nal_pps(HEVCContext *s) <nl>      if (pps->cu_qp_delta_enabled_flag) <nl>          pps->diff_cu_qp_delta_depth = get_ue_golomb_long(gb); <nl>   <nl> +    if (pps->diff_cu_qp_delta_depth < 0 || <nl> +        pps->diff_cu_qp_delta_depth > sps->log2_diff_max_min_coding_block_size) { <nl> +        av_log(s->avctx, AV_LOG_ERROR, "diff_cu_qp_delta_depth %d is invalid\n", <nl> +               pps->diff_cu_qp_delta_depth); <nl> +        ret = AVERROR_INVALIDDATA; <nl> +        goto err; <nl> +    } <nl> + <nl>      pps->cb_qp_offset = get_se_golomb(gb); <nl>      if (pps->cb_qp_offset < -12 || pps->cb_qp_offset > 12) { <nl>          av_log(s->avctx, AV_LOG_ERROR, "pps_cb_qp_offset out of range: %d\n",
@@ -101,8 +101,9 @@ static av_cold int adpcm_decode_init(AVCodecContext * avctx) <nl>          max_channels = 6; <nl>          break; <nl>      } <nl> -    if(avctx->channels > max_channels){ <nl> -        return -1; <nl> +    if (avctx->channels <= 0 || avctx->channels > max_channels) { <nl> +        av_log(avctx, AV_LOG_ERROR, "Invalid number of channels\n"); <nl> +        return AVERROR(EINVAL); <nl>      } <nl>   <nl>      switch(avctx->codec->id) {
@@ -1244,6 +1244,10 @@ static int dca_decode_frame(AVCodecContext * avctx, <nl>          } else <nl>              s->channel_order_tab = dca_channel_reorder_nolfe[s->amode]; <nl>   <nl> +        if (s->prim_channels > 0 && <nl> +            s->channel_order_tab[s->prim_channels - 1] < 0) <nl> +            return -1; <nl> + <nl>          if(avctx->request_channels == 2 && s->prim_channels > 2) { <nl>              channels = 2; <nl>              s->output = DCA_STEREO;
@@ -131,6 +131,8 @@ static int theora_header(AVFormatContext *s, int idx) <nl>          st->codec->extradata_size = 0; <nl>          return err; <nl>      } <nl> +    memset(st->codec->extradata + cds, 0, FF_INPUT_BUFFER_PADDING_SIZE); <nl> + <nl>      cdp    = st->codec->extradata + st->codec->extradata_size; <nl>      *cdp++ = os->psize >> 8; <nl>      *cdp++ = os->psize & 0xff;
@@ -1442,7 +1442,7 @@ int ff_rtsp_connect(AVFormatContext *s) <nl>      char *option_list, *option, *filename; <nl>      URLContext *rtsp_hd; <nl>      int port, err, tcp_fd; <nl> -    RTSPMessageHeader reply1, *reply = &reply1; <nl> +    RTSPMessageHeader reply1 = {}, *reply = &reply1; <nl>      int lower_transport_mask = 0; <nl>      char real_challenge[64]; <nl>      struct sockaddr_storage peer;
@@ -397,19 +397,18 @@ static int hnm_decode_frame(AVCodecContext *avctx, void *data, <nl>          return AVERROR_INVALIDDATA; <nl>      } <nl>   <nl> -    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0) <nl> -        return ret; <nl> - <nl>      chunk_id = AV_RL16(avpkt->data + 4); <nl>   <nl>      if (chunk_id == HNM4_CHUNK_ID_PL) { <nl>          hnm_update_palette(avctx, avpkt->data, avpkt->size); <nl> -        frame->palette_has_changed = 1; <nl>      } else if (chunk_id == HNM4_CHUNK_ID_IZ) { <nl>          if (avpkt->size < 12) { <nl>              av_log(avctx, AV_LOG_ERROR, "packet too small\n"); <nl>              return AVERROR_INVALIDDATA; <nl>          } <nl> +        if ((ret = ff_get_buffer(avctx, frame, 0)) < 0) <nl> +            return ret; <nl> + <nl>          unpack_intraframe(avctx, avpkt->data + 12, avpkt->size - 12); <nl>          memcpy(hnm->previous, hnm->current, hnm->width * hnm->height); <nl>          if (hnm->version == 0x4a) <nl> @@ -422,6 +421,9 @@ static int hnm_decode_frame(AVCodecContext *avctx, void *data, <nl>          memcpy(frame->data[1], hnm->palette, 256 * 4); <nl>          *got_frame = 1; <nl>      } else if (chunk_id == HNM4_CHUNK_ID_IU) { <nl> +        if ((ret = ff_get_buffer(avctx, frame, 0)) < 0) <nl> +            return ret; <nl> + <nl>          if (hnm->version == 0x4a) { <nl>              decode_interframe_v4a(avctx, avpkt->data + 8, avpkt->size - 8); <nl>              memcpy(hnm->processed, hnm->current, hnm->width * hnm->height);
@@ -155,7 +155,7 @@ void ff_nut_reset_ts(NUTContext *nut, AVRational time_base, int64_t val){ <nl>  } <nl>   <nl>  int64_t ff_lsb2full(StreamContext *stream, int64_t lsb){ <nl> -    int64_t mask = (1<<stream->msb_pts_shift)-1; <nl> +    int64_t mask = (1ULL<<stream->msb_pts_shift)-1; <nl>      int64_t delta= stream->last_pts - mask/2; <nl>      return  ((lsb - delta)&mask) + delta; <nl>  }
@@ -1815,7 +1815,7 @@ static int dca_decode_frame(AVCodecContext * avctx, <nl>          return -1; <nl>      } <nl>   <nl> -    if (avctx->channels != channels) { <nl> +    if (avctx->channels && avctx->channels != channels) { <nl>          av_log(avctx, AV_LOG_INFO, "Number of channels changed in DCA decoder (%d -> %d)\n", avctx->channels, channels); <nl>          avctx->channels = channels; <nl>      }
@@ -801,15 +801,16 @@ static int flv_read_packet(AVFormatContext *s, AVPacket *pkt) <nl>      int av_uninit(channels); <nl>      int av_uninit(sample_rate); <nl>      AVStream *st    = NULL; <nl> +    int last = -1; <nl>   <nl>      /* pkt size is repeated at end. skip it */ <nl> -    for (;; avio_skip(s->pb, 4)) { <nl> +    for (;; last = avio_rb32(s->pb)) { <nl>          pos  = avio_tell(s->pb); <nl>          type = (avio_r8(s->pb) & 0x1F); <nl>          size = avio_rb24(s->pb); <nl>          dts  = avio_rb24(s->pb); <nl>          dts |= avio_r8(s->pb) << 24; <nl> -        av_log(s, AV_LOG_TRACE, "type:%d, size:%d, dts:%"PRId64" pos:%"PRId64"\n", type, size, dts, avio_tell(s->pb)); <nl> +        av_log(s, AV_LOG_TRACE, "type:%d, size:%d, last:%d, dts:%"PRId64" pos:%"PRId64"\n", type, size, last, dts, avio_tell(s->pb)); <nl>          if (avio_feof(s->pb)) <nl>              return AVERROR_EOF; <nl>          avio_skip(s->pb, 3); /* stream id, always 0 */
@@ -716,7 +716,7 @@ static int decode_block(MJpegDecodeContext *s, int16_t *block, int component, <nl>          return AVERROR_INVALIDDATA; <nl>      } <nl>      val = val * quant_matrix[0] + s->last_dc[component]; <nl> -    val = FFMIN(val, 32767); <nl> +    val = av_clip_int16(val); <nl>      s->last_dc[component] = val; <nl>      block[0] = val; <nl>      /* AC coefs */
@@ -317,7 +317,9 @@ static int a64multi_encode_frame(AVCodecContext *avctx, AVPacket *pkt, <nl>      } else { <nl>          /* fill up mc_meta_charset with data until lifetime exceeds */ <nl>          if (c->mc_frame_counter < c->mc_lifetime) { <nl> -            *p = *pict; <nl> +            ret = av_frame_ref(p, pict); <nl> +            if (ret < 0) <nl> +                return ret; <nl>              p->pict_type = AV_PICTURE_TYPE_I; <nl>              p->key_frame = 1; <nl>              to_meta_with_crop(avctx, p, meta + 32000 * c->mc_frame_counter);
@@ -431,7 +431,7 @@ static int shorten_decode_frame(AVCodecContext *avctx, void *data, <nl>          void *tmp_ptr; <nl>          s->max_framesize = 1024; // should hopefully be enough for the first header <nl>          tmp_ptr = av_fast_realloc(s->bitstream, &s->allocated_bitstream_size, <nl> -                                  s->max_framesize); <nl> +                                  s->max_framesize + FF_INPUT_BUFFER_PADDING_SIZE); <nl>          if (!tmp_ptr) { <nl>              av_log(avctx, AV_LOG_ERROR, "error allocating bitstream buffer\n"); <nl>              return AVERROR(ENOMEM);
@@ -1349,8 +1349,8 @@ static void show_packets(WriterContext *w, AVFormatContext *fmt_ctx) <nl>          if (do_show_frames && <nl>              get_video_frame(fmt_ctx, &frame, &pkt)) { <nl>              show_frame(w, &frame, fmt_ctx->streams[pkt.stream_index]); <nl> -            av_free_packet(&pkt); <nl>          } <nl> +        av_free_packet(&pkt); <nl>      } <nl>      av_init_packet(&pkt); <nl>      pkt.data = NULL;
@@ -502,7 +502,10 @@ static int read_quant_tables(RangeCoder *c, <nl>      int context_count = 1; <nl>   <nl>      for (i = 0; i < 5; i++) { <nl> -        context_count *= read_quant_table(c, quant_table[i], context_count); <nl> +        int ret = read_quant_table(c, quant_table[i], context_count); <nl> +        if (ret < 0) <nl> +            return ret; <nl> +        context_count *= ret; <nl>          if (context_count > 32768U) { <nl>              return AVERROR_INVALIDDATA; <nl>          }
@@ -4495,6 +4495,12 @@ static int execute_decode_slices(H264Context *h, int context_count) <nl>      H264Context *hx; <nl>      int i; <nl>   <nl> +    if (h->mb_y >= h->mb_height) { <nl> +        av_log(h->avctx, AV_LOG_ERROR, <nl> +               "Input contains more MB rows than the frame height.\n"); <nl> +        return AVERROR_INVALIDDATA; <nl> +    } <nl> + <nl>      if (h->avctx->hwaccel) <nl>          return 0; <nl>      if (context_count == 1) {
@@ -167,6 +167,7 @@ static int h263_decode_gob_header(MpegEncContext *s) <nl>          /* We have a GBSC probably with GSTUFF */ <nl>      skip_bits(&s->gb, 16); /* Drop the zeros */ <nl>      left= get_bits_left(&s->gb); <nl> +    left = FFMIN(left, 32); <nl>      //MN: we must check the bits left or we might end in an infinite loop (or segfault) <nl>      for(;left>13; left--){ <nl>          if(get_bits1(&s->gb)) break; /* Seek the '1' bit */
@@ -120,6 +120,8 @@ static int adx_decode_frame(AVCodecContext *avctx, void *data, <nl>          buf += header_size; <nl>          buf_size -= header_size; <nl>      } <nl> +    if(c->channels <= 0) <nl> +        return AVERROR_INVALIDDATA; <nl>   <nl>      /* calculate number of blocks in the packet */ <nl>      num_blocks = buf_size / (BLOCK_SIZE * c->channels);
@@ -2123,8 +2123,12 @@ static int decode_video(InputStream *ist, AVPacket *pkt, int *got_output) <nl>      ist->hwaccel_retrieved_pix_fmt = decoded_frame->format; <nl>   <nl>      best_effort_timestamp= av_frame_get_best_effort_timestamp(decoded_frame); <nl> -    if(best_effort_timestamp != AV_NOPTS_VALUE) <nl> -        ist->next_pts = ist->pts = av_rescale_q(decoded_frame->pts = best_effort_timestamp, ist->st->time_base, AV_TIME_BASE_Q); <nl> +    if(best_effort_timestamp != AV_NOPTS_VALUE) { <nl> +        int64_t ts = av_rescale_q(decoded_frame->pts = best_effort_timestamp, ist->st->time_base, AV_TIME_BASE_Q); <nl> + <nl> +        if (ts != AV_NOPTS_VALUE) <nl> +            ist->next_pts = ist->pts = ts; <nl> +    } <nl>   <nl>      if (debug_ts) { <nl>          av_log(NULL, AV_LOG_INFO, "decoder -> ist_index:%d type:video "
@@ -62,7 +62,7 @@ <nl>  #define MUNGE_ROW(x) (((x) + 0x7F)>>8) <nl>  #define IDCT_ROW(dest,src) IDCT_TRANSFORM(dest,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,MUNGE_ROW,src) <nl>   <nl> -static inline void bink_idct_col(DCTELEM *dest, const DCTELEM *src) <nl> +static inline void bink_idct_col(int *dest, const DCTELEM *src) <nl>  { <nl>      if ((src[8]|src[16]|src[24]|src[32]|src[40]|src[48]|src[56])==0) { <nl>          dest[0]  = <nl> @@ -81,7 +81,7 @@ static inline void bink_idct_col(DCTELEM *dest, const DCTELEM *src) <nl>  void ff_bink_idct_c(DCTELEM *block) <nl>  { <nl>      int i; <nl> -    DCTELEM temp[64]; <nl> +    int temp[64]; <nl>   <nl>      for (i = 0; i < 8; i++) <nl>          bink_idct_col(&temp[i], &block[i]); <nl> @@ -103,7 +103,7 @@ void ff_bink_idct_add_c(uint8_t *dest, int linesize, DCTELEM *block) <nl>  void ff_bink_idct_put_c(uint8_t *dest, int linesize, DCTELEM *block) <nl>  { <nl>      int i; <nl> -    DCTELEM temp[64]; <nl> +    int temp[64]; <nl>      for (i = 0; i < 8; i++) <nl>          bink_idct_col(&temp[i], &block[i]); <nl>      for (i = 0; i < 8; i++) {
@@ -470,6 +470,7 @@ static float wv_get_value_float(WavpackFrameContext *s, uint32_t *crc, int S) <nl>  static void wv_reset_saved_context(WavpackFrameContext *s) <nl>  { <nl>      s->pos = 0; <nl> +    s->samples_left = 0; <nl>      s->sc.crc = s->extra_sc.crc = 0xFFFFFFFF; <nl>  } <nl>   <nl> @@ -582,6 +583,7 @@ static inline int wv_unpack_stereo(WavpackFrameContext *s, GetBitContext *gb, vo <nl>   <nl>      s->samples_left -= count; <nl>      if(!s->samples_left){ <nl> +        wv_reset_saved_context(s); <nl>          if(crc != s->CRC){ <nl>              av_log(s->avctx, AV_LOG_ERROR, "CRC error\n"); <nl>              return -1; <nl> @@ -590,7 +592,6 @@ static inline int wv_unpack_stereo(WavpackFrameContext *s, GetBitContext *gb, vo <nl>              av_log(s->avctx, AV_LOG_ERROR, "Extra bits CRC error\n"); <nl>              return -1; <nl>          } <nl> -        wv_reset_saved_context(s); <nl>      }else{ <nl>          s->pos = pos; <nl>          s->sc.crc = crc; <nl> @@ -660,6 +661,7 @@ static inline int wv_unpack_mono(WavpackFrameContext *s, GetBitContext *gb, void <nl>   <nl>      s->samples_left -= count; <nl>      if(!s->samples_left){ <nl> +        wv_reset_saved_context(s); <nl>          if(crc != s->CRC){ <nl>              av_log(s->avctx, AV_LOG_ERROR, "CRC error\n"); <nl>              return -1; <nl> @@ -668,7 +670,6 @@ static inline int wv_unpack_mono(WavpackFrameContext *s, GetBitContext *gb, void <nl>              av_log(s->avctx, AV_LOG_ERROR, "Extra bits CRC error\n"); <nl>              return -1; <nl>          } <nl> -        wv_reset_saved_context(s); <nl>      }else{ <nl>          s->pos = pos; <nl>          s->sc.crc = crc; <nl> @@ -1195,7 +1196,7 @@ static void wavpack_decode_flush(AVCodecContext *avctx) <nl>      int i; <nl>   <nl>      for (i = 0; i < s->fdec_num; i++) <nl> -        s->fdec[i]->samples_left = 0; <nl> +        wv_reset_saved_context(s->fdec[i]); <nl>  } <nl>   <nl>  AVCodec ff_wavpack_decoder = {
@@ -965,7 +965,7 @@ int ff_hevc_parse_sps(HEVCSPS *sps, GetBitContext *gb, unsigned int *sps_id, <nl>      return 0; <nl>   <nl>  err: <nl> -    return ret; <nl> +    return ret < 0 ? ret : AVERROR_INVALIDDATA; <nl>  } <nl>   <nl>  int ff_hevc_decode_nal_sps(GetBitContext *gb, AVCodecContext *avctx,
@@ -179,6 +179,7 @@ static void truespeech_apply_twopoint_filter(TSContext *dec, int quart) <nl>      for(i = 0; i < 146; i++) <nl>          tmp[i] = dec->filtbuf[i]; <nl>      off = (t / 25) + dec->offset1[quart >> 1] + 18; <nl> +    off = av_clip(off, 0, 145); <nl>      ptr0 = tmp + 145 - off; <nl>      ptr1 = tmp + 146; <nl>      filter = (const int16_t*)ts_order2_coeffs + (t % 25) * 2;
@@ -180,8 +180,8 @@ typedef struct MotionEstContext{ <nl>      int stride; <nl>      int uvstride; <nl>      /* temp variables for picture complexity calculation */ <nl> -    int mc_mb_var_sum_temp; <nl> -    int mb_var_sum_temp; <nl> +    int64_t mc_mb_var_sum_temp; <nl> +    int64_t mb_var_sum_temp; <nl>      int scene_change_score; <nl>  /*    cmp, chroma_cmp;*/ <nl>      op_pixels_func (*hpel_put)[4];
@@ -608,6 +608,11 @@ static int smka_decode_frame(AVCodecContext *avctx, void *data, <nl>   <nl>      unp_size = AV_RL32(buf); <nl>   <nl> +    if (unp_size > (1U<<24)) { <nl> +        av_log(avctx, AV_LOG_ERROR, "packet is too big\n"); <nl> +        return AVERROR_INVALIDDATA; <nl> +    } <nl> + <nl>      init_get_bits(&gb, buf + 4, (buf_size - 4) * 8); <nl>   <nl>      if(!get_bits1(&gb)){
@@ -237,6 +237,7 @@ void ff_set_fixed_vector(float *out, const AMRFixed *in, float scale, int size) <nl>          int x   = in->x[i], repeats = !((in->no_repeat_mask >> i) & 1); <nl>          float y = in->y[i] * scale; <nl>   <nl> +        if (in->pitch_lag > 0) <nl>          do { <nl>              out[x] += y; <nl>              y *= in->pitch_fac; <nl> @@ -252,6 +253,7 @@ void ff_clear_fixed_vector(float *out, const AMRFixed *in, int size) <nl>      for (i=0; i < in->n; i++) { <nl>          int x  = in->x[i], repeats = !((in->no_repeat_mask >> i) & 1); <nl>   <nl> +        if (in->pitch_lag > 0) <nl>          do { <nl>              out[x] = 0.0; <nl>              x += in->pitch_lag;
@@ -792,7 +792,8 @@ static void mxf_read_pixel_layout(AVIOContext *pb, MXFDescriptor *descriptor) <nl>          if (ofs <= 14) { <nl>              layout[ofs++] = code; <nl>              layout[ofs++] = value; <nl> -        } <nl> +        } else <nl> +            break;  /* don't read byte by byte on sneaky files filled with lots of non-zeroes */ <nl>      } while (code != 0); /* SMPTE 377M E.2.46 */ <nl>   <nl>      ff_mxf_decode_pixel_layout(layout, &descriptor->pix_fmt);
@@ -384,6 +384,11 @@ static int get_cox(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *c) <nl>          return AVERROR_INVALIDDATA; <nl>      } <nl>   <nl> +    if (c->log2_cblk_width > 6 || c->log2_cblk_height > 6) { <nl> +        avpriv_request_sample(s->avctx, "cblk size > 64"); <nl> +        return AVERROR_PATCHWELCOME; <nl> +    } <nl> + <nl>      c->cblk_style = bytestream2_get_byteu(&s->g); <nl>      if (c->cblk_style != 0) { // cblk style <nl>          av_log(s->avctx, AV_LOG_WARNING, "extra cblk styles %X\n", c->cblk_style); <nl> @@ -1025,6 +1030,9 @@ static int decode_cblk(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *codsty, <nl>      int bpass_csty_symbol           = codsty->cblk_style & JPEG2000_CBLK_BYPASS; <nl>      int vert_causal_ctx_csty_symbol = codsty->cblk_style & JPEG2000_CBLK_VSC; <nl>   <nl> +    av_assert0(width  <= JPEG2000_MAX_CBLKW); <nl> +    av_assert0(height <= JPEG2000_MAX_CBLKH); <nl> + <nl>      for (y = 0; y < height; y++) <nl>          memset(t1->data[y], 0, width * sizeof(**t1->data)); <nl>  
@@ -910,7 +910,8 @@ static int svq3_decode_frame (AVCodecContext *avctx, <nl>        s->next_p_frame_damaged = 0; <nl>    } <nl>   <nl> -  frame_start (h); <nl> +  if (frame_start (h) < 0) <nl> +    return -1; <nl>   <nl>    if (s->pict_type == B_TYPE) { <nl>      h->frame_num_offset = (h->slice_num - h->prev_frame_num);
@@ -186,6 +186,7 @@ static void filter(USPPContext *p, uint8_t *dst[3], uint8_t *src[3], <nl>  { <nl>      int x, y, i, j; <nl>      const int count = 1<<p->log2_count; <nl> +    int ret; <nl>   <nl>      for (i = 0; i < 3; i++) { <nl>          int is_chroma = !!i; <nl> @@ -249,7 +250,12 @@ static void filter(USPPContext *p, uint8_t *dst[3], uint8_t *src[3], <nl>          p->frame->data[2] = p->src[2] + x1c  + y1c  * p->frame->linesize[2]; <nl>          p->frame->format  = p->avctx_enc[i]->pix_fmt; <nl>   <nl> -        avcodec_encode_video2(p->avctx_enc[i], &pkt, p->frame, &got_pkt_ptr); <nl> +        ret = avcodec_encode_video2(p->avctx_enc[i], &pkt, p->frame, &got_pkt_ptr); <nl> +        if (ret < 0) { <nl> +            av_log(p->avctx_enc[i], AV_LOG_ERROR, "Encoding failed\n"); <nl> +            continue; <nl> +        } <nl> + <nl>          p->frame_dec = p->avctx_enc[i]->coded_frame; <nl>   <nl>          offset = (BLOCK-x1) + (BLOCK-y1) * p->frame_dec->linesize[0];
@@ -109,7 +109,7 @@ void av_get_channel_layout_string(char *buf, int buf_size, <nl>          int i, ch; <nl>          av_strlcat(buf, " (", buf_size); <nl>          for (i = 0, ch = 0; i < 64; i++) { <nl> -            if ((channel_layout & (1L << i))) { <nl> +            if ((channel_layout & (UINT64_C(1) << i))) { <nl>                  const char *name = get_channel_name(i); <nl>                  if (name) { <nl>                      if (ch > 0)
@@ -235,6 +235,8 @@ static int asfrtp_parse_packet(AVFormatContext *s, PayloadContext *asf, <nl>                  int prev_len = out_len; <nl>                  out_len += cur_len; <nl>                  asf->buf = av_realloc(asf->buf, out_len); <nl> +                if(!asf->buf || FFMIN(cur_len, len - off)<0) <nl> +                    return -1; <nl>                  memcpy(asf->buf + prev_len, buf + off, <nl>                         FFMIN(cur_len, len - off)); <nl>                  avio_skip(pb, cur_len);
@@ -186,7 +186,7 @@ static void ff_id3v2_parse(AVFormatContext *s, int len, uint8_t version, uint8_t <nl>  { <nl>      int isv34, tlen, unsync; <nl>      char tag[5]; <nl> -    int64_t next; <nl> +    int64_t next, end = avio_tell(s->pb) + len; <nl>      int taghdrlen; <nl>      const char *reason; <nl>      AVIOContext pb; <nl> @@ -284,8 +284,9 @@ static void ff_id3v2_parse(AVFormatContext *s, int len, uint8_t version, uint8_t <nl>          avio_skip(s->pb, len); <nl>      } <nl>      if (version == 4 && flags & 0x10) /* Footer preset, always 10 bytes, skip over it */ <nl> -        avio_skip(s->pb, 10); <nl> +        end += 10; <nl>   <nl> +    avio_seek(s->pb, end, SEEK_SET); <nl>      av_free(buffer); <nl>      return; <nl>  
@@ -2269,7 +2269,7 @@ static int output_packet(InputStream *ist, <nl>              ret = transcode_video    (ist, &avpkt, &got_output, &pkt_pts); <nl>              if (avpkt.duration) { <nl>                  duration = av_rescale_q(avpkt.duration, ist->st->time_base, AV_TIME_BASE_Q); <nl> -            } else if(ist->st->codec->time_base.num != 0) { <nl> +            } else if(ist->st->codec->time_base.num != 0 && ist->st->codec->time_base.den != 0) { <nl>                  int ticks= ist->st->parser ? ist->st->parser->repeat_pict+1 : ist->st->codec->ticks_per_frame; <nl>                  duration = ((int64_t)AV_TIME_BASE * <nl>                                  ist->st->codec->time_base.num * ticks) /
@@ -147,6 +147,9 @@ int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) { <nl>      AVCodecContext* ctx = avcodec_alloc_context3(NULL); <nl>      if (!ctx) <nl>          error("Failed memory allocation"); <nl> + <nl> +    ctx->max_pixels = 4096 * 4096; //To reduce false positive OOM and hangs <nl> + <nl>      int res = avcodec_open2(ctx, c, NULL); <nl>      if (res < 0) <nl>          return res;
@@ -1174,7 +1174,12 @@ static int decode_subframe(WMAProDecodeCtx *s) <nl>              int num_bits = av_log2((s->subframe_len + 3)/4) + 1; <nl>              for (i = 0; i < s->channels_for_cur_subframe; i++) { <nl>                  int c = s->channel_indexes_for_cur_subframe[i]; <nl> -                s->channel[c].num_vec_coeffs = get_bits(&s->gb, num_bits) << 2; <nl> +                int num_vec_coeffs = get_bits(&s->gb, num_bits) << 2; <nl> +                if (num_vec_coeffs > WMAPRO_BLOCK_MAX_SIZE) { <nl> +                    av_log(s->avctx, AV_LOG_ERROR, "num_vec_coeffs %d is too large\n", num_vec_coeffs); <nl> +                    return AVERROR_INVALIDDATA; <nl> +                } <nl> +                s->channel[c].num_vec_coeffs = num_vec_coeffs; <nl>              } <nl>          } else { <nl>              for (i = 0; i < s->channels_for_cur_subframe; i++) {
@@ -213,13 +213,13 @@ static int rv40_decode_mb_info(RV34DecContext *r) <nl>      if(--r->s.mb_skip_run) <nl>           return RV34_MB_SKIP; <nl>   <nl> -    if(r->avail[0]) <nl> +    if(r->avail_cache[5-1]) <nl>          blocks[r->mb_type[mb_pos - 1]]++; <nl> -    if(r->avail[1]){ <nl> +    if(r->avail_cache[5-4]){ <nl>          blocks[r->mb_type[mb_pos - s->mb_stride]]++; <nl> -        if(r->avail[2]) <nl> +        if(r->avail_cache[5-2]) <nl>              blocks[r->mb_type[mb_pos - s->mb_stride + 1]]++; <nl> -        if(r->avail[3]) <nl> +        if(r->avail_cache[5-5]) <nl>              blocks[r->mb_type[mb_pos - s->mb_stride - 1]]++; <nl>      } <nl>  
@@ -47,8 +47,8 @@ void ff_rtp_send_aac(AVFormatContext *s1, const uint8_t *buff, int size) <nl>              memmove(p + 2, s->buf + 2, au_size); <nl>          } <nl>          /* Write the AU header size */ <nl> -        p[0] = ((au_size * 8) & 0xFF) >> 8; <nl> -        p[1] = (au_size * 8) & 0xFF; <nl> +        p[0] =  au_size >> 5; <nl> +        p[1] = (au_size & 0x1F) << 3; <nl>   <nl>          ff_rtp_send_data(s1, p, s->buf_ptr - p, 1); <nl>  
@@ -488,6 +488,8 @@ static const AVOption avcodec_options[] = { <nl>  {"bt", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = AV_FIELD_BT }, 0, 0, V|D|E, "field_order" }, <nl>  {"dump_separator", "set information dump field separator", OFFSET(dump_separator), AV_OPT_TYPE_STRING, {.str = NULL}, CHAR_MIN, CHAR_MAX, A|V|S|D|E}, <nl>  {"codec_whitelist", "List of decoders that are allowed to be used", OFFSET(codec_whitelist), AV_OPT_TYPE_STRING, { .str = NULL },  CHAR_MIN, CHAR_MAX, A|V|S|D }, <nl> +{"pixel_format", "set pixel format", OFFSET(pix_fmt), AV_OPT_TYPE_PIXEL_FMT, {.i64=AV_PIX_FMT_NONE}, -1, INT_MAX, 0 }, <nl> +{"video_size", "set video size", OFFSET(width), AV_OPT_TYPE_IMAGE_SIZE, {.str=NULL}, 0, INT_MAX, 0 }, <nl>  {NULL}, <nl>  }; <nl>  
@@ -614,11 +614,12 @@ int ff_thread_decode_frame(AVCodecContext *avctx, <nl>       * If we're still receiving the initial packets, don't return a frame. <nl>       */ <nl>   <nl> -    if (fctx->delaying && avpkt->size) { <nl> +    if (fctx->delaying) { <nl>          if (fctx->next_decoding >= (avctx->thread_count-1)) fctx->delaying = 0; <nl>   <nl>          *got_picture_ptr=0; <nl> -        return avpkt->size; <nl> +        if (avpkt->size) <nl> +            return avpkt->size; <nl>      } <nl>   <nl>      /*
@@ -106,8 +106,10 @@ static int doTest(uint8_t *ref[4], int refStride[4], int w, int h, <nl>           * prefer, as long as they're aligned enough for the architecture, and <nl>           * they're freed appropriately (such as using av_free for buffers <nl>           * allocated with av_malloc). */ <nl> -        src[i]= av_mallocz(srcStride[i]*srcH); <nl> -        dst[i]= av_mallocz(dstStride[i]*dstH); <nl> +        /* An extra 16 bytes is being allocated because some scalers may write <nl> +         * out of bounds. */ <nl> +        src[i]= av_mallocz(srcStride[i]*srcH+16); <nl> +        dst[i]= av_mallocz(dstStride[i]*dstH+16); <nl>          out[i]= av_mallocz(refStride[i]*h); <nl>          if (!src[i] || !dst[i] || !out[i]) { <nl>              perror("Malloc");
@@ -387,7 +387,7 @@ int avfilter_graph_parse(AVFilterGraph *graph, const char *filters, <nl>          goto fail; <nl>      } <nl>   <nl> -    if (*open_inputs && !strcmp((*open_inputs)->name, "out") && curr_inputs) { <nl> +    if (open_inputs && *open_inputs && !strcmp((*open_inputs)->name, "out") && curr_inputs) { <nl>          /* Last output can be omitted if it is "[out]" */ <nl>          const char *tmp = "[out]"; <nl>          if ((ret = parse_outputs(&tmp, &curr_inputs, open_inputs, open_outputs,
@@ -129,7 +129,7 @@ static av_cold int wavpack_encode_init(AVCodecContext *avctx) <nl>      s->avctx = avctx; <nl>   <nl>      if (avctx->channels > 255) { <nl> -        av_log(avctx, AV_LOG_ERROR, "Too many channels\n", avctx->channels); <nl> +        av_log(avctx, AV_LOG_ERROR, "Invalid channel count: %d\n", avctx->channels); <nl>          return AVERROR(EINVAL); <nl>      } <nl>  
@@ -52,9 +52,9 @@ static void arith2_normalise(ArithCoder *c) <nl>              c->value ^= 0x8000; <nl>              c->low   ^= 0x8000; <nl>          } <nl> -        c->high  = c->high  << 8 & 0xFFFFFF | 0xFF; <nl> -        c->value = c->value << 8 & 0xFFFFFF | bytestream2_get_byte(c->gbc.gB); <nl> -        c->low   = c->low   << 8 & 0xFFFFFF; <nl> +        c->high  = (uint16_t)c->high  << 8  | 0xFF; <nl> +        c->value = (uint16_t)c->value << 8  | bytestream2_get_byte(c->gbc.gB); <nl> +        c->low   = (uint16_t)c->low   << 8; <nl>      } <nl>  } <nl>  
@@ -860,6 +860,7 @@ static int rm_read_packet(AVFormatContext *s, AVPacket *pkt) <nl>                  len = !ast->audio_framesize ? RAW_PACKET_SIZE : <nl>                      ast->coded_framesize * ast->sub_packet_h / 2; <nl>                  flags = (seq++ == 1) ? 2 : 0; <nl> +                pos = url_ftell(s->pb); <nl>              } else { <nl>                  len=sync(s, &timestamp, &flags, &i, &pos); <nl>                  if (len > 0)
@@ -2880,7 +2880,7 @@ static int rtsp_parse_request(HTTPContext *c) <nl>      if (*p == '\n') <nl>          p++; <nl>      while (*p != '\0') { <nl> -        p1 = strchr(p, '\n'); <nl> +        p1 = memchr(p, '\n', (char *)c->buffer_ptr - p); <nl>          if (!p1) <nl>              break; <nl>          p2 = p1;
@@ -575,8 +575,8 @@ mp_image_t* vf_get_image(vf_instance_t* vf, unsigned int outfmt, int mp_imgtype, <nl>      } <nl>   <nl>    mpi->qscale = NULL; <nl> -  } <nl>    mpi->usage_count++; <nl> +  } <nl>  //    printf("\rVF_MPI: %p %p %p %d %d %d    \n", <nl>  //      mpi->planes[0],mpi->planes[1],mpi->planes[2], <nl>  //      mpi->stride[0],mpi->stride[1],mpi->stride[2]);
@@ -129,8 +129,8 @@ typedef struct WmallDecodeCtx { <nl>   <nl>      int8_t  mclms_order; <nl>      int8_t  mclms_scaling; <nl> -    int16_t mclms_coeffs[128]; <nl> -    int16_t mclms_coeffs_cur[4]; <nl> +    int16_t mclms_coeffs[WMALL_MAX_CHANNELS * WMALL_MAX_CHANNELS * 32]; <nl> +    int16_t mclms_coeffs_cur[WMALL_MAX_CHANNELS * WMALL_MAX_CHANNELS]; <nl>      int16_t mclms_prevvalues[WMALL_MAX_CHANNELS * 2 * 32]; <nl>      int16_t mclms_updates[WMALL_MAX_CHANNELS * 2 * 32]; <nl>      int     mclms_recent;
@@ -135,8 +135,8 @@ static int msrle_decode_8_16_24_32(AVCodecContext *avctx, AVPicture *pic, int de <nl>      uint8_t *output, *output_end; <nl>      const uint8_t* src = data; <nl>      int p1, p2, line=avctx->height, pos=0, i; <nl> -    uint16_t pix16; <nl> -    uint32_t pix32; <nl> +    uint16_t av_uninit(pix16); <nl> +    uint32_t av_uninit(pix32); <nl>   <nl>      output = pic->data[0] + (avctx->height - 1) * pic->linesize[0]; <nl>      output_end = pic->data[0] + (avctx->height) * pic->linesize[0];
@@ -137,7 +137,7 @@ static av_cold int init(AVFilterContext *ctx, const char *args, void *opaque) <nl>  static av_cold void uninit(AVFilterContext *ctx) <nl>  { <nl>      BufferSourceContext *s = ctx->priv; <nl> -    while (av_fifo_size(s->fifo)) { <nl> +    while (s->fifo && av_fifo_size(s->fifo)) { <nl>          AVFilterBufferRef *buf; <nl>          av_fifo_generic_read(s->fifo, &buf, sizeof(buf), NULL); <nl>          avfilter_unref_buffer(buf);
@@ -301,11 +301,17 @@ static void decode_p_block(FourXContext *f, uint16_t *dst, uint16_t *src, int lo <nl>      const int index= size2index[log2h][log2w]; <nl>      const int h= 1<<log2h; <nl>      int code= get_vlc2(&f->gb, block_type_vlc[1-f->version][index].table, BLOCK_TYPE_VLC_BITS, 1); <nl> +    uint16_t *start= f->last_picture.data[0]; <nl> +    uint16_t *end= start + stride*(f->avctx->height-h+1) - (1<<log2w); <nl>   <nl>      assert(code>=0 && code<=6); <nl>   <nl>      if(code == 0){ <nl>          src += f->mv[ *f->bytestream++ ]; <nl> +        if(start > src || src > end){ <nl> +            av_log(f->avctx, AV_LOG_ERROR, "mv out of pic\n"); <nl> +            return; <nl> +        } <nl>          mcdc(dst, src, log2w, h, stride, 1, 0); <nl>      }else if(code == 1){ <nl>          log2h--; <nl> @@ -319,6 +325,10 @@ static void decode_p_block(FourXContext *f, uint16_t *dst, uint16_t *src, int lo <nl>          mcdc(dst, src, log2w, h, stride, 1, 0); <nl>      }else if(code == 4){ <nl>          src += f->mv[ *f->bytestream++ ]; <nl> +        if(start > src || src > end){ <nl> +            av_log(f->avctx, AV_LOG_ERROR, "mv out of pic\n"); <nl> +            return; <nl> +        } <nl>          mcdc(dst, src, log2w, h, stride, 1, le2me_16(*f->wordstream++)); <nl>      }else if(code == 5){ <nl>          mcdc(dst, src, log2w, h, stride, 0, le2me_16(*f->wordstream++));
@@ -706,7 +706,7 @@ static int ff_filter_frame_framed(AVFilterLink *link, AVFilterBufferRef *frame) <nl>      } else <nl>          out = frame; <nl>   <nl> -    while(cmd && cmd->time <= frame->pts * av_q2d(link->time_base)){ <nl> +    while(cmd && cmd->time <= out->pts * av_q2d(link->time_base)){ <nl>          av_log(link->dst, AV_LOG_DEBUG, <nl>                 "Processing command time:%f command:%s arg:%s\n", <nl>                 cmd->time, cmd->command, cmd->arg);
@@ -1158,6 +1158,10 @@ static int dvbsub_parse_region_segment(AVCodecContext *avctx, <nl>      buf += 2; <nl>   <nl>      ret = av_image_check_size2(region->width, region->height, avctx->max_pixels, AV_PIX_FMT_PAL8, 0, avctx); <nl> +    if (ret >= 0 && region->width * region->height * 2 > 320 * 1024 * 8) { <nl> +        ret = AVERROR_INVALIDDATA; <nl> +        av_log(avctx, AV_LOG_ERROR, "Pixel buffer memory constraint violated\n"); <nl> +    } <nl>      if (ret < 0) { <nl>          region->width= region->height= 0; <nl>          return ret;
@@ -213,22 +213,27 @@ static int compare_ocl_device_desc(const void *a, const void *b) <nl>   <nl>  int opt_opencl_bench(void *optctx, const char *opt, const char *arg) <nl>  { <nl> -    int i, j, nb_devices = 0, count = 0; <nl> +    int i, j, nb_devices = 0, count = 0, ret = 0; <nl>      int64_t score = 0; <nl>      AVOpenCLDeviceList *device_list; <nl>      AVOpenCLDeviceNode *device_node = NULL; <nl>      OpenCLDeviceBenchmark *devices = NULL; <nl>      cl_platform_id platform; <nl>   <nl> -    av_opencl_get_device_list(&device_list); <nl> +    ret = av_opencl_get_device_list(&device_list); <nl> +    if (ret < 0) { <nl> +        return ret; <nl> +    } <nl>      for (i = 0; i < device_list->platform_num; i++) <nl>          nb_devices += device_list->platform_node[i]->device_num; <nl>      if (!nb_devices) { <nl>          av_log(NULL, AV_LOG_ERROR, "No OpenCL device detected!\n"); <nl> +        av_opencl_free_device_list(&device_list); <nl>          return AVERROR(EINVAL); <nl>      } <nl>      if (!(devices = av_malloc_array(nb_devices, sizeof(OpenCLDeviceBenchmark)))) { <nl>          av_log(NULL, AV_LOG_ERROR, "Could not allocate buffer\n"); <nl> +        av_opencl_free_device_list(&device_list); <nl>          return AVERROR(ENOMEM); <nl>      } <nl>  
@@ -722,6 +722,8 @@ static int rm_assemble_video_frame(AVFormatContext *s, AVIOContext *pb, <nl>   <nl>      if(++vst->cur_slice > vst->slices) <nl>          return 1; <nl> +    if(!vst->pkt.data) <nl> +        return AVERROR(ENOMEM); <nl>      AV_WL32(vst->pkt.data - 7 + 8*vst->cur_slice, 1); <nl>      AV_WL32(vst->pkt.data - 3 + 8*vst->cur_slice, vst->videobufpos - 8*vst->slices - 1); <nl>      if(vst->videobufpos + len > vst->videobufsize)
@@ -763,7 +763,7 @@ static int decode_pce(AVCodecContext *avctx, MPEG4AudioConfig *m4ac, <nl>      if (get_bits1(gb)) <nl>          skip_bits(gb, 3); // mixdown_coeff_index and pseudo_surround <nl>   <nl> -    if (get_bits_left(gb) < 4 * (num_front + num_side + num_back + num_lfe + num_assoc_data + num_cc)) { <nl> +    if (get_bits_left(gb) < 5 * (num_front + num_side + num_back + num_cc) + 4 *(num_lfe + num_assoc_data + num_cc)) { <nl>          av_log(avctx, AV_LOG_ERROR, "decode_pce: " overread_err); <nl>          return -1; <nl>      }
@@ -30,6 +30,7 @@ <nl>   <nl>  #include "libavutil/atomic.h" <nl>  #include "libavutil/avassert.h" <nl> +#include "libavutil/qsort.h" <nl>  #include "avcodec.h" <nl>  #include "internal.h" <nl>  #include "mathops.h" <nl> @@ -333,7 +334,7 @@ int ff_init_vlc_sparse(VLC *vlc_arg, int nb_bits, int nb_codes, <nl>      } <nl>      COPY(buf[j].bits > nb_bits); <nl>      // qsort is the slowest part of init_vlc, and could probably be improved or avoided <nl> -    qsort(buf, j, sizeof(VLCcode), compare_vlcspec); <nl> +    AV_QSORT(buf, j, struct VLCcode, compare_vlcspec); <nl>      COPY(buf[j].bits && buf[j].bits <= nb_bits); <nl>      nb_codes = j; <nl>  
@@ -731,7 +731,7 @@ static inline void dv_guess_qnos(EncBlockInfo* blks, int* qnos) <nl>      int i, j, k, a, prev, a2; <nl>      EncBlockInfo* b; <nl>   <nl> -    size[4]= 1<<24; <nl> +    size[0] = size[1] = size[2] = size[3] = size[4] = 1<<24; <nl>      do { <nl>         b = blks; <nl>         for (i=0; i<5; i++) { <nl> @@ -753,11 +753,14 @@ static inline void dv_guess_qnos(EncBlockInfo* blks, int* qnos) <nl>                             prev= k; <nl>                         } else { <nl>                             if(b->next[k] >= mb_area_start[a+1] && b->next[k]<64){ <nl> -                                for(a2=a+1; b->next[k] >= mb_area_start[a2+1]; a2++); <nl> +                                for(a2=a+1; b->next[k] >= mb_area_start[a2+1]; a2++) <nl> +                                    b->prev[a2] = prev; <nl>                                  assert(a2<4); <nl>                                  assert(b->mb[b->next[k]]); <nl>                                  b->bit_size[a2] += dv_rl2vlc_size(b->next[k] - prev - 1, b->mb[b->next[k]]) <nl>                                                    -dv_rl2vlc_size(b->next[k] -    k - 1, b->mb[b->next[k]]); <nl> +                                for(; (b->prev[a2]==k) && (a2<4); a2++) <nl> +                                        b->prev[a2] = prev; <nl>                             } <nl>                             b->next[prev] = b->next[k]; <nl>                         }
@@ -111,8 +111,7 @@ read_header: <nl>      av_log(avctx, AV_LOG_DEBUG, "sod offs: 0x%x\n", sod_offs); <nl>      if (sos_offs) <nl>      { <nl> -//        init_get_bits(&s->gb, buf+sos_offs, (buf_end - (buf+sos_offs))*8); <nl> -        init_get_bits(&s->gb, buf_ptr+sos_offs, field_size*8); <nl> +        init_get_bits(&s->gb, buf_ptr+sos_offs, FFMIN(field_size, buf_end - (buf_ptr+sos_offs))*8); <nl>          s->mjpb_skiptosod = (sod_offs - sos_offs - show_bits(&s->gb, 16)); <nl>          s->start_code = SOS; <nl>          if (ff_mjpeg_decode_sos(s, NULL, NULL) < 0 &&
@@ -430,6 +430,8 @@ static int dv_read_packet(AVFormatContext *s, AVPacket *pkt) <nl>      size = dv_get_packet(c->dv_demux, pkt); <nl>   <nl>      if (size < 0) { <nl> +        if (!c->dv_demux->sys) <nl> +            return AVERROR(EIO); <nl>          size = c->dv_demux->sys->frame_size; <nl>          if (get_buffer(s->pb, c->buf, size) <= 0) <nl>              return AVERROR(EIO);
@@ -2175,6 +2175,10 @@ static int theora_decode_header(AVCodecContext *avctx, GetBitContext *gb) <nl>      { <nl>          skip_bits(gb, 5); /* keyframe frequency force */ <nl>          avctx->pix_fmt = theora_pix_fmts[get_bits(gb, 2)]; <nl> +        if (avctx->pix_fmt == AV_PIX_FMT_NONE) { <nl> +            av_log(avctx, AV_LOG_ERROR, "Invalid pixel format\n"); <nl> +            return AVERROR_INVALIDDATA; <nl> +        } <nl>          skip_bits(gb, 3); /* reserved */ <nl>      } <nl>   <nl> @@ -2349,7 +2353,8 @@ static av_cold int theora_decode_init(AVCodecContext *avctx) <nl>      switch(ptype) <nl>      { <nl>          case 0x80: <nl> -            theora_decode_header(avctx, &gb); <nl> +            if (theora_decode_header(avctx, &gb) < 0) <nl> +                return -1; <nl>                  break; <nl>          case 0x81: <nl>  // FIXME: is this needed? it breaks sometimes
@@ -176,9 +176,10 @@ double ff_lpc_calc_ref_coefs_f(LPCContext *s, const float *samples, int len, <nl>      const double a = 0.5f, b = 1.0f - a; <nl>   <nl>      /* Apply windowing */ <nl> -    for (i = 0; i < len; i++) { <nl> +    for (i = 0; i <= len / 2; i++) { <nl>          double weight = a - b*cos((2*M_PI*i)/(len - 1)); <nl>          s->windowed_samples[i] = weight*samples[i]; <nl> +        s->windowed_samples[len-1-i] = weight*samples[len-1-i]; <nl>      } <nl>   <nl>      s->lpc_compute_autocorr(s->windowed_samples, len, order, autoc);
@@ -24,6 +24,7 @@ <nl>   * RV30/40 decoder common data <nl>   */ <nl>   <nl> +#include "libavutil/imgutils.h" <nl>  #include "libavutil/internal.h" <nl>   <nl>  #include "avcodec.h" <nl> @@ -1661,6 +1662,9 @@ int ff_rv34_decode_frame(AVCodecContext *avctx, <nl>              av_log(s->avctx, AV_LOG_WARNING, "Changing dimensions to %dx%d\n", <nl>                     si.width, si.height); <nl>   <nl> +            if (av_image_check_size(si.width, si.height, 0, s->avctx)) <nl> +                return AVERROR_INVALIDDATA; <nl> + <nl>              s->width  = si.width; <nl>              s->height = si.height; <nl>              avcodec_set_dimensions(s->avctx, s->width, s->height);
@@ -174,8 +174,8 @@ static int filter_frame(AVFilterLink *inlink, AVFrame *in) <nl>   <nl>      switch (s->mode) { <nl>      case 0: <nl> -        top    = s->frame[1 + tf - outlink->frame_count]; <nl> -        bottom = s->frame[1 + bf - outlink->frame_count]; <nl> +        top    = s->frame[tf - outlink->frame_count + 1]; <nl> +        bottom = s->frame[bf - outlink->frame_count + 1]; <nl>          break; <nl>      case 1: <nl>          top    = s->frame[1 + tf];
@@ -2475,6 +2475,7 @@ static av_cold int theora_decode_init(AVCodecContext *avctx) <nl>      const uint8_t *header_start[3]; <nl>      int header_len[3]; <nl>      int i; <nl> +    int ret; <nl>   <nl>      avctx->pix_fmt = AV_PIX_FMT_YUV420P; <nl>   <nl> @@ -2494,7 +2495,9 @@ static av_cold int theora_decode_init(AVCodecContext *avctx) <nl>      for (i = 0; i < 3; i++) { <nl>          if (header_len[i] <= 0) <nl>              continue; <nl> -        init_get_bits8(&gb, header_start[i], header_len[i]); <nl> +        ret = init_get_bits8(&gb, header_start[i], header_len[i]); <nl> +        if (ret < 0) <nl> +            return ret; <nl>   <nl>          ptype = get_bits(&gb, 8); <nl>  
@@ -389,7 +389,7 @@ static int encode_frame(AVCodecContext *avctx, AVPacket *avpkt, <nl>          memcpy(s->buf + NELLY_BUF_LEN, frame->data[0], <nl>                 frame->nb_samples * sizeof(*s->buf)); <nl>          if (frame->nb_samples < NELLY_SAMPLES) { <nl> -            memset(s->buf + NELLY_BUF_LEN + avctx->frame_size, 0, <nl> +            memset(s->buf + NELLY_BUF_LEN + frame->nb_samples, 0, <nl>                     (NELLY_SAMPLES - frame->nb_samples) * sizeof(*s->buf)); <nl>              if (frame->nb_samples >= NELLY_BUF_LEN) <nl>                  s->last_frame = 1;
@@ -3150,7 +3150,10 @@ static int matroska_parse_block(MatroskaDemuxContext *matroska, uint8_t *data, <nl>   <nl>      if (matroska->skip_to_keyframe && <nl>          track->type != MATROSKA_TRACK_TYPE_SUBTITLE) { <nl> -        if (timecode < matroska->skip_to_timecode) <nl> +        // Compare signed timecodes. Timecode may be negative due to codec delay <nl> +        // offset. We don't support timestamps greater than int64_t anyway - see <nl> +        // AVPacket's pts. <nl> +        if ((int64_t)timecode < (int64_t)(matroska->skip_to_timecode)) <nl>              return res; <nl>          if (is_keyframe) <nl>              matroska->skip_to_keyframe = 0;
@@ -127,7 +127,6 @@ typedef struct ASFContext { <nl>      int64_t sub_dts; <nl>      uint8_t dts_delta; // for subpayloads <nl>      uint32_t packet_size_internal; // packet size stored inside ASFPacket, can be 0 <nl> -    int64_t dts; <nl>      int64_t packet_offset; // offset of the current packet inside Data Object <nl>      uint32_t pad_len; // padding after payload <nl>      uint32_t rep_data_len; <nl> @@ -1248,7 +1247,6 @@ static int asf_read_payload(AVFormatContext *s, AVPacket *pkt) <nl>              if (asf->stream_index == asf->asf_st[i]->stream_index) { <nl>                  asf_pkt               = &asf->asf_st[i]->pkt; <nl>                  asf_pkt->stream_index = asf->asf_st[i]->index; <nl> -                asf_pkt->dts          = asf->dts; <nl>                  break; <nl>              } <nl>          } <nl> @@ -1486,7 +1484,6 @@ static void reset_packet_state(AVFormatContext *s) <nl>      asf->nb_sub            = 0; <nl>      asf->prop_flags        = 0; <nl>      asf->sub_dts           = 0; <nl> -    asf->dts               = 0; <nl>      for (i = 0; i < asf->nb_streams; i++) { <nl>          ASFPacket *pkt = &asf->asf_st[i]->pkt; <nl>          pkt->size_left = 0;
@@ -685,7 +685,7 @@ static void psy_3gpp_analyze_channel(FFPsyContext *ctx, int channel, <nl>   <nl>              band->thr_quiet = band->thr = FFMAX(band->thr, coeffs[g].ath); <nl>              //5.4.2.5 "Pre-echo control" <nl> -            if (!(wi->window_type[0] == LONG_STOP_SEQUENCE || (wi->window_type[1] == LONG_START_SEQUENCE && !w))) <nl> +            if (!(wi->window_type[0] == LONG_STOP_SEQUENCE || (!w && wi->window_type[1] == LONG_START_SEQUENCE))) <nl>                  band->thr = FFMAX(PSY_3GPP_RPEMIN*band->thr, FFMIN(band->thr, <nl>                                    PSY_3GPP_RPELEV*pch->prev_band[w+g].thr_quiet)); <nl>   <nl> @@ -1018,9 +1018,10 @@ static FFPsyWindowInfo psy_lame_window(FFPsyContext *ctx, const float *audio, <nl>          for (i = 0; i < 8; i += wi.grouping[i]) { <nl>              int w; <nl>              float clipping = 0.0f; <nl> -            for (w = 0; w < wi.grouping[i] && !clipping; w++) <nl> +            for (w = 0; w < wi.grouping[i]; w++) <nl>                  clipping = FFMAX(clipping, clippings[i+w]); <nl> -            wi.clipping[i] = clipping; <nl> +            for (w = 0; w < wi.grouping[i]; w++) <nl> +                wi.clipping[i+w] = clipping; <nl>          } <nl>      } <nl>  
@@ -90,7 +90,7 @@ static av_cold void rnd_table_init(void) { <nl>   <nl>  static av_cold void init_noise_samples(void) { <nl>      int i; <nl> -    int random_seed = 0; <nl> +    unsigned random_seed = 0; <nl>      float delta = 1.0 / 16384.0; <nl>      for (i = 0; i < 128;i++) { <nl>          random_seed = random_seed * 214013 + 2531011;
@@ -279,6 +279,8 @@ static int mp_decode_frame(AVCodecContext *avctx, <nl>      if (sz == 0) <nl>          goto end; <nl>   <nl> +    if (mp->max_codes_bits <= 0) <nl> +        goto end; <nl>      if (init_vlc(&mp->vlc, mp->max_codes_bits, mp->codes_count, &mp->codes[0].size, sizeof(HuffCode), 1, &mp->codes[0].code, sizeof(HuffCode), 4, 0)) <nl>          goto end; <nl>      mp_decode_frame_helper(mp, &gb);
@@ -826,8 +826,6 @@ static int hls_slice_header(HEVCContext *s) <nl>      s->HEVClc->tu.cu_qp_offset_cb = 0; <nl>      s->HEVClc->tu.cu_qp_offset_cr = 0; <nl>   <nl> -    s->no_rasl_output_flag = IS_IDR(s) || IS_BLA(s) || (s->nal_unit_type == HEVC_NAL_CRA_NUT && s->last_eos); <nl> - <nl>      return 0; <nl>  } <nl>   <nl> @@ -2677,6 +2675,8 @@ static int hevc_frame_start(HEVCContext *s) <nl>      s->is_decoded        = 0; <nl>      s->first_nal_type    = s->nal_unit_type; <nl>   <nl> +    s->no_rasl_output_flag = IS_IDR(s) || IS_BLA(s) || (s->nal_unit_type == HEVC_NAL_CRA_NUT && s->last_eos); <nl> + <nl>      if (s->ps.pps->tiles_enabled_flag) <nl>          lc->end_of_tiles_x = s->ps.pps->column_width[0] << s->ps.sps->log2_ctb_size; <nl>  
@@ -101,7 +101,7 @@ void ff_aac_update_ltp(AACEncContext *s, SingleChannelElement *sce) <nl>              lag = i; <nl>          } <nl>      } <nl> -    lag = av_clip(lag, 0, 2048); /* 11 bits => 2^11 = 2048 */ <nl> +    lag = av_clip(lag, 0, 2047); /* 11 bits => 2^11 = 0->2047 */ <nl>   <nl>      if (!lag) { <nl>          sce->ics.ltp.lag = lag;
@@ -348,7 +348,7 @@ static const ID3v2EMFunc *get_extra_meta_func(const char *tag, int isv34) <nl>              return &ff_id3v2_extra_meta_funcs[i]; <nl>          i++; <nl>      } <nl> -    return NULL; <nl> +    return &ff_id3v2_extra_meta_funcs[i]; <nl>  } <nl>   <nl>  static void ff_id3v2_parse(AVFormatContext *s, int len, uint8_t version, uint8_t flags, ID3v2ExtraMeta **extra_meta) <nl> @@ -531,7 +531,7 @@ void ff_id3v2_free_extra_meta(ID3v2ExtraMeta **extra_meta) <nl>   <nl>  const ID3v2EMFunc ff_id3v2_extra_meta_funcs[] = { <nl>      { "GEO", "GEOB", read_geobtag, free_geobtag }, <nl> -    { NULL } <nl> +    { NULL,  NULL,   NULL,         NULL } <nl>  }; <nl>   <nl>  const AVMetadataConv ff_id3v2_34_metadata_conv[] = {
@@ -1047,7 +1047,7 @@ int attribute_align_arg avcodec_encode_audio(AVCodecContext *avctx, <nl>                                               const short *samples) <nl>  { <nl>      AVPacket pkt; <nl> -    AVFrame frame0 = { 0 }; <nl> +    AVFrame frame0 = { { 0 } }; <nl>      AVFrame *frame; <nl>      int ret, samples_size, got_packet; <nl>   <nl> @@ -1311,7 +1311,7 @@ int attribute_align_arg avcodec_decode_audio3(AVCodecContext *avctx, int16_t *sa <nl>                                                int *frame_size_ptr, <nl>                                                AVPacket *avpkt) <nl>  { <nl> -    AVFrame frame = {0}; <nl> +    AVFrame frame = { { 0 } }; <nl>      int ret, got_frame = 0; <nl>   <nl>      if (avctx->get_buffer != avcodec_default_get_buffer) {
@@ -121,6 +121,13 @@ static void dxva2_frames_uninit(AVHWFramesContext *ctx) <nl>      } <nl>  } <nl>   <nl> +static void dxva2_pool_release_dummy(void *opaque, uint8_t *data) <nl> +{ <nl> +    // important not to free anything here--data is a surface object <nl> +    // associated with the call to CreateSurface(), and these surfaces are <nl> +    // released in dxva2_frames_uninit() <nl> +} <nl> + <nl>  static AVBufferRef *dxva2_pool_alloc(void *opaque, int size) <nl>  { <nl>      AVHWFramesContext      *ctx = (AVHWFramesContext*)opaque; <nl> @@ -130,7 +137,7 @@ static AVBufferRef *dxva2_pool_alloc(void *opaque, int size) <nl>      if (s->nb_surfaces_used < hwctx->nb_surfaces) { <nl>          s->nb_surfaces_used++; <nl>          return av_buffer_create((uint8_t*)s->surfaces_internal[s->nb_surfaces_used - 1], <nl> -                                sizeof(*hwctx->surfaces), NULL, 0, 0); <nl> +                                sizeof(*hwctx->surfaces), dxva2_pool_release_dummy, 0, 0); <nl>      } <nl>   <nl>      return NULL;
@@ -396,13 +396,11 @@ static int encode_superframe(AVCodecContext *avctx, <nl>      } <nl>  #endif <nl>   <nl> -    if ((i = encode_frame(s, s->coefs, buf, buf_size, total_gain)) >= 0) { <nl> -        av_log(avctx, AV_LOG_ERROR, "required frame size too large. please " <nl> -               "use a higher bit rate.\n"); <nl> -        return AVERROR(EINVAL); <nl> -    } <nl> +    encode_frame(s, s->coefs, buf, buf_size, total_gain); <nl>      assert((put_bits_count(&s->pb) & 7) == 0); <nl> -    while (i++) <nl> +    i= s->block_align - (put_bits_count(&s->pb)+7)/8; <nl> +    assert(i>=0); <nl> +    while(i--) <nl>          put_bits(&s->pb, 8, 'N'); <nl>   <nl>      flush_put_bits(&s->pb);
@@ -123,9 +123,6 @@ offset_t url_fseek(ByteIOContext *s, offset_t offset, int whence) <nl>          /* can do the seek inside the buffer */ <nl>          s->buf_ptr = s->buffer + offset1; <nl>      } else { <nl> -        if (!s->seek) <nl> -            return -EPIPE; <nl> - <nl>  #ifdef CONFIG_MUXERS <nl>          if (s->write_flag) { <nl>              flush_buffer(s); <nl> @@ -136,7 +133,7 @@ offset_t url_fseek(ByteIOContext *s, offset_t offset, int whence) <nl>              s->buf_end = s->buffer; <nl>          } <nl>          s->buf_ptr = s->buffer; <nl> -        if (s->seek(s->opaque, offset, SEEK_SET) == (offset_t)-EPIPE) <nl> +        if (!s->seek || s->seek(s->opaque, offset, SEEK_SET) == (offset_t)-EPIPE) <nl>              return -EPIPE; <nl>          s->pos = offset; <nl>      }
@@ -794,7 +794,7 @@ static int url_open_dyn_buf_internal(ByteIOContext **s, int max_packet_size) <nl>          return -1; <nl>      d = av_mallocz(sizeof(DynBuffer) + io_buffer_size); <nl>      if (!d) <nl> -        return -1; <nl> +        return AVERROR(ENOMEM); <nl>      *s = av_mallocz(sizeof(ByteIOContext)); <nl>      if(!*s) { <nl>          av_free(d);
@@ -206,7 +206,6 @@ static int filter_samples(AVFilterLink *inlink, AVFilterBufferRef *insamples) <nl>                               av_rescale_q((p - (int16_t *)insamples->data[0]) / nb_channels, <nl>                                            (AVRational){ 1, inlink->sample_rate }, <nl>                                            outlink->time_base); <nl> -            outlink->out_buf = outpicref; <nl>              linesize = outpicref->linesize[0]; <nl>              memset(outpicref->data[0], 0, showwaves->h*linesize); <nl>          }
@@ -96,14 +96,17 @@ static int mtv_read_header(AVFormatContext *s) <nl>   <nl>      /* Calculate width and height if missing from header */ <nl>   <nl> -    if(!mtv->img_width) <nl> +    if (!mtv->img_width && mtv->img_height > 0 && mtv->img_bpp >= 8) <nl>          mtv->img_width=mtv->img_segment_size / (mtv->img_bpp>>3) <nl>                          / mtv->img_height; <nl>   <nl> -    if(!mtv->img_height) <nl> +    if (!mtv->img_height && mtv->img_width > 0 && mtv->img_bpp >= 8) <nl>          mtv->img_height=mtv->img_segment_size / (mtv->img_bpp>>3) <nl>                          / mtv->img_width; <nl>   <nl> +    if (!mtv->img_width || !mtv->img_height) <nl> +        return AVERROR_INVALIDDATA; <nl> + <nl>      avio_skip(pb, 4); <nl>      audio_subsegments = avio_rl16(pb); <nl>  
@@ -135,7 +135,7 @@ static int decode_frame(AVCodecContext *avctx, <nl>      JvContext *s           = avctx->priv_data; <nl>      const uint8_t *buf     = avpkt->data; <nl>      const uint8_t *buf_end = buf + avpkt->size; <nl> -    int video_size, video_type, i, j; <nl> +    int video_size, video_type, ret, i, j; <nl>   <nl>      if (avpkt->size < 6) <nl>          return AVERROR_INVALIDDATA; <nl> @@ -149,9 +149,9 @@ static int decode_frame(AVCodecContext *avctx, <nl>              av_log(avctx, AV_LOG_ERROR, "video size %d invalid\n", video_size); <nl>              return AVERROR_INVALIDDATA; <nl>          } <nl> -        if (avctx->reget_buffer(avctx, &s->frame) < 0) { <nl> +        if ((ret = avctx->reget_buffer(avctx, &s->frame)) < 0) { <nl>              av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n"); <nl> -            return -1; <nl> +            return ret; <nl>          } <nl>   <nl>          if (video_type == 0 || video_type == 1) {
@@ -2936,7 +2936,7 @@ static int read_thread(void *arg) <nl>          AVStream *st = ic->streams[i]; <nl>          enum AVMediaType type = st->codecpar->codec_type; <nl>          st->discard = AVDISCARD_ALL; <nl> -        if (wanted_stream_spec[type] && st_index[type] == -1) <nl> +        if (type >= 0 && wanted_stream_spec[type] && st_index[type] == -1) <nl>              if (avformat_match_stream_specifier(ic, st, wanted_stream_spec[type]) > 0) <nl>                  st_index[type] = i; <nl>      }
@@ -372,9 +372,6 @@ int av_probe_input_buffer2(AVIOContext *pb, AVInputFormat **fmt, <nl>      for(probe_size= PROBE_BUF_MIN; probe_size<=max_probe_size && !*fmt; <nl>          probe_size = FFMIN(probe_size<<1, FFMAX(max_probe_size, probe_size+1))) { <nl>   <nl> -        if (probe_size < offset) { <nl> -            continue; <nl> -        } <nl>          score = probe_size < max_probe_size ? AVPROBE_SCORE_RETRY : 0; <nl>   <nl>          /* read probe data */ <nl> @@ -390,6 +387,8 @@ int av_probe_input_buffer2(AVIOContext *pb, AVInputFormat **fmt, <nl>              ret = 0;            /* error was end of file, nothing read */ <nl>          } <nl>          buf_offset += ret; <nl> +        if (buf_offset < offset) <nl> +            continue; <nl>          pd.buf_size = buf_offset - offset; <nl>          pd.buf = &buf[offset]; <nl>  
@@ -130,6 +130,8 @@ static int cdxl_read_packet(AVFormatContext *s, AVPacket *pkt) <nl>      height       = AV_RB16(&cdxl->header[16]); <nl>      palette_size = AV_RB16(&cdxl->header[20]); <nl>      audio_size   = AV_RB16(&cdxl->header[22]); <nl> +    if (FFALIGN(width, 16) * (uint64_t)height * cdxl->header[19] > INT_MAX) <nl> +        return AVERROR_INVALIDDATA; <nl>      image_size   = FFALIGN(width, 16) * height * cdxl->header[19] / 8; <nl>      video_size   = palette_size + image_size; <nl>  
@@ -819,6 +819,10 @@ static void do_subtitle_out(AVFormatContext *s, <nl>   <nl>      if (!subtitle_out) { <nl>          subtitle_out = av_malloc(subtitle_out_max_size); <nl> +        if (!subtitle_out) { <nl> +            av_log(NULL, AV_LOG_FATAL, "Failed to allocate subtitle_out\n"); <nl> +            exit_program(1); <nl> +        } <nl>      } <nl>   <nl>      /* Note: DVB subtitle need one packet to draw them and one other
@@ -141,7 +141,7 @@ static int xwd_decode_frame(AVCodecContext *avctx, void *data, <nl>          return AVERROR_INVALIDDATA; <nl>      } <nl>   <nl> -    if (bytestream2_get_bytes_left(&gb) < ncolors * XWD_CMAP_SIZE + avctx->height * lsize) { <nl> +    if (bytestream2_get_bytes_left(&gb) < ncolors * XWD_CMAP_SIZE + (uint64_t)avctx->height * lsize) { <nl>          av_log(avctx, AV_LOG_ERROR, "input buffer too small\n"); <nl>          return AVERROR_INVALIDDATA; <nl>      }
@@ -703,8 +703,10 @@ static int compute_bit_allocation(AC3EncodeContext *s, <nl>      /* audio blocks */ <nl>      for(i=0;i<NB_BLOCKS;i++) { <nl>          frame_bits += s->nb_channels * 2 + 2; /* blksw * c, dithflag * c, dynrnge, cplstre */ <nl> -        if (s->acmod == 2) <nl> +        if (s->acmod == 2) { <nl>              frame_bits++; /* rematstr */ <nl> +            if(i==0) frame_bits += 4; <nl> +        } <nl>          frame_bits += 2 * s->nb_channels; /* chexpstr[2] * c */ <nl>  	if (s->lfe) <nl>  	    frame_bits++; /* lfeexpstr */
@@ -1463,9 +1463,7 @@ int attribute_align_arg avcodec_decode_audio4(AVCodecContext *avctx, <nl>                  frame->extended_buf    = NULL; <nl>                  frame->nb_extended_buf = 0; <nl>              } <nl> -        } <nl> - <nl> -        if (ret < 0 && frame->data[0]) <nl> +        } else if (frame->data[0]) <nl>              av_frame_unref(frame); <nl>      } <nl>  
@@ -5463,7 +5463,7 @@ static int vc1_decode_frame(AVCodecContext *avctx, void *data, <nl>   <nl>      if (!s->context_initialized) { <nl>          if (ff_msmpeg4_decode_init(avctx) < 0 || ff_vc1_decode_init_alloc_tables(v) < 0) <nl> -            return -1; <nl> +            goto err; <nl>   <nl>          s->low_delay = !avctx->has_b_frames || v->res_sprite; <nl>  
@@ -468,7 +468,7 @@ static int sync(AVFormatContext *s, int64_t *timestamp, int *flags, int *stream_ <nl>  skip: <nl>              /* skip packet if unknown number */ <nl>              url_fskip(pb, len); <nl> -            rm->remaining_len -= len; <nl> +            rm->remaining_len = 0; <nl>              continue; <nl>          } <nl>          *stream_index= i;
@@ -266,7 +266,7 @@ av_cold void ff_msmpeg4_encode_init(MpegEncContext *s) <nl>   <nl>          for(i=0; i<NB_RL_TABLES; i++){ <nl>              int level; <nl> -            for(level=0; level<=MAX_LEVEL; level++){ <nl> +            for (level = 1; level <= MAX_LEVEL; level++) { <nl>                  int run; <nl>                  for(run=0; run<=MAX_RUN; run++){ <nl>                      int last;
@@ -364,7 +364,8 @@ static int Stagefright_decode_frame(AVCodecContext *avctx, void *data, <nl>      AVFrame *ret_frame; <nl>   <nl>      if (!s->thread_started) { <nl> -        pthread_create(&s->decode_thread_id, NULL, &decode_thread, avctx); <nl> +        if(pthread_create(&s->decode_thread_id, NULL, &decode_thread, avctx)) <nl> +            return AVERROR(ENOMEM); <nl>          s->thread_started = true; <nl>      } <nl>  
@@ -260,8 +260,8 @@ static int idcin_read_packet(AVFormatContext *s, <nl>          url_fseek(pb, 4, SEEK_CUR); <nl>          chunk_size -= 4; <nl>          ret= av_get_packet(pb, pkt, chunk_size); <nl> -        if (ret != chunk_size) <nl> -            return AVERROR(EIO); <nl> +        if (ret < 0) <nl> +            return ret; <nl>          pkt->stream_index = idcin->video_stream_index; <nl>          pkt->pts = idcin->pts; <nl>      } else { <nl> @@ -271,8 +271,8 @@ static int idcin_read_packet(AVFormatContext *s, <nl>          else <nl>              chunk_size = idcin->audio_chunk_size1; <nl>          ret= av_get_packet(pb, pkt, chunk_size); <nl> -        if (ret != chunk_size) <nl> -            return AVERROR(EIO); <nl> +        if (ret < 0) <nl> +            return ret; <nl>          pkt->stream_index = idcin->audio_stream_index; <nl>          pkt->pts = idcin->pts; <nl>  
@@ -51,7 +51,7 @@ static int msf_read_header(AVFormatContext *s) <nl>      st->codec->codec_type  = AVMEDIA_TYPE_AUDIO; <nl>      codec                  = avio_rb32(s->pb); <nl>      st->codec->channels    = avio_rb32(s->pb); <nl> -    if (st->codec->channels <= 0) <nl> +    if (st->codec->channels <= 0 || st->codec->channels >= INT_MAX / 1024) <nl>          return AVERROR_INVALIDDATA; <nl>      size = avio_rb32(s->pb); <nl>      st->codec->sample_rate = avio_rb32(s->pb);
@@ -339,8 +339,13 @@ static inline int GET_TOK(TM2Context *ctx,int type) { <nl>          av_log(ctx->avctx, AV_LOG_ERROR, "Read token from stream %i out of bounds (%i>=%i)\n", type, ctx->tok_ptrs[type], ctx->tok_lens[type]); <nl>          return 0; <nl>      } <nl> -    if(type <= TM2_MOT) <nl> +    if(type <= TM2_MOT) { <nl> +        if (ctx->tokens[type][ctx->tok_ptrs[type]] >= TM2_DELTAS) { <nl> +            av_log(ctx->avctx, AV_LOG_ERROR, "token %d is too large\n", ctx->tokens[type][ctx->tok_ptrs[type]]); <nl> +            return 0; <nl> +        } <nl>          return ctx->deltas[type][ctx->tokens[type][ctx->tok_ptrs[type]++]]; <nl> +    } <nl>      return ctx->tokens[type][ctx->tok_ptrs[type]++]; <nl>  } <nl>  
@@ -998,7 +998,7 @@ static av_always_inline int coeff_abs_level_remaining_decode(HEVCContext *s, int <nl>      } else { <nl>          int prefix_minus3 = prefix - 3; <nl>   <nl> -        if (prefix == CABAC_MAX_BIN) { <nl> +        if (prefix == CABAC_MAX_BIN || prefix_minus3 + rc_rice_param >= 31) { <nl>              av_log(s->avctx, AV_LOG_ERROR, "CABAC_MAX_BIN : %d\n", prefix); <nl>              return 0; <nl>          }
@@ -494,7 +494,7 @@ void ff_msmpeg4_encode_mb(MpegEncContext * s, <nl>  static void msmpeg4_encode_dc(MpegEncContext * s, int level, int n, int *dir_ptr) <nl>  { <nl>      int sign, code; <nl> -    int pred, extquant; <nl> +    int pred, av_uninit(extquant); <nl>      int extrabits = 0; <nl>   <nl>      int16_t *dc_val;
@@ -477,7 +477,10 @@ static int ra144_encode_frame(AVCodecContext *avctx, uint8_t *frame, <nl>           * The filter is unstable: use the coefficients of the previous frame. <nl>           */ <nl>          ff_int_to_int16(block_coefs[NBLOCKS - 1], ractx->lpc_coef[1]); <nl> -        ff_eval_refl(lpc_refl, block_coefs[NBLOCKS - 1], avctx); <nl> +        if (ff_eval_refl(lpc_refl, block_coefs[NBLOCKS - 1], avctx)) { <nl> +            /* the filter is still unstable. set reflection coeffs to zero. */ <nl> +            memset(lpc_refl, 0, sizeof(lpc_refl)); <nl> +        } <nl>      } <nl>      init_put_bits(&pb, frame, buf_size); <nl>      for (i = 0; i < LPC_ORDER; i++) {
@@ -421,7 +421,7 @@ static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame_ptr, <nl>          return ret; <nl>      out_frame = (int16_t*) frame->data[0]; <nl>   <nl> -    if (buf_size == 10) { <nl> +    if (buf_size % 10 == 0) { <nl>          packet_type = FORMAT_G729_8K; <nl>          format = &format_g729_8k; <nl>          //Reset voice decision <nl> @@ -711,7 +711,7 @@ static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame_ptr, <nl>      memmove(ctx->exc_base, ctx->exc_base + 2 * SUBFRAME_SIZE, (PITCH_DELAY_MAX+INTERPOL_LEN)*sizeof(int16_t)); <nl>   <nl>      *got_frame_ptr = 1; <nl> -    return buf_size; <nl> +    return packet_type == FORMAT_G729_8K ? 10 : 8; <nl>  } <nl>   <nl>  AVCodec ff_g729_decoder = { <nl> @@ -722,5 +722,5 @@ AVCodec ff_g729_decoder = { <nl>      .priv_data_size = sizeof(G729Context), <nl>      .init           = decoder_init, <nl>      .decode         = decode_frame, <nl> -    .capabilities   = CODEC_CAP_DR1, <nl> +    .capabilities   = CODEC_CAP_SUBFRAMES | CODEC_CAP_DR1, <nl>  };
@@ -2538,7 +2538,7 @@ static int encode_thread(AVCodecContext *c, void *arg){ <nl>      int mb_x, mb_y, pdif = 0; <nl>      int chr_h= 16>>s->chroma_y_shift; <nl>      int i, j; <nl> -    MpegEncContext best_s, backup_s; <nl> +    MpegEncContext best_s = { 0 }, backup_s; <nl>      uint8_t bit_buf[2][MAX_MB_BYTES]; <nl>      uint8_t bit_buf2[2][MAX_MB_BYTES]; <nl>      uint8_t bit_buf_tex[2][MAX_MB_BYTES];
@@ -144,6 +144,7 @@ static inline int set_options(AVFilterContext *ctx, const char *args) <nl>   <nl>              hue->hue_expr     = NULL; <nl>              hue->hue_deg_expr = NULL; <nl> +            hue->saturation_expr = NULL; <nl>   <nl>              if ((ret = av_set_options_string(hue, args, "=", ":")) < 0) <nl>                  return ret;
@@ -199,6 +199,9 @@ static int flic_decode_frame_8BPP(AVCodecContext *avctx, <nl>      num_chunks = bytestream2_get_le16(&g2); <nl>      bytestream2_skip(&g2, 8);  /* skip padding */ <nl>   <nl> +    if (frame_size < 16) <nl> +        return AVERROR_INVALIDDATA; <nl> + <nl>      frame_size -= 16; <nl>   <nl>      /* iterate through the chunks */ <nl> @@ -523,6 +526,8 @@ static int flic_decode_frame_15_16BPP(AVCodecContext *avctx, <nl>      if (frame_size > buf_size) <nl>          frame_size = buf_size; <nl>   <nl> +    if (frame_size < 16) <nl> +        return AVERROR_INVALIDDATA; <nl>      frame_size -= 16; <nl>   <nl>      /* iterate through the chunks */ <nl> @@ -815,6 +820,8 @@ static int flic_decode_frame_24BPP(AVCodecContext *avctx, <nl>      if (frame_size > buf_size) <nl>          frame_size = buf_size; <nl>   <nl> +    if (frame_size < 16) <nl> +        return AVERROR_INVALIDDATA; <nl>      frame_size -= 16; <nl>   <nl>      /* iterate through the chunks */
@@ -150,8 +150,8 @@ static void find_block_motion(DeshakeContext *deshake, uint8_t *src1, <nl>          } <nl>      } else if (deshake->search == SMART_EXHAUSTIVE) { <nl>          // Compare every other possible position and find the best match <nl> -        for (y = -deshake->ry + 1; y < deshake->ry - 2; y += 2) { <nl> -            for (x = -deshake->rx + 1; x < deshake->rx - 2; x += 2) { <nl> +        for (y = -deshake->ry + 1; y < deshake->ry; y += 2) { <nl> +            for (x = -deshake->rx + 1; x < deshake->rx; x += 2) { <nl>                  diff = CMP(cx - x, cy - y); <nl>                  if (diff < smallest) { <nl>                      smallest = diff;
@@ -1176,7 +1176,7 @@ static int svq3_decode_frame(AVCodecContext *avctx, void *data, <nl>   <nl>      h->cur_pic_ptr = s->cur_pic; <nl>      av_frame_unref(&h->cur_pic.f); <nl> -    h->cur_pic     = *s->cur_pic; <nl> +    memcpy(&h->cur_pic.tf, &s->cur_pic->tf, sizeof(h->cur_pic) - offsetof(H264Picture, tf)); <nl>      ret = av_frame_ref(&h->cur_pic.f, &s->cur_pic->f); <nl>      if (ret < 0) <nl>          return ret;
@@ -119,7 +119,8 @@ CFDataRef ff_videotoolbox_avcc_extradata_create(AVCodecContext *avctx) <nl>   <nl>      // save sps header (profile/level) used to create decoder session, <nl>      // so we can detect changes and recreate it. <nl> -    memcpy(vtctx->sps, h->ps.sps->data + 1, 3); <nl> +    if (vtctx) <nl> +        memcpy(vtctx->sps, h->ps.sps->data + 1, 3); <nl>   <nl>      data = CFDataCreate(kCFAllocatorDefault, vt_extradata, vt_extradata_size); <nl>      av_free(vt_extradata); <nl> @@ -323,6 +324,11 @@ static int videotoolbox_h264_decode_params(AVCodecContext *avctx, <nl>                                             uint32_t size) <nl>  { <nl>      VTContext *vtctx = avctx->internal->hwaccel_priv_data; <nl> +    H264Context *h = avctx->priv_data; <nl> + <nl> +    // save sps header (profile/level) used to create decoder session <nl> +    if (!vtctx->sps[0]) <nl> +        memcpy(vtctx->sps, h->ps.sps->data + 1, 3); <nl>   <nl>      if (type == H264_NAL_SPS) { <nl>          if (size > 4 && memcmp(vtctx->sps, buffer + 1, 3) != 0) {
@@ -241,10 +241,6 @@ static int vp9_raw_reorder_make_output(AVBSFContext *bsf, <nl>                 "(%"PRId64") from slot %d.\n", <nl>                 frame->sequence, frame->pts, s); <nl>   <nl> -        frame->packet = av_packet_alloc(); <nl> -        if (!frame->packet) <nl> -            return AVERROR(ENOMEM); <nl> - <nl>          err = av_new_packet(out, 2); <nl>          if (err < 0) <nl>              return err;
@@ -34,6 +34,7 @@ <nl>  #include "libavutil/imgutils.h" <nl>  #include "libavutil/mathematics.h" <nl>  #include "libavutil/opt.h" <nl> +#include "libavutil/timestamp.h" <nl>  #include "internal.h" <nl>  #include "dualinput.h" <nl>  #include "drawutils.h" <nl> @@ -576,6 +577,7 @@ static AVFrame *do_blend(AVFilterContext *ctx, AVFrame *mainpic, <nl>  static int filter_frame(AVFilterLink *inlink, AVFrame *inpicref) <nl>  { <nl>      OverlayContext *s = inlink->dst->priv; <nl> +    av_log(inlink->dst, AV_LOG_DEBUG, "Incoming frame (time:%s) from link #%d\n", av_ts2timestr(inpicref->pts, &inlink->time_base), FF_INLINK_IDX(inlink)); <nl>      return ff_dualinput_filter_frame(&s->dinput, inlink, inpicref); <nl>  } <nl>  
@@ -1605,7 +1605,7 @@ static void mov_build_index(MOVContext *mov, AVStream *st) <nl>          if (sc->time_offset < 0) <nl>              sc->time_offset = av_rescale(sc->time_offset, sc->time_scale, mov->time_scale); <nl>          current_dts = -sc->time_offset; <nl> -        if (sc->ctts_data && sc->stts_data && <nl> +        if (sc->ctts_data && sc->stts_data && sc->stts_data[0].duration && <nl>              sc->ctts_data[0].duration / sc->stts_data[0].duration > 16) { <nl>              /* more than 16 frames delay, dts are likely wrong <nl>                 this happens with files created by iMovie */
@@ -123,6 +123,7 @@ static int raw_decode(AVCodecContext *avctx, <nl>      AVFrame * frame = (AVFrame *) data; <nl>      AVPicture * picture = (AVPicture *) data; <nl>   <nl> +    frame->pict_type        = avctx->coded_frame->pict_type; <nl>      frame->interlaced_frame = avctx->coded_frame->interlaced_frame; <nl>      frame->top_field_first = avctx->coded_frame->top_field_first; <nl>      frame->reordered_opaque = avctx->reordered_opaque;
@@ -92,8 +92,12 @@ AVFilterBufferRef *avfilter_get_video_buffer_ref_from_frame(const AVFrame *frame <nl>  AVFilterBufferRef *avfilter_get_audio_buffer_ref_from_frame(const AVFrame *frame, <nl>                                                              int perms) <nl>  { <nl> -    AVFilterBufferRef *samplesref = <nl> -        avfilter_get_audio_buffer_ref_from_arrays((uint8_t **)frame->data, frame->linesize[0], perms, <nl> +    AVFilterBufferRef *samplesref; <nl> + <nl> +    if(av_frame_get_channels(frame) > 8) // libavfilter does not suport more than 8 channels FIXME, remove once libavfilter is fixed <nl> +        return NULL; <nl> + <nl> +    samplesref = avfilter_get_audio_buffer_ref_from_arrays((uint8_t **)frame->data, frame->linesize[0], perms, <nl>                                                    frame->nb_samples, frame->format, <nl>                                                    av_frame_get_channel_layout(frame)); <nl>      if (!samplesref)
@@ -1269,6 +1269,8 @@ static int jpeg2000_decode_frame(AVCodecContext *avctx, void *data, <nl>                     "couldn't find jpeg2k codestream atom\n"); <nl>              return -1; <nl>          } <nl> +    } else if (AV_RB16(s->buf) != JPEG2000_SOC && AV_RB32(s->buf + 4) == JP2_CODESTREAM) { <nl> +        s->buf += 8; <nl>      } <nl>   <nl>      if (bytestream_get_be16(&s->buf) != JPEG2000_SOC) {
@@ -102,6 +102,8 @@ static int vdadec_decode(AVCodecContext *avctx, <nl>          AVBufferRef *buffer = pic->buf[0]; <nl>          VDABufferContext *context = av_buffer_get_opaque(buffer); <nl>          CVPixelBufferRef cv_buffer = (CVPixelBufferRef)pic->data[3]; <nl> + <nl> +        CVPixelBufferRetain(cv_buffer); <nl>          CVPixelBufferLockBaseAddress(cv_buffer, 0); <nl>          context->cv_buffer = cv_buffer; <nl>          pic->format = ctx->pix_fmt; <nl> @@ -202,6 +204,7 @@ static av_cold int vdadec_init(AVCodecContext *avctx) <nl>      vda_ctx->height = avctx->height; <nl>      vda_ctx->format = 'avc1'; <nl>      vda_ctx->use_sync_decoding = 1; <nl> +    vda_ctx->use_ref_buffer = 1; <nl>      ctx->pix_fmt = avctx->get_format(avctx, avctx->codec->pix_fmts); <nl>      switch (ctx->pix_fmt) { <nl>      case AV_PIX_FMT_UYVY422:
@@ -601,6 +601,7 @@ int ff_frame_thread_init(AVCodecContext *avctx) <nl>   <nl>          p->frame = av_frame_alloc(); <nl>          if (!p->frame) { <nl> +            av_freep(&copy); <nl>              err = AVERROR(ENOMEM); <nl>              goto error; <nl>          }
@@ -158,6 +158,9 @@ static int cmv_decode_frame(AVCodecContext *avctx, <nl>      CmvContext *s = avctx->priv_data; <nl>      const uint8_t *buf_end = buf + buf_size; <nl>   <nl> +    if (buf_end - buf < EA_PREAMBLE_SIZE) <nl> +        return AVERROR_INVALIDDATA; <nl> + <nl>      if (AV_RL32(buf)==MVIh_TAG||AV_RB32(buf)==MVIh_TAG) { <nl>          cmv_process_header(s, buf+EA_PREAMBLE_SIZE, buf_end); <nl>          return buf_size;
@@ -774,13 +774,15 @@ static int decode_audio_specific_config(AACContext *ac, <nl>  { <nl>      GetBitContext gb; <nl>      int i; <nl> +    int ret; <nl>   <nl>      av_dlog(avctx, "audio specific config size %d\n", bit_size >> 3); <nl>      for (i = 0; i < bit_size >> 3; i++) <nl>           av_dlog(avctx, "%02x ", data[i]); <nl>      av_dlog(avctx, "\n"); <nl>   <nl> -    init_get_bits(&gb, data, bit_size); <nl> +    if ((ret = init_get_bits(&gb, data, bit_size)) < 0) <nl> +        return ret; <nl>   <nl>      if ((i = avpriv_mpeg4audio_get_config(m4ac, data, bit_size, sync_extension)) < 0) <nl>          return -1; <nl> @@ -2922,7 +2924,8 @@ static int latm_decode_frame(AVCodecContext *avctx, void *out, <nl>      int                 muxlength, err; <nl>      GetBitContext       gb; <nl>   <nl> -    init_get_bits(&gb, avpkt->data, avpkt->size * 8); <nl> +    if ((err = init_get_bits8(&gb, avpkt->data, avpkt->size)) < 0) <nl> +        return err; <nl>   <nl>      // check for LOAS sync word <nl>      if (get_bits(&gb, 11) != LOAS_SYNC_WORD)
@@ -324,11 +324,15 @@ static int decode_nal_sei_message(GetBitContext *gb, void *logctx, HEVCSEI *s, <nl>      av_log(logctx, AV_LOG_DEBUG, "Decoding SEI\n"); <nl>   <nl>      while (byte == 0xFF) { <nl> +        if (get_bits_left(gb) < 16 || payload_type > INT_MAX - 255) <nl> +            return AVERROR_INVALIDDATA; <nl>          byte          = get_bits(gb, 8); <nl>          payload_type += byte; <nl>      } <nl>      byte = 0xFF; <nl>      while (byte == 0xFF) { <nl> +        if (get_bits_left(gb) < 8 + 8LL*payload_size) <nl> +            return AVERROR_INVALIDDATA; <nl>          byte          = get_bits(gb, 8); <nl>          payload_size += byte; <nl>      }
@@ -1658,6 +1658,9 @@ static int mkv_parse_video_projection(AVStream *st, const MatroskaTrack *track) <nl>              return AVERROR_INVALIDDATA; <nl>          } <nl>          break; <nl> +    case MATROSKA_VIDEO_PROJECTION_TYPE_RECTANGULAR: <nl> +        /* No Spherical metadata */ <nl> +        return 0; <nl>      default: <nl>          av_log(NULL, AV_LOG_WARNING, <nl>                 "Unknown spherical metadata type %"PRIu64"\n",
@@ -1355,8 +1355,8 @@ static int mc_subpel(DiracContext *s, DiracBlock *block, const uint8_t *src[5], <nl>          motion_y >>= s->chroma_y_shift; <nl>      } <nl>   <nl> -    mx         = motion_x & ~(-1 << s->mv_precision); <nl> -    my         = motion_y & ~(-1 << s->mv_precision); <nl> +    mx         = motion_x & ~(-1U << s->mv_precision); <nl> +    my         = motion_y & ~(-1U << s->mv_precision); <nl>      motion_x >>= s->mv_precision; <nl>      motion_y >>= s->mv_precision; <nl>      /* normalize subpel coordinates to epel */
@@ -406,6 +406,10 @@ static int flashsv_decode_frame(AVCodecContext *avctx, void *data, <nl>                  int k; <nl>                  int off = (s->image_height - y_pos - 1) * s->frame.linesize[0]; <nl>   <nl> +                if (!s->keyframe) { <nl> +                    av_log(avctx, AV_LOG_ERROR, "no keyframe yet\n"); <nl> +                    return AVERROR_INVALIDDATA; <nl> +                } <nl>                  for (k = 0; k < cur_blk_height; k++) <nl>                      memcpy(s->frame.data[0] + off - k*s->frame.linesize[0] + x_pos*3, <nl>                             s->keyframe + off - k*s->frame.linesize[0] + x_pos*3,
@@ -2268,8 +2268,10 @@ matroska_parse_block(MatroskaDemuxContext *matroska, uint8_t *data, int size, <nl>          av_free(origdata); <nl>          return res; <nl>      } <nl> -    if (matroska->tracks[track]->stream_index < 0) <nl> +    if (matroska->tracks[track]->stream_index < 0) { <nl> +        av_free(origdata); <nl>          return res; <nl> +    } <nl>      st = matroska->ctx->streams[matroska->tracks[track]->stream_index]; <nl>      if (st->discard >= AVDISCARD_ALL) { <nl>          av_free(origdata); <nl> @@ -2287,8 +2289,10 @@ matroska_parse_block(MatroskaDemuxContext *matroska, uint8_t *data, int size, <nl>          is_keyframe = flags & 0x80 ? PKT_FLAG_KEY : 0; <nl>   <nl>      if (matroska->skip_to_keyframe) { <nl> -        if (!is_keyframe || st != matroska->skip_to_stream) <nl> +        if (!is_keyframe || st != matroska->skip_to_stream) { <nl> +            av_free(origdata); <nl>              return res; <nl> +        } <nl>          matroska->skip_to_keyframe = 0; <nl>      } <nl>  
@@ -119,8 +119,10 @@ int main(int argc, char *argv[]) <nl>  end: <nl>      avformat_close_input(&fmt_ctx); <nl>      /* note: the internal buffer could have changed, and be != avio_ctx_buffer */ <nl> -    av_freep(&avio_ctx->buffer); <nl> -    av_freep(&avio_ctx); <nl> +    if (avio_ctx) { <nl> +        av_freep(&avio_ctx->buffer); <nl> +        av_freep(&avio_ctx); <nl> +    } <nl>      av_file_unmap(buffer, buffer_size); <nl>   <nl>      if (ret < 0) {
@@ -767,7 +767,7 @@ static int recover(WtvContext *wtv, uint64_t broken_pos) <nl>      int i; <nl>      for (i = 0; i < wtv->nb_index_entries; i++) { <nl>          if (wtv->index_entries[i].pos > broken_pos) { <nl> -            int ret = avio_seek(pb, wtv->index_entries[i].pos, SEEK_SET); <nl> +            int64_t ret = avio_seek(pb, wtv->index_entries[i].pos, SEEK_SET); <nl>              if (ret < 0) <nl>                  return ret; <nl>              wtv->pts = wtv->index_entries[i].timestamp;
@@ -231,6 +231,11 @@ static int filter_frame(AVFilterLink *inlink, AVFilterBufferRef *insamples) <nl>          if (inlink == ctx->inputs[input_number]) <nl>              break; <nl>      av_assert1(input_number < am->nb_inputs); <nl> +    if (ff_bufqueue_is_full(&am->in[input_number].queue)) { <nl> +        av_log(ctx, AV_LOG_ERROR, "Buffer queue overflow\n"); <nl> +        avfilter_unref_buffer(insamples); <nl> +        return AVERROR(ENOMEM); <nl> +    } <nl>      ff_bufqueue_add(ctx, &am->in[input_number].queue, insamples); <nl>      am->in[input_number].nb_samples += insamples->audio->nb_samples; <nl>      nb_samples = am->in[0].nb_samples;
@@ -235,7 +235,7 @@ static ResampleContext *resample_init(ResampleContext *c, int out_rate, int in_r <nl>          c->factor        = factor; <nl>          c->filter_length = FFMAX((int)ceil(filter_size/factor), 1); <nl>          c->filter_alloc  = FFALIGN(c->filter_length, 8); <nl> -        c->filter_bank   = av_mallocz(c->filter_alloc*(phase_count+1)*c->felem_size); <nl> +        c->filter_bank   = av_calloc(c->filter_alloc, (phase_count+1)*c->felem_size); <nl>          c->filter_type   = filter_type; <nl>          c->kaiser_beta   = kaiser_beta; <nl>          if (!c->filter_bank)
@@ -93,6 +93,8 @@ static int get_channel_idx(char **map, int *ch, char delim, int max_ch) <nl>      int n = 0; <nl>      if (!next && delim == '-') <nl>          return AVERROR(EINVAL); <nl> +    if (!*map) <nl> +        return AVERROR(EINVAL); <nl>      len = strlen(*map); <nl>      sscanf(*map, "%d%n", ch, &n); <nl>      if (n != len)
@@ -5364,9 +5364,10 @@ static int vc1_decode_frame(AVCodecContext *avctx, void *data, <nl>                      break; <nl>                  case VC1_CODE_FIELD: { <nl>                      int buf_size3; <nl> -                    slices = av_realloc(slices, sizeof(*slices) * (n_slices+1)); <nl> -                    if (!slices) <nl> +                    tmp = av_realloc(slices, sizeof(*slices) * (n_slices+1)); <nl> +                    if (!tmp) <nl>                          goto err; <nl> +                    slices = tmp; <nl>                      slices[n_slices].buf = av_mallocz(buf_size + FF_INPUT_BUFFER_PADDING_SIZE); <nl>                      if (!slices[n_slices].buf) <nl>                          goto err; <nl> @@ -5388,9 +5389,10 @@ static int vc1_decode_frame(AVCodecContext *avctx, void *data, <nl>                      break; <nl>                  case VC1_CODE_SLICE: { <nl>                      int buf_size3; <nl> -                    slices = av_realloc(slices, sizeof(*slices) * (n_slices+1)); <nl> -                    if (!slices) <nl> +                    tmp = av_realloc(slices, sizeof(*slices) * (n_slices+1)); <nl> +                    if (!tmp) <nl>                          goto err; <nl> +                    slices = tmp; <nl>                      slices[n_slices].buf = av_mallocz(buf_size + FF_INPUT_BUFFER_PADDING_SIZE); <nl>                      if (!slices[n_slices].buf) <nl>                          goto err;
@@ -43,7 +43,7 @@ typedef struct VBDecContext { <nl>      AVFrame pic; <nl>   <nl>      uint8_t *frame, *prev_frame; <nl> -    uint32_t pal[256]; <nl> +    uint32_t pal[AVPALETTE_COUNT]; <nl>      const uint8_t *stream; <nl>  } VBDecContext; <nl>  
@@ -312,6 +312,7 @@ static int submit_packet(PerThreadContext *p, AVPacket *avpkt) <nl>      FrameThreadContext *fctx = p->parent; <nl>      PerThreadContext *prev_thread = fctx->prev_thread; <nl>      const AVCodec *codec = p->avctx->codec; <nl> +    int ret; <nl>   <nl>      if (!avpkt->size && !(codec->capabilities & AV_CODEC_CAP_DELAY)) <nl>          return 0; <nl> @@ -337,7 +338,12 @@ static int submit_packet(PerThreadContext *p, AVPacket *avpkt) <nl>      } <nl>   <nl>      av_packet_unref(&p->avpkt); <nl> -    av_packet_ref(&p->avpkt, avpkt); <nl> +    ret = av_packet_ref(&p->avpkt, avpkt); <nl> +    if (ret < 0) { <nl> +        pthread_mutex_unlock(&p->mutex); <nl> +        av_log(p->avctx, AV_LOG_ERROR, "av_packet_ref() failed in submit_packet()\n"); <nl> +        return ret; <nl> +    } <nl>   <nl>      p->state = STATE_SETTING_UP; <nl>      pthread_cond_signal(&p->input_cond);
@@ -238,17 +238,18 @@ static inline int pred_non_zero_count(H264Context *h, int n){ <nl>  } <nl>   <nl>  static av_cold void init_cavlc_level_tab(void){ <nl> -    int suffix_length, mask; <nl> +    int suffix_length; <nl>      unsigned int i; <nl>   <nl>      for(suffix_length=0; suffix_length<7; suffix_length++){ <nl>          for(i=0; i<(1<<LEVEL_TAB_BITS); i++){ <nl>              int prefix= LEVEL_TAB_BITS - av_log2(2*i); <nl> -            int level_code= (prefix<<suffix_length) + (i>>(LEVEL_TAB_BITS-prefix-1-suffix_length)) - (1<<suffix_length); <nl>   <nl> -            mask= -(level_code&1); <nl> -            level_code= (((2+level_code)>>1) ^ mask) - mask; <nl>              if(prefix + 1 + suffix_length <= LEVEL_TAB_BITS){ <nl> +                int level_code = (prefix << suffix_length) + <nl> +                    (i >> (av_log2(i) - suffix_length)) - (1 << suffix_length); <nl> +                int mask = -(level_code&1); <nl> +                level_code = (((2 + level_code) >> 1) ^ mask) - mask; <nl>                  cavlc_level_tab[suffix_length][i][0]= level_code; <nl>                  cavlc_level_tab[suffix_length][i][1]= prefix + 1 + suffix_length; <nl>              }else if(prefix + 1 <= LEVEL_TAB_BITS){
@@ -104,6 +104,7 @@ static int msnwc_tcp_read_packet(AVFormatContext *ctx, AVPacket *pkt) <nl>      AVIOContext *pb = ctx->pb; <nl>      uint16_t keyframe; <nl>      uint32_t size, timestamp; <nl> +    int ret; <nl>   <nl>      avio_skip(pb, 1); /* one byte has been read ahead */ <nl>      avio_skip(pb, 2); <nl> @@ -114,8 +115,11 @@ static int msnwc_tcp_read_packet(AVFormatContext *ctx, AVPacket *pkt) <nl>      avio_skip(pb, 4); <nl>      timestamp = avio_rl32(pb); <nl>   <nl> -    if(!size || av_get_packet(pb, pkt, size) != size) <nl> -        return -1; <nl> +    if (!size) <nl> +        return AVERROR_INVALIDDATA; <nl> + <nl> +    if ((ret = av_get_packet(pb, pkt, size)) < 0) <nl> +        return ret; <nl>   <nl>      avio_skip(pb, 1); /* Read ahead one byte of struct size like read_header */ <nl>  
@@ -3382,8 +3382,12 @@ static OutputStream *choose_output(void) <nl>   <nl>      for (i = 0; i < nb_output_streams; i++) { <nl>          OutputStream *ost = output_streams[i]; <nl> -        int64_t opts = av_rescale_q(ost->st->cur_dts, ost->st->time_base, <nl> +        int64_t opts = ost->st->cur_dts == AV_NOPTS_VALUE ? INT64_MIN : <nl> +                       av_rescale_q(ost->st->cur_dts, ost->st->time_base, <nl>                                      AV_TIME_BASE_Q); <nl> +        if (ost->st->cur_dts == AV_NOPTS_VALUE) <nl> +            av_log(NULL, AV_LOG_DEBUG, "cur_dts is invalid (this is harmless if it occurs once at the start per stream)\n"); <nl> + <nl>          if (!ost->finished && opts < opts_min) { <nl>              opts_min = opts; <nl>              ost_min  = ost->unavailable ? NULL : ost;
@@ -3216,17 +3216,19 @@ static inline void RENAME(duplicate)(uint8_t src[], int stride) <nl>  #if TEMPLATE_PP_MMX <nl>      __asm__ volatile( <nl>          "movq (%0), %%mm0               \n\t" <nl> +        "movq %%mm0, (%0, %1, 4)        \n\t" <nl>          "add %1, %0                     \n\t" <nl>          "movq %%mm0, (%0)               \n\t" <nl>          "movq %%mm0, (%0, %1)           \n\t" <nl>          "movq %%mm0, (%0, %1, 2)        \n\t" <nl> +        "movq %%mm0, (%0, %1, 4)        \n\t" <nl>          : "+r" (src) <nl>          : "r" ((x86_reg)-stride) <nl>      ); <nl>  #else <nl>      int i; <nl>      uint8_t *p=src; <nl> -    for(i=0; i<3; i++){ <nl> +    for(i=0; i<5; i++){ <nl>          p-= stride; <nl>          memcpy(p, src, 8); <nl>      }
@@ -877,8 +877,8 @@ static int huffman_decode(MPADecodeContext *s, GranuleDef *g, <nl>   <nl>              exponent= exponents[s_index]; <nl>   <nl> -            ff_dlog(s->avctx, "region=%d n=%d x=%d y=%d exp=%d\n", <nl> -                    i, g->region_size[i] - j, x, y, exponent); <nl> +            ff_dlog(s->avctx, "region=%d n=%d y=%d exp=%d\n", <nl> +                    i, g->region_size[i] - j, y, exponent); <nl>              if (y & 16) { <nl>                  x = y >> 5; <nl>                  y = y & 0x0f;
@@ -1501,6 +1501,15 @@ int ff_mjpeg_decode_sos(MJpegDecodeContext *s, const uint8_t *mb_bitmask, <nl>          return -1; <nl>      } <nl>   <nl> +    if (reference) { <nl> +        if (reference->width  != s->picture_ptr->width  || <nl> +            reference->height != s->picture_ptr->height || <nl> +            reference->format != s->picture_ptr->format) { <nl> +            av_log(s->avctx, AV_LOG_ERROR, "Reference mismatching\n"); <nl> +            return AVERROR_INVALIDDATA; <nl> +        } <nl> +    } <nl> + <nl>      av_assert0(s->picture_ptr->data[0]); <nl>      /* XXX: verify len field validity */ <nl>      len = get_bits(&s->gb, 16);
@@ -237,6 +237,8 @@ static int decode_pic_hdr(IVI45DecContext *ctx, AVCodecContext *avctx) <nl>      /* skip picture header extension if any */ <nl>      while (get_bits1(&ctx->gb)) { <nl>          ff_dlog(avctx, "Pic hdr extension encountered!\n"); <nl> +        if (get_bits_left(&ctx->gb) < 10) <nl> +            return AVERROR_INVALIDDATA; <nl>          skip_bits(&ctx->gb, 8); <nl>      } <nl>  
@@ -394,7 +394,7 @@ static void buf_set(AudioData *out, AudioData *in, int count){ <nl>          for(ch=0; ch<out->ch_count; ch++) <nl>              out->ch[ch]= in->ch[ch] + count*out->bps; <nl>      }else{ <nl> -        for(ch=0; ch<out->ch_count; ch++) <nl> +        for(ch=out->ch_count-1; ch>=0; ch--) <nl>              out->ch[ch]= in->ch[0] + (ch + count*out->ch_count) * out->bps; <nl>      } <nl>  }
@@ -46,6 +46,9 @@ int ff_vaapi_render_picture(struct vaapi_context *vactx, VASurfaceID surface) <nl>      VABufferID va_buffers[3]; <nl>      unsigned int n_va_buffers = 0; <nl>   <nl> +    if (!vactx->pic_param_buf_id) <nl> +        return 0; <nl> + <nl>      vaUnmapBuffer(vactx->display, vactx->pic_param_buf_id); <nl>      va_buffers[n_va_buffers++] = vactx->pic_param_buf_id; <nl>  
@@ -402,6 +402,8 @@ static int decodeTonalComponents (GetBitContext *gb, tonal_component *pComponent <nl>   <nl>              for (k=0; k<coded_components; k++) { <nl>                  sfIndx = get_bits(gb,6); <nl> +                if (component_count >= 64) <nl> +                    return AVERROR_INVALIDDATA; <nl>                  pComponent[component_count].pos = j * 64 + (get_bits(gb,6)); <nl>                  max_coded_values = SAMPLES_PER_FRAME - pComponent[component_count].pos; <nl>                  coded_values = coded_values_per_component + 1;
@@ -681,7 +681,7 @@ static void floor_fit(vorbis_enc_context *venc, vorbis_enc_floor *fc, <nl>          float average = averages[i]; <nl>          int j; <nl>   <nl> -        average *= pow(tot_average / average, 0.5) * pow(1.25, position/200.); // MAGIC! <nl> +        average = sqrt(tot_average * average) * pow(1.25f, position*0.005f); // MAGIC! <nl>          for (j = 0; j < range - 1; j++) <nl>              if (ff_vorbis_floor1_inverse_db_table[j * fc->multiplier] > average) <nl>                  break;
@@ -53,6 +53,7 @@ int ff_lzf_uncompress(GetByteContext *gb, uint8_t **buf, int64_t *size) <nl>                  ret = av_reallocp(buf, *size); <nl>                  if (ret < 0) <nl>                      return ret; <nl> +                p = *buf + len; <nl>              } <nl>   <nl>              bytestream2_get_buffer(gb, p, s); <nl> @@ -75,6 +76,7 @@ int ff_lzf_uncompress(GetByteContext *gb, uint8_t **buf, int64_t *size) <nl>                  ret = av_reallocp(buf, *size); <nl>                  if (ret < 0) <nl>                      return ret; <nl> +                p = *buf + len; <nl>              } <nl>   <nl>              av_memcpy_backptr(p, off, l);
@@ -80,9 +80,11 @@ int avpriv_mpeg4audio_get_config(MPEG4AudioConfig *c, const uint8_t *buf, <nl>                                   int bit_size, int sync_extension) <nl>  { <nl>      GetBitContext gb; <nl> -    int specific_config_bitindex; <nl> +    int specific_config_bitindex, ret; <nl>   <nl> -    init_get_bits(&gb, buf, bit_size); <nl> +    ret = init_get_bits(&gb, buf, bit_size); <nl> +    if (ret < 0) <nl> +        return ret; <nl>      c->object_type = get_object_type(&gb); <nl>      c->sample_rate = get_sample_rate(&gb, &c->sampling_index); <nl>      c->chan_config = get_bits(&gb, 4);
@@ -3546,6 +3546,8 @@ void avformat_free_context(AVFormatContext *s) <nl>      av_opt_free(s); <nl>      if (s->iformat && s->iformat->priv_class && s->priv_data) <nl>          av_opt_free(s->priv_data); <nl> +    if (s->oformat && s->oformat->priv_class && s->priv_data) <nl> +        av_opt_free(s->priv_data); <nl>   <nl>      for (i = s->nb_streams - 1; i >= 0; i--) { <nl>          ff_free_stream(s, s->streams[i]);
@@ -705,7 +705,7 @@ static uint64_t calc_rice_params(RiceContext *rc, <nl>      bits[pmin] = UINT32_MAX; <nl>      for (i = pmax; ; ) { <nl>          bits[i] = calc_optimal_rice_params(&tmp_rc, i, sums, n, pred_order, kmax, exact); <nl> -        if (bits[i] < bits[opt_porder]) { <nl> +        if (bits[i] < bits[opt_porder] || pmax == pmin) { <nl>              opt_porder = i; <nl>              *rc = tmp_rc; <nl>          }
@@ -177,7 +177,6 @@ static int read_frame(BVID_DemuxContext *vid, AVIOContext *pb, AVPacket *pkt, <nl>      if ((ret = av_new_packet(pkt, vidbuf_nbytes)) < 0) <nl>          goto fail; <nl>      memcpy(pkt->data, vidbuf_start, vidbuf_nbytes); <nl> -    av_free(vidbuf_start); <nl>   <nl>      pkt->pos = position; <nl>      pkt->stream_index = vid->video_index; <nl> @@ -198,7 +197,6 @@ static int read_frame(BVID_DemuxContext *vid, AVIOContext *pb, AVPacket *pkt, <nl>      } <nl>   <nl>      vid->nframes--;  // used to check if all the frames were read <nl> -    return 0; <nl>  fail: <nl>      av_free(vidbuf_start); <nl>      return ret;
@@ -220,6 +220,7 @@ int main(int argc, char **argv) <nl>          goto end; <nl>   <nl>      /* read all packets */ <nl> +    packet0.data = NULL; <nl>      packet.data = NULL; <nl>      while (1) { <nl>          if (!packet0.data) {
@@ -279,7 +279,7 @@ int dv_assemble_frame(DVMuxContext *c, AVStream* st, <nl>   <nl>  DVMuxContext* dv_init_mux(AVFormatContext* s) <nl>  { <nl> -    DVMuxContext *c; <nl> +    DVMuxContext *c = (DVMuxContext *)s->priv_data; <nl>      AVStream *vst = NULL; <nl>      int i; <nl>   <nl> @@ -287,10 +287,6 @@ DVMuxContext* dv_init_mux(AVFormatContext* s) <nl>      if (s->nb_streams > 3) <nl>          return NULL; <nl>   <nl> -    c = av_mallocz(sizeof(DVMuxContext)); <nl> -    if (!c) <nl> -        return NULL; <nl> - <nl>      c->n_ast = 0; <nl>      c->ast[0] = c->ast[1] = NULL; <nl>   <nl> @@ -345,7 +341,6 @@ DVMuxContext* dv_init_mux(AVFormatContext* s) <nl>      return c; <nl>   <nl>  bail_out: <nl> -    av_free(c); <nl>      return NULL; <nl>  } <nl>   <nl> @@ -359,8 +354,7 @@ void dv_delete_mux(DVMuxContext *c) <nl>  #ifdef CONFIG_MUXERS <nl>  static int dv_write_header(AVFormatContext *s) <nl>  { <nl> -    s->priv_data = dv_init_mux(s); <nl> -    if (!s->priv_data) { <nl> +    if (!dv_init_mux(s)) { <nl>          av_log(s, AV_LOG_ERROR, "Can't initialize DV format!\n" <nl>                      "Make sure that you supply exactly two streams:\n" <nl>                      "     video: 25fps or 29.97fps, audio: 2ch/48Khz/PCM\n"
@@ -1103,7 +1103,7 @@ int ff_rtsp_make_setup_request(AVFormatContext *s, const char *host, int port, <nl>                                int lower_transport, const char *real_challenge) <nl>  { <nl>      RTSPState *rt = s->priv_data; <nl> -    int rtx, j, i, err, interleave = 0; <nl> +    int rtx = 0, j, i, err, interleave = 0; <nl>      RTSPStream *rtsp_st; <nl>      RTSPMessageHeader reply1, *reply = &reply1; <nl>      char cmd[2048];
@@ -565,8 +565,8 @@ static int opus_decode_packet(AVCodecContext *avctx, void *data, <nl>          if (buffer_samples) { <nl>              float *buf[2] = { c->out[2 * i + 0] ? c->out[2 * i + 0] : (float*)frame->extended_data[0], <nl>                                c->out[2 * i + 1] ? c->out[2 * i + 1] : (float*)frame->extended_data[0] }; <nl> -            buf[0] += buffer_samples; <nl> -            buf[1] += buffer_samples; <nl> +            buf[0] += decoded_samples; <nl> +            buf[1] += decoded_samples; <nl>              ret = av_audio_fifo_write(c->sync_buffers[i], (void**)buf, buffer_samples); <nl>              if (ret < 0) <nl>                  return ret;
@@ -157,8 +157,8 @@ void ff_ac3_bit_alloc_calc_mask(AC3BitAllocParameters *s, int16_t *band_psd, <nl>      if (dba_mode == DBA_REUSE || dba_mode == DBA_NEW) { <nl>          int band, seg, delta; <nl>          band = 0; <nl> -        for (seg = 0; seg < dba_nsegs; seg++) { <nl> -            band += dba_offsets[seg]; <nl> +        for (seg = 0; seg < FFMIN(8, dba_nsegs); seg++) { <nl> +            band = FFMIN(49, band + dba_offsets[seg]); <nl>              if (dba_values[seg] >= 4) { <nl>                  delta = (dba_values[seg] - 3) << 7; <nl>              } else {
@@ -20,6 +20,7 @@ <nl>   */ <nl>   <nl>  #include "libavutil/channel_layout.h" <nl> +#include "libavutil/imgutils.h" <nl>  #include "libavutil/intreadwrite.h" <nl>  #include "libavutil/intfloat.h" <nl>  #include "avformat.h" <nl> @@ -188,6 +189,10 @@ static int nuv_header(AVFormatContext *s) <nl>              return AVERROR(ENOMEM); <nl>          ctx->v_id = vst->index; <nl>   <nl> +        ret = av_image_check_size(width, height, 0, ctx); <nl> +        if (ret < 0) <nl> +            return ret; <nl> + <nl>          vst->codec->codec_type            = AVMEDIA_TYPE_VIDEO; <nl>          vst->codec->codec_id              = AV_CODEC_ID_NUV; <nl>          vst->codec->width                 = width;
@@ -848,6 +848,7 @@ static int ff_asf_parse_packet(AVFormatContext *s, ByteIOContext *pb, AVPacket * <nl>      ASFContext *asf = s->priv_data; <nl>      ASFStream *asf_st = 0; <nl>      for (;;) { <nl> +        int ret; <nl>          if(url_feof(pb)) <nl>              return AVERROR_EOF; <nl>          if (asf->packet_size_left < FRAME_HEADER_SIZE <nl> @@ -950,8 +951,10 @@ static int ff_asf_parse_packet(AVFormatContext *s, ByteIOContext *pb, AVPacket * <nl>              continue; <nl>          } <nl>   <nl> -        get_buffer(pb, asf_st->pkt.data + asf->packet_frag_offset, <nl> -                   asf->packet_frag_size); <nl> +        ret = get_buffer(pb, asf_st->pkt.data + asf->packet_frag_offset, <nl> +                         asf->packet_frag_size); <nl> +        if (ret != asf->packet_frag_size) <nl> +            return ret >= 0 ? AVERROR_EOF : ret; <nl>          if (s->key && s->keylen == 20) <nl>              ff_asfcrypt_dec(s->key, asf_st->pkt.data + asf->packet_frag_offset, <nl>                              asf->packet_frag_size);
@@ -25,6 +25,11 @@ <nl>  #include "libavutil/pixdesc.h" <nl>  #include "avcodec.h" <nl>  #include "internal.h" <nl> + <nl> +#if defined(_MSC_VER) <nl> +#define X264_API_IMPORTS 1 <nl> +#endif <nl> + <nl>  #include <x264.h> <nl>  #include <float.h> <nl>  #include <math.h>
@@ -2760,8 +2760,8 @@ void avcodec_string(char *buf, int buf_size, AVCodecContext *enc, int encode) <nl>   <nl>              if (enc->sample_aspect_ratio.num) { <nl>                  av_reduce(&display_aspect_ratio.num, &display_aspect_ratio.den, <nl> -                          enc->width * enc->sample_aspect_ratio.num, <nl> -                          enc->height * enc->sample_aspect_ratio.den, <nl> +                          enc->width * (int64_t)enc->sample_aspect_ratio.num, <nl> +                          enc->height * (int64_t)enc->sample_aspect_ratio.den, <nl>                            1024 * 1024); <nl>                  snprintf(buf + strlen(buf), buf_size - strlen(buf), <nl>                           " [SAR %d:%d DAR %d:%d]",
@@ -1704,7 +1704,7 @@ int ff_h264_frame_start(H264Context *h) <nl>   <nl>      if ((ret = alloc_picture(h, pic)) < 0) <nl>          return ret; <nl> -    if(!h->sync) <nl> +    if(!h->sync && !h->avctx->hwaccel) <nl>          avpriv_color_frame(&pic->f, c); <nl>   <nl>      h->cur_pic_ptr = pic;
@@ -590,7 +590,7 @@ static int smka_decode_frame(AVCodecContext *avctx, void *data, int *data_size, <nl>      } <nl>      stereo = get_bits1(&gb); <nl>      bits = get_bits1(&gb); <nl> -    if ((unp_size << !bits) > *data_size) { <nl> +    if (unp_size & 0xC0000000 || (unp_size << !bits) > *data_size) { <nl>          av_log(avctx, AV_LOG_ERROR, "Frame is too large to fit in buffer\n"); <nl>          return -1; <nl>      }
@@ -348,7 +348,7 @@ static av_cold int init(AVFilterContext *ctx) <nl>  { <nl>      ExtractPlanesContext *s = ctx->priv; <nl>      int planes = (s->requested_planes & 0xf) | (s->requested_planes >> 4); <nl> -    int i; <nl> +    int i, ret; <nl>   <nl>      for (i = 0; i < 4; i++) { <nl>          char *name; <nl> @@ -365,7 +365,10 @@ static av_cold int init(AVFilterContext *ctx) <nl>          pad.type = AVMEDIA_TYPE_VIDEO; <nl>          pad.config_props = config_output; <nl>   <nl> -        ff_insert_outpad(ctx, ctx->nb_outputs, &pad); <nl> +        if ((ret = ff_insert_outpad(ctx, ctx->nb_outputs, &pad)) < 0) { <nl> +            av_freep(&pad.name); <nl> +            return ret; <nl> +        } <nl>      } <nl>   <nl>      return 0;
@@ -64,9 +64,9 @@ static void ict_int(void *_src0, void *_src1, void *_src2, int csize) <nl>      int i; <nl>   <nl>      for (i = 0; i < csize; i++) { <nl> -        i0 = *src0 + *src2 + (((26345 * *src2) + (1 << 15)) >> 16); <nl> +        i0 = *src0 + *src2 + ((int)((26345U * *src2) + (1 << 15)) >> 16); <nl>          i1 = *src0 - ((int)(((unsigned)i_ict_params[1] * *src1) + (1 << 15)) >> 16) <nl> -                   - (((i_ict_params[2] * *src2) + (1 << 15)) >> 16); <nl> +                   - ((int)(((unsigned)i_ict_params[2] * *src2) + (1 << 15)) >> 16); <nl>          i2 = *src0 + (2 * *src1) + ((int)((-14942U * *src1) + (1 << 15)) >> 16); <nl>          *src0++ = i0; <nl>          *src1++ = i1;
@@ -149,7 +149,7 @@ static void RENAME(decode_rgb_frame)(FFV1Context *s, uint8_t *src[3], int w, int <nl>              } <nl>   <nl>              if (lbd) <nl> -                *((uint32_t*)(src[0] + x*4 + stride[0]*y)) = b + (g<<8) + (r<<16) + (a<<24); <nl> +                *((uint32_t*)(src[0] + x*4 + stride[0]*y)) = b + ((unsigned)g<<8) + ((unsigned)r<<16) + ((unsigned)a<<24); <nl>              else if (sizeof(TYPE) == 4) { <nl>                  *((uint16_t*)(src[0] + x*2 + stride[0]*y)) = g; <nl>                  *((uint16_t*)(src[1] + x*2 + stride[1]*y)) = b;
@@ -116,8 +116,7 @@ static int codec_reinit(AVCodecContext *avctx, int width, int height, int qualit <nl>              return 0; <nl>          avctx->width = c->width = width; <nl>          avctx->height = c->height = height; <nl> -        c->decomp_size = c->height * c->width * 3 / 2; <nl> -        c->decomp_buf = av_realloc(c->decomp_buf, c->decomp_size + AV_LZO_OUTPUT_PADDING); <nl> +        av_fast_malloc(&c->decomp_buf, &c->decomp_size, c->height * c->width * 3 / 2); <nl>          if (!c->decomp_buf) { <nl>              av_log(avctx, AV_LOG_ERROR, "Can't allocate decompression buffer.\n"); <nl>              return 0;
@@ -284,6 +284,8 @@ static int read_header(AVFormatContext *s1, AVFormatParameters *ap) <nl>          s->split_planes = str && !av_strcasecmp(str + 1, "y"); <nl>          st->codec->codec_type = AVMEDIA_TYPE_VIDEO; <nl>          st->codec->codec_id = av_str2id(img_tags, s->path); <nl> +        if (st->codec->codec_id = CODEC_ID_LJPEG) <nl> +            st->codec->codec_id = CODEC_ID_MJPEG; <nl>      } <nl>      if(st->codec->codec_type == AVMEDIA_TYPE_VIDEO && pix_fmt != PIX_FMT_NONE) <nl>          st->codec->pix_fmt = pix_fmt;
@@ -452,6 +452,11 @@ av_cold int ff_MPV_encode_init(AVCodecContext *avctx) <nl>          av_log(avctx, AV_LOG_ERROR, "b frames not supported by codec\n"); <nl>          return -1; <nl>      } <nl> +    if (s->max_b_frames < 0) { <nl> +        av_log(avctx, AV_LOG_ERROR, <nl> +               "max b frames must be 0 or postive for mpegvideo based encoders\n"); <nl> +        return -1; <nl> +    } <nl>   <nl>      if ((s->codec_id == AV_CODEC_ID_MPEG4 || <nl>           s->codec_id == AV_CODEC_ID_H263  ||
@@ -1771,9 +1771,9 @@ static int mov_write_trak_tag(AVIOContext *pb, MOVMuxContext *mov, <nl>      avio_wb32(pb, 0); /* size */ <nl>      ffio_wfourcc(pb, "trak"); <nl>      mov_write_tkhd_tag(pb, mov, track, st); <nl> -    if (track->mode == MODE_PSP || track->flags & MOV_TRACK_CTTS || <nl> -        (track->entry && track->cluster[0].dts) || <nl> -        is_clcp_track(track)) { <nl> +    if (track->entry && <nl> +        (track->mode == MODE_PSP || track->flags & MOV_TRACK_CTTS || <nl> +        track->cluster[0].dts || is_clcp_track(track))) { <nl>          if (mov->use_editlist) <nl>              mov_write_edts_tag(pb, mov, track);  // PSP Movies require edts box <nl>          else if ((track->entry && track->cluster[0].dts) || track->mode == MODE_PSP || is_clcp_track(track))
@@ -322,9 +322,6 @@ static int cinepak_decode (CinepakContext *s) <nl>      int           y0 = 0; <nl>      int           encoded_buf_size; <nl>   <nl> -    if (s->size < 10) <nl> -        return AVERROR_INVALIDDATA; <nl> - <nl>      frame_flags = s->data[0]; <nl>      num_strips  = AV_RB16 (&s->data[8]); <nl>      encoded_buf_size = AV_RB24(&s->data[1]); <nl> @@ -439,6 +436,9 @@ static int cinepak_decode_frame(AVCodecContext *avctx, <nl>      s->data = buf; <nl>      s->size = buf_size; <nl>   <nl> +    if (s->size < 10) <nl> +        return AVERROR_INVALIDDATA; <nl> + <nl>      if ((ret = ff_reget_buffer(avctx, s->frame)) < 0) <nl>          return ret; <nl>  
@@ -412,6 +412,10 @@ static av_cold int decode_init(AVCodecContext *avctx) <nl>          } <nl>          s->sfb_offsets[i][band - 1] = subframe_len; <nl>          s->num_sfb[i]               = band - 1; <nl> +        if (s->num_sfb[i] <= 0) { <nl> +            av_log(avctx, AV_LOG_ERROR, "num_sfb invalid\n"); <nl> +            return AVERROR_INVALIDDATA; <nl> +        } <nl>      } <nl>   <nl>  
@@ -943,6 +943,10 @@ static int mxf_read_close(AVFormatContext *s) <nl>      int i; <nl>   <nl>      av_freep(&mxf->packages_refs); <nl> + <nl> +    for (i = 0; i < s->nb_streams; i++) <nl> +        s->streams[i]->priv_data = NULL; <nl> + <nl>      for (i = 0; i < mxf->metadata_sets_count; i++) { <nl>          switch (mxf->metadata_sets[i]->type) { <nl>          case MultipleDescriptor: <nl> @@ -955,9 +959,6 @@ static int mxf_read_close(AVFormatContext *s) <nl>          case MaterialPackage: <nl>              av_freep(&((MXFPackage *)mxf->metadata_sets[i])->tracks_refs); <nl>              break; <nl> -        case Track: <nl> -            mxf->metadata_sets[i] = NULL; /* will be freed later */ <nl> -            break; <nl>          default: <nl>              break; <nl>          }
@@ -613,7 +613,9 @@ int MPV_common_init(MpegEncContext *s) <nl>  { <nl>      int y_size, c_size, yc_size, i, mb_array_size, mv_table_size, x, y; <nl>   <nl> -    if(s->avctx->thread_count > MAX_THREADS || (16*s->avctx->thread_count > s->height && s->height)){ <nl> +    s->mb_height = (s->height + 15) / 16; <nl> + <nl> +    if(s->avctx->thread_count > MAX_THREADS || (s->avctx->thread_count > s->mb_height && s->mb_height)){ <nl>          av_log(s->avctx, AV_LOG_ERROR, "too many threads\n"); <nl>          return -1; <nl>      } <nl> @@ -628,7 +630,6 @@ int MPV_common_init(MpegEncContext *s) <nl>      s->flags2= s->avctx->flags2; <nl>   <nl>      s->mb_width  = (s->width  + 15) / 16; <nl> -    s->mb_height = (s->height + 15) / 16; <nl>      s->mb_stride = s->mb_width + 1; <nl>      s->b8_stride = s->mb_width*2 + 1; <nl>      s->b4_stride = s->mb_width*4 + 1;
@@ -321,6 +321,7 @@ static int subtitle_disable; <nl>  static const char* wanted_stream_spec[AVMEDIA_TYPE_NB] = {0}; <nl>  static int seek_by_bytes = -1; <nl>  static int display_disable; <nl> +static int borderless; <nl>  static int startup_volume = 100; <nl>  static int show_status = 1; <nl>  static int av_sync_type = AV_SYNC_AUDIO_MASTER; <nl> @@ -1265,6 +1266,8 @@ static int video_open(VideoState *is) <nl>              window_title = input_filename; <nl>          if (is_full_screen) <nl>              flags |= SDL_WINDOW_FULLSCREEN_DESKTOP; <nl> +        if (borderless) <nl> +            flags |= SDL_WINDOW_BORDERLESS; <nl>          window = SDL_CreateWindow(window_title, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, w, h, flags); <nl>          SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "linear"); <nl>          if (window) { <nl> @@ -3513,6 +3516,7 @@ static const OptionDef options[] = { <nl>      { "t", HAS_ARG, { .func_arg = opt_duration }, "play  \"duration\" seconds of audio/video", "duration" }, <nl>      { "bytes", OPT_INT | HAS_ARG, { &seek_by_bytes }, "seek by bytes 0=off 1=on -1=auto", "val" }, <nl>      { "nodisp", OPT_BOOL, { &display_disable }, "disable graphical display" }, <nl> +    { "noborder", OPT_BOOL, { &borderless }, "borderless window" }, <nl>      { "volume", OPT_INT | HAS_ARG, { &startup_volume}, "set startup volume 0=min 100=max", "volume" }, <nl>      { "f", HAS_ARG, { .func_arg = opt_format }, "force format", "fmt" }, <nl>      { "pix_fmt", HAS_ARG | OPT_EXPERT | OPT_VIDEO, { .func_arg = opt_frame_pix_fmt }, "set pixel format", "format" },
@@ -1783,7 +1783,7 @@ static int matroska_parse_block(MatroskaDemuxContext *matroska, uint8_t *data, <nl>                          lace_size[n] = lace_size[n - 1] + snum; <nl>                          total += lace_size[n]; <nl>                      } <nl> -                    lace_size[n] = size - total; <nl> +                    lace_size[laces - 1] = size - total; <nl>                      break; <nl>                  } <nl>              }
@@ -827,7 +827,8 @@ int ff_rtsp_open_transport_ctx(AVFormatContext *s, RTSPStream *rtsp_st) <nl>   <nl>      if (!rtsp_st->transport_priv) { <nl>           return AVERROR(ENOMEM); <nl> -    } else if (CONFIG_RTPDEC && rt->transport == RTSP_TRANSPORT_RTP) { <nl> +    } else if (CONFIG_RTPDEC && rt->transport == RTSP_TRANSPORT_RTP && <nl> +               s->iformat) { <nl>          RTPDemuxContext *rtpctx = rtsp_st->transport_priv; <nl>          rtpctx->ssrc = rtsp_st->ssrc; <nl>          if (rtsp_st->dynamic_handler) {
@@ -3167,7 +3167,7 @@ static void compute_chapters_end(AVFormatContext *s) <nl>                  if (j != i && next_start > ch->start && next_start < end) <nl>                      end = next_start; <nl>              } <nl> -            ch->end = (end == INT64_MAX) ? ch->start : end; <nl> +            ch->end = (end == INT64_MAX || end < ch->start) ? ch->start : end; <nl>          } <nl>  } <nl>  
@@ -1898,7 +1898,7 @@ static void update_stream_timings(AVFormatContext *ic) <nl>          st = ic->streams[i]; <nl>          if (st->start_time != AV_NOPTS_VALUE && st->time_base.den) { <nl>              start_time1= av_rescale_q(st->start_time, st->time_base, AV_TIME_BASE_Q); <nl> -            if (st->codec->codec_id == CODEC_ID_DVB_TELETEXT) { <nl> +            if (st->codec->codec_id == CODEC_ID_DVB_TELETEXT || st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) { <nl>                  if (start_time1 < start_time_text) <nl>                      start_time_text = start_time1; <nl>              } else
@@ -224,6 +224,8 @@ static inline void xan_wc3_copy_pixel_run(XanContext *s, <nl>   <nl>      palette_plane = s->current_frame.data[0]; <nl>      prev_palette_plane = s->last_frame.data[0]; <nl> +    if (!prev_palette_plane) <nl> +        prev_palette_plane = palette_plane; <nl>      stride = s->current_frame.linesize[0]; <nl>      line_inc = stride - width; <nl>      curframe_index = y * stride + x;
@@ -484,7 +484,8 @@ ogg_get_length (AVFormatContext * s) <nl>      url_fseek (&s->pb, end, SEEK_SET); <nl>   <nl>      while (!ogg_read_page (s, &i)){ <nl> -        if (ogg->streams[i].granule != -1 && ogg->streams[i].granule != 0) <nl> +        if (ogg->streams[i].granule != -1 && ogg->streams[i].granule != 0 && <nl> +            ogg->streams[i].codec) <nl>              idx = i; <nl>      } <nl>  
@@ -661,7 +661,7 @@ int ff_get_wav_header(AVIOContext *pb, AVCodecContext *codec, int size) <nl>          codec->sample_rate = 0; <nl>      } <nl>      /* override bits_per_coded_sample for G.726 */ <nl> -    if (codec->codec_id == AV_CODEC_ID_ADPCM_G726) <nl> +    if (codec->codec_id == AV_CODEC_ID_ADPCM_G726 && codec->sample_rate) <nl>          codec->bits_per_coded_sample = codec->bit_rate / codec->sample_rate; <nl>   <nl>      return 0;
@@ -495,7 +495,8 @@ static int rm_assemble_video_frame(AVFormatContext *s, RMContext *rm, AVPacket * <nl>      if((seq & 0x7F) == 1 || rm->curpic_num != pic_num){ <nl>          rm->slices = ((hdr & 0x3F) << 1) + 1; <nl>          ssize = len2 + 8*rm->slices + 1; <nl> -        rm->videobuf = av_realloc(rm->videobuf, ssize); <nl> +        if(!(rm->videobuf = av_realloc(rm->videobuf, ssize))) <nl> +            return AVERROR(ENOMEM); <nl>          rm->videobufsize = ssize; <nl>          rm->videobufpos = 8*rm->slices + 1; <nl>          rm->cur_slice = 0;
@@ -96,11 +96,11 @@ static int gif_read_image(GifState *s) <nl>      n = (1 << bits_per_pixel); <nl>      spal = palette; <nl>      for(i = 0; i < n; i++) { <nl> -        s->image_palette[i] = (0xff << 24) | AV_RB24(spal); <nl> +        s->image_palette[i] = (0xffu << 24) | AV_RB24(spal); <nl>          spal += 3; <nl>      } <nl>      for(; i < 256; i++) <nl> -        s->image_palette[i] = (0xff << 24); <nl> +        s->image_palette[i] = (0xffu << 24); <nl>      /* handle transparency */ <nl>      if (s->transparent_color_index >= 0) <nl>          s->image_palette[s->transparent_color_index] = 0;
@@ -381,11 +381,10 @@ static inline void doHorizLowPass_C(uint8_t dst[], int stride, const PPContext * <nl>  static inline void horizX1Filter(uint8_t *src, int stride, int QP) <nl>  { <nl>      int y; <nl> -    static uint64_t *lut= NULL; <nl> -    if(lut==NULL) <nl> +    static uint64_t lut[256]; <nl> +    if(!lut[255]) <nl>      { <nl>          int i; <nl> -        lut = av_malloc(256*8); <nl>          for(i=0; i<256; i++) <nl>          { <nl>              int v= i < 128 ? 2*i : 2*(i-256);
@@ -4889,8 +4889,8 @@ static int decode_residual(H264Context *h, GetBitContext *gb, DCTELEM *block, in <nl>   <nl>      if(total_coeff==0) <nl>          return 0; <nl> -    if(total_coeff<0) { <nl> -        av_log(h->s.avctx, AV_LOG_ERROR, "corrupted macroblock %d %d (total_coeff<0)\n", s->mb_x, s->mb_y); <nl> +    if(total_coeff > (unsigned)max_coeff) { <nl> +        av_log(h->s.avctx, AV_LOG_ERROR, "corrupted macroblock %d %d (total_coeff=%d)\n", s->mb_x, s->mb_y, total_coeff); <nl>          return -1; <nl>      } <nl>  
@@ -40,10 +40,10 @@ void FUNCC(ff_h264_idct_add)(uint8_t *_dst, int16_t *_block, int stride) <nl>      block[0] += 1 << 5; <nl>   <nl>      for(i=0; i<4; i++){ <nl> -        const SUINT z0=  block[i + 4*0]     +  block[i + 4*2]; <nl> -        const SUINT z1=  block[i + 4*0]     -  block[i + 4*2]; <nl> -        const SUINT z2= (block[i + 4*1]>>1) -  block[i + 4*3]; <nl> -        const SUINT z3=  block[i + 4*1]     + (block[i + 4*3]>>1); <nl> +        const SUINT z0=  block[i + 4*0]     +  (unsigned)block[i + 4*2]; <nl> +        const SUINT z1=  block[i + 4*0]     -  (unsigned)block[i + 4*2]; <nl> +        const SUINT z2= (block[i + 4*1]>>1) -  (unsigned)block[i + 4*3]; <nl> +        const SUINT z3=  block[i + 4*1]     + (unsigned)(block[i + 4*3]>>1); <nl>   <nl>          block[i + 4*0]= z0 + z3; <nl>          block[i + 4*1]= z1 + z2;
@@ -103,7 +103,7 @@ static int rv30_decode_mb_info(RV34DecContext *r) <nl>      GetBitContext *gb = &s->gb; <nl>      int code = svq3_get_ue_golomb(gb); <nl>   <nl> -    if(code > 11){ <nl> +    if (code < 0 || code > 11) { <nl>          av_log(s->avctx, AV_LOG_ERROR, "Incorrect MB type code\n"); <nl>          return -1; <nl>      }
@@ -233,5 +233,5 @@ int main(int argc, char **argv){ <nl>   <nl>      selfTest(src, stride, W, H); <nl>   <nl> -    return 123; <nl> +    return 0; <nl>  }
@@ -684,7 +684,7 @@ static void fill_coding_method_array (sb_int8_array tone_level_idx, sb_int8_arra <nl>          SAMPLES_NEEDED <nl>          for (ch = 0; ch < nb_channels; ch++) <nl>              for (sb = 0; sb < 30; sb++) { <nl> -                for (j = 1; j < 64; j++) { <nl> +                for (j = 1; j < 63; j++) {  // The loop only iterates to 63 so the code doesn't overflow the buffer <nl>                      add1 = tone_level_idx[ch][sb][j] - 10; <nl>                      if (add1 < 0) <nl>                          add1 = 0;
@@ -720,6 +720,7 @@ static int read_channel_params(MLPDecodeContext *m, unsigned int substr, <nl>   <nl>      if (cp->huff_lsbs > 24) { <nl>          av_log(m->avctx, AV_LOG_ERROR, "Invalid huff_lsbs.\n"); <nl> +        cp->huff_lsbs = 0; <nl>          return AVERROR_INVALIDDATA; <nl>      } <nl>  
@@ -631,6 +631,8 @@ static int epic_decode_run_length(ePICContext *dc, int x, int y, int tile_width, <nl>                (NN  != N)  << 1 | <nl>                (NNW != NW); <nl>          WWneW = ff_els_decode_bit(&dc->els_ctx, &dc->W_ctx_rung[idx]); <nl> +        if (WWneW < 0) <nl> +            return WWneW; <nl>      } <nl>   <nl>      if (WWneW) <nl> @@ -837,10 +839,13 @@ static int epic_decode_tile(ePICContext *dc, uint8_t *out, int tile_height, <nl>                  if (y < 2 || x < 2 || x == tile_width - 1) { <nl>                      run       = 1; <nl>                      got_pixel = epic_handle_edges(dc, x, y, curr_row, above_row, &pix); <nl> -                } else <nl> +                } else { <nl>                      got_pixel = epic_decode_run_length(dc, x, y, tile_width, <nl>                                                         curr_row, above_row, <nl>                                                         above2_row, &pix, &run); <nl> +                    if (got_pixel < 0) <nl> +                        return got_pixel; <nl> +                } <nl>   <nl>                  if (!got_pixel && !epic_predict_from_NW_NE(dc, x, y, run, <nl>                                                             tile_width, curr_row,
@@ -480,7 +480,6 @@ AVCodec ff_wmv2_decoder = { <nl>      wmv2_decode_end, <nl>      ff_h263_decode_frame, <nl>      CODEC_CAP_DRAW_HORIZ_BAND | CODEC_CAP_DR1, <nl> -    .max_lowres = 3, <nl>      .long_name = NULL_IF_CONFIG_SMALL("Windows Media Video 8"), <nl>      .pix_fmts= ff_pixfmt_list_420, <nl>  };
@@ -1278,12 +1278,12 @@ static int jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile, <nl>   <nl>   <nl>              y    = tile->comp[compno].coord[1][0] - s->image_offset_y; <nl> -            line = picture->data[plane] + y * picture->linesize[plane]; <nl> +            line = picture->data[plane] + y / s->cdy[compno] * picture->linesize[plane]; <nl>              for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) { <nl>                  uint8_t *dst; <nl>   <nl>                  x   = tile->comp[compno].coord[0][0] - s->image_offset_x; <nl> -                dst = line + x * pixelsize + compno*!planar; <nl> +                dst = line + x / s->cdx[compno] * pixelsize + compno*!planar; <nl>   <nl>                  if (codsty->transform == FF_DWT97) { <nl>                      for (; x < w; x += s->cdx[compno]) { <nl> @@ -1324,12 +1324,12 @@ static int jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile, <nl>                  plane = s->cdef[compno] ? s->cdef[compno]-1 : (s->ncomponents-1); <nl>   <nl>              y     = tile->comp[compno].coord[1][0] - s->image_offset_y; <nl> -            linel = (uint16_t *)picture->data[plane] + y * (picture->linesize[plane] >> 1); <nl> +            linel = (uint16_t *)picture->data[plane] + y / s->cdy[compno] * (picture->linesize[plane] >> 1); <nl>              for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) { <nl>                  uint16_t *dst; <nl>   <nl>                  x   = tile->comp[compno].coord[0][0] - s->image_offset_x; <nl> -                dst = linel + (x * pixelsize + compno*!planar); <nl> +                dst = linel + (x / s->cdx[compno] * pixelsize + compno*!planar); <nl>                  if (codsty->transform == FF_DWT97) { <nl>                      for (; x < w; x += s-> cdx[compno]) { <nl>                          int  val = lrintf(*datap) + (1 << (cbps - 1));
@@ -1483,6 +1483,7 @@ int ff_rv34_decode_frame(AVCodecContext *avctx, <nl>          slice_count = (*buf++) + 1; <nl>          slices_hdr = buf + 4; <nl>          buf += 8 * slice_count; <nl> +        buf_size -= 1 + 8 * slice_count; <nl>      }else <nl>          slice_count = avctx->slice_count; <nl>   <nl> @@ -1501,7 +1502,7 @@ int ff_rv34_decode_frame(AVCodecContext *avctx, <nl>      if(   (avctx->skip_frame >= AVDISCARD_NONREF && si.type==AV_PICTURE_TYPE_B) <nl>         || (avctx->skip_frame >= AVDISCARD_NONKEY && si.type!=AV_PICTURE_TYPE_I) <nl>         ||  avctx->skip_frame >= AVDISCARD_ALL) <nl> -        return buf_size; <nl> +        return avpkt->size; <nl>   <nl>      for(i = 0; i < slice_count; i++){ <nl>          int offset = get_slice_offset(avctx, slices_hdr, i); <nl> @@ -1550,7 +1551,7 @@ int ff_rv34_decode_frame(AVCodecContext *avctx, <nl>          } <nl>          s->current_picture_ptr = NULL; //so we can detect if frame_end wasnt called (find some nicer solution...) <nl>      } <nl> -    return buf_size; <nl> +    return avpkt->size; <nl>  } <nl>   <nl>  av_cold int ff_rv34_decode_end(AVCodecContext *avctx)
@@ -622,9 +622,6 @@ static int tiff_decode_tag(TiffContext *s, AVFrame *frame) <nl>          else { <nl>              switch (type) { <nl>              case TIFF_BYTE: <nl> -                s->bpp = (off & 0xFF) + ((off >> 8) & 0xFF) + <nl> -                         ((off >> 16) & 0xFF) + ((off >> 24) & 0xFF); <nl> -                break; <nl>              case TIFF_SHORT: <nl>              case TIFF_LONG: <nl>                  s->bpp = 0;
@@ -85,8 +85,7 @@ int ff_load_image(uint8_t *data[4], int linesize[4], <nl>      av_image_copy(data, linesize, (const uint8_t **)frame->data, frame->linesize, *pix_fmt, *w, *h); <nl>   <nl>  end: <nl> -    if (codec_ctx) <nl> -        avcodec_close(codec_ctx); <nl> +    avcodec_close(codec_ctx); <nl>      if (format_ctx) <nl>          avformat_close_input(&format_ctx); <nl>      av_freep(&frame);
@@ -926,7 +926,7 @@ int av_write_trailer(AVFormatContext *s) <nl>      for (;; ) { <nl>          AVPacket pkt; <nl>          ret = interleave_packet(s, &pkt, NULL, 1); <nl> -        if (ret < 0) //FIXME cleanup needed for ret<0 ? <nl> +        if (ret < 0) <nl>              goto fail; <nl>          if (!ret) <nl>              break; <nl> @@ -943,10 +943,14 @@ int av_write_trailer(AVFormatContext *s) <nl>              goto fail; <nl>      } <nl>   <nl> +fail: <nl>      if (s->oformat->write_trailer) <nl> +        if (ret >= 0) { <nl>          ret = s->oformat->write_trailer(s); <nl> +        } else { <nl> +            s->oformat->write_trailer(s); <nl> +        } <nl>   <nl> -fail: <nl>      if (s->pb) <nl>         avio_flush(s->pb); <nl>      if (ret == 0)
@@ -509,7 +509,7 @@ static int hds_write_packet(AVFormatContext *s, AVPacket *pkt) <nl>      HDSContext *c = s->priv_data; <nl>      AVStream *st = s->streams[pkt->stream_index]; <nl>      OutputStream *os = &c->streams[s->streams[pkt->stream_index]->id]; <nl> -    int64_t end_dts = (os->fragment_index) * c->min_frag_duration; <nl> +    int64_t end_dts = os->fragment_index * (int64_t) c->min_frag_duration; <nl>      int ret; <nl>   <nl>      if (st->first_dts == AV_NOPTS_VALUE)
@@ -192,6 +192,9 @@ int ff_lpc_calc_coefs(LPCContext *s, <nl>          LLSModel m[2]; <nl>          double var[MAX_LPC_ORDER+1], av_uninit(weight); <nl>   <nl> +        if(lpc_passes <= 0) <nl> +            lpc_passes = 2; <nl> + <nl>          for(pass=0; pass<lpc_passes; pass++){ <nl>              av_init_lls(&m[pass&1], max_order); <nl>  
@@ -2080,7 +2080,8 @@ static int matroska_parse_block(MatroskaDemuxContext *matroska, uint8_t *data, <nl>               st->codec->codec_id == AV_CODEC_ID_ATRAC3) && <nl>               st->codec->block_align && track->audio.sub_packet_size) { <nl>   <nl> -            res = matroska_parse_rm_audio(matroska, track, st, data, size, <nl> +            res = matroska_parse_rm_audio(matroska, track, st, data, <nl> +                                          lace_size[n], <nl>                                            timecode, duration, pos); <nl>              if (res) <nl>                  goto end; <nl> @@ -2096,7 +2097,6 @@ static int matroska_parse_block(MatroskaDemuxContext *matroska, uint8_t *data, <nl>          if (timecode != AV_NOPTS_VALUE) <nl>              timecode = duration ? timecode + duration : AV_NOPTS_VALUE; <nl>          data += lace_size[n]; <nl> -        size -= lace_size[n]; <nl>      } <nl>   <nl>  end:
@@ -50,6 +50,9 @@ int av_image_get_linesize(enum PixelFormat pix_fmt, int width, int plane) <nl>      int max_step_comp[4];       /* the component for each plane which has the max pixel step */ <nl>      int s, linesize; <nl>   <nl> +    if ((unsigned)pix_fmt >= PIX_FMT_NB || desc->flags & PIX_FMT_HWACCEL) <nl> +        return AVERROR(EINVAL); <nl> + <nl>      av_image_fill_max_pixsteps(max_step, max_step_comp, desc); <nl>      s = (max_step_comp[plane] == 1 || max_step_comp[plane] == 2) ? desc->log2_chroma_w : 0; <nl>      linesize = max_step[plane] * (((width + (1 << s) - 1)) >> s);
@@ -136,6 +136,11 @@ static int decode_rle(AVCodecContext *avctx, AVSubtitle *sub, <nl>          } <nl>      } <nl>   <nl> +    if (pixel_count < sub->rects[0]->w * sub->rects[0]->h) { <nl> +        av_log(avctx, AV_LOG_ERROR, "Insufficient RLE data for subtitle\n"); <nl> +        return -1; <nl> +    } <nl> + <nl>      dprintf(avctx, "Pixel Count = %d, Area = %d\n", pixel_count, sub->rects[0]->w * sub->rects[0]->h); <nl>   <nl>      return 0;
@@ -96,6 +96,10 @@ static int read_header(AVFormatContext *s) <nl>      mvi->get_int = (vst->codec->width * vst->codec->height < (1 << 16)) ? avio_rl16 : avio_rl24; <nl>   <nl>      mvi->audio_frame_size   = ((uint64_t)mvi->audio_data_size << MVI_FRAC_BITS) / frames_count; <nl> +    if (!mvi->audio_frame_size) { <nl> +        av_log(s, AV_LOG_ERROR, "audio_frame_size is 0\n"); <nl> +        return AVERROR_INVALIDDATA; <nl> +    } <nl>      mvi->audio_size_counter = (ast->codec->sample_rate * 830 / mvi->audio_frame_size - 1) * mvi->audio_frame_size; <nl>      mvi->audio_size_left    = mvi->audio_data_size; <nl>  
@@ -2858,7 +2858,7 @@ static int mov_read_default(MOVContext *c, AVIOContext *pb, MOVAtom atom) <nl>   <nl>  static int mov_probe(AVProbeData *p) <nl>  { <nl> -    unsigned int offset; <nl> +    int64_t offset; <nl>      uint32_t tag; <nl>      int score = 0; <nl>  
@@ -1410,13 +1410,15 @@ int ff_h264_decode_slice_header(H264Context *h, H264Context *h0) <nl>                       || 16*h->sps.mb_height * (2 - h->sps.frame_mbs_only_flag) != h->avctx->coded_height <nl>                       || h->avctx->bits_per_raw_sample != h->sps.bit_depth_luma <nl>                       || h->cur_chroma_format_idc != h->sps.chroma_format_idc <nl> -                     || av_cmp_q(h->sps.sar, h->avctx->sample_aspect_ratio) <nl>                       || h->mb_width  != h->sps.mb_width <nl>                       || h->mb_height != h->sps.mb_height * (2 - h->sps.frame_mbs_only_flag) <nl>                      )); <nl>      if (non_j_pixfmt(h0->avctx->pix_fmt) != non_j_pixfmt(get_pixel_format(h0, 0))) <nl>          must_reinit = 1; <nl>   <nl> +    if (first_slice && av_cmp_q(h->sps.sar, h->avctx->sample_aspect_ratio)) <nl> +        must_reinit = 1; <nl> + <nl>      h->mb_width  = h->sps.mb_width; <nl>      h->mb_height = h->sps.mb_height * (2 - h->sps.frame_mbs_only_flag); <nl>      h->mb_num    = h->mb_width * h->mb_height;
@@ -2067,7 +2067,8 @@ static int decode_chunks(AVCodecContext *avctx, <nl>          buf_ptr = avpriv_find_start_code(buf_ptr, buf_end, &start_code); <nl>          if (start_code > 0x1ff) { <nl>              if (!skip_frame) { <nl> -                if (HAVE_THREADS && (avctx->active_thread_type & FF_THREAD_SLICE)) { <nl> +                if (HAVE_THREADS && (avctx->active_thread_type & FF_THREAD_SLICE) && <nl> +                    !avctx->hwaccel) { <nl>                      int i; <nl>   <nl>                      avctx->execute(avctx, slice_decode_thread,  &s2->thread_context[0], NULL, s->slice_count, sizeof(void*)); <nl> @@ -2117,7 +2118,8 @@ static int decode_chunks(AVCodecContext *avctx, <nl>                  return AVERROR_INVALIDDATA; <nl>              } <nl>   <nl> -            if (HAVE_THREADS && (avctx->active_thread_type & FF_THREAD_SLICE) && s->slice_count) { <nl> +            if (HAVE_THREADS && (avctx->active_thread_type & FF_THREAD_SLICE) && <nl> +                !avctx->hwaccel && s->slice_count) { <nl>                  int i; <nl>   <nl>                  avctx->execute(avctx, slice_decode_thread, <nl> @@ -2263,7 +2265,8 @@ static int decode_chunks(AVCodecContext *avctx, <nl>                      break; <nl>                  } <nl>   <nl> -                if (HAVE_THREADS && (avctx->active_thread_type & FF_THREAD_SLICE)) { <nl> +                if (HAVE_THREADS && (avctx->active_thread_type & FF_THREAD_SLICE) && <nl> +                    !avctx->hwaccel) { <nl>                      int threshold = (s2->mb_height * s->slice_count + <nl>                                       s2->slice_context_count / 2) / <nl>                                      s2->slice_context_count;
@@ -219,6 +219,8 @@ static int cinvideo_decode_frame(AVCodecContext *avctx, <nl>      if (bitmap_frame_size < palette_colors_count * (3 + (palette_type != 0))) <nl>          return AVERROR_INVALIDDATA; <nl>      if (palette_type == 0) { <nl> +        if (palette_colors_count > 256) <nl> +            return AVERROR_INVALIDDATA; <nl>          for (i = 0; i < palette_colors_count; ++i) { <nl>              cin->palette[i] = bytestream_get_le24(&buf); <nl>              bitmap_frame_size -= 3;
@@ -1369,6 +1369,7 @@ static int video_thread(void *arg) <nl>              is->last_pts_for_fault_detection= INT64_MIN; <nl>              is->frame_last_pts= AV_NOPTS_VALUE; <nl>              is->frame_last_delay = 0; <nl> +            is->frame_timer = (double)av_gettime() / 1000000.0; <nl>   <nl>              continue; <nl>          } <nl> @@ -1820,7 +1821,6 @@ static int stream_component_open(VideoState *is, int stream_index) <nl>          is->video_stream = stream_index; <nl>          is->video_st = ic->streams[stream_index]; <nl>   <nl> -        is->frame_timer = (double)av_gettime() / 1000000.0; <nl>  //        is->video_current_pts_time = av_gettime(); <nl>   <nl>          packet_queue_init(&is->videoq);
@@ -183,6 +183,8 @@ static void rpza_decode_stream(RpzaContext *s) <nl>              color4[1] |= ((11 * ta + 21 * tb) >> 5); <nl>              color4[2] |= ((21 * ta + 11 * tb) >> 5); <nl>   <nl> +            if (s->size - stream_ptr < n_blocks * 4) <nl> +                return; <nl>              while (n_blocks--) { <nl>                  block_ptr = row_ptr + pixel_ptr; <nl>                  for (pixel_y = 0; pixel_y < 4; pixel_y++) { <nl> @@ -200,6 +202,8 @@ static void rpza_decode_stream(RpzaContext *s) <nl>   <nl>          /* Fill block with 16 colors */ <nl>          case 0x00: <nl> +            if (s->size - stream_ptr < 16) <nl> +                return; <nl>              block_ptr = row_ptr + pixel_ptr; <nl>              for (pixel_y = 0; pixel_y < 4; pixel_y++) { <nl>                  for (pixel_x = 0; pixel_x < 4; pixel_x++){
@@ -187,7 +187,7 @@ static int filter_frame(AVFilterLink *inlink, AVFilterBufferRef *in) <nl>      GradFunContext *gf = inlink->dst->priv; <nl>      AVFilterLink *outlink = inlink->dst->outputs[0]; <nl>      AVFilterBufferRef *out; <nl> -    int p, direct; <nl> +    int p, direct = 0; <nl>   <nl>      if ((in->perms & AV_PERM_WRITE) && !(in->perms & AV_PERM_PRESERVE)) { <nl>          direct = 1;
@@ -177,12 +177,12 @@ int main(int argc, char **argv) <nl>              st->stream->codec->pix_fmt             = st->link->format; <nl>              break; <nl>          case AVMEDIA_TYPE_AUDIO: <nl> -            st->stream->codec->codec_id = <nl> -                av_get_pcm_codec(st->stream->codec->sample_fmt, -1); <nl>              st->stream->codec->channel_layout = st->link->channel_layout; <nl>              st->stream->codec->channels = avfilter_link_get_channels(st->link); <nl>              st->stream->codec->sample_rate = st->link->sample_rate; <nl>              st->stream->codec->sample_fmt = st->link->format; <nl> +            st->stream->codec->codec_id = <nl> +                av_get_pcm_codec(st->stream->codec->sample_fmt, -1); <nl>              break; <nl>          default: <nl>              av_assert0(!"reached");
@@ -295,7 +295,7 @@ static void rac_normalise(RangeCoder *c) <nl>              c->low |= *c->src++; <nl>          } else if (!c->low) { <nl>              c->got_error = 1; <nl> -            return; <nl> +            c->low = 1; <nl>          } <nl>          if (c->range >= RAC_BOTTOM) <nl>              return;
@@ -174,14 +174,9 @@ static av_cold int peak_init_writer(AVFormatContext *s) <nl>      } <nl>   <nl>      wav->peak_maxpos = av_mallocz(enc->channels * sizeof(*wav->peak_maxpos)); <nl> -    if (!wav->peak_maxpos) <nl> -        goto nomem; <nl>      wav->peak_maxneg = av_mallocz(enc->channels * sizeof(*wav->peak_maxneg)); <nl> -    if (!wav->peak_maxneg) <nl> -        goto nomem; <nl> - <nl>      wav->peak_output = av_malloc(PEAK_BUFFER_SIZE); <nl> -    if (!wav->peak_output) <nl> +    if (!wav->peak_maxpos || !wav->peak_maxneg || !wav->peak_output) <nl>          goto nomem; <nl>   <nl>      wav->peak_outbuf_size = PEAK_BUFFER_SIZE;
@@ -353,7 +353,7 @@ static int decode_frame(AVCodecContext *avctx, <nl>          } <nl>   <nl>          s->slices[i][j].start = offset + header_size; <nl> -        s->slices[i][j].size  = avpkt->size - offset; <nl> +        s->slices[i][j].size  = avpkt->size - s->slices[i][j].start; <nl>      } <nl>   <nl>      if (bytestream2_get_byte(&gb) != s->planes)
@@ -72,8 +72,9 @@ static int ivf_write_packet(AVFormatContext *s, AVPacket *pkt) <nl>  static int ivf_write_trailer(AVFormatContext *s) <nl>  { <nl>      AVIOContext *pb = s->pb; <nl> -    if (pb->seekable) { <nl> -        IVFEncContext *ctx = s->priv_data; <nl> +    IVFEncContext *ctx = s->priv_data; <nl> + <nl> +    if (pb->seekable && ctx->frame_cnt > 1) { <nl>          size_t end = avio_tell(pb); <nl>   <nl>          avio_seek(pb, 24, SEEK_SET);
@@ -5364,7 +5364,7 @@ static void vc1_draw_sprites(VC1Context *v, SpriteData* sd) <nl>      int ysub[2]; <nl>      MpegEncContext *s = &v->s; <nl>   <nl> -    for (i = 0; i < 2; i++) { <nl> +    for (i = 0; i <= v->two_sprites; i++) { <nl>          xoff[i] = av_clip(sd->coefs[i][2], 0, v->sprite_width-1 << 16); <nl>          xadv[i] = sd->coefs[i][0]; <nl>          if (xadv[i] != 1<<16 || (v->sprite_width << 16) - (v->output_width << 16) - xoff[i]) <nl> @@ -5442,7 +5442,7 @@ static void vc1_draw_sprites(VC1Context *v, SpriteData* sd) <nl>          } <nl>   <nl>          if (!plane) { <nl> -            for (i = 0; i < 2; i++) { <nl> +            for (i = 0; i <= v->two_sprites; i++) { <nl>                  xoff[i] >>= 1; <nl>                  yoff[i] >>= 1; <nl>              }
@@ -1069,6 +1069,9 @@ end: <nl>          frame->height = avctx->height; <nl>      } <nl>   <nl> +    if (ret < 0) <nl> +        av_frame_unref(frame); <nl> + <nl>      return ret; <nl>  } <nl>  
@@ -277,7 +277,7 @@ static int cdxl_decode_frame(AVCodecContext *avctx, void *data, <nl>      c->padded_bits  = aligned_width - c->avctx->width; <nl>      if (c->video_size < aligned_width * avctx->height * (int64_t)c->bpp / 8) <nl>          return AVERROR_INVALIDDATA; <nl> -    if (!encoding && c->palette_size && c->bpp <= 8) { <nl> +    if (!encoding && c->palette_size && c->bpp <= 8 && c->format != CHUNKY) { <nl>          avctx->pix_fmt = AV_PIX_FMT_PAL8; <nl>      } else if (encoding == 1 && (c->bpp == 6 || c->bpp == 8)) { <nl>          if (c->palette_size != (1 << (c->bpp - 1)))
@@ -282,8 +282,13 @@ static int fic_decode_frame(AVCodecContext *avctx, void *data, <nl>          av_log(avctx, AV_LOG_WARNING, "Invalid FIC Header.\n"); <nl>   <nl>      /* Is it a skip frame? */ <nl> -    if (src[17]) <nl> +    if (src[17]) { <nl> +        if (!ctx->final_frame) { <nl> +            av_log(avctx, AV_LOG_WARNING, "Initial frame is skipped\n"); <nl> +            return AVERROR_INVALIDDATA; <nl> +        } <nl>          goto skip; <nl> +    } <nl>   <nl>      nslices = src[13]; <nl>      if (!nslices) {
@@ -100,7 +100,7 @@ void ff_af_queue_remove(AudioFrameQueue *afq, int nb_samples, int64_t *pts, <nl>   <nl>      if(nb_samples){ <nl>          av_assert0(!afq->frame_count); <nl> -        if(afq->frames[0].pts != AV_NOPTS_VALUE) <nl> +        if(afq->frames && afq->frames[0].pts != AV_NOPTS_VALUE) <nl>              afq->frames[0].pts += nb_samples; <nl>          av_log(afq->avctx, AV_LOG_DEBUG, "Trying to remove %d more samples than are in the que\n", nb_samples); <nl>      }
@@ -475,13 +475,15 @@ static int vp56_size_changed(VP56Context *s) <nl>          return -1; <nl>      } <nl>   <nl> -    s->above_blocks = av_realloc(s->above_blocks, <nl> -                                 (4*s->mb_width+6) * sizeof(*s->above_blocks)); <nl> -    s->macroblocks = av_realloc(s->macroblocks, <nl> -                                s->mb_width*s->mb_height*sizeof(*s->macroblocks)); <nl> +    av_reallocp_array(&s->above_blocks, 4*s->mb_width+6, <nl> +                      sizeof(*s->above_blocks)); <nl> +    av_reallocp_array(&s->macroblocks, s->mb_width*s->mb_height, <nl> +                      sizeof(*s->macroblocks)); <nl>      av_free(s->edge_emu_buffer_alloc); <nl>      s->edge_emu_buffer_alloc = av_malloc(16*stride); <nl>      s->edge_emu_buffer = s->edge_emu_buffer_alloc; <nl> +    if (!s->above_blocks || !s->macroblocks || !s->edge_emu_buffer_alloc) <nl> +        return AVERROR(ENOMEM); <nl>      if (s->flip < 0) <nl>          s->edge_emu_buffer += 15 * stride; <nl>  
@@ -245,7 +245,7 @@ static int decode_frame(AVCodecContext *avctx, <nl>      AVFrame *p = data; <nl>      GetByteContext gb; <nl>      GetBitContext b; <nl> -    int i, j, k; <nl> +    int i, j, k, width, height; <nl>   <nl>      bytestream2_init(&gb, avpkt->data, avpkt->size); <nl>      if (bytestream2_get_le32(&gb) != MKTAG('M','A','G','Y')) <nl> @@ -309,7 +309,9 @@ static int decode_frame(AVCodecContext *avctx, <nl>      s->interlaced = !!(bytestream2_get_byte(&gb) & 2); <nl>      bytestream2_skip(&gb, 3); <nl>   <nl> -    if ((ret = ff_set_dimensions(avctx, bytestream2_get_le32(&gb), bytestream2_get_le32(&gb))) < 0) <nl> +    width  = bytestream2_get_le32(&gb); <nl> +    height = bytestream2_get_le32(&gb); <nl> +    if ((ret = ff_set_dimensions(avctx, width, height)) < 0) <nl>          return ret; <nl>   <nl>      slice_width = bytestream2_get_le32(&gb);
@@ -412,7 +412,7 @@ static int h261_probe(AVProbeData *p) <nl>   <nl>  static int ac3_probe(AVProbeData *p) <nl>  { <nl> -    int max_frames, first_frames, frames; <nl> +    int max_frames, first_frames = 0, frames; <nl>      uint8_t *buf, *buf2, *end; <nl>      AC3HeaderInfo hdr; <nl>  
@@ -1627,9 +1627,9 @@ static int probe_file(WriterContext *wctx, const char *filename) <nl>      do_read_packets = do_show_packets || do_count_packets; <nl>   <nl>      ret = open_input_file(&fmt_ctx, filename); <nl> -    nb_streams_frames  = av_calloc(fmt_ctx->nb_streams, sizeof(*nb_streams_frames)); <nl> -    nb_streams_packets = av_calloc(fmt_ctx->nb_streams, sizeof(*nb_streams_packets)); <nl>      if (ret >= 0) { <nl> +        nb_streams_frames  = av_calloc(fmt_ctx->nb_streams, sizeof(*nb_streams_frames)); <nl> +        nb_streams_packets = av_calloc(fmt_ctx->nb_streams, sizeof(*nb_streams_packets)); <nl>          if (do_read_frames || do_read_packets) { <nl>              const char *chapter; <nl>              if (do_show_frames && do_show_packets && <nl> @@ -1651,11 +1651,9 @@ static int probe_file(WriterContext *wctx, const char *filename) <nl>              if (fmt_ctx->streams[i]->codec->codec_id != CODEC_ID_NONE) <nl>                  avcodec_close(fmt_ctx->streams[i]->codec); <nl>          avformat_close_input(&fmt_ctx); <nl> +        av_freep(&nb_streams_frames); <nl> +        av_freep(&nb_streams_packets); <nl>      } <nl> - <nl> -    av_freep(&nb_streams_frames); <nl> -    av_freep(&nb_streams_packets); <nl> - <nl>      return ret; <nl>  } <nl>  
@@ -1670,6 +1670,8 @@ static int mjpeg_decode_app(MJpegDecodeContext *s) <nl>   <nl>      if (id == AV_RB32("JFIF")) { <nl>          int t_w, t_h, v1, v2; <nl> +        if (len < 8) <nl> +            goto out; <nl>          skip_bits(&s->gb, 8); /* the trailing zero-byte */ <nl>          v1 = get_bits(&s->gb, 8); <nl>          v2 = get_bits(&s->gb, 8);
@@ -1894,10 +1894,8 @@ int ff_mpegts_parse_packet(MpegTSContext *ts, AVPacket *pkt, <nl>   <nl>      len1 = len; <nl>      ts->pkt = pkt; <nl> -    ts->stop_parse = 0; <nl>      for(;;) { <nl> -        if (ts->stop_parse>0) <nl> -            break; <nl> +        ts->stop_parse = 0; <nl>          if (len < TS_PACKET_SIZE) <nl>              return -1; <nl>          if (buf[0] != 0x47) { <nl> @@ -1907,6 +1905,8 @@ int ff_mpegts_parse_packet(MpegTSContext *ts, AVPacket *pkt, <nl>              handle_packet(ts, buf); <nl>              buf += TS_PACKET_SIZE; <nl>              len -= TS_PACKET_SIZE; <nl> +            if (ts->stop_parse == 1) <nl> +                break; <nl>          } <nl>      } <nl>      return len1 - len;
@@ -83,6 +83,9 @@ int ff_oss_audio_open(AVFormatContext *s1, int is_output, <nl>       * usable. If OSS is not usable the SNDCTL_DSP_SETFMTS later is going to <nl>       * fail anyway. `err =` kept to eliminate compiler warning. */ <nl>      err = ioctl(audio_fd, SNDCTL_DSP_GETFMTS, &tmp); <nl> +    if (err < 0) { <nl> +        av_log(s1, AV_LOG_WARNING, "SNDCTL_DSP_GETFMTS: %s\n", strerror(errno)); <nl> +    } <nl>   <nl>  #if HAVE_BIGENDIAN <nl>      if (tmp & AFMT_S16_BE) {
@@ -1217,6 +1217,10 @@ int64_t av_gen_search(AVFormatContext *s, int stream_index, int64_t target_ts, i <nl>  #ifdef DEBUG_SEEK <nl>  av_log(s, AV_LOG_DEBUG, "%"PRId64" %"PRId64" %"PRId64" / %"PRId64" %"PRId64" %"PRId64" target:%"PRId64" limit:%"PRId64" start:%"PRId64" noc:%d\n", pos_min, pos, pos_max, ts_min, ts, ts_max, target_ts, pos_limit, start_pos, no_change); <nl>  #endif <nl> +        if(ts == AV_NOPTS_VALUE){ <nl> +            av_log(s, AV_LOG_ERROR, "read_timestamp() failed in the middle\n"); <nl> +            return -1; <nl> +        } <nl>          assert(ts != AV_NOPTS_VALUE); <nl>          if (target_ts <= ts) { <nl>              pos_limit = start_pos - 1;
@@ -73,6 +73,7 @@ static void apply_unsharp(      uint8_t *dst, int dst_stride, <nl>   <nl>      int32_t res; <nl>      int x, y, z; <nl> +    const uint8_t *src2; <nl>   <nl>      if (!fp->amount) { <nl>          if (dst_stride == src_stride) <nl> @@ -87,9 +88,12 @@ static void apply_unsharp(      uint8_t *dst, int dst_stride, <nl>          memset(sc[y], 0, sizeof(sc[y][0]) * (width + 2 * fp->steps_x)); <nl>   <nl>      for (y = -fp->steps_y; y < height + fp->steps_y; y++) { <nl> +        if (y < height) <nl> +            src2 = src; <nl> + <nl>          memset(sr, 0, sizeof(sr[0]) * (2 * fp->steps_x - 1)); <nl>          for (x = -fp->steps_x; x < width + fp->steps_x; x++) { <nl> -            tmp1 = x <= 0 ? src[0] : x >= width ? src[width-1] : src[x]; <nl> +            tmp1 = x <= 0 ? src2[0] : x >= width ? src2[width-1] : src2[x]; <nl>              for (z = 0; z < fp->steps_x * 2; z += 2) { <nl>                  tmp2 = sr[z + 0] + tmp1; sr[z + 0] = tmp1; <nl>                  tmp1 = sr[z + 1] + tmp2; sr[z + 1] = tmp2;
@@ -247,7 +247,7 @@ static void read_tree(GetBitContext *gb, Tree *tree) <nl>              tree->syms[i] = get_bits(gb, 4); <nl>              tmp1[tree->syms[i]] = 1; <nl>          } <nl> -        for (i = 0; i < 16; i++) <nl> +        for (i = 0; i < 16 && len < 16 - 1; i++) <nl>              if (!tmp1[i]) <nl>                  tree->syms[++len] = i; <nl>      } else {
@@ -428,6 +428,8 @@ fail: <nl>  fail_at_end: <nl>      av_freep(&pic->codec_picture_params); <nl>      av_frame_free(&pic->recon_image); <nl> +    av_buffer_unref(&pic->output_buffer_ref); <nl> +    pic->output_buffer = VA_INVALID_ID; <nl>      return err; <nl>  } <nl>  
@@ -119,6 +119,7 @@ static void cdxl_decode_rgb(CDXLVideoContext *c) <nl>  { <nl>      uint32_t *new_palette = (uint32_t *)c->frame.data[1]; <nl>   <nl> +    memset(c->frame.data[1], 0, AVPALETTE_SIZE); <nl>      import_palette(c, new_palette); <nl>      import_format(c, c->frame.linesize[0], c->frame.data[0]); <nl>  }
@@ -124,12 +124,18 @@ static int encode_frame(AVCodecContext *avctx, AVPacket *pkt, <nl>          uint8_t *luma = &p->data[0][y * p->linesize[0]]; <nl>          uint8_t *cb   = &p->data[1][y * p->linesize[1]]; <nl>          uint8_t *cr   = &p->data[2][y * p->linesize[2]]; <nl> +        uint8_t luma_tmp[4]; <nl>          for (x = 0; x < avctx->width; x += 4) { <nl>              switch (a->dither_type) { <nl>              case 0: dither = 0x492A0000;                       break; <nl>              case 1: dither = dither * 1664525 + 1013904223;    break; <nl>              case 2: dither = ordered_dither[ y&1 ][ (x>>2)&1 ];break; <nl>              } <nl> +            if (x+3 >= avctx->width) { <nl> +                memset(luma_tmp, 0, sizeof(luma_tmp)); <nl> +                memcpy(luma_tmp, luma, avctx->width - x); <nl> +                luma = luma_tmp; <nl> +            } <nl>              put_bits(&pb, 5, (249*(luma[3] +  (dither>>29)   )) >> 11); <nl>              put_bits(&pb, 5, (249*(luma[2] + ((dither>>26)&7))) >> 11); <nl>              put_bits(&pb, 5, (249*(luma[1] + ((dither>>23)&7))) >> 11);
@@ -1112,7 +1112,7 @@ static int rv34_decode_macroblock(RV34DecContext *r, int8_t *intra_types) <nl>      GetBitContext *gb = &s->gb; <nl>      int cbp, cbp2; <nl>      int i, blknum, blkoff; <nl> -    DCTELEM block16[64]; <nl> +    LOCAL_ALIGNED_16(DCTELEM, block16, [64]); <nl>      int luma_dc_quant; <nl>      int dist; <nl>      int mb_pos = s->mb_x + s->mb_y * s->mb_stride; <nl> @@ -1147,7 +1147,7 @@ static int rv34_decode_macroblock(RV34DecContext *r, int8_t *intra_types) <nl>   <nl>      luma_dc_quant = r->block_type == RV34_MB_P_MIX16x16 ? r->luma_dc_quant_p[s->qscale] : r->luma_dc_quant_i[s->qscale]; <nl>      if(r->is16){ <nl> -        memset(block16, 0, sizeof(block16)); <nl> +        memset(block16, 0, 64 * sizeof(*block16)); <nl>          rv34_decode_block(block16, gb, r->cur_vlcs, 3, 0); <nl>          rv34_dequant4x4_16x16(block16, rv34_qscale_tab[luma_dc_quant],rv34_qscale_tab[s->qscale]); <nl>          r->rdsp.rv34_inv_transform_tab[1](block16);
@@ -153,6 +153,9 @@ static int cmv_decode_frame(AVCodecContext *avctx, <nl>      CmvContext *s = avctx->priv_data; <nl>      const uint8_t *buf_end = buf + buf_size; <nl>   <nl> +    if (buf_end - buf < EA_PREAMBLE_SIZE) <nl> +        return AVERROR_INVALIDDATA; <nl> + <nl>      if (AV_RL32(buf)==MVIh_TAG||AV_RB32(buf)==MVIh_TAG) { <nl>          cmv_process_header(s, buf+EA_PREAMBLE_SIZE, buf_end); <nl>          return buf_size;
@@ -74,6 +74,8 @@ static void init_uni_ac_vlc(RLTable *rl, uint8_t *uni_ac_vlc_len){ <nl>      for(i=0; i<128; i++){ <nl>          int level= i-64; <nl>          int run; <nl> +        if (!level) <nl> +            continue; <nl>          for(run=0; run<64; run++){ <nl>              int len, bits, code; <nl>  
@@ -96,6 +96,9 @@ int ff_dirac_golomb_read_16bit(DiracGolombLUT *lut_ctx, const uint8_t *buf, <nl>          if ((c_idx + 1) > coeffs) <nl>              return c_idx; <nl>   <nl> +        if (res_bits >= RSIZE_BITS) <nl> +            res_bits = res = 0; <nl> + <nl>          if (res_bits && l->sign) { <nl>              int32_t coeff = 1; <nl>              APPEND_RESIDUE(res, l->preamble);
@@ -406,8 +406,10 @@ static int get_cookies(HTTPContext *s, char **cookies, const char *path, <nl>          while ((param = av_strtok(cookie, "; ", &next_param))) { <nl>              cookie = NULL; <nl>              if        (!av_strncasecmp("path=",   param, 5)) { <nl> +                av_free(cpath); <nl>                  cpath = av_strdup(&param[5]); <nl>              } else if (!av_strncasecmp("domain=", param, 7)) { <nl> +                av_free(cdomain); <nl>                  cdomain = av_strdup(&param[7]); <nl>              } else if (!av_strncasecmp("secure",  param, 6) || <nl>                         !av_strncasecmp("comment", param, 7) || <nl> @@ -415,6 +417,7 @@ static int get_cookies(HTTPContext *s, char **cookies, const char *path, <nl>                         !av_strncasecmp("version", param, 7)) { <nl>                  // ignore Comment, Max-Age, Secure and Version <nl>              } else { <nl> +                av_free(cvalue); <nl>                  cvalue = av_strdup(param); <nl>              } <nl>          }
@@ -100,7 +100,7 @@ static int config_input(AVFilterLink *inlink) <nl>      PadContext *pad = ctx->priv; <nl>      const AVPixFmtDescriptor *pix_desc = &av_pix_fmt_descriptors[inlink->format]; <nl>      uint8_t rgba_color[4]; <nl> -    uint8_t rgba_map[4]; <nl> +    uint8_t rgba_map[4] = {0}; <nl>      int i, is_packed_rgb = 1; <nl>   <nl>      switch (inlink->format) {
@@ -131,6 +131,10 @@ static int submit_stats(AVCodecContext *avctx) <nl>          } <nl>          h->stats_size = strlen(avctx->stats_in) * 3/4; <nl>          h->stats      = av_malloc(h->stats_size); <nl> +        if (!h->stats) { <nl> +            h->stats_size = 0; <nl> +            return AVERROR(ENOMEM); <nl> +        } <nl>          h->stats_size = av_base64_decode(h->stats, avctx->stats_in, h->stats_size); <nl>      } <nl>      while (h->stats_size - h->stats_offset > 0) {
@@ -446,7 +446,10 @@ bitmap_end_skip: <nl>                  goto skip; <nl>              if ((res = av_new_packet(pkt, len)) < 0) <nl>                  return res; <nl> -            avio_read(pb, pkt->data, 4); <nl> +            if (avio_read(pb, pkt->data, 4) != 4) { <nl> +                av_free_packet(pkt); <nl> +                return AVERROR_INVALIDDATA; <nl> +            } <nl>              if (AV_RB32(pkt->data) == 0xffd8ffd9 || <nl>                  AV_RB32(pkt->data) == 0xffd9ffd8) { <nl>                  /* old SWF files containing SOI/EOI as data start */
@@ -1443,7 +1443,7 @@ static int mjpeg_decode_app(MJpegDecodeContext *s) <nl>      int len, id, i; <nl>   <nl>      len = get_bits(&s->gb, 16); <nl> -    if (len < 5) <nl> +    if (len < 6) <nl>          return AVERROR_INVALIDDATA; <nl>      if (8 * len > get_bits_left(&s->gb)) <nl>          return AVERROR_INVALIDDATA; <nl> @@ -1557,7 +1557,7 @@ static int mjpeg_decode_app(MJpegDecodeContext *s) <nl>      } <nl>   <nl>      /* EXIF metadata */ <nl> -    if (s->start_code == APP1 && id == AV_RB32("Exif")) { <nl> +    if (s->start_code == APP1 && id == AV_RB32("Exif") && len >= 2) { <nl>          GetByteContext gbytes; <nl>          int ret, le, ifd_offset, bytes_read; <nl>          const uint8_t *aligned;
@@ -584,6 +584,13 @@ static int decode_cell(Indeo3DecodeContext *ctx, AVCodecContext *avctx, <nl>          /* set the pointer to the reference pixels for modes 0-4 INTER */ <nl>          mv_y      = cell->mv_ptr[0]; <nl>          mv_x      = cell->mv_ptr[1]; <nl> +        if (   mv_x + 4*cell->xpos < 0 <nl> +            || mv_y + 4*cell->ypos < 0 <nl> +            || mv_x + 4*cell->xpos + 4*cell->width  > plane->width <nl> +            || mv_y + 4*cell->ypos + 4*cell->height > plane->height) { <nl> +            av_log(avctx, AV_LOG_ERROR, "motion vector %d %d outside reference\n", mv_x + 4*cell->xpos, mv_y + 4*cell->ypos); <nl> +            return AVERROR_INVALIDDATA; <nl> +        } <nl>          offset   += mv_y * plane->pitch + mv_x; <nl>          ref_block = plane->pixels[ctx->buf_sel ^ 1] + offset; <nl>      }
@@ -247,7 +247,7 @@ static int libx265_encode_frame(AVCodecContext *avctx, AVPacket *pkt, <nl>  { <nl>      libx265Context *ctx = avctx->priv_data; <nl>      x265_picture x265pic; <nl> -    x265_picture x265pic_out = { { 0 } }; <nl> +    x265_picture x265pic_out = { 0 }; <nl>      x265_nal *nal; <nl>      uint8_t *dst; <nl>      int payload = 0;
@@ -3057,7 +3057,7 @@ static int verify_md5(HEVCContext *s, AVFrame *frame) <nl>      return 0; <nl>  } <nl>   <nl> -static int hevc_decode_extradata(HEVCContext *s, uint8_t *buf, int length) <nl> +static int hevc_decode_extradata(HEVCContext *s, uint8_t *buf, int length, int first) <nl>  { <nl>      int ret, i; <nl>   <nl> @@ -3069,7 +3069,7 @@ static int hevc_decode_extradata(HEVCContext *s, uint8_t *buf, int length) <nl>   <nl>      /* export stream parameters from the first SPS */ <nl>      for (i = 0; i < FF_ARRAY_ELEMS(s->ps.sps_list); i++) { <nl> -        if (s->ps.sps_list[i]) { <nl> +        if (first && s->ps.sps_list[i]) { <nl>              const HEVCSPS *sps = (const HEVCSPS*)s->ps.sps_list[i]->data; <nl>              export_stream_params(s->avctx, &s->ps, sps); <nl>              break; <nl> @@ -3099,7 +3099,7 @@ static int hevc_decode_frame(AVCodecContext *avctx, void *data, int *got_output, <nl>      new_extradata = av_packet_get_side_data(avpkt, AV_PKT_DATA_NEW_EXTRADATA, <nl>                                              &new_extradata_size); <nl>      if (new_extradata && new_extradata_size > 0) { <nl> -        ret = hevc_decode_extradata(s, new_extradata, new_extradata_size); <nl> +        ret = hevc_decode_extradata(s, new_extradata, new_extradata_size, 0); <nl>          if (ret < 0) <nl>              return ret; <nl>      } <nl> @@ -3387,7 +3387,7 @@ static av_cold int hevc_decode_init(AVCodecContext *avctx) <nl>          s->threads_number = 1; <nl>   <nl>      if (avctx->extradata_size > 0 && avctx->extradata) { <nl> -        ret = hevc_decode_extradata(s, avctx->extradata, avctx->extradata_size); <nl> +        ret = hevc_decode_extradata(s, avctx->extradata, avctx->extradata_size, 1); <nl>          if (ret < 0) { <nl>              hevc_decode_free(avctx); <nl>              return ret;
@@ -807,6 +807,12 @@ static int decode_frame(AVCodecContext *avctx, void *data, <nl>      if (buf_size < 20) <nl>          return AVERROR_INVALIDDATA; <nl>   <nl> +    if (avctx->width % 16 || avctx->height % 16) { <nl> +        av_log(avctx, AV_LOG_ERROR, <nl> +               "Dimensions non-multiple of 16 are invalid.\n"); <nl> +        return AVERROR_INVALIDDATA; <nl> +    } <nl> + <nl>      if (buf_size < AV_RL32(buf + 4) + 8) { <nl>          av_log(f->avctx, AV_LOG_ERROR, "size mismatch %d %d\n", <nl>                 buf_size, AV_RL32(buf + 4));
@@ -136,7 +136,7 @@ static int rtsp_read_header(AVFormatContext *s, <nl>      rt->real_setup_cache = av_mallocz(2 * s->nb_streams * sizeof(*rt->real_setup_cache)); <nl>      if (!rt->real_setup_cache) <nl>          return AVERROR(ENOMEM); <nl> -    rt->real_setup = rt->real_setup_cache + s->nb_streams * sizeof(*rt->real_setup); <nl> +    rt->real_setup = rt->real_setup_cache + s->nb_streams; <nl>   <nl>      if (ap->initial_pause) { <nl>           /* do not start immediately */
@@ -748,9 +748,6 @@ static void close_connection(HTTPContext *c) <nl>   <nl>      ctx = &c->fmt_ctx; <nl>   <nl> -    for(i=0; i<ctx->nb_streams; i++)  <nl> -        av_free(ctx->streams[i]) ;  <nl> - <nl>      if (!c->last_packet_sent) { <nl>          if (ctx->oformat) { <nl>              /* prepare header */ <nl> @@ -761,6 +758,9 @@ static void close_connection(HTTPContext *c) <nl>          } <nl>      } <nl>   <nl> +    for(i=0; i<ctx->nb_streams; i++)  <nl> +        av_free(ctx->streams[i]) ;  <nl> + <nl>      if (c->stream) <nl>          current_bandwidth -= c->stream->bandwidth; <nl>      av_freep(&c->pb_buffer);
@@ -163,6 +163,8 @@ static int avs_read_packet(AVFormatContext * s, AVPacket * pkt) <nl>              sub_type = avio_r8(s->pb); <nl>              type = avio_r8(s->pb); <nl>              size = avio_rl16(s->pb); <nl> +            if (size < 4) <nl> +                return AVERROR_INVALIDDATA; <nl>              avs->remaining_frame_size -= size; <nl>   <nl>              switch (type) {
@@ -896,6 +896,8 @@ int vc1_parse_frame_header_adv(VC1Context *v, GetBitContext* gb) <nl>      v->rnd = get_bits1(gb); <nl>      if (v->interlace) <nl>          v->uvsamp = get_bits1(gb); <nl> +    if(!ff_vc1_bfraction_vlc.table) <nl> +        return 0; //parsing only, vlc tables havnt been allocated <nl>      if (v->field_mode) { <nl>          if (!v->refdist_flag) <nl>              v->refdist = 0;
@@ -200,8 +200,8 @@ WINDOW_FUNC(long_start) <nl>      float *out = sce->ret; <nl>   <nl>      dsp->vector_fmul(out, audio, lwindow, 1024); <nl> -    memcpy(out + 1024, audio, sizeof(out[0]) * 448); <nl> -    dsp->vector_fmul_reverse(out + 1024 + 448, audio, swindow, 128); <nl> +    memcpy(out + 1024, audio + 1024, sizeof(out[0]) * 448); <nl> +    dsp->vector_fmul_reverse(out + 1024 + 448, audio + 1024 + 448, swindow, 128); <nl>      memset(out + 1024 + 576, 0, sizeof(out[0]) * 448); <nl>  } <nl>  
@@ -2653,10 +2653,9 @@ int ff_mpeg4_frame_end(AVCodecContext *avctx, const uint8_t *buf, int buf_size) <nl>          } <nl>   <nl>          if (startcode_found) { <nl> -            av_fast_malloc(&s->bitstream_buffer, <nl> +            av_fast_padded_malloc(&s->bitstream_buffer, <nl>                             &s->allocated_bitstream_buffer_size, <nl> -                           buf_size - current_pos + <nl> -                           FF_INPUT_BUFFER_PADDING_SIZE); <nl> +                           buf_size - current_pos); <nl>              if (!s->bitstream_buffer) <nl>                  return AVERROR(ENOMEM); <nl>              memcpy(s->bitstream_buffer, buf + current_pos,
@@ -597,6 +597,10 @@ static int vorbis_parse_setup_hdr_floors(vorbis_context *vc) <nl>                         "Floor 0 amplitude bits is 0.\n"); <nl>                  return AVERROR_INVALIDDATA; <nl>              } <nl> +            if (floor_setup->data.t0.bark_map_size == 0) { <nl> +                av_log(vc->avccontext, AV_LOG_ERROR, "Floor 0 bark map size is 0.\n"); <nl> +                return AVERROR_INVALIDDATA; <nl> +            } <nl>              floor_setup->data.t0.amplitude_offset = get_bits(gb, 8); <nl>              floor_setup->data.t0.num_books        = get_bits(gb, 4) + 1; <nl>  
@@ -133,7 +133,7 @@ static av_always_inline SoftFloat autocorr_calc(int64_t accu) <nl>   <nl>          round = 1U << (nz-1); <nl>          mant = (int)((accu + round) >> nz); <nl> -        mant = (mant + 0x40)>>7; <nl> +        mant = (mant + 0x40LL)>>7; <nl>          mant *= 64; <nl>          expo = nz + 15; <nl>          return av_int2sf(mant, 30 - expo);
@@ -626,6 +626,14 @@ int ff_h264_execute_ref_pic_marking(H264Context *h, MMCO *mmco, int mmco_count) <nl>                       */ <nl>   <nl>              if (h->long_ref[mmco[i].long_arg] != h->cur_pic_ptr) { <nl> +                if (h->cur_pic_ptr->long_ref) { <nl> +                    for(j=0; j<16; j++) { <nl> +                        if(h->long_ref[j] == h->cur_pic_ptr) { <nl> +                            remove_long(h, j, 0); <nl> +                            av_log(h->avctx, AV_LOG_ERROR, "mmco: cannot assign current picture to 2 long term references\n"); <nl> +                        } <nl> +                    } <nl> +                } <nl>                  av_assert0(!h->cur_pic_ptr->long_ref); <nl>                  remove_long(h, mmco[i].long_arg, 0); <nl>                  if (remove_short(h, h->cur_pic_ptr->frame_num, 0)) {
@@ -20,6 +20,7 @@ <nl>   */ <nl>   <nl>  #include "libavutil/intreadwrite.h" <nl> +#include "libavcodec/internal.h" <nl>  #include "avformat.h" <nl>  #include "internal.h" <nl>  #include "pcm.h" <nl> @@ -59,7 +60,7 @@ static int epaf_read_header(AVFormatContext *s) <nl>          channels    = avio_rb32(s->pb); <nl>      } <nl>   <nl> -    if (!channels || !sample_rate) <nl> +    if (channels <= 0 || channels > FF_SANE_NB_CHANNELS || sample_rate <= 0) <nl>          return AVERROR_INVALIDDATA; <nl>   <nl>      st = avformat_new_stream(s, NULL);
@@ -212,7 +212,7 @@ static int parse_playlist(HLSContext *c, const char *url, <nl>      uint8_t iv[16] = ""; <nl>      int has_iv = 0; <nl>      char key[MAX_URL_SIZE] = ""; <nl> -    char line[1024]; <nl> +    char line[MAX_URL_SIZE]; <nl>      const char *ptr; <nl>      int close_in = 0; <nl>  
@@ -238,9 +238,9 @@ <nl>   * according with endianness of the host machine. <nl>   */ <nl>  #if HAVE_BIGENDIAN <nl> -#define PD(a,b) (((a) << 8) + (b)) <nl> +#define PD(a,b) (((a) * (1 << 8)) + (b)) <nl>  #else <nl> -#define PD(a,b) (((b) << 8) + (a)) <nl> +#define PD(a,b) (((b) * (1 << 8)) + (a)) <nl>  #endif <nl>   <nl>  /** <nl> @@ -285,9 +285,9 @@ static const int16_t delta_tab_3_5[79]  = { TAB_3_5 }; <nl>   * according with endianness of the host machine. <nl>   */ <nl>  #if HAVE_BIGENDIAN <nl> -#define PD(a,b) (((a) << 24) + ((a) << 16) + ((b) << 8) + (b)) <nl> +#define PD(a,b) (((a) * (1 << 24)) + ((a) * (1 << 16)) + ((b) * (1 << 8)) + (b)) <nl>  #else <nl> -#define PD(a,b) (((b) << 24) + ((b) << 16) + ((a) << 8) + (a)) <nl> +#define PD(a,b) (((b) * (1 << 24)) + ((b) * (1 << 16)) + ((a) * (1 << 8)) + (a)) <nl>  #endif <nl>   <nl>  /*
@@ -85,7 +85,7 @@ int av_cold ff_wma_get_frame_len_bits(int sample_rate, int version, <nl>      } else if (sample_rate <= 22050 || <nl>               (sample_rate <= 32000 && version == 1)) { <nl>          frame_len_bits = 10; <nl> -    } else if (sample_rate <= 48000) { <nl> +    } else if (sample_rate <= 48000 || version < 3) { <nl>          frame_len_bits = 11; <nl>      } else if (sample_rate <= 96000) { <nl>          frame_len_bits = 12;
@@ -2367,7 +2367,7 @@ static void implicit_weight_table(H264Context *h, int field){ <nl>  static void idr(H264Context *h){ <nl>      int i; <nl>      ff_h264_remove_all_refs(h); <nl> -    h->prev_frame_num= 0; <nl> +    h->prev_frame_num= -1; <nl>      h->prev_frame_num_offset= 0; <nl>      h->prev_poc_msb= <nl>      h->prev_poc_lsb= 0; <nl> @@ -2882,7 +2882,7 @@ static int decode_slice_header(H264Context *h, H264Context *h0){ <nl>   <nl>      if(h0->current_slice == 0){ <nl>          // Shorten frame num gaps so we don't have to allocate reference frames just to throw them away <nl> -        if(h->frame_num != h->prev_frame_num) { <nl> +        if(h->frame_num != h->prev_frame_num && h->prev_frame_num >= 0) { <nl>              int unwrap_prev_frame_num = h->prev_frame_num, max_frame_num = 1<<h->sps.log2_max_frame_num; <nl>   <nl>              if (unwrap_prev_frame_num > h->frame_num) unwrap_prev_frame_num -= max_frame_num; <nl> @@ -2896,7 +2896,7 @@ static int decode_slice_header(H264Context *h, H264Context *h0){ <nl>              } <nl>          } <nl>   <nl> -        while(h->frame_num !=  h->prev_frame_num && <nl> +        while(h->frame_num !=  h->prev_frame_num && h->prev_frame_num >= 0 && <nl>                h->frame_num != (h->prev_frame_num+1)%(1<<h->sps.log2_max_frame_num)){ <nl>              Picture *prev = h->short_ref_count ? h->short_ref[0] : NULL; <nl>              av_log(h->s.avctx, AV_LOG_DEBUG, "Frame num gap %d %d\n", h->frame_num, h->prev_frame_num);
@@ -571,6 +571,7 @@ static int read_extra_header(FFV1Context *f) <nl>      f->quant_table_count = get_symbol(c, state, 0); <nl>      if (f->quant_table_count > (unsigned)MAX_QUANT_TABLES || !f->quant_table_count) { <nl>          av_log(f->avctx, AV_LOG_ERROR, "quant table count %d is invalid\n", f->quant_table_count); <nl> +        f->quant_table_count = 0; <nl>          return AVERROR_INVALIDDATA; <nl>      } <nl>  
@@ -1485,7 +1485,7 @@ static int asf_read_packet(AVFormatContext *s, AVPacket *pkt) <nl>              asf->return_subpayload = 0; <nl>              return 0; <nl>          } <nl> -        for (i = 0; i < s->nb_streams; i++) { <nl> +        for (i = 0; i < asf->nb_streams; i++) { <nl>              ASFPacket *asf_pkt = &asf->asf_st[i]->pkt; <nl>              if (asf_pkt && !asf_pkt->size_left && asf_pkt->data_size) { <nl>                  if (asf->asf_st[i]->span > 1 &&
@@ -71,8 +71,12 @@ static int encode_init(AVCodecContext * avctx){ <nl>      for(i = 0; i < s->nb_block_sizes; i++) <nl>          ff_mdct_init(&s->mdct_ctx[i], s->frame_len_bits - i + 1, 0, 1.0); <nl>   <nl> -    avctx->block_align= <nl> -    s->block_align= avctx->bit_rate*(int64_t)s->frame_len / (avctx->sample_rate*8); <nl> +    s->block_align     = avctx->bit_rate * (int64_t)s->frame_len / <nl> +                         (avctx->sample_rate * 8); <nl> +    s->block_align     = FFMIN(s->block_align, MAX_CODED_SUPERFRAME_SIZE); <nl> +    avctx->block_align = s->block_align; <nl> +    avctx->bit_rate    = avctx->block_align * 8LL * avctx->sample_rate / <nl> +                         s->frame_len; <nl>  //av_log(NULL, AV_LOG_ERROR, "%d %d %d %d\n", s->block_align, avctx->bit_rate, s->frame_len, avctx->sample_rate); <nl>      avctx->frame_size= s->frame_len; <nl>  
@@ -2051,6 +2051,7 @@ int attribute_align_arg avcodec_decode_audio4(AVCodecContext *avctx, <nl>          avctx->pkt = &tmp; <nl>          ret = avctx->codec->decode(avctx, frame, got_frame_ptr, &tmp); <nl>          if (ret >= 0 && *got_frame_ptr) { <nl> +            add_metadata_from_side_data(avctx, frame); <nl>              avctx->frame_number++; <nl>              frame->pkt_dts = avpkt->dts; <nl>              av_frame_set_best_effort_timestamp(frame, <nl> @@ -2070,7 +2071,6 @@ int attribute_align_arg avcodec_decode_audio4(AVCodecContext *avctx, <nl>                  avci->to_free.extended_data = avci->to_free.data; <nl>              } <nl>          } <nl> -        add_metadata_from_side_data(avctx, frame); <nl>   <nl>          side= av_packet_get_side_data(avctx->pkt, AV_PKT_DATA_SKIP_SAMPLES, &side_size); <nl>          if(side && side_size>=10) {
@@ -492,6 +492,7 @@ void decode_mvs(VP8Context *s, VP8Macroblock *mb, int mb_x, int mb_y) <nl>   <nl>      AV_ZERO32(&near_mv[0]); <nl>      AV_ZERO32(&near_mv[1]); <nl> +    AV_ZERO32(&near_mv[2]); <nl>   <nl>      /* Process MB on top, left and top-left */ <nl>      #define MV_EDGE_CHECK(n)\
@@ -70,11 +70,6 @@ static int chunk_mux_init(AVFormatContext *s) <nl>      oc->max_delay          = s->max_delay; <nl>      av_dict_copy(&oc->metadata, s->metadata, 0); <nl>   <nl> -    oc->priv_data = av_mallocz(oc->oformat->priv_data_size); <nl> -    if (!oc->priv_data) { <nl> -        avio_close(oc->pb); <nl> -        return AVERROR(ENOMEM); <nl> -    } <nl>      *(const AVClass**)oc->priv_data = oc->oformat->priv_class; <nl>      av_opt_set_defaults(oc->priv_data); <nl>      av_opt_set_int(oc->priv_data, "dash", 1, 0);
@@ -2420,7 +2420,6 @@ static int matroska_parse_cluster_incremental(MatroskaDemuxContext *matroska) <nl>          } <nl>      } <nl>   <nl> -    if (res < 0)  matroska->done = 1; <nl>      return res; <nl>  } <nl>  
@@ -915,6 +915,9 @@ int av_add_index_entry(AVStream *st, <nl>                  memmove(entries + index + 1, entries + index, sizeof(AVIndexEntry)*(st->nb_index_entries - index)); <nl>              } <nl>              st->nb_index_entries++; <nl> +        }else{ <nl> +            if(ie->pos == pos && distance < ie->min_distance) //dont reduce the distance <nl> +                distance= ie->min_distance; <nl>          } <nl>      }else{ <nl>          index= st->nb_index_entries++;
@@ -217,7 +217,7 @@ static av_cold int ape_decode_init(AVCodecContext *avctx) <nl>   <nl>      av_log(avctx, AV_LOG_DEBUG, "Compression Level: %d - Flags: %d\n", <nl>             s->compression_level, s->flags); <nl> -    if (s->compression_level % 1000 || s->compression_level > COMPRESSION_LEVEL_INSANE) { <nl> +    if (s->compression_level % 1000 || s->compression_level > COMPRESSION_LEVEL_INSANE || !s->compression_level) { <nl>          av_log(avctx, AV_LOG_ERROR, "Incorrect compression level %d\n", <nl>                 s->compression_level); <nl>          return AVERROR_INVALIDDATA;
@@ -635,6 +635,12 @@ int ff_hevc_decode_nal_sps(HEVCContext *s) <nl>          goto err; <nl>      } <nl>   <nl> +    if (!s->vps_list[sps->vps_id]) { <nl> +        av_log(s->avctx, AV_LOG_ERROR, "VPS does not exist \n"); <nl> +        ret = AVERROR_INVALIDDATA; <nl> +        goto err; <nl> +    } <nl> + <nl>      sps->max_sub_layers = get_bits(gb, 3) + 1; <nl>      if (sps->max_sub_layers > MAX_SUB_LAYERS) { <nl>          av_log(s->avctx, AV_LOG_ERROR, "sps_max_sub_layers out of range: %d\n",
@@ -136,6 +136,11 @@ read_header: <nl>   <nl>      //XXX FIXME factorize, this looks very similar to the EOI code <nl>   <nl> +    if(!s->got_picture) { <nl> +        av_log(avctx, AV_LOG_WARNING, "no picture\n"); <nl> +        return buf_size; <nl> +    } <nl> + <nl>      *picture= *s->picture_ptr; <nl>      *data_size = sizeof(AVFrame); <nl>  
@@ -451,8 +451,8 @@ static int process_ipmovie_chunk(IPMVEContext *s, AVIOContext *pb, <nl>              av_dlog(NULL, "set palette\n"); <nl>              /* check for the logical maximum palette size <nl>               * (3 * 256 + 4 bytes) */ <nl> -            if (opcode_size > 0x304) { <nl> -                av_dlog(NULL, "demux_ipmovie: set_palette opcode too large\n"); <nl> +            if (opcode_size > 0x304 || opcode_size < 4) { <nl> +                av_dlog(NULL, "demux_ipmovie: set_palette opcode with invalid size\n"); <nl>                  chunk_type = CHUNK_BAD; <nl>                  break; <nl>              }
@@ -57,14 +57,14 @@ static int ass_read_close(AVFormatContext *s) <nl>  static int read_dialogue(ASSContext *ass, AVBPrint *dst, const uint8_t *p, <nl>                           int64_t *start, int *duration) <nl>  { <nl> -    int pos; <nl> +    int pos = 0; <nl>      int64_t end; <nl>      int hh1, mm1, ss1, ms1; <nl>      int hh2, mm2, ss2, ms2; <nl>   <nl>      if (sscanf(p, "Dialogue: %*[^,],%d:%d:%d%*c%d,%d:%d:%d%*c%d,%n", <nl>                 &hh1, &mm1, &ss1, &ms1, <nl> -               &hh2, &mm2, &ss2, &ms2, &pos) >= 8) { <nl> +               &hh2, &mm2, &ss2, &ms2, &pos) >= 8 && pos > 0) { <nl>   <nl>          /* This is not part of the sscanf itself in order to handle an actual <nl>           * number (which would be the Layer) or the form "Marked=N" (which is
@@ -218,6 +218,7 @@ retry: <nl>          } <nl>          buf      = c->decomp_buf; <nl>          buf_size = c->decomp_size - FFMAX(FF_INPUT_BUFFER_PADDING_SIZE, AV_LZO_OUTPUT_PADDING) - outlen; <nl> +        memset(c->decomp_buf + buf_size, 0, FF_INPUT_BUFFER_PADDING_SIZE); <nl>      } <nl>      if (c->codec_frameheader) { <nl>          int w, h, q;
@@ -99,10 +99,10 @@ void ff_spatial_idwt_slice2(DWTContext *d, int y); <nl>      (b1 + ((int)(b0 + (unsigned)(b2) + 1) >> 1)) <nl>   <nl>  #define COMPOSE_DD97iH0(b0, b1, b2, b3, b4)\ <nl> -    (b2 + ((int)(-b0 + 9U*b1 + 9U*b3 - b4 + 8) >> 4)) <nl> +    (int)(((unsigned)(b2) + ((int)(-b0 + 9U*b1 + 9U*b3 - b4 + 8) >> 4))) <nl>   <nl>  #define COMPOSE_DD137iL0(b0, b1, b2, b3, b4)\ <nl> -    (b2 - ((int)(-b0 + 9U*b1 + 9U*b3 - b4 + 16) >> 5)) <nl> +    (int)(((unsigned)(b2) - ((int)(-b0 + 9U*b1 + 9U*b3 - b4 + 16) >> 5))) <nl>   <nl>  #define COMPOSE_HAARiL0(b0, b1)\ <nl>      (b0 - ((b1 + 1) >> 1))
@@ -83,7 +83,8 @@ void av_log_default_callback(void* ptr, int level, const char* fmt, va_list vl) <nl>  { <nl>      static int print_prefix=1; <nl>      static int count; <nl> -    static char line[1024], prev[1024]; <nl> +    static char prev[1024]; <nl> +    char line[1024]; <nl>      static int is_atty; <nl>      AVClass* avc= ptr ? *(AVClass**)ptr : NULL; <nl>      if(level>av_log_level) <nl> @@ -108,7 +109,7 @@ void av_log_default_callback(void* ptr, int level, const char* fmt, va_list vl) <nl>      if(!is_atty) is_atty= isatty(2) ? 1 : -1; <nl>  #endif <nl>   <nl> -    if(print_prefix && (flags & AV_LOG_SKIP_REPEATED) && !strcmp(line, prev)){ <nl> +    if(print_prefix && (flags & AV_LOG_SKIP_REPEATED) && !strncmp(line, prev, sizeof line)){ <nl>          count++; <nl>          if(is_atty==1) <nl>              fprintf(stderr, "    Last message repeated %d times\r", count); <nl> @@ -119,7 +120,7 @@ void av_log_default_callback(void* ptr, int level, const char* fmt, va_list vl) <nl>          count=0; <nl>      } <nl>      colored_fputs(av_clip(level>>3, 0, 6), line); <nl> -    strcpy(prev, line); <nl> +    strncpy(prev, line, sizeof line); <nl>  } <nl>   <nl>  static void (*av_log_callback)(void*, int, const char*, va_list) = av_log_default_callback;
@@ -300,7 +300,7 @@ static int buffer_needs_copy(PadContext *s, AVFrame *frame, AVBufferRef *buf) <nl>              return 1; <nl>   <nl>  #define SIGN(x) ((x) > 0 ? 1 : -1) <nl> -        for (j = 0; j < FF_ARRAY_ELEMS(planes) & planes[j] >= 0; j++) { <nl> +        for (j = 0; j < FF_ARRAY_ELEMS(planes) && planes[j] >= 0; j++) { <nl>              int hsub1 = s->draw.hsub[planes[j]]; <nl>              uint8_t *start1 = frame->data[planes[j]]; <nl>              uint8_t *end1   = start1 + (frame->height >> hsub1) *
@@ -615,8 +615,10 @@ static int find_and_decode_index(NUTContext *nut) <nl>      GET_V(syncpoint_count, tmp < INT_MAX / 8 && tmp > 0); <nl>      syncpoints   = av_malloc(sizeof(int64_t) *  syncpoint_count); <nl>      has_keyframe = av_malloc(sizeof(int8_t)  * (syncpoint_count + 1)); <nl> -    if (!syncpoints || !has_keyframe) <nl> -        return AVERROR(ENOMEM); <nl> +    if (!syncpoints || !has_keyframe) { <nl> +        ret = AVERROR(ENOMEM); <nl> +        goto fail; <nl> +    } <nl>      for (i = 0; i < syncpoint_count; i++) { <nl>          syncpoints[i] = ffio_read_varlen(bc); <nl>          if (syncpoints[i] <= 0)
@@ -36,6 +36,8 @@ static int noise(AVBitStreamFilterContext *bsfc, AVCodecContext *avctx, const ch <nl>          return AVERROR(EINVAL); <nl>   <nl>      *poutbuf= av_malloc(buf_size + FF_INPUT_BUFFER_PADDING_SIZE); <nl> +    if (!*poutbuf) <nl> +        return AVERROR(ENOMEM); <nl>   <nl>      memcpy(*poutbuf, buf, buf_size + FF_INPUT_BUFFER_PADDING_SIZE); <nl>      for(i=0; i<buf_size; i++){
@@ -105,7 +105,7 @@ static int parse_channel_expressions(AVFilterContext *ctx, <nl>  { <nl>      EvalContext *eval = ctx->priv; <nl>      char *args1 = av_strdup(eval->exprs); <nl> -    char *expr, *last_expr, *buf; <nl> +    char *expr, *last_expr = NULL, *buf; <nl>      double (* const *func1)(void *, double) = NULL; <nl>      const char * const *func1_names = NULL; <nl>      int i, ret = 0;
@@ -927,7 +927,17 @@ static int handle_p_frame_apng(AVCodecContext *avctx, PNGDecContext *s, <nl>              pd      += s->image_linesize; <nl>              pd_last += s->image_linesize; <nl>          } <nl> +    } else { <nl> +        for (j = s->y_offset; j < s->y_offset + s->cur_h; j++) { <nl> +            for (i = 0; i < s->x_offset * s->bpp; i++) <nl> +                pd[i] = pd_last[i]; <nl> +            for (i = (s->x_offset + s->cur_w) * s->bpp; i < ls; i++) <nl> +                pd[i] = pd_last[i]; <nl> +            pd      += s->image_linesize; <nl> +            pd_last += s->image_linesize; <nl> +        } <nl>      } <nl> + <nl>      for (j = s->y_offset + s->cur_h; j < s->height; j++) { <nl>          for (i = 0; i < ls; i++) <nl>              pd[i] = pd_last[i];
@@ -231,7 +231,7 @@ static int mmsh_open(URLContext *h, const char *uri, int flags) <nl>          host, sizeof(host), &port, path, sizeof(path), location); <nl>      if (port<0) <nl>          port = 80; // default mmsh protocol port <nl> -    ff_url_join(httpname, sizeof(httpname), "http", NULL, host, port, path); <nl> +    ff_url_join(httpname, sizeof(httpname), "http", NULL, host, port, "%s", path); <nl>   <nl>      if (ffurl_alloc(&mms->mms_hd, httpname, AVIO_FLAG_READ) < 0) { <nl>          return AVERROR(EIO);
@@ -221,6 +221,11 @@ static av_cold int tta_decode_init(AVCodecContext * avctx) <nl>          s->data_length = get_bits_long(&s->gb, 32); <nl>          skip_bits(&s->gb, 32); // CRC32 of header <nl>   <nl> +        if (s->channels == 0) { <nl> +            av_log(s->avctx, AV_LOG_ERROR, "Invalid number of channels\n"); <nl> +            return AVERROR_INVALIDDATA; <nl> +        } <nl> + <nl>          switch(s->bps) { <nl>          case 2: <nl>              avctx->sample_fmt = AV_SAMPLE_FMT_S16;
@@ -37,7 +37,7 @@ typedef struct DNXHDContext { <nl>      AVCodecContext *avctx; <nl>      AVFrame picture; <nl>      GetBitContext gb; <nl> -    int cid;                            ///< compression id <nl> +    int64_t cid;                        ///< compression id <nl>      unsigned int width, height; <nl>      unsigned int mb_width, mb_height; <nl>      uint32_t mb_scan_index[68];         /* max for 1080p */ <nl> @@ -71,10 +71,11 @@ static av_cold int dnxhd_decode_init(AVCodecContext *avctx) <nl>      avcodec_get_frame_defaults(&ctx->picture); <nl>      ctx->picture.type = AV_PICTURE_TYPE_I; <nl>      ctx->picture.key_frame = 1; <nl> +    ctx->cid = -1; <nl>      return 0; <nl>  } <nl>   <nl> -static int dnxhd_init_vlc(DNXHDContext *ctx, int cid) <nl> +static int dnxhd_init_vlc(DNXHDContext *ctx, uint32_t cid) <nl>  { <nl>      if (cid != ctx->cid) { <nl>          int index;
@@ -663,6 +663,8 @@ static int smka_decode_frame(AVCodecContext *avctx, void *data, <nl>          for(i = 0; i <= stereo; i++) <nl>              *samples++ = pred[i]; <nl>          for(; i < unp_size / 2; i++) { <nl> +            if(get_bits_left(&gb)<0) <nl> +                return -1; <nl>              if(i & stereo) { <nl>                  if(vlc[2].table) <nl>                      res = get_vlc2(&gb, vlc[2].table, SMKTREE_BITS, 3); <nl> @@ -697,6 +699,8 @@ static int smka_decode_frame(AVCodecContext *avctx, void *data, <nl>          for(i = 0; i <= stereo; i++) <nl>              *samples8++ = pred[i]; <nl>          for(; i < unp_size; i++) { <nl> +            if(get_bits_left(&gb)<0) <nl> +                return -1; <nl>              if(i & stereo){ <nl>                  if(vlc[1].table) <nl>                      res = get_vlc2(&gb, vlc[1].table, SMKTREE_BITS, 3);
@@ -46,6 +46,9 @@ int ff_vaapi_render_picture(struct vaapi_context *vactx, VASurfaceID surface) <nl>      VABufferID va_buffers[3]; <nl>      unsigned int n_va_buffers = 0; <nl>   <nl> +    if (!vactx->pic_param_buf_id) <nl> +        return 0; <nl> + <nl>      vaUnmapBuffer(vactx->display, vactx->pic_param_buf_id); <nl>      va_buffers[n_va_buffers++] = vactx->pic_param_buf_id; <nl>  
@@ -173,8 +173,6 @@ static av_cold void uninit(AVFilterContext *ctx) <nl>  { <nl>      MovieContext *movie = ctx->priv; <nl>   <nl> -    av_free(movie->file_name); <nl> -    av_free(movie->format_name); <nl>      if (movie->codec_ctx) <nl>          avcodec_close(movie->codec_ctx); <nl>      if (movie->format_ctx)
@@ -40,6 +40,11 @@ static int adx_read_packet(AVFormatContext *s, AVPacket *pkt) <nl>      AVCodecContext *avctx = s->streams[0]->codec; <nl>      int ret, size; <nl>   <nl> +    if (avctx->channels <= 0) { <nl> +        av_log(s, AV_LOG_ERROR, "invalid number of channels %d\n", avctx->channels); <nl> +        return AVERROR_INVALIDDATA; <nl> +    } <nl> + <nl>      size = BLOCK_SIZE * avctx->channels; <nl>   <nl>      pkt->pos = avio_tell(s->pb);
@@ -1504,8 +1504,10 @@ return_packet: <nl>      st = s->streams[pkt->stream_index]; <nl>      if (st->skip_samples) { <nl>          uint8_t *p = av_packet_new_side_data(pkt, AV_PKT_DATA_SKIP_SAMPLES, 10); <nl> -        AV_WL32(p, st->skip_samples); <nl> -        av_log(s, AV_LOG_DEBUG, "demuxer injecting skip %d\n", st->skip_samples); <nl> +        if (p) { <nl> +            AV_WL32(p, st->skip_samples); <nl> +            av_log(s, AV_LOG_DEBUG, "demuxer injecting skip %d\n", st->skip_samples); <nl> +        } <nl>          st->skip_samples = 0; <nl>      } <nl>  
@@ -405,7 +405,7 @@ static int alac_decode_frame(AVCodecContext *avctx, <nl>      ALACContext *alac = avctx->priv_data; <nl>   <nl>      int channels; <nl> -    int32_t outputsamples; <nl> +    unsigned int outputsamples; <nl>      int hassize; <nl>      int readsamplesize; <nl>      int wasted_bytes; <nl> @@ -458,6 +458,10 @@ static int alac_decode_frame(AVCodecContext *avctx, <nl>      if (hassize) { <nl>          /* now read the number of samples as a 32bit integer */ <nl>          outputsamples = get_bits(&alac->gb, 32); <nl> +        if(outputsamples > alac->setinfo_max_samples_per_frame){ <nl> +            av_log(avctx, AV_LOG_ERROR, "outputsamples %d > %d\n", outputsamples, alac->setinfo_max_samples_per_frame); <nl> +            return -1; <nl> +        } <nl>      } else <nl>          outputsamples = alac->setinfo_max_samples_per_frame; <nl>  
@@ -36,7 +36,7 @@ static int ffm_is_avail_data(AVFormatContext *s, int size) <nl>  { <nl>      FFMContext *ffm = s->priv_data; <nl>      int64_t pos, avail_size; <nl> -    int len; <nl> +    ptrdiff_t len; <nl>   <nl>      len = ffm->packet_end - ffm->packet_ptr; <nl>      if (size <= len) <nl> @@ -87,8 +87,9 @@ static int ffm_read_data(AVFormatContext *s, <nl>  { <nl>      FFMContext *ffm = s->priv_data; <nl>      AVIOContext *pb = s->pb; <nl> -    int len, fill_size, size1, frame_offset; <nl> +    int fill_size, size1, frame_offset; <nl>      uint32_t id; <nl> +    ptrdiff_t len; <nl>      int64_t last_pos = -1; <nl>   <nl>      size1 = size;
@@ -81,8 +81,8 @@ <nl>  #        define FF_DISABLE_DEPRECATION_WARNINGS __pragma(warning(push)) __pragma(warning(disable:4996)) <nl>  #        define FF_ENABLE_DEPRECATION_WARNINGS  __pragma(warning(pop)) <nl>  #    else <nl> -#        define FF_DISABLE_DEPRECATION_WARNINGS _Pragma("GCC diagnostic ignored \"-Wdeprecated-declarations\"") <nl> -#        define FF_ENABLE_DEPRECATION_WARNINGS  _Pragma("GCC diagnostic warning \"-Wdeprecated-declarations\"") <nl> +#        define FF_DISABLE_DEPRECATION_WARNINGS _Pragma("GCC diagnostic push") _Pragma("GCC diagnostic ignored \"-Wdeprecated-declarations\"") <nl> +#        define FF_ENABLE_DEPRECATION_WARNINGS  _Pragma("GCC diagnostic pop") <nl>  #    endif <nl>  #else <nl>  #    define FF_DISABLE_DEPRECATION_WARNINGS
@@ -383,6 +383,10 @@ static void celt_search_for_dual_stereo(OpusPsyContext *s, CeltFrame *f) <nl>  { <nl>      float td1, td2; <nl>      f->dual_stereo = 0; <nl> + <nl> +    if (s->avctx->channels < 2) <nl> +        return; <nl> + <nl>      bands_dist(s, f, &td1); <nl>      f->dual_stereo = 1; <nl>      bands_dist(s, f, &td2); <nl> @@ -396,6 +400,9 @@ static void celt_search_for_intensity(OpusPsyContext *s, CeltFrame *f) <nl>      int i, best_band = CELT_MAX_BANDS - 1; <nl>      float dist, best_dist = FLT_MAX; <nl>   <nl> +    if (s->avctx->channels < 2) <nl> +        return; <nl> + <nl>      /* TODO: fix, make some heuristic up here using the lambda value */ <nl>      float end_band = 0; <nl>  
@@ -251,7 +251,7 @@ static void qtrle_decode_16bpp(QtrleContext *s) <nl>      int header; <nl>      int start_line; <nl>      int lines_to_change; <nl> -    signed char rle_code; <nl> +    int rle_code; <nl>      int row_ptr, pixel_ptr; <nl>      int row_inc = s->frame.linesize[0]; <nl>      unsigned short rgb16; <nl> @@ -329,7 +329,7 @@ static void qtrle_decode_24bpp(QtrleContext *s) <nl>      int header; <nl>      int start_line; <nl>      int lines_to_change; <nl> -    signed char rle_code; <nl> +    int rle_code; <nl>      int row_ptr, pixel_ptr; <nl>      int row_inc = s->frame.linesize[0]; <nl>      unsigned char r, g, b; <nl> @@ -408,7 +408,7 @@ static void qtrle_decode_32bpp(QtrleContext *s) <nl>      int header; <nl>      int start_line; <nl>      int lines_to_change; <nl> -    signed char rle_code; <nl> +    int rle_code; <nl>      int row_ptr, pixel_ptr; <nl>      int row_inc = s->frame.linesize[0]; <nl>      unsigned char r, g, b;
@@ -801,7 +801,13 @@ static int flv_read_packet(AVFormatContext *s, AVPacket *pkt) <nl>                             type, size, flags); <nl>   <nl>  skip: <nl> -            avio_seek(s->pb, next, SEEK_SET); <nl> +            if (avio_seek(s->pb, next, SEEK_SET) != next) { <nl> +                // This can happen if flv_read_metabody above read past <nl> +                // next, on a non-seekable input, and the preceding data has <nl> +                // been flushed out from the IO buffer. <nl> +                av_log(s, AV_LOG_ERROR, "Unable to seek to the next packet\n"); <nl> +                return AVERROR_INVALIDDATA; <nl> +            } <nl>              continue; <nl>          } <nl>  
@@ -1841,12 +1841,12 @@ int av_find_stream_info(AVFormatContext *ic) <nl>              if(st->codec.codec_id == CODEC_ID_RAWVIDEO && !st->codec.codec_tag && !st->codec.bits_per_sample) <nl>                  st->codec.codec_tag= avcodec_pix_fmt_to_codec_tag(st->codec.pix_fmt); <nl>   <nl> -            if(best_duration[i] < INT64_MAX && st->codec.time_base.num*1000 <= st->codec.time_base.den){ <nl> +            if(best_duration[i] < INT64_MAX && st->codec.time_base.num*1000 <= st->codec.time_base.den && <nl> +               st->time_base.num*best_duration[i]*1000LL > st->time_base.den){ <nl>                  int int_fps; <nl>   <nl>                  st->r_frame_rate.num= st->time_base.den; <nl>                  st->r_frame_rate.den= st->time_base.num*best_duration[i]; <nl> -                av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den, st->r_frame_rate.num, st->r_frame_rate.den, 1<<15); <nl>                   <nl>                  int_fps= av_rescale(st->r_frame_rate.num, 1, st->r_frame_rate.den); // 1/0 <nl>                  
@@ -2628,7 +2628,10 @@ static int decode_frame(AVCodecContext * avctx, <nl>              } <nl>  	    s->inbuf_ptr = s->inbuf; <nl>  	    s->frame_size = 0; <nl> -	    *data_size = out_size; <nl> +            if(out_size>=0) <nl> +	        *data_size = out_size; <nl> +            else <nl> +                av_log(avctx, AV_LOG_DEBUG, "Error while decoding mpeg audio frame\n"); //FIXME return -1 / but also return the number of bytes consumed <nl>  	    break; <nl>  	} <nl>      }
@@ -94,7 +94,7 @@ typedef struct Indeo3DecodeContext { <nl>   <nl>      int16_t         width, height; <nl>      uint32_t        frame_num;      ///< current frame number (zero-based) <nl> -    uint32_t        data_size;      ///< size of the frame data in bytes <nl> +    int             data_size;      ///< size of the frame data in bytes <nl>      uint16_t        frame_flags;    ///< frame properties <nl>      uint8_t         cb_offset;      ///< needed for selecting VQ tables <nl>      uint8_t         buf_sel;        ///< active frame buffer: 0 - primary, 1 -secondary <nl> @@ -899,7 +899,8 @@ static int decode_frame_headers(Indeo3DecodeContext *ctx, AVCodecContext *avctx, <nl>      GetByteContext gb; <nl>      const uint8_t   *bs_hdr; <nl>      uint32_t        frame_num, word2, check_sum, data_size; <nl> -    uint32_t        y_offset, u_offset, v_offset, starts[3], ends[3]; <nl> +    int             y_offset, u_offset, v_offset; <nl> +    uint32_t        starts[3], ends[3]; <nl>      uint16_t        height, width; <nl>      int             i, j; <nl>  
@@ -232,8 +232,8 @@ void Process(void *ctx, AVPicture *picture, enum PixelFormat pix_fmt, int width, <nl>      AVPicture picture1; <nl>      AVPicture picture2; <nl>      AVPicture *pict = picture; <nl> -    int out_width; <nl> -    int out_height; <nl> +    int av_uninit(out_width); <nl> +    int av_uninit(out_height); <nl>      int i; <nl>      uint8_t *ptr = NULL; <nl>      FILE *in = rwpipe_reader( ci->rw );
@@ -104,7 +104,7 @@ static VLC_TYPE vlc_tables[VLC_TABLES_SIZE][2]; <nl>   <nl>  static av_cold int imc_decode_init(AVCodecContext * avctx) <nl>  { <nl> -    int i, j; <nl> +    int i, j, ret; <nl>      IMCContext *q = avctx->priv_data; <nl>      double r1, r2; <nl>   <nl> @@ -156,7 +156,10 @@ static av_cold int imc_decode_init(AVCodecContext * avctx) <nl>      } <nl>      q->one_div_log2 = 1/log(2); <nl>   <nl> -    ff_fft_init(&q->fft, 7, 1); <nl> +    if ((ret = ff_fft_init(&q->fft, 7, 1))) { <nl> +        av_log(avctx, AV_LOG_INFO, "FFT init failed\n"); <nl> +        return ret; <nl> +    } <nl>      dsputil_init(&q->dsp, avctx); <nl>      avctx->sample_fmt = AV_SAMPLE_FMT_FLT; <nl>      avctx->channel_layout = (avctx->channels==2) ? AV_CH_LAYOUT_STEREO : AV_CH_LAYOUT_MONO;
@@ -634,9 +634,6 @@ static int init_input(AVFormatContext *s, const char *filename, AVDictionary **o <nl>      int ret; <nl>      AVProbeData pd = {filename, NULL, 0}; <nl>   <nl> -    if(s->iformat && !strlen(filename)) <nl> -        return 0; <nl> - <nl>      if (s->pb) { <nl>          s->flags |= AVFMT_FLAG_CUSTOM_IO; <nl>          if (!s->iformat)
@@ -91,10 +91,10 @@ static int64_t wrap_timestamp(AVStream *st, int64_t timestamp) <nl>          st->pts_wrap_reference != AV_NOPTS_VALUE && timestamp != AV_NOPTS_VALUE) { <nl>          if (st->pts_wrap_behavior == AV_PTS_WRAP_ADD_OFFSET && <nl>              timestamp < st->pts_wrap_reference) <nl> -            return timestamp + (1LL<<st->pts_wrap_bits); <nl> +            return timestamp + (1ULL<<st->pts_wrap_bits); <nl>          else if (st->pts_wrap_behavior == AV_PTS_WRAP_SUB_OFFSET && <nl>              timestamp >= st->pts_wrap_reference) <nl> -            return timestamp - (1LL<<st->pts_wrap_bits); <nl> +            return timestamp - (1ULL<<st->pts_wrap_bits); <nl>      } <nl>      return timestamp; <nl>  } <nl> @@ -925,7 +925,7 @@ static AVPacketList *get_next_pkt(AVFormatContext *s, AVStream *st, AVPacketList <nl>   <nl>  static int update_wrap_reference(AVFormatContext *s, AVStream *st, int stream_index) <nl>  { <nl> -    if (s->correct_ts_overflow && st->pts_wrap_bits != 64 && <nl> +    if (s->correct_ts_overflow && st->pts_wrap_bits < 63 && <nl>          st->pts_wrap_reference == AV_NOPTS_VALUE && st->first_dts != AV_NOPTS_VALUE) { <nl>          int i; <nl>  
@@ -817,7 +817,6 @@ retry: <nl>      return psize; <nl>  fail: <nl>      av_free_packet(pkt); <nl> -    av_free(pkt); <nl>      return AVERROR(ENOMEM); <nl>  } <nl>  
@@ -226,7 +226,7 @@ static void png_filter_row(PNGDSPContext *dsp, uint8_t *dst, int filter_type, <nl>          if (bpp == 4) { <nl>              p = *(int*)dst; <nl>              for (; i < size; i += bpp) { <nl> -                int s = *(int*)(src + i); <nl> +                unsigned s = *(int*)(src + i); <nl>                  p = ((s & 0x7f7f7f7f) + (p & 0x7f7f7f7f)) ^ ((s ^ p) & 0x80808080); <nl>                  *(int*)(dst + i) = p; <nl>              }
@@ -24,7 +24,8 @@ ERROR <nl>  #endif <nl>   <nl>  void RENAME(swri_noise_shaping)(SwrContext *s, AudioData *dsts, const AudioData *srcs, const AudioData *noises, int count){ <nl> -    int i, j, pos, ch; <nl> +    int pos = s->dither.ns_pos; <nl> +    int i, j, ch; <nl>      int taps  = s->dither.ns_taps; <nl>      float S   = s->dither.ns_scale; <nl>      float S_1 = s->dither.ns_scale_1;
@@ -232,7 +232,7 @@ static int jacosub_read_header(AVFormatContext *s) <nl>      /* general/essential directives in the extradata */ <nl>      ret = avpriv_bprint_to_extradata(st->codec, &header); <nl>      if (ret < 0) <nl> -        return ret; <nl> +        goto fail; <nl>   <nl>      /* SHIFT and TIMERES affect the whole script so packet timing can only be <nl>       * done in a second pass */ <nl> @@ -243,6 +243,9 @@ static int jacosub_read_header(AVFormatContext *s) <nl>      ff_subtitles_queue_finalize(&jacosub->q); <nl>   <nl>      return 0; <nl> +fail: <nl> +    jacosub_read_close(s); <nl> +    return ret; <nl>  } <nl>   <nl>  static int jacosub_read_packet(AVFormatContext *s, AVPacket *pkt)
@@ -326,6 +326,10 @@ static int lag_decode_zero_run_line(LagarithContext *l, uint8_t *dst, <nl>  output_zeros: <nl>      if (l->zeros_rem) { <nl>          count = FFMIN(l->zeros_rem, width - i); <nl> +        if(end - dst < count) { <nl> +            av_log(l->avctx, AV_LOG_ERROR, "too many zeros remaining\n"); <nl> +            return AVERROR_INVALIDDATA; <nl> +        } <nl>          memset(dst, 0, count); <nl>          l->zeros_rem -= count; <nl>          dst += count;
@@ -254,8 +254,10 @@ static int rpl_read_header(AVFormatContext *s) <nl>          int64_t offset, video_size, audio_size; <nl>          error |= read_line(pb, line, sizeof(line)); <nl>          if (3 != sscanf(line, "%"SCNd64" , %"SCNd64" ; %"SCNd64, <nl> -                        &offset, &video_size, &audio_size)) <nl> +                        &offset, &video_size, &audio_size)) { <nl>              error = -1; <nl> +            continue; <nl> +        } <nl>          av_add_index_entry(vst, offset, i * rpl->frames_per_chunk, <nl>                             video_size, rpl->frames_per_chunk, 0); <nl>          if (ast)
@@ -1043,7 +1043,7 @@ static int apply_color_indexing_transform(WebPContext *s) <nl>          uint8_t *line; <nl>          int pixel_bits = 8 >> pal->size_reduction; <nl>   <nl> -        line = av_malloc(img->frame->linesize[0]); <nl> +        line = av_malloc(img->frame->linesize[0] + AV_INPUT_BUFFER_PADDING_SIZE); <nl>          if (!line) <nl>              return AVERROR(ENOMEM); <nl>  
@@ -2611,6 +2611,8 @@ static int aac_decode_frame_int(AVCodecContext *avctx, void *data, <nl>   <nl>      if (samples) <nl>          ac->frame->nb_samples = samples; <nl> +    else <nl> +        av_frame_unref(ac->frame); <nl>      *got_frame_ptr = !!samples; <nl>   <nl>      if (is_dmono) {
@@ -2070,7 +2070,7 @@ static int mxf_set_audio_pts(MXFContext *mxf, AVCodecContext *codec, AVPacket *p <nl>      pkt->pts = track->sample_count; <nl>      if (codec->channels <= 0 || av_get_bits_per_sample(codec->codec_id) <= 0) <nl>          return AVERROR(EINVAL); <nl> -    track->sample_count += pkt->size / (codec->channels * av_get_bits_per_sample(codec->codec_id) / 8); <nl> +    track->sample_count += pkt->size / (codec->channels * (int64_t)av_get_bits_per_sample(codec->codec_id) / 8); <nl>      return 0; <nl>  } <nl>  
@@ -76,7 +76,7 @@ static av_cold int escape124_decode_close(AVCodecContext *avctx) <nl>      Escape124Context *s = avctx->priv_data; <nl>   <nl>      for (i = 0; i < 3; i++) <nl> -        av_free(s->codebooks[i].blocks); <nl> +        av_freep(&s->codebooks[i].blocks); <nl>   <nl>      av_frame_free(&s->frame); <nl>   <nl> @@ -263,7 +263,7 @@ static int escape124_decode_frame(AVCodecContext *avctx, <nl>                      cb_size = s->num_superblocks << cb_depth; <nl>                  } <nl>              } <nl> -            av_free(s->codebooks[i].blocks); <nl> +            av_freep(&s->codebooks[i].blocks); <nl>              s->codebooks[i] = unpack_codebook(&gb, cb_depth, cb_size); <nl>              if (!s->codebooks[i].blocks) <nl>                  return -1;
@@ -512,9 +512,9 @@ static int encode_frame(AVCodecContext *avctx, AVPacket *pkt, <nl>      ret         = 0; <nl>   <nl>  the_end: <nl> -    av_free(crow_base); <nl> -    av_free(progressive_buf); <nl> -    av_free(top_buf); <nl> +    av_freep(&crow_base); <nl> +    av_freep(&progressive_buf); <nl> +    av_freep(&top_buf); <nl>      deflateEnd(&s->zstream); <nl>      return ret; <nl>  fail:
@@ -2482,7 +2482,7 @@ static int wavpack_encode_block(WavPackEncodeContext *s, <nl>                                  uint8_t *out, int out_size) <nl>  { <nl>      int block_size, start, end, data_size, tcount, temp, m = 0; <nl> -    int i, j, ret, got_extra = 0, nb_samples = s->block_samples; <nl> +    int i, j, ret = 0, got_extra = 0, nb_samples = s->block_samples; <nl>      uint32_t crc = 0xffffffffu; <nl>      struct Decorr *dpp; <nl>      PutByteContext pb;
@@ -887,12 +887,11 @@ static int update_wrap_reference(AVFormatContext *s, AVStream *st, int stream_in <nl>   <nl>      if (ref == AV_NOPTS_VALUE) <nl>          ref = pkt->pts; <nl> -    if (ref == AV_NOPTS_VALUE) <nl> +    if (st->pts_wrap_reference != AV_NOPTS_VALUE || st->pts_wrap_bits >= 63 || ref == AV_NOPTS_VALUE || !s->correct_ts_overflow) <nl>          return 0; <nl>      ref &= (1LL<<st->pts_wrap_bits)-1; <nl>   <nl> -    if (s->correct_ts_overflow && st->pts_wrap_bits < 63 && <nl> -        st->pts_wrap_reference == AV_NOPTS_VALUE) { <nl> +    { <nl>          int i; <nl>   <nl>          // reference time stamp should be 60 s before first time stamp <nl> @@ -945,7 +944,6 @@ static int update_wrap_reference(AVFormatContext *s, AVStream *st, int stream_in <nl>          } <nl>          return 1; <nl>      } <nl> -    return 0; <nl>  } <nl>   <nl>  static void update_initial_timestamps(AVFormatContext *s, int stream_index,
@@ -1137,7 +1137,7 @@ static int ljpeg_decode_yuv_scan(MJpegDecodeContext *s, int predictor, <nl>                          if (s->interlaced && s->bottom_field) <nl>                              ptr += linesize >> 1; <nl>                          pred &= mask; <nl> -                        *ptr= pred + (dc << point_transform); <nl> +                        *ptr= pred + ((unsigned)dc << point_transform); <nl>                          }else{ <nl>                              ptr16 = (uint16_t*)(s->picture_ptr->data[c] + 2*(linesize * (v * mb_y + y)) + 2*(h * mb_x + x)); //FIXME optimize this crap <nl>                              if(y==0 && toprow){
@@ -1830,7 +1830,7 @@ static void mov_build_index(MOVContext *mov, AVStream *st) <nl>   <nl>          current_dts -= sc->dts_shift; <nl>   <nl> -        if (!sc->sample_count) <nl> +        if (!sc->sample_count || st->nb_index_entries) <nl>              return; <nl>          if (sc->sample_count >= UINT_MAX / sizeof(*st->index_entries)) <nl>              return;
@@ -392,9 +392,12 @@ static int iec61883_read_header(AVFormatContext *context) <nl>   <nl>  #if THREADS <nl>      dv->thread_loop = 1; <nl> -    pthread_mutex_init(&dv->mutex, NULL); <nl> -    pthread_cond_init(&dv->cond, NULL); <nl> -    pthread_create(&dv->receive_task_thread, NULL, iec61883_receive_task, dv); <nl> +    if (pthread_mutex_init(&dv->mutex, NULL)) <nl> +        goto fail; <nl> +    if (pthread_cond_init(&dv->cond, NULL)) <nl> +        goto fail; <nl> +    if (pthread_create(&dv->receive_task_thread, NULL, iec61883_receive_task, dv)) <nl> +        goto fail; <nl>  #endif <nl>   <nl>      return 0;
@@ -306,8 +306,10 @@ static int qsv_decode(AVCodecContext *avctx, QSVContext *q, <nl>   <nl>      do { <nl>          ret = get_surface(avctx, q, &insurf); <nl> -        if (ret < 0) <nl> +        if (ret < 0) { <nl> +            av_freep(&sync); <nl>              return ret; <nl> +        } <nl>   <nl>          ret = MFXVideoDECODE_DecodeFrameAsync(q->session, avpkt->size ? &bs : NULL, <nl>                                                insurf, &outsurf, sync);
@@ -41,8 +41,6 @@ int avpriv_dca_convert_bitstream(const uint8_t *src, int src_size, uint8_t *dst, <nl>  { <nl>      uint32_t mrk; <nl>      int i, tmp; <nl> -    const uint16_t *ssrc = (const uint16_t *) src; <nl> -    uint16_t *sdst = (uint16_t *) dst; <nl>      PutBitContext pb; <nl>   <nl>      if ((unsigned) src_size > (unsigned) max_size) <nl> @@ -54,8 +52,11 @@ int avpriv_dca_convert_bitstream(const uint8_t *src, int src_size, uint8_t *dst, <nl>          memcpy(dst, src, src_size); <nl>          return src_size; <nl>      case DCA_SYNCWORD_CORE_LE: <nl> -        for (i = 0; i < (src_size + 1) >> 1; i++) <nl> -            *sdst++ = av_bswap16(*ssrc++); <nl> +        for (i = 0; i < (src_size + 1) >> 1; i++) { <nl> +            AV_WB16(dst, AV_RL16(src)); <nl> +            src += 2; <nl> +            dst += 2; <nl> +        } <nl>          return src_size; <nl>      case DCA_SYNCWORD_CORE_14B_BE: <nl>      case DCA_SYNCWORD_CORE_14B_LE:
@@ -131,6 +131,9 @@ int ff_ac3_bit_alloc_calc_mask(AC3BitAllocParameters *s, int16_t *band_psd, <nl>      int band_start, band_end, begin, end1; <nl>      int lowcomp, fastleak, slowleak; <nl>   <nl> +    if (end <= 0) <nl> +        return AVERROR_INVALIDDATA; <nl> + <nl>      /* excitation function */ <nl>      band_start = ff_ac3_bin_to_band_tab[start]; <nl>      band_end   = ff_ac3_bin_to_band_tab[end-1] + 1;
@@ -1051,7 +1051,7 @@ static void FUNC(put_hevc_qpel_bi_w_hv)(uint8_t *_dst, ptrdiff_t _dststride, uin <nl>      for (y = 0; y < height; y++) { <nl>          for (x = 0; x < width; x++) <nl>              dst[x] = av_clip_pixel(((QPEL_FILTER(tmp, MAX_PB_SIZE) >> 6) * wx1 + src2[x] * wx0 + <nl> -                                    ((ox0 + ox1 + 1) << log2Wd)) >> (log2Wd + 1)); <nl> +                                    ((ox0 + ox1 + 1) * (1 << log2Wd))) >> (log2Wd + 1)); <nl>          tmp  += MAX_PB_SIZE; <nl>          dst  += dststride; <nl>          src2 += MAX_PB_SIZE;
@@ -671,6 +671,7 @@ static int avi_read_header(AVFormatContext *s) <nl>                  codec_type = AVMEDIA_TYPE_VIDEO; <nl>   <nl>                  ast->sample_size = 0; <nl> +                st->avg_frame_rate = av_inv_q(st->time_base); <nl>                  break; <nl>              case MKTAG('a', 'u', 'd', 's'): <nl>                  codec_type = AVMEDIA_TYPE_AUDIO;
@@ -253,6 +253,7 @@ static int spdif_write_packet(struct AVFormatContext *s, AVPacket *pkt) <nl>      IEC958Context *ctx = s->priv_data; <nl>      int ret, padding; <nl>   <nl> +    ctx->out_buf = pkt->data; <nl>      ctx->out_bytes = pkt->size; <nl>      ctx->length_code = FFALIGN(pkt->size, 2) << 3; <nl>  
@@ -410,7 +410,7 @@ static inline void dv_decode_video_segment(DVVideoContext *s, <nl>              if (DV_PROFILE_IS_HD(s->sys)) { <nl>                  mb->idct_put = s->idct_put[0]; <nl>                  mb->scan_table = s->dv_zigzag[0]; <nl> -                mb->factor_table = s->dv100_idct_factor[((s->sys->height == 720)<<1)&(j < 4)][class1][quant]; <nl> +                mb->factor_table = s->dv100_idct_factor[((s->sys->height == 720)<<1)|(j >= 4)][class1][quant]; <nl>                  is_field_mode[mb_index] |= !j && dct_mode; <nl>              } else { <nl>                  mb->idct_put = s->idct_put[dct_mode && log2_blocksize==3];
@@ -230,14 +230,14 @@ int main(void) <nl>          if (check(root) > 999) { <nl>              av_log(NULL, AV_LOG_ERROR, "FATAL error %d\n", i); <nl>              print(root, 0); <nl> -            return -1; <nl> +            return 1; <nl>          } <nl>   <nl>          if (!node) <nl>              node = av_tree_node_alloc(); <nl>          if (!node) { <nl>              av_log(NULL, AV_LOG_ERROR, "Memory allocation failure.\n"); <nl> -            return AVERROR(ENOMEM); <nl> +            return 1; <nl>          } <nl>          av_tree_insert(&root, jj, cmp, &node); <nl>  
@@ -651,7 +651,7 @@ static av_cold void nvenc_setup_rate_control(AVCodecContext *avctx) <nl>   <nl>      if (ctx->flags & NVENC_LOSSLESS) { <nl>          set_lossless(avctx); <nl> -    } else if (ctx->rc > 0) { <nl> +    } else if (ctx->rc >= 0) { <nl>          nvenc_override_rate_control(avctx); <nl>      } else { <nl>          ctx->encode_config.rcParams.rateControlMode = NV_ENC_PARAMS_RC_VBR;
@@ -475,8 +475,8 @@ static int dv_decode_video_segment(AVCodecContext *avctx, void *arg) <nl>      GetBitContext gb; <nl>      BlockInfo mb_data[5 * DV_MAX_BPM], *mb, *mb1; <nl>      LOCAL_ALIGNED_16(DCTELEM, sblock, [5*DV_MAX_BPM], [64]); <nl> -    LOCAL_ALIGNED_16(uint8_t, mb_bit_buffer, [80 + 4]); /* allow some slack */ <nl> -    LOCAL_ALIGNED_16(uint8_t, vs_bit_buffer, [5 * 80 + 4]); /* allow some slack */ <nl> +    LOCAL_ALIGNED_16(uint8_t, mb_bit_buffer, [  80 + FF_INPUT_BUFFER_PADDING_SIZE]); /* allow some slack */ <nl> +    LOCAL_ALIGNED_16(uint8_t, vs_bit_buffer, [5*80 + FF_INPUT_BUFFER_PADDING_SIZE]); /* allow some slack */ <nl>      const int log2_blocksize = 3-s->avctx->lowres; <nl>      int is_field_mode[5]; <nl>   <nl> @@ -543,6 +543,7 @@ static int dv_decode_video_segment(AVCodecContext *avctx, void *arg) <nl>          block = block1; <nl>          mb    = mb1; <nl>          init_get_bits(&gb, mb_bit_buffer, put_bits_count(&pb)); <nl> +        put_bits32(&pb, 0); // padding must be zero'ed <nl>          flush_put_bits(&pb); <nl>          for (j = 0; j < s->sys->bpm; j++, block += 64, mb++) { <nl>              if (mb->pos < 64 && get_bits_left(&gb) > 0) { <nl> @@ -563,6 +564,7 @@ static int dv_decode_video_segment(AVCodecContext *avctx, void *arg) <nl>      block = &sblock[0][0]; <nl>      mb    = mb_data; <nl>      init_get_bits(&gb, vs_bit_buffer, put_bits_count(&vs_pb)); <nl> +    put_bits32(&vs_pb, 0); // padding must be zero'ed <nl>      flush_put_bits(&vs_pb); <nl>      for (mb_index = 0; mb_index < 5; mb_index++) { <nl>          for (j = 0; j < s->sys->bpm; j++) {
@@ -423,7 +423,7 @@ static int ffm2_read_header(AVFormatContext *s) <nl>              } <nl>              break; <nl>          case MKBETAG('S', '2', 'V', 'I'): <nl> -            if (f_stvi++) { <nl> +            if (f_stvi++ || !size) { <nl>                  ret = AVERROR(EINVAL); <nl>                  goto fail; <nl>              } <nl> @@ -438,7 +438,7 @@ static int ffm2_read_header(AVFormatContext *s) <nl>                  goto fail; <nl>              break; <nl>          case MKBETAG('S', '2', 'A', 'U'): <nl> -            if (f_stau++) { <nl> +            if (f_stau++ || !size) { <nl>                  ret = AVERROR(EINVAL); <nl>                  goto fail; <nl>              }
@@ -652,6 +652,8 @@ static int asf_write_header(AVFormatContext *s) <nl>      asf->nb_packets = 0; <nl>   <nl>      asf->index_ptr             = av_malloc(sizeof(ASFIndex) * ASF_INDEX_BLOCK); <nl> +    if (!asf->index_ptr) <nl> +        return AVERROR(ENOMEM); <nl>      asf->nb_index_memory_alloc = ASF_INDEX_BLOCK; <nl>      asf->maximum_packet        = 0; <nl>  
@@ -437,7 +437,9 @@ static int request_frame(AVFilterLink *outlink) <nl>          ret = calc_active_inputs(s); <nl>          if (ret < 0) <nl>              return ret; <nl> +    } <nl>   <nl> +    if (s->active_inputs > 1) { <nl>          available_samples = get_available_samples(s); <nl>          if (!available_samples) <nl>              return AVERROR(EAGAIN);
@@ -247,7 +247,7 @@ static void read_tree(GetBitContext *gb, Tree *tree) <nl>              tree->syms[i] = get_bits(gb, 4); <nl>              tmp1[tree->syms[i]] = 1; <nl>          } <nl> -        for (i = 0; i < 16; i++) <nl> +        for (i = 0; i < 16 && len < 16 - 1; i++) <nl>              if (!tmp1[i]) <nl>                  tree->syms[++len] = i; <nl>      } else {
@@ -77,7 +77,7 @@ typedef struct XMVAudioPacket { <nl>      uint16_t bits_per_sample; ///< Bits per compressed sample. <nl>      uint32_t bit_rate;        ///< Bits of compressed data per second. <nl>      uint16_t flags;           ///< Flags <nl> -    uint16_t block_align;     ///< Bytes per compressed block. <nl> +    unsigned block_align;     ///< Bytes per compressed block. <nl>      uint16_t block_samples;   ///< Decompressed samples per compressed block. <nl>   <nl>      enum AVCodecID codec_id; ///< The codec ID of the compression scheme.
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: mdoc_validate.c,v 1.167 2014/10/11 21:14:11 schwarze Exp $ */ <nl> +/*	$OpenBSD: mdoc_validate.c,v 1.168 2014/10/11 21:33:58 schwarze Exp $ */ <nl>  /* <nl>   * Copyright (c) 2008-2012 Kristaps Dzonsons <kristaps@bsd.lv> <nl>   * Copyright (c) 2010-2014 Ingo Schwarze <schwarze@openbsd.org> <nl> @@ -1029,7 +1029,7 @@ post_fo(POST_ARGS) <nl>   <nl>  	hwarn_eq1(mdoc); <nl>  	bwarn_ge1(mdoc); <nl> -	if (mdoc->last->type == MDOC_HEAD) <nl> +	if (mdoc->last->type == MDOC_HEAD && mdoc->last->nchild) <nl>  		post_fname(mdoc); <nl>  	return(1); <nl>  }
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: log.c,v 1.24 2005/07/27 15:45:44 xsa Exp $	*/ <nl> +/*	$OpenBSD: log.c,v 1.25 2005/08/05 16:21:41 xsa Exp $	*/ <nl>  /* <nl>   * Copyright (c) 2004 Jean-Francois Brousseau <jfb@openbsd.org> <nl>   * All rights reserved. <nl> @@ -203,7 +203,7 @@ int <nl>  cvs_vlog(u_int level, const char *fmt, va_list vap) <nl>  { <nl>  	int ecp; <nl> -	char prefix[64], buf[1024], ebuf[32]; <nl> +	char prefix[64], buf[1024], ebuf[255]; <nl>  	FILE *out; <nl>  	struct cvs_cmd *cmdp; <nl>  
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: vmm.c,v 1.34 2016/07/29 16:36:51 stefan Exp $	*/ <nl> +/*	$OpenBSD: vmm.c,v 1.35 2016/08/01 16:32:10 stefan Exp $	*/ <nl>   <nl>  /* <nl>   * Copyright (c) 2015 Mike Larkin <mlarkin@openbsd.org> <nl> @@ -529,7 +529,7 @@ start_vm(struct imsg *imsg, uint32_t *id) <nl>  		return (0); <nl>  	} else { <nl>  		/* Child */ <nl> -		setproctitle(vcp->vcp_name); <nl> +		setproctitle("%s", vcp->vcp_name); <nl>  		log_procinit(vcp->vcp_name); <nl>   <nl>  		create_memory_map(vcp);
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: ibus.c,v 1.6 2006/07/20 19:08:15 miod Exp $	*/ <nl> +/*	$OpenBSD: ibus.c,v 1.7 2006/07/20 19:52:08 miod Exp $	*/ <nl>  /*	$NetBSD: ibus.c,v 1.7 2001/02/04 20:36:32 ragge Exp $ */ <nl>  /* <nl>   * Copyright (c) 1999 Ludd, University of Lule}, Sweden. <nl> @@ -57,7 +57,7 @@ ibus_print(void *aux, const char *name) <nl>  	struct bp_conf *bp = aux; <nl>   <nl>  	if (name) <nl> -		printf("device %s at %s", bp->type, name); <nl> +		printf("%s at %s", bp->type, name); <nl>   <nl>  	return (UNCONF); <nl>  }
@@ -1,5 +1,5 @@ <nl> -/*	$Id: aldap.c,v 1.22 2010/02/07 13:04:25 blambert Exp $ */ <nl> -/*	$OpenBSD: aldap.c,v 1.22 2010/02/07 13:04:25 blambert Exp $ */ <nl> +/*	$Id: aldap.c,v 1.23 2010/04/28 10:05:28 jasper Exp $ */ <nl> +/*	$OpenBSD: aldap.c,v 1.23 2010/04/28 10:05:28 jasper Exp $ */ <nl>   <nl>  /* <nl>   * Copyright (c) 2008 Alexander Schrijver <aschrijver@openbsd.org> <nl> @@ -546,6 +546,7 @@ aldap_parse_url(char *url, struct aldap_url *lu) <nl>  	if (p) <nl>  		lu->filter = p; <nl>  done: <nl> +	free(url); <nl>  	return (1); <nl>  fail: <nl>  	free(lu->buffer);
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: kern_exec.c,v 1.34 1999/11/05 01:18:01 mickey Exp $	*/ <nl> +/*	$OpenBSD: kern_exec.c,v 1.35 2000/01/19 23:03:04 deraadt Exp $	*/ <nl>  /*	$NetBSD: kern_exec.c,v 1.75 1996/02/09 18:59:28 christos Exp $	*/ <nl>   <nl>  /*- <nl> @@ -521,7 +521,8 @@ sys_execve(p, v, retval) <nl>   <nl>  			flags = FREAD | (i == 0 ? 0 : FWRITE); <nl>   <nl> -			if (p->p_fd->fd_ofiles[i] == NULL) { <nl> +			if (i < p->p_fd->fd_nfiles || <nl> +			    p->p_fd->fd_ofiles[i] == NULL) { <nl>  				if ((error = falloc(p, &fp, &indx)) != 0) <nl>  					continue; <nl>  				NDINIT(&nd, LOOKUP, FOLLOW, UIO_SYSSPACE,
@@ -1,4 +1,4 @@ <nl> -/* $OpenBSD: message.c,v 1.78 2004/06/14 09:55:41 ho Exp $	 */ <nl> +/* $OpenBSD: message.c,v 1.79 2004/06/14 10:04:22 hshoexer Exp $	 */ <nl>  /* $EOM: message.c,v 1.156 2000/10/10 12:36:39 provos Exp $	 */ <nl>   <nl>  /* <nl> @@ -515,6 +515,7 @@ message_validate_delete(struct message *msg, struct payload *p) <nl>  	/* Only accept authenticated DELETEs. */ <nl>  	if ((msg->flags & MSG_AUTHENTICATED) == 0) { <nl>  		log_print("message_validate_delete: got unauthenticated DELETE"); <nl> +		message_free(msg); <nl>  		return -1; <nl>  	} <nl>  
@@ -1,4 +1,4 @@ <nl> -/* $OpenBSD: http_main.c,v 1.19 2002/07/20 10:38:25 henning Exp $ */ <nl> +/* $OpenBSD: http_main.c,v 1.20 2002/07/22 18:25:31 henning Exp $ */ <nl>   <nl>  /* ==================================================================== <nl>   * The Apache Software License, Version 1.1 <nl> @@ -5189,7 +5189,7 @@ static void standalone_main(int argc, char **argv) <nl>  	ap_init_modules(pconf, server_conf); <nl>  	version_locked++;	/* no more changes to server_version */ <nl>   <nl> -	if(!is_graceful) <nl> +	if(!is_graceful && !is_chrooted) <nl>  	    if (ap_server_chroot) { <nl>  		if (geteuid()) { <nl>  		    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_EMERG, 
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: vacation.c,v 1.9 1998/02/07 02:47:21 millert Exp $	*/ <nl> +/*	$OpenBSD: vacation.c,v 1.10 1998/07/08 21:39:08 deraadt Exp $	*/ <nl>  /*	$NetBSD: vacation.c,v 1.7 1995/04/29 05:58:27 cgd Exp $	*/ <nl>   <nl>  /* <nl> @@ -44,7 +44,7 @@ static char copyright[] = <nl>  #if 0 <nl>  static char sccsid[] = "@(#)vacation.c	8.2 (Berkeley) 1/26/94"; <nl>  #endif <nl> -static char rcsid[] = "$OpenBSD: vacation.c,v 1.9 1998/02/07 02:47:21 millert Exp $"; <nl> +static char rcsid[] = "$OpenBSD: vacation.c,v 1.10 1998/07/08 21:39:08 deraadt Exp $"; <nl>  #endif /* not lint */ <nl>   <nl>  /* <nl> @@ -426,7 +426,7 @@ sendmessage(myname) <nl>  		dup2(pvect[0], 0); <nl>  		close(pvect[0]); <nl>  		close(pvect[1]); <nl> -		fclose(mfp); <nl> +		close(fileno(mfp)); <nl>  		execl(_PATH_SENDMAIL, "sendmail", "-f", myname, "--", <nl>  		    from, NULL); <nl>  		syslog(LOG_ERR, "vacation: can't exec %s: %m", _PATH_SENDMAIL);
@@ -1,4 +1,4 @@ <nl> -/* $OpenBSD: acpi.c,v 1.128 2009/02/04 20:09:03 kettenis Exp $ */ <nl> +/* $OpenBSD: acpi.c,v 1.129 2009/02/10 02:13:19 jordan Exp $ */ <nl>  /* <nl>   * Copyright (c) 2005 Thorsten Lockert <tholo@sigmasoft.com> <nl>   * Copyright (c) 2005 Jordan Hargrave <jordan@openbsd.org> <nl> @@ -1658,7 +1658,7 @@ acpi_enter_sleep_state(struct acpi_softc *sc, int state) <nl>  	u_int16_t rega, regb; <nl>  	int retries; <nl>   <nl> -	if (state == ACPI_STATE_S0) <nl> +	if (sc == NULL || state == ACPI_STATE_S0) <nl>  		return; <nl>  	if (sc->sc_sleeptype[state].slp_typa == -1 || <nl>  	    sc->sc_sleeptype[state].slp_typb == -1) {
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: inetd.c,v 1.39 1997/08/31 18:04:37 deraadt Exp $	*/ <nl> +/*	$OpenBSD: inetd.c,v 1.40 1997/09/19 12:21:27 deraadt Exp $	*/ <nl>  /*	$NetBSD: inetd.c,v 1.11 1996/02/22 11:14:41 mycroft Exp $	*/ <nl>  /* <nl>   * Copyright (c) 1983,1991 The Regents of the University of California. <nl> @@ -41,7 +41,7 @@ char copyright[] = <nl>   <nl>  #ifndef lint <nl>  /*static char sccsid[] = "from: @(#)inetd.c	5.30 (Berkeley) 6/3/91";*/ <nl> -static char rcsid[] = "$OpenBSD: inetd.c,v 1.39 1997/08/31 18:04:37 deraadt Exp $"; <nl> +static char rcsid[] = "$OpenBSD: inetd.c,v 1.40 1997/09/19 12:21:27 deraadt Exp $"; <nl>  #endif /* not lint */ <nl>   <nl>  /* <nl> @@ -378,6 +378,8 @@ main(argc, argv, envp) <nl>  	sigvec(SIGTERM, &sv, NULL); <nl>  	sv.sv_handler = goaway; <nl>  	sigvec(SIGINT, &sv, NULL); <nl> +	sv.sv_handler = SIG_IGN; <nl> +	sigvec(SIGPIPE, &sv, NULL); <nl>   <nl>  	{ <nl>  		/* space for daemons to overwrite environment for ps */
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: rde_lsdb.c,v 1.42 2009/01/07 21:16:36 claudio Exp $ */ <nl> +/*	$OpenBSD: rde_lsdb.c,v 1.43 2009/11/12 22:29:15 claudio Exp $ */ <nl>   <nl>  /* <nl>   * Copyright (c) 2004, 2005 Claudio Jeker <claudio@openbsd.org> <nl> @@ -260,6 +260,10 @@ lsa_router_check(struct lsa *lsa, u_int16_t len) <nl>  	} <nl>   <nl>  	nlinks = ntohs(lsa->data.rtr.nlinks); <nl> +	if (nlinks == 0) { <nl> +		log_warnx("lsa_check: invalid LSA router packet"); <nl> +		return (0); <nl> +	} <nl>  	for (i = 0; i < nlinks; i++) { <nl>  		rtr_link = (struct lsa_rtr_link *)(buf + off); <nl>  		off += sizeof(struct lsa_rtr_link);
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: queue_shared.c,v 1.8 2009/02/15 13:44:06 jacekm Exp $	*/ <nl> +/*	$OpenBSD: queue_shared.c,v 1.9 2009/02/16 10:15:10 jacekm Exp $	*/ <nl>   <nl>  /* <nl>   * Copyright (c) 2008 Gilles Chehade <gilles@openbsd.org> <nl> @@ -694,10 +694,12 @@ display_envelope(struct message *envelope, int flags) <nl>  		errx(1, "%s: unexpected status 0x%04x", envelope->message_uid, <nl>  		    envelope->status); <nl>   <nl> -	getflag(&envelope->flags, F_MESSAGE_SCHEDULED, "SCHEDULED", <nl> +	getflag(&envelope->flags, F_MESSAGE_AUTHENTICATED, "AUTH", <nl>  	    status, sizeof(status)); <nl>  	getflag(&envelope->flags, F_MESSAGE_PROCESSING, "PROCESSING", <nl>  	    status, sizeof(status)); <nl> +	getflag(&envelope->flags, F_MESSAGE_SCHEDULED, "SCHEDULED", <nl> +	    status, sizeof(status)); <nl>   <nl>  	if (envelope->flags) <nl>  		errx(1, "%s: unexpected flags 0x%04x", envelope->message_uid,
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: kroute.c,v 1.84 2017/02/12 15:53:15 krw Exp $	*/ <nl> +/*	$OpenBSD: kroute.c,v 1.85 2017/03/08 15:07:32 krw Exp $	*/ <nl>   <nl>  /* <nl>   * Copyright 2012 Kenneth R Westerback <krw@openbsd.org> <nl> @@ -44,6 +44,9 @@ <nl>  #include "log.h" <nl>  #include "privsep.h" <nl>   <nl> +#define ROUNDUP(a) \ <nl> +    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(long) - 1))) : sizeof(long)) <nl> + <nl>  struct in_addr active_addr; <nl>   <nl>  int	create_route_label(struct sockaddr_rtlabel *); <nl> @@ -706,9 +709,6 @@ populate_rti_info(struct sockaddr **rti_info, struct rt_msghdr *rtm) <nl>  	struct sockaddr *sa; <nl>  	int i; <nl>   <nl> -#define ROUNDUP(a) \ <nl> -    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(long) - 1))) : sizeof(long)) <nl> - <nl>  	sa = (struct sockaddr *)((char *)(rtm) + rtm->rtm_hdrlen); <nl>   <nl>  	for (i = 0; i < RTAX_MAX; i++) {
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: server_fcgi.c,v 1.24 2014/08/06 18:38:11 reyk Exp $	*/ <nl> +/*	$OpenBSD: server_fcgi.c,v 1.25 2014/08/06 18:40:15 reyk Exp $	*/ <nl>   <nl>  /* <nl>   * Copyright (c) 2014 Florian Obser <florian@openbsd.org> <nl> @@ -358,6 +358,7 @@ fcgi_add_stdin(struct client *clt, struct evbuffer *evbuf) <nl>  { <nl>  	struct fcgi_record_header	h; <nl>   <nl> +	memset(&h, 0, sizeof(h)); <nl>  	h.version = 1; <nl>  	h.type = FCGI_STDIN; <nl>  	h.id = htons(1);
@@ -1,4 +1,4 @@ <nl> -/* $OpenBSD: scp.c,v 1.182 2015/04/24 01:36:00 deraadt Exp $ */ <nl> +/* $OpenBSD: scp.c,v 1.183 2015/10/16 17:07:24 mmcc Exp $ */ <nl>  /* <nl>   * scp - secure remote copy.  This is basically patched BSD rcp which <nl>   * uses ssh to do the data transfer (instead of using rcmd). <nl> @@ -845,7 +845,7 @@ rsource(char *name, struct stat *statp) <nl>  		return; <nl>  	} <nl>  	last = strrchr(name, '/'); <nl> -	if (last == 0) <nl> +	if (last == NULL) <nl>  		last = name; <nl>  	else <nl>  		last++;
@@ -1,4 +1,4 @@ <nl> -/* $OpenBSD: tls_verify.c,v 1.3 2014/12/07 15:48:02 bcook Exp $ */ <nl> +/* $OpenBSD: tls_verify.c,v 1.4 2014/12/07 16:01:03 jsing Exp $ */ <nl>  /* <nl>   * Copyright (c) 2014 Jeremie Courreges-Anglas <jca@openbsd.org> <nl>   * <nl> @@ -155,7 +155,7 @@ tls_check_subject_altname(X509 *cert, const char *host) <nl>  		} <nl>  	} <nl>   <nl> -	sk_GENERAL_NAME_free(altname_stack); <nl> +	sk_GENERAL_NAME_pop_free(altname_stack, GENERAL_NAME_free); <nl>  	return rv; <nl>  } <nl>  
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: print-ip6.c,v 1.3 2002/02/19 19:39:40 millert Exp $	*/ <nl> +/*	$OpenBSD: print-ip6.c,v 1.4 2003/01/27 10:00:40 henning Exp $	*/ <nl>   <nl>  /* <nl>   * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994 <nl> @@ -165,6 +165,8 @@ ip6_print(register const u_char *bp, register int length) <nl>  			(void)printf("ip-proto-%d %d", ip6->ip6_nxt, len); <nl>  			goto end; <nl>  		} <nl> +		if (hlen == 0) <nl> +			break; <nl>  	} <nl>   <nl>   end:
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: editor.c,v 1.227 2010/03/23 14:32:34 otto Exp $	*/ <nl> +/*	$OpenBSD: editor.c,v 1.228 2010/03/23 14:59:30 otto Exp $	*/ <nl>   <nl>  /* <nl>   * Copyright (c) 1997-2000 Todd C. Miller <Todd.Miller@courtesan.com> <nl> @@ -2341,7 +2341,7 @@ max_partition_size(struct disklabel *lp, int partno) <nl>  { <nl>  	struct partition *pp = &lp->d_partitions[partno]; <nl>  	struct diskchunk *chunks; <nl> -	u_int64_t maxsize, offset; <nl> +	u_int64_t maxsize = 0, offset; <nl>  	int fstype, i; <nl>   <nl>  	fstype = pp->p_fstype;
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: net.c,v 1.18 2012/04/14 12:10:04 haesbaert Exp $	*/ <nl> +/*	$OpenBSD: net.c,v 1.19 2012/04/15 03:25:27 jsg Exp $	*/ <nl>   <nl>  /* <nl>   * Copyright (c) 2005 Hkan Olsson.  All rights reserved. <nl> @@ -746,6 +746,7 @@ net_read(struct syncpeer *p, u_int32_t *msgtype, u_int32_t *msglen) <nl>   <nl>  	if (memcmp(hash, rhash, sizeof hash) != 0) { <nl>  		free(blob); <nl> +		free(msg); <nl>  		log_msg(0, "net_read: got bad message (typo in shared key?)"); <nl>  		return NULL; <nl>  	}
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: socket1.c,v 1.2 2003/07/31 21:48:06 deraadt Exp $	*/ <nl> +/*	$OpenBSD: socket1.c,v 1.3 2006/01/05 03:47:19 tedu Exp $	*/ <nl>  /* <nl>   * Copyright (c) 1993, 1994, 1995, 1996 by Chris Provenzano and contributors,  <nl>   * proven@mit.edu All rights reserved. <nl> @@ -89,11 +89,12 @@ sock_connect(void *arg) <nl>  	sleep(1); <nl>   <nl>  	CHECKr(pthread_mutex_lock(&mutex)); <nl> +	memset(buf, 0, sizeof(buf)); <nl>  	CHECKe(read(fd, buf, 1024)); <nl>   <nl> +	ASSERT(++counter == atoi(buf)); <nl>  	write(fd, "6", 1); <nl>   <nl> -	ASSERT(++counter == atoi(buf)); <nl>  	CHECKe(close(fd)); <nl>  	success++; <nl>  	CHECKr(pthread_mutex_unlock(&mutex)); <nl> @@ -155,6 +156,7 @@ sock_accept(void *arg) <nl>   <nl>  	/* Setup a write thread */ <nl>  	CHECKr(pthread_create(&thread, &attr, sock_write, &fd)); <nl> +	memset(buf, 0, sizeof(buf)); <nl>  	CHECKe(read(fd, buf, 1024)); <nl>   <nl>  	ASSERT(++counter == atoi(buf));
@@ -1,4 +1,4 @@ <nl> -/*      $OpenBSD: pf_key_v2.c,v 1.36 2000/11/17 05:16:36 angelos Exp $  */ <nl> +/*      $OpenBSD: pf_key_v2.c,v 1.37 2000/11/27 01:41:04 angelos Exp $  */ <nl>  /*	$EOM: pf_key_v2.c,v 1.67 2000/11/17 05:10:14 angelos Exp $	*/ <nl>   <nl>  /* <nl> @@ -1193,6 +1193,7 @@ pf_key_v2_flow (in_addr_t laddr, in_addr_t lmask, in_addr_t raddr, <nl>   <nl>  #ifdef SADB_X_EXT_FLOW_TYPE <nl>    /* Setup the flow type extension.  */ <nl> +  bzero (&flowtype, sizeof flowtype); <nl>    flowtype.sadb_protocol_exttype = SADB_X_EXT_FLOW_TYPE; <nl>    flowtype.sadb_protocol_len = sizeof flowtype / PF_KEY_V2_CHUNK; <nl>    flowtype.sadb_protocol_direction <nl> @@ -1230,7 +1231,11 @@ pf_key_v2_flow (in_addr_t laddr, in_addr_t lmask, in_addr_t raddr, <nl>     * XXX Addresses have to be thought through.  Assumes IPv4. <nl>     */ <nl>    len = sizeof *addr + PF_KEY_V2_ROUND (sizeof (struct sockaddr_in)); <nl> +#ifdef SADB_X_EXT_FLOW_TYPE <nl>    if (!delete || ingress) <nl> +#else <nl> +  if (!delete) <nl> +#endif /* SADB_X_EXT_FLOW_TYPE */ <nl>      { <nl>        addr = malloc (len); <nl>        if (!addr)
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: edit.c,v 1.21 2007/01/05 09:32:49 xsa Exp $	*/ <nl> +/*	$OpenBSD: edit.c,v 1.22 2007/01/05 09:41:30 xsa Exp $	*/ <nl>  /* <nl>   * Copyright (c) 2006, 2007 Xavier Santolaria <xsa@openbsd.org> <nl>   * <nl> @@ -289,6 +289,10 @@ cvs_edit_local(struct cvs_file *cf) <nl>  	    MAXPATHLEN) >= MAXPATHLEN) <nl>  		fatal("cvs_edit_local: truncation"); <nl>   <nl> +	if (mkdir(CVS_PATH_BASEDIR, 0755) == -1 && errno != EEXIST) <nl> +		fatal("cvs_edit_local: `%s': %s", CVS_PATH_BASEDIR, <nl> +		    strerror(errno)); <nl> + <nl>  	/* XXX: copy cf->file_path to bfpath */ <nl>   <nl>  	xfree(bfpath);
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: pfctl_altq.c,v 1.100 2013/10/12 12:16:11 henning Exp $	*/ <nl> +/*	$OpenBSD: pfctl_altq.c,v 1.101 2014/01/19 04:14:34 claudio Exp $	*/ <nl>   <nl>  /* <nl>   * Copyright (c) 2002 <nl> @@ -459,8 +459,7 @@ cbq_compute_idletime(struct pfctl *pf, struct pf_altq *pa) <nl>  			warnx("queue bandwidth must be larger than %s", <nl>  			    rate2str(ifnsPerByte * (double)opts->maxpktsize / <nl>  			    (double)INT_MAX * (double)pa->ifbandwidth)); <nl> -			fprintf(stderr, "cbq: queue %s is too slow!\n", <nl> -			    pa->qname); <nl> +		fprintf(stderr, "cbq: queue %s is too slow!\n", pa->qname); <nl>  		nsPerByte = (double)(INT_MAX / opts->maxpktsize); <nl>  	} <nl>  
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: kern_exec.c,v 1.126 2012/03/23 15:51:26 guenther Exp $	*/ <nl> +/*	$OpenBSD: kern_exec.c,v 1.127 2012/03/26 04:19:55 deraadt Exp $	*/ <nl>  /*	$NetBSD: kern_exec.c,v 1.75 1996/02/09 18:59:28 christos Exp $	*/ <nl>   <nl>  /*- <nl> @@ -472,9 +472,9 @@ sys_execve(struct proc *p, void *v, register_t *retval) <nl>  	TCB_SET(p, NULL);	/* reset the TCB address */ <nl>   <nl>  	/* set command name & other accounting info */ <nl> +	bzero(p->p_comm, sizeof(p->p_comm)); <nl>  	len = min(nid.ni_cnd.cn_namelen, MAXCOMLEN); <nl>  	bcopy(nid.ni_cnd.cn_nameptr, p->p_comm, len); <nl> -	p->p_comm[len] = 0; <nl>  	p->p_acflag &= ~AFORK; <nl>   <nl>  	/* record proc's vnode, for use by procfs and others */
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: version.c,v 1.11 2005/05/24 04:12:25 jfb Exp $	*/ <nl> +/*	$OpenBSD: version.c,v 1.12 2005/05/25 06:02:00 joris Exp $	*/ <nl>  /* <nl>   * Copyright (c) 2004 Jean-Francois Brousseau <jfb@openbsd.org> <nl>   * All rights reserved. <nl> @@ -34,6 +34,7 @@ <nl>   <nl>  #include "cvs.h" <nl>  #include "proto.h" <nl> +#include "log.h" <nl>   <nl>  static int cvs_version_sendflags  (struct cvsroot *); <nl>   <nl> @@ -59,10 +60,10 @@ cvs_version_sendflags(struct cvsroot *root) <nl>  { <nl>  	if ((root != NULL) && (root->cr_method != CVS_METHOD_LOCAL)) <nl>  		printf("Client: "); <nl> -	printf("%s\n", CVS_VERSION); <nl> +	cvs_printf("%s\n", CVS_VERSION); <nl>   <nl>  	if ((root != NULL) && (root->cr_method != CVS_METHOD_LOCAL)) { <nl> -		printf("Server: %s\n", root->cr_version == NULL ? <nl> +		cvs_printf("Server: %s\n", root->cr_version == NULL ? <nl>  		    "(unknown)" : root->cr_version); <nl>  	} <nl>  
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: malloc.c,v 1.222 2017/04/17 16:36:35 otto Exp $	*/ <nl> +/*	$OpenBSD: malloc.c,v 1.223 2017/04/18 15:46:44 otto Exp $	*/ <nl>  /* <nl>   * Copyright (c) 2008, 2010, 2011, 2016 Otto Moerbeek <otto@drijf.net> <nl>   * Copyright (c) 2012 Matthew Dempsky <matthew@openbsd.org> <nl> @@ -2018,6 +2018,9 @@ omemalign(struct dir_info *pool, size_t alignment, size_t sz, int zero_fill, voi <nl>  		else <nl>  			memset(p, SOME_JUNK, psz - mopts.malloc_guard); <nl>  	} <nl> +	else if (mopts.chunk_canaries) <nl> +		fill_canary(p, sz - mopts.malloc_guard, <nl> +		    psz - mopts.malloc_guard); <nl>   <nl>  	return p; <nl>  }
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: if_uath.c,v 1.14 2006/12/03 17:51:41 damien Exp $	*/ <nl> +/*	$OpenBSD: if_uath.c,v 1.15 2006/12/16 15:32:05 damien Exp $	*/ <nl>   <nl>  /*- <nl>   * Copyright (c) 2006 <nl> @@ -1243,8 +1243,8 @@ uath_data_rxeof(usbd_xfer_handle xfer, usbd_private_handle priv, <nl>  	/* finalize mbuf */ <nl>  	m->m_pkthdr.rcvif = ifp; <nl>  	m->m_data = data->buf + sizeof (uint32_t); <nl> -	m->m_pkthdr.len = m->m_len = <nl> -	    betoh32(desc->len) - sizeof (struct uath_rx_desc); <nl> +	m->m_pkthdr.len = m->m_len = betoh32(desc->len) - <nl> +	    sizeof (struct uath_rx_desc) - IEEE80211_CRC_LEN; <nl>   <nl>  	data = ndata; <nl>  
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: gzio.c,v 1.7 2002/03/12 00:25:57 millert Exp $	*/ <nl> +/*	$OpenBSD: gzio.c,v 1.8 2002/07/06 00:11:40 millert Exp $	*/ <nl>  /* gzio.c -- IO on .gz files <nl>   * Copyright (C) 1995-2002 Jean-loup Gailly. <nl>   * For conditions of distribution and use, see copyright notice in zlib.h <nl> @@ -681,6 +681,7 @@ z_off_t ZEXPORT gzseek (file, offset, whence) <nl>  	/* At this point, offset is the number of zero bytes to write. */ <nl>  	if (s->inbuf == Z_NULL) { <nl>  	    s->inbuf = (Byte*)ALLOC(Z_BUFSIZE); /* for seeking */ <nl> +	    if (s->inbuf == Z_NULL) return -1L; <nl>  	    zmemzero(s->inbuf, Z_BUFSIZE); <nl>  	} <nl>  	while (offset > 0)  { <nl> @@ -723,6 +724,7 @@ z_off_t ZEXPORT gzseek (file, offset, whence) <nl>   <nl>      if (offset != 0 && s->outbuf == Z_NULL) { <nl>  	s->outbuf = (Byte*)ALLOC(Z_BUFSIZE); <nl> +	if (s->outbuf == Z_NULL) return -1L; <nl>      } <nl>      while (offset > 0)  { <nl>  	int size = Z_BUFSIZE; <nl> @@ -862,12 +864,13 @@ const char*  ZEXPORT gzerror (file, errnum) <nl>      *errnum = s->z_err; <nl>      if (*errnum == Z_OK) return (const char*)""; <nl>   <nl> -    m =  (char*)(*errnum == Z_ERRNO ? zstrerror(errno) : s->stream.msg); <nl> +    m = (char*)(*errnum == Z_ERRNO ? zstrerror(errno) : s->stream.msg); <nl>   <nl>      if (m == NULL || *m == '\0') m = (char*)ERR_MSG(s->z_err); <nl>   <nl>      TRYFREE(s->msg); <nl>      s->msg = (char*)ALLOC(strlen(s->path) + strlen(m) + 3); <nl> +    if (s->msg == Z_NULL) return (const char*)ERR_MSG(Z_MEM_ERROR); <nl>      strcpy(s->msg, s->path); <nl>      strcat(s->msg, ": "); <nl>      strcat(s->msg, m);
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: acpi_user.c,v 1.5 2007/04/03 10:43:33 jsg Exp $	*/ <nl> +/*	$OpenBSD: acpi_user.c,v 1.6 2008/06/06 10:16:03 marco Exp $	*/ <nl>  /*- <nl>   * Copyright (c) 1999 Doug Rabson <nl>   * Copyright (c) 2000 Mitsuru IWASAKI <iwasaki@FreeBSD.org> <nl> @@ -25,7 +25,7 @@ <nl>   * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF <nl>   * SUCH DAMAGE. <nl>   * <nl> - *	$Id: acpi_user.c,v 1.5 2007/04/03 10:43:33 jsg Exp $ <nl> + *	$Id: acpi_user.c,v 1.6 2008/06/06 10:16:03 marco Exp $ <nl>   *	$FreeBSD: src/usr.sbin/acpi/acpidump/acpi_user.c,v 1.3 2000/11/08 02:37:00 iwasaki Exp $ <nl>   */ <nl>  #include <sys/types.h> <nl> @@ -107,6 +107,7 @@ acpi_find_rsd_ptr() <nl>   <nl>  	acpi_user_init(); <nl>  	for (i = 0; i < 1024 * 1024; i += 16) { <nl> +		lseek(acpi_mem_fd, i, SEEK_SET); <nl>  		read(acpi_mem_fd, buf, 16); <nl>  		if (!memcmp(buf, "RSD PTR ", 8)) { <nl>  			/* Read the rest of the structure */ <nl> @@ -115,6 +116,7 @@ acpi_find_rsd_ptr() <nl>  			/* Verify checksum before accepting it. */ <nl>  			if (acpi_checksum(buf, sizeof(struct ACPIrsdp))) <nl>  				continue; <nl> + <nl>  			return (acpi_map_physical(i, sizeof(struct ACPIrsdp))); <nl>  		} <nl>  	}
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: hpux_machdep.c,v 1.13 2002/07/20 19:24:55 art Exp $	*/ <nl> +/*	$OpenBSD: hpux_machdep.c,v 1.14 2002/08/02 16:11:11 millert Exp $	*/ <nl>  /*	$NetBSD: hpux_machdep.c,v 1.19 1998/02/16 20:58:30 thorpej Exp $	*/ <nl>   <nl>  /* <nl> @@ -241,6 +241,9 @@ hpux_sys_getcontext(p, v, retval) <nl>  	int l, i, error = 0; <nl>  	int len;  <nl>   <nl> +	if (SCARG(uap, len) <= 0) <nl> +		return (EINVAL); <nl> + <nl>  	for (i = 0; context_table[i].str != NULL; i++) <nl>  		if (context_table[i].val == fputype) <nl>  			break;
@@ -1,4 +1,4 @@ <nl> -/* $OpenBSD: rebound.c,v 1.93 2018/02/07 01:02:46 tedu Exp $ */ <nl> +/* $OpenBSD: rebound.c,v 1.94 2018/02/10 17:51:37 anton Exp $ */ <nl>  /* <nl>   * Copyright (c) 2015 Ted Unangst <tedu@openbsd.org> <nl>   * <nl> @@ -886,6 +886,9 @@ monitorloop(int ud, int ld, int ud6, int ld6, const char *confname) <nl>  	int conffd = -1; <nl>  	struct timespec ts, *timeout = NULL; <nl>   <nl> +	if (pledge("stdio rpath proc exec", NULL) == -1) <nl> +		err(1, "pledge"); <nl> + <nl>  	kq = kqueue(); <nl>   <nl>  	/* catch these signals with kevent */
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: uipc_socket.c,v 1.103 2012/07/10 11:42:53 guenther Exp $	*/ <nl> +/*	$OpenBSD: uipc_socket.c,v 1.104 2012/07/22 18:11:54 guenther Exp $	*/ <nl>  /*	$NetBSD: uipc_socket.c,v 1.21 1996/02/04 02:17:52 christos Exp $	*/ <nl>   <nl>  /* <nl> @@ -772,7 +772,7 @@ dontblock: <nl>  		} else { <nl>  			sbfree(&so->so_rcv, m); <nl>  			so->so_rcv.sb_mb = m->m_next; <nl> -			m->m_next = 0; <nl> +			m->m_nextpkt = m->m_next = NULL; <nl>  			cm = m; <nl>  			m = so->so_rcv.sb_mb; <nl>  			sbsync(&so->so_rcv, nextrecord);
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: if_vr.c,v 1.148 2015/11/25 03:09:59 dlg Exp $	*/ <nl> +/*	$OpenBSD: if_vr.c,v 1.149 2016/01/26 01:51:33 dlg Exp $	*/ <nl>   <nl>  /* <nl>   * Copyright (c) 1997, 1998 <nl> @@ -1330,6 +1330,7 @@ vr_start(struct ifnet *ifp) <nl>  		/* Pack the data into the descriptor. */ <nl>  		head_tx = cur_tx; <nl>  		if (vr_encap(sc, &cur_tx, m)) { <nl> +			m_freem(m); <nl>  			ifp->if_oerrors++; <nl>  			continue; <nl>  		}
@@ -2014,6 +2014,8 @@ gotswap: <nl>  			 */ <nl>  			nswapdev = dumpdev = NODEV; <nl>  		} <nl> +		if (nswapdev == rootdev) <nl> +			nswapdev = NODEV; <nl>  		swdevt[0].sw_dev = nswapdev; <nl>  		swdevt[1].sw_dev = NODEV; <nl>  
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: if_fxp.c,v 1.20 1999/10/09 19:45:02 downsj Exp $	*/ <nl> +/*	$OpenBSD: if_fxp.c,v 1.21 1999/10/14 18:28:39 jason Exp $	*/ <nl>  /*	$NetBSD: if_fxp.c,v 1.2 1997/06/05 02:01:55 thorpej Exp $	*/ <nl>   <nl>  /* <nl> @@ -1173,6 +1173,10 @@ fxp_stats_update(arg) <nl>  		sp->rx_rnr_errors = 0; <nl>  		sp->rx_overrun_errors = 0; <nl>  	} <nl> + <nl> +	/* Tick the MII clock. */ <nl> +	mii_tick(&sc->sc_mii); <nl> + <nl>  	splx(s); <nl>  	/* <nl>  	 * Schedule another timeout one second from now.
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: system.c,v 1.15 2003/07/10 00:06:51 david Exp $	*/ <nl> +/*	$OpenBSD: system.c,v 1.16 2003/10/22 23:05:11 tedu Exp $	*/ <nl>   <nl>  /*- <nl>   * Copyright (c) 1988 The Regents of the University of California. <nl> @@ -31,7 +31,7 @@ <nl>   <nl>  #ifndef lint <nl>  /*static char sccsid[] = "from: @(#)system.c	4.5 (Berkeley) 4/26/91";*/ <nl> -static char rcsid[] = "$OpenBSD: system.c,v 1.15 2003/07/10 00:06:51 david Exp $"; <nl> +static char rcsid[] = "$OpenBSD: system.c,v 1.16 2003/10/22 23:05:11 tedu Exp $"; <nl>  #endif /* not lint */ <nl>   <nl>  #include <sys/types.h> <nl> @@ -638,13 +638,15 @@ char	*argv[]; <nl>      struct timeval tv; <nl>      long ikey; <nl>   <nl> -    keyname = strdup("/tmp/apiXXXXXXXXXX"); <nl> +    if ((keyname = strdup("/tmp/apiXXXXXXXXXX")) == NULL) <nl> +	    err(1, "strdup"); <nl>      if ((fd = mkstemp(keyname)) == -1) { <nl>  	perror("open"); <nl>  	free(keyname); <nl>  	return 0; <nl>      } <nl> -    keyname = strdup(sockNAME); <nl> +    if ((keyname = strdup(sockNAME)) == NULL) <nl> +	    err(1, "strdup"); <nl>   <nl>      /* Now, get seed for random */ <nl>  
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: uvm_map.c,v 1.101 2008/07/18 16:40:17 kurt Exp $	*/ <nl> +/*	$OpenBSD: uvm_map.c,v 1.102 2008/07/25 12:02:09 art Exp $	*/ <nl>  /*	$NetBSD: uvm_map.c,v 1.86 2000/11/27 08:40:03 chs Exp $	*/ <nl>   <nl>  /*  <nl> @@ -726,6 +726,8 @@ uvm_map_p(struct vm_map *map, vaddr_t *startp, vsize_t size, <nl>   <nl>  	if ((map->flags & VM_MAP_INTRSAFE) == 0) <nl>  		splassert(IPL_NONE); <nl> +	else <nl> +		splassert(IPL_VM); <nl>   <nl>  	/* <nl>  	 * step 0: sanity check of protection code <nl> @@ -1426,6 +1428,8 @@ uvm_unmap_remove(struct vm_map *map, vaddr_t start, vaddr_t end, <nl>   <nl>  	if ((map->flags & VM_MAP_INTRSAFE) == 0) <nl>  		splassert(IPL_NONE); <nl> +	else <nl> +		splassert(IPL_VM); <nl>   <nl>  	/* <nl>  	 * find first entry
@@ -1,4 +1,4 @@ <nl> -/*	$Id: make_keypair.c,v 1.1.1.1 1995/12/14 06:52:53 tholo Exp $	*/ <nl> +/*	$Id: make_keypair.c,v 1.2 1995/12/29 09:49:55 tholo Exp $	*/ <nl>   <nl>  /*- <nl>   * Copyright (c) 1988, 1993 <nl> @@ -56,6 +56,8 @@ static char sccsid[] = "@(#)make_keypair.c	8.1 (Berkeley) 6/1/93"; <nl>  #include "pathnames.h" <nl>  #include "register_proto.h" <nl>   <nl> +char *progname; <nl> + <nl>  extern void herror(); <nl>  void make_key(), usage(); <nl>   <nl> @@ -68,6 +70,7 @@ main(argc, argv) <nl>  	int		i; <nl>  	struct sockaddr_in	sin; <nl>   <nl> +	progname = (addr = strrchr(*argv, '/')) ? addr + 1 : *argv; <nl>  	if (argc != 2) { <nl>  		usage(argv[0]); <nl>  		exit(1); <nl> @@ -106,8 +109,7 @@ make_key(addr) <nl>  	char		namebuf[255]; <nl>  	int		fd; <nl>   <nl> -	(void)sprintf(namebuf, ".%s%s", <nl> -		CLIENT_KEYFILE, <nl> +	(void)sprintf(namebuf, "%s", <nl>  		inet_ntoa(addr)); <nl>  	fd = open(namebuf, O_WRONLY|O_CREAT, 0600); <nl>  	if (fd < 0) {
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: if_pfsync.c,v 1.120 2009/04/04 13:09:29 dlg Exp $	*/ <nl> +/*	$OpenBSD: if_pfsync.c,v 1.121 2009/04/15 05:11:49 david Exp $	*/ <nl>   <nl>  /* <nl>   * Copyright (c) 2002 Michael Shalayeff <nl> @@ -942,7 +942,7 @@ pfsync_in_upd(struct pfsync_pkt *pkt, struct mbuf *m, int offset, int count) <nl>  		} <nl>   <nl>  		if (sfail) { <nl> -			if (pf_status.debug >= PF_DEBUG_MISC) { <nl> +			if (pf_status.debug >= PF_DEBUG_NOISY) { <nl>  				printf("pfsync: %s stale update (%d)" <nl>  				    " id: %016llx creatorid: %08x\n", <nl>  				    (sfail < 7 ?  "ignoring" : "partial"), <nl> @@ -1034,7 +1034,7 @@ pfsync_in_upd_c(struct pfsync_pkt *pkt, struct mbuf *m, int offset, int count) <nl>  		} <nl>   <nl>  		if (sfail) { <nl> -			if (pf_status.debug >= PF_DEBUG_MISC) { <nl> +			if (pf_status.debug >= PF_DEBUG_NOISY) { <nl>  				printf("pfsync: ignoring stale update " <nl>  				    "(%d) id: %016llx " <nl>  				    "creatorid: %08x\n", sfail,
@@ -28,7 +28,7 @@ <nl>   */ <nl>   <nl>  #if !defined(lint) && defined(LIBC_SCCS) <nl> -static char rcsid[] = "$OpenBSD: gmon.c,v 1.17 2005/03/23 19:32:09 otto Exp $"; <nl> +static char rcsid[] = "$OpenBSD: gmon.c,v 1.18 2005/04/21 00:09:01 deraadt Exp $"; <nl>  #endif <nl>   <nl>  #include <sys/param.h> <nl> @@ -219,9 +219,9 @@ _mcleanup(void) <nl>  		perror("mcount: gmon.log"); <nl>  		return; <nl>  	} <nl> -	len = snprintf(dbuf, sizeof dbuf, "[mcleanup1] kcount 0x%x ssiz %d\n", <nl> +	snprintf(dbuf, sizeof dbuf, "[mcleanup1] kcount 0x%x ssiz %d\n", <nl>  	    p->kcount, p->kcountsize); <nl> -	write(log, dbuf, len); <nl> +	write(log, dbuf, strlen(dbuf)); <nl>  #endif <nl>  	hdr = (struct gmonhdr *)&gmonhdr; <nl>  	bzero(hdr, sizeof(*hdr)); <nl> @@ -242,11 +242,11 @@ _mcleanup(void) <nl>  		for (toindex = p->froms[fromindex]; toindex != 0; <nl>  		     toindex = p->tos[toindex].link) { <nl>  #ifdef DEBUG <nl> -			len = snprintf(dbuf, sizeof dbuf, <nl> +			(void) snprintf(dbuf, sizeof dbuf, <nl>  			"[mcleanup2] frompc 0x%x selfpc 0x%x count %d\n" , <nl>  				frompc, p->tos[toindex].selfpc, <nl>  				p->tos[toindex].count); <nl> -			write(log, dbuf, len); <nl> +			write(log, dbuf, strlen(dbuf)); <nl>  #endif <nl>  			rawarc.raw_frompc = frompc; <nl>  			rawarc.raw_selfpc = p->tos[toindex].selfpc;
@@ -1,4 +1,4 @@ <nl> -/* $OpenBSD: packet.c,v 1.215 2015/09/21 04:31:00 djm Exp $ */ <nl> +/* $OpenBSD: packet.c,v 1.216 2015/10/21 11:33:03 gsoares Exp $ */ <nl>  /* <nl>   * Author: Tatu Ylonen <ylo@cs.hut.fi> <nl>   * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland <nl> @@ -2027,8 +2027,10 @@ ssh_packet_write_wait(struct ssh *ssh) <nl>  	    NFDBITS), sizeof(fd_mask)); <nl>  	if (setp == NULL) <nl>  		return SSH_ERR_ALLOC_FAIL; <nl> -	if ((r = ssh_packet_write_poll(ssh)) != 0) <nl> +	if ((r = ssh_packet_write_poll(ssh)) != 0) { <nl> +		free(setp); <nl>  		return r; <nl> +	} <nl>  	while (ssh_packet_have_data_to_write(ssh)) { <nl>  		memset(setp, 0, howmany(state->connection_out + 1, <nl>  		    NFDBITS) * sizeof(fd_mask));
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: kern_sysctl.c,v 1.8 1996/05/24 22:17:44 dm Exp $	*/ <nl> +/*	$OpenBSD: kern_sysctl.c,v 1.9 1996/06/29 21:04:21 tholo Exp $	*/ <nl>  /*	$NetBSD: kern_sysctl.c,v 1.17 1996/05/20 17:49:05 mrg Exp $	*/ <nl>   <nl>  /*- <nl> @@ -218,6 +218,8 @@ kern_sysctl(name, namelen, oldp, oldlenp, newp, newlen, p) <nl>  		return (sysctl_rdstring(oldp, oldlenp, newp, osrelease)); <nl>  	case KERN_OSREV: <nl>  		return (sysctl_rdint(oldp, oldlenp, newp, BSD)); <nl> +	case KERN_OSVERSION: <nl> +		return (sysctl_rdstring(oldp, oldlenp, newp, osversion)); <nl>  	case KERN_VERSION: <nl>  		return (sysctl_rdstring(oldp, oldlenp, newp, version)); <nl>  	case KERN_MAXVNODES:
@@ -275,6 +275,11 @@ hvs_attach(struct device *parent, struct device *self, void *aux) <nl>  	if (strcmp("scsi", aa->aa_ident) == 0) <nl>  		sc->sc_flags |= HVSF_SCSI; <nl>   <nl> +	if (hv_channel_setdeferred(sc->sc_chan, sc->sc_dev.dv_xname)) { <nl> +		printf(": failed to create the interrupt thread\n"); <nl> +		return; <nl> +	} <nl> + <nl>  	if (hv_channel_open(sc->sc_chan, HVS_RING_SIZE, &sc->sc_props, <nl>  	    sizeof(sc->sc_props), hvs_intr, sc)) { <nl>  		printf(": failed to open channel\n");
@@ -1045,6 +1045,9 @@ hvn_nvs_cmd(struct hvn_softc *sc, void *cmd, size_t cmdsize, uint64_t tid, <nl>  		return (rv); <nl>  	} <nl>   <nl> +	if (timo == 0) <nl> +		return (0); <nl> + <nl>  	do { <nl>  		if (cold) <nl>  			delay(1000);
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: kern_subr.c,v 1.25 2003/07/21 22:44:50 tedu Exp $	*/ <nl> +/*	$OpenBSD: kern_subr.c,v 1.26 2003/10/31 11:10:41 markus Exp $	*/ <nl>  /*	$NetBSD: kern_subr.c,v 1.15 1996/04/09 17:21:56 ragge Exp $	*/ <nl>   <nl>  /* <nl> @@ -164,16 +164,14 @@ hashinit(elements, type, flags, hashmask) <nl>  	int elements, type, flags; <nl>  	u_long *hashmask; <nl>  { <nl> -	long hashsize; <nl> +	u_long hashsize, i; <nl>  	LIST_HEAD(generic, generic) *hashtbl; <nl> -	int i; <nl>   <nl>  	if (elements <= 0) <nl>  		panic("hashinit: bad cnt"); <nl> -	for (hashsize = 1; hashsize <= elements; hashsize <<= 1) <nl> +	for (hashsize = 1; hashsize < elements; hashsize <<= 1) <nl>  		continue; <nl> -	hashsize >>= 1; <nl> -	hashtbl = malloc((u_long)hashsize * sizeof(*hashtbl), type, flags); <nl> +	hashtbl = malloc(hashsize * sizeof(*hashtbl), type, flags); <nl>  	if (hashtbl == NULL) <nl>  		return NULL; <nl>  	for (i = 0; i < hashsize; i++)
@@ -1,4 +1,4 @@ <nl> -/*      $OpenBSD: criov.c,v 1.14 2003/08/14 15:18:05 jason Exp $	*/ <nl> +/*      $OpenBSD: criov.c,v 1.15 2006/11/19 22:13:47 jmc Exp $	*/ <nl>   <nl>  /* <nl>   * Copyright (c) 1999 Theo de Raadt <nl> @@ -143,7 +143,7 @@ cuio_apply(struct uio *uio, int off, int len, <nl>  	ind = 0; <nl>  	while (off > 0) { <nl>  		if (ind >= uio->uio_iovcnt) <nl> -			panic("cui_apply: ind %d >= uio_iovcnt %d for off", <nl> +			panic("cuio_apply: ind %d >= uio_iovcnt %d for off", <nl>  			    ind, uio->uio_iovcnt); <nl>  		uiolen = uio->uio_iov[ind].iov_len; <nl>  		if (off < uiolen) <nl> @@ -153,7 +153,7 @@ cuio_apply(struct uio *uio, int off, int len, <nl>  	} <nl>  	while (len > 0) { <nl>  		if (ind >= uio->uio_iovcnt) <nl> -			panic("cui_apply: ind %d >= uio_iovcnt %d for len", <nl> +			panic("cuio_apply: ind %d >= uio_iovcnt %d for len", <nl>  			    ind, uio->uio_iovcnt); <nl>  		count = min(uio->uio_iov[ind].iov_len - off, len); <nl>  
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: route.c,v 1.154 2011/07/02 22:00:54 claudio Exp $	*/ <nl> +/*	$OpenBSD: route.c,v 1.155 2011/07/04 22:48:31 claudio Exp $	*/ <nl>  /*	$NetBSD: route.c,v 1.16 1996/04/15 18:27:05 cgd Exp $	*/ <nl>   <nl>  /* <nl> @@ -865,6 +865,7 @@ getaddr(int which, char *s, struct hostent **hpp) <nl>  	    } <nl>   <nl>  	case AF_LINK: <nl> +		su->sa.sa_len = sizeof(struct sockaddr_dl); <nl>  		link_addr(s, &su->sdl); <nl>  		return (1); <nl>  	case AF_MPLS:
@@ -1,4 +1,4 @@ <nl> -/* $OpenBSD: mke2fs.c,v 1.14 2015/11/26 06:59:12 deraadt Exp $ */ <nl> +/* $OpenBSD: mke2fs.c,v 1.15 2016/01/26 19:09:57 mmcc Exp $ */ <nl>  /*	$NetBSD: mke2fs.c,v 1.13 2009/10/19 18:41:08 bouyer Exp $	*/ <nl>   <nl>  /*- <nl> @@ -536,7 +536,6 @@ mke2fs(const char *fsys, int fi, int fo) <nl>  	    MAP_ANON|MAP_PRIVATE, -1, 0); <nl>  	if (iobuf == MAP_FAILED) <nl>  		errx(EXIT_FAILURE, "Cannot allocate I/O buffer\n"); <nl> -	memset(iobuf, 0, iobufsize); <nl>   <nl>  	/* <nl>  	 * We now start writing to the filesystem
@@ -55,6 +55,12 @@ int	 drm_detach(struct device *, int); <nl>  int	 drm_activate(struct device *, enum devact); <nl>  int	 drmprint(void *, const char *); <nl>   <nl> +/* <nl> + * attach drm to a pci-based driver. <nl> + * <nl> + * This function does all the pci-specific calculations for the  <nl> + * drm_attach_args. <nl> + */ <nl>  struct device * <nl>  drm_attach_pci(const struct drm_driver_info *driver, struct pci_attach_args *pa, <nl>      int is_agp, struct device *dev) <nl> @@ -119,6 +125,7 @@ drm_attach(struct device *parent, struct device *self, void *aux) <nl>  	dev->driver = da->driver; <nl>   <nl>  	dev->dmat = da->dmat; <nl> +	dev->bst = da->bst; <nl>  	dev->irq = da->irq; <nl>  	dev->unique = da->busid; <nl>  	dev->unique_len = da->busid_len;
@@ -48,7 +48,7 @@ <nl>   <nl>  #include "fed.h" <nl>   <nl> -void main(int argc, char *argv[]) <nl> +int main(int argc, char *argv[]) <nl>  { <nl>  	int i; <nl>  	int row, col; <nl> @@ -163,6 +163,7 @@ void main(int argc, char *argv[]) <nl>  		writefont(); <nl>  	} <nl>  	endwin(); <nl> +	exit(0); <nl>  } <nl>   <nl>  /*---------------------------------- E O F ----------------------------------*/
@@ -308,7 +308,7 @@ void ssl_mutex_sem_create(server_rec *s, pool *p) <nl>      } <nl>      semctlbuf.sem_perm.uid  = ap_user_id; <nl>      semctlbuf.sem_perm.gid  = ap_group_id; <nl> -    semctlbuf.sem_perm.mode = 0660; <nl> +    semctlbuf.sem_perm.mode = 0600; <nl>      semctlarg.buf = &semctlbuf; <nl>      if (semctl(semid, 0, IPC_SET, semctlarg) < 0) { <nl>          ssl_log(s, SSL_LOG_ERROR|SSL_ADD_ERRNO,
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: intr.h,v 1.31 2010/05/21 15:24:29 jsing Exp $	*/ <nl> +/*	$OpenBSD: intr.h,v 1.32 2010/06/08 12:33:30 jsing Exp $	*/ <nl>   <nl>  /* <nl>   * Copyright (c) 2002-2004 Michael Shalayeff <nl> @@ -160,6 +160,7 @@ void	 softintr_schedule(void *); <nl>   <nl>  #ifdef MULTIPROCESSOR <nl>  void	 hppa_ipi_init(struct cpu_info *); <nl> +int	 hppa_ipi_intr(void *arg); <nl>  int	 hppa_ipi_send(struct cpu_info *, u_long); <nl>  #endif <nl>  
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: buffer.c,v 1.30 2016/09/03 11:31:17 nayden Exp $	*/ <nl> +/*	$OpenBSD: buffer.c,v 1.31 2017/03/18 01:48:43 deraadt Exp $	*/ <nl>   <nl>  /* <nl>   * Copyright (c) 2002, 2003 Niels Provos <provos@citi.umich.edu> <nl> @@ -359,7 +359,8 @@ evbuffer_expand(struct evbuffer *buf, size_t datlen) <nl>   <nl>  		if (buf->orig_buffer != buf->buffer) <nl>  			evbuffer_align(buf); <nl> -		if ((newbuf = realloc(buf->buffer, length)) == NULL) <nl> +		if ((newbuf = recallocarray(buf->buffer, buf->totallen, <nl> +		    length, 1)) == NULL) <nl>  			return (-1); <nl>   <nl>  		buf->orig_buffer = buf->buffer = newbuf;
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: i2c_scan.c,v 1.117 2008/04/01 04:18:17 cnst Exp $	*/ <nl> +/*	$OpenBSD: i2c_scan.c,v 1.118 2008/04/07 00:31:07 deraadt Exp $	*/ <nl>   <nl>  /* <nl>   * Copyright (c) 2005 Theo de Raadt <deraadt@openbsd.org> <nl> @@ -847,6 +847,14 @@ iic_probe_sensor(struct device *self, u_int8_t addr) <nl>  	} else if ((addr == 0x2c || addr == 0x2d || addr == 0x2e) && <nl>  	      iicprobe(0x16) == 0x41 && ((iicprobe(0x17) & 0xf0) == 0x40)) { <nl>  		name = "adm1026"; <nl> +	} else if ((addr & 0x18) == 0x18 && iicprobew(0x06) == 0x1131 && <nl> +	    iicprobew(0x07) == 0xa101 && <nl> +	    (iicprobew(0x00) & 0xfff0) == 0x0010) { <nl> +		name = "se98"; <nl> +	} else if ((addr & 0x18) == 0x18 && iicprobew(0x06) == 0x11d4 && <nl> +	    (iicprobew(0x07) & 0xfff0) == 0x0800 && <nl> +	    iicprobew(0x00) == 0x001d) { <nl> +		name = "adt7408"; <nl>  	} else if (name == NULL && <nl>  	    (addr & 0x78) == 0x48) {		/* addr 0b1001xxx */ <nl>  		name = lm75probe();
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: x99token.c,v 1.11 2015/10/15 17:23:09 bluhm Exp $	*/ <nl> +/*	$OpenBSD: x99token.c,v 1.12 2015/10/15 19:30:03 bluhm Exp $	*/ <nl>   <nl>  /* <nl>   * X9.9 calculator <nl> @@ -46,7 +46,7 @@ main(int argc, char **argv) <nl>  	unsigned int pin; <nl>  	struct passwd *pwd; <nl>   <nl> -	if (pledge("stdio rpath wpath cpath fattr getpw tty", NULL) == -1) <nl> +	if (pledge("stdio rpath wpath cpath getpw tty", NULL) == -1) <nl>  		err(1, "pledge"); <nl>   <nl>  	while ((i = getopt(argc, argv, "dk:in:")) != -1) { <nl> @@ -139,9 +139,10 @@ main(int argc, char **argv) <nl>  		key[0] ^= (pin >> ((i * 7) % 26)) & 0x7f; <nl>   <nl>  	if (init) { <nl> +		umask(S_IRWXG | S_IRWXO); <nl> +		unlink(keyfile); <nl>  		if ((fp = fopen(keyfile, "w")) == NULL) <nl>  			err(1, "could not open %s for writing", keyfile); <nl> -		fchmod(fileno(fp), 0600); <nl>  		for (i = 0; i < 8; ++i) { <nl>  			fprintf(fp, "%c", digits[(key[i]>>4)&0xf]); <nl>  			fprintf(fp, "%c", digits[(key[i]>>0)&0xf]);
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: pfctl_parser.c,v 1.174 2003/08/22 21:52:11 itojun Exp $ */ <nl> +/*	$OpenBSD: pfctl_parser.c,v 1.175 2003/09/18 20:27:58 cedric Exp $ */ <nl>   <nl>  /* <nl>   * Copyright (c) 2001 Daniel Hartmeier <nl> @@ -852,6 +852,8 @@ check_netmask(struct node_host *h, sa_family_t af) <nl>  	struct pf_addr	*m; <nl>   <nl>  	for (n = h; n != NULL; n = n->next) { <nl> +		if (h->addr.type == PF_ADDR_TABLE) <nl> +			continue; <nl>  		m = &h->addr.v.a.mask; <nl>  		/* fix up netmask for dynaddr */ <nl>  		if (af == AF_INET && h->addr.type == PF_ADDR_DYNIFTL &&
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: ike_auth.c,v 1.39 2001/04/09 12:34:37 ho Exp $	*/ <nl> +/*	$OpenBSD: ike_auth.c,v 1.40 2001/05/24 03:15:37 angelos Exp $	*/ <nl>  /*	$EOM: ike_auth.c,v 1.59 2000/11/21 00:21:31 angelos Exp $	*/ <nl>   <nl>  /* <nl> @@ -693,7 +693,8 @@ rsa_sig_decode_hash (struct message *msg) <nl>  	  id_found = 0; <nl>  	  for (i = 0; i < n; i++) <nl>   	    if (id_cert_len[i] == id_len <nl> -		&& memcmp (id, id_cert[i], id_len) == 0) <nl> +		&& id[0] == id_cert[i][0] <nl> +		&& memcmp (id + 4, id_cert[i] + 4, id_len - 4) == 0) <nl>  	      { <nl>  		id_found++; <nl>  		break;
@@ -1,5 +1,5 @@ <nl>  /*	$OpenPackages$ */ <nl> -/*	$OpenBSD: str.c,v 1.17 2001/05/03 13:41:11 espie Exp $	*/ <nl> +/*	$OpenBSD: str.c,v 1.18 2001/05/07 22:54:53 espie Exp $	*/ <nl>  /*	$NetBSD: str.c,v 1.13 1996/11/06 17:59:23 christos Exp $	*/ <nl>   <nl>  /*- <nl> @@ -47,7 +47,7 @@ <nl>  static char	sccsid[] = "@(#)str.c	5.8 (Berkeley) 6/1/90"; <nl>  #else <nl>  UNUSED <nl> -static char rcsid[] = "$OpenBSD: str.c,v 1.17 2001/05/03 13:41:11 espie Exp $"; <nl> +static char rcsid[] = "$OpenBSD: str.c,v 1.18 2001/05/07 22:54:53 espie Exp $"; <nl>  #endif <nl>  #endif				/* not lint */ <nl>   <nl> @@ -83,7 +83,8 @@ str_concati(s1, s2, e2, sep) <nl>  	result[len1-1] = sep; <nl>   <nl>      /* copy second string plus EOS into place */ <nl> -    memcpy(result + len1, s2, len2 + 1); <nl> +    memcpy(result + len1, s2, len2); <nl> +    result[len1+len2] = '\0'; <nl>      return result; <nl>  } <nl>  
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: i2c_scan.c,v 1.97 2007/04/10 17:47:55 miod Exp $	*/ <nl> +/*	$OpenBSD: i2c_scan.c,v 1.98 2007/09/03 19:04:43 kettenis Exp $	*/ <nl>   <nl>  /* <nl>   * Copyright (c) 2005 Theo de Raadt <deraadt@openbsd.org> <nl> @@ -561,6 +561,11 @@ iic_probe(struct device *self, struct i2cbus_attach_args *iba, u_int8_t addr) <nl>  		    (iicprobe(0x3f) & 0xf0) == 0xb0) <nl>  			name = "emc6w201"; <nl>  		break; <nl> +	case 0x61:		/* Andigilog */ <nl> +		if ((addr == 0x2c || addr == 0x2d || addr == 0x2e) && <nl> +		    iicprobe(0x3f) == 0x6c) <nl> +			name = "asc7621"; <nl> +		break; <nl>  	case 0xa1:		/* Philips */ <nl>  		if ((iicprobe(0x3f) & 0xf0) == 0x20 && <nl>  		    (iicprobe(0x40) & 0x80) == 0x00 &&
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: trap.c,v 1.15 1997/09/19 17:16:14 niklas Exp $	*/ <nl> +/*	$OpenBSD: trap.c,v 1.16 1997/10/07 22:52:05 niklas Exp $	*/ <nl>  /*	$NetBSD: trap.c,v 1.56 1997/07/16 00:01:47 is Exp $	*/ <nl>   <nl>  /* <nl> @@ -177,6 +177,9 @@ int mmudebug = 0; <nl>  extern struct pcb *curpcb; <nl>  extern char fubail[], subail[]; <nl>   <nl> +/* XXX until we get it from m68k/cpu.h */ <nl> +extern void    regdump __P((struct trapframe *, int)); <nl> + <nl>  int	_write_back __P((u_int, u_int, u_int, u_int, vm_map_t)); <nl>  void	userret __P((struct proc *, int, u_quad_t)); <nl>  void	panictrap __P((int, u_int, u_int, struct frame *));
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: pf_ioctl.c,v 1.161 2005/12/10 14:41:07 krw Exp $ */ <nl> +/*	$OpenBSD: pf_ioctl.c,v 1.162 2006/01/05 02:23:39 deraadt Exp $ */ <nl>   <nl>  /* <nl>   * Copyright (c) 2001 Daniel Hartmeier <nl> @@ -355,6 +355,7 @@ pf_find_or_create_ruleset(const char *path) <nl>  	if (ruleset != NULL) <nl>  		return (ruleset); <nl>  	p = (char *)malloc(MAXPATHLEN, M_TEMP, M_WAITOK); <nl> +	bzero(p, MAXPATHLEN); <nl>  	strlcpy(p, path, MAXPATHLEN); <nl>  	while (parent == NULL && (q = strrchr(p, '/')) != NULL) { <nl>  		*q = 0; <nl> @@ -473,6 +474,7 @@ pf_anchor_setup(struct pf_rule *r, const struct pf_ruleset *s, <nl>  	if (!name[0]) <nl>  		return (0); <nl>  	path = (char *)malloc(MAXPATHLEN, M_TEMP, M_WAITOK); <nl> +	bzero(path, MAXPATHLEN); <nl>  	if (name[0] == '/') <nl>  		strlcpy(path, name + 1, MAXPATHLEN); <nl>  	else { <nl> @@ -530,6 +532,7 @@ pf_anchor_copyout(const struct pf_ruleset *rs, const struct pf_rule *r, <nl>  		int	 i; <nl>   <nl>  		a = (char *)malloc(MAXPATHLEN, M_TEMP, M_WAITOK); <nl> +		bzero(a, MAXPATHLEN); <nl>  		if (rs->anchor == NULL) <nl>  			a[0] = 0; <nl>  		else
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: dhcrelay.c,v 1.28 2006/12/18 01:08:58 stevesk Exp $ */ <nl> +/*	$OpenBSD: dhcrelay.c,v 1.29 2007/02/09 16:49:47 stevesk Exp $ */ <nl>   <nl>  /* <nl>   * Copyright (c) 2004 Henning Brauer <henning@cvs.openbsd.org> <nl> @@ -321,6 +321,9 @@ got_response(struct protocol *l) <nl>  		    inet_ntoa(sp->to.sin_addr)); <nl>  		return; <nl>  	} <nl> +	if (result == -1 && errno == ECONNREFUSED) <nl> +		return; <nl> + <nl>  	if (result == 0) <nl>  		return; <nl>  
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: pstat.c,v 1.11 1997/08/07 20:58:30 millert Exp $	*/ <nl> +/*	$OpenBSD: pstat.c,v 1.12 1997/08/10 04:55:18 millert Exp $	*/ <nl>  /*	$NetBSD: pstat.c,v 1.27 1996/10/23 22:50:06 cgd Exp $	*/ <nl>   <nl>  /*- <nl> @@ -44,7 +44,7 @@ static char copyright[] = <nl>  #if 0 <nl>  from: static char sccsid[] = "@(#)pstat.c	8.9 (Berkeley) 2/16/94"; <nl>  #else <nl> -static char *rcsid = "$OpenBSD: pstat.c,v 1.11 1997/08/07 20:58:30 millert Exp $"; <nl> +static char *rcsid = "$OpenBSD: pstat.c,v 1.12 1997/08/10 04:55:18 millert Exp $"; <nl>  #endif <nl>  #endif /* not lint */ <nl>   <nl> @@ -805,9 +805,9 @@ ttyprt(tp) <nl>  	char *name, state[20]; <nl>   <nl>  	if (usenumflag || (name = devname(tp->t_dev, S_IFCHR)) == NULL) <nl> -		(void)printf("%2d,%-2d   ", major(tp->t_dev), minor(tp->t_dev)); <nl> +		(void)printf("%2d,%-3d  ", major(tp->t_dev), minor(tp->t_dev)); <nl>  	else <nl> -		(void)printf("%-7s ", name); <nl> +		(void)printf("%6s ", name); <nl>  	(void)printf("%3d %4d ", tp->t_rawq.c_cc, tp->t_canq.c_cc); <nl>  	(void)printf("%4d %4d %3d %6d ", tp->t_outq.c_cc,  <nl>  		tp->t_hiwat, tp->t_lowat, tp->t_column);
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: build.c,v 1.1 2007/04/19 04:04:58 dlg Exp $ */ <nl> +/*	$OpenBSD: build.c,v 1.2 2007/04/19 04:08:51 dlg Exp $ */ <nl>   <nl>  /* <nl>   * Copyright (c) 2007 David Gwynne <dlg@openbsd.org> <nl> @@ -32,11 +32,15 @@ main(int argc, char *argv[]) <nl>  { <nl>  	ssize_t		len; <nl>  	int		fd; <nl> +	int		i; <nl>   <nl>  	fd = open(THT_FW_NAME, O_WRONLY | O_CREAT | O_TRUNC, 0644); <nl>  	if (fd == -1) <nl>  		err(1, "%s", THT_FW_NAME); <nl>   <nl> +	for (i = 0; i < (sizeof(tht_fw) / sizeof(tht_fw[0])); i++) <nl> +		tht_fw[i] = htole32(tht_fw[i]); <nl> + <nl>  	len = write(fd, tht_fw, sizeof(tht_fw)); <nl>  	if (len == -1) <nl>  		err(1, "%s write", THT_FW_NAME);
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: rs.c,v 1.25 2015/08/20 22:32:41 deraadt Exp $	*/ <nl> +/*	$OpenBSD: rs.c,v 1.26 2015/10/06 03:26:31 deraadt Exp $	*/ <nl>   <nl>  /*- <nl>   * Copyright (c) 1993 <nl> @@ -93,6 +93,9 @@ void	  putfile(void); <nl>  int <nl>  main(int argc, char *argv[]) <nl>  { <nl> +	if (tame("stdio", NULL) == -1) <nl> +		err(1, "tame"); <nl> + <nl>  	getargs(argc, argv); <nl>  	getfile(); <nl>  	if (flags & SHAPEONLY) {
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: fetch.c,v 1.120 2014/05/19 20:05:09 jca Exp $	*/ <nl> +/*	$OpenBSD: fetch.c,v 1.121 2014/05/19 20:09:22 jca Exp $	*/ <nl>  /*	$NetBSD: fetch.c,v 1.14 1997/08/18 10:20:20 lukem Exp $	*/ <nl>   <nl>  /*- <nl> @@ -856,6 +856,7 @@ again: <nl>  			} <nl>   <nl>  			if (ssl_check_hostname(cert, host) != 0) { <nl> +				X509_free(cert); <nl>  				fprintf(ttyout, "%s: host `%s' not present in" <nl>  				    " server certificate\n", <nl>  				    getprogname(), host);
@@ -1,4 +1,4 @@ <nl> -/*      $OpenBSD: whois.c,v 1.56 2017/07/26 15:48:38 sthen Exp $   */ <nl> +/*      $OpenBSD: whois.c,v 1.57 2018/06/17 15:34:54 florian Exp $   */ <nl>   <nl>  /* <nl>   * Copyright (c) 1980, 1993 <nl> @@ -278,7 +278,8 @@ whois(const char *query, const char *server, const char *port, int flags) <nl>   * If the TLD is a number, query ARIN, otherwise, use TLD.whois-server.net. <nl>   * If the domain does not contain '.', check to see if it is an NSI handle <nl>   * (starts with '!') or a CORE handle (COCO-[0-9]+ or COHO-[0-9]+) or an <nl> - * ASN (starts with AS). Fall back to NICHOST for the non-handle case. <nl> + * ASN (starts with AS) or IPv6 address (contains ':'). Fall back to <nl> + * NICHOST for the non-handle and non-IPv6 case. <nl>   */ <nl>  char * <nl>  choose_server(const char *name, const char *country, char **tofree) <nl> @@ -305,6 +306,8 @@ choose_server(const char *name, const char *country, char **tofree) <nl>  		else if ((strncasecmp(name, "AS", 2) == 0) && <nl>  		    strtol(name + 2, &ep, 10) > 0 && *ep == '\0') <nl>  			return (MNICHOST); <nl> +		else if (strchr(name, ':') != NULL) /* IPv6 address */ <nl> +			return (ANICHOST); <nl>  		else <nl>  			return (NICHOST); <nl>  	} else if (isdigit((unsigned char)*(++qhead)))
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: pfvar.h,v 1.199 2004/06/25 00:42:58 itojun Exp $ */ <nl> +/*	$OpenBSD: pfvar.h,v 1.200 2004/06/25 10:10:14 itojun Exp $ */ <nl>   <nl>  /* <nl>   * Copyright (c) 2001 Daniel Hartmeier <nl> @@ -47,7 +47,7 @@ struct ip; <nl>  #define	PF_TCPS_PROXY_SRC	((TCP_NSTATES)+0) <nl>  #define	PF_TCPS_PROXY_DST	((TCP_NSTATES)+1) <nl>   <nl> -enum	{ PF_FORWARD, PF_IN, PF_OUT }; <nl> +enum	{ PF_INOUT, PF_IN, PF_OUT, PF_FORWARD }; <nl>  enum	{ PF_LAN_EXT, PF_EXT_GWY, PF_ID }; <nl>  enum	{ PF_PASS, PF_DROP, PF_SCRUB, PF_NAT, PF_NONAT, <nl>  	  PF_BINAT, PF_NOBINAT, PF_RDR, PF_NORDR, PF_SYNPROXY_DROP };
@@ -290,6 +290,7 @@ blockcheck(origname) <nl>  	char *origname; <nl>  { <nl>  	struct stat stslash, stblock, stchar; <nl> +	struct fstab *fsp; <nl>  	char *newname, *raw; <nl>  	int retried = 0; <nl>   <nl> @@ -330,6 +331,11 @@ retry: <nl>  	 * Not a block or character device, just return name and <nl>  	 * let the user decide whether to use it. <nl>  	 */ <nl> +	if ((fsp = getfsfile(origname))) { <nl> +	    newname = fsp->fs_spec; <nl> +	    retried++; <nl> +	    goto retry; <nl> +    	} <nl>  	return (origname); <nl>  } <nl>  
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: rcs.c,v 1.13 2006/06/04 02:54:07 niallo Exp $	*/ <nl> +/*	$OpenBSD: rcs.c,v 1.14 2006/06/04 02:54:59 niallo Exp $	*/ <nl>  /* <nl>   * Copyright (c) 2004 Jean-Francois Brousseau <jfb@openbsd.org> <nl>   * All rights reserved. <nl> @@ -2778,6 +2778,7 @@ rcs_expand_keywords(char *rcsfile, struct rcs_delta *rdp, BUF *bp, int mode) <nl>  	} <nl>  	bp = rcs_buf_alloc(len - 1, BUF_AUTOEXT); <nl>  	rcs_buf_set(bp, data, len - 1, 0); <nl> +	xfree(data); <nl>   <nl>  	return (bp); <nl>  }
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: pcvt_kbd.c,v 1.24 1999/09/27 01:50:19 aaron Exp $	*/ <nl> +/*	$OpenBSD: pcvt_kbd.c,v 1.25 1999/10/04 09:38:19 aaron Exp $	*/ <nl>   <nl>  /* <nl>   * Copyright (c) 1992, 1995 Hellmuth Michaelis and Joerg Wunsch. <nl> @@ -1486,11 +1486,11 @@ regular: <nl>   <nl>  	if ((key == 85) && shift_down && kbd_lastkey != 85) <nl>  	{ <nl> -		if (vsp->scr_offset > (vsp->screen_rows - 1)) <nl> +		if (vsp->scr_offset > vsp->row) <nl>  		{ <nl>  			if (!vsp->scrolling) <nl>  			{ <nl> -				vsp->scrolling += vsp->screen_rows - 2; <nl> +				vsp->scrolling += vsp->row - 1; <nl>  				if (vsp->Scrollback) <nl>  				{ <nl>  					scrollback_save_screen(); <nl> @@ -1534,7 +1534,7 @@ scroll_reset: <nl>  			if (vsp->scrolling < 0) <nl>  				vsp->scrolling = 0; <nl>   <nl> -			if (vsp->scrolling <= vsp->screen_rows) <nl> +			if (vsp->scrolling <= vsp->row) <nl>  			{ <nl>  				vsp->scrolling = 0; <nl>  				scrollback_restore_screen();
@@ -1,4 +1,4 @@ <nl> -/*	$NetBSD: preen.c,v 1.11 1995/03/18 14:55:59 cgd Exp $	*/ <nl> +/*	$NetBSD: preen.c,v 1.12 1996/05/11 14:27:50 mycroft Exp $	*/ <nl>   <nl>  /* <nl>   * Copyright (c) 1990, 1993 <nl> @@ -37,7 +37,7 @@ <nl>  #if 0 <nl>  static char sccsid[] = "@(#)preen.c	8.3 (Berkeley) 12/6/94"; <nl>  #else <nl> -static char rcsid[] = "$NetBSD: preen.c,v 1.11 1995/03/18 14:55:59 cgd Exp $"; <nl> +static char rcsid[] = "$NetBSD: preen.c,v 1.12 1996/05/11 14:27:50 mycroft Exp $"; <nl>  #endif <nl>  #endif /* not lint */ <nl>   <nl> @@ -326,6 +326,10 @@ retry: <nl>  		newname = unrawname(newname); <nl>  		retried++; <nl>  		goto retry; <nl> +	} else if ((fsp = getfsfile(newname)) != 0 && !retried) { <nl> +		newname = fsp->fs_spec; <nl> +		retried++; <nl> +		goto retry; <nl>  	} <nl>  	/* <nl>  	 * Not a block or character device, just return name and
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: isa.c,v 1.15 1996/08/15 05:26:19 deraadt Exp $	*/ <nl> +/*	$OpenBSD: isa.c,v 1.16 1996/08/15 05:30:45 deraadt Exp $	*/ <nl>  /*	$NetBSD: isa.c,v 1.85 1996/05/14 00:31:04 thorpej Exp $	*/ <nl>   <nl>  /*- <nl> @@ -138,6 +138,9 @@ isascan(parent, match) <nl>  	struct isa_attach_args ia; <nl>  	struct emap *io_map, *mem_map, *irq_map, *drq_map; <nl>   <nl> +	if (cf->cf_loc[6] == -1)	/* pnp device, scanned later */ <nl> +		return; <nl> + <nl>  	io_map = find_emap("io"); <nl>  	mem_map = find_emap("mem"); <nl>  	irq_map = find_emap("irq");
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: init_main.c,v 1.222 2014/10/17 01:51:39 tedu Exp $	*/ <nl> +/*	$OpenBSD: init_main.c,v 1.223 2014/10/25 12:53:14 miod Exp $	*/ <nl>  /*	$NetBSD: init_main.c,v 1.84.4.1 1996/06/02 09:08:06 mrg Exp $	*/ <nl>   <nl>  /* <nl> @@ -531,7 +531,7 @@ main(void *framep) <nl>  	if (kthread_create(uvm_aiodone_daemon, NULL, NULL, "aiodoned")) <nl>  		panic("fork aiodoned"); <nl>   <nl> -#ifndef __hppa__ <nl> +#if !defined(__hppa__) && !(defined(__m88k__) && defined(MULTIPROCESSOR)) <nl>  	/* Create the page zeroing kernel thread. */ <nl>  	if (kthread_create(uvm_pagezero_thread, NULL, NULL, "zerothread")) <nl>  		panic("fork zerothread");
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: inp.c,v 1.37 2013/11/26 13:19:07 deraadt Exp $	*/ <nl> +/*	$OpenBSD: inp.c,v 1.38 2014/10/08 04:06:23 doug Exp $	*/ <nl>   <nl>  /* <nl>   * patch - a program to apply diffs to original files <nl> @@ -111,7 +111,7 @@ reallocate_lines(size_t *lines_allocated) <nl>  	size_t	new_size; <nl>   <nl>  	new_size = *lines_allocated * 3 / 2; <nl> -	p = realloc(i_ptr, (new_size + 2) * sizeof(char *)); <nl> +	p = reallocarray(i_ptr, new_size + 2, sizeof(char *)); <nl>  	if (p == NULL) {	/* shucks, it was a near thing */ <nl>  		munmap(i_womp, i_size); <nl>  		i_womp = NULL;
@@ -1,4 +1,4 @@ <nl> -/* $OpenBSD: policy.c,v 1.75 2004/06/20 15:24:05 ho Exp $	 */ <nl> +/* $OpenBSD: policy.c,v 1.76 2004/06/24 15:58:58 hshoexer Exp $	 */ <nl>  /* $EOM: policy.c,v 1.49 2000/10/24 13:33:39 niklas Exp $ */ <nl>   <nl>  /* <nl> @@ -2264,7 +2264,8 @@ keynote_cert_get_key(void *scert, void *keyp) <nl>   <nl>  	kl = kn_get_licensees(kid, sid); <nl>  	while (kl) { <nl> -		if (kl->key_alg == KEYNOTE_ALGORITHM_RSA) { <nl> +		if (kl->key_alg == KEYNOTE_ALGORITHM_RSA || <nl> +		    kl->key_alg == KEYNOTE_ALGORITHM_X509) { <nl>  			*(RSA **)keyp = RSAPublicKey_dup(kl->key_key); <nl>  			break; <nl>  		}
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: kern_malloc.c,v 1.31 2001/05/14 08:03:13 angelos Exp $	*/ <nl> +/*	$OpenBSD: kern_malloc.c,v 1.32 2001/06/21 14:27:13 niklas Exp $	*/ <nl>  /*	$NetBSD: kern_malloc.c,v 1.15.4.2 1996/06/13 17:10:56 cgd Exp $	*/ <nl>   <nl>  /* <nl> @@ -341,6 +341,12 @@ free(addr, type) <nl>  		return; <nl>  #endif <nl>   <nl> +#ifdef DIAGNOSTIC <nl> +	if (addr < (void *)kmembase || addr >= (void *)kmemlimit) <nl> +		panic("free of non-malloced addr %p type %s", addr, <nl> +		    memname[type]); <nl> +#endif <nl> + <nl>  	kup = btokup(addr); <nl>  	size = 1 << kup->ku_indx; <nl>  	kbp = &bucket[kup->ku_indx];
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: zdump.c,v 1.10 2015/04/23 05:26:33 deraadt Exp $ */ <nl> +/*	$OpenBSD: zdump.c,v 1.11 2015/10/12 01:40:09 deraadt Exp $ */ <nl>  /* <nl>  ** This file is in the public domain, so clarified as of <nl>  ** 2009-05-17 by Arthur David Olson. <nl> @@ -121,6 +121,9 @@ main(int argc, char *argv[]) <nl>  	struct tm	tm, newtm, *tmp, *newtmp; <nl>  	char		**fakeenv; <nl>   <nl> +	if (pledge("stdio", NULL) == -1) <nl> +		perror("pledge"); <nl> + <nl>  	while ((c = getopt(argc, argv, "c:v")) == 'c' || c == 'v') { <nl>  		switch (c) { <nl>  		case 'v':
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: if_ethersubr.c,v 1.240 2016/10/10 02:44:17 dlg Exp $	*/ <nl> +/*	$OpenBSD: if_ethersubr.c,v 1.241 2016/10/11 11:40:12 mikeb Exp $	*/ <nl>  /*	$NetBSD: if_ethersubr.c,v 1.19 1996/05/07 02:40:30 thorpej Exp $	*/ <nl>   <nl>  /* <nl> @@ -319,6 +319,10 @@ ether_input(struct ifnet *ifp, struct mbuf *m, void *cookie) <nl>  	struct ether_header *eh_tmp; <nl>  #endif <nl>   <nl> +	/* Drop short frames */ <nl> +	if (m->m_len < ETHER_HDR_LEN) <nl> +		goto dropanyway; <nl> + <nl>  	ac = (struct arpcom *)ifp; <nl>  	eh = mtod(m, struct ether_header *); <nl>  	m_adj(m, ETHER_HDR_LEN); <nl> @@ -435,7 +439,8 @@ decapsulate: <nl>  		return (1); <nl>  #endif <nl>  	default: <nl> -		if (llcfound || etype > ETHERMTU) <nl> +		if (llcfound || etype > ETHERMTU || <nl> +		    m->m_len < sizeof(struct llc)) <nl>  			goto dropanyway; <nl>  		llcfound = 1; <nl>  		l = mtod(m, struct llc *);
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: relay_http.c,v 1.17 2014/04/15 22:35:11 andre Exp $	*/ <nl> +/*	$OpenBSD: relay_http.c,v 1.18 2014/04/20 16:18:32 reyk Exp $	*/ <nl>   <nl>  /* <nl>   * Copyright (c) 2006 - 2012 Reyk Floeter <reyk@openbsd.org> <nl> @@ -896,7 +896,8 @@ relay_expand_http(struct ctl_relay_event *cre, char *val, char *buf, size_t len) <nl>  	struct relay	*rlay = con->se_relay; <nl>  	char		 ibuf[128]; <nl>   <nl> -	(void)strlcpy(buf, val, len); <nl> +	if (strlcpy(buf, val, len) >= len) <nl> +		return (NULL); <nl>   <nl>  	if (strstr(val, "$REMOTE_") != NULL) { <nl>  		if (strstr(val, "$REMOTE_ADDR") != NULL) {
@@ -1344,12 +1344,12 @@ std::string controller::bookmark( <nl>  	std::string bookmark_cmd = cfg.get_configvalue("bookmark-cmd"); <nl>  	bool is_interactive = cfg.get_configvalue_as_bool("bookmark-interactive"); <nl>  	if (bookmark_cmd.length() > 0) { <nl> -		std::string cmdline = strprintf::fmt("%s '%s' %s %s %s", <nl> +		std::string cmdline = strprintf::fmt("%s '%s' '%s' '%s' '%s'", <nl>  		                                       bookmark_cmd, <nl>  		                                       utils::replace_all(url,"'", "%27"), <nl> -		                                       quote_empty(stfl::quote(title)), <nl> -		                                       quote_empty(stfl::quote(description)), <nl> -		                                       quote_empty(stfl::quote(feed_title))); <nl> +		                                       utils::replace_all(title,"'", "%27"), <nl> +		                                       utils::replace_all(description,"'", "%27"), <nl> +		                                       utils::replace_all(feed_title,"'", "%27")); <nl>   <nl>  		LOG(level::DEBUG, "controller::bookmark: cmd = %s", cmdline); <nl>  
@@ -751,8 +751,7 @@ int unix_listen_opts(QemuOpts *opts, Error **errp) <nl>          qemu_opt_set(opts, "path", un.sun_path, &error_abort); <nl>      } <nl>   <nl> -    if ((access(un.sun_path, F_OK) == 0) && <nl> -        unlink(un.sun_path) < 0) { <nl> +    if (unlink(un.sun_path) < 0 && errno != ENOENT) { <nl>          error_setg_errno(errp, errno, <nl>                           "Failed to unlink socket %s", un.sun_path); <nl>          goto err;
@@ -545,6 +545,11 @@ static int usb_serial_initfn(USBDevice *dev) <nl>      USBSerialState *s = DO_UPCAST(USBSerialState, dev, dev); <nl>      s->dev.speed = USB_SPEED_FULL; <nl>   <nl> +    if (!s->cs) { <nl> +        error_report("Property chardev is required"); <nl> +        return -1; <nl> +    } <nl> + <nl>      qemu_chr_add_handlers(s->cs, usb_serial_can_read, usb_serial_read, <nl>                            usb_serial_event, s); <nl>      usb_serial_handle_reset(dev);
@@ -120,6 +120,12 @@ DMAContext *spapr_tce_new_dma_context(uint32_t liobn, size_t window_size) <nl>  { <nl>      sPAPRTCETable *tcet; <nl>   <nl> +    if (spapr_tce_find_by_liobn(liobn)) { <nl> +        fprintf(stderr, "Attempted to create TCE table with duplicate" <nl> +                " LIOBN 0x%x\n", liobn); <nl> +        return NULL; <nl> +    } <nl> + <nl>      if (!window_size) { <nl>          return NULL; <nl>      }
@@ -2662,11 +2662,12 @@ static void disas_pc_rel_adr(DisasContext *s, uint32_t insn) <nl>  { <nl>      unsigned int page, rd; <nl>      uint64_t base; <nl> -    int64_t offset; <nl> +    uint64_t offset; <nl>   <nl>      page = extract32(insn, 31, 1); <nl>      /* SignExtend(immhi:immlo) -> offset */ <nl> -    offset = ((int64_t)sextract32(insn, 5, 19) << 2) | extract32(insn, 29, 2); <nl> +    offset = sextract64(insn, 5, 19); <nl> +    offset = offset << 2 | extract32(insn, 29, 2); <nl>      rd = extract32(insn, 0, 5); <nl>      base = s->pc - 4; <nl>  
@@ -736,8 +736,9 @@ static inline int cpu_interrupts_enabled(CPUSPARCState *env1) <nl>      if (env1->psret != 0) <nl>          return 1; <nl>  #else <nl> -    if (env1->pstate & PS_IE) <nl> +    if ((env1->pstate & PS_IE) && !cpu_hypervisor_mode(env1)) { <nl>          return 1; <nl> +    } <nl>  #endif <nl>   <nl>      return 0;
@@ -2191,7 +2191,7 @@ static int decode_gusa(DisasContext *ctx, CPUSH4State *env, int *pmax_insns) <nl>      } <nl>   <nl>      /* If op_src is not a valid register, then op_arg was a constant.  */ <nl> -    if (op_src < 0) { <nl> +    if (op_src < 0 && !TCGV_IS_UNUSED(op_arg)) { <nl>          tcg_temp_free_i32(op_arg); <nl>      } <nl>  
@@ -141,7 +141,7 @@ static void test_dispatch_cmd_io(void) <nl>   <nl>      ret3 = qobject_to_qint(test_qmp_dispatch(req)); <nl>      assert(qint_get_int(ret3) == 66); <nl> -    QDECREF(ret); <nl> +    QDECREF(ret3); <nl>   <nl>      QDECREF(req); <nl>  }
@@ -2948,7 +2948,9 @@ static int img_amend(int argc, char **argv) <nl>      } <nl>   <nl>      if (optind != argc - 1) { <nl> -        error_exit("Expecting one image file name"); <nl> +        error_report("Expecting one image file name"); <nl> +        ret = -1; <nl> +        goto out; <nl>      } <nl>   <nl>      flags = BDRV_O_FLAGS | BDRV_O_RDWR;
@@ -50,6 +50,7 @@ <nl>  #include "qemu/host-utils.h" <nl>  #include "sysemu/qtest.h" <nl>  #include "qemu/error-report.h" <nl> +#include "hw/empty_slot.h" <nl>   <nl>  //#define DEBUG_BOARD_INIT <nl>   <nl> @@ -908,6 +909,11 @@ void mips_malta_init(QEMUMachineInitArgs *args) <nl>      DeviceState *dev = qdev_create(NULL, TYPE_MIPS_MALTA); <nl>      MaltaState *s = MIPS_MALTA(dev); <nl>   <nl> +    /* The whole address space decoded by the GT-64120A doesn't generate <nl> +       exception when accessing invalid memory. Create an empty slot to <nl> +       emulate this feature. */ <nl> +    empty_slot_init(0, 0x20000000); <nl> + <nl>      qdev_init_nofail(dev); <nl>   <nl>      /* Make sure the first 3 serial ports are associated with a device. */
@@ -186,6 +186,7 @@ static void leon3_generic_hw_init(MachineState *machine) <nl>          fprintf(stderr, "Can't read bios image %s\n", filename); <nl>          exit(1); <nl>      } <nl> +    g_free(filename); <nl>   <nl>      /* Can directly load an application. */ <nl>      if (kernel_filename != NULL) {
@@ -161,7 +161,7 @@ vu_message_read(VuDev *dev, int conn_fd, VhostUserMsg *vmsg) <nl>          rc = recvmsg(conn_fd, &msg, 0); <nl>      } while (rc < 0 && (errno == EINTR || errno == EAGAIN)); <nl>   <nl> -    if (rc <= 0) { <nl> +    if (rc < 0) { <nl>          vu_panic(dev, "Error while recvmsg: %s", strerror(errno)); <nl>          return false; <nl>      } <nl> @@ -806,6 +806,8 @@ vu_process_message(VuDev *dev, VhostUserMsg *vmsg) <nl>          return vu_get_queue_num_exec(dev, vmsg); <nl>      case VHOST_USER_SET_VRING_ENABLE: <nl>          return vu_set_vring_enable_exec(dev, vmsg); <nl> +    case VHOST_USER_NONE: <nl> +        break; <nl>      default: <nl>          vmsg_close_fds(vmsg); <nl>          vu_panic(dev, "Unhandled request: %d", vmsg->request);
@@ -510,6 +510,7 @@ static int slirp_smb(SlirpState* s, const char *exported_dir, <nl>              "socket address=127.0.0.1\n" <nl>              "pid directory=%s\n" <nl>              "lock directory=%s\n" <nl> +            "state directory=%s\n" <nl>              "log file=%s/log.smbd\n" <nl>              "smb passwd file=%s/smbpasswd\n" <nl>              "security = share\n" <nl> @@ -522,6 +523,7 @@ static int slirp_smb(SlirpState* s, const char *exported_dir, <nl>              s->smb_dir, <nl>              s->smb_dir, <nl>              s->smb_dir, <nl> +            s->smb_dir, <nl>              exported_dir <nl>              ); <nl>      fclose(f);
@@ -726,7 +726,7 @@ static void ehci_detach(USBPort *port) <nl>      ehci_queues_rip_device(s, port->dev, 0); <nl>      ehci_queues_rip_device(s, port->dev, 1); <nl>   <nl> -    *portsc &= ~(PORTSC_CONNECT|PORTSC_PED); <nl> +    *portsc &= ~(PORTSC_CONNECT|PORTSC_PED|PORTSC_SUSPEND); <nl>      *portsc |= PORTSC_CSC; <nl>   <nl>      ehci_raise_irq(s, USBSTS_PCD);
@@ -1701,7 +1701,13 @@ static void qxl_send_events(PCIQXLDevice *d, uint32_t events) <nl>      uint32_t le_events = cpu_to_le32(events); <nl>   <nl>      trace_qxl_send_events(d->id, events); <nl> -    assert(qemu_spice_display_is_running(&d->ssd)); <nl> +    if (!qemu_spice_display_is_running(&d->ssd)) { <nl> +        /* spice-server tracks guest running state and should not do this */ <nl> +        fprintf(stderr, "%s: spice-server bug: guest stopped, ignoring\n", <nl> +                __func__); <nl> +        trace_qxl_send_events_vm_stopped(d->id, events); <nl> +        return; <nl> +    } <nl>      old_pending = __sync_fetch_and_or(&d->ram->int_pending, le_events); <nl>      if ((old_pending & le_events) == le_events) { <nl>          return;
@@ -1286,7 +1286,7 @@ static int iscsi_open(BlockDriverState *bs, QDict *options, int flags, <nl>      QemuOpts *opts; <nl>      Error *local_err = NULL; <nl>      const char *filename; <nl> -    int i, ret; <nl> +    int i, ret = 0; <nl>   <nl>      if ((BDRV_SECTOR_SIZE % 512) != 0) { <nl>          error_setg(errp, "iSCSI: Invalid BDRV_SECTOR_SIZE. "
@@ -105,7 +105,9 @@ void restore_boot_order(void *opaque) <nl>          return; <nl>      } <nl>   <nl> -    qemu_boot_set(normal_boot_order, NULL); <nl> +    if (boot_set_handler) { <nl> +        qemu_boot_set(normal_boot_order, &error_abort); <nl> +    } <nl>   <nl>      qemu_unregister_reset(restore_boot_order, normal_boot_order); <nl>      g_free(normal_boot_order);
@@ -914,10 +914,16 @@ int rom_add_file(const char *file, const char *fw_dir, <nl>  err: <nl>      if (fd != -1) <nl>          close(fd); <nl> + <nl>      g_free(rom->data); <nl>      g_free(rom->path); <nl>      g_free(rom->name); <nl> +    if (fw_dir) { <nl> +        g_free(rom->fw_dir); <nl> +        g_free(rom->fw_file); <nl> +    } <nl>      g_free(rom); <nl> + <nl>      return -1; <nl>  } <nl>  
@@ -463,6 +463,7 @@ void memory_region_allocate_system_memory(MemoryRegion *mr, Object *owner, <nl>              exit(1); <nl>          } <nl>   <nl> +        host_memory_backend_set_mapped(backend, true); <nl>          memory_region_add_subregion(mr, addr, seg); <nl>          vmstate_register_ram_global(seg); <nl>          addr += size;
@@ -1121,6 +1121,9 @@ static void virtio_serial_device_unrealize(DeviceState *dev, Error **errp) <nl>          timer_free(vser->post_load->timer); <nl>          g_free(vser->post_load); <nl>      } <nl> + <nl> +    qbus_set_hotplug_handler(BUS(&vser->bus), NULL, errp); <nl> + <nl>      virtio_cleanup(vdev); <nl>  } <nl>  
@@ -2099,7 +2099,9 @@ void *address_space_map(AddressSpace *as, <nl>          if (bounce.buffer) { <nl>              return NULL; <nl>          } <nl> -        bounce.buffer = qemu_memalign(TARGET_PAGE_SIZE, TARGET_PAGE_SIZE); <nl> +        /* Avoid unbounded allocations */ <nl> +        l = MIN(l, TARGET_PAGE_SIZE); <nl> +        bounce.buffer = qemu_memalign(TARGET_PAGE_SIZE, l); <nl>          bounce.addr = addr; <nl>          bounce.len = l; <nl>  
@@ -232,6 +232,9 @@ static int tx_consume(Rocker *r, DescInfo *info) <nl>          frag_addr = rocker_tlv_get_le64(tlvs[ROCKER_TLV_TX_FRAG_ATTR_ADDR]); <nl>          frag_len = rocker_tlv_get_le16(tlvs[ROCKER_TLV_TX_FRAG_ATTR_LEN]); <nl>   <nl> +        if (iovcnt >= ROCKER_TX_FRAGS_MAX) { <nl> +            goto err_too_many_frags; <nl> +        } <nl>          iov[iovcnt].iov_len = frag_len; <nl>          iov[iovcnt].iov_base = g_malloc(frag_len); <nl>          if (!iov[iovcnt].iov_base) { <nl> @@ -244,10 +247,7 @@ static int tx_consume(Rocker *r, DescInfo *info) <nl>              err = -ROCKER_ENXIO; <nl>              goto err_bad_io; <nl>          } <nl> - <nl> -        if (++iovcnt > ROCKER_TX_FRAGS_MAX) { <nl> -            goto err_too_many_frags; <nl> -        } <nl> +        iovcnt++; <nl>      } <nl>   <nl>      if (iovcnt) {
@@ -186,6 +186,8 @@ static void vnc_async_encoding_end(VncState *orig, VncState *local) <nl>      orig->hextile = local->hextile; <nl>      orig->zrle = local->zrle; <nl>      orig->lossy_rect = local->lossy_rect; <nl> + <nl> +    queue->buffer = local->output; <nl>  } <nl>   <nl>  static int vnc_worker_thread_loop(VncJobQueue *queue)
@@ -341,7 +341,7 @@ static void qio_channel_websock_handshake_send_res_ok(QIOChannelWebsock *ioc, <nl>      char combined_key[QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN + <nl>                        QIO_CHANNEL_WEBSOCK_GUID_LEN + 1]; <nl>      char *accept = NULL; <nl> -    char *date = qio_channel_websock_date_str(); <nl> +    char *date = NULL; <nl>   <nl>      g_strlcpy(combined_key, key, QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN + 1); <nl>      g_strlcat(combined_key, QIO_CHANNEL_WEBSOCK_GUID, <nl> @@ -360,6 +360,7 @@ static void qio_channel_websock_handshake_send_res_ok(QIOChannelWebsock *ioc, <nl>          return; <nl>      } <nl>   <nl> +    date = qio_channel_websock_date_str(); <nl>      qio_channel_websock_handshake_send_res( <nl>          ioc, QIO_CHANNEL_WEBSOCK_HANDSHAKE_RES_OK, date, accept); <nl>  
@@ -155,7 +155,7 @@ static int virtio_pci_load_config(void * opaque, QEMUFile *f) <nl>   <nl>      /* Try to find out if the guest has bus master disabled, but is <nl>         in ready state. Then we have a buggy guest OS. */ <nl> -    if (!(proxy->vdev->status & VIRTIO_CONFIG_S_DRIVER_OK) && <nl> +    if ((proxy->vdev->status & VIRTIO_CONFIG_S_DRIVER_OK) && <nl>          !(proxy->pci_dev.config[PCI_COMMAND] & PCI_COMMAND_MASTER)) { <nl>          proxy->bugs |= VIRTIO_PCI_BUG_BUS_MASTER; <nl>      }
@@ -594,6 +594,9 @@ static int virtio_serial_load(QEMUFile *f, void *opaque, int version_id) <nl>   <nl>          id = qemu_get_be32(f); <nl>          port = find_port_by_id(s, id); <nl> +        if (!port) { <nl> +            return -EINVAL; <nl> +        } <nl>   <nl>          port->guest_connected = qemu_get_byte(f); <nl>          host_connected = qemu_get_byte(f);
@@ -72,7 +72,7 @@ typedef struct PIIX4PMState { <nl>  #define SMBHSTDAT1 0x06 <nl>  #define SMBBLKDAT 0x07 <nl>   <nl> -PIIX4PMState *pm_state; <nl> +static PIIX4PMState *pm_state; <nl>   <nl>  static uint32_t get_pmtmr(PIIX4PMState *s) <nl>  { <nl> @@ -526,7 +526,9 @@ i2c_bus *piix4_pm_init(PCIBus *bus, int devfn, uint32_t smb_io_base, <nl>  #if defined(TARGET_I386) <nl>  void qemu_system_powerdown(void) <nl>  { <nl> -    if(pm_state->pmen & PWRBTN_EN) { <nl> +    if (!pm_state) { <nl> +        qemu_system_shutdown_request(); <nl> +    } else if (pm_state->pmen & PWRBTN_EN) { <nl>          pm_state->pmsts |= PWRBTN_EN; <nl>  	pm_update_sci(pm_state); <nl>      }
@@ -68,13 +68,14 @@ static void json_message_process_token(JSONLexer *lexer, QString *token, JSONTok <nl>          /* Security consideration, we limit total memory allocated per object <nl>           * and the maximum recursion depth that a message can force. <nl>           */ <nl> -        goto out_emit; <nl> +        goto out_emit_bad; <nl>      } <nl>   <nl>      return; <nl>   <nl>  out_emit_bad: <nl> -    /* clear out token list and tell the parser to emit and error <nl> +    /* <nl> +     * Clear out token list and tell the parser to emit an error <nl>       * indication by passing it a NULL list <nl>       */ <nl>      QDECREF(parser->tokens);
@@ -2090,7 +2090,7 @@ static void coroutine_fn v9fs_write(void *opaque) <nl>      offset = 7; <nl>      err = pdu_marshal(pdu, offset, "d", total); <nl>      if (err < 0) { <nl> -        goto out; <nl> +        goto out_qiov; <nl>      } <nl>      err += offset; <nl>      trace_v9fs_write_return(pdu->tag, pdu->id, total, err);
@@ -36,6 +36,8 @@ <nl>   <nl>  #define MAX_IS_ALLOCATED_SEARCH 65536 <nl>   <nl> +#define MAX_INFLIGHT_IO 512 <nl> + <nl>  //#define DEBUG_BLK_MIGRATION <nl>   <nl>  #ifdef DEBUG_BLK_MIGRATION <nl> @@ -665,7 +667,10 @@ static int block_save_iterate(QEMUFile *f, void *opaque) <nl>      blk_mig_lock(); <nl>      while ((block_mig_state.submitted + <nl>              block_mig_state.read_done) * BLOCK_SIZE < <nl> -           qemu_file_get_rate_limit(f)) { <nl> +           qemu_file_get_rate_limit(f) && <nl> +           (block_mig_state.submitted + <nl> +            block_mig_state.read_done) < <nl> +           MAX_INFLIGHT_IO) { <nl>          blk_mig_unlock(); <nl>          if (block_mig_state.bulk_completed == 0) { <nl>              /* first finish the bulk phase */
@@ -239,8 +239,11 @@ static int kvm_has_msr_star(CPUState *env) <nl>          if (ret < 0) <nl>              return 0; <nl>   <nl> -        kvm_msr_list = qemu_mallocz(sizeof(msr_list) + <nl> -                                    msr_list.nmsrs * sizeof(msr_list.indices[0])); <nl> +        /* Old kernel modules had a bug and could write beyond the provided <nl> +           memory. Allocate at least a safe amount of 1K. */ <nl> +        kvm_msr_list = qemu_mallocz(MAX(1024, sizeof(msr_list) + <nl> +                                              msr_list.nmsrs * <nl> +                                              sizeof(msr_list.indices[0]))); <nl>   <nl>          kvm_msr_list->nmsrs = msr_list.nmsrs; <nl>          ret = kvm_ioctl(env->kvm_state, KVM_GET_MSR_INDEX_LIST, kvm_msr_list);
@@ -1345,6 +1345,9 @@ static int inc_refcounts(BlockDriverState *bs, <nl>          if (refcount == s->refcount_max) { <nl>              fprintf(stderr, "ERROR: overflow cluster offset=0x%" PRIx64 <nl>                      "\n", cluster_offset); <nl> +            fprintf(stderr, "Use qemu-img amend to increase the refcount entry " <nl> +                    "width or qemu-img convert to create a clean copy if the " <nl> +                    "image cannot be opened for writing\n"); <nl>              res->corruptions++; <nl>              continue; <nl>          }
@@ -2351,6 +2351,8 @@ static void disas_ldst_reg_imm9(DisasContext *s, uint32_t insn, <nl>          post_index = false; <nl>          writeback = true; <nl>          break; <nl> +    default: <nl> +        g_assert_not_reached(); <nl>      } <nl>   <nl>      if (rn == 31) {
@@ -1033,7 +1033,6 @@ int vhost_dev_init(struct vhost_dev *hdev, void *opaque, <nl>          r = -1; <nl>          goto fail; <nl>      } <nl> -    QLIST_INSERT_HEAD(&vhost_devices, hdev, entry); <nl>   <nl>      r = hdev->vhost_ops->vhost_set_owner(hdev); <nl>      if (r < 0) { <nl> @@ -1103,6 +1102,7 @@ int vhost_dev_init(struct vhost_dev *hdev, void *opaque, <nl>      hdev->started = false; <nl>      hdev->memory_changed = false; <nl>      memory_listener_register(&hdev->memory_listener, &address_space_memory); <nl> +    QLIST_INSERT_HEAD(&vhost_devices, hdev, entry); <nl>      return 0; <nl>  fail_busyloop: <nl>      while (--i >= 0) { <nl> @@ -1126,7 +1126,11 @@ void vhost_dev_cleanup(struct vhost_dev *hdev) <nl>      for (i = 0; i < hdev->nvqs; ++i) { <nl>          vhost_virtqueue_cleanup(hdev->vqs + i); <nl>      } <nl> -    memory_listener_unregister(&hdev->memory_listener); <nl> +    if (hdev->mem) { <nl> +        /* those are only safe after successful init */ <nl> +        memory_listener_unregister(&hdev->memory_listener); <nl> +        QLIST_REMOVE(hdev, entry); <nl> +    } <nl>      if (hdev->migration_blocker) { <nl>          migrate_del_blocker(hdev->migration_blocker); <nl>          error_free(hdev->migration_blocker); <nl> @@ -1135,7 +1139,6 @@ void vhost_dev_cleanup(struct vhost_dev *hdev) <nl>      g_free(hdev->mem_sections); <nl>      hdev->vhost_ops->vhost_backend_cleanup(hdev); <nl>      assert(!hdev->log); <nl> -    QLIST_REMOVE(hdev, entry); <nl>  } <nl>   <nl>  /* Stop processing guest IO notifications in qemu.
@@ -728,20 +728,18 @@ static int virtio_blk_device_init(VirtIODevice *vdev) <nl>      return 0; <nl>  } <nl>   <nl> -static int virtio_blk_device_exit(DeviceState *dev) <nl> +static void virtio_blk_device_exit(VirtIODevice *vdev) <nl>  { <nl> -    VirtIODevice *vdev = VIRTIO_DEVICE(dev); <nl> -    VirtIOBlock *s = VIRTIO_BLK(dev); <nl> +    VirtIOBlock *s = VIRTIO_BLK(vdev); <nl>  #ifdef CONFIG_VIRTIO_BLK_DATA_PLANE <nl>      remove_migration_state_change_notifier(&s->migration_state_notifier); <nl>      virtio_blk_data_plane_destroy(s->dataplane); <nl>      s->dataplane = NULL; <nl>  #endif <nl>      qemu_del_vm_change_state_handler(s->change); <nl> -    unregister_savevm(dev, "virtio-blk", s); <nl> +    unregister_savevm(DEVICE(vdev), "virtio-blk", s); <nl>      blockdev_mark_auto_del(s->bs); <nl>      virtio_cleanup(vdev); <nl> -    return 0; <nl>  } <nl>   <nl>  static Property virtio_blk_properties[] = { <nl> @@ -753,10 +751,10 @@ static void virtio_blk_class_init(ObjectClass *klass, void *data) <nl>  { <nl>      DeviceClass *dc = DEVICE_CLASS(klass); <nl>      VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS(klass); <nl> -    dc->exit = virtio_blk_device_exit; <nl>      dc->props = virtio_blk_properties; <nl>      set_bit(DEVICE_CATEGORY_STORAGE, dc->categories); <nl>      vdc->init = virtio_blk_device_init; <nl> +    vdc->exit = virtio_blk_device_exit; <nl>      vdc->get_config = virtio_blk_update_config; <nl>      vdc->set_config = virtio_blk_set_config; <nl>      vdc->get_features = virtio_blk_get_features;
@@ -100,7 +100,8 @@ static void isa_irq_handler(void *opaque, int n, int level) <nl>      if (n < 16) { <nl>          qemu_set_irq(isa->i8259[n], level); <nl>      } <nl> -    qemu_set_irq(isa->ioapic[n], level); <nl> +    if (isa->ioapic) <nl> +        qemu_set_irq(isa->ioapic[n], level); <nl>  }; <nl>   <nl>  static void ioport80_write(void *opaque, uint32_t addr, uint32_t data)
@@ -504,7 +504,8 @@ void hmp_info_local_apic(Monitor *mon, const QDict *qdict) <nl>   <nl>  void hmp_info_io_apic(Monitor *mon, const QDict *qdict) <nl>  { <nl> -    if (kvm_irqchip_in_kernel()) { <nl> +    if (kvm_irqchip_in_kernel() && <nl> +        !kvm_irqchip_is_split()) { <nl>          kvm_ioapic_dump_state(mon, qdict); <nl>      } else { <nl>          ioapic_dump_state(mon, qdict);
@@ -985,6 +985,10 @@ static void load_linux(PCMachineState *pcms, <nl>          setup_size = 4; <nl>      } <nl>      setup_size = (setup_size+1)*512; <nl> +    if (setup_size > kernel_size) { <nl> +        fprintf(stderr, "qemu: invalid kernel header\n"); <nl> +        exit(1); <nl> +    } <nl>      kernel_size -= setup_size; <nl>   <nl>      setup  = g_malloc(setup_size);
@@ -217,7 +217,9 @@ static int vhost_user_call(struct vhost_dev *dev, unsigned long int request, <nl>          for (i = 0; i < dev->mem->nregions; ++i) { <nl>              struct vhost_memory_region *reg = dev->mem->regions + i; <nl>              ram_addr_t ram_addr; <nl> -            qemu_ram_addr_from_host((void *)reg->userspace_addr, &ram_addr); <nl> + <nl> +            assert((uintptr_t)reg->userspace_addr == reg->userspace_addr); <nl> +            qemu_ram_addr_from_host((void *)(uintptr_t)reg->userspace_addr, &ram_addr); <nl>              fd = qemu_get_ram_fd(ram_addr); <nl>              if (fd > 0) { <nl>                  msg.memory.regions[fd_num].userspace_addr = reg->userspace_addr;
@@ -122,8 +122,12 @@ void watchdog_perform_action(void) <nl>          exit(0); <nl>   <nl>      case WDT_PAUSE:             /* same as 'stop' command in monitor */ <nl> +        /* In a timer callback, when vm_stop calls qemu_clock_enable <nl> +         * you would get a deadlock.  Bypass the problem. <nl> +         */ <nl> +        qemu_system_vmstop_request_prepare(); <nl>          qapi_event_send_watchdog(WATCHDOG_EXPIRATION_ACTION_PAUSE, &error_abort); <nl> -        vm_stop(RUN_STATE_WATCHDOG); <nl> +        qemu_system_vmstop_request(RUN_STATE_WATCHDOG); <nl>          break; <nl>   <nl>      case WDT_DEBUG:
@@ -2097,6 +2097,8 @@ static void qemu_rdma_cleanup(RDMAContext *rdma) <nl>          rdma_destroy_event_channel(rdma->channel); <nl>          rdma->channel = NULL; <nl>      } <nl> +    g_free(rdma->host); <nl> +    rdma->host = NULL; <nl>  } <nl>   <nl>  
@@ -167,10 +167,6 @@ static PixelFormat sdl_to_qemu_pixelformat(SDL_PixelFormat *sdl_pf) <nl>  static DisplaySurface* sdl_create_displaysurface(int width, int height) <nl>  { <nl>      DisplaySurface *surface = (DisplaySurface*) g_malloc0(sizeof(DisplaySurface)); <nl> -    if (surface == NULL) { <nl> -        fprintf(stderr, "sdl_create_displaysurface: malloc failed\n"); <nl> -        exit(1); <nl> -    } <nl>   <nl>      surface->width = width; <nl>      surface->height = height;
@@ -3677,6 +3677,7 @@ static int vnc_display_listen_addr(VncDisplay *vd, <nl>          qio_channel_set_name(QIO_CHANNEL(sioc), name); <nl>          if (qio_channel_socket_listen_sync( <nl>                  sioc, rawaddrs[i], listenerr == NULL ? &listenerr : NULL) < 0) { <nl> +            object_unref(OBJECT(sioc)); <nl>              continue; <nl>          } <nl>          listening = true;
@@ -699,6 +699,12 @@ void virtio_scsi_common_realize(DeviceState *dev, Error **errp, <nl>      virtio_init(vdev, "virtio-scsi", VIRTIO_ID_SCSI, <nl>                  sizeof(VirtIOSCSIConfig)); <nl>   <nl> +    if (s->conf.num_queues <= 0 || s->conf.num_queues > VIRTIO_PCI_QUEUE_MAX) { <nl> +        error_setg(errp, "Invalid number of queues (= %" PRId32 "), " <nl> +                         "must be a positive integer less than %d.", <nl> +                   s->conf.num_queues, VIRTIO_PCI_QUEUE_MAX); <nl> +        return; <nl> +    } <nl>      s->cmd_vqs = g_malloc0(s->conf.num_queues * sizeof(VirtQueue *)); <nl>      s->sense_size = VIRTIO_SCSI_SENSE_SIZE; <nl>      s->cdb_size = VIRTIO_SCSI_CDB_SIZE;
@@ -144,6 +144,7 @@ static void xlnx_zynqmp_realize(DeviceState *dev, Error **errp) <nl>          } else { <nl>              s->boot_cpu_ptr = &s->apu_cpu[i]; <nl>          } <nl> +        g_free(name); <nl>   <nl>          object_property_set_int(OBJECT(&s->apu_cpu[i]), GIC_BASE_ADDR, <nl>                                  "reset-cbar", &err); <nl> @@ -181,6 +182,7 @@ static void xlnx_zynqmp_realize(DeviceState *dev, Error **errp) <nl>          } else { <nl>              s->boot_cpu_ptr = &s->rpu_cpu[i]; <nl>          } <nl> +        g_free(name); <nl>   <nl>          object_property_set_bool(OBJECT(&s->rpu_cpu[i]), true, "reset-hivecs", <nl>                                   &err);
@@ -791,6 +791,9 @@ static int rtl8139_can_receive(VLANClientState *nc) <nl>        return 1; <nl>      if (!rtl8139_receiver_enabled(s)) <nl>        return 1; <nl> +    /* network/host communication happens only in normal mode */ <nl> +    if ((s->Cfg9346 & Chip9346_op_mask) != Cfg9346_Normal) <nl> +	return 0; <nl>   <nl>      if (rtl8139_cp_receiver_enabled(s)) { <nl>          /* ??? Flow control not implemented in c+ mode. <nl> @@ -833,6 +836,12 @@ static ssize_t rtl8139_do_receive(VLANClientState *nc, const uint8_t *buf, size_ <nl>          return -1; <nl>      } <nl>   <nl> +    /* check whether we are in normal mode */ <nl> +    if ((s->Cfg9346 & Chip9346_op_mask) != Cfg9346_Normal) { <nl> +        DPRINTF("not in normal op mode\n"); <nl> +        return -1; <nl> +    } <nl> + <nl>      /* XXX: check this */ <nl>      if (s->RxConfig & AcceptAllPhys) { <nl>          /* promiscuous: receive all */
@@ -694,7 +694,8 @@ static void eepro100_cu_command(EEPRO100State * s, uint8_t val) <nl>                  logout <nl>                      ("illegal values of TBD array address and TCB byte count!\n"); <nl>              } <nl> -            uint8_t buf[MAX_ETH_FRAME_SIZE + 4]; <nl> +            // sends larger than MAX_ETH_FRAME_SIZE are allowed, up to 2600 bytes <nl> +            uint8_t buf[2600]; <nl>              uint16_t size = 0; <nl>              uint32_t tbd_address = cb_address + 0x10; <nl>              assert(tcb_bytes <= sizeof(buf)); <nl> @@ -706,6 +707,7 @@ static void eepro100_cu_command(EEPRO100State * s, uint8_t val) <nl>                  logout <nl>                      ("TBD (simplified mode): buffer address 0x%08x, size 0x%04x\n", <nl>                       tx_buffer_address, tx_buffer_size); <nl> +                tx_buffer_size = MIN(tx_buffer_size, sizeof(buf) - size); <nl>                  cpu_physical_memory_read(tx_buffer_address, &buf[size], <nl>                                           tx_buffer_size); <nl>                  size += tx_buffer_size; <nl> @@ -726,6 +728,7 @@ static void eepro100_cu_command(EEPRO100State * s, uint8_t val) <nl>                          logout <nl>                              ("TBD (extended flexible mode): buffer address 0x%08x, size 0x%04x\n", <nl>                               tx_buffer_address, tx_buffer_size); <nl> +                        tx_buffer_size = MIN(tx_buffer_size, sizeof(buf) - size); <nl>                          cpu_physical_memory_read(tx_buffer_address, &buf[size], <nl>                                                   tx_buffer_size); <nl>                          size += tx_buffer_size; <nl> @@ -743,6 +746,7 @@ static void eepro100_cu_command(EEPRO100State * s, uint8_t val) <nl>                      logout <nl>                          ("TBD (flexible mode): buffer address 0x%08x, size 0x%04x\n", <nl>                           tx_buffer_address, tx_buffer_size); <nl> +                    tx_buffer_size = MIN(tx_buffer_size, sizeof(buf) - size); <nl>                      cpu_physical_memory_read(tx_buffer_address, &buf[size], <nl>                                               tx_buffer_size); <nl>                      size += tx_buffer_size;
@@ -4040,7 +4040,7 @@ int coroutine_fn bdrv_is_allocated(BlockDriverState *bs, int64_t sector_num, <nl>      if (ret < 0) { <nl>          return ret; <nl>      } <nl> -    return (ret & BDRV_BLOCK_ALLOCATED); <nl> +    return !!(ret & BDRV_BLOCK_ALLOCATED); <nl>  } <nl>   <nl>  /*
@@ -38,7 +38,7 @@ void arp_table_add(Slirp *slirp, uint32_t ip_addr, uint8_t ethaddr[ETH_ALEN]) <nl>                  ethaddr[3], ethaddr[4], ethaddr[5])); <nl>   <nl>      /* Check 0.0.0.0/8 invalid source-only addresses */ <nl> -    if ((ip_addr & htonl(~(0xf << 28))) == 0) { <nl> +    if ((ip_addr & htonl(~(0xfU << 28))) == 0) { <nl>          return; <nl>      } <nl>   <nl> @@ -74,7 +74,7 @@ bool arp_table_search(Slirp *slirp, uint32_t ip_addr, <nl>      DEBUG_ARG("ip = 0x%x", ip_addr); <nl>   <nl>      /* Check 0.0.0.0/8 invalid source-only addresses */ <nl> -    assert((ip_addr & htonl(~(0xf << 28))) != 0); <nl> +    assert((ip_addr & htonl(~(0xfU << 28))) != 0); <nl>   <nl>      /* If broadcast address */ <nl>      if (ip_addr == 0xffffffff || ip_addr == broadcast_addr) {
@@ -348,6 +348,6 @@ int qemu_create_pidfile(const char *filename) <nl>          return -1; <nl>      } <nl>   <nl> -    close(fd); <nl> +    /* keep pidfile open & locked forever */ <nl>      return 0; <nl>  }
@@ -213,6 +213,12 @@ static void filter_mirror_setup(NetFilterState *nf, Error **errp) <nl>      MirrorState *s = FILTER_MIRROR(nf); <nl>      Chardev *chr; <nl>   <nl> +    if (s->outdev == NULL) { <nl> +        error_set(errp, ERROR_CLASS_DEVICE_NOT_FOUND, "filter-mirror parameter"\ <nl> +                  " 'outdev' cannot be empty"); <nl> +        return; <nl> +    } <nl> + <nl>      chr = qemu_chr_find(s->outdev); <nl>      if (chr == NULL) { <nl>          error_set(errp, ERROR_CLASS_DEVICE_NOT_FOUND,
@@ -1699,6 +1699,7 @@ static int aio_write_f(BlockBackend *blk, int argc, char **argv) <nl>          int64_t count = cvtnum(argv[optind]); <nl>          if (count < 0) { <nl>              print_cvtnum_err(count, argv[optind]); <nl> +            g_free(ctx); <nl>              return 0; <nl>          } <nl>  
@@ -493,7 +493,7 @@ address_space_translate_for_iotlb(CPUState *cpu, int asidx, hwaddr addr, <nl>                                    hwaddr *xlat, hwaddr *plen) <nl>  { <nl>      MemoryRegionSection *section; <nl> -    AddressSpaceDispatch *d = cpu->cpu_ases[asidx].memory_dispatch; <nl> +    AddressSpaceDispatch *d = atomic_rcu_read(&cpu->cpu_ases[asidx].memory_dispatch); <nl>   <nl>      section = address_space_translate_internal(d, addr, xlat, plen, false); <nl>   <nl> @@ -2376,7 +2376,7 @@ static void tcg_commit(MemoryListener *listener) <nl>       * may have split the RCU critical section. <nl>       */ <nl>      d = atomic_rcu_read(&cpuas->as->dispatch); <nl> -    cpuas->memory_dispatch = d; <nl> +    atomic_rcu_set(&cpuas->memory_dispatch, d); <nl>      tlb_flush(cpuas->cpu, 1); <nl>  } <nl>  
@@ -466,6 +466,8 @@ process_tx_desc(E1000State *s, struct e1000_tx_desc *dp) <nl>              bytes = split_size; <nl>              if (tp->size + bytes > msh) <nl>                  bytes = msh - tp->size; <nl> + <nl> +            bytes = MIN(sizeof(tp->data) - tp->size, bytes); <nl>              pci_dma_read(&s->dev, addr, tp->data + tp->size, bytes); <nl>              if ((sz = tp->size + bytes) >= hdr && tp->size < hdr) <nl>                  memmove(tp->header, tp->data, hdr); <nl> @@ -481,6 +483,7 @@ process_tx_desc(E1000State *s, struct e1000_tx_desc *dp) <nl>          // context descriptor TSE is not set, while data descriptor TSE is set <nl>          DBGOUT(TXERR, "TCP segmentaion Error\n"); <nl>      } else { <nl> +        split_size = MIN(sizeof(tp->data) - tp->size, split_size); <nl>          pci_dma_read(&s->dev, addr, tp->data + tp->size, split_size); <nl>          tp->size += split_size; <nl>      }
@@ -818,14 +818,14 @@ static void exynos4210_ltick_recalc_count(struct tick_timer *s) <nl>           */ <nl>   <nl>          if (s->last_tcnto) { <nl> -            to_count = s->last_tcnto * s->last_icnto; <nl> +            to_count = (uint64_t)s->last_tcnto * s->last_icnto; <nl>          } else { <nl>              to_count = s->last_icnto; <nl>          } <nl>      } else { <nl>          /* distance is passed, recalculate with tcnto * icnto */ <nl>          if (s->icntb) { <nl> -            s->distance = s->tcntb * s->icntb; <nl> +            s->distance = (uint64_t)s->tcntb * s->icntb; <nl>          } else { <nl>              s->distance = s->tcntb; <nl>          }
@@ -1263,7 +1263,7 @@ int qcow2_alloc_cluster_offset(BlockDriverState *bs, uint64_t offset, <nl>   <nl>  again: <nl>      start = offset; <nl> -    remaining = *num << BDRV_SECTOR_BITS; <nl> +    remaining = (uint64_t)*num << BDRV_SECTOR_BITS; <nl>      cluster_offset = 0; <nl>      *host_offset = 0; <nl>      cur_bytes = 0;
@@ -806,7 +806,7 @@ static int (* const net_client_init_fun[NET_CLIENT_OPTIONS_KIND_MAX])( <nl>  #ifdef CONFIG_VHOST_NET_USED <nl>          [NET_CLIENT_OPTIONS_KIND_VHOST_USER] = net_init_vhost_user, <nl>  #endif <nl> -#ifdef CONFIG_LINUX <nl> +#ifdef CONFIG_L2TPV3 <nl>          [NET_CLIENT_OPTIONS_KIND_L2TPV3]    = net_init_l2tpv3, <nl>  #endif <nl>  }; <nl> @@ -845,7 +845,7 @@ static int net_client_init1(const void *object, int is_netdev, Error **errp) <nl>  #ifdef CONFIG_VHOST_NET_USED <nl>          case NET_CLIENT_OPTIONS_KIND_VHOST_USER: <nl>  #endif <nl> -#ifdef CONFIG_LINUX <nl> +#ifdef CONFIG_L2TPV3 <nl>          case NET_CLIENT_OPTIONS_KIND_L2TPV3: <nl>  #endif <nl>              break;
@@ -698,7 +698,7 @@ static uint32_t nvic_readl(NVICState *s, uint32_t offset, MemTxAttrs attrs) <nl>          return ((s->num_irq - NVIC_FIRST_IRQ) / 32) - 1; <nl>      case 0x380 ... 0x3bf: /* NVIC_ITNS<n> */ <nl>      { <nl> -        int startvec = 32 * (offset - 0x380) + NVIC_FIRST_IRQ; <nl> +        int startvec = 8 * (offset - 0x380) + NVIC_FIRST_IRQ; <nl>          int i; <nl>   <nl>          if (!arm_feature(&cpu->env, ARM_FEATURE_V8)) { <nl> @@ -1102,7 +1102,7 @@ static void nvic_writel(NVICState *s, uint32_t offset, uint32_t value, <nl>      switch (offset) { <nl>      case 0x380 ... 0x3bf: /* NVIC_ITNS<n> */ <nl>      { <nl> -        int startvec = 32 * (offset - 0x380) + NVIC_FIRST_IRQ; <nl> +        int startvec = 8 * (offset - 0x380) + NVIC_FIRST_IRQ; <nl>          int i; <nl>   <nl>          if (!arm_feature(&cpu->env, ARM_FEATURE_V8)) {
@@ -111,7 +111,7 @@ uint16_t pvpanic_port(void) <nl>      if (!o) { <nl>          return 0; <nl>      } <nl> -    return object_property_get_int(o, PVPANIC_IOPORT_PROP, NULL); <nl> +    return object_property_get_uint(o, PVPANIC_IOPORT_PROP, NULL); <nl>  } <nl>   <nl>  static Property pvpanic_isa_properties[] = {
@@ -1004,8 +1004,6 @@ int bdrv_open_backing_file(BlockDriverState *bs, QDict *options, Error **errp) <nl>      ret = bdrv_open(bs->backing_hd, <nl>                      *backing_filename ? backing_filename : NULL, options, <nl>                      back_flags, back_drv, &local_err); <nl> -    pstrcpy(bs->backing_file, sizeof(bs->backing_file), <nl> -            bs->backing_hd->file->filename); <nl>      if (ret < 0) { <nl>          bdrv_unref(bs->backing_hd); <nl>          bs->backing_hd = NULL; <nl> @@ -1013,6 +1011,8 @@ int bdrv_open_backing_file(BlockDriverState *bs, QDict *options, Error **errp) <nl>          error_propagate(errp, local_err); <nl>          return ret; <nl>      } <nl> +    pstrcpy(bs->backing_file, sizeof(bs->backing_file), <nl> +            bs->backing_hd->file->filename); <nl>      return 0; <nl>  } <nl>  
@@ -105,7 +105,6 @@ static void pm_update_sci(PIIX4PMState *s) <nl>      if ((s->pmen & TMROF_EN) && !(pmsts & TMROF_EN)) { <nl>          expire_time = muldiv64(s->tmr_overflow_time, ticks_per_sec, PM_FREQ); <nl>          qemu_mod_timer(s->tmr_timer, expire_time); <nl> -        s->tmr_overflow_time += 0x800000; <nl>      } else { <nl>          qemu_del_timer(s->tmr_timer); <nl>      }
@@ -869,8 +869,10 @@ static void do_pci_unregister_device(PCIDevice *pci_dev) <nl>      pci_dev->bus->devices[pci_dev->devfn] = NULL; <nl>      pci_config_free(pci_dev); <nl>   <nl> -    memory_region_del_subregion(&pci_dev->bus_master_container_region, <nl> -                                &pci_dev->bus_master_enable_region); <nl> +    if (memory_region_is_mapped(&pci_dev->bus_master_enable_region)) { <nl> +        memory_region_del_subregion(&pci_dev->bus_master_container_region, <nl> +                                    &pci_dev->bus_master_enable_region); <nl> +    } <nl>      address_space_destroy(&pci_dev->bus_master_as); <nl>  } <nl>  
@@ -22,6 +22,15 @@ <nl>  #include "cpu.h" <nl>  #include "qemu-common.h" <nl>  #include "exec/exec-all.h" <nl> +#include "qemu/error-report.h" <nl> + <nl> +static hwaddr tricore_cpu_get_phys_page_attrs_debug(CPUState *cpu, vaddr addr, <nl> +                                         MemTxAttrs *attrs) <nl> +{ <nl> +    error_report("function cpu_get_phys_page_attrs_debug not " <nl> +                    "implemented, aborting"); <nl> +    return -1; <nl> +} <nl>   <nl>  static inline void set_feature(CPUTriCoreState *env, int feature) <nl>  { <nl> @@ -176,6 +185,7 @@ static void tricore_cpu_class_init(ObjectClass *c, void *data) <nl>      cc->dump_state = tricore_cpu_dump_state; <nl>      cc->set_pc = tricore_cpu_set_pc; <nl>      cc->synchronize_from_tb = tricore_cpu_synchronize_from_tb; <nl> +    cc->get_phys_page_attrs_debug = tricore_cpu_get_phys_page_attrs_debug; <nl>  } <nl>   <nl>  static void cpu_register(const TriCoreCPUInfo *info)
@@ -1242,7 +1242,7 @@ static void exynos4210_update_resolution(Exynos4210fimdState *s) <nl>  static void exynos4210_fimd_update(void *opaque) <nl>  { <nl>      Exynos4210fimdState *s = (Exynos4210fimdState *)opaque; <nl> -    DisplaySurface *surface = qemu_console_surface(s->console); <nl> +    DisplaySurface *surface; <nl>      Exynos4210fimdWindow *w; <nl>      int i, line; <nl>      hwaddr fb_line_addr, inc_size; <nl> @@ -1255,11 +1255,12 @@ static void exynos4210_fimd_update(void *opaque) <nl>      const int global_height = ((s->vidtcon[2] >> FIMD_VIDTCON2_VER_SHIFT) & <nl>              FIMD_VIDTCON2_SIZE_MASK) + 1; <nl>   <nl> -    if (!s || !s->console || !surface_bits_per_pixel(surface) || <nl> -            !s->enabled) { <nl> +    if (!s || !s->console || !s->enabled || <nl> +        surface_bits_per_pixel(qemu_console_surface(s->console)) == 0) { <nl>          return; <nl>      } <nl>      exynos4210_update_resolution(s); <nl> +    surface = qemu_console_surface(s->console); <nl>   <nl>      for (i = 0; i < NUM_OF_WINDOWS; i++) { <nl>          w = &s->window[i];
@@ -162,8 +162,9 @@ hwaddr s390_cpu_get_phys_page_debug(CPUState *cs, vaddr vaddr) <nl>          vaddr &= 0x7fffffff; <nl>      } <nl>   <nl> -    mmu_translate(env, vaddr, MMU_INST_FETCH, asc, &raddr, &prot, false); <nl> - <nl> +    if (mmu_translate(env, vaddr, MMU_INST_FETCH, asc, &raddr, &prot, false)) { <nl> +        return -1; <nl> +    } <nl>      return raddr; <nl>  } <nl>  
@@ -287,7 +287,9 @@ static void *spapr_create_fdt_skel(const char *cpu_model, <nl>   <nl>          _FDT((fdt_property(fdt, "qemu,boot-kernel", &kprop, sizeof(kprop)))); <nl>      } <nl> -    _FDT((fdt_property_string(fdt, "qemu,boot-device", boot_device))); <nl> +    if (boot_device) { <nl> +        _FDT((fdt_property_string(fdt, "qemu,boot-device", boot_device))); <nl> +    } <nl>      _FDT((fdt_property_cell(fdt, "qemu,graphic-width", graphic_width))); <nl>      _FDT((fdt_property_cell(fdt, "qemu,graphic-height", graphic_height))); <nl>      _FDT((fdt_property_cell(fdt, "qemu,graphic-depth", graphic_depth))); <nl> @@ -964,7 +966,7 @@ static QEMUMachine spapr_machine = { <nl>      .block_default_type = IF_SCSI, <nl>      .max_cpus = MAX_CPUS, <nl>      .no_parallel = 1, <nl> -    DEFAULT_MACHINE_OPTIONS, <nl> +    .boot_order = NULL, <nl>  }; <nl>   <nl>  static void spapr_machine_init(void)
@@ -316,6 +316,7 @@ typedef struct RAMBlock { <nl>  static inline void *ramblock_ptr(RAMBlock *block, ram_addr_t offset) <nl>  { <nl>      assert(offset < block->length); <nl> +    assert(block->host); <nl>      return (char *)block->host + offset; <nl>  } <nl>  
@@ -522,8 +522,8 @@ void nand_setio(DeviceState *dev, uint32_t value) <nl>   <nl>      if (s->ale) { <nl>          unsigned int shift = s->addrlen * 8; <nl> -        unsigned int mask = ~(0xff << shift); <nl> -        unsigned int v = value << shift; <nl> +        uint64_t mask = ~(0xffull << shift); <nl> +        uint64_t v = (uint64_t)value << shift; <nl>   <nl>          s->addr = (s->addr & mask) | v; <nl>          s->addrlen ++;
@@ -790,6 +790,13 @@ static int qemu_rdma_broken_ipv6_kernel(Error **errp, struct ibv_context *verbs) <nl>   <nl>          for (x = 0; x < num_devices; x++) { <nl>              verbs = ibv_open_device(dev_list[x]); <nl> +            if (!verbs) { <nl> +                if (errno == EPERM) { <nl> +                    continue; <nl> +                } else { <nl> +                    return -EINVAL; <nl> +                } <nl> +            } <nl>   <nl>              if (ibv_query_port(verbs, 1, &port_attr)) { <nl>                  ibv_close_device(verbs);
@@ -2929,6 +2929,7 @@ static int enable_write_target(BDRVVVFATState *s, Error **errp) <nl>      set_option_parameter(options, BLOCK_OPT_BACKING_FILE, "fat:"); <nl>   <nl>      ret = bdrv_create(bdrv_qcow, s->qcow_filename, options, errp); <nl> +    free_option_parameters(options); <nl>      if (ret < 0) { <nl>          goto err; <nl>      }
@@ -1139,6 +1139,9 @@ void unregister_savevm(DeviceState *dev, const char *idstr, void *opaque) <nl>      QTAILQ_FOREACH_SAFE(se, &savevm_handlers, entry, new_se) { <nl>          if (strcmp(se->idstr, id) == 0 && se->opaque == opaque) { <nl>              QTAILQ_REMOVE(&savevm_handlers, se, entry); <nl> +            if (se->compat) { <nl> +                qemu_free(se->compat); <nl> +            } <nl>              qemu_free(se); <nl>          } <nl>      } <nl> @@ -1206,6 +1209,9 @@ void vmstate_unregister(DeviceState *dev, const VMStateDescription *vmsd, <nl>      QTAILQ_FOREACH_SAFE(se, &savevm_handlers, entry, new_se) { <nl>          if (se->vmsd == vmsd && se->opaque == opaque) { <nl>              QTAILQ_REMOVE(&savevm_handlers, se, entry); <nl> +            if (se->compat) { <nl> +                qemu_free(se->compat); <nl> +            } <nl>              qemu_free(se); <nl>          } <nl>      }
@@ -277,6 +277,7 @@ static void vhost_scsi_unrealize(DeviceState *dev, Error **errp) <nl>      /* This will stop vhost backend. */ <nl>      vhost_scsi_set_status(vdev, 0); <nl>   <nl> +    vhost_dev_cleanup(&s->dev); <nl>      g_free(s->dev.vqs); <nl>   <nl>      virtio_scsi_common_unrealize(dev, errp);
@@ -4955,6 +4955,8 @@ static QDict *qmp_check_input_obj(QObject *input_obj, Error **errp) <nl>                            "arguments", "object"); <nl>                  return NULL; <nl>              } <nl> +        } else if (!strcmp(arg_name, "id")) { <nl> +            /* Any string is acceptable as "id", so nothing to check */ <nl>          } else { <nl>              error_set(errp, QERR_QMP_EXTRA_MEMBER, arg_name); <nl>              return NULL;
@@ -274,10 +274,9 @@ static bool blit_region_is_unsafe(struct CirrusVGAState *s, <nl>  { <nl>      if (pitch < 0) { <nl>          int64_t min = addr <nl> -            + ((int64_t)s->cirrus_blt_height-1) * pitch; <nl> -        int32_t max = addr <nl> -            + s->cirrus_blt_width; <nl> -        if (min < 0 || max > s->vga.vram_size) { <nl> +            + ((int64_t)s->cirrus_blt_height - 1) * pitch <nl> +            - s->cirrus_blt_width; <nl> +        if (min < -1 || addr >= s->vga.vram_size) { <nl>              return true; <nl>          } <nl>      } else {
@@ -711,6 +711,12 @@ static int qemu_rbd_open(BlockDriverState *bs, QDict *options, int flags, <nl>      name           = qemu_opt_get(opts, "image"); <nl>      keypairs       = qemu_opt_get(opts, "keyvalue-pairs"); <nl>   <nl> +    if (!pool || !name) { <nl> +        error_setg(errp, "Parameters 'pool' and 'image' are required"); <nl> +        r = -EINVAL; <nl> +        goto failed_opts; <nl> +    } <nl> + <nl>      r = rados_create(&s->cluster, clientname); <nl>      if (r < 0) { <nl>          error_setg_errno(errp, -r, "error initializing"); <nl> @@ -718,9 +724,7 @@ static int qemu_rbd_open(BlockDriverState *bs, QDict *options, int flags, <nl>      } <nl>   <nl>      s->snap = g_strdup(snap); <nl> -    if (name) { <nl> -        pstrcpy(s->name, RBD_MAX_IMAGE_NAME_SIZE, name); <nl> -    } <nl> +    pstrcpy(s->name, RBD_MAX_IMAGE_NAME_SIZE, name); <nl>   <nl>      /* try default location when conf=NULL, but ignore failure */ <nl>      r = rados_conf_read_file(s->cluster, conf);
@@ -900,6 +900,10 @@ static int cirrus_bitblt_cputovideo(CirrusVGAState * s) <nl>  { <nl>      int w; <nl>   <nl> +    if (blit_is_unsafe(s, true)) { <nl> +        return 0; <nl> +    } <nl> + <nl>      s->cirrus_blt_mode &= ~CIRRUS_BLTMODE_MEMSYSSRC; <nl>      s->cirrus_srcptr = &s->cirrus_bltbuf[0]; <nl>      s->cirrus_srcptr_end = &s->cirrus_bltbuf[0]; <nl> @@ -925,6 +929,10 @@ static int cirrus_bitblt_cputovideo(CirrusVGAState * s) <nl>  	} <nl>          s->cirrus_srccounter = s->cirrus_blt_srcpitch * s->cirrus_blt_height; <nl>      } <nl> + <nl> +    /* the blit_is_unsafe call above should catch this */ <nl> +    assert(s->cirrus_blt_srcpitch <= CIRRUS_BLTBUFSIZE); <nl> + <nl>      s->cirrus_srcptr = s->cirrus_bltbuf; <nl>      s->cirrus_srcptr_end = s->cirrus_bltbuf + s->cirrus_blt_srcpitch; <nl>      cirrus_update_memory_access(s);
@@ -1266,9 +1266,10 @@ static int ram_save_complete(QEMUFile *f, void *opaque) <nl>   <nl>      flush_compressed_data(f); <nl>      ram_control_after_iterate(f, RAM_CONTROL_FINISH); <nl> -    migration_end(); <nl>   <nl>      rcu_read_unlock(); <nl> + <nl> +    migration_end(); <nl>      qemu_put_be64(f, RAM_SAVE_FLAG_EOS); <nl>   <nl>      return 0;
@@ -2038,15 +2038,14 @@ static void cirrus_mem_writeb_mode4and5_8bpp(CirrusVGAState * s, <nl>      unsigned val = mem_value; <nl>      uint8_t *dst; <nl>   <nl> -    dst = s->vga.vram_ptr + (offset &= s->cirrus_addr_mask); <nl>      for (x = 0; x < 8; x++) { <nl> +        dst = s->vga.vram_ptr + ((offset + x) & s->cirrus_addr_mask); <nl>  	if (val & 0x80) { <nl>  	    *dst = s->cirrus_shadow_gr1; <nl>  	} else if (mode == 5) { <nl>  	    *dst = s->cirrus_shadow_gr0; <nl>  	} <nl>  	val <<= 1; <nl> -	dst++; <nl>      } <nl>      memory_region_set_dirty(&s->vga.vram, offset, 8); <nl>  } <nl> @@ -2060,8 +2059,8 @@ static void cirrus_mem_writeb_mode4and5_16bpp(CirrusVGAState * s, <nl>      unsigned val = mem_value; <nl>      uint8_t *dst; <nl>   <nl> -    dst = s->vga.vram_ptr + (offset &= s->cirrus_addr_mask); <nl>      for (x = 0; x < 8; x++) { <nl> +        dst = s->vga.vram_ptr + ((offset + 2 * x) & s->cirrus_addr_mask & ~1); <nl>  	if (val & 0x80) { <nl>  	    *dst = s->cirrus_shadow_gr1; <nl>  	    *(dst + 1) = s->vga.gr[0x11]; <nl> @@ -2070,7 +2069,6 @@ static void cirrus_mem_writeb_mode4and5_16bpp(CirrusVGAState * s, <nl>  	    *(dst + 1) = s->vga.gr[0x10]; <nl>  	} <nl>  	val <<= 1; <nl> -	dst += 2; <nl>      } <nl>      memory_region_set_dirty(&s->vga.vram, offset, 16); <nl>  }
@@ -756,8 +756,8 @@ void cuda_init (int *cuda_mem_index, qemu_irq irq) <nl>   <nl>      s->timers[1].index = 1; <nl>   <nl> -    qemu_get_timedate(&tm, RTC_OFFSET); <nl> -    s->tick_offset = mktimegm(&tm); <nl> +    qemu_get_timedate(&tm, 0); <nl> +    s->tick_offset = (uint32_t)mktimegm(&tm) + RTC_OFFSET; <nl>   <nl>      s->adb_poll_timer = qemu_new_timer(vm_clock, cuda_adb_poll, s); <nl>      *cuda_mem_index = cpu_register_io_memory(0, cuda_read, cuda_write, s);
@@ -391,9 +391,6 @@ static int scsi_disk_emulate_inquiry(SCSIRequest *req, uint8_t *outbuf) <nl>              } <nl>   <nl>              l = strlen(s->serial); <nl> -            if (l > req->cmd.xfer) { <nl> -                l = req->cmd.xfer; <nl> -            } <nl>              if (l > 20) { <nl>                  l = 20; <nl>              } <nl> @@ -1002,9 +999,6 @@ static int scsi_disk_emulate_mode_sense(SCSIDiskReq *r, uint8_t *outbuf) <nl>          outbuf[0] = ((buflen - 2) >> 8) & 0xff; <nl>          outbuf[1] = (buflen - 2) & 0xff; <nl>      } <nl> -    if (buflen > r->req.cmd.xfer) { <nl> -        buflen = r->req.cmd.xfer; <nl> -    } <nl>      return buflen; <nl>  } <nl>   <nl> @@ -1038,9 +1032,6 @@ static int scsi_disk_emulate_read_toc(SCSIRequest *req, uint8_t *outbuf) <nl>      default: <nl>          return -1; <nl>      } <nl> -    if (toclen > req->cmd.xfer) { <nl> -        toclen = req->cmd.xfer; <nl> -    } <nl>      return toclen; <nl>  } <nl>   <nl> @@ -1251,6 +1242,7 @@ static int scsi_disk_emulate_command(SCSIDiskReq *r) <nl>          scsi_check_condition(r, SENSE_CODE(INVALID_OPCODE)); <nl>          return -1; <nl>      } <nl> +    buflen = MIN(buflen, req->cmd.xfer); <nl>      return buflen; <nl>   <nl>  not_ready:
@@ -1031,6 +1031,11 @@ static int scsi_disk_initfn(SCSIDevice *dev) <nl>      } <nl>      s->bs = s->qdev.conf.dinfo->bdrv; <nl>   <nl> +    if (bdrv_is_sg(s->bs)) { <nl> +        qemu_error("scsi-disk: unwanted /dev/sg*\n"); <nl> +        return -1; <nl> +    } <nl> + <nl>      if (bdrv_get_type_hint(s->bs) == BDRV_TYPE_CDROM) { <nl>          s->cluster_size = 4; <nl>      } else {
@@ -740,6 +740,7 @@ int kvm_init(void) <nl>          fprintf(stderr, "Please add the 'switch_amode' kernel parameter to " <nl>                          "your host kernel command line\n"); <nl>  #endif <nl> +        ret = s->vmfd; <nl>          goto err; <nl>      } <nl>   <nl> @@ -798,7 +799,7 @@ int kvm_init(void) <nl>   <nl>  err: <nl>      if (s) { <nl> -        if (s->vmfd != -1) { <nl> +        if (s->vmfd >= 0) { <nl>              close(s->vmfd); <nl>          } <nl>          if (s->fd != -1) {
@@ -22,8 +22,8 @@ void object_property_set_qobject(Object *obj, QObject *value, <nl>                                   const char *name, Error **errp) <nl>  { <nl>      Visitor *v; <nl> -    /* TODO: Should we reject, rather than ignore, excess input? */ <nl> -    v = qobject_input_visitor_new(value, false); <nl> + <nl> +    v = qobject_input_visitor_new(value, true); <nl>      object_property_set(obj, v, name, errp); <nl>      visit_free(v); <nl>  }
@@ -132,6 +132,7 @@ static inline void softusb_read_dmem(MilkymistSoftUsbState *s, <nl>      if (offset + len >= s->dmem_size) { <nl>          error_report("milkymist_softusb: read dmem out of bounds " <nl>                  "at offset 0x%x, len %d", offset, len); <nl> +        memset(buf, 0, len); <nl>          return; <nl>      } <nl>   <nl> @@ -156,6 +157,7 @@ static inline void softusb_read_pmem(MilkymistSoftUsbState *s, <nl>      if (offset + len >= s->pmem_size) { <nl>          error_report("milkymist_softusb: read pmem out of bounds " <nl>                  "at offset 0x%x, len %d", offset, len); <nl> +        memset(buf, 0, len); <nl>          return; <nl>      } <nl>  
@@ -487,7 +487,7 @@ static void tci_out_label(TCGContext *s, TCGArg arg) <nl>          assert(label->u.value); <nl>      } else { <nl>          tcg_out_reloc(s, s->code_ptr, sizeof(tcg_target_ulong), arg, 0); <nl> -        tcg_out_i(s, 0); <nl> +        s->code_ptr += sizeof(tcg_target_ulong); <nl>      } <nl>  } <nl>  
@@ -653,6 +653,13 @@ retry: <nl>              goto retry; <nl>          } <nl>      } <nl> + <nl> +    /* Make sure that all offsets in the "allocated" range are representable <nl> +     * in an int64_t */ <nl> +    if (s->free_cluster_index - 1 > (INT64_MAX >> s->cluster_bits)) { <nl> +        return -EFBIG; <nl> +    } <nl> + <nl>  #ifdef DEBUG_ALLOC2 <nl>      fprintf(stderr, "alloc_clusters: size=%" PRId64 " -> %" PRId64 "\n", <nl>              size,
@@ -108,6 +108,7 @@ ssize_t v9fs_list_xattr(FsContext *ctx, const char *path, <nl>      g_free(name); <nl>      close_preserve_errno(dirfd); <nl>      if (xattr_len < 0) { <nl> +        g_free(orig_value); <nl>          return -1; <nl>      } <nl>  
@@ -8149,9 +8149,10 @@ static void ppc_cpu_realizefn(DeviceState *dev, Error **errp) <nl>          } <nl>          printf("PowerPC %-12s : PVR %08x MSR %016" PRIx64 "\n" <nl>                 "    MMU model        : %s\n", <nl> -               pcc->name, pcc->pvr, pcc->msr_mask, mmu_model); <nl> +               object_class_get_name(OBJECT_CLASS(pcc)), <nl> +               pcc->pvr, pcc->msr_mask, mmu_model); <nl>  #if !defined(CONFIG_USER_ONLY) <nl> -        if (env->tlb != NULL) { <nl> +        if (env->tlb.tlb6) { <nl>              printf("                       %d %s TLB in %d ways\n", <nl>                     env->nb_tlb, env->id_tlbs ? "splitted" : "merged", <nl>                     env->nb_ways);
@@ -393,16 +393,20 @@ static int nfs_file_open(BlockDriverState *bs, QDict *options, int flags, <nl>      qemu_opts_absorb_qdict(opts, options, &local_err); <nl>      if (local_err) { <nl>          error_propagate(errp, local_err); <nl> -        return -EINVAL; <nl> +        ret = -EINVAL; <nl> +        goto out; <nl>      } <nl>      ret = nfs_client_open(client, qemu_opt_get(opts, "filename"), <nl>                            (flags & BDRV_O_RDWR) ? O_RDWR : O_RDONLY, <nl>                            errp); <nl>      if (ret < 0) { <nl> -        return ret; <nl> +        goto out; <nl>      } <nl>      bs->total_sectors = ret; <nl> -    return 0; <nl> +    ret = 0; <nl> +out: <nl> +    qemu_opts_del(opts); <nl> +    return ret; <nl>  } <nl>   <nl>  static int nfs_file_create(const char *url, QemuOpts *opts, Error **errp)
@@ -563,7 +563,6 @@ int virtio_gpu_create_mapping_iov(struct virtio_gpu_resource_attach_backing *ab, <nl>                            __func__, ab->resource_id, i); <nl>              virtio_gpu_cleanup_mapping_iov(*iov, i); <nl>              g_free(ents); <nl> -            g_free(*iov); <nl>              *iov = NULL; <nl>              return -1; <nl>          } <nl> @@ -580,12 +579,12 @@ void virtio_gpu_cleanup_mapping_iov(struct iovec *iov, uint32_t count) <nl>          cpu_physical_memory_unmap(iov[i].iov_base, iov[i].iov_len, 1, <nl>                                    iov[i].iov_len); <nl>      } <nl> +    g_free(iov); <nl>  } <nl>   <nl>  static void virtio_gpu_cleanup_mapping(struct virtio_gpu_simple_resource *res) <nl>  { <nl>      virtio_gpu_cleanup_mapping_iov(res->iov, res->iov_cnt); <nl> -    g_free(res->iov); <nl>      res->iov = NULL; <nl>      res->iov_cnt = 0; <nl>  }
@@ -730,10 +730,10 @@ static void cirrus_do_copy(CirrusVGAState *s, int dst, int src, int w, int h) <nl>      s->get_resolution((VGAState *)s, &width, &height); <nl>   <nl>      /* extra x, y */ <nl> -    sx = (src % (width * depth)) / depth; <nl> -    sy = (src / (width * depth)); <nl> -    dx = (dst % (width *depth)) / depth; <nl> -    dy = (dst / (width * depth)); <nl> +    sx = (src % ABS(s->cirrus_blt_srcpitch)) / depth; <nl> +    sy = (src / ABS(s->cirrus_blt_srcpitch)); <nl> +    dx = (dst % ABS(s->cirrus_blt_dstpitch)) / depth; <nl> +    dy = (dst / ABS(s->cirrus_blt_dstpitch)); <nl>   <nl>      /* normalize width */ <nl>      w /= depth;
@@ -59,6 +59,8 @@ static void do_test_equality(bool expected, int _, ...) <nl>              g_assert(qobject_is_equal(args[i], args[j]) == expected); <nl>          } <nl>      } <nl> + <nl> +    g_free(args); <nl>  } <nl>   <nl>  #define check_equal(...) \
@@ -269,7 +269,11 @@ static int vpc_open(BlockDriverState *bs, QDict *options, int flags, <nl>              goto fail; <nl>          } <nl>   <nl> -        s->pagetable = qemu_blockalign(bs, s->max_table_entries * 4); <nl> +        s->pagetable = qemu_try_blockalign(bs->file, s->max_table_entries * 4); <nl> +        if (s->pagetable == NULL) { <nl> +            ret = -ENOMEM; <nl> +            goto fail; <nl> +        } <nl>   <nl>          s->bat_offset = be64_to_cpu(dyndisk_header->table_offset); <nl>  
@@ -943,7 +943,6 @@ static int bt_hci_name_req(struct bt_hci_s *hci, bdaddr_t *bdaddr) <nl>  { <nl>      struct bt_device_s *slave; <nl>      evt_remote_name_req_complete params; <nl> -    int len; <nl>   <nl>      for (slave = hci->device.net->slave; slave; slave = slave->next) <nl>          if (slave->page_scan && !bacmp(&slave->bd_addr, bdaddr)) <nl> @@ -955,9 +954,7 @@ static int bt_hci_name_req(struct bt_hci_s *hci, bdaddr_t *bdaddr) <nl>   <nl>      params.status       = HCI_SUCCESS; <nl>      bacpy(&params.bdaddr, &slave->bd_addr); <nl> -    len = snprintf(params.name, sizeof(params.name), <nl> -                    "%s", slave->lmp_name ?: ""); <nl> -    memset(params.name + len, 0, sizeof(params.name) - len); <nl> +    pstrcpy(params.name, sizeof(params.name), slave->lmp_name ?: ""); <nl>      bt_hci_event(hci, EVT_REMOTE_NAME_REQ_COMPLETE, <nl>                      &params, EVT_REMOTE_NAME_REQ_COMPLETE_SIZE); <nl>   <nl> @@ -1388,7 +1385,7 @@ static inline void bt_hci_event_complete_read_local_name(struct bt_hci_s *hci) <nl>      params.status = HCI_SUCCESS; <nl>      memset(params.name, 0, sizeof(params.name)); <nl>      if (hci->device.lmp_name) <nl> -        strncpy(params.name, hci->device.lmp_name, sizeof(params.name)); <nl> +        pstrcpy(params.name, sizeof(params.name), hci->device.lmp_name); <nl>   <nl>      bt_hci_event_complete(hci, &params, READ_LOCAL_NAME_RP_SIZE); <nl>  }
@@ -205,7 +205,7 @@ static target_ulong put_tce_emu(sPAPRTCETable *tcet, target_ulong ioba, <nl>      sPAPRTCE *tcep; <nl>   <nl>      if (ioba >= tcet->window_size) { <nl> -        hcall_dprintf("spapr_vio_put_tce on out-of-boards IOBA 0x" <nl> +        hcall_dprintf("spapr_vio_put_tce on out-of-bounds IOBA 0x" <nl>                        TARGET_FMT_lx "\n", ioba); <nl>          return H_PARAMETER; <nl>      }
@@ -48,6 +48,7 @@ static int qcrypto_ivgen_essiv_init(QCryptoIVGen *ivgen, <nl>                             &salt, &nhash, <nl>                             errp) < 0) { <nl>          g_free(essiv); <nl> +        g_free(salt); <nl>          return -1; <nl>      } <nl>  
@@ -811,7 +811,8 @@ static void test_acpi_piix4_tcg_cphp(void) <nl>      memset(&data, 0, sizeof(data)); <nl>      data.machine = MACHINE_PC; <nl>      data.variant = ".cphp"; <nl> -    test_acpi_one("-smp 2,cores=3,sockets=2,maxcpus=6", <nl> +    test_acpi_one("-smp 2,cores=3,sockets=2,maxcpus=6" <nl> +                  " -numa node -numa node", <nl>                    &data); <nl>      free_test_data(&data); <nl>  } <nl> @@ -823,7 +824,8 @@ static void test_acpi_q35_tcg_cphp(void) <nl>      memset(&data, 0, sizeof(data)); <nl>      data.machine = MACHINE_Q35; <nl>      data.variant = ".cphp"; <nl> -    test_acpi_one(" -smp 2,cores=3,sockets=2,maxcpus=6", <nl> +    test_acpi_one(" -smp 2,cores=3,sockets=2,maxcpus=6" <nl> +                  " -numa node -numa node", <nl>                    &data); <nl>      free_test_data(&data); <nl>  }
@@ -60,7 +60,7 @@ typedef struct QObject { <nl>      QObject base <nl>   <nl>  /* Get the 'base' part of an object */ <nl> -#define QOBJECT(obj) (&obj->base) <nl> +#define QOBJECT(obj) (&(obj)->base) <nl>   <nl>  /* High-level interface for qobject_incref() */ <nl>  #define QINCREF(obj)      \
@@ -4108,7 +4108,7 @@ static void gen_hrfid(DisasContext *ctx) <nl>      gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC); <nl>  #else <nl>      /* Restore CPU state */ <nl> -    if (unlikely(!ctx->hv)) { <nl> +    if (unlikely(ctx->pr || !ctx->hv)) { <nl>          gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC); <nl>          return; <nl>      } <nl> @@ -4845,7 +4845,7 @@ static void gen_tlbia(DisasContext *ctx) <nl>  #if defined(CONFIG_USER_ONLY) <nl>      gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC); <nl>  #else <nl> -    if (unlikely(ctx->pr)) { <nl> +    if (unlikely(ctx->pr || !ctx->hv)) { <nl>          gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC); <nl>          return; <nl>      } <nl> @@ -4913,7 +4913,7 @@ static void gen_slbia(DisasContext *ctx) <nl>  #if defined(CONFIG_USER_ONLY) <nl>      gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC); <nl>  #else <nl> -    if (unlikely(ctx->pr || !ctx->hv)) { <nl> +    if (unlikely(ctx->pr)) { <nl>          gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC); <nl>          return; <nl>      }
@@ -85,6 +85,9 @@ static void pc_fw_add_pflash_drv(void) <nl>      filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name); <nl>   <nl>      opts = drive_add(IF_PFLASH, -1, filename, "readonly=on"); <nl> + <nl> +    g_free(filename); <nl> + <nl>      if (opts == NULL) { <nl>        return; <nl>      }
@@ -90,7 +90,7 @@ int mips_cpu_gdb_write_register(CPUState *cs, uint8_t *mem_buf, int n) <nl>          return sizeof(target_ulong); <nl>      } <nl>      if (env->CP0_Config1 & (1 << CP0C1_FP) <nl> -            && n >= 38 && n < 73) { <nl> +            && n >= 38 && n < 72) { <nl>          if (n < 70) { <nl>              if (env->CP0_Status & (1 << CP0St_FR)) { <nl>                  env->active_fpu.fpr[n - 38].d = tmp;
@@ -2724,8 +2724,10 @@ static int vnc_refresh_lossy_rect(VncDisplay *vd, int x, int y) <nl>   <nl>  static int vnc_update_stats(VncDisplay *vd,  struct timeval * tv) <nl>  { <nl> -    int width = pixman_image_get_width(vd->guest.fb); <nl> -    int height = pixman_image_get_height(vd->guest.fb); <nl> +    int width = MIN(pixman_image_get_width(vd->guest.fb), <nl> +                    pixman_image_get_width(vd->server)); <nl> +    int height = MIN(pixman_image_get_height(vd->guest.fb), <nl> +                     pixman_image_get_height(vd->server)); <nl>      int x, y; <nl>      struct timeval res; <nl>      int has_dirty = 0;
@@ -2608,6 +2608,7 @@ fail: <nl>      QDECREF(bs->options); <nl>      QDECREF(options); <nl>      bs->options = NULL; <nl> +    bs->explicit_options = NULL; <nl>      bdrv_unref(bs); <nl>      error_propagate(errp, local_err); <nl>      return NULL; <nl> @@ -3087,6 +3088,7 @@ static void bdrv_close(BlockDriverState *bs) <nl>          QDECREF(bs->options); <nl>          QDECREF(bs->explicit_options); <nl>          bs->options = NULL; <nl> +        bs->explicit_options = NULL; <nl>          QDECREF(bs->full_open_options); <nl>          bs->full_open_options = NULL; <nl>      }
@@ -148,17 +148,18 @@ static void cd_read_sector_cb(void *opaque, int ret) <nl>  { <nl>      IDEState *s = opaque; <nl>   <nl> -    block_acct_done(blk_get_stats(s->blk), &s->acct); <nl> - <nl>  #ifdef DEBUG_IDE_ATAPI <nl>      printf("cd_read_sector_cb: lba=%d ret=%d\n", s->lba, ret); <nl>  #endif <nl>   <nl>      if (ret < 0) { <nl> +        block_acct_failed(blk_get_stats(s->blk), &s->acct); <nl>          ide_atapi_io_error(s, ret); <nl>          return; <nl>      } <nl>   <nl> +    block_acct_done(blk_get_stats(s->blk), &s->acct); <nl> + <nl>      if (s->cd_sector_size == 2352) { <nl>          cd_data_to_raw(s->io_buffer, s->lba); <nl>      } <nl> @@ -173,6 +174,7 @@ static void cd_read_sector_cb(void *opaque, int ret) <nl>  static int cd_read_sector(IDEState *s) <nl>  { <nl>      if (s->cd_sector_size != 2048 && s->cd_sector_size != 2352) { <nl> +        block_acct_invalid(blk_get_stats(s->blk), BLOCK_ACCT_READ); <nl>          return -EINVAL; <nl>      } <nl>  
@@ -871,7 +871,7 @@ static void virtser_port_device_realize(DeviceState *dev, Error **errp) <nl>          return; <nl>      } <nl>   <nl> -    if (find_port_by_name(port->name)) { <nl> +    if (port->name != NULL && find_port_by_name(port->name)) { <nl>          error_setg(errp, "virtio-serial-bus: A port already exists by name %s", <nl>                     port->name); <nl>          return;
@@ -2737,7 +2737,6 @@ static int disas_vfp_insn(CPUARMState * env, DisasContext *s, uint32_t insn) <nl>                      } <nl>                  } else { <nl>                      /* arm->vfp */ <nl> -                    tmp = load_reg(s, rd); <nl>                      if (insn & (1 << 21)) { <nl>                          rn >>= 1; <nl>                          /* system register */ <nl> @@ -2748,6 +2747,7 @@ static int disas_vfp_insn(CPUARMState * env, DisasContext *s, uint32_t insn) <nl>                              /* Writes are ignored.  */ <nl>                              break; <nl>                          case ARM_VFP_FPSCR: <nl> +                            tmp = load_reg(s, rd); <nl>                              gen_helper_vfp_set_fpscr(cpu_env, tmp); <nl>                              tcg_temp_free_i32(tmp); <nl>                              gen_lookup_tb(s); <nl> @@ -2757,18 +2757,21 @@ static int disas_vfp_insn(CPUARMState * env, DisasContext *s, uint32_t insn) <nl>                                  return 1; <nl>                              /* TODO: VFP subarchitecture support. <nl>                               * For now, keep the EN bit only */ <nl> +                            tmp = load_reg(s, rd); <nl>                              tcg_gen_andi_i32(tmp, tmp, 1 << 30); <nl>                              store_cpu_field(tmp, vfp.xregs[rn]); <nl>                              gen_lookup_tb(s); <nl>                              break; <nl>                          case ARM_VFP_FPINST: <nl>                          case ARM_VFP_FPINST2: <nl> +                            tmp = load_reg(s, rd); <nl>                              store_cpu_field(tmp, vfp.xregs[rn]); <nl>                              break; <nl>                          default: <nl>                              return 1; <nl>                          } <nl>                      } else { <nl> +                        tmp = load_reg(s, rd); <nl>                          gen_vfp_msr(tmp); <nl>                          gen_mov_vreg_F0(0, rn); <nl>                      }
@@ -326,9 +326,7 @@ extern uintptr_t tci_tb_ptr; <nl>     (6) jump to corresponding code of the next of fast path <nl>   */ <nl>  # if defined(__i386__) || defined(__x86_64__) <nl> -#  define GETRA() ((uintptr_t)__builtin_return_address(0)) <nl> -/* The return address argument for ldst is passed directly.  */ <nl> -#  define GETPC_LDST()  (abort(), 0) <nl> +#  define GETPC_EXT()  GETPC() <nl>  # elif defined (_ARCH_PPC) && !defined (_ARCH_PPC64) <nl>  #  define GETRA() ((uintptr_t)__builtin_return_address(0)) <nl>  #  define GETPC_LDST() ((uintptr_t) ((*(int32_t *)(GETRA() - 4)) - 1)) <nl> @@ -349,7 +347,7 @@ static inline uintptr_t tcg_getpc_ldst(uintptr_t ra) <nl>                                     not the start of the next opcode  */ <nl>      return ra; <nl>  } <nl> -#elif defined(__aarch64__) <nl> +# elif defined(__aarch64__) <nl>  #  define GETRA()       ((uintptr_t)__builtin_return_address(0)) <nl>  #  define GETPC_LDST()  tcg_getpc_ldst(GETRA()) <nl>  static inline uintptr_t tcg_getpc_ldst(uintptr_t ra) <nl> @@ -367,7 +365,9 @@ static inline uintptr_t tcg_getpc_ldst(uintptr_t ra) <nl>  #  error "CONFIG_QEMU_LDST_OPTIMIZATION needs GETPC_LDST() implementation!" <nl>  # endif <nl>  bool is_tcg_gen_code(uintptr_t pc_ptr); <nl> -# define GETPC_EXT() (is_tcg_gen_code(GETRA()) ? GETPC_LDST() : GETPC()) <nl> +# ifndef GETPC_EXT <nl> +#  define GETPC_EXT() (is_tcg_gen_code(GETRA()) ? GETPC_LDST() : GETPC()) <nl> +# endif <nl>  #else <nl>  # define GETPC_EXT() GETPC() <nl>  #endif
@@ -1355,7 +1355,8 @@ static int pci_rocker_init(PCIDevice *dev) <nl>          fprintf(stderr, <nl>                  "rocker: name too long; please shorten to at most %d chars\n", <nl>                  MAX_ROCKER_NAME_LEN); <nl> -        return -EINVAL; <nl> +        err = -EINVAL; <nl> +        goto err_name_too_long; <nl>      } <nl>   <nl>      if (memcmp(&r->fp_start_macaddr, &zero, sizeof(zero)) == 0) { <nl> @@ -1414,6 +1415,7 @@ static int pci_rocker_init(PCIDevice *dev) <nl>   <nl>      return 0; <nl>   <nl> +err_name_too_long: <nl>  err_duplicate: <nl>      rocker_msix_uninit(r); <nl>  err_msix_init:
@@ -200,18 +200,14 @@ static void set_chr(Object *obj, Visitor *v, const char *name, void *opaque, <nl>      } <nl>   <nl>      s = qemu_chr_find(str); <nl> -    g_free(str); <nl>      if (s == NULL) { <nl>          error_setg(errp, "Property '%s.%s' can't find value '%s'", <nl>                     object_get_typename(obj), prop->name, str); <nl> -        return; <nl> -    } <nl> - <nl> -    if (!qemu_chr_fe_init(be, s, errp)) { <nl> +    } else if (!qemu_chr_fe_init(be, s, errp)) { <nl>          error_prepend(errp, "Property '%s.%s' can't take value '%s': ", <nl>                        object_get_typename(obj), prop->name, str); <nl> -        return; <nl>      } <nl> +    g_free(str); <nl>  } <nl>   <nl>  static void release_chr(Object *obj, const char *name, void *opaque)
@@ -112,12 +112,13 @@ static uint16_t handle_write_event_buf(SCLPEventFacility *ef, <nl>      SCLPEvent *event; <nl>      SCLPEventClass *ec; <nl>   <nl> +    rc = SCLP_RC_INVALID_FUNCTION; <nl> + <nl>      QTAILQ_FOREACH(kid, &ef->sbus.qbus.children, sibling) { <nl>          DeviceState *qdev = kid->child; <nl>          event = (SCLPEvent *) qdev; <nl>          ec = SCLP_EVENT_GET_CLASS(event); <nl>   <nl> -        rc = SCLP_RC_INVALID_FUNCTION; <nl>          if (ec->write_event_data && <nl>              ec->event_type() == event_buf->type) { <nl>              rc = ec->write_event_data(event, event_buf);
@@ -222,7 +222,7 @@ static uint16_t nvme_rw(NvmeCtrl *n, NvmeNamespace *ns, NvmeCmd *cmd, <nl>   <nl>      uint8_t lba_index  = NVME_ID_NS_FLBAS_INDEX(ns->id_ns.flbas); <nl>      uint8_t data_shift = ns->id_ns.lbaf[lba_index].ds; <nl> -    uint64_t data_size = nlb << data_shift; <nl> +    uint64_t data_size = (uint64_t)nlb << data_shift; <nl>      uint64_t aio_slba  = slba << (data_shift - BDRV_SECTOR_BITS); <nl>      int is_write = rw->opcode == NVME_CMD_WRITE ? 1 : 0; <nl>  
@@ -2483,6 +2483,11 @@ void usb_ehci_realize(EHCIState *s, DeviceState *dev, Error **errp) <nl>                     NB_PORTS); <nl>          return; <nl>      } <nl> +    if (s->maxframes < 8 || s->maxframes > 512)  { <nl> +        error_setg(errp, "maxframes %d out if range (8 .. 512)", <nl> +                   s->maxframes); <nl> +        return; <nl> +    } <nl>   <nl>      usb_bus_new(&s->bus, sizeof(s->bus), s->companion_enable ? <nl>                  &ehci_bus_ops_companion : &ehci_bus_ops_standalone, dev);
@@ -86,7 +86,7 @@ static int tpm_passthrough_unix_write(int fd, const uint8_t *buf, uint32_t len) <nl>      int ret, remain; <nl>   <nl>      remain = len; <nl> -    while (len > 0) { <nl> +    while (remain > 0) { <nl>          ret = write(fd, buf, remain); <nl>          if (ret < 0) { <nl>              if (errno != EINTR && errno != EAGAIN) {
@@ -789,7 +789,7 @@ static gint crs_range_compare(gconstpointer a, gconstpointer b) <nl>  static void crs_replace_with_free_ranges(GPtrArray *ranges, <nl>                                           uint64_t start, uint64_t end) <nl>  { <nl> -    GPtrArray *free_ranges = g_ptr_array_new_with_free_func(crs_range_free); <nl> +    GPtrArray *free_ranges = g_ptr_array_new(); <nl>      uint64_t free_base = start; <nl>      int i; <nl>   <nl> @@ -813,7 +813,7 @@ static void crs_replace_with_free_ranges(GPtrArray *ranges, <nl>          g_ptr_array_add(ranges, g_ptr_array_index(free_ranges, i)); <nl>      } <nl>   <nl> -    g_ptr_array_free(free_ranges, false); <nl> +    g_ptr_array_free(free_ranges, true); <nl>  } <nl>   <nl>  /*
@@ -47,7 +47,7 @@ <nl>  #ifdef _VNC_DEBUG <nl>  #define VNC_DEBUG(fmt, ...) do { fprintf(stderr, fmt, ## __VA_ARGS__); } while (0) <nl>   <nl> -#if CONFIG_VNC_TLS && _VNC_DEBUG >= 2 <nl> +#if defined(CONFIG_VNC_TLS) && _VNC_DEBUG >= 2 <nl>  /* Very verbose, so only enabled for _VNC_DEBUG >= 2 */ <nl>  static void vnc_debug_gnutls_log(int level, const char* str) { <nl>      VNC_DEBUG("%d %s", level, str);
@@ -286,9 +286,12 @@ static void sdl_grab_start(void) <nl>          SDL_WarpMouse(guest_x, guest_y); <nl>      } else <nl>          sdl_hide_cursor(); <nl> -    SDL_WM_GrabInput(SDL_GRAB_ON); <nl> -    gui_grab = 1; <nl> -    sdl_update_caption(); <nl> + <nl> +    if (SDL_WM_GrabInput(SDL_GRAB_ON) == SDL_GRAB_ON) { <nl> +        gui_grab = 1; <nl> +        sdl_update_caption(); <nl> +    } else <nl> +        sdl_show_cursor(); <nl>  } <nl>   <nl>  static void sdl_grab_end(void)
@@ -420,6 +420,7 @@ int main(int argc, char **argv) <nl>            " -device ipmi-bmc-extern,chardev=ipmi0,id=bmc0" <nl>            " -device isa-ipmi-bt,bmc=bmc0", emu_port); <nl>      qtest_start(cmdline); <nl> +    g_free(cmdline); <nl>      qtest_irq_intercept_in(global_qtest, "ioapic"); <nl>      qtest_add_func("/ipmi/extern/connect", test_connect); <nl>      qtest_add_func("/ipmi/extern/bt_base", test_bt_base);
@@ -98,7 +98,9 @@ static void pc_fw_add_pflash_drv(void) <nl>        return; <nl>      } <nl>   <nl> -    drive_init(opts, machine->use_scsi); <nl> +    if (!drive_init(opts, machine->use_scsi)) { <nl> +        qemu_opts_del(opts); <nl> +    } <nl>  } <nl>   <nl>  static void pc_system_flash_init(MemoryRegion *rom_memory,
@@ -88,9 +88,7 @@ ISADevice *isa_ide_init(ISABus *bus, int iobase, int iobase2, int isairq, <nl>      qdev_prop_set_uint32(dev, "iobase",  iobase); <nl>      qdev_prop_set_uint32(dev, "iobase2", iobase2); <nl>      qdev_prop_set_uint32(dev, "irq",     isairq); <nl> -    if (qdev_init(dev) < 0) { <nl> -        return NULL; <nl> -    } <nl> +    qdev_init_nofail(dev); <nl>   <nl>      s = ISA_IDE(dev); <nl>      if (hd0) {
@@ -195,7 +195,7 @@ static uint32_t cc_calc_abs_64(int64_t dst) <nl>      if ((uint64_t)dst == 0x8000000000000000ULL) { <nl>          return 3; <nl>      } else if (dst) { <nl> -        return 1; <nl> +        return 2; <nl>      } else { <nl>          return 0; <nl>      } <nl> @@ -296,7 +296,7 @@ static uint32_t cc_calc_abs_32(int32_t dst) <nl>      if ((uint32_t)dst == 0x80000000UL) { <nl>          return 3; <nl>      } else if (dst) { <nl> -        return 1; <nl> +        return 2; <nl>      } else { <nl>          return 0; <nl>      }
@@ -128,6 +128,11 @@ ivshmem_client_handle_server_msg(IvshmemClient *client) <nl>      /* new vector */ <nl>      IVSHMEM_CLIENT_DEBUG(client, "  new vector %d (fd=%d) for peer id %ld\n", <nl>                           peer->vectors_count, fd, peer->id); <nl> +    if (peer->vectors_count >= G_N_ELEMENTS(peer->vectors)) { <nl> +        IVSHMEM_CLIENT_DEBUG(client, "Too many vectors received, failing"); <nl> +        return -1; <nl> +    } <nl> + <nl>      peer->vectors[peer->vectors_count] = fd; <nl>      peer->vectors_count++; <nl>  
@@ -82,6 +82,12 @@ static void cpu_class_init(ObjectClass *oc, void *data) <nl>      k->get_receive_mask = receive_mask; <nl>      k->read_event_data = read_event_data; <nl>      set_bit(DEVICE_CATEGORY_MISC, dc->categories); <nl> +    /* <nl> +     * Reason: raise_irq_cpu_hotplug() depends on an unique <nl> +     * TYPE_SCLP_CPU_HOTPLUG device, which is already created <nl> +     * by the sclp event facility <nl> +     */ <nl> +    dc->user_creatable = false; <nl>  } <nl>   <nl>  static const TypeInfo sclp_cpu_info = {
@@ -81,8 +81,11 @@ void vncws_handshake_read(void *opaque) <nl>      VncState *vs = opaque; <nl>      uint8_t *handshake_end; <nl>      long ret; <nl> -    buffer_reserve(&vs->ws_input, 4096); <nl> -    ret = vnc_client_read_buf(vs, buffer_end(&vs->ws_input), 4096); <nl> +    /* Typical HTTP headers from novnc are 512 bytes, so limiting <nl> +     * total header size to 4096 is easily enough. */ <nl> +    size_t want = 4096 - vs->ws_input.offset; <nl> +    buffer_reserve(&vs->ws_input, want); <nl> +    ret = vnc_client_read_buf(vs, buffer_end(&vs->ws_input), want); <nl>   <nl>      if (!ret) { <nl>          if (vs->csock == -1) { <nl> @@ -99,6 +102,9 @@ void vncws_handshake_read(void *opaque) <nl>          vncws_process_handshake(vs, vs->ws_input.buffer, vs->ws_input.offset); <nl>          buffer_advance(&vs->ws_input, handshake_end - vs->ws_input.buffer + <nl>                  strlen(WS_HANDSHAKE_END)); <nl> +    } else if (vs->ws_input.offset >= 4096) { <nl> +        VNC_DEBUG("End of headers not found in first 4096 bytes\n"); <nl> +        vnc_client_error(vs); <nl>      } <nl>  } <nl>  
@@ -199,6 +199,9 @@ vgafb_write(void *opaque, target_phys_addr_t addr, uint32_t value) <nl>      addr >>= 2; <nl>      switch (addr) { <nl>      case R_CTRL: <nl> +        s->regs[addr] = value; <nl> +        vgafb_resize(s); <nl> +        break; <nl>      case R_HSYNC_START: <nl>      case R_HSYNC_END: <nl>      case R_HSCAN:
@@ -341,6 +341,8 @@ static int vmdk_parent_open(BlockDriverState *bs, const char * filename) <nl>          p_name += sizeof("parentFileNameHint") + 1; <nl>          if ((end_name = strchr(p_name,'\"')) == 0) <nl>              return -1; <nl> +        if ((end_name - p_name) > sizeof (s->hd->backing_file) - 1) <nl> +            return -1; <nl>   <nl>          strncpy(s->hd->backing_file, p_name, end_name - p_name); <nl>          if (stat(s->hd->backing_file, &file_buf) != 0) {
@@ -68,7 +68,6 @@ typedef struct Peer { <nl>   <nl>  typedef struct EventfdEntry { <nl>      PCIDevice *pdev; <nl> -    int vector; <nl>  } EventfdEntry; <nl>   <nl>  typedef struct IVShmemState { <nl> @@ -287,9 +286,11 @@ static void fake_irqfd(void *opaque, const uint8_t *buf, int size) { <nl>   <nl>      EventfdEntry *entry = opaque; <nl>      PCIDevice *pdev = entry->pdev; <nl> +    IVShmemState *s = IVSHMEM(pdev); <nl> +    int vector = entry - s->eventfd_table; <nl>   <nl> -    IVSHMEM_DPRINTF("interrupt on vector %p %d\n", pdev, entry->vector); <nl> -    msix_notify(pdev, entry->vector); <nl> +    IVSHMEM_DPRINTF("interrupt on vector %p %d\n", pdev, vector); <nl> +    msix_notify(pdev, vector); <nl>  } <nl>   <nl>  static CharDriverState* create_eventfd_chr_device(void * opaque, EventNotifier *n, <nl> @@ -311,7 +312,6 @@ static CharDriverState* create_eventfd_chr_device(void * opaque, EventNotifier * <nl>      /* if MSI is supported we need multiple interrupts */ <nl>      if (ivshmem_has_feature(s, IVSHMEM_MSI)) { <nl>          s->eventfd_table[vector].pdev = PCI_DEVICE(s); <nl> -        s->eventfd_table[vector].vector = vector; <nl>   <nl>          qemu_chr_add_handlers(chr, ivshmem_can_receive, fake_irqfd, <nl>                        ivshmem_event, &s->eventfd_table[vector]);
@@ -1255,7 +1255,14 @@ static inline bool arm_singlestep_active(CPUARMState *env) <nl>  static inline void cpu_get_tb_cpu_state(CPUARMState *env, target_ulong *pc, <nl>                                          target_ulong *cs_base, int *flags) <nl>  { <nl> -    int fpen = extract32(env->cp15.c1_coproc, 20, 2); <nl> +    int fpen; <nl> + <nl> +    if (arm_feature(env, ARM_FEATURE_V6)) { <nl> +        fpen = extract32(env->cp15.c1_coproc, 20, 2); <nl> +    } else { <nl> +        /* CPACR doesn't exist before v6, so VFP is always accessible */ <nl> +        fpen = 3; <nl> +    } <nl>   <nl>      if (is_a64(env)) { <nl>          *pc = env->pc;
@@ -187,7 +187,9 @@ static int vhost_user_write(struct vhost_dev *dev, VhostUserMsg *msg, <nl>          return 0; <nl>      } <nl>   <nl> -    qemu_chr_fe_set_msgfds(chr, fds, fd_num); <nl> +    if (qemu_chr_fe_set_msgfds(chr, fds, fd_num) < 0) { <nl> +        return -1; <nl> +    } <nl>   <nl>      return qemu_chr_fe_write_all(chr, (const uint8_t *) msg, size) == size ? <nl>              0 : -1;
@@ -467,7 +467,7 @@ static void vga_putcharxy(DisplayState *ds, int x, int y, int ch, <nl>              font_data = *font_ptr++; <nl>              if (t_attrib->uline <nl>                  && ((i == FONT_HEIGHT - 2) || (i == FONT_HEIGHT - 3))) { <nl> -                font_data = 0xFFFF; <nl> +                font_data = 0xFF; <nl>              } <nl>              ((uint32_t *)d)[0] = (dmask16[(font_data >> 4)] & xorcol) ^ bgcol; <nl>              ((uint32_t *)d)[1] = (dmask16[(font_data >> 0) & 0xf] & xorcol) ^ bgcol; <nl> @@ -480,7 +480,7 @@ static void vga_putcharxy(DisplayState *ds, int x, int y, int ch, <nl>              font_data = *font_ptr++; <nl>              if (t_attrib->uline <nl>                  && ((i == FONT_HEIGHT - 2) || (i == FONT_HEIGHT - 3))) { <nl> -                font_data = 0xFFFF; <nl> +                font_data = 0xFF; <nl>              } <nl>              ((uint32_t *)d)[0] = (dmask4[(font_data >> 6)] & xorcol) ^ bgcol; <nl>              ((uint32_t *)d)[1] = (dmask4[(font_data >> 4) & 3] & xorcol) ^ bgcol; <nl> @@ -493,7 +493,7 @@ static void vga_putcharxy(DisplayState *ds, int x, int y, int ch, <nl>          for(i = 0; i < FONT_HEIGHT; i++) { <nl>              font_data = *font_ptr++; <nl>              if (t_attrib->uline && ((i == FONT_HEIGHT - 2) || (i == FONT_HEIGHT - 3))) { <nl> -                font_data = 0xFFFF; <nl> +                font_data = 0xFF; <nl>              } <nl>              ((uint32_t *)d)[0] = (-((font_data >> 7)) & xorcol) ^ bgcol; <nl>              ((uint32_t *)d)[1] = (-((font_data >> 6) & 1) & xorcol) ^ bgcol;
@@ -1306,6 +1306,11 @@ static BlockDriverAIOCB *bdrv_aio_rw_vector(BlockDriverState *bs, <nl>          s->aiocb = bdrv_aio_read(bs, sector_num, s->bounce, nb_sectors, <nl>                                   bdrv_aio_rw_vector_cb, s); <nl>      } <nl> +    if (!s->aiocb) { <nl> +        qemu_vfree(s->bounce); <nl> +        qemu_aio_release(s); <nl> +        return NULL; <nl> +    } <nl>      return &s->common; <nl>  } <nl>  
@@ -127,7 +127,7 @@ enum vga_retrace_method { <nl>   <nl>  extern enum vga_retrace_method vga_retrace_method; <nl>   <nl> -#ifndef TARGET_SPARC <nl> +#if !defined(TARGET_SPARC) || defined(TARGET_SPARC64) <nl>  #define VGA_RAM_SIZE (8192 * 1024) <nl>  #else <nl>  #define VGA_RAM_SIZE (9 * 1024 * 1024)
@@ -1108,8 +1108,8 @@ build_ssdt(GArray *table_data, GArray *linker, <nl>          aml_append(field, aml_named_field("PEPT", 8)); <nl>          aml_append(dev, field); <nl>   <nl> -        /* device present, functioning, decoding, not shown in UI */ <nl> -        aml_append(dev, aml_name_decl("_STA", aml_int(0xB))); <nl> +        /* device present, functioning, decoding, shown in UI */ <nl> +        aml_append(dev, aml_name_decl("_STA", aml_int(0xF))); <nl>   <nl>          method = aml_method("RDPT", 0); <nl>          aml_append(method, aml_store(aml_name("PEPT"), aml_local(0)));
@@ -487,7 +487,11 @@ static DriveInfo *blockdev_init(QemuOpts *all_opts, <nl>   <nl>          drv = bdrv_find_whitelisted_format(buf, ro); <nl>          if (!drv) { <nl> -            error_report("'%s' invalid format", buf); <nl> +            if (!ro && bdrv_find_whitelisted_format(buf, !ro)) { <nl> +                error_report("'%s' can be only used as read-only device.", buf); <nl> +            } else { <nl> +                error_report("'%s' invalid format", buf); <nl> +            } <nl>              return NULL; <nl>          } <nl>      }
@@ -674,9 +674,12 @@ static void tcg_out_setcond_i32(TCGContext *s, TCGCond cond, TCGReg ret, <nl>      case TCG_COND_NE: <nl>          /* For equality, we can transform to inequality vs zero.  */ <nl>          if (c2 != 0) { <nl> -            tcg_out_arithc(s, ret, c1, c2, c2const, ARITH_XOR); <nl> +            tcg_out_arithc(s, TCG_REG_T1, c1, c2, c2const, ARITH_XOR); <nl> +            c2 = TCG_REG_T1; <nl> +        } else { <nl> +            c2 = c1; <nl>          } <nl> -        c1 = TCG_REG_G0, c2 = ret, c2const = 0; <nl> +        c1 = TCG_REG_G0, c2const = 0; <nl>          cond = (cond == TCG_COND_EQ ? TCG_COND_GEU : TCG_COND_LTU); <nl>  	break; <nl>  
@@ -224,7 +224,7 @@ SCSIDevice *scsi_bus_legacy_add_drive(SCSIBus *bus, BlockDriverState *bdrv, <nl>      if (object_property_find(OBJECT(dev), "removable", NULL)) { <nl>          qdev_prop_set_bit(dev, "removable", removable); <nl>      } <nl> -    if (serial) { <nl> +    if (serial && object_property_find(OBJECT(dev), "serial", NULL)) { <nl>          qdev_prop_set_string(dev, "serial", serial); <nl>      } <nl>      if (qdev_prop_set_drive(dev, "drive", bdrv) < 0) {
@@ -139,7 +139,6 @@ static void msmouse_chr_close (struct CharDriverState *chr) <nl>   <nl>      qemu_input_handler_unregister(mouse->hs); <nl>      g_free(mouse); <nl> -    g_free(chr); <nl>  } <nl>   <nl>  static QemuInputHandler msmouse_handler = {
@@ -1580,10 +1580,7 @@ DisplayState *init_displaystate(void) <nl>      gchar *name; <nl>      int i; <nl>   <nl> -    if (!display_state) { <nl> -        display_state = g_new0(DisplayState, 1); <nl> -    } <nl> - <nl> +    get_alloc_displaystate(); <nl>      for (i = 0; i < nb_consoles; i++) { <nl>          if (consoles[i]->console_type != GRAPHIC_CONSOLE && <nl>              consoles[i]->ds == NULL) {
@@ -11767,6 +11767,7 @@ static inline void gen_intermediate_code_internal(PowerPCCPU *cpu, <nl>          max_insns = CF_COUNT_MASK; <nl>   <nl>      gen_tb_start(); <nl> +    tcg_clear_temp_count(); <nl>      /* Set env in case of segfault during code fetch */ <nl>      while (ctx.exception == POWERPC_EXCP_NONE <nl>              && tcg_ctx.gen_opc_ptr < gen_opc_end) { <nl> @@ -11866,6 +11867,12 @@ static inline void gen_intermediate_code_internal(PowerPCCPU *cpu, <nl>               */ <nl>              break; <nl>          } <nl> +        if (tcg_check_temp_count()) { <nl> +            fprintf(stderr, "Opcode %02x %02x %02x (%08x) leaked temporaries\n", <nl> +                    opc1(ctx.opcode), opc2(ctx.opcode), opc3(ctx.opcode), <nl> +                    ctx.opcode); <nl> +            exit(1); <nl> +        } <nl>      } <nl>      if (tb->cflags & CF_LAST_IO) <nl>          gen_io_end();
@@ -3282,6 +3282,7 @@ static void coroutine_fn v9fs_xattrcreate(void *opaque) <nl>      xattr_fidp->fs.xattr.flags = flags; <nl>      v9fs_string_init(&xattr_fidp->fs.xattr.name); <nl>      v9fs_string_copy(&xattr_fidp->fs.xattr.name, &name); <nl> +    g_free(xattr_fidp->fs.xattr.value); <nl>      xattr_fidp->fs.xattr.value = g_malloc0(size); <nl>      err = offset; <nl>      put_fid(pdu, file_fidp);
@@ -382,6 +382,7 @@ static void cpu_common_unrealizefn(DeviceState *dev, Error **errp) <nl>   <nl>  static void cpu_common_initfn(Object *obj) <nl>  { <nl> +    uint32_t count; <nl>      CPUState *cpu = CPU(obj); <nl>      CPUClass *cc = CPU_GET_CLASS(obj); <nl>   <nl> @@ -396,7 +397,10 @@ static void cpu_common_initfn(Object *obj) <nl>      QTAILQ_INIT(&cpu->breakpoints); <nl>      QTAILQ_INIT(&cpu->watchpoints); <nl>   <nl> -    cpu->trace_dstate = bitmap_new(trace_get_vcpu_event_count()); <nl> +    count = trace_get_vcpu_event_count(); <nl> +    if (count) { <nl> +        cpu->trace_dstate = bitmap_new(count); <nl> +    } <nl>   <nl>      cpu_exec_initfn(cpu); <nl>  }
@@ -1937,7 +1937,7 @@ static int xen_pt_config_reg_init(XenPCIPassthroughState *s, <nl>                  break; <nl>          case 4: rc = xen_host_pci_get_long(&s->real_device, offset, &val); <nl>                  break; <nl> -        default: assert(1); <nl> +        default: abort(); <nl>          } <nl>          if (rc) { <nl>              /* Serious issues when we cannot read the host values! */ <nl> @@ -1982,7 +1982,7 @@ static int xen_pt_config_reg_init(XenPCIPassthroughState *s, <nl>                  break; <nl>          case 4: pci_set_long(s->dev.config + offset, val); <nl>                  break; <nl> -        default: assert(1); <nl> +        default: abort(); <nl>          } <nl>          /* set register value pointer to the data. */ <nl>          reg_entry->ptr.byte = s->dev.config + offset;
@@ -693,6 +693,13 @@ int net_init_tap(const NetClientOptions *opts, const char *name, <nl>      queues = tap->has_queues ? tap->queues : 1; <nl>      vhostfdname = tap->has_vhostfd ? tap->vhostfd : NULL; <nl>   <nl> +    /* QEMU vlans does not support multiqueue tap, in this case peer is set. <nl> +     * For -netdev, peer is always NULL. */ <nl> +    if (peer && (tap->has_queues || tap->has_fds || tap->has_vhostfds)) { <nl> +        error_report("Multiqueue tap cannnot be used with QEMU vlans"); <nl> +        return -1; <nl> +    } <nl> + <nl>      if (tap->has_fd) { <nl>          if (tap->has_ifname || tap->has_script || tap->has_downscript || <nl>              tap->has_vnet_hdr || tap->has_helper || tap->has_queues ||
@@ -5237,7 +5237,7 @@ void helper_svm_check_intercept_param(uint32_t type, uint64_t param) <nl>              switch((uint32_t)ECX) { <nl>              case 0 ... 0x1fff: <nl>                  t0 = (ECX * 2) % 8; <nl> -                t1 = ECX / 8; <nl> +                t1 = (ECX * 2) / 8; <nl>                  break; <nl>              case 0xc0000000 ... 0xc0001fff: <nl>                  t0 = (8192 + ECX - 0xc0000000) * 2;
@@ -157,6 +157,11 @@ static size_t curl_read_cb(void *ptr, size_t size, size_t nmemb, void *opaque) <nl>      if (!s || !s->orig_buf) <nl>          goto read_end; <nl>   <nl> +    if (s->buf_off >= s->buf_len) { <nl> +        /* buffer full, read nothing */ <nl> +        return 0; <nl> +    } <nl> +    realsize = MIN(realsize, s->buf_len - s->buf_off); <nl>      memcpy(s->orig_buf + s->buf_off, ptr, realsize); <nl>      s->buf_off += realsize; <nl>  
@@ -3281,6 +3281,7 @@ void cpu_unregister_map_client(void *_client) <nl>      MapClient *client = (MapClient *)_client; <nl>   <nl>      LIST_REMOVE(client, link); <nl> +    qemu_free(client); <nl>  } <nl>   <nl>  static void cpu_notify_map_clients(void) <nl> @@ -3290,7 +3291,7 @@ static void cpu_notify_map_clients(void) <nl>      while (!LIST_EMPTY(&map_client_list)) { <nl>          client = LIST_FIRST(&map_client_list); <nl>          client->callback(client->opaque); <nl> -        LIST_REMOVE(client, link); <nl> +        cpu_unregister_map_client(client); <nl>      } <nl>  } <nl>  
@@ -89,6 +89,7 @@ static int tpm_passthrough_unix_tx_bufs(TPMPassthruState *tpm_pt, <nl>      bool is_selftest; <nl>      const struct tpm_resp_hdr *hdr; <nl>   <nl> +    /* FIXME: protect shared variables or use other sync mechanism */ <nl>      tpm_pt->tpm_op_canceled = false; <nl>      tpm_pt->tpm_executing = true; <nl>      *selftest_done = false; <nl> @@ -178,12 +179,11 @@ static void tpm_passthrough_cancel_cmd(TPMBackend *tb) <nl>       */ <nl>      if (tpm_pt->tpm_executing) { <nl>          if (tpm_pt->cancel_fd >= 0) { <nl> +            tpm_pt->tpm_op_canceled = true; <nl>              n = write(tpm_pt->cancel_fd, "-", 1); <nl>              if (n != 1) { <nl>                  error_report("Canceling TPM command failed: %s", <nl>                               strerror(errno)); <nl> -            } else { <nl> -                tpm_pt->tpm_op_canceled = true; <nl>              } <nl>          } else { <nl>              error_report("Cannot cancel TPM command due to missing "
@@ -52,11 +52,14 @@ file_backend_memory_alloc(HostMemoryBackend *backend, Error **errp) <nl>      error_setg(errp, "-mem-path not supported on this host"); <nl>  #else <nl>      if (!memory_region_size(&backend->mr)) { <nl> +        gchar *path; <nl>          backend->force_prealloc = mem_prealloc; <nl> +        path = object_get_canonical_path(OBJECT(backend)); <nl>          memory_region_init_ram_from_file(&backend->mr, OBJECT(backend), <nl> -                                 object_get_canonical_path(OBJECT(backend)), <nl> +                                 path, <nl>                                   backend->size, fb->share, <nl>                                   fb->mem_path, errp); <nl> +        g_free(path); <nl>      } <nl>  #endif <nl>  }
@@ -43,6 +43,7 @@ void AcpiCpuHotplug_add(ACPIGPE *gpe, AcpiCpuHotplug *g, CPUState *cpu) <nl>   <nl>      *gpe->sts = *gpe->sts | ACPI_CPU_HOTPLUG_STATUS; <nl>      cpu_id = k->get_arch_id(CPU(cpu)); <nl> +    g_assert((cpu_id / 8) < ACPI_GPE_PROC_LEN); <nl>      g->sts[cpu_id / 8] |= (1 << (cpu_id % 8)); <nl>  } <nl>  
@@ -674,6 +674,7 @@ static int serial_post_load(void *opaque, int version_id) <nl>      } <nl>      /* Initialize fcr via setter to perform essential side-effects */ <nl>      serial_ioport_write(s, 0x02, s->fcr_vmstate); <nl> +    serial_update_parameters(s); <nl>      return 0; <nl>  } <nl>  
@@ -230,8 +230,17 @@ static int ssi_sd_load(QEMUFile *f, void *opaque, int version_id) <nl>      for (i = 0; i < 5; i++) <nl>          s->response[i] = qemu_get_be32(f); <nl>      s->arglen = qemu_get_be32(f); <nl> +    if (s->mode == SSI_SD_CMDARG && <nl> +        (s->arglen < 0 || s->arglen >= ARRAY_SIZE(s->cmdarg))) { <nl> +        return -EINVAL; <nl> +    } <nl>      s->response_pos = qemu_get_be32(f); <nl>      s->stopping = qemu_get_be32(f); <nl> +    if (s->mode == SSI_SD_RESPONSE && <nl> +        (s->response_pos < 0 || s->response_pos >= ARRAY_SIZE(s->response) || <nl> +        (!s->stopping && s->arglen > ARRAY_SIZE(s->response)))) { <nl> +        return -EINVAL; <nl> +    } <nl>   <nl>      ss->cs = qemu_get_be32(f); <nl>  
@@ -1557,13 +1557,8 @@ void bdrv_drain_all(void) <nl>      BlockDriverState *bs; <nl>   <nl>      while (busy) { <nl> -        /* FIXME: We do not have timer support here, so this is effectively <nl> -         * a busy wait. <nl> -         */ <nl>          QTAILQ_FOREACH(bs, &bdrv_states, list) { <nl> -            if (bdrv_start_throttled_reqs(bs)) { <nl> -                busy = true; <nl> -            } <nl> +            bdrv_start_throttled_reqs(bs); <nl>          } <nl>   <nl>          busy = bdrv_requests_pending_all();
@@ -724,8 +724,7 @@ static int ohci_service_iso_td(OHCIState *ohci, struct ohci_ed *ed, <nl>             ed->head & OHCI_DPTR_MASK, ed->tail & OHCI_DPTR_MASK, <nl>             iso_td.flags, iso_td.bp, iso_td.next, iso_td.be, <nl>             ohci->frame_number, starting_frame, <nl> -           frame_count, relative_frame_number, <nl> -           OHCI_BM(iso_td.flags, TD_DI), OHCI_BM(iso_td.flags, TD_CC)); <nl> +           frame_count, relative_frame_number); <nl>      trace_usb_ohci_iso_td_head_offset( <nl>             iso_td.offset[0], iso_td.offset[1], <nl>             iso_td.offset[2], iso_td.offset[3],
@@ -392,6 +392,11 @@ static void pc_init_pci_no_kvmclock(MachineState *machine) <nl>      has_pci_info = false; <nl>      has_acpi_build = false; <nl>      smbios_defaults = false; <nl> +    gigabyte_align = false; <nl> +    smbios_legacy_mode = true; <nl> +    has_reserved_memory = false; <nl> +    option_rom_has_mr = true; <nl> +    rom_file_has_mr = false; <nl>      x86_cpu_compat_disable_kvm_features(FEAT_KVM, KVM_FEATURE_PV_EOI); <nl>      enable_compat_apic_id_mode(); <nl>      pc_init1(machine, 1, 0); <nl> @@ -402,6 +407,11 @@ static void pc_init_isa(MachineState *machine) <nl>      has_pci_info = false; <nl>      has_acpi_build = false; <nl>      smbios_defaults = false; <nl> +    gigabyte_align = false; <nl> +    smbios_legacy_mode = true; <nl> +    has_reserved_memory = false; <nl> +    option_rom_has_mr = true; <nl> +    rom_file_has_mr = false; <nl>      if (!machine->cpu_model) { <nl>          machine->cpu_model = "486"; <nl>      }
@@ -213,9 +213,6 @@ void exynos4210_init_board_irqs(Exynos4210Irq *s) <nl>      uint32_t grp, bit, irq_id, n; <nl>   <nl>      for (n = 0; n < EXYNOS4210_MAX_EXT_COMBINER_IN_IRQ; n++) { <nl> -        s->board_irqs[n] = qemu_irq_split(s->int_combiner_irq[n], <nl> -                s->ext_combiner_irq[n]); <nl> - <nl>          irq_id = 0; <nl>          if (n == EXYNOS4210_COMBINER_GET_IRQ_NUM(1, 4) || <nl>                  n == EXYNOS4210_COMBINER_GET_IRQ_NUM(12, 4)) { <nl> @@ -230,8 +227,10 @@ void exynos4210_init_board_irqs(Exynos4210Irq *s) <nl>          if (irq_id) { <nl>              s->board_irqs[n] = qemu_irq_split(s->int_combiner_irq[n], <nl>                      s->ext_gic_irq[irq_id-32]); <nl> +        } else { <nl> +            s->board_irqs[n] = qemu_irq_split(s->int_combiner_irq[n], <nl> +                    s->ext_combiner_irq[n]); <nl>          } <nl> - <nl>      } <nl>      for (; n < EXYNOS4210_MAX_INT_COMBINER_IN_IRQ; n++) { <nl>          /* these IDs are passed to Internal Combiner and External GIC */
@@ -121,8 +121,8 @@ static int vhost_user_read(struct vhost_dev *dev, VhostUserMsg *msg) <nl>   <nl>      r = qemu_chr_fe_read_all(chr, p, size); <nl>      if (r != size) { <nl> -        error_report("Failed to read msg header. Read %d instead of %d.", r, <nl> -                size); <nl> +        error_report("Failed to read msg header. Read %d instead of %d." <nl> +                     " Original request %d.", r, size, msg->request); <nl>          goto fail; <nl>      } <nl>  
@@ -986,7 +986,7 @@ static void pci_info_device(PCIBus *bus, PCIDevice *d) <nl>                         base, limit); <nl>   <nl>          base = pci_bridge_get_base(d, PCI_BASE_ADDRESS_SPACE_MEMORY); <nl> -        limit= pci_config_get_memory_base(d, PCI_BASE_ADDRESS_SPACE_MEMORY); <nl> +        limit= pci_bridge_get_limit(d, PCI_BASE_ADDRESS_SPACE_MEMORY); <nl>          monitor_printf(mon, <nl>                         "      memory range [0x%08"PRIx64", 0x%08"PRIx64"]\n", <nl>                         base, limit);
@@ -2131,14 +2131,14 @@ static void x86_cpu_realizefn(DeviceState *dev, Error **errp) <nl>          env->cpuid_ext3_features &= TCG_EXT3_FEATURES; <nl>          env->cpuid_svm_features &= TCG_SVM_FEATURES; <nl>      } else { <nl> -#ifdef CONFIG_KVM <nl> -        filter_features_for_kvm(cpu); <nl> -#endif <nl>          if (check_cpuid && kvm_check_features_against_host(cpu) <nl>              && enforce_cpuid) { <nl>              error_setg(errp, "Host's CPU doesn't support requested features"); <nl>              return; <nl>          } <nl> +#ifdef CONFIG_KVM <nl> +        filter_features_for_kvm(cpu); <nl> +#endif <nl>      } <nl>   <nl>  #ifndef CONFIG_USER_ONLY
@@ -337,6 +337,7 @@ void memory_mapping_filter(MemoryMappingList *list, int64_t begin, <nl>          if (cur->phys_addr >= begin + length || <nl>              cur->phys_addr + cur->length <= begin) { <nl>              QTAILQ_REMOVE(&list->head, cur, next); <nl> +            g_free(cur); <nl>              list->num--; <nl>              continue; <nl>          }
@@ -1634,12 +1634,12 @@ static always_inline int translate_one (DisasContext *ctx, uint32_t insn) <nl>          break; <nl>  #endif <nl>      case 0x1A: <nl> -        if (ra != 31) <nl> -            tcg_gen_movi_i64(cpu_ir[ra], ctx->pc); <nl>          if (rb != 31) <nl>              tcg_gen_andi_i64(cpu_pc, cpu_ir[rb], ~3); <nl>          else <nl>              tcg_gen_movi_i64(cpu_pc, 0); <nl> +        if (ra != 31) <nl> +            tcg_gen_movi_i64(cpu_ir[ra], ctx->pc); <nl>          /* Those four jumps only differ by the branch prediction hint */ <nl>          switch (fn2) { <nl>          case 0x0:
@@ -679,6 +679,8 @@ void hmp_info_block_jobs(Monitor *mon, const QDict *qdict) <nl>          } <nl>          list = list->next; <nl>      } <nl> + <nl> +    qapi_free_BlockJobInfoList(list); <nl>  } <nl>   <nl>  void hmp_info_tpm(Monitor *mon, const QDict *qdict)
@@ -459,7 +459,7 @@ static int qemu_rbd_open(BlockDriverState *bs, QDict *options, int flags, <nl>      clientname = qemu_rbd_parse_clientname(conf, clientname_buf); <nl>      r = rados_create(&s->cluster, clientname); <nl>      if (r < 0) { <nl> -        error_setg(&local_err, "error initializing"); <nl> +        error_setg(errp, "error initializing"); <nl>          goto failed_opts; <nl>      } <nl>   <nl> @@ -495,19 +495,19 @@ static int qemu_rbd_open(BlockDriverState *bs, QDict *options, int flags, <nl>   <nl>      r = rados_connect(s->cluster); <nl>      if (r < 0) { <nl> -        error_setg(&local_err, "error connecting"); <nl> +        error_setg(errp, "error connecting"); <nl>          goto failed_shutdown; <nl>      } <nl>   <nl>      r = rados_ioctx_create(s->cluster, pool, &s->io_ctx); <nl>      if (r < 0) { <nl> -        error_setg(&local_err, "error opening pool %s", pool); <nl> +        error_setg(errp, "error opening pool %s", pool); <nl>          goto failed_shutdown; <nl>      } <nl>   <nl>      r = rbd_open(s->io_ctx, s->name, &s->image, s->snap); <nl>      if (r < 0) { <nl> -        error_setg(&local_err, "error reading header from %s", s->name); <nl> +        error_setg(errp, "error reading header from %s", s->name); <nl>          goto failed_open; <nl>      } <nl>  
@@ -233,6 +233,8 @@ static Property vhost_scsi_properties[] = { <nl>      DEFINE_PROP_STRING("wwpn", VirtIOSCSICommon, conf.wwpn), <nl>      DEFINE_PROP_UINT32("boot_tpgt", VirtIOSCSICommon, conf.boot_tpgt, 0), <nl>      DEFINE_PROP_UINT32("num_queues", VirtIOSCSICommon, conf.num_queues, 1), <nl> +    DEFINE_PROP_UINT32("virtqueue_size", VirtIOSCSICommon, conf.virtqueue_size, <nl> +                       128), <nl>      DEFINE_PROP_UINT32("max_sectors", VirtIOSCSICommon, conf.max_sectors, <nl>                         0xFFFF), <nl>      DEFINE_PROP_UINT32("cmd_per_lun", VirtIOSCSICommon, conf.cmd_per_lun, 128),
@@ -391,8 +391,12 @@ static int raw_pread(BlockDriverState *bs, int64_t offset, <nl>                      size = ALIGNED_BUFFER_SIZE; <nl>   <nl>                  ret = raw_pread_aligned(bs, offset, s->aligned_buf, size); <nl> -                if (ret < 0) <nl> +                if (ret < 0) { <nl>                      return ret; <nl> +                } else if (ret == 0) { <nl> +                    fprintf(stderr, "raw_pread: read beyond end of file\n"); <nl> +                    abort(); <nl> +                } <nl>   <nl>                  size = ret; <nl>                  if (size > count)
@@ -394,7 +394,8 @@ static int qdev_add_one_global(QemuOpts *opts, void *opaque) <nl>      g->driver   = qemu_opt_get(opts, "driver"); <nl>      g->property = qemu_opt_get(opts, "property"); <nl>      g->value    = qemu_opt_get(opts, "value"); <nl> -    oc = object_class_by_name(g->driver); <nl> +    oc = object_class_dynamic_cast(object_class_by_name(g->driver), <nl> +                                   TYPE_DEVICE); <nl>      if (oc) { <nl>          DeviceClass *dc = DEVICE_CLASS(oc); <nl>  
@@ -664,7 +664,7 @@ static ssize_t gem_receive(VLANClientState *nc, const uint8_t *buf, size_t size) <nl>           */ <nl>   <nl>          memcpy(rxbuf, buf, size); <nl> -        memset(rxbuf + size, 0, sizeof(rxbuf - size)); <nl> +        memset(rxbuf + size, 0, sizeof(rxbuf) - size); <nl>          rxbuf_ptr = rxbuf; <nl>          crc_val = cpu_to_le32(crc32(0, rxbuf, MAX(size, 60))); <nl>          if (size < 60) {
@@ -2024,7 +2024,7 @@ static int vtd_irte_get(IntelIOMMUState *iommu, uint16_t index, <nl>  /* Fetch IRQ information of specific IR index */ <nl>  static int vtd_remap_irq_get(IntelIOMMUState *iommu, uint16_t index, VTDIrq *irq) <nl>  { <nl> -    VTD_IRTE irte = { 0 }; <nl> +    VTD_IRTE irte = {}; <nl>      int ret = 0; <nl>   <nl>      ret = vtd_irte_get(iommu, index, &irte); <nl> @@ -2082,7 +2082,7 @@ static int vtd_interrupt_remap_msi(IntelIOMMUState *iommu, <nl>      int ret = 0; <nl>      VTD_IR_MSIAddress addr; <nl>      uint16_t index; <nl> -    VTDIrq irq = {0}; <nl> +    VTDIrq irq = {}; <nl>   <nl>      assert(origin && translated); <nl>   <nl> @@ -2176,7 +2176,7 @@ static MemTxResult vtd_mem_ir_write(void *opaque, hwaddr addr, <nl>                                      MemTxAttrs attrs) <nl>  { <nl>      int ret = 0; <nl> -    MSIMessage from = {0}, to = {0}; <nl> +    MSIMessage from = {}, to = {}; <nl>   <nl>      from.address = (uint64_t) addr + VTD_INTERRUPT_ADDR_FIRST; <nl>      from.data = (uint32_t) value;
@@ -1943,6 +1943,7 @@ void memory_listener_unregister(MemoryListener *listener) <nl>   <nl>  void address_space_init(AddressSpace *as, MemoryRegion *root, const char *name) <nl>  { <nl> +    memory_region_ref(root); <nl>      memory_region_transaction_begin(); <nl>      as->root = root; <nl>      as->current_map = g_new(FlatView, 1); <nl> @@ -1969,10 +1970,13 @@ static void do_address_space_destroy(AddressSpace *as) <nl>      flatview_unref(as->current_map); <nl>      g_free(as->name); <nl>      g_free(as->ioeventfds); <nl> +    memory_region_unref(as->root); <nl>  } <nl>   <nl>  void address_space_destroy(AddressSpace *as) <nl>  { <nl> +    MemoryRegion *root = as->root; <nl> + <nl>      /* Flush out anything from MemoryListeners listening in on this */ <nl>      memory_region_transaction_begin(); <nl>      as->root = NULL; <nl> @@ -1984,6 +1988,7 @@ void address_space_destroy(AddressSpace *as) <nl>       * entries that the guest should never use.  Wait for the old <nl>       * values to expire before freeing the data. <nl>       */ <nl> +    as->root = root; <nl>      call_rcu(as, do_address_space_destroy, rcu); <nl>  } <nl>  
@@ -86,6 +86,7 @@ static void qmp_input_start_struct(Visitor *v, void **obj, const char *kind, <nl>  { <nl>      QmpInputVisitor *qiv = to_qiv(v); <nl>      const QObject *qobj = qmp_input_get_object(qiv, name); <nl> +    Error *err = NULL; <nl>   <nl>      if (!qobj || qobject_type(qobj) != QTYPE_QDICT) { <nl>          error_set(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : "null", <nl> @@ -93,8 +94,9 @@ static void qmp_input_start_struct(Visitor *v, void **obj, const char *kind, <nl>          return; <nl>      } <nl>   <nl> -    qmp_input_push(qiv, qobj, errp); <nl> -    if (error_is_set(errp)) { <nl> +    qmp_input_push(qiv, qobj, &err); <nl> +    if (err) { <nl> +        error_propagate(errp, err); <nl>          return; <nl>      } <nl>  
@@ -205,13 +205,13 @@ extern int daemon(int, int); <nl>   <nl>  /* Round number up to multiple. Requires that d be a power of 2 (see <nl>   * QEMU_ALIGN_UP for a safer but slower version on arbitrary <nl> - * numbers) */ <nl> + * numbers); works even if d is a smaller type than n.  */ <nl>  #ifndef ROUND_UP <nl> -#define ROUND_UP(n,d) (((n) + (d) - 1) & -(d)) <nl> +#define ROUND_UP(n, d) (((n) + (d) - 1) & -(0 ? (n) : (d))) <nl>  #endif <nl>   <nl>  #ifndef DIV_ROUND_UP <nl> -#define DIV_ROUND_UP(n,d) (((n) + (d) - 1) / (d)) <nl> +#define DIV_ROUND_UP(n, d) (((n) + (d) - 1) / (d)) <nl>  #endif <nl>   <nl>  /*
@@ -1146,7 +1146,9 @@ static ssize_t rtl8139_do_receive(NetClientState *nc, const uint8_t *buf, size_t <nl>   <nl>          /* if receiver buffer is empty then avail == 0 */ <nl>   <nl> -        if (avail != 0 && size + 8 >= avail) <nl> +#define RX_ALIGN(x) (((x) + 3) & ~0x3) <nl> + <nl> +        if (avail != 0 && RX_ALIGN(size + 8) >= avail) <nl>          { <nl>              DPRINTF("rx overflow: rx buffer length %d head 0x%04x " <nl>                  "read 0x%04x === available 0x%04x need 0x%04x\n", <nl> @@ -1174,7 +1176,7 @@ static ssize_t rtl8139_do_receive(NetClientState *nc, const uint8_t *buf, size_t <nl>          rtl8139_write_buffer(s, (uint8_t *)&val, 4); <nl>   <nl>          /* correct buffer write pointer */ <nl> -        s->RxBufAddr = MOD2((s->RxBufAddr + 3) & ~0x3, s->RxBufferSize); <nl> +        s->RxBufAddr = MOD2(RX_ALIGN(s->RxBufAddr), s->RxBufferSize); <nl>   <nl>          /* now we can signal we have received something */ <nl>  
@@ -4312,8 +4312,9 @@ int main(int argc, char **argv, char **envp) <nl>      /* init remote displays */ <nl>      qemu_opts_foreach(qemu_find_opts("vnc"), vnc_init_func, NULL, 0); <nl>      if (show_vnc_port) { <nl> -        printf("VNC server running on `%s'\n", <nl> -               vnc_display_local_addr("default")); <nl> +        char *ret = vnc_display_local_addr("default"); <nl> +        printf("VNC server running on `%s'\n", ret); <nl> +        g_free(ret); <nl>      } <nl>  #endif <nl>  #ifdef CONFIG_SPICE
@@ -1065,6 +1065,13 @@ static int bdrv_open_common(BlockDriverState *bs, BlockDriverState *file, <nl>          goto free_and_fail; <nl>      } <nl>   <nl> +    if (bs->encrypted) { <nl> +        error_report("Encrypted images are deprecated"); <nl> +        error_printf("Support for them will be removed in a future release.\n" <nl> +                     "You can use 'qemu-img convert' to convert your image" <nl> +                     " to an unencrypted one.\n"); <nl> +    } <nl> + <nl>      ret = refresh_total_sectors(bs, bs->total_sectors); <nl>      if (ret < 0) { <nl>          error_setg_errno(errp, -ret, "Could not refresh total sector count");
@@ -135,7 +135,7 @@ create_iovec(QEMUIOVector *qiov, char **argv, int nr_iov, int pattern) <nl>   <nl>  	for (i = 0; i < nr_iov; i++) { <nl>  		char *arg = argv[i]; <nl> -                uint64_t len; <nl> +                int64_t len; <nl>   <nl>  		len = cvtnum(arg); <nl>  		if (len < 0) { <nl> @@ -144,7 +144,7 @@ create_iovec(QEMUIOVector *qiov, char **argv, int nr_iov, int pattern) <nl>  		} <nl>   <nl>  		/* should be SIZE_T_MAX, but that doesn't exist */ <nl> -		if (len > UINT_MAX) { <nl> +		if (len > INT_MAX) { <nl>  			printf("too large length argument -- %s\n", arg); <nl>  			goto fail; <nl>  		}
@@ -304,9 +304,9 @@ qcrypto_tls_session_check_certificate(QCryptoTLSSession *session, <nl>   <nl>                  allow = qemu_acl_party_is_allowed(acl, session->peername); <nl>   <nl> -                error_setg(errp, "TLS x509 ACL check for %s is %s", <nl> -                           session->peername, allow ? "allowed" : "denied"); <nl>                  if (!allow) { <nl> +                    error_setg(errp, "TLS x509 ACL check for %s is denied", <nl> +                               session->peername); <nl>                      goto error; <nl>                  } <nl>              }
@@ -1789,9 +1789,13 @@ static void ide_init1(IDEBus *bus, int unit) <nl>      s->unit = unit; <nl>      s->drive_serial = drive_serial++; <nl>      /* we need at least 2k alignment for accessing CDROMs using O_DIRECT */ <nl> -    s->io_buffer = qemu_memalign(2048, IDE_DMA_BUF_SECTORS*512 + 4); <nl>      s->io_buffer_total_len = IDE_DMA_BUF_SECTORS*512 + 4; <nl> +    s->io_buffer = qemu_memalign(2048, s->io_buffer_total_len); <nl> +    memset(s->io_buffer, 0, s->io_buffer_total_len); <nl> + <nl>      s->smart_selftest_data = qemu_blockalign(s->bs, 512); <nl> +    memset(s->smart_selftest_data, 0, 512); <nl> + <nl>      s->sector_write_timer = qemu_new_timer_ns(vm_clock, <nl>                                             ide_sector_write_timer_cb, s); <nl>  }
@@ -527,6 +527,7 @@ DeviceState *qdev_device_add(QemuOpts *opts) <nl>      } <nl>      if (qemu_opt_foreach(opts, set_property, qdev, 1) != 0) { <nl>          qdev_free(qdev); <nl> +        object_unref(OBJECT(qdev)); <nl>          return NULL; <nl>      } <nl>      if (qdev->id) { <nl> @@ -540,6 +541,7 @@ DeviceState *qdev_device_add(QemuOpts *opts) <nl>          g_free(name); <nl>      }         <nl>      if (qdev_init(qdev) < 0) { <nl> +        object_unref(OBJECT(qdev)); <nl>          qerror_report(QERR_DEVICE_INIT_FAILED, driver); <nl>          return NULL; <nl>      }
@@ -295,6 +295,7 @@ static BlockBackend *img_open_opts(const char *optstr, <nl>          if (qdict_haskey(options, BDRV_OPT_FORCE_SHARE) <nl>              && !qdict_get_bool(options, BDRV_OPT_FORCE_SHARE)) { <nl>              error_report("--force-share/-U conflicts with image options"); <nl> +            QDECREF(options); <nl>              return NULL; <nl>          } <nl>          qdict_put(options, BDRV_OPT_FORCE_SHARE, qbool_from_bool(true));
@@ -743,7 +743,6 @@ static int bdrv_open_common(BlockDriverState *bs, BlockDriverState *file, <nl>              ret = -EINVAL; <nl>              goto free_and_fail; <nl>          } <nl> -        assert(file != NULL); <nl>          bs->file = file; <nl>          ret = drv->bdrv_open(bs, options, open_flags); <nl>      }
@@ -184,8 +184,8 @@ static void kvm_apic_realize(DeviceState *dev, Error **errp) <nl>  { <nl>      APICCommonState *s = APIC_COMMON(dev); <nl>   <nl> -    memory_region_init_io(&s->io_memory, NULL, &kvm_apic_io_ops, s, "kvm-apic-msi", <nl> -                          APIC_SPACE_SIZE); <nl> +    memory_region_init_io(&s->io_memory, OBJECT(s), &kvm_apic_io_ops, s, <nl> +                          "kvm-apic-msi", APIC_SPACE_SIZE); <nl>   <nl>      if (kvm_has_gsi_routing()) { <nl>          msi_nonbroken = true;
@@ -7,7 +7,6 @@ <nl>  #include "sysemu/blockdev.h" <nl>  #include "trace.h" <nl>  #include "sysemu/dma.h" <nl> -#include "qapi/qmp/qerror.h" <nl>   <nl>  static char *scsibus_get_dev_path(DeviceState *dev); <nl>  static char *scsibus_get_fw_dev_path(DeviceState *dev); <nl> @@ -245,9 +244,7 @@ SCSIDevice *scsi_bus_legacy_add_drive(SCSIBus *bus, BlockBackend *blk, <nl>      } <nl>      qdev_prop_set_drive(dev, "drive", blk, &err); <nl>      if (err) { <nl> -        qerror_report_err(err); <nl> -        error_free(err); <nl> -        error_setg(errp, "Setting drive property failed"); <nl> +        error_propagate(errp, err); <nl>          object_unparent(OBJECT(dev)); <nl>          return NULL; <nl>      }
@@ -1002,11 +1002,9 @@ static void virtio_pci_device_plugged(DeviceState *d) <nl>   <nl>  static void virtio_pci_device_unplugged(DeviceState *d) <nl>  { <nl> -    PCIDevice *pci_dev = PCI_DEVICE(d); <nl>      VirtIOPCIProxy *proxy = VIRTIO_PCI(d); <nl>   <nl>      virtio_pci_stop_ioeventfd(proxy); <nl> -    msix_uninit_exclusive_bar(pci_dev); <nl>  } <nl>   <nl>  static int virtio_pci_init(PCIDevice *pci_dev) <nl> @@ -1023,6 +1021,8 @@ static int virtio_pci_init(PCIDevice *pci_dev) <nl>  static void virtio_pci_exit(PCIDevice *pci_dev) <nl>  { <nl>      VirtIOPCIProxy *proxy = VIRTIO_PCI(pci_dev); <nl> + <nl> +    msix_uninit_exclusive_bar(pci_dev); <nl>      memory_region_destroy(&proxy->bar); <nl>  } <nl>  
@@ -3013,6 +3013,8 @@ void gen_intermediate_code(CPUAlphaState *env, struct TranslationBlock *tb) <nl>      } <nl>   <nl>      gen_tb_start(tb); <nl> +    tcg_clear_temp_count(); <nl> + <nl>      do { <nl>          tcg_gen_insn_start(ctx.pc); <nl>          num_insns++; <nl> @@ -3035,6 +3037,10 @@ void gen_intermediate_code(CPUAlphaState *env, struct TranslationBlock *tb) <nl>          ret = translate_one(ctxp, insn); <nl>          free_context_temps(ctxp); <nl>   <nl> +        if (tcg_check_temp_count()) { <nl> +            qemu_log("TCG temporary leak before "TARGET_FMT_lx"\n", ctx.pc); <nl> +        } <nl> + <nl>          /* If we reach a page boundary, are single stepping, <nl>             or exhaust instruction count, stop generation.  */ <nl>          if (ret == NO_EXIT
@@ -1144,6 +1144,12 @@ static void dec_fpu(DisasContext *dc) <nl>   <nl>  static void dec_null(DisasContext *dc) <nl>  { <nl> +    if ((dc->tb_flags & MSR_EE_FLAG) <nl> +          && (dc->env->pvr.regs[2] & PVR2_ILL_OPCODE_EXC_MASK)) { <nl> +        tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_ILLEGAL_OP); <nl> +        t_gen_raise_exception(dc, EXCP_HW_EXCP); <nl> +        return; <nl> +    } <nl>      qemu_log ("unknown insn pc=%x opc=%x\n", dc->pc, dc->opcode); <nl>      dc->abort_at_next_insn = 1; <nl>  }
@@ -1426,6 +1426,7 @@ static int ehci_process_itd(EHCIState *ehci, <nl>              if (off + len > 4096) { <nl>                  /* transfer crosses page border */ <nl>                  if (pg == 6) { <nl> +                    qemu_sglist_destroy(&ehci->isgl); <nl>                      return -1;  /* avoid page pg + 1 */ <nl>                  } <nl>                  ptr2 = (itd->bufptr[pg + 1] & ITD_BUFPTR_MASK);
@@ -775,7 +775,7 @@ static void xenfb_handle_events(struct XenFB *xenfb) <nl>   <nl>      prod = page->out_prod; <nl>      out_cons = page->out_cons; <nl> -    if (prod - out_cons >= XENFB_OUT_RING_LEN) { <nl> +    if (prod - out_cons > XENFB_OUT_RING_LEN) { <nl>          return; <nl>      } <nl>      xen_rmb();		/* ensure we see ring contents up to prod */
@@ -415,6 +415,14 @@ bool virtio_blk_data_plane_create(VirtIODevice *vdev, VirtIOBlkConf *blk, <nl>          return false; <nl>      } <nl>   <nl> +    /* If dataplane is (re-)enabled while the guest is running there could be <nl> +     * block jobs that can conflict. <nl> +     */ <nl> +    if (bdrv_in_use(blk->conf.bs)) { <nl> +        error_report("cannot start dataplane thread while device is in use"); <nl> +        return false; <nl> +    } <nl> + <nl>      fd = raw_get_aio_fd(blk->conf.bs); <nl>      if (fd < 0) { <nl>          error_report("drive is incompatible with x-data-plane, "
@@ -1137,6 +1137,11 @@ int bdrv_open(BlockDriverState *bs, const char *filename, QDict *options, <nl>      if (drvname) { <nl>          drv = bdrv_find_format(drvname); <nl>          qdict_del(options, "driver"); <nl> +        if (!drv) { <nl> +            error_setg(errp, "Invalid driver: '%s'", drvname); <nl> +            ret = -EINVAL; <nl> +            goto unlink_and_fail; <nl> +        } <nl>      } <nl>   <nl>      if (!drv) {
@@ -351,16 +351,22 @@ qcrypto_tls_session_check_credentials(QCryptoTLSSession *session, <nl>  { <nl>      if (object_dynamic_cast(OBJECT(session->creds), <nl>                              TYPE_QCRYPTO_TLS_CREDS_ANON)) { <nl> +        trace_qcrypto_tls_session_check_creds(session, "nop"); <nl>          return 0; <nl>      } else if (object_dynamic_cast(OBJECT(session->creds), <nl>                              TYPE_QCRYPTO_TLS_CREDS_X509)) { <nl>          if (session->creds->verifyPeer) { <nl> -            return qcrypto_tls_session_check_certificate(session, <nl> -                                                         errp); <nl> +            int ret = qcrypto_tls_session_check_certificate(session, <nl> +                                                            errp); <nl> +            trace_qcrypto_tls_session_check_creds(session, <nl> +                                                  ret == 0 ? "pass" : "fail"); <nl> +            return ret; <nl>          } else { <nl> +            trace_qcrypto_tls_session_check_creds(session, "skip"); <nl>              return 0; <nl>          } <nl>      } else { <nl> +        trace_qcrypto_tls_session_check_creds(session, "error"); <nl>          error_setg(errp, "Unexpected credential type %s", <nl>                     object_get_typename(OBJECT(session->creds))); <nl>          return -1;
@@ -531,6 +531,7 @@ static void vmxnet3_complete_packet(VMXNET3State *s, int qidx, uint32_t tx_ridx) <nl>   <nl>      VMXNET3_RING_DUMP(VMW_RIPRN, "TXC", qidx, &s->txq_descr[qidx].comp_ring); <nl>   <nl> +    memset(&txcq_descr, 0, sizeof(txcq_descr)); <nl>      txcq_descr.txdIdx = tx_ridx; <nl>      txcq_descr.gen = vmxnet3_ring_curr_gen(&s->txq_descr[qidx].comp_ring); <nl>  
@@ -1312,11 +1312,6 @@ static void ppc_spapr_init(QEMUMachineInitArgs *args) <nl>                                     NULL, &lowaddr, NULL, 0, ELF_MACHINE, 0); <nl>              kernel_le = kernel_size > 0; <nl>          } <nl> -        if (kernel_size < 0) { <nl> -            kernel_size = load_image_targphys(kernel_filename, <nl> -                                              KERNEL_LOAD_ADDR, <nl> -                                              load_limit - KERNEL_LOAD_ADDR); <nl> -        } <nl>          if (kernel_size < 0) { <nl>              fprintf(stderr, "qemu: could not load kernel '%s'\n", <nl>                      kernel_filename);
@@ -1285,9 +1285,9 @@ DisplaySurface *qemu_create_displaysurface_guestmem(int width, int height, <nl>          linesize = width * PIXMAN_FORMAT_BPP(format) / 8; <nl>      } <nl>   <nl> -    size = linesize * height; <nl> +    size = (hwaddr)linesize * height; <nl>      data = cpu_physical_memory_map(addr, &size, 0); <nl> -    if (size != linesize * height) { <nl> +    if (size != (hwaddr)linesize * height) { <nl>          cpu_physical_memory_unmap(data, size, 0, 0); <nl>          return NULL; <nl>      }
@@ -1087,7 +1087,7 @@ void console_select(unsigned int index) <nl>      if (s) { <nl>          DisplayState *ds = s->ds; <nl>   <nl> -        if (active_console->cursor_timer) { <nl> +        if (active_console && active_console->cursor_timer) { <nl>              qemu_del_timer(active_console->cursor_timer); <nl>          } <nl>          active_console = s;
@@ -379,7 +379,15 @@ static int virtio_net_has_buffers(VirtIONet *n, int bufsize) <nl>          (n->mergeable_rx_bufs && <nl>           !virtqueue_avail_bytes(n->rx_vq, bufsize, 0))) { <nl>          virtio_queue_set_notification(n->rx_vq, 1); <nl> -        return 0; <nl> + <nl> +        /* To avoid a race condition where the guest has made some buffers <nl> +         * available after the above check but before notification was <nl> +         * enabled, check for available buffers again. <nl> +         */ <nl> +        if (virtio_queue_empty(n->rx_vq) || <nl> +            (n->mergeable_rx_bufs && <nl> +             !virtqueue_avail_bytes(n->rx_vq, bufsize, 0))) <nl> +            return 0; <nl>      } <nl>   <nl>      virtio_queue_set_notification(n->rx_vq, 0);
@@ -55,8 +55,8 @@ static AddrRange addrrange_shift(AddrRange range, int64_t delta) <nl>   <nl>  static bool addrrange_intersects(AddrRange r1, AddrRange r2) <nl>  { <nl> -    return (r1.start >= r2.start && r1.start < r2.start + r2.size) <nl> -        || (r2.start >= r1.start && r2.start < r1.start + r1.size); <nl> +    return (r1.start >= r2.start && (r1.start - r2.start) < r2.size) <nl> +        || (r2.start >= r1.start && (r2.start - r1.start) < r1.size); <nl>  } <nl>   <nl>  static AddrRange addrrange_intersection(AddrRange r1, AddrRange r2)
@@ -22,13 +22,9 @@ <nl>   * THE SOFTWARE. <nl>   */ <nl>   <nl> -#include "sysemu/sysemu.h" <nl> -#include "monitor/monitor.h" <nl> -#include "ui/console.h" <nl> - <nl> -#include "hw/hw.h" <nl> - <nl> +#include "qemu/main-loop.h" <nl>  #include "qemu/timer.h" <nl> + <nl>  #ifdef CONFIG_POSIX <nl>  #include <pthread.h> <nl>  #endif
@@ -2828,6 +2828,7 @@ static void x86_cpu_apic_create(X86CPU *cpu, Error **errp) <nl>   <nl>      object_property_add_child(OBJECT(cpu), "lapic", <nl>                                OBJECT(cpu->apic_state), &error_abort); <nl> +    object_unref(OBJECT(cpu->apic_state)); <nl>   <nl>      qdev_prop_set_uint8(cpu->apic_state, "id", cpu->apic_id); <nl>      /* TODO: convert to link<> */
@@ -158,6 +158,7 @@ static int blkverify_open(BlockDriverState *bs, QDict *options, int flags, <nl>   <nl>      ret = 0; <nl>  fail: <nl> +    qemu_opts_del(opts); <nl>      return ret; <nl>  } <nl>  
@@ -645,7 +645,7 @@ static int pmsav5_insn_ap_read(CPUARMState *env, const ARMCPRegInfo *ri, <nl>  static int arm946_prbs_read(CPUARMState *env, const ARMCPRegInfo *ri, <nl>                              uint64_t *value) <nl>  { <nl> -    if (ri->crm > 8) { <nl> +    if (ri->crm >= 8) { <nl>          return EXCP_UDEF; <nl>      } <nl>      *value = env->cp15.c6_region[ri->crm]; <nl> @@ -655,7 +655,7 @@ static int arm946_prbs_read(CPUARMState *env, const ARMCPRegInfo *ri, <nl>  static int arm946_prbs_write(CPUARMState *env, const ARMCPRegInfo *ri, <nl>                               uint64_t value) <nl>  { <nl> -    if (ri->crm > 8) { <nl> +    if (ri->crm >= 8) { <nl>          return EXCP_UDEF; <nl>      } <nl>      env->cp15.c6_region[ri->crm] = value;
@@ -217,7 +217,7 @@ static void stm32f2xx_timer_write(void *opaque, hwaddr offset, <nl>          return; <nl>      case TIM_PSC: <nl>          timer_val = stm32f2xx_ns_to_ticks(s, now) - s->tick_offset; <nl> -        s->tim_psc = value; <nl> +        s->tim_psc = value & 0xFFFF; <nl>          value = timer_val; <nl>          break; <nl>      case TIM_CNT:
@@ -1394,7 +1394,7 @@ GEN_LOGICAL2(nand, tcg_gen_nand_tl, 0x0E, PPC_INTEGER); <nl>  /* nor & nor. */ <nl>  GEN_LOGICAL2(nor, tcg_gen_nor_tl, 0x03, PPC_INTEGER); <nl>   <nl> -#if defined(TARGET_PPC64) <nl> +#if defined(TARGET_PPC64) && !defined(CONFIG_USER_ONLY) <nl>  static void gen_pause(DisasContext *ctx) <nl>  { <nl>      TCGv_i32 t0 = tcg_const_i32(0); <nl> @@ -1482,7 +1482,9 @@ static void gen_or(DisasContext *ctx) <nl>              /* Pause us out of TCG otherwise spin loops with smt_low <nl>               * eat too much CPU and the kernel hangs <nl>               */ <nl> +#if !defined(CONFIG_USER_ONLY) <nl>              gen_pause(ctx); <nl> +#endif <nl>          } <nl>  #endif <nl>      }
@@ -193,14 +193,15 @@ int pci_bus_num(PCIBus *s) <nl>  static int get_pci_config_device(QEMUFile *f, void *pv, size_t size) <nl>  { <nl>      PCIDevice *s = container_of(pv, PCIDevice, config); <nl> -    uint8_t config[size]; <nl> +    uint8_t config[PCI_CONFIG_SPACE_SIZE]; <nl>      int i; <nl>   <nl> -    qemu_get_buffer(f, config, size); <nl> -    for (i = 0; i < size; ++i) <nl> +    assert(size == sizeof config); <nl> +    qemu_get_buffer(f, config, sizeof config); <nl> +    for (i = 0; i < sizeof config; ++i) <nl>          if ((config[i] ^ s->config[i]) & s->cmask[i] & ~s->wmask[i]) <nl>              return -EINVAL; <nl> -    memcpy(s->config, config, size); <nl> +    memcpy(s->config, config, sizeof config); <nl>   <nl>      pci_update_mappings(s); <nl>  
@@ -1136,7 +1136,7 @@ static int img_rebase(int argc, char **argv) <nl>      if (!unsafe) { <nl>          uint64_t num_sectors; <nl>          uint64_t sector; <nl> -        int n, n1; <nl> +        int n; <nl>          uint8_t * buf_old; <nl>          uint8_t * buf_new; <nl>   <nl> @@ -1155,8 +1155,8 @@ static int img_rebase(int argc, char **argv) <nl>              } <nl>   <nl>              /* If the cluster is allocated, we don't need to take action */ <nl> -            if (bdrv_is_allocated(bs, sector, n, &n1)) { <nl> -                n = n1; <nl> +            ret = bdrv_is_allocated(bs, sector, n, &n); <nl> +            if (ret) { <nl>                  continue; <nl>              } <nl>  
@@ -297,7 +297,11 @@ static void gt64120_pci_mapping(GT64120State *s) <nl>        s->PCI0IO_start = s->regs[GT_PCI0IOLD] << 21; <nl>        s->PCI0IO_length = ((s->regs[GT_PCI0IOHD] + 1) - (s->regs[GT_PCI0IOLD] & 0x7f)) << 21; <nl>        isa_mem_base = s->PCI0IO_start; <nl> -      isa_mmio_init(s->PCI0IO_start, s->PCI0IO_length); <nl> +      if (s->PCI0IO_length) { <nl> +          isa_mmio_setup(&s->PCI0IO_mem, s->PCI0IO_length); <nl> +          memory_region_add_subregion(get_system_memory(), s->PCI0IO_start, <nl> +                                      &s->PCI0IO_mem); <nl> +      } <nl>      } <nl>  } <nl>  
@@ -3536,6 +3536,13 @@ void cpu_physical_memory_write_rom(target_phys_addr_t addr, <nl>              /* ROM/RAM case */ <nl>              ptr = qemu_get_ram_ptr(addr1); <nl>              memcpy(ptr, buf, l); <nl> +            if (!cpu_physical_memory_is_dirty(addr1)) { <nl> +                /* invalidate code */ <nl> +                tb_invalidate_phys_page_range(addr1, addr1 + l, 0); <nl> +                /* set dirty bit */ <nl> +                cpu_physical_memory_set_dirty_flags( <nl> +                    addr1, (0xff & ~CODE_DIRTY_FLAG)); <nl> +            } <nl>              qemu_put_ram_ptr(ptr); <nl>          } <nl>          len -= l;
@@ -6,6 +6,7 @@ <nl>   */ <nl>  #include "qemu/osdep.h" <nl>  #include "qemu/qht.h" <nl> +#include "qemu/rcu.h" <nl>   <nl>  #define N 5000 <nl>   <nl> @@ -51,6 +52,7 @@ static void check(int a, int b, bool expected) <nl>      struct qht_stats stats; <nl>      int i; <nl>   <nl> +    rcu_read_lock(); <nl>      for (i = a; i < b; i++) { <nl>          void *p; <nl>          uint32_t hash; <nl> @@ -61,6 +63,8 @@ static void check(int a, int b, bool expected) <nl>          p = qht_lookup(&ht, is_equal, &val, hash); <nl>          g_assert_true(!!p == expected); <nl>      } <nl> +    rcu_read_unlock(); <nl> + <nl>      qht_statistics_init(&ht, &stats); <nl>      if (stats.used_head_buckets) { <nl>          g_assert_cmpfloat(qdist_avg(&stats.chain), >=, 1.0);
@@ -22,6 +22,7 @@ <nl>  #include "kvm_i386.h" <nl>  #include "hw/sysbus.h" <nl>  #include "hw/kvm/clock.h" <nl> +#include "qapi/error.h" <nl>   <nl>  #include <linux/kvm.h> <nl>  #include <linux/kvm_para.h> <nl> @@ -208,6 +209,11 @@ static void kvmclock_realize(DeviceState *dev, Error **errp) <nl>  { <nl>      KVMClockState *s = KVM_CLOCK(dev); <nl>   <nl> +    if (!kvm_enabled()) { <nl> +        error_setg(errp, "kvmclock device requires KVM"); <nl> +        return; <nl> +    } <nl> + <nl>      kvm_update_clock(s); <nl>   <nl>      qemu_add_vm_change_state_handler(kvmclock_vm_state_change, s);
@@ -681,6 +681,10 @@ int cpu_exec(CPUArchState *env) <nl>               * local variables as longjmp is marked 'noreturn'. */ <nl>              cpu = current_cpu; <nl>              env = cpu->env_ptr; <nl> +#if !(defined(CONFIG_USER_ONLY) && \ <nl> +      (defined(TARGET_M68K) || defined(TARGET_PPC) || defined(TARGET_S390X))) <nl> +            cc = CPU_GET_CLASS(cpu); <nl> +#endif <nl>          } <nl>      } /* for(;;) */ <nl>  
@@ -642,7 +642,7 @@ static int get_bits_from_size(size_t size) <nl>  static int preallocate(BlockDriverState *bs) <nl>  { <nl>      BDRVQcowState *s = bs->opaque; <nl> -    uint64_t cluster_offset; <nl> +    uint64_t cluster_offset = 0; <nl>      uint64_t nb_sectors; <nl>      uint64_t offset; <nl>      int num;
@@ -814,7 +814,7 @@ int qemu_opts_foreach(QemuOptsList *list, qemu_opts_loopfunc func, void *opaque, <nl>      int rc = 0; <nl>   <nl>      QTAILQ_FOREACH(opts, &list->head, next) { <nl> -        rc = func(opts, opaque); <nl> +        rc |= func(opts, opaque); <nl>          if (abort_on_failure  &&  rc != 0) <nl>              break; <nl>      }
@@ -1704,12 +1704,6 @@ static const VMStateDescription *vmstate_get_subsection(const VMStateSubsection <nl>  static int vmstate_subsection_load(QEMUFile *f, const VMStateDescription *vmsd, <nl>                                     void *opaque) <nl>  { <nl> -    const VMStateSubsection *sub = vmsd->subsections; <nl> - <nl> -    if (!sub || !sub->needed) { <nl> -        return 0; <nl> -    } <nl> - <nl>      while (qemu_peek_byte(f, 0) == QEMU_VM_SUBSECTION) { <nl>          char idstr[256]; <nl>          int ret; <nl> @@ -1731,7 +1725,7 @@ static int vmstate_subsection_load(QEMUFile *f, const VMStateDescription *vmsd, <nl>              /* it don't have a valid subsection name */ <nl>              return 0; <nl>          } <nl> -        sub_vmsd = vmstate_get_subsection(sub, idstr); <nl> +        sub_vmsd = vmstate_get_subsection(vmsd->subsections, idstr); <nl>          if (sub_vmsd == NULL) { <nl>              return -ENOENT; <nl>          } <nl> @@ -1740,7 +1734,6 @@ static int vmstate_subsection_load(QEMUFile *f, const VMStateDescription *vmsd, <nl>          qemu_file_skip(f, len); /* idstr */ <nl>          version_id = qemu_get_be32(f); <nl>   <nl> -        assert(!sub_vmsd->subsections); <nl>          ret = vmstate_load_state(f, sub_vmsd, opaque, version_id); <nl>          if (ret) { <nl>              return ret; <nl> @@ -1764,7 +1757,6 @@ static void vmstate_subsection_save(QEMUFile *f, const VMStateDescription *vmsd, <nl>              qemu_put_byte(f, len); <nl>              qemu_put_buffer(f, (uint8_t *)vmsd->name, len); <nl>              qemu_put_be32(f, vmsd->version_id); <nl> -            assert(!vmsd->subsections); <nl>              vmstate_save_state(f, vmsd, opaque); <nl>          } <nl>          sub++;
@@ -603,8 +603,8 @@ static void process_event(JSONMessageParser *parser, QList *tokens) <nl>              error_free(err); <nl>          } <nl>          ret = send_response(s, QOBJECT(qdict)); <nl> -        if (ret) { <nl> -            g_warning("error sending error response: %s", strerror(ret)); <nl> +        if (ret < 0) { <nl> +            g_warning("error sending error response: %s", strerror(-ret)); <nl>          } <nl>      } <nl>  
@@ -597,7 +597,7 @@ connect_to_qemu( <nl>      const char *port <nl>  ) { <nl>      struct addrinfo hints; <nl> -    struct addrinfo *server; <nl> +    struct addrinfo *server = NULL; <nl>      int ret, sock; <nl>   <nl>      sock = socket(AF_INET, SOCK_STREAM, 0); <nl> @@ -629,9 +629,14 @@ connect_to_qemu( <nl>      if (verbose) { <nl>          printf("Connected (sizeof Header=%zd)!\n", sizeof(VSCMsgHeader)); <nl>      } <nl> + <nl> +    freeaddrinfo(server); <nl>      return sock; <nl>   <nl>  cleanup_socket: <nl> +    if (server) { <nl> +        freeaddrinfo(server); <nl> +    } <nl>      closesocket(sock); <nl>      return -1; <nl>  }
@@ -87,8 +87,8 @@ static void win32_aio_process_completion(QEMUWin32AIOState *s, <nl>                  memcpy(qiov->iov[i].iov_base, p, qiov->iov[i].iov_len); <nl>                  p += qiov->iov[i].iov_len; <nl>              } <nl> -            qemu_vfree(waiocb->buf); <nl>          } <nl> +        qemu_vfree(waiocb->buf); <nl>      } <nl>   <nl>  
@@ -77,13 +77,13 @@ static target_ulong h_random(PowerPCCPU *cpu, sPAPRMachineState *spapr, <nl>      hrdata.val.v64 = 0; <nl>      hrdata.received = 0; <nl>   <nl> -    qemu_mutex_unlock_iothread(); <nl>      while (hrdata.received < 8) { <nl>          rng_backend_request_entropy(rngstate->backend, 8 - hrdata.received, <nl>                                      random_recv, &hrdata); <nl> +        qemu_mutex_unlock_iothread(); <nl>          qemu_sem_wait(&hrdata.sem); <nl> +        qemu_mutex_lock_iothread(); <nl>      } <nl> -    qemu_mutex_lock_iothread(); <nl>   <nl>      qemu_sem_destroy(&hrdata.sem); <nl>      args[0] = hrdata.val.v64;
@@ -182,6 +182,7 @@ static void drive_uninit(DriveInfo *dinfo) <nl>  { <nl>      qemu_opts_del(dinfo->opts); <nl>      bdrv_delete(dinfo->bdrv); <nl> +    qemu_free(dinfo->id); <nl>      QTAILQ_REMOVE(&drives, dinfo, next); <nl>      qemu_free(dinfo); <nl>  }
@@ -288,8 +288,12 @@ static void fsl_imx25_class_init(ObjectClass *oc, void *data) <nl>      DeviceClass *dc = DEVICE_CLASS(oc); <nl>   <nl>      dc->realize = fsl_imx25_realize; <nl> - <nl>      dc->desc = "i.MX25 SOC"; <nl> +    /* <nl> +     * Reason: uses serial_hds in realize and the imx25 board does not <nl> +     * support multiple CPUs <nl> +     */ <nl> +    dc->user_creatable = false; <nl>  } <nl>   <nl>  static const TypeInfo fsl_imx25_type_info = {
@@ -2214,6 +2214,15 @@ static void migration_class_init(ObjectClass *klass, void *data) <nl>      dc->props = migration_properties; <nl>  } <nl>   <nl> +static void migration_instance_finalize(Object *obj) <nl> +{ <nl> +    MigrationState *ms = MIGRATION_OBJ(obj); <nl> +    MigrationParameters *params = &ms->parameters; <nl> + <nl> +    g_free(params->tls_hostname); <nl> +    g_free(params->tls_creds); <nl> +} <nl> + <nl>  static void migration_instance_init(Object *obj) <nl>  { <nl>      MigrationState *ms = MIGRATION_OBJ(obj); <nl> @@ -2282,6 +2291,7 @@ static const TypeInfo migration_type = { <nl>      .class_size = sizeof(MigrationClass), <nl>      .instance_size = sizeof(MigrationState), <nl>      .instance_init = migration_instance_init, <nl> +    .instance_finalize = migration_instance_finalize, <nl>  }; <nl>   <nl>  static void register_migration_types(void)
@@ -33,8 +33,10 @@ static int nbd_errno_to_system_errno(int err) <nl>          return ENOMEM; <nl>      case NBD_ENOSPC: <nl>          return ENOSPC; <nl> -    case NBD_EINVAL: <nl>      default: <nl> +        TRACE("Squashing unexpected error %d to EINVAL", err); <nl> +        /* fallthrough */ <nl> +    case NBD_EINVAL: <nl>          return EINVAL; <nl>      } <nl>  }
@@ -2209,6 +2209,9 @@ bool bdrv_dev_is_medium_locked(BlockDriverState *bs) <nl>   */ <nl>  int bdrv_check(BlockDriverState *bs, BdrvCheckResult *res, BdrvCheckMode fix) <nl>  { <nl> +    if (bs->drv == NULL) { <nl> +        return -ENOMEDIUM; <nl> +    } <nl>      if (bs->drv->bdrv_check == NULL) { <nl>          return -ENOTSUP; <nl>      }
@@ -1427,7 +1427,7 @@ int kvm_init(void) <nl>      } while (ret == -EINTR); <nl>   <nl>      if (ret < 0) { <nl> -        fprintf(stderr, "ioctl(KVM_CREATE_VM) failed: %d %s\n", -s->vmfd, <nl> +        fprintf(stderr, "ioctl(KVM_CREATE_VM) failed: %d %s\n", -ret, <nl>                  strerror(-ret)); <nl>   <nl>  #ifdef TARGET_S390X
@@ -833,6 +833,7 @@ static int pci_unregister_device(DeviceState *dev) <nl>   <nl>      pci_unregister_io_regions(pci_dev); <nl>      pci_del_option_rom(pci_dev); <nl> +    qemu_free(pci_dev->romfile); <nl>      do_pci_unregister_device(pci_dev); <nl>      return 0; <nl>  }
@@ -154,6 +154,8 @@ void qmp_guest_set_time(bool has_time, int64_t time_ns, Error **errp) <nl>   <nl>      /* If user has passed a time, validate and set it. */ <nl>      if (has_time) { <nl> +        GDate date = { 0, }; <nl> + <nl>          /* year-2038 will overflow in case time_t is 32bit */ <nl>          if (time_ns / 1000000000 != (time_t)(time_ns / 1000000000)) { <nl>              error_setg(errp, "Time %" PRId64 " is too large", time_ns); <nl> @@ -162,6 +164,11 @@ void qmp_guest_set_time(bool has_time, int64_t time_ns, Error **errp) <nl>   <nl>          tv.tv_sec = time_ns / 1000000000; <nl>          tv.tv_usec = (time_ns % 1000000000) / 1000; <nl> +        g_date_set_time_t(&date, tv.tv_sec); <nl> +        if (date.year < 1970 || date.year >= 2070) { <nl> +            error_setg_errno(errp, errno, "Invalid time"); <nl> +            return; <nl> +        } <nl>   <nl>          ret = settimeofday(&tv, NULL); <nl>          if (ret < 0) {
@@ -827,6 +827,7 @@ exit_err: <nl>  void qmp_netdev_del(const char *id, Error **errp) <nl>  { <nl>      NetClientState *nc; <nl> +    QemuOpts *opts; <nl>   <nl>      nc = qemu_find_netdev(id); <nl>      if (!nc) { <nl> @@ -834,8 +835,14 @@ void qmp_netdev_del(const char *id, Error **errp) <nl>          return; <nl>      } <nl>   <nl> +    opts = qemu_opts_find(qemu_find_opts_err("netdev", NULL), id); <nl> +    if (!opts) { <nl> +        error_setg(errp, "Device '%s' is not a netdev", id); <nl> +        return; <nl> +    } <nl> + <nl>      qemu_del_net_client(nc); <nl> -    qemu_opts_del(qemu_opts_find(qemu_find_opts_err("netdev", errp), id)); <nl> +    qemu_opts_del(opts); <nl>  } <nl>   <nl>  void print_net_client(Monitor *mon, NetClientState *nc)
@@ -1981,7 +1981,11 @@ static void megasas_handle_frame(MegasasState *s, uint64_t frame_addr, <nl>          break; <nl>      } <nl>      if (frame_status != MFI_STAT_INVALID_STATUS) { <nl> -        cmd->frame->header.cmd_status = frame_status; <nl> +        if (cmd->frame) { <nl> +            cmd->frame->header.cmd_status = frame_status; <nl> +        } else { <nl> +            megasas_frame_set_cmd_status(s, frame_addr, frame_status); <nl> +        } <nl>          megasas_unmap_frame(s, cmd); <nl>          megasas_complete_frame(s, cmd->context); <nl>      }
@@ -310,7 +310,7 @@ static int ioreq_runio_qemu_sync(struct ioreq *ioreq) <nl>      off_t pos; <nl>   <nl>      if (ioreq->req.nr_segments && ioreq_map(ioreq) == -1) <nl> -	goto err; <nl> +	goto err_no_map; <nl>      if (ioreq->presync) <nl>  	bdrv_flush(blkdev->bs); <nl>   <nl> @@ -364,6 +364,9 @@ static int ioreq_runio_qemu_sync(struct ioreq *ioreq) <nl>      return 0; <nl>   <nl>  err: <nl> +    ioreq_unmap(ioreq); <nl> +err_no_map: <nl> +    ioreq_finish(ioreq); <nl>      ioreq->status = BLKIF_RSP_ERROR; <nl>      return -1; <nl>  } <nl> @@ -393,7 +396,7 @@ static int ioreq_runio_qemu_aio(struct ioreq *ioreq) <nl>      struct XenBlkDev *blkdev = ioreq->blkdev; <nl>   <nl>      if (ioreq->req.nr_segments && ioreq_map(ioreq) == -1) <nl> -	goto err; <nl> +	goto err_no_map; <nl>   <nl>      ioreq->aio_inflight++; <nl>      if (ioreq->presync) <nl> @@ -427,6 +430,9 @@ static int ioreq_runio_qemu_aio(struct ioreq *ioreq) <nl>      return 0; <nl>   <nl>  err: <nl> +    ioreq_unmap(ioreq); <nl> +err_no_map: <nl> +    ioreq_finish(ioreq); <nl>      ioreq->status = BLKIF_RSP_ERROR; <nl>      return -1; <nl>  }
@@ -161,6 +161,7 @@ sPAPRTCETable *spapr_tce_new_table(DeviceState *owner, uint32_t liobn, <nl>                                     bool vfio_accel) <nl>  { <nl>      sPAPRTCETable *tcet; <nl> +    char tmp[64]; <nl>   <nl>      if (spapr_tce_find_by_liobn(liobn)) { <nl>          fprintf(stderr, "Attempted to create TCE table with duplicate" <nl> @@ -179,7 +180,8 @@ sPAPRTCETable *spapr_tce_new_table(DeviceState *owner, uint32_t liobn, <nl>      tcet->nb_table = nb_table; <nl>      tcet->vfio_accel = vfio_accel; <nl>   <nl> -    object_property_add_child(OBJECT(owner), "tce-table", OBJECT(tcet), NULL); <nl> +    snprintf(tmp, sizeof(tmp), "tce-table-%x", liobn); <nl> +    object_property_add_child(OBJECT(owner), tmp, OBJECT(tcet), NULL); <nl>   <nl>      object_property_set_bool(OBJECT(tcet), true, "realized", NULL); <nl>  
@@ -940,6 +940,7 @@ DriveInfo *drive_init(QemuOpts *all_opts, BlockInterfaceType block_default_type) <nl>   <nl>      /* Actual block device init: Functionality shared with blockdev-add */ <nl>      dinfo = blockdev_init(filename, bs_opts, &local_err); <nl> +    bs_opts = NULL; <nl>      if (dinfo == NULL) { <nl>          if (local_err) { <nl>              error_report("%s", error_get_pretty(local_err)); <nl> @@ -977,6 +978,7 @@ DriveInfo *drive_init(QemuOpts *all_opts, BlockInterfaceType block_default_type) <nl>   <nl>  fail: <nl>      qemu_opts_del(legacy_opts); <nl> +    QDECREF(bs_opts); <nl>      return dinfo; <nl>  } <nl>  
@@ -732,7 +732,7 @@ static void pxa2xx_ssp_save(QEMUFile *f, void *opaque) <nl>  static int pxa2xx_ssp_load(QEMUFile *f, void *opaque, int version_id) <nl>  { <nl>      PXA2xxSSPState *s = (PXA2xxSSPState *) opaque; <nl> -    int i; <nl> +    int i, v; <nl>   <nl>      s->enable = qemu_get_be32(f); <nl>   <nl> @@ -746,7 +746,11 @@ static int pxa2xx_ssp_load(QEMUFile *f, void *opaque, int version_id) <nl>      qemu_get_8s(f, &s->ssrsa); <nl>      qemu_get_8s(f, &s->ssacd); <nl>   <nl> -    s->rx_level = qemu_get_byte(f); <nl> +    v = qemu_get_byte(f); <nl> +    if (v < 0 || v > ARRAY_SIZE(s->rx_fifo)) { <nl> +        return -EINVAL; <nl> +    } <nl> +    s->rx_level = v; <nl>      s->rx_start = 0; <nl>      for (i = 0; i < s->rx_level; i ++) <nl>          s->rx_fifo[i] = qemu_get_byte(f);
@@ -95,7 +95,13 @@ static int target_pread(int fd, abi_ulong ptr, abi_ulong len, <nl>      int ret; <nl>   <nl>      buf = lock_user(VERIFY_WRITE, ptr, len, 0); <nl> +    if (!buf) { <nl> +        return -EFAULT; <nl> +    } <nl>      ret = pread(fd, buf, len, offset); <nl> +    if (ret < 0) { <nl> +        ret = -errno; <nl> +    } <nl>      unlock_user(buf, ptr, len); <nl>      return ret; <nl>  }
@@ -86,9 +86,8 @@ static void cpu_openrisc_load_kernel(ram_addr_t ram_size, <nl>                      kernel_filename); <nl>              exit(1); <nl>          } <nl> +        cpu->env.pc = entry; <nl>      } <nl> - <nl> -    cpu->env.pc = entry; <nl>  } <nl>   <nl>  static void openrisc_sim_init(QEMUMachineInitArgs *args)
@@ -78,7 +78,8 @@ static void stat_put(QDict *dict, const char *label, uint64_t val) <nl>  static QObject *get_stats_qobject(VirtIOBalloon *dev) <nl>  { <nl>      QDict *dict = qdict_new(); <nl> -    uint32_t actual = ram_size - (dev->actual << VIRTIO_BALLOON_PFN_SHIFT); <nl> +    uint64_t actual = ram_size - ((uint64_t) dev->actual << <nl> +                                  VIRTIO_BALLOON_PFN_SHIFT); <nl>   <nl>      stat_put(dict, "actual", actual); <nl>      stat_put(dict, "mem_swapped_in", dev->stats[VIRTIO_BALLOON_S_SWAP_IN]);
@@ -703,7 +703,7 @@ static int init_directory(BDRVVVFATState* s,const char* dirname) <nl>      memset(&(s->first_sectors[0]),0,0x40*0x200); <nl>   <nl>      /* TODO: if FAT32, this is probably wrong */ <nl> -    s->sectors_per_fat=0xfc; <nl> +    s->sectors_per_fat=0xec; <nl>      s->sectors_per_cluster=0x10; <nl>      s->cluster_size=s->sectors_per_cluster*0x200; <nl>      s->cluster=malloc(s->cluster_size);
@@ -206,7 +206,7 @@ int qdev_device_help(QemuOpts *opts) <nl>      } <nl>   <nl>      prop_list = qmp_device_list_properties(driver, &local_err); <nl> -    if (!prop_list) { <nl> +    if (local_err) { <nl>          error_printf("%s\n", error_get_pretty(local_err)); <nl>          error_free(local_err); <nl>          return 1;
@@ -1588,6 +1588,13 @@ static void virtio_net_device_realize(DeviceState *dev, Error **errp) <nl>      virtio_init(vdev, "virtio-net", VIRTIO_ID_NET, n->config_size); <nl>   <nl>      n->max_queues = MAX(n->nic_conf.peers.queues, 1); <nl> +    if (n->max_queues * 2 + 1 > VIRTIO_PCI_QUEUE_MAX) { <nl> +        error_setg(errp, "Invalid number of queues (= %" PRIu32 "), " <nl> +                   "must be a postive integer less than %d.", <nl> +                   n->max_queues, (VIRTIO_PCI_QUEUE_MAX - 1) / 2); <nl> +        virtio_cleanup(vdev); <nl> +        return; <nl> +    } <nl>      n->vqs = g_malloc0(sizeof(VirtIONetQueue) * n->max_queues); <nl>      n->vqs[0].rx_vq = virtio_add_queue(vdev, 256, virtio_net_handle_rx); <nl>      n->curr_queues = 1;
@@ -1883,6 +1883,11 @@ static struct iovec *lock_iovec(int type, abi_ulong target_addr, <nl>      return vec; <nl>   <nl>   fail: <nl> +    while (--i >= 0) { <nl> +        if (tswapal(target_vec[i].iov_len) > 0) { <nl> +            unlock_user(vec[i].iov_base, tswapal(target_vec[i].iov_base), 0); <nl> +        } <nl> +    } <nl>      unlock_user(target_vec, target_addr, 0); <nl>   fail2: <nl>      free(vec);
@@ -1481,7 +1481,7 @@ static void load_symbols(struct elfhdr *hdr, int fd, abi_ulong load_bias) <nl>      struct elf_shdr *shdr; <nl>      char *strings; <nl>      struct syminfo *s; <nl> -    struct elf_sym *syms; <nl> +    struct elf_sym *syms, *new_syms; <nl>   <nl>      shnum = hdr->e_shnum; <nl>      i = shnum * sizeof(struct elf_shdr); <nl> @@ -1550,12 +1550,14 @@ static void load_symbols(struct elfhdr *hdr, int fd, abi_ulong load_bias) <nl>         that we threw away.  Whether or not this has any effect on the <nl>         memory allocation depends on the malloc implementation and how <nl>         many symbols we managed to discard.  */ <nl> -    syms = realloc(syms, nsyms * sizeof(*syms)); <nl> -    if (syms == NULL) { <nl> +    new_syms = realloc(syms, nsyms * sizeof(*syms)); <nl> +    if (new_syms == NULL) { <nl>          free(s); <nl> +        free(syms); <nl>          free(strings); <nl>          return; <nl>      } <nl> +    syms = new_syms; <nl>   <nl>      qsort(syms, nsyms, sizeof(*syms), symcmp); <nl>  
@@ -35,10 +35,6 @@ static void acquire_privilege(const char *name, Error **errp) <nl>      TOKEN_PRIVILEGES priv; <nl>      Error *local_err = NULL; <nl>   <nl> -    if (error_is_set(errp)) { <nl> -        return; <nl> -    } <nl> - <nl>      if (OpenProcessToken(GetCurrentProcess(), <nl>          TOKEN_ADJUST_PRIVILEGES|TOKEN_QUERY, &token)) <nl>      { <nl> @@ -74,9 +70,6 @@ static void execute_async(DWORD WINAPI (*func)(LPVOID), LPVOID opaque, <nl>  { <nl>      Error *local_err = NULL; <nl>   <nl> -    if (error_is_set(errp)) { <nl> -        return; <nl> -    } <nl>      HANDLE thread = CreateThread(NULL, 0, func, opaque, 0, NULL); <nl>      if (!thread) { <nl>          error_set(&local_err, QERR_QGA_COMMAND_FAILED, <nl> @@ -268,9 +261,6 @@ static void check_suspend_mode(GuestSuspendMode mode, Error **errp) <nl>      SYSTEM_POWER_CAPABILITIES sys_pwr_caps; <nl>      Error *local_err = NULL; <nl>   <nl> -    if (error_is_set(errp)) { <nl> -        return; <nl> -    } <nl>      ZeroMemory(&sys_pwr_caps, sizeof(sys_pwr_caps)); <nl>      if (!GetPwrCapabilities(&sys_pwr_caps)) { <nl>          error_set(&local_err, QERR_QGA_COMMAND_FAILED,
@@ -5167,6 +5167,7 @@ static int open_self_cmdline(void *cpu_env, int fd) <nl>   <nl>          if (word_skipped) { <nl>              if (write(fd, cp_buf, nb_read) != nb_read) { <nl> +                close(fd_orig); <nl>                  return -1; <nl>              } <nl>          }
@@ -451,7 +451,8 @@ static int vmdk_init_tables(BlockDriverState *bs, VmdkExtent *extent, <nl>                              Error **errp) <nl>  { <nl>      int ret; <nl> -    int l1_size, i; <nl> +    size_t l1_size; <nl> +    int i; <nl>   <nl>      /* read the L1 table */ <nl>      l1_size = extent->l1_size * sizeof(uint32_t);
@@ -1043,7 +1043,7 @@ void helper_sysret(CPUX86State *env, int dflag) <nl>                                     DESC_CS_MASK | DESC_R_MASK | DESC_A_MASK); <nl>              env->eip = (uint32_t)env->regs[R_ECX]; <nl>          } <nl> -        cpu_x86_load_seg_cache(env, R_SS, selector + 8, <nl> +        cpu_x86_load_seg_cache(env, R_SS, (selector + 8) | 3, <nl>                                 0, 0xffffffff, <nl>                                 DESC_G_MASK | DESC_B_MASK | DESC_P_MASK | <nl>                                 DESC_S_MASK | (3 << DESC_DPL_SHIFT) | <nl> @@ -1056,7 +1056,7 @@ void helper_sysret(CPUX86State *env, int dflag) <nl>                                 DESC_S_MASK | (3 << DESC_DPL_SHIFT) | <nl>                                 DESC_CS_MASK | DESC_R_MASK | DESC_A_MASK); <nl>          env->eip = (uint32_t)env->regs[R_ECX]; <nl> -        cpu_x86_load_seg_cache(env, R_SS, selector + 8, <nl> +        cpu_x86_load_seg_cache(env, R_SS, (selector + 8) | 3, <nl>                                 0, 0xffffffff, <nl>                                 DESC_G_MASK | DESC_B_MASK | DESC_P_MASK | <nl>                                 DESC_S_MASK | (3 << DESC_DPL_SHIFT) |
@@ -348,9 +348,13 @@ static int img_create(int argc, char **argv) <nl>          char *end; <nl>          sval = strtosz_suffix(argv[optind++], &end, STRTOSZ_DEFSUFFIX_B); <nl>          if (sval < 0 || *end) { <nl> -            error_report("Invalid image size specified! You may use k, M, G or " <nl> -                  "T suffixes for "); <nl> -            error_report("kilobytes, megabytes, gigabytes and terabytes."); <nl> +            if (sval == -ERANGE) { <nl> +                error_report("Image size must be less than 8 EiB!"); <nl> +            } else { <nl> +                error_report("Invalid image size specified! You may use k, M, " <nl> +                      "G or T suffixes for "); <nl> +                error_report("kilobytes, megabytes, gigabytes and terabytes."); <nl> +            } <nl>              return 1; <nl>          } <nl>          img_size = (uint64_t)sval;
@@ -677,7 +677,7 @@ static int virtio_net_handle_mac(VirtIONet *n, uint8_t cmd, <nl>          goto error; <nl>      } <nl>   <nl> -    if (in_use + mac_data.entries <= MAC_TABLE_ENTRIES) { <nl> +    if (mac_data.entries <= MAC_TABLE_ENTRIES - in_use) { <nl>          s = iov_to_buf(iov, iov_cnt, 0, &macs[in_use * ETH_ALEN], <nl>                         mac_data.entries * ETH_ALEN); <nl>          if (s != mac_data.entries * ETH_ALEN) {
@@ -168,7 +168,7 @@ static void vfio_ccw_register_io_notifier(VFIOCCWDevice *vcdev, Error **errp) <nl>          return; <nl>      } <nl>   <nl> -    argsz = sizeof(*irq_set); <nl> +    argsz = sizeof(*irq_info); <nl>      irq_info = g_malloc0(argsz); <nl>      irq_info->index = VFIO_CCW_IO_IRQ_INDEX; <nl>      irq_info->argsz = argsz;
@@ -806,7 +806,8 @@ typedef struct E1000E_RingInfo_st { <nl>  static inline bool <nl>  e1000e_ring_empty(E1000ECore *core, const E1000E_RingInfo *r) <nl>  { <nl> -    return core->mac[r->dh] == core->mac[r->dt]; <nl> +    return core->mac[r->dh] == core->mac[r->dt] || <nl> +                core->mac[r->dt] >= core->mac[r->dlen] / E1000_RING_DESC_LEN; <nl>  } <nl>   <nl>  static inline uint64_t <nl> @@ -1522,6 +1523,10 @@ e1000e_write_packet_to_guest(E1000ECore *core, struct NetRxPkt *pkt, <nl>              desc_size = core->rx_desc_buf_size; <nl>          } <nl>   <nl> +        if (e1000e_ring_empty(core, rxi)) { <nl> +            return; <nl> +        } <nl> + <nl>          base = e1000e_ring_head_descr(core, rxi); <nl>   <nl>          pci_dma_read(d, base, &desc, core->rx_desc_len);
@@ -409,9 +409,6 @@ int bdrv_all_delete_snapshot(const char *name, BlockDriverState **first_bad_bs, <nl>          if (bdrv_can_snapshot(bs) && <nl>                  bdrv_snapshot_find(bs, snapshot, name) >= 0) { <nl>              ret = bdrv_snapshot_delete_by_id_or_name(bs, name, err); <nl> -            if (ret < 0) { <nl> -                goto fail; <nl> -            } <nl>          } <nl>          aio_context_release(ctx); <nl>          if (ret < 0) {
@@ -97,6 +97,7 @@ int s390_virtio_hypercall(CPUState *env, uint64_t mem, uint64_t hypercall) <nl>   <nl>          dev = s390_virtio_bus_find_mem(s390_bus, mem); <nl>          virtio_reset(dev->vdev); <nl> +        stb_phys(dev->dev_offs + VIRTIO_DEV_OFFS_STATUS, 0); <nl>          s390_virtio_device_sync(dev); <nl>          break; <nl>      }
@@ -2026,6 +2026,16 @@ static void set_pixel_format(VncState *vs, <nl>          return; <nl>      } <nl>   <nl> +    switch (bits_per_pixel) { <nl> +    case 8: <nl> +    case 16: <nl> +    case 32: <nl> +        break; <nl> +    default: <nl> +        vnc_client_error(vs); <nl> +        return; <nl> +    } <nl> + <nl>      vs->client_pf.rmax = red_max; <nl>      vs->client_pf.rbits = hweight_long(red_max); <nl>      vs->client_pf.rshift = red_shift;
@@ -137,20 +137,21 @@ static void generic_loader_realize(DeviceState *dev, Error **errp) <nl>  #endif <nl>   <nl>      if (s->file) { <nl> +        AddressSpace *as = s->cpu ? s->cpu->as :  NULL; <nl> + <nl>          if (!s->force_raw) { <nl>              size = load_elf_as(s->file, NULL, NULL, &entry, NULL, NULL, <nl> -                               big_endian, 0, 0, 0, s->cpu->as); <nl> +                               big_endian, 0, 0, 0, as); <nl>   <nl>              if (size < 0) { <nl>                  size = load_uimage_as(s->file, &entry, NULL, NULL, NULL, NULL, <nl> -                                      s->cpu->as); <nl> +                                      as); <nl>              } <nl>          } <nl>   <nl>          if (size < 0 || s->force_raw) { <nl>              /* Default to the maximum size being the machine's ram size */ <nl> -            size = load_image_targphys_as(s->file, s->addr, ram_size, <nl> -                                          s->cpu->as); <nl> +            size = load_image_targphys_as(s->file, s->addr, ram_size, as); <nl>          } else { <nl>              s->addr = entry; <nl>          }
@@ -2482,6 +2482,7 @@ typedef struct { <nl>      void *buffer; <nl>      hwaddr addr; <nl>      hwaddr len; <nl> +    bool in_use; <nl>  } BounceBuffer; <nl>   <nl>  static BounceBuffer bounce; <nl> @@ -2570,7 +2571,7 @@ void *address_space_map(AddressSpace *as, <nl>      l = len; <nl>      mr = address_space_translate(as, addr, &xlat, &l, is_write); <nl>      if (!memory_access_is_direct(mr, is_write)) { <nl> -        if (bounce.buffer) { <nl> +        if (atomic_xchg(&bounce.in_use, true)) { <nl>              return NULL; <nl>          } <nl>          /* Avoid unbounded allocations */ <nl> @@ -2640,6 +2641,7 @@ void address_space_unmap(AddressSpace *as, void *buffer, hwaddr len, <nl>      qemu_vfree(bounce.buffer); <nl>      bounce.buffer = NULL; <nl>      memory_region_unref(bounce.mr); <nl> +    atomic_mb_set(&bounce.in_use, false); <nl>      cpu_notify_map_clients(); <nl>  } <nl>  
@@ -206,7 +206,8 @@ void op_addo (void) <nl>   <nl>      tmp = T0; <nl>      T0 += T1; <nl> -    if ((T0 >> 31) ^ (T1 >> 31) ^ (tmp >> 31)) { <nl> +    if (((tmp ^ T1 ^ (-1)) & (T0 ^ T1)) >> 31) { <nl> +       /* operands of same sign, result different sign */ <nl>          CALL_FROM_TB1(do_raise_exception_direct, EXCP_OVERFLOW); <nl>      } <nl>      RETURN(); <nl> @@ -224,7 +225,8 @@ void op_subo (void) <nl>   <nl>      tmp = T0; <nl>      T0 = (int32_t)T0 - (int32_t)T1; <nl> -    if (!((T0 >> 31) ^ (T1 >> 31) ^ (tmp >> 31))) { <nl> +    if (((tmp ^ T1) & (tmp ^ T0)) >> 31) { <nl> +       /* operands of different sign, first operand and result different sign */ <nl>          CALL_FROM_TB1(do_raise_exception_direct, EXCP_OVERFLOW); <nl>      } <nl>      RETURN();
@@ -43,12 +43,13 @@ static testdef_t tests[] = { <nl>  static void check_guest_output(const testdef_t *test, int fd) <nl>  { <nl>      bool output_ok = false; <nl> -    int i, nbr, pos = 0; <nl> +    int i, nbr, pos = 0, ccnt; <nl>      char ch; <nl>   <nl>      /* Poll serial output... Wait at most 60 seconds */ <nl>      for (i = 0; i < 6000; ++i) { <nl> -        while ((nbr = read(fd, &ch, 1)) == 1) { <nl> +        ccnt = 0; <nl> +        while ((nbr = read(fd, &ch, 1)) == 1 && ccnt++ < 512) { <nl>              if (ch == test->expect[pos]) { <nl>                  pos += 1; <nl>                  if (test->expect[pos] == '\0') {
@@ -1226,10 +1226,6 @@ static CharDriverState *qemu_chr_open_tty(QemuOpts *opts) <nl>      } <nl>      tty_serial_init(fd, 115200, 'N', 8, 1); <nl>      chr = qemu_chr_open_fd(fd, fd); <nl> -    if (!chr) { <nl> -        close(fd); <nl> -        return NULL; <nl> -    } <nl>      chr->chr_ioctl = tty_serial_ioctl; <nl>      chr->chr_close = qemu_chr_close_tty; <nl>      return chr;
@@ -6505,7 +6505,7 @@ abi_long do_syscall(void *cpu_env, int num, abi_long arg1, <nl>                      unsigned long zero = arg2 - ret; <nl>                      p = alloca(zero); <nl>                      memset(p, 0, zero); <nl> -                    if (copy_to_user(arg3 + zero, p, zero)) { <nl> +                    if (copy_to_user(arg3 + ret, p, zero)) { <nl>                          goto efault; <nl>                      } <nl>                      arg2 = ret;
@@ -48,7 +48,7 @@ typedef struct VirtQueueElement <nl>      struct iovec out_sg[VIRTQUEUE_MAX_SIZE]; <nl>  } VirtQueueElement; <nl>   <nl> -#define VIRTIO_QUEUE_MAX 64 <nl> +#define VIRTIO_QUEUE_MAX 1024 <nl>   <nl>  #define VIRTIO_NO_VECTOR 0xffff <nl>  
@@ -853,6 +853,7 @@ static void *oss_audio_init (void) <nl>   <nl>      if (access(conf->devpath_in, R_OK | W_OK) < 0 || <nl>          access(conf->devpath_out, R_OK | W_OK) < 0) { <nl> +        g_free(conf); <nl>          return NULL; <nl>      } <nl>      return conf;
@@ -419,8 +419,7 @@ uint64_t HELPER(cdlgb)(CPUS390XState *env, uint64_t v2, uint32_t m3) <nl>  uint64_t HELPER(cxlgb)(CPUS390XState *env, uint64_t v2, uint32_t m3) <nl>  { <nl>      int hold = swap_round_mode(env, m3); <nl> -    /* ??? Not 50% correct.  */ <nl> -    float128 ret = int64_to_float128(v2, &env->fpu_status); <nl> +    float128 ret = uint64_to_float128(v2, &env->fpu_status); <nl>      set_float_rounding_mode(hold, &env->fpu_status); <nl>      handle_exceptions(env, GETPC()); <nl>      return RET128(ret);
@@ -100,8 +100,9 @@ void helper_lswx(CPUPPCState *env, target_ulong addr, uint32_t reg, <nl>                   uint32_t ra, uint32_t rb) <nl>  { <nl>      if (likely(xer_bc != 0)) { <nl> -        if (unlikely((ra != 0 && reg < ra && (reg + xer_bc) > ra) || <nl> -                     (reg < rb && (reg + xer_bc) > rb))) { <nl> +        int num_used_regs = (xer_bc + 3) / 4; <nl> +        if (unlikely((ra != 0 && reg < ra && (reg + num_used_regs) > ra) || <nl> +                     (reg < rb && (reg + num_used_regs) > rb))) { <nl>              helper_raise_exception_err(env, POWERPC_EXCP_PROGRAM, <nl>                                         POWERPC_EXCP_INVAL | <nl>                                         POWERPC_EXCP_INVAL_LSWX);
@@ -293,12 +293,9 @@ static void rtas_ibm_os_term(PowerPCCPU *cpu, <nl>                              target_ulong args, <nl>                              uint32_t nret, target_ulong rets) <nl>  { <nl> -    target_ulong ret = 0; <nl> +    qemu_system_guest_panicked(NULL); <nl>   <nl> -    qapi_event_send_guest_panicked(GUEST_PANIC_ACTION_PAUSE, false, NULL, <nl> -                                   &error_abort); <nl> - <nl> -    rtas_st(rets, 0, ret); <nl> +    rtas_st(rets, 0, RTAS_OUT_SUCCESS); <nl>  } <nl>   <nl>  static void rtas_set_power_level(PowerPCCPU *cpu, sPAPRMachineState *spapr,
@@ -22,7 +22,12 @@ static inline void close_preserve_errno(int fd) <nl>   <nl>  static inline int openat_dir(int dirfd, const char *name) <nl>  { <nl> -    return openat(dirfd, name, O_DIRECTORY | O_RDONLY | O_PATH); <nl> +#ifdef O_PATH <nl> +#define OPENAT_DIR_O_PATH O_PATH <nl> +#else <nl> +#define OPENAT_DIR_O_PATH 0 <nl> +#endif <nl> +    return openat(dirfd, name, O_DIRECTORY | O_RDONLY | OPENAT_DIR_O_PATH); <nl>  } <nl>   <nl>  static inline int openat_file(int dirfd, const char *name, int flags,
@@ -214,7 +214,8 @@ static void fw_cfg_write(FWCfgState *s, uint8_t value) <nl>   <nl>      FW_CFG_DPRINTF("write %d\n", value); <nl>   <nl> -    if (s->cur_entry & FW_CFG_WRITE_CHANNEL && s->cur_offset < e->len) { <nl> +    if (s->cur_entry & FW_CFG_WRITE_CHANNEL && e->callback && <nl> +        s->cur_offset < e->len) { <nl>          e->data[s->cur_offset++] = value; <nl>          if (s->cur_offset == e->len) { <nl>              e->callback(e->callback_opaque, e->data);
@@ -2550,6 +2550,8 @@ ram_addr_t qemu_ram_alloc_from_ptr(ram_addr_t size, void *host, <nl>   <nl>      ram_list.phys_dirty = g_realloc(ram_list.phys_dirty, <nl>                                         last_ram_offset() >> TARGET_PAGE_BITS); <nl> +    memset(ram_list.phys_dirty + (new_block->offset >> TARGET_PAGE_BITS), <nl> +           0, size >> TARGET_PAGE_BITS); <nl>      cpu_physical_memory_set_dirty_range(new_block->offset, size, 0xff); <nl>   <nl>      if (kvm_enabled())
@@ -441,7 +441,7 @@ static int kvm_physical_sync_dirty_bitmap(MemoryRegionSection *section) <nl>   <nl>          d.slot = mem->slot; <nl>   <nl> -        if (kvm_vm_ioctl(s, KVM_GET_DIRTY_LOG, &d) == -1) { <nl> +        if (kvm_vm_ioctl(s, KVM_GET_DIRTY_LOG, &d) < 0) { <nl>              DPRINTF("ioctl failed %d\n", errno); <nl>              ret = -1; <nl>              break;
@@ -3618,8 +3618,10 @@ int main(int argc, char **argv, char **envp) <nl>                  } <nl>                  break; <nl>              case QEMU_OPTION_incoming: <nl> +                if (!incoming) { <nl> +                    runstate_set(RUN_STATE_INMIGRATE); <nl> +                } <nl>                  incoming = optarg; <nl> -                runstate_set(RUN_STATE_INMIGRATE); <nl>                  break; <nl>              case QEMU_OPTION_nodefaults: <nl>                  has_defaults = 0;
@@ -3669,8 +3669,8 @@ static BlockMeasureInfo *qcow2_measure(QemuOpts *opts, BlockDriverState *in_bs, <nl>              for (sector_num = 0; <nl>                   sector_num < ssize / BDRV_SECTOR_SIZE; <nl>                   sector_num += pnum) { <nl> -                int nb_sectors = MAX(ssize / BDRV_SECTOR_SIZE - sector_num, <nl> -                                     INT_MAX); <nl> +                int nb_sectors = MIN(ssize / BDRV_SECTOR_SIZE - sector_num, <nl> +                                     BDRV_REQUEST_MAX_SECTORS); <nl>                  BlockDriverState *file; <nl>                  int64_t ret; <nl>  
@@ -200,7 +200,8 @@ static int l2_allocate(BlockDriverState *bs, int l1_index, uint64_t **table) <nl>   <nl>      l2_offset = qcow2_alloc_clusters(bs, s->l2_size * sizeof(uint64_t)); <nl>      if (l2_offset < 0) { <nl> -        return l2_offset; <nl> +        ret = l2_offset; <nl> +        goto fail; <nl>      } <nl>   <nl>      ret = qcow2_cache_flush(bs, s->refcount_block_cache); <nl> @@ -213,7 +214,7 @@ static int l2_allocate(BlockDriverState *bs, int l1_index, uint64_t **table) <nl>      trace_qcow2_l2_allocate_get_empty(bs, l1_index); <nl>      ret = qcow2_cache_get_empty(bs, s->l2_table_cache, l2_offset, (void**) table); <nl>      if (ret < 0) { <nl> -        return ret; <nl> +        goto fail; <nl>      } <nl>   <nl>      l2_table = *table;
@@ -2275,7 +2275,7 @@ void helper_pmon (int function) <nl>          break; <nl>      case 158: <nl>          { <nl> -            unsigned char *fmt = (void *)(unsigned long)env->active_tc.gpr[4]; <nl> +            unsigned char *fmt = (void *)(uintptr_t)env->active_tc.gpr[4]; <nl>              printf("%s", fmt); <nl>          } <nl>          break;
@@ -1903,8 +1903,8 @@ static void gdb_breakpoint_remove_all(void) <nl>   <nl>  static void gdb_set_cpu_pc(GDBState *s, target_ulong pc) <nl>  { <nl> -#if defined(TARGET_I386) <nl>      cpu_synchronize_state(s->c_cpu); <nl> +#if defined(TARGET_I386) <nl>      s->c_cpu->eip = pc; <nl>  #elif defined (TARGET_PPC) <nl>      s->c_cpu->nip = pc; <nl> @@ -1929,7 +1929,6 @@ static void gdb_set_cpu_pc(GDBState *s, target_ulong pc) <nl>  #elif defined (TARGET_ALPHA) <nl>      s->c_cpu->pc = pc; <nl>  #elif defined (TARGET_S390X) <nl> -    cpu_synchronize_state(s->c_cpu); <nl>      s->c_cpu->psw.addr = pc; <nl>  #elif defined (TARGET_LM32) <nl>      s->c_cpu->pc = pc;
@@ -919,7 +919,8 @@ int qcow2_update_header(BlockDriverState *bs) <nl>          ret = sizeof(*header); <nl>          break; <nl>      default: <nl> -        return -EINVAL; <nl> +        ret = -EINVAL; <nl> +        goto fail; <nl>      } <nl>   <nl>      buf += ret;
@@ -5327,8 +5327,12 @@ static target_ulong disas_insn(DisasContext *s, target_ulong pc_start) <nl>          if (CODE64(s)) <nl>              goto illegal_op; <nl>          val = ldub_code(s->pc++); <nl> -        gen_op_aam(val); <nl> -        s->cc_op = CC_OP_LOGICB; <nl> +        if (val == 0) { <nl> +            gen_exception(s, EXCP00_DIVZ, pc_start - s->cs_base); <nl> +        } else { <nl> +            gen_op_aam(val); <nl> +            s->cc_op = CC_OP_LOGICB; <nl> +        } <nl>          break; <nl>      case 0xd5: /* aad */ <nl>          if (CODE64(s))
@@ -235,9 +235,9 @@ int trace_record_start(TraceBufferRecord *rec, TraceEventID event, size_t datasi <nl>      rec->next_tbuf_idx = new_idx % TRACE_BUF_LEN; <nl>   <nl>      rec_off = idx; <nl> -    rec_off = write_to_buffer(rec_off, (uint8_t*)&event, sizeof(event)); <nl> -    rec_off = write_to_buffer(rec_off, (uint8_t*)&timestamp_ns, sizeof(timestamp_ns)); <nl> -    rec_off = write_to_buffer(rec_off, (uint8_t*)&rec_len, sizeof(rec_len)); <nl> +    rec_off = write_to_buffer(rec_off, &event, sizeof(event)); <nl> +    rec_off = write_to_buffer(rec_off, &timestamp_ns, sizeof(timestamp_ns)); <nl> +    rec_off = write_to_buffer(rec_off, &rec_len, sizeof(rec_len)); <nl>   <nl>      rec->tbuf_idx = idx; <nl>      rec->rec_off  = (idx + sizeof(TraceRecord)) % TRACE_BUF_LEN;
@@ -386,8 +386,9 @@ uint64_t cpu_physical_memory_sync_dirty_bitmap(RAMBlock *rb, <nl>          int k; <nl>          int nr = BITS_TO_LONGS(length >> TARGET_PAGE_BITS); <nl>          unsigned long * const *src; <nl> -        unsigned long idx = (page * BITS_PER_LONG) / DIRTY_MEMORY_BLOCK_SIZE; <nl> -        unsigned long offset = BIT_WORD((page * BITS_PER_LONG) % <nl> +        unsigned long word = BIT_WORD((start + rb->offset) >> TARGET_PAGE_BITS); <nl> +        unsigned long idx = (word * BITS_PER_LONG) / DIRTY_MEMORY_BLOCK_SIZE; <nl> +        unsigned long offset = BIT_WORD((word * BITS_PER_LONG) % <nl>                                          DIRTY_MEMORY_BLOCK_SIZE); <nl>   <nl>          rcu_read_lock(); <nl> @@ -414,9 +415,11 @@ uint64_t cpu_physical_memory_sync_dirty_bitmap(RAMBlock *rb, <nl>   <nl>          rcu_read_unlock(); <nl>      } else { <nl> +        ram_addr_t offset = rb->offset; <nl> + <nl>          for (addr = 0; addr < length; addr += TARGET_PAGE_SIZE) { <nl>              if (cpu_physical_memory_test_and_clear_dirty( <nl> -                        start + addr, <nl> +                        start + addr + offset, <nl>                          TARGET_PAGE_SIZE, <nl>                          DIRTY_MEMORY_MIGRATION)) { <nl>                  *real_dirty_pages += 1;
@@ -761,6 +761,7 @@ static int ata_passthrough_12_xfer_size(SCSIDevice *dev, uint8_t *buf) <nl>      switch (length) { <nl>      case 0: <nl>      case 3: /* USB-specific.  */ <nl> +    default: <nl>          xfer = 0; <nl>          break; <nl>      case 1: <nl> @@ -784,6 +785,7 @@ static int ata_passthrough_16_xfer_size(SCSIDevice *dev, uint8_t *buf) <nl>      switch (length) { <nl>      case 0: <nl>      case 3: /* USB-specific.  */ <nl> +    default: <nl>          xfer = 0; <nl>          break; <nl>      case 1:
@@ -1286,6 +1286,8 @@ void qmp_transaction(TransactionActionList *dev_list, Error **errp) <nl>          assert(dev_info->kind < ARRAY_SIZE(actions)); <nl>   <nl>          ops = &actions[dev_info->kind]; <nl> +        assert(ops->instance_size > 0); <nl> + <nl>          state = g_malloc0(ops->instance_size); <nl>          state->ops = ops; <nl>          state->action = dev_info;
@@ -808,9 +808,9 @@ static void vmdk_close(BlockDriverState *bs) <nl>   <nl>      qemu_free(s->l1_table); <nl>      qemu_free(s->l2_cache); <nl> -    bdrv_delete(s->hd); <nl>      // try to close parent image, if exist <nl>      vmdk_parent_close(s->hd); <nl> +    bdrv_delete(s->hd); <nl>  } <nl>   <nl>  static void vmdk_flush(BlockDriverState *bs)
@@ -714,9 +714,7 @@ int xen_be_init(void) <nl>          return -1; <nl>      } <nl>   <nl> -    if (qemu_set_fd_handler(xs_fileno(xenstore), xenstore_update, NULL, NULL) < 0) { <nl> -        goto err; <nl> -    } <nl> +    qemu_set_fd_handler(xs_fileno(xenstore), xenstore_update, NULL, NULL); <nl>   <nl>      if (xen_xc == XC_HANDLER_INITIAL_VALUE) { <nl>          /* Check if xen_init() have been called */
@@ -170,7 +170,7 @@ static void balloon_stats_set_poll_interval(Object *obj, struct Visitor *v, <nl>          return; <nl>      } <nl>   <nl> -    if (value > UINT_MAX) { <nl> +    if (value > UINT32_MAX) { <nl>          error_setg(errp, "timer value is too big"); <nl>          return; <nl>      }
@@ -92,8 +92,6 @@ <nl>  #define MP_ETH_CRDP3            0x4AC <nl>  #define MP_ETH_CTDP0            0x4E0 <nl>  #define MP_ETH_CTDP1            0x4E4 <nl> -#define MP_ETH_CTDP2            0x4E8 <nl> -#define MP_ETH_CTDP3            0x4EC <nl>   <nl>  /* MII PHY access */ <nl>  #define MP_ETH_SMIR_DATA        0x0000FFFF <nl> @@ -308,7 +306,7 @@ static uint64_t mv88w8618_eth_read(void *opaque, hwaddr offset, <nl>      case MP_ETH_CRDP0 ... MP_ETH_CRDP3: <nl>          return s->rx_queue[(offset - MP_ETH_CRDP0)/4]; <nl>   <nl> -    case MP_ETH_CTDP0 ... MP_ETH_CTDP3: <nl> +    case MP_ETH_CTDP0 ... MP_ETH_CTDP1: <nl>          return s->tx_queue[(offset - MP_ETH_CTDP0)/4]; <nl>   <nl>      default: <nl> @@ -362,7 +360,7 @@ static void mv88w8618_eth_write(void *opaque, hwaddr offset, <nl>              s->cur_rx[(offset - MP_ETH_CRDP0)/4] = value; <nl>          break; <nl>   <nl> -    case MP_ETH_CTDP0 ... MP_ETH_CTDP3: <nl> +    case MP_ETH_CTDP0 ... MP_ETH_CTDP1: <nl>          s->tx_queue[(offset - MP_ETH_CTDP0)/4] = value; <nl>          break; <nl>      }
@@ -986,7 +986,7 @@ static void v9fs_attach(void *opaque) <nl>      s->root_fid = fid; <nl>      /* disable migration */ <nl>      error_set(&s->migration_blocker, QERR_VIRTFS_FEATURE_BLOCKS_MIGRATION, <nl> -              s->ctx.fs_root, s->tag); <nl> +              s->ctx.fs_root ? s->ctx.fs_root : "NULL", s->tag); <nl>      migrate_add_blocker(s->migration_blocker); <nl>  out: <nl>      put_fid(pdu, fidp);
@@ -1241,6 +1241,14 @@ static void pcnet_transmit(PCNetState *s) <nl>          } <nl>   <nl>          bcnt = 4096 - GET_FIELD(tmd.length, TMDL, BCNT); <nl> + <nl> +        /* if multi-tmd packet outsizes s->buffer then skip it silently. <nl> +           Note: this is not what real hw does */ <nl> +        if (s->xmit_pos + bcnt > sizeof(s->buffer)) { <nl> +            s->xmit_pos = -1; <nl> +            goto txdone; <nl> +        } <nl> + <nl>          s->phys_mem_read(s->dma_opaque, PHYSADDR(s, tmd.tbadr), <nl>                           s->buffer + s->xmit_pos, bcnt, CSR_BSWP(s)); <nl>          s->xmit_pos += bcnt;
@@ -2167,6 +2167,11 @@ build_dsdt(GArray *table_data, GArray *linker, <nl>                               0, pci->w64.begin, pci->w64.end - 1, 0, <nl>                               pci->w64.end - pci->w64.begin)); <nl>      } <nl> + <nl> +    if (misc->tpm_version != TPM_VERSION_UNSPEC) { <nl> +        aml_append(crs, aml_memory32_fixed(TPM_TIS_ADDR_BASE, <nl> +                   TPM_TIS_ADDR_SIZE, AML_READ_WRITE)); <nl> +    } <nl>      aml_append(scope, aml_name_decl("_CRS", crs)); <nl>   <nl>      /* reserve GPE0 block resources */
@@ -237,7 +237,7 @@ struct BusState { <nl>  struct Property { <nl>      const char   *name; <nl>      PropertyInfo *info; <nl> -    int          offset; <nl> +    ptrdiff_t    offset; <nl>      uint8_t      bitnr; <nl>      qtype_code   qtype; <nl>      int64_t      defval;
@@ -3737,6 +3737,7 @@ static const VMStateDescription vmstate_xhci_event = { <nl>          VMSTATE_UINT32(flags,  XHCIEvent), <nl>          VMSTATE_UINT8(slotid,  XHCIEvent), <nl>          VMSTATE_UINT8(epid,    XHCIEvent), <nl> +        VMSTATE_END_OF_LIST() <nl>      } <nl>  }; <nl>  
@@ -1491,7 +1491,7 @@ static void report_unavailable_features(FeatureWord w, uint32_t mask) <nl>      int i; <nl>   <nl>      for (i = 0; i < 32; ++i) { <nl> -        if (1 << i & mask) { <nl> +        if ((1UL << i) & mask) { <nl>              const char *reg = get_register_name_32(f->cpuid_reg); <nl>              assert(reg); <nl>              fprintf(stderr, "warning: %s doesn't support requested feature: "
@@ -226,9 +226,7 @@ static int tpm_passthrough_open_sysfs_cancel(TPMPassthruState *tpm_pt) <nl>          if (snprintf(path, sizeof(path), "/sys/class/misc/%s/device/cancel", <nl>                       dev) < sizeof(path)) { <nl>              fd = qemu_open(path, O_WRONLY); <nl> -            if (fd >= 0) { <nl> -                tpm_pt->options->cancel_path = g_strdup(path); <nl> -            } else { <nl> +            if (fd < 0) { <nl>                  error_report("tpm_passthrough: Could not open TPM cancel " <nl>                               "path %s : %s", path, strerror(errno)); <nl>              }
@@ -351,10 +351,6 @@ static int vpc_open(BlockDriverState *bs, QDict *options, int flags, <nl>              ret = -EINVAL; <nl>              goto fail; <nl>          } <nl> -        if (s->max_table_entries > (VHD_MAX_SECTORS * 512) / s->block_size) { <nl> -            ret = -EINVAL; <nl> -            goto fail; <nl> -        } <nl>   <nl>          computed_size = (uint64_t) s->max_table_entries * s->block_size; <nl>          if (computed_size < bs->total_sectors * 512) {
@@ -119,11 +119,12 @@ wait: <nl>              break; <nl>          } <nl>   <nl> +        copy = false; <nl> + <nl>          ret = bdrv_is_allocated(bs, sector_num, <nl>                                  STREAM_BUFFER_SIZE / BDRV_SECTOR_SIZE, &n); <nl>          if (ret == 1) { <nl>              /* Allocated in the top, no need to copy.  */ <nl> -            copy = false; <nl>          } else if (ret >= 0) { <nl>              /* Copy if allocated in the intermediate images.  Limit to the <nl>               * known-unallocated area [sector_num, sector_num+n).  */ <nl> @@ -138,7 +139,7 @@ wait: <nl>              copy = (ret == 1); <nl>          } <nl>          trace_stream_one_iteration(s, sector_num, n, ret); <nl> -        if (ret >= 0 && copy) { <nl> +        if (copy) { <nl>              if (s->common.speed) { <nl>                  delay_ns = ratelimit_calculate_delay(&s->limit, n); <nl>                  if (delay_ns > 0) {
@@ -1244,7 +1244,7 @@ fail: <nl>  /* refcount checking functions */ <nl>   <nl>   <nl> -static size_t refcount_array_byte_size(BDRVQcow2State *s, uint64_t entries) <nl> +static uint64_t refcount_array_byte_size(BDRVQcow2State *s, uint64_t entries) <nl>  { <nl>      /* This assertion holds because there is no way we can address more than <nl>       * 2^(64 - 9) clusters at once (with cluster size 512 = 2^9, and because
@@ -132,8 +132,8 @@ static inline int is_bit_set(BlockDriverState *bs, int64_t bitnum) <nl>  /* Return true if first block has been changed (ie. current version is <nl>   * in COW file).  Set the number of continuous blocks for which that <nl>   * is true. */ <nl> -static int cow_is_allocated(BlockDriverState *bs, int64_t sector_num, <nl> -        int nb_sectors, int *num_same) <nl> +static int coroutine_fn cow_co_is_allocated(BlockDriverState *bs, <nl> +        int64_t sector_num, int nb_sectors, int *num_same) <nl>  { <nl>      int changed; <nl>   <nl> @@ -178,7 +178,7 @@ static int cow_read(BlockDriverState *bs, int64_t sector_num, <nl>      int ret, n; <nl>   <nl>      while (nb_sectors > 0) { <nl> -        if (cow_is_allocated(bs, sector_num, nb_sectors, &n)) { <nl> +        if (bdrv_is_allocated(bs, sector_num, nb_sectors, &n)) { <nl>              ret = bdrv_pread(bs->file, <nl>                          s->cow_sectors_offset + sector_num * 512, <nl>                          buf, n * 512); <nl> @@ -335,7 +335,7 @@ static BlockDriver bdrv_cow = { <nl>      .bdrv_read              = cow_co_read, <nl>      .bdrv_write             = cow_co_write, <nl>      .bdrv_co_flush_to_disk  = cow_co_flush, <nl> -    .bdrv_is_allocated      = cow_is_allocated, <nl> +    .bdrv_co_is_allocated   = cow_co_is_allocated, <nl>   <nl>      .create_options = cow_create_options, <nl>  };
@@ -197,6 +197,10 @@ static ssize_t eth_rx(NetClientState *nc, const uint8_t *buf, size_t size) <nl>      } <nl>   <nl>      D(qemu_log("%s %zd rxbase=%x\n", __func__, size, rxbase)); <nl> +    if (size > (R_MAX - R_RX_BUF0 - rxbase) * 4) { <nl> +        D(qemu_log("ethlite packet is too big, size=%x\n", size)); <nl> +        return -1; <nl> +    } <nl>      memcpy(&s->regs[rxbase + R_RX_BUF0], buf, size); <nl>   <nl>      s->regs[rxbase + R_RX_CTRL0] |= CTRL_S;
@@ -1534,7 +1534,7 @@ static int vmdk_create_extent(const char *filename, int64_t filesize, <nl>      int ret, i; <nl>      BlockDriverState *bs = NULL; <nl>      VMDK4Header header; <nl> -    Error *local_err; <nl> +    Error *local_err = NULL; <nl>      uint32_t tmp, magic, grains, gd_sectors, gt_size, gt_count; <nl>      uint32_t *gd_buf = NULL; <nl>      int gd_buf_size; <nl> @@ -1700,7 +1700,7 @@ static int vmdk_create(const char *filename, QEMUOptionParameter *options, <nl>  { <nl>      int idx = 0; <nl>      BlockDriverState *new_bs = NULL; <nl> -    Error *local_err; <nl> +    Error *local_err = NULL; <nl>      char *desc = NULL; <nl>      int64_t total_size = 0, filesize; <nl>      const char *adapter_type = NULL; <nl> @@ -1881,7 +1881,7 @@ static int vmdk_create(const char *filename, QEMUOptionParameter *options, <nl>      } else { <nl>          ret = bdrv_create_file(filename, options, &local_err); <nl>          if (ret < 0) { <nl> -            error_setg_errno(errp, -ret, "Could not create image file"); <nl> +            error_propagate(errp, local_err); <nl>              goto exit; <nl>          } <nl>      } <nl> @@ -1889,7 +1889,7 @@ static int vmdk_create(const char *filename, QEMUOptionParameter *options, <nl>      ret = bdrv_open(&new_bs, filename, NULL, NULL, <nl>                      BDRV_O_RDWR | BDRV_O_PROTOCOL, NULL, &local_err); <nl>      if (ret < 0) { <nl> -        error_setg_errno(errp, -ret, "Could not write description"); <nl> +        error_propagate(errp, local_err); <nl>          goto exit; <nl>      } <nl>      ret = bdrv_pwrite(new_bs, desc_offset, desc, desc_len);
@@ -36,7 +36,7 @@ <nl>   <nl>  typedef struct SuperIOConfig <nl>  { <nl> -    uint8_t config[0xff]; <nl> +    uint8_t config[0x100]; <nl>      uint8_t index; <nl>      uint8_t data; <nl>  } SuperIOConfig;
@@ -353,7 +353,7 @@ int inet_dgram_opts(QemuOpts *opts) <nl>      if (0 != (rc = getaddrinfo(addr, port, &ai, &local))) { <nl>          fprintf(stderr,"getaddrinfo(%s,%s): %s\n", addr, port, <nl>                  gai_strerror(rc)); <nl> -        return -1; <nl> +        goto err; <nl>      } <nl>   <nl>      /* create socket */
@@ -2301,7 +2301,7 @@ static void vfio_unmap_bar(VFIOPCIDevice *vdev, int nr) <nl>  static void vfio_map_bar(VFIOPCIDevice *vdev, int nr) <nl>  { <nl>      VFIOBAR *bar = &vdev->bars[nr]; <nl> -    unsigned size = bar->region.size; <nl> +    uint64_t size = bar->region.size; <nl>      char name[64]; <nl>      uint32_t pci_bar; <nl>      uint8_t type; <nl> @@ -2351,7 +2351,7 @@ static void vfio_map_bar(VFIOPCIDevice *vdev, int nr) <nl>      } <nl>   <nl>      if (vdev->msix && vdev->msix->table_bar == nr) { <nl> -        unsigned start; <nl> +        uint64_t start; <nl>   <nl>          start = HOST_PAGE_ALIGN(vdev->msix->table_offset + <nl>                                  (vdev->msix->entries * PCI_MSIX_ENTRY_SIZE));
@@ -1817,9 +1817,10 @@ struct target_sigcontext { <nl>  /* A Sparc stack frame */ <nl>  struct sparc_stackf { <nl>          abi_ulong locals[8]; <nl> -        abi_ulong ins[6]; <nl> -        struct sparc_stackf *fp; <nl> -        abi_ulong callers_pc; <nl> +        abi_ulong ins[8]; <nl> +        /* It's simpler to treat fp and callers_pc as elements of ins[] <nl> +         * since we never need to access them ourselves. <nl> +         */ <nl>          char *structptr; <nl>          abi_ulong xargs[6]; <nl>          abi_ulong xxargs[1];
@@ -102,11 +102,15 @@ static target_ulong h_enter(PowerPCCPU *cpu, sPAPRMachineState *spapr, <nl>              return H_PARAMETER; <nl>          } <nl>      } else { <nl> +        target_ulong wimg_flags; <nl>          /* Looks like an IO address */ <nl>          /* FIXME: What WIMG combinations could be sensible for IO? <nl>           * For now we allow WIMG=010x, but are there others? */ <nl>          /* FIXME: Should we check against registered IO addresses? */ <nl> -        if ((ptel & (HPTE64_R_W | HPTE64_R_I | HPTE64_R_M)) != HPTE64_R_I) { <nl> +        wimg_flags = (ptel & (HPTE64_R_W | HPTE64_R_I | HPTE64_R_M)); <nl> + <nl> +        if (wimg_flags != HPTE64_R_I && <nl> +            wimg_flags != (HPTE64_R_I | HPTE64_R_M)) { <nl>              return H_PARAMETER; <nl>          } <nl>      }
@@ -4679,12 +4679,15 @@ static void disas_sparc_insn(DisasContext * dc, unsigned int insn) <nl>                  case 0xd:       /* ldstub -- XXX: should be atomically */ <nl>                      { <nl>                          TCGv r_const; <nl> +                        TCGv tmp = tcg_temp_new(); <nl>   <nl>                          gen_address_mask(dc, cpu_addr); <nl> -                        tcg_gen_qemu_ld8u(cpu_val, cpu_addr, dc->mem_idx); <nl> +                        tcg_gen_qemu_ld8u(tmp, cpu_addr, dc->mem_idx); <nl>                          r_const = tcg_const_tl(0xff); <nl>                          tcg_gen_qemu_st8(r_const, cpu_addr, dc->mem_idx); <nl> +                        tcg_gen_mov_tl(cpu_val, tmp); <nl>                          tcg_temp_free(r_const); <nl> +                        tcg_temp_free(tmp); <nl>                      } <nl>                      break; <nl>                  case 0x0f:
@@ -932,6 +932,7 @@ static void qxl_enter_vga_mode(PCIQXLDevice *d) <nl>      qemu_spice_create_host_primary(&d->ssd); <nl>      d->mode = QXL_MODE_VGA; <nl>      memset(&d->ssd.dirty, 0, sizeof(d->ssd.dirty)); <nl> +    vga_dirty_log_start(&d->vga); <nl>  } <nl>   <nl>  static void qxl_exit_vga_mode(PCIQXLDevice *d) <nl> @@ -940,6 +941,7 @@ static void qxl_exit_vga_mode(PCIQXLDevice *d) <nl>          return; <nl>      } <nl>      trace_qxl_exit_vga_mode(d->id); <nl> +    vga_dirty_log_stop(&d->vga); <nl>      qxl_destroy_primary(d, QXL_SYNC); <nl>  } <nl>  
@@ -496,7 +496,9 @@ static int vfio_msix_vector_do_use(PCIDevice *pdev, unsigned int nr, <nl>              vfio_update_kvm_msi_virq(vector, *msg, pdev); <nl>          } <nl>      } else { <nl> -        vfio_add_kvm_msi_virq(vdev, vector, nr, true); <nl> +        if (msg) { <nl> +            vfio_add_kvm_msi_virq(vdev, vector, nr, true); <nl> +        } <nl>      } <nl>   <nl>      /*
@@ -3176,7 +3176,9 @@ static int tcp_chr_wait_connected(CharDriverState *chr, Error **errp) <nl>      TCPCharDriver *s = chr->opaque; <nl>      QIOChannelSocket *sioc; <nl>   <nl> -    while (!s->connected) { <nl> +    /* It can't wait on s->connected, since it is set asynchronously <nl> +     * in TLS and telnet cases, only wait for an accepted socket */ <nl> +    while (!s->ioc) { <nl>          if (s->is_listen) { <nl>              fprintf(stderr, "QEMU waiting for connection on: %s\n", <nl>                      chr->filename);
@@ -3644,7 +3644,7 @@ void vnc_display_open(const char *id, Error **errp) <nl>              if (vs->ws_enabled) { <nl>                  vs->lwebsock = inet_listen_opts(wsopts, 0, errp); <nl>                  if (vs->lwebsock < 0) { <nl> -                    if (vs->lsock) { <nl> +                    if (vs->lsock != -1) { <nl>                          close(vs->lsock); <nl>                          vs->lsock = -1; <nl>                      }
@@ -313,9 +313,7 @@ static ram_addr_t qxl_rom_size(void) <nl>                                   sizeof(qxl_modes); <nl>      uint32_t rom_size = 8192; /* two pages */ <nl>   <nl> -    required_rom_size = MAX(required_rom_size, TARGET_PAGE_SIZE); <nl> -    required_rom_size = msb_mask(required_rom_size * 2 - 1); <nl> -    assert(required_rom_size <= rom_size); <nl> +    QEMU_BUILD_BUG_ON(required_rom_size > rom_size); <nl>      return rom_size; <nl>  } <nl>  
@@ -1079,6 +1079,9 @@ void socket_listen_cleanup(int fd, Error **errp) <nl>      SocketAddress *addr; <nl>   <nl>      addr = socket_local_address(fd, errp); <nl> +    if (!addr) { <nl> +        return; <nl> +    } <nl>   <nl>      if (addr->type == SOCKET_ADDRESS_TYPE_UNIX <nl>          && addr->u.q_unix.path) {
@@ -960,21 +960,21 @@ static int multiwrite_f(int argc, char **argv) <nl>      buf = g_malloc0(nr_reqs * sizeof(*buf)); <nl>      qiovs = g_malloc(nr_reqs * sizeof(*qiovs)); <nl>   <nl> -    for (i = 0; i < nr_reqs; i++) { <nl> +    for (i = 0; i < nr_reqs && optind < argc; i++) { <nl>          int j; <nl>   <nl>          /* Read the offset of the request */ <nl>          offset = cvtnum(argv[optind]); <nl>          if (offset < 0) { <nl>              printf("non-numeric offset argument -- %s\n", argv[optind]); <nl> -            return 0; <nl> +            goto out; <nl>          } <nl>          optind++; <nl>   <nl>          if (offset & 0x1ff) { <nl>              printf("offset %lld is not sector aligned\n", <nl>                     (long long)offset); <nl> -            return 0; <nl> +            goto out; <nl>          } <nl>   <nl>          if (i == 0) { <nl> @@ -1005,6 +1005,9 @@ static int multiwrite_f(int argc, char **argv) <nl>          pattern++; <nl>      } <nl>   <nl> +    /* If there were empty requests at the end, ignore them */ <nl> +    nr_reqs = i; <nl> + <nl>      gettimeofday(&t1, NULL); <nl>      cnt = do_aio_multiwrite(reqs, nr_reqs, &total); <nl>      gettimeofday(&t2, NULL);
@@ -176,6 +176,12 @@ static void msix_mmio_write(void *opaque, target_phys_addr_t addr, <nl>      PCIDevice *dev = opaque; <nl>      unsigned int offset = addr & (MSIX_PAGE_SIZE - 1) & ~0x3; <nl>      int vector = offset / PCI_MSIX_ENTRY_SIZE; <nl> + <nl> +    /* MSI-X page includes a read-only PBA and a writeable Vector Control. */ <nl> +    if (vector >= dev->msix_entries_nr) { <nl> +        return; <nl> +    } <nl> + <nl>      pci_set_long(dev->msix_table_page + offset, val); <nl>      msix_handle_mask_update(dev, vector); <nl>  }
@@ -299,7 +299,9 @@ static int apic_init_common(SysBusDevice *dev) <nl>   <nl>      sysbus_init_mmio(dev, &s->io_memory); <nl>   <nl> -    if (!vapic && s->vapic_control & VAPIC_ENABLE_MASK) { <nl> +    /* Note: We need at least 1M to map the VAPIC option ROM */ <nl> +    if (!vapic && s->vapic_control & VAPIC_ENABLE_MASK && <nl> +        ram_size >= 1024 * 1024) { <nl>          vapic = sysbus_create_simple("kvmvapic", -1, NULL); <nl>      } <nl>      s->vapic = vapic;
@@ -1300,7 +1300,7 @@ TranslationBlock *tb_gen_code(CPUState *cpu, <nl>  #ifdef CONFIG_PROFILER <nl>      tcg_ctx.tb_count++; <nl>      tcg_ctx.interm_time += profile_getclock() - ti; <nl> -    tcg_ctx.code_time -= profile_getclock(); <nl> +    ti = profile_getclock(); <nl>  #endif <nl>   <nl>      /* ??? Overflow could be handled better here.  In particular, we <nl> @@ -1318,7 +1318,7 @@ TranslationBlock *tb_gen_code(CPUState *cpu, <nl>      } <nl>   <nl>  #ifdef CONFIG_PROFILER <nl> -    tcg_ctx.code_time += profile_getclock(); <nl> +    tcg_ctx.code_time += profile_getclock() - ti; <nl>      tcg_ctx.code_in_len += tb->size; <nl>      tcg_ctx.code_out_len += gen_code_size; <nl>      tcg_ctx.search_out_len += search_size;
@@ -309,10 +309,9 @@ static void spapr_cpu_core_realize(DeviceState *dev, Error **errp) <nl>      } <nl>   <nl>  err: <nl> -    while (i >= 0) { <nl> +    while (--i >= 0) { <nl>          obj = sc->threads + i * size; <nl>          object_unparent(obj); <nl> -        i--; <nl>      } <nl>      g_free(sc->threads); <nl>      error_propagate(errp, local_err);
@@ -3178,7 +3178,7 @@ CharDriverState *qemu_chr_new_from_opts(QemuOpts *opts, <nl>      if (i == NULL) { <nl>          error_setg(errp, "chardev: backend \"%s\" not found", <nl>                     qemu_opt_get(opts, "backend")); <nl> -        return NULL; <nl> +        goto err; <nl>      } <nl>   <nl>      if (!cd->open) {
@@ -96,7 +96,7 @@ World *rocker_get_world(Rocker *r, enum rocker_world_type type) <nl>   <nl>  RockerSwitch *qmp_query_rocker(const char *name, Error **errp) <nl>  { <nl> -    RockerSwitch *rocker = g_malloc0(sizeof(*rocker)); <nl> +    RockerSwitch *rocker; <nl>      Rocker *r; <nl>   <nl>      r = rocker_find(name); <nl> @@ -106,6 +106,7 @@ RockerSwitch *qmp_query_rocker(const char *name, Error **errp) <nl>          return NULL; <nl>      } <nl>   <nl> +    rocker = g_new0(RockerSwitch, 1); <nl>      rocker->name = g_strdup(r->name); <nl>      rocker->id = r->switch_id; <nl>      rocker->ports = r->fp_ports;
@@ -252,6 +252,8 @@ static int vnc_worker_thread_loop(VncJobQueue *queue) <nl>   <nl>          if (job->vs->csock == -1) { <nl>              vnc_unlock_display(job->vs->vd); <nl> +            /* Copy persistent encoding data */ <nl> +            vnc_async_encoding_end(job->vs, &vs); <nl>              goto disconnected; <nl>          } <nl>   <nl> @@ -278,6 +280,9 @@ static int vnc_worker_thread_loop(VncJobQueue *queue) <nl>          vnc_async_encoding_end(job->vs, &vs); <nl>   <nl>  	qemu_bh_schedule(job->vs->bh); <nl> +    }  else { <nl> +        /* Copy persistent encoding data */ <nl> +        vnc_async_encoding_end(job->vs, &vs); <nl>      } <nl>      vnc_unlock_output(job->vs); <nl>  
@@ -1129,14 +1129,14 @@ int main(int argc, char **argv) <nl>          } <nl>      } <nl>   <nl> -    if (chdir("/") < 0) { <nl> -        do_perror("chdir"); <nl> -        goto error; <nl> -    } <nl>      if (chroot(rpath) < 0) { <nl>          do_perror("chroot"); <nl>          goto error; <nl>      } <nl> +    if (chdir("/") < 0) { <nl> +        do_perror("chdir"); <nl> +        goto error; <nl> +    } <nl>   <nl>      get_version = false; <nl>  #ifdef FS_IOC_GETVERSION
@@ -572,8 +572,17 @@ static void invalidate_tlb (int idx) <nl>  { <nl>      tlb_t *tlb; <nl>      target_ulong addr; <nl> +    uint8_t ASID; <nl> + <nl> +    ASID = env->CP0_EntryHi & 0xFF; <nl>   <nl>      tlb = &env->tlb[idx]; <nl> +    /* The qemu TLB is flushed then the ASID changes, so no need to <nl> +       flush these entries again.  */ <nl> +    if (tlb->G == 0 && tlb->ASID != ASID) { <nl> +        return; <nl> +    } <nl> + <nl>      if (tlb->V0) { <nl>          tb_invalidate_page_range(tlb->PFN[0], tlb->end - tlb->VPN); <nl>          addr = tlb->VPN;
@@ -859,11 +859,6 @@ static void memory_region_destructor_ram(MemoryRegion *mr) <nl>      qemu_ram_free(mr->ram_addr); <nl>  } <nl>   <nl> -static void memory_region_destructor_alias(MemoryRegion *mr) <nl> -{ <nl> -    memory_region_unref(mr->alias); <nl> -} <nl> - <nl>  static void memory_region_destructor_ram_from_ptr(MemoryRegion *mr) <nl>  { <nl>      qemu_ram_free_from_ptr(mr->ram_addr); <nl> @@ -1272,8 +1267,6 @@ void memory_region_init_alias(MemoryRegion *mr, <nl>                                uint64_t size) <nl>  { <nl>      memory_region_init(mr, owner, name, size); <nl> -    memory_region_ref(orig); <nl> -    mr->destructor = memory_region_destructor_alias; <nl>      mr->alias = orig; <nl>      mr->alias_offset = offset; <nl>  }
@@ -417,7 +417,7 @@ static bool is_byte_request_lun_aligned(int64_t offset, int count, <nl>  static bool is_sector_request_lun_aligned(int64_t sector_num, int nb_sectors, <nl>                                            IscsiLun *iscsilun) <nl>  { <nl> -    assert(nb_sectors < BDRV_REQUEST_MAX_SECTORS); <nl> +    assert(nb_sectors <= BDRV_REQUEST_MAX_SECTORS); <nl>      return is_byte_request_lun_aligned(sector_num << BDRV_SECTOR_BITS, <nl>                                         nb_sectors << BDRV_SECTOR_BITS, <nl>                                         iscsilun); <nl> @@ -661,7 +661,8 @@ static int coroutine_fn iscsi_co_readv(BlockDriverState *bs, <nl>          int64_t ret; <nl>          int pnum; <nl>          BlockDriverState *file; <nl> -        ret = iscsi_co_get_block_status(bs, sector_num, INT_MAX, &pnum, &file); <nl> +        ret = iscsi_co_get_block_status(bs, sector_num, <nl> +                                        BDRV_REQUEST_MAX_SECTORS, &pnum, &file); <nl>          if (ret < 0) { <nl>              return ret; <nl>          }
@@ -279,6 +279,7 @@ int main(int argc, char **argv) <nl>      cmdline = g_strdup_printf("-device ipmi-bmc-sim,id=bmc0" <nl>                                " -device isa-ipmi-kcs,bmc=bmc0"); <nl>      qtest_start(cmdline); <nl> +    g_free(cmdline); <nl>      qtest_irq_intercept_in(global_qtest, "ioapic"); <nl>      qtest_add_func("/ipmi/local/kcs_base", test_kcs_base); <nl>      qtest_add_func("/ipmi/local/kcs_abort", test_kcs_abort);
@@ -595,7 +595,7 @@ static int do_readlink(struct iovec *iovec, struct iovec *out_iovec) <nl>      } <nl>      buffer = g_malloc(size); <nl>      v9fs_string_init(&target); <nl> -    retval = readlink(path.data, buffer, size); <nl> +    retval = readlink(path.data, buffer, size - 1); <nl>      if (retval > 0) { <nl>          buffer[retval] = '\0'; <nl>          v9fs_string_sprintf(&target, "%s", buffer);
@@ -379,7 +379,7 @@ static void qht_bucket_reset__locked(struct qht_bucket *head) <nl>              if (b->pointers[i] == NULL) { <nl>                  goto done; <nl>              } <nl> -            b->hashes[i] = 0; <nl> +            atomic_set(&b->hashes[i], 0); <nl>              atomic_set(&b->pointers[i], NULL); <nl>          } <nl>          b = b->next; <nl> @@ -444,7 +444,7 @@ void *qht_do_lookup(struct qht_bucket *head, qht_lookup_func_t func, <nl>   <nl>      do { <nl>          for (i = 0; i < QHT_BUCKET_ENTRIES; i++) { <nl> -            if (b->hashes[i] == hash) { <nl> +            if (atomic_read(&b->hashes[i]) == hash) { <nl>                  /* The pointer is dereferenced before seqlock_read_retry, <nl>                   * so (unlike qht_insert__locked) we need to use <nl>                   * atomic_rcu_read here. <nl> @@ -538,8 +538,8 @@ static bool qht_insert__locked(struct qht *ht, struct qht_map *map, <nl>      if (new) { <nl>          atomic_rcu_set(&prev->next, b); <nl>      } <nl> -    b->hashes[i] = hash; <nl>      /* smp_wmb() implicit in seqlock_write_begin.  */ <nl> +    atomic_set(&b->hashes[i], hash); <nl>      atomic_set(&b->pointers[i], p); <nl>      seqlock_write_end(&head->sequence); <nl>      return true; <nl> @@ -607,10 +607,10 @@ qht_entry_move(struct qht_bucket *to, int i, struct qht_bucket *from, int j) <nl>      qht_debug_assert(to->pointers[i]); <nl>      qht_debug_assert(from->pointers[j]); <nl>   <nl> -    to->hashes[i] = from->hashes[j]; <nl> +    atomic_set(&to->hashes[i], from->hashes[j]); <nl>      atomic_set(&to->pointers[i], from->pointers[j]); <nl>   <nl> -    from->hashes[j] = 0; <nl> +    atomic_set(&from->hashes[j], 0); <nl>      atomic_set(&from->pointers[j], NULL); <nl>  } <nl>  
@@ -757,8 +757,8 @@ static void nvdimm_dsm_set_label_data(NVDIMMDevice *nvdimm, NvdimmDsmIn *in, <nl>          return; <nl>      } <nl>   <nl> -    assert(sizeof(*in) + sizeof(*set_label_data) + set_label_data->length <= <nl> -           4096); <nl> +    assert(offsetof(NvdimmDsmIn, arg3) + <nl> +           sizeof(*set_label_data) + set_label_data->length <= 4096); <nl>   <nl>      nvc->write_label_data(nvdimm, set_label_data->in_buf, <nl>                            set_label_data->length, set_label_data->offset);
@@ -478,7 +478,7 @@ static unsigned hpte_page_shift(const struct ppc_one_seg_page_size *sps, <nl>   <nl>          mask = ((1ULL << ps->page_shift) - 1) & HPTE64_R_RPN; <nl>   <nl> -        if ((pte1 & mask) == (ps->pte_enc << HPTE64_R_RPN_SHIFT)) { <nl> +        if ((pte1 & mask) == ((uint64_t)ps->pte_enc << HPTE64_R_RPN_SHIFT)) { <nl>              return ps->page_shift; <nl>          } <nl>      }
@@ -213,7 +213,7 @@ void parse_option_size(const char *name, const char *value, <nl>  bool has_help_option(const char *param) <nl>  { <nl>      size_t buflen = strlen(param) + 1; <nl> -    char *buf = g_malloc0(buflen); <nl> +    char *buf = g_malloc(buflen); <nl>      const char *p = param; <nl>      bool result = false; <nl>   <nl> @@ -237,7 +237,7 @@ out: <nl>  bool is_valid_option_list(const char *param) <nl>  { <nl>      size_t buflen = strlen(param) + 1; <nl> -    char *buf = g_malloc0(buflen); <nl> +    char *buf = g_malloc(buflen); <nl>      const char *p = param; <nl>      bool result = true; <nl>  
@@ -267,9 +267,7 @@ static target_ulong h_put_tce_indirect(PowerPCCPU *cpu, <nl>      ioba &= page_mask; <nl>   <nl>      for (i = 0; i < npages; ++i, ioba += page_size) { <nl> -        target_ulong off = (tce_list & ~SPAPR_TCE_RW) + <nl> -                                i * sizeof(target_ulong); <nl> -        tce = ldq_be_phys(cs->as, off); <nl> +        tce = ldq_be_phys(cs->as, tce_list + i * sizeof(target_ulong)); <nl>   <nl>          ret = put_tce_emu(tcet, ioba, tce); <nl>          if (ret) {
@@ -902,7 +902,9 @@ int hvf_vcpu_exec(CPUState *cpu) <nl>              macvm_set_rip(cpu, rip + ins_len); <nl>              break; <nl>          case VMX_REASON_VMCALL: <nl> -            /* TODO: inject #GP fault */ <nl> +            env->exception_injected = EXCP0D_GPF; <nl> +            env->has_error_code = true; <nl> +            env->error_code = 0; <nl>              break; <nl>          default: <nl>              error_report("%llx: unhandled exit %llx\n", rip, exit_reason);
@@ -301,6 +301,14 @@ void memory_region_allocate_system_memory(MemoryRegion *mr, Object *owner, <nl>              exit(1); <nl>          } <nl>   <nl> +        if (memory_region_is_mapped(seg)) { <nl> +            char *path = object_get_canonical_path_component(OBJECT(backend)); <nl> +            error_report("memory backend %s is used multiple times. Each " <nl> +                         "-numa option must use a different memdev value.", <nl> +                         path); <nl> +            exit(1); <nl> +        } <nl> + <nl>          memory_region_add_subregion(mr, addr, seg); <nl>          vmstate_register_ram_global(seg); <nl>          addr += size;
@@ -1512,7 +1512,8 @@ static int iscsi_truncate(BlockDriverState *bs, int64_t offset) <nl>      if (iscsilun->allocationmap != NULL) { <nl>          g_free(iscsilun->allocationmap); <nl>          iscsilun->allocationmap = <nl> -            bitmap_new(DIV_ROUND_UP(bs->total_sectors, <nl> +            bitmap_new(DIV_ROUND_UP(sector_lun2qemu(iscsilun->num_blocks, <nl> +                                                    iscsilun), <nl>                                      iscsilun->cluster_sectors)); <nl>      } <nl>  
@@ -296,6 +296,13 @@ static void scsi_do_read(void *opaque, int ret) <nl>          } <nl>      } <nl>   <nl> +    if (r->req.io_canceled) { <nl> +        return; <nl> +    } <nl> + <nl> +    /* The request is used as the AIO opaque value, so add a ref.  */ <nl> +    scsi_req_ref(&r->req); <nl> + <nl>      if (r->req.sg) { <nl>          dma_acct_start(s->qdev.conf.bs, &r->acct, r->req.sg, BDRV_ACCT_READ); <nl>          r->req.resid -= r->req.sg->size;
@@ -453,12 +453,12 @@ static uint64_t do_cvttq(CPUAlphaState *env, uint64_t a, int roundmode) <nl>          if (shift >= 0) { <nl>              /* In this case the number is so large that we must shift <nl>                 the fraction left.  There is no rounding to do.  */ <nl> -            exc = FPCR_IOV | FPCR_INE; <nl> -            if (shift < 63) { <nl> +            if (shift < 64) { <nl>                  ret = frac << shift; <nl> -                if ((ret >> shift) == frac) { <nl> -                    exc = 0; <nl> -                } <nl> +            } <nl> +            /* Check for overflow.  Note the special case of -0x1p63.  */ <nl> +            if (shift >= 11 && a != 0xC3E0000000000000ull) { <nl> +                exc = FPCR_IOV | FPCR_INE; <nl>              } <nl>          } else { <nl>              uint64_t round;
@@ -126,11 +126,11 @@ static MemoryRegionIOMMUOps spapr_iommu_ops = { <nl>  static int spapr_tce_table_realize(DeviceState *dev) <nl>  { <nl>      sPAPRTCETable *tcet = SPAPR_TCE_TABLE(dev); <nl> +    uint64_t window_size = (uint64_t)tcet->nb_table << tcet->page_shift; <nl>   <nl> -    if (kvm_enabled()) { <nl> +    if (kvm_enabled() && !(window_size >> 32)) { <nl>          tcet->table = kvmppc_create_spapr_tce(tcet->liobn, <nl> -                                              tcet->nb_table << <nl> -                                              tcet->page_shift, <nl> +                                              window_size, <nl>                                                &tcet->fd, <nl>                                                tcet->vfio_accel); <nl>      }
@@ -784,7 +784,7 @@ void fw_cfg_add_file_callback(FWCfgState *s,  const char *filename, <nl>       * index and "i - 1" is the one being copied from, thus the <nl>       * unusual start and end in the for statement. <nl>       */ <nl> -    for (i = count + 1; i > index; i--) { <nl> +    for (i = count; i > index; i--) { <nl>          s->files->f[i] = s->files->f[i - 1]; <nl>          s->files->f[i].select = cpu_to_be16(FW_CFG_FILE_FIRST + i); <nl>          s->entries[0][FW_CFG_FILE_FIRST + i] = <nl> @@ -833,7 +833,6 @@ void *fw_cfg_modify_file(FWCfgState *s, const char *filename, <nl>      assert(s->files); <nl>   <nl>      index = be32_to_cpu(s->files->count); <nl> -    assert(index < fw_cfg_file_slots(s)); <nl>   <nl>      for (i = 0; i < index; i++) { <nl>          if (strcmp(filename, s->files->f[i].name) == 0) { <nl> @@ -843,6 +842,9 @@ void *fw_cfg_modify_file(FWCfgState *s, const char *filename, <nl>              return ptr; <nl>          } <nl>      } <nl> + <nl> +    assert(index < fw_cfg_file_slots(s)); <nl> + <nl>      /* add new one */ <nl>      fw_cfg_add_file_callback(s, filename, NULL, NULL, NULL, data, len, true); <nl>      return NULL;
@@ -114,8 +114,8 @@ static void virtio_net_vhost_status(VirtIONet *n, uint8_t status) <nl>          return; <nl>      } <nl>   <nl> -    if (!!n->vhost_started == virtio_net_started(n, status) && <nl> -                              !nc->peer->link_down) { <nl> +    if (!!n->vhost_started == <nl> +        (virtio_net_started(n, status) && !nc->peer->link_down)) { <nl>          return; <nl>      } <nl>      if (!n->vhost_started) {
@@ -232,8 +232,7 @@ static int nbd_handle_reply_err(QIOChannel *ioc, nbd_opt_reply *reply, <nl>          break; <nl>   <nl>      case NBD_REP_ERR_UNKNOWN: <nl> -        error_setg(errp, "Requested export not available for option %" PRIx32 <nl> -                   " (%s)", reply->option, nbd_opt_lookup(reply->option)); <nl> +        error_setg(errp, "Requested export not available"); <nl>          break; <nl>   <nl>      case NBD_REP_ERR_SHUTDOWN: <nl> @@ -253,7 +252,7 @@ static int nbd_handle_reply_err(QIOChannel *ioc, nbd_opt_reply *reply, <nl>      } <nl>   <nl>      if (msg) { <nl> -        error_append_hint(errp, "%s\n", msg); <nl> +        error_append_hint(errp, "server reported: %s\n", msg); <nl>      } <nl>   <nl>   cleanup:
@@ -289,7 +289,7 @@ enum RSState { <nl>  typedef struct GDBState { <nl>      CPUArchState *c_cpu; /* current CPU for step/continue ops */ <nl>      CPUArchState *g_cpu; /* current CPU for other ops */ <nl> -    CPUArchState *query_cpu; /* for q{f|s}ThreadInfo */ <nl> +    CPUState *query_cpu; /* for q{f|s}ThreadInfo */ <nl>      enum RSState state; /* parsing state */ <nl>      char line_buf[MAX_PACKET_LENGTH]; <nl>      int line_buf_index; <nl> @@ -2401,15 +2401,14 @@ static int gdb_handle_packet(GDBState *s, const char *line_buf) <nl>              put_packet(s, "QC1"); <nl>              break; <nl>          } else if (strcmp(p,"fThreadInfo") == 0) { <nl> -            s->query_cpu = first_cpu->env_ptr; <nl> +            s->query_cpu = first_cpu; <nl>              goto report_cpuinfo; <nl>          } else if (strcmp(p,"sThreadInfo") == 0) { <nl>          report_cpuinfo: <nl>              if (s->query_cpu) { <nl> -                snprintf(buf, sizeof(buf), "m%x", <nl> -                         cpu_index(ENV_GET_CPU(s->query_cpu))); <nl> +                snprintf(buf, sizeof(buf), "m%x", cpu_index(s->query_cpu)); <nl>                  put_packet(s, buf); <nl> -                s->query_cpu = ENV_GET_CPU(s->query_cpu)->next_cpu->env_ptr; <nl> +                s->query_cpu = s->query_cpu->next_cpu; <nl>              } else <nl>                  put_packet(s, "l"); <nl>              break;
@@ -873,6 +873,9 @@ void vhost_dev_disable_notifiers(struct vhost_dev *hdev, VirtIODevice *vdev) <nl>  int vhost_dev_start(struct vhost_dev *hdev, VirtIODevice *vdev) <nl>  { <nl>      int i, r; <nl> + <nl> +    hdev->started = true; <nl> + <nl>      if (!vdev->binding->set_guest_notifiers) { <nl>          fprintf(stderr, "binding does not support guest notifiers\n"); <nl>          r = -ENOSYS; <nl> @@ -918,8 +921,6 @@ int vhost_dev_start(struct vhost_dev *hdev, VirtIODevice *vdev) <nl>          } <nl>      } <nl>   <nl> -    hdev->started = true; <nl> - <nl>      return 0; <nl>  fail_log: <nl>  fail_vq: <nl> @@ -934,6 +935,8 @@ fail_features: <nl>      vdev->binding->set_guest_notifiers(vdev->binding_opaque, hdev->nvqs, false); <nl>  fail_notifiers: <nl>  fail: <nl> + <nl> +    hdev->started = false; <nl>      return r; <nl>  } <nl>  
@@ -782,13 +782,13 @@ static int usb_hid_handle_control(USBDevice *dev, USBPacket *p, <nl>              goto fail; <nl>          break; <nl>      case GET_PROTOCOL: <nl> -        if (s->kind != USB_KEYBOARD) <nl> +        if (s->kind != USB_KEYBOARD && s->kind != USB_MOUSE) <nl>              goto fail; <nl>          ret = 1; <nl>          data[0] = s->protocol; <nl>          break; <nl>      case SET_PROTOCOL: <nl> -        if (s->kind != USB_KEYBOARD) <nl> +        if (s->kind != USB_KEYBOARD && s->kind != USB_MOUSE) <nl>              goto fail; <nl>          ret = 0; <nl>          s->protocol = value;
@@ -775,7 +775,7 @@ static int create_dynamic_disk(BlockBackend *blk, uint8_t *buf, <nl>      num_bat_entries = (total_sectors + block_size / 512) / (block_size / 512); <nl>   <nl>      ret = blk_pwrite(blk, offset, buf, HEADER_SIZE); <nl> -    if (ret) { <nl> +    if (ret < 0) { <nl>          goto fail; <nl>      } <nl>  
@@ -108,6 +108,7 @@ static int __attach (RIOW32Dbg *dbg) { <nl>  		eprintf ("exception code 0x%04x\n", (ut32)de.dwDebugEventCode); <nl>  		goto att_exit; <nl>  	} <nl> +	dbg->pi.hProcess = h_proc; <nl>  	dbg->winbase = (ut64)de.u.CreateProcessInfo.lpBaseOfImage; <nl>  	dbg->tid = __w32_first_thread (dbg->pid); <nl>  	ret = dbg->pid;
@@ -65,6 +65,7 @@ R_API void r_cons_less_str(const char *str) { <nl>  		} <nl>  	} <nl>  	free (lines); <nl> +	free (p); <nl>  	r_cons_set_raw (R_FALSE); <nl>  	r_cons_show_cursor (R_TRUE); <nl>  }
@@ -306,7 +306,7 @@ R_API void r_anal_var_list_show(RAnal *anal, RAnalFunction *fcn, int kind, int m <nl>  				// we cant express all type info here :( <nl>  				anal->printf ("af%c %d %s %s @ 0x%"PFMT64x"\n", <nl>  					kind, var->delta, <nl> -					var->type, var->name, fcn->addr); <nl> +					var->name, var->type, fcn->addr); <nl>  				break; <nl>  			case 'j': <nl>  				anal->printf ("{\"name\":\"%s\","
@@ -421,7 +421,7 @@ static void dex_parse_debug_item(RBinFile *binfile, RBinDexObj *bin, <nl>  		return; <nl>  	} <nl>  	ut8 opcode = *(p4++) & 0xff; <nl> -	while (keep) { <nl> +	while (keep && p4 < p4_end) { <nl>  		switch (opcode) { <nl>  		case 0x0: // DBG_END_SEQUENCE <nl>  			keep = false; <nl> @@ -606,7 +606,6 @@ static void dex_parse_debug_item(RBinFile *binfile, RBinDexObj *bin, <nl>  		binfile->sdb_addrinfo = sdb_new0 (); <nl>  	} <nl>   <nl> - <nl>  	RListIter *iter1; <nl>  	struct dex_debug_position_t *pos; <nl>  // Loading the debug info takes too much time and nobody uses this afaik
@@ -521,6 +521,9 @@ R_API void r_cons_filter() { <nl>   <nl>  R_API void r_cons_push() { <nl>  	if (I.cons_stack) { <nl> +		if (I.buffer_len < 1) { <nl> +			return; <nl> +		} <nl>  		RConsStack *data = R_NEW0 (RConsStack); <nl>  		data->buf = malloc (I.buffer_len); <nl>  		if (!data->buf) { <nl> @@ -552,7 +555,7 @@ R_API void r_cons_pop() { <nl>  		if (!data) { <nl>  			return; <nl>  		} <nl> -		if (!data->buf) { <nl> +		if (!data->buf || data->buf_size < 1 || data->buf_len < 1) { <nl>  			free (data); <nl>  			return; <nl>  		}
@@ -449,8 +449,14 @@ grub_disk_read (grub_disk_t disk, grub_disk_addr_t sector, <nl>        if (data) <nl>  	{ <nl>  	  /* Just copy it!  */ <nl> -	  if (buf) <nl> +	  if (buf) { <nl> +	    if (pos + real_offset + len >= size) { <nl> +              // prevent read overflow <nl> +              grub_errno = GRUB_ERR_BAD_FS; <nl> +              return grub_errno; <nl> +	    } <nl>  	    grub_memcpy (buf, data + pos + real_offset, len); <nl> +          } <nl>  	  grub_disk_cache_unlock (disk->dev->id, disk->id, start_sector); <nl>  	} <nl>        else
@@ -9,6 +9,7 @@ static int r_core_magic_at(RCore *core, const char *file, ut64 addr, int depth, <nl>  	char *q, *p; <nl>  	const char *str; <nl>  	int found = 0, delta = 0, adelta = 0; <nl> +	const char *cmdhit = r_config_get (core->config, "cmd.hit"); <nl>  #define NAH 32 <nl>   <nl>  	if (--depth<0) <nl> @@ -63,6 +64,9 @@ static int r_core_magic_at(RCore *core, const char *file, ut64 addr, int depth, <nl>  				*q = '\n'; <nl>  				strcpy (q+1, q+((q[2]==' ')? 3: 2)); <nl>  			} <nl> +		if (cmdhit && *cmdhit) { <nl> +			r_core_cmd0 (core, cmdhit); <nl> +		} <nl>  		// TODO: This must be a callback .. move this into RSearch? <nl>  		r_cons_printf ("0x%08"PFMT64x" %d %s\n", addr + adelta, magicdepth-depth, p); <nl>  		r_cons_clear_line (1);
@@ -1,4 +1,4 @@ <nl> -/* radare - LGPL - Copyright 2008-2014 nibble, pancake, inisider */ <nl> +/* radare - LGPL - Copyright 2008-2015 nibble, pancake, inisider */ <nl>   <nl>  #include <stdio.h> <nl>  #include <stdlib.h> <nl> @@ -1004,6 +1004,8 @@ struct r_bin_pe_import_t* PE_(r_bin_pe_get_imports)(struct PE_(r_bin_pe_obj_t) * <nl>  	PE_DWord import_func_name_offset; <nl>  	PE_(image_import_directory) *curr_import_dir = NULL; <nl>  	PE_(image_delay_import_directory) *curr_delay_import_dir = 0; <nl> +	if (!bin) <nl> +		return NULL; <nl>   <nl>  	if (bin->import_directory_offset < bin->size && bin->import_directory_offset > 0) { <nl>  		curr_import_dir = (PE_(image_import_directory)*)(bin->b->buf + bin->import_directory_offset);
@@ -2023,9 +2023,9 @@ static int opmov(RAsm *a, ut8 *data, const Opcode *op) { <nl>  			if (op->operands[1].scale[0] == 0) { <nl>  				return -1; <nl>  			} <nl> -			data[l++] = SEG_REG_PREFIXES[op->operands[1].regs[0]]; <nl> +			data[l++] = SEG_REG_PREFIXES[op->operands[1].regs[0] % 6]; <nl>  			data[l++] = 0x8b; <nl> -			data[l++] = op->operands[0].reg << 3 | 0x5; <nl> +			data[l++] = (((ut32)op->operands[0].reg) << 3) | 0x5; <nl>  			data[l++] = offset; <nl>  			data[l++] = offset >> 8; <nl>  			data[l++] = offset >> 16;
@@ -78,6 +78,9 @@ static int formatDisassembledOperand(char *strOperand, int operandNum, const dis <nl>  	char binary[9]; <nl>  	int retVal; <nl>   <nl> +	if (operandNum >= AVR_MAX_NUM_OPERANDS) <nl> +		return 0; <nl> + <nl>  	switch (dInstruction.instruction->operandTypes[operandNum]) { <nl>  	case OPERAND_NONE: <nl>  	case OPERAND_REGISTER_GHOST:
@@ -86,11 +86,15 @@ static char *getstr(const char *src) { <nl>  } <nl>   <nl>  static void parseline (char *b) { <nl> +	int must_free = R_FALSE; <nl>  	char *e = strchr (b, '='); <nl>  	if (!e) return; <nl>  	if (*b=='#') return; <nl>  	*e++ = 0; <nl> -	if (*e=='$') e = r_sys_getenv (e); <nl> +	if (*e=='$') { <nl> +		must_free = R_TRUE; <nl> +		e = r_sys_getenv (e); <nl> +	} <nl>  	if (e == NULL) return; <nl>  	if (!strcmp (b, "program")) _args[0] = _program = strdup (e); <nl>  	else if (!strcmp (b, "system")) _system = strdup (e); <nl> @@ -145,6 +149,8 @@ static void parseline (char *b) { <nl>  			r_sys_setenv (e, v); <nl>  		} <nl>  	} <nl> +	if (must_free == R_TRUE) <nl> +		free (e); <nl>  } <nl>   <nl>  #if __UNIX__
@@ -551,6 +551,7 @@ static int cmd_help(void *data, const char *input) { <nl>  		switch (input[1]) { <nl>  		case '?': <nl>  			r_cons_printf ("|Usage: ?v[id][ num]  # Show value\n" <nl> +				"|?vx number  -> show 8 digit padding in hex\n" <nl>  				"|?vi1 200    -> 1 byte size value (char)\n" <nl>  				"|?vi2 0xffff -> 2 byte size value (short)\n" <nl>  				"|?vi4 0xffff -> 4 byte size value (int)\n" <nl> @@ -561,6 +562,9 @@ static int cmd_help(void *data, const char *input) { <nl>  		case '\0': <nl>  			r_cons_printf ("%d\n", (st32)n); <nl>  			break; <nl> +		case 'x': // "?vx" <nl> +			r_cons_printf ("0x%08"PFMT64d"\n", n); <nl> +			break; <nl>  		case 'i': // "?vi" <nl>  			switch (input[2]) { <nl>  			case '1': // byte
@@ -267,7 +267,7 @@ static void analop_esil(RAnal *a, RAnalOp *op, ut64 addr, const ut8 *buf) { <nl>  		emit("B,!,OV,=,0,A,B,A,/=,A,B,*,-,-,B,=,0,C,="); <nl>  		break; <nl>  	case 0x85: /* mov */ <nl> -		h(IRAM_BASE ",%2$d,+,[1]," IRAM_BASE ",%2$d,+,=[1]"); <nl> +		h(IRAM_BASE ",%2$d,+,[1]," IRAM_BASE ",%3$d,+,=[1]"); <nl>  		break; <nl>  	case 0x86: case 0x87: <nl>  		j (XR(R0I) XW(IB1));
@@ -3124,9 +3124,9 @@ static int cmd_print(void *data, const char *input) { <nl>  		} <nl>  		break; <nl>  	} <nl> -	/*if (tbs != core->blocksize)*/ <nl> -		/*r_core_block_size (core, tbs);*/ <nl>  beach: <nl> +	if (tbs != core->blocksize) <nl> +		r_core_block_size (core, tbs); <nl>  	if (tmpseek != UT64_MAX) { <nl>  		r_core_seek (core, tmpseek, SEEK_SET); <nl>  	}
@@ -183,6 +183,7 @@ static RList* symbols(RBinArch *arch) { <nl>  		strncpy (ptr->forwarder, "NONE", R_BIN_SIZEOF_STRINGS); <nl>  		strncpy (ptr->bind, symbol[i].bind, R_BIN_SIZEOF_STRINGS); <nl>  		strncpy (ptr->type, symbol[i].type, R_BIN_SIZEOF_STRINGS); <nl> +		ptr->classname = 0; <nl>  		ptr->rva = symbol[i].offset + base; <nl>  		ptr->offset = symbol[i].offset + base; <nl>  		ptr->size = symbol[i].size;
@@ -427,6 +427,13 @@ static bool r_bin_mdmp_init_directory_entry(struct r_bin_mdmp_obj *obj, struct m <nl>   <nl>  		for (i = 0; i < memory_list->number_of_memory_ranges; i++) { <nl>  			memories = (struct minidump_memory_descriptor *)(&(memory_list->memory_ranges)); <nl> +			ut64 start_offset = entry->location.rva <nl> +			                + r_offsetof (struct minidump_memory_list, memory_ranges); <nl> +			ut64 needed_space = (i + 1) * sizeof (memories[0]); <nl> +			if (start_offset + needed_space > obj->b->length <nl> +			    || start_offset + needed_space < start_offset) { <nl> +				break; <nl> +			} <nl>  			r_list_append (obj->streams.memories, &(memories[i])); <nl>  		} <nl>  		break;
@@ -690,13 +690,13 @@ break; <nl>  			       fpos + sizeof (struct ext2_dirent), <nl>  			       dirent.namelen, filename); <nl>  	  if (grub_errno) { <nl> -            free (filename); <nl> +            grub_free (filename); <nl>  	    return 0; <nl>  	  } <nl>   <nl>  	  fdiro = grub_malloc (sizeof (struct grub_fshelp_node)); <nl>  	  if (! fdiro) { <nl> -            free (filename); <nl> +            grub_free (filename); <nl>  	    return 0; <nl>            } <nl>   <nl> @@ -724,7 +724,7 @@ break; <nl>                                      grub_le_to_cpu32 (dirent.inode), <nl>  				    &fdiro->inode); <nl>  	      if (grub_errno) { <nl> -                  free (filename); <nl> +                  grub_free (filename); <nl>  		  grub_free (fdiro); <nl>  		  return 0; <nl>  		} <nl> @@ -743,10 +743,10 @@ break; <nl>  	    } <nl>   <nl>  	  if (hook (filename, type, fdiro, closure)) { <nl> -            free (filename); <nl> +            grub_free (filename); <nl>  	    return 1; <nl>            } <nl> -          free (filename); <nl> +          grub_free (filename); <nl>  	} <nl>   <nl>        fpos += grub_le_to_cpu16 (dirent.direntlen);
@@ -633,7 +633,7 @@ R_API bool r_core_bin_load(RCore *r, const char *filenameuri, ut64 baddr) { <nl>  		r_config_set_i (r->config, "io.va", 0); <nl>  	} <nl>  	//workaround to map correctly malloc:// and raw binaries <nl> -	if (!plugin || !strcmp (plugin->name, "any") || r_io_desc_is_dbg (desc) || (obj && (!obj->sections ||!va))) { <nl> +	if (!plugin || !strcmp (plugin->name, "any") || r_io_desc_is_dbg (desc) || (obj && (!obj->sections || !va))) { <nl>  		r_io_map_new (r->io, desc->fd, desc->flags, 0LL, laddr, r_io_desc_size (desc), true); <nl>  	} <nl>  	return true;
@@ -2337,7 +2337,6 @@ R_API int r_core_print_disasm(RPrint *p, RCore *core, ut64 addr, ut8 *buf, int l <nl>  		core->anal->cur->reset_counter (core->anal, addr); <nl>  	} <nl>   <nl> - <nl>  	handle_reflines_init (core->anal, ds); <nl>  	core->inc = 0; <nl>  	/* reset jmp table if not asked to keep it */ <nl> @@ -2406,6 +2405,9 @@ toro: <nl>  				inc = 0; //delta; <nl>  				idx = 0; <nl>  				of = f; <nl> +				if (len == l) { <nl> +					break; <nl> +				} <nl>  				continue; <nl>  			} else { <nl>  				ds->lines--;
@@ -67,7 +67,11 @@ VRT_acl_log(VRT_CTX, const char *msg) <nl>  { <nl>   <nl>  	CHECK_OBJ_NOTNULL(ctx, VRT_CTX_MAGIC); <nl> -	VSLb(ctx->vsl, SLT_VCL_acl, "%s", msg); <nl> +	AN(msg); <nl> +	if (ctx->vsl != NULL) <nl> +		VSLb(ctx->vsl, SLT_VCL_acl, "%s", msg); <nl> +	else <nl> +		VSL(SLT_VCL_acl, 0, "%s", msg); <nl>  } <nl>   <nl>  /*--------------------------------------------------------------------*/
@@ -559,9 +559,12 @@ h2_end_headers(struct worker *wrk, struct h2_sess *h2, <nl>  	assert(r2->state == H2_S_OPEN); <nl>  	h2e = h2h_decode_fini(h2, r2->decode); <nl>  	FREE_OBJ(r2->decode); <nl> -	if (h2->rxf_flags & H2FF_HEADERS_END_STREAM) <nl> -		r2->state = H2_S_CLOS_REM; <nl>  	h2->new_req = NULL; <nl> +	if (r2->req->req_body_status == REQ_BODY_NONE) { <nl> +		/* REQ_BODY_NONE implies one of the frames in the <nl> +		 * header block contained END_STREAM */ <nl> +		r2->state = H2_S_CLOS_REM; <nl> +	} <nl>  	if (h2e != NULL) { <nl>  		Lck_Lock(&h2->sess->mtx); <nl>  		VSLb(h2->vsl, SLT_Debug, "HPACK/FINI %s", h2e->name);
@@ -410,6 +410,7 @@ mgt_run(int dflag, const char *T_arg) <nl>   <nl>  	setproctitle("Varnish-Mgr %s", heritage.name); <nl>   <nl> +	memset(&sac, 0, sizeof sac); <nl>  	sac.sa_handler = SIG_IGN; <nl>  	sac.sa_flags = SA_RESTART; <nl>  
@@ -352,7 +352,8 @@ HSH_Deref(struct object *o) <nl>  	} <nl>  	assert(o->refcnt > 0); <nl>  	r = --o->refcnt; <nl> -	hsh_rush(oh); <nl> +	if (oh != NULL) <nl> +		hsh_rush(oh); <nl>  	if (oh != NULL) { <nl>  		if (!r) <nl>  			VTAILQ_REMOVE(&oh->objects, o, list);
@@ -67,7 +67,7 @@ smp_def_sign(const struct smp_sc *sc, struct smp_signctx *ctx, <nl>  	AZ(off & 7);			/* Alignment */ <nl>  	assert(strlen(id) < sizeof ctx->ss->ident); <nl>   <nl> -	memset(ctx, 0, sizeof ctx); <nl> +	memset(ctx, 0, sizeof *ctx); <nl>  	ctx->ss = (void*)(sc->base + off); <nl>  	ctx->unique = sc->unique; <nl>  	ctx->id = id;
@@ -661,7 +661,10 @@ HSH_FindBan(struct sess *sp, struct objcore **oc) <nl>  	CHECK_OBJ_NOTNULL(oc1, OBJCORE_MAGIC); <nl>  	oh = oc1->objhead; <nl>  	CHECK_OBJ_NOTNULL(oh, OBJHEAD_MAGIC); <nl> -	Lck_Lock(&oh->mtx); <nl> +	if (Lck_Trylock(&oh->mtx)) { <nl> +		*oc = NULL; <nl> +		return; <nl> +	} <nl>  	VTAILQ_FOREACH(oc2, &oh->objcs, list) <nl>  		if (oc1 == oc2) <nl>  			break;
@@ -288,6 +288,7 @@ do_list(struct cli *cli, struct director *d, void *priv) <nl>  	if (d->vdir->admin_health == VDI_AH_DELETED) <nl>  		return (0); <nl>   <nl> +	// XXX admin health "probe" for the no-probe case is confusing <nl>  	VCLI_Out(cli, "\n%-30s %-7s ", d->vdir->cli_name, VDI_Ahealth(d)); <nl>   <nl>  	if (d->vdir->methods->list != NULL)
@@ -119,6 +119,10 @@ read_tmo(int fd, char *ptr, unsigned len, double tmo) <nl>  	pfd.events = POLLIN; <nl>  	for (j = 0; len > 0; ) { <nl>  		i = poll(&pfd, 1, to); <nl> +		if (i < 0) { <nl> +			errno = EINTR; <nl> +			return (-1); <nl> +		} <nl>  		if (i == 0) { <nl>  			errno = ETIMEDOUT; <nl>  			return (-1);
@@ -180,6 +180,7 @@ vwk_fini(struct waiter *w) <nl>  	vwk->kq = -1; <nl>  	Lck_Unlock(&vwk->mtx); <nl>  	AZ(pthread_join(vwk->thread, &vp)); <nl> +	Lck_Delete(&vwk->mtx); <nl>  } <nl>   <nl>  /*--------------------------------------------------------------------*/
@@ -5467,7 +5467,7 @@ static char *addenv(struct cgi_env_block *block, const char *fmt, ...) <nl>  		return NULL; <nl>   <nl>  	/* Calculate how much space is left in the buffer */ <nl> -	space = sizeof(block->buf) - block->len - 2; <nl> +	space = (int)(sizeof(block->buf) - block->len) - 2; <nl>  	/* assert(space >= 0); */ <nl>  	if (space < 0) <nl>  		return NULL;
@@ -1213,7 +1213,8 @@ next: <nl>  	} <nl>   <nl>  	// this must be called only by the master !!! <nl> -	if (uwsgi.mywid > 0) return; <nl> +	if (!uwsgi.workers) return; <nl> +	if (uwsgi.workers[0].pid != getpid()) return; <nl>  	uwsgi_legion_announce_death(); <nl>  } <nl>  
@@ -54,7 +54,7 @@ static struct uwsgi_option rawrouter_options[] = { <nl>  	{"rawrouter-ss", required_argument, 0, "run the rawrouter stats server", uwsgi_opt_set_str, &urr.cr.stats_server, 0}, <nl>  	{"rawrouter-harakiri", required_argument, 0, "enable rawrouter harakiri", uwsgi_opt_set_int, &urr.cr.harakiri, 0}, <nl>   <nl> -	{"rawrouter-xclient", no_argument, 0, "use the xclient protocol to pass the client addres", uwsgi_opt_true, &urr.xclient, 0}, <nl> +	{"rawrouter-xclient", no_argument, 0, "use the xclient protocol to pass the client address", uwsgi_opt_true, &urr.xclient, 0}, <nl>   <nl>  	{"rawrouter-buffer-size", required_argument, 0, "set internal buffer size (default: page size)", uwsgi_opt_set_64bit, &urr.cr.buffer_size, 0}, <nl>  
@@ -3338,7 +3338,7 @@ void *mem_collector(void *foobar) { <nl>  	uwsgi_log_verbose("mem-collector thread started for worker %d\n", uwsgi.mywid); <nl>  	for(;;) { <nl>  		sleep(uwsgi.mem_collector_freq); <nl> -		uint64_t rss, vsz; <nl> +		uint64_t rss = 0, vsz = 0; <nl>  		get_memusage(&rss, &vsz); <nl>  		uwsgi.workers[uwsgi.mywid].rss_size = rss; <nl>  		uwsgi.workers[uwsgi.mywid].vsz_size = vsz;
@@ -582,7 +582,7 @@ static void mongrel2_connect() { <nl>  		} <nl>  		char *responder = strchr(uwsgi_sock->name, ','); <nl>          	if (!responder) { <nl> -                	uwsgi_log("invalid zeromq address\n"); <nl> +                	uwsgi_log("invalid zeromq address: %s\n", uwsgi_sock->name); <nl>                  	exit(1); <nl>          	} <nl>          	uwsgi_sock->receiver = uwsgi_concat2n(uwsgi_sock->name, responder - uwsgi_sock->name, "", 0);
@@ -141,6 +141,9 @@ bool persist_file_context::clear_var(const std::string &global, bool immediate) <nl>  	while ((active->empty()) && (!namespace_.lineage_.empty())) { <nl>  		name_space prev = namespace_.prev(); <nl>  		active = get_node(cfg_, prev); <nl> +		/// @todo: This assertion replaces a seg fault. Still need to fix the <nl> +		/// real bug (documented as bug #21093). <nl> +		assert(active != NULL); <nl>  		active->clear_children(namespace_.node_); <nl>  		if (active->has_child("variables") && active->child("variables").empty()) { <nl>  			active->clear_children("variables");
@@ -38,6 +38,7 @@ <nl>  		@li <a href="hierarchy.html">Classes</a> <nl>  		@li <a href="files.html">Source Files</a> <nl>  		@li <a href="todo.html">Todo</a> <nl> +		@li <a href="deprecated.html">Deprecated</a> <nl>  	</td> <nl>  	</tr> <nl>  	</table>
@@ -654,10 +654,14 @@ config connect::side::get_config() const <nl>  			} <nl>  			{ <nl>  				res["id"] = res["save_id"]; <nl> -				const config &ai_cfg = ai::configuration::get_ai_config_for(ai_algorithm_); <nl> -				res.add_child("ai",ai_cfg); <nl>  				utils::string_map symbols; <nl> -				symbols["playername"] = ai_cfg["description"]; <nl> +				if (allow_player_) { <nl> +					const config &ai_cfg = ai::configuration::get_ai_config_for(ai_algorithm_); <nl> +					res.add_child("ai",ai_cfg); <nl> +					symbols["playername"] = ai_cfg["description"]; <nl> +				} else { // do not import default ai cfg here - all is set by scenario config <nl> +					symbols["playername"] = _("Computer Player"); <nl> +				} <nl>  				symbols["side"] = res["side"].str(); <nl>  				description = vgettext("$playername $side",symbols); <nl>  			}
@@ -666,7 +666,9 @@ std::string server::process_command(const std::string& query) { <nl>  	} else if (command == "status") { <nl>  		out << "STATUS REPORT\n"; <nl>  		for (player_map::const_iterator pl = players_.begin(); pl != players_.end(); ++pl) { <nl> -			if (parameters == "" || utils::wildcard_string_match(pl->second.name(), parameters)) { <nl> +			if (parameters == "" <nl> +				|| utils::wildcard_string_match(pl->second.name(), parameters) <nl> +				|| utils::wildcard_string_match(network::ip_address(pl->first), parameters)) { <nl>  				const network::connection_stats& stats = network::get_connection_stats(pl->first); <nl>  				const int time_connected = stats.time_connected/1000; <nl>  				const int seconds = time_connected%60; <nl> @@ -785,7 +787,7 @@ std::string server::process_command(const std::string& query) { <nl>  	} else { <nl>  		out << "Command '" << command << "' is not recognized.\n"; <nl>  		out << "Available commands are: (lobby)msg <message>, motd [<message>]" <nl> -			", status [<nickmask>], metrics, (k)ban(s) [<mask>], unban <ipmask>" <nl> +			", status [<mask>], metrics, (k)ban(s) [<mask>], unban <ipmask>" <nl>  			", kick <mask>"; <nl>  	} <nl>  
@@ -153,7 +153,8 @@ namespace { <nl>  		net_manager_(min_thread,max_thread), <nl>  		server_manager_(load_config()), <nl>  		hooks_(), <nl> -		input_(0) <nl> +		input_(0), <nl> +		compress_level_(0) <nl>  	{ <nl>  		if(cfg_.child("campaigns") == NULL) { <nl>  			cfg_.add_child("campaigns");
@@ -322,7 +322,6 @@ paths::route mouse_handler::get_route(unit_map::const_iterator un, map_location <nl>   <nl>  void mouse_handler::mouse_press(const SDL_MouseButtonEvent& event, const bool browse) <nl>  { <nl> -	if (attackmove_) return; <nl>  	mouse_handler_base::mouse_press(event, browse); <nl>  } <nl>   <nl> @@ -444,7 +443,9 @@ bool mouse_handler::left_click(int x, int y, const bool browse) <nl>   <nl>  		gui().unhighlight_reach(); <nl>  		move_unit_along_current_route(check_shroud); <nl> -	} else { <nl> +	} else if (!attackmove_) { <nl> +		// we block selection during attack+move (because motion is blocked) <nl> +		// FIXME: deal with selected event when commands_disabled <nl>  		// we select a (maybe empty) hex <nl>  		select_hex(hex, browse); <nl>  	}
@@ -159,7 +159,7 @@ namespace <nl>  		char* endptr; <nl>  		int res = strtol(index_str, &endptr, 10); <nl>   <nl> -		if (*endptr != ']' || res > int(game_config::max_loop)) <nl> +		if (*endptr != ']' || res > int(game_config::max_loop) || endptr == index_str) <nl>  		{ <nl>  			throw invalid_variablename_exception(); <nl>  		}
@@ -82,7 +82,8 @@ void room_manager::load_config(const config& cfg) <nl>  { <nl>  	filename_ = cfg["room_save_file"]; <nl>  	compress_stored_rooms_ = utils::string_bool(cfg["compress_stored_rooms"], true); <nl> -	new_room_policy_ = pp_from_string(cfg["new_room_policy"]); <nl> +	PRIVILEGE_POLICY pp = pp_from_string(cfg["new_room_policy"]); <nl> +	if (pp != PP_COUNT) new_room_policy_ = pp; <nl>  } <nl>   <nl>  const std::string& room_manager::storage_filename() const
@@ -21,14 +21,14 @@ <nl>   <nl>  bool detect_format_and_read(config &cfg, std::istream &in) <nl>  { <nl> -	try { <nl> +	unsigned char c = in.peek(); <nl> +	if (c < 5) { <nl>  		read_compressed(cfg, in); <nl>  		return true; <nl> -	} catch (config::error &) { <nl> +	} else { <nl> +		read(cfg, in); <nl> +		return false; <nl>  	} <nl> - <nl> -	read(cfg, in); <nl> -	return false; <nl>  } <nl>   <nl>  void write_possibly_compressed(std::string const &filename, config &cfg, bool compress)
@@ -247,6 +247,7 @@ void server::handle_read_from_fifo(const boost::system::error_code& error, std:: <nl>   <nl>  	if(ctl == "shut_down") { <nl>  		LOG_CS << "Shut down requested by admin, shutting down...\n"; <nl> +		throw server_shutdown("Shut down via fifo command"); <nl>  	} else if(ctl == "readonly") { <nl>  		if(ctl.args_count()) { <nl>  			cfg_["read_only"] = read_only_ = utils::string_bool(ctl[1], true);
@@ -311,6 +311,7 @@ config connect::side::get_config() const <nl>  			break; <nl>  		case CNTR_EMPTY: <nl>  			description = N_("(Empty slot)"); <nl> +			res["no_leader"] = "yes"; <nl>  			break; <nl>  		default: <nl>  			wassert(false);
@@ -1922,7 +1922,8 @@ bool event_handler::handle_event_command(const queued_event& event_info, <nl>  					const int side = lexical_cast_default<int>(side_str.value(), -1); <nl>   <nl>  					//Select advancement if it is on the playing side and the player is a human <nl> -					const bool sel = (side == u.side() && (*teams)[side-1].is_human()); <nl> +					const bool sel = (side == static_cast<int>(u.side()) <nl> +					                 && (*teams)[side-1].is_human()); <nl>   <nl>  					//The code in dialogs::advance_unit tests whether the unit can advance <nl>  					dialogs::advance_unit(*game_data_ptr, *game_map, *units, loc, *screen, !sel, true);
@@ -1553,11 +1553,11 @@ void game_controller::reset_game_cfg() <nl>  	defines_map_["APPLE"] = preproc_define(); <nl>  #endif <nl>   <nl> -	defines_map_["NORMAL"] = preproc_define(); <nl> -	defines_map_["MEDIUM"] = preproc_define(); <nl> - <nl>  	if(multiplayer_mode_) { <nl>  		defines_map_["MULTIPLAYER"] = preproc_define(); <nl> +	} else { <nl> +		defines_map_["NORMAL"] = preproc_define(); <nl> +		defines_map_["MEDIUM"] = preproc_define(); <nl>  	} <nl>   <nl>  	refresh_game_cfg();
@@ -1338,7 +1338,7 @@ DECLAREreadFunc(readContigTilesIntoBuffer) <nl>  		uint32 colb = 0; <nl>  		uint32 col; <nl>   <nl> -		for (col = 0; col < imagewidth; col += tw) { <nl> +		for (col = 0; col < imagewidth && colb < imagew; col += tw) { <nl>  			if (TIFFReadTile(in, tilebuf, col, row, 0, 0) < 0 <nl>  			    && !ignore) { <nl>  				TIFFError(TIFFFileName(in), <nl> @@ -1523,7 +1523,7 @@ DECLAREwriteFunc(writeBufferToContigTiles) <nl>  		uint32 colb = 0; <nl>  		uint32 col; <nl>   <nl> -		for (col = 0; col < imagewidth; col += tw) { <nl> +		for (col = 0; col < imagewidth && colb < imagew; col += tw) { <nl>  			/* <nl>  			 * Tile is clipped horizontally.  Calculate <nl>  			 * visible portion and skewing factors.
@@ -400,6 +400,10 @@ process(register int code, unsigned char** fill) <nl>      } <nl>   <nl>      if (oldcode == -1) { <nl> +        if (code >= clear) { <nl> +            fprintf(stderr, "bad input: code=%d is larger than clear=%d\n",code, clear); <nl> +            return 0; <nl> +        } <nl>  	*(*fill)++ = suffix[code]; <nl>  	firstchar = oldcode = code; <nl>  	return 1;
@@ -3403,8 +3403,12 @@ struct bdev *bdev_copy(struct lxc_container *c0, const char *cname, <nl>  	*needs_rdep = 0; <nl>  	if (bdevtype && strcmp(orig->type, "dir") == 0 && <nl>  			(strcmp(bdevtype, "aufs") == 0 || <nl> -			 strcmp(bdevtype, "overlayfs") == 0)) <nl> +			 strcmp(bdevtype, "overlayfs") == 0)) { <nl>  		*needs_rdep = 1; <nl> +	} else if (snap && strcmp(orig->type, "lvm") == 0 && <nl> +			!lvm_is_thin_volume(orig->src)) { <nl> +		*needs_rdep = 1; <nl> +	} <nl>   <nl>  	new = bdev_get(bdevtype ? bdevtype : orig->type); <nl>  	if (!new) {
@@ -765,6 +765,7 @@ static int config_network_ipv4_gateway(const char *key, const char *value, <nl>  	} <nl>   <nl>  	if (!strcmp(value, "auto")) { <nl> +		free(gw); <nl>  		netdev->ipv4_gateway = NULL; <nl>  		netdev->ipv4_gateway_auto = true; <nl>  	} else {
@@ -339,7 +339,7 @@ int dhcp6_option_parse_ip6addrs(uint8_t *optval, uint16_t optlen, <nl>   <nl>  int dhcp6_option_parse_domainname(const uint8_t *optval, uint16_t optlen, char ***str_arr) { <nl>          size_t pos = 0, idx = 0; <nl> -        _cleanup_free_ char **names = NULL; <nl> +        _cleanup_strv_free_ char **names = NULL; <nl>          int r; <nl>   <nl>          assert_return(optlen > 1, -ENODATA);
@@ -108,6 +108,7 @@ int main(int argc, char *argv[], char *envp[]) <nl>  	udev_init_config(); <nl>   <nl>  	/* set signal handlers */ <nl> +	memset(&act, 0x00, sizeof(act)); <nl>  	act.sa_handler = (void (*) (int))sig_handler; <nl>  	sigemptyset (&act.sa_mask); <nl>  	act.sa_flags = 0;
@@ -1396,7 +1396,7 @@ static int unit_file_search( <nl>   <nl>          _cleanup_free_ char *template = NULL; <nl>          _cleanup_strv_free_ char **dirs = NULL; <nl> -        _cleanup_free_ char **files = NULL; <nl> +        _cleanup_strv_free_ char **files = NULL; <nl>          const char *dropin_dir_name = NULL; <nl>          const char *dropin_template_dir_name = NULL; <nl>  
@@ -74,7 +74,8 @@ _public_ int sd_pid_get_machine_name(pid_t pid, char **name) { <nl>   <nl>  _public_ int sd_pid_get_owner_uid(pid_t pid, uid_t *uid) { <nl>          int r; <nl> -        _cleanup_free_ char *root = NULL, *cgroup = NULL, *p = NULL, *cc = NULL; <nl> +        _cleanup_free_ char *root = NULL, *cgroup = NULL, *cc = NULL; <nl> +        char *p; <nl>          struct stat st; <nl>   <nl>          if (pid < 0)
@@ -56,13 +56,13 @@ int util_resolve_sys_link(struct udev *udev, char *syspath, size_t size) <nl>  { <nl>  	char link_target[UTIL_PATH_SIZE]; <nl>   <nl> -	int len; <nl> +	ssize_t len; <nl>  	int i; <nl>  	int back; <nl>  	char *base; <nl>   <nl>  	len = readlink(syspath, link_target, sizeof(link_target)); <nl> -	if (len <= 0) <nl> +	if (len <= 0 || len == (ssize_t)sizeof(link_target)) <nl>  		return -1; <nl>  	link_target[len] = '\0'; <nl>  	dbg(udev, "path link '%s' points to '%s'\n", syspath, link_target);
@@ -1592,7 +1592,7 @@ int config_parse_service_sockets( <nl>   <nl>          p = rvalue; <nl>          for(;;) { <nl> -                _cleanup_free_ char *word = NULL, *t = NULL, *k = NULL; <nl> +                _cleanup_free_ char *word = NULL, *k = NULL; <nl>   <nl>                  r = extract_first_word(&p, &word, NULL, 0); <nl>                  if (r == 0)
@@ -2737,6 +2737,8 @@ static int service_dispatch_timer(sd_event_source *source, usec_t usec, void *us <nl>   <nl>          case SERVICE_RELOAD: <nl>                  log_unit_warning(UNIT(s), "Reload operation timed out. Stopping."); <nl> +                service_unwatch_control_pid(s); <nl> +                service_kill_control_processes(s); <nl>                  s->reload_result = SERVICE_FAILURE_TIMEOUT; <nl>                  service_enter_running(s, SERVICE_SUCCESS); <nl>                  break;
@@ -2751,8 +2751,10 @@ int manager_environment_add(Manager *m, char **minus, char **plus) { <nl>   <nl>          if (!strv_isempty(plus)) { <nl>                  b = strv_env_merge(2, l, plus); <nl> -                if (!b) <nl> +                if (!b) { <nl> +                        strv_free(a); <nl>                          return -ENOMEM; <nl> +                } <nl>   <nl>                  l = b; <nl>          }
@@ -111,6 +111,12 @@ static void manager_watch_jobs_in_progress(Manager *m) { <nl>   <nl>          assert(m); <nl>   <nl> +        /* We do not want to show the cylon animation if the user <nl> +         * needs to confirm service executions otherwise confirmation <nl> +         * messages will be screwed by the cylon animation. */ <nl> +        if (m->confirm_spawn) <nl> +                return; <nl> + <nl>          if (m->jobs_in_progress_event_source) <nl>                  return; <nl>  
@@ -327,6 +327,7 @@ static void worker_spawn(Manager *manager, struct event *event) { <nl>          struct udev *udev = event->udev; <nl>          _cleanup_udev_monitor_unref_ struct udev_monitor *worker_monitor = NULL; <nl>          pid_t pid; <nl> +        int r = 0; <nl>   <nl>          /* listen for new events */ <nl>          worker_monitor = udev_monitor_new_from_netlink(udev, NULL); <nl> @@ -334,7 +335,9 @@ static void worker_spawn(Manager *manager, struct event *event) { <nl>                  return; <nl>          /* allow the main daemon netlink address to send devices to the worker */ <nl>          udev_monitor_allow_unicast_sender(worker_monitor, manager->monitor); <nl> -        udev_monitor_enable_receiving(worker_monitor); <nl> +        r = udev_monitor_enable_receiving(worker_monitor); <nl> +        if (r < 0) <nl> +                log_error_errno(r, "worker: could not enable receiving of device: %m"); <nl>   <nl>          pid = fork(); <nl>          switch (pid) { <nl> @@ -346,7 +349,6 @@ static void worker_spawn(Manager *manager, struct event *event) { <nl>                  struct epoll_event ep_signal = { .events = EPOLLIN }; <nl>                  struct epoll_event ep_monitor = { .events = EPOLLIN }; <nl>                  sigset_t mask; <nl> -                int r = 0; <nl>   <nl>                  /* take initial device from queue */ <nl>                  dev = event->dev; <nl> @@ -528,7 +530,6 @@ out: <nl>          default: <nl>          { <nl>                  struct worker *worker; <nl> -                int r; <nl>   <nl>                  r = worker_new(&worker, manager, worker_monitor, pid); <nl>                  if (r < 0)
@@ -81,7 +81,7 @@ int manager_handle_action( <nl>   <nl>                  n = manager_count_displays(m); <nl>                  if (n != 1) { <nl> -                        log_debug("Ignoring lid switch request, %s displays connected."); <nl> +                        log_debug("Ignoring lid switch request, %i displays connected.", n); <nl>                          return 0; <nl>                  } <nl>          }
@@ -1181,6 +1181,12 @@ static int dns_transaction_request_dnssec_rr(DnsTransaction *t, DnsResourceKey * <nl>          assert(t); <nl>          assert(key); <nl>   <nl> +        r = dns_resource_key_equal(t->key, key); <nl> +        if (r < 0) <nl> +                return r; <nl> +        if (r > 0) /* Don't go in circles */ <nl> +                return 0; <nl> + <nl>          /* Try to get the data from the trust anchor */ <nl>          r = dns_trust_anchor_lookup(&t->scope->manager->trust_anchor, key, &a); <nl>          if (r < 0)
@@ -708,6 +708,7 @@ int config_parse_strv(const char *unit, <nl>                        void *userdata) { <nl>   <nl>          char ***sv = data; <nl> +        int r; <nl>   <nl>          assert(filename); <nl>          assert(lvalue); <nl> @@ -721,18 +722,19 @@ int config_parse_strv(const char *unit, <nl>                   * we actually fill in a real empty array here rather <nl>                   * than NULL, since some code wants to know if <nl>                   * something was set at all... */ <nl> -                empty = strv_new(NULL, NULL); <nl> +                empty = new0(char*, 1); <nl>                  if (!empty) <nl>                          return log_oom(); <nl>   <nl>                  strv_free(*sv); <nl>                  *sv = empty; <nl> + <nl>                  return 0; <nl>          } <nl>   <nl>          for (;;) { <nl>                  char *word = NULL; <nl> -                int r; <nl> + <nl>                  r = extract_first_word(&rvalue, &word, WHITESPACE, EXTRACT_QUOTES|EXTRACT_RETAIN_ESCAPE); <nl>                  if (r == 0) <nl>                          break;
@@ -300,6 +300,10 @@ _public_ int sd_journal_sendv(const struct iovec *iov, int n) { <nl>          if (k >= 0) <nl>                  return 0; <nl>   <nl> +        /* Fail silently if the journal is not available */ <nl> +        if (errno == ENOENT) <nl> +                return 0; <nl> + <nl>          if (errno != EMSGSIZE && errno != ENOBUFS) <nl>                  return -errno; <nl>  
@@ -564,7 +564,7 @@ static void output_draw(Output *o, bool menu, term_screen *screen) { <nl>   */ <nl>   <nl>  static void terminal_dirty(Terminal *t) { <nl> -        uint64_t usec; <nl> +        usec_t usec; <nl>          int r; <nl>   <nl>          assert(t);
@@ -688,7 +688,8 @@ int calendar_spec_from_string(const char *p, CalendarSpec **spec) { <nl>                  if (r < 0) <nl>                          goto fail; <nl>   <nl> -        } else if (strcaseeq(p, "anually") || strcaseeq(p, "yearly")) { <nl> +        } else if (strcaseeq(p, "annually") || strcaseeq(p, "yearly") <nl> +                   || strcaseeq(p, "anually") /* backwards compatibility */ ) { <nl>                  r = const_chain(1, &c->month); <nl>                  if (r < 0) <nl>                          goto fail;
@@ -72,6 +72,8 @@ <nl>          "  <property name=\"Job\" type=\"(uo)\" access=\"read\"/>\n"    \ <nl>          "  <property name=\"RecursiveStop\" type=\"b\" access=\"read\"/>\n" \ <nl>          "  <property name=\"StopWhenUneeded\" type=\"b\" access=\"read\"/>\n" \ <nl> +        "  <property name=\"OnlyByDependency\" type=\"b\" access=\"read\"/>\n" \ <nl> +        "  <property name=\"DefaultDependencies\" type=\"b\" access=\"read\"/>\n" \ <nl>          "  <property name=\"DefaultControlGroup\" type=\"s\" access=\"read\"/>\n" \ <nl>          "  <property name=\"ControlGroups\" type=\"as\" access=\"read\"/>\n" \ <nl>          " </interface>\n" <nl> @@ -104,6 +106,8 @@ <nl>          { "org.freedesktop.systemd1.Unit", "Job",                  bus_unit_append_job,            "(uo)", u                                 }, \ <nl>          { "org.freedesktop.systemd1.Unit", "RecursiveStop",        bus_property_append_bool,       "b",    &u->meta.recursive_stop           }, \ <nl>          { "org.freedesktop.systemd1.Unit", "StopWhenUneeded",      bus_property_append_bool,       "b",    &u->meta.stop_when_unneeded       }, \ <nl> +        { "org.freedesktop.systemd1.Unit", "OnlyByDependency",     bus_property_append_bool,       "b",    &u->meta.only_by_dependency       }, \ <nl> +        { "org.freedesktop.systemd1.Unit", "DefaultDependencies",  bus_property_append_bool,       "b",    &u->meta.default_dependencies     }, \ <nl>          { "org.freedesktop.systemd1.Unit", "DefaultControlGroup",  bus_unit_append_default_cgroup, "s",    u                                 }, \ <nl>          { "org.freedesktop.systemd1.Unit", "ControlGroups",        bus_unit_append_cgroups,        "as",   u                                 } <nl>  
@@ -1829,6 +1829,7 @@ int main(int argc, char *argv[]) { <nl>  finish: <nl>          pager_close(); <nl>   <nl> +        arg_shutdown_watchdog = m->shutdown_watchdog; <nl>          m = manager_free(m); <nl>   <nl>          for (j = 0; j < ELEMENTSOF(arg_default_rlimit); j++) {
@@ -688,8 +688,11 @@ static int parse_date(const char **p, CalendarSpec *c) { <nl>                  c->month = first; <nl>                  c->day = second; <nl>                  return 0; <nl> -        } else if (c->end_of_month) <nl> +        } else if (c->end_of_month) { <nl> +                free_chain(first); <nl> +                free_chain(second); <nl>                  return -EINVAL; <nl> +        } <nl>   <nl>          if (*t == '~') <nl>                  c->end_of_month = true;
@@ -996,6 +996,10 @@ int config_parse_ipv6_route_preference(const char *unit, <nl>          _cleanup_route_free_ Route *n = NULL; <nl>          int r; <nl>   <nl> +        r = route_new_static(network, filename, section_line, &n); <nl> +        if (r < 0) <nl> +                return r; <nl> + <nl>          if (streq(rvalue, "low")) <nl>                  n->pref = ICMPV6_ROUTER_PREF_LOW; <nl>          else if (streq(rvalue, "medium"))
@@ -285,6 +285,9 @@ static int service_collect_fds(Service *s, int **fds, unsigned *n_fds) { <nl>                  p = manager_get_unit(UNIT(s)->meta.manager, k); <nl>                  free(k); <nl>   <nl> +                if (!p) <nl> +                        continue; <nl> + <nl>                  if ((r = socket_collect_fds(SOCKET(p), &cfds, &cn_fds)) < 0) <nl>                          goto fail; <nl>  
@@ -187,6 +187,7 @@ static int add_rtattr(sd_rtnl_message *m, unsigned short type, const void *data, <nl>          uint32_t rta_length, message_length; <nl>          struct nlmsghdr *new_hdr; <nl>          struct rtattr *rta; <nl> +        char *padding; <nl>   <nl>          assert_return(m, -EINVAL); <nl>          assert_return(m->hdr, -EINVAL); <nl> @@ -194,10 +195,9 @@ static int add_rtattr(sd_rtnl_message *m, unsigned short type, const void *data, <nl>          assert_return(data, -EINVAL); <nl>          assert_return(data_length > 0, -EINVAL); <nl>   <nl> -        /* get the size of the new rta attribute (without padding at the end) */ <nl> +        /* get the size of the new rta attribute (with padding at the end) */ <nl>          rta_length = RTA_LENGTH(data_length); <nl> -        /* get the new message size (with padding between the old message and the new attrib, <nl> -         * but no padding after) <nl> +        /* get the new message size (with padding at the end) <nl>           */ <nl>          message_length = m->hdr->nlmsg_len + RTA_ALIGN(rta_length); <nl>   <nl> @@ -218,7 +218,9 @@ static int add_rtattr(sd_rtnl_message *m, unsigned short type, const void *data, <nl>          /* we don't deal with the case where the user lies about the type and gives us <nl>           * too little data (so don't do that) <nl>           */ <nl> -        memcpy(RTA_DATA(rta), data, data_length); <nl> +        padding = mempcpy(RTA_DATA(rta), data, data_length); <nl> +        /* make sure also the padding at the end of the message is initialized */ <nl> +        memset(padding, '\0', (unsigned char *) m->hdr + m->hdr->nlmsg_len - (unsigned char *) padding); <nl>   <nl>          return 0; <nl>  }
@@ -209,9 +209,10 @@ int main(int argc, char *argv[], char *envp[]) <nl>  		} <nl>   <nl>  		/* run dev.d/ scripts if we created/deleted a node or changed a netif name */ <nl> -		if (udev_dev_d && udev.devname[0] != '\0') { <nl> +		if (udev.devname[0] != '\0') { <nl>  			setenv("DEVNAME", udev.devname, 1); <nl> -			udev_multiplex_directory(&udev, DEVD_DIR, DEVD_SUFFIX); <nl> +			if (udev_dev_d) <nl> +				udev_multiplex_directory(&udev, DEVD_DIR, DEVD_SUFFIX); <nl>  		} <nl>  	} else if ((strncmp(devpath, "/devices/", 9) == 0)) { <nl>  		if (strcmp(action, "add") == 0) {
@@ -173,6 +173,9 @@ static void set_trackpoint_sensitivity(struct udev_device *dev, const char *valu <nl>          if (r < 0) { <nl>                  log_error("Unable to parse POINTINGSTICK_SENSITIVITY '%s' for '%s'", value, udev_device_get_devnode(dev)); <nl>                  return; <nl> +        } else if (val_i < 0 || val_i > 255) { <nl> +                log_error("POINTINGSTICK_SENSITIVITY %d outside range [0..255] for '%s' ", val_i, udev_device_get_devnode(dev)); <nl> +                return; <nl>          } <nl>   <nl>          xsprintf(val_s, "%d", val_i);
@@ -4718,10 +4718,8 @@ gtk_xtext_append (xtext_buffer *buf, unsigned char *text, int len, time_t stamp) <nl>   <nl>  	ent = g_malloc (len + 1 + sizeof (textentry)); <nl>  	ent->str = (unsigned char *) ent + sizeof (textentry); <nl> -	ent->str_len = len; <nl> -	if (len) <nl> -		memcpy (ent->str, text, len); <nl> -	ent->str[len] = 0; <nl> +	safe_strcpy (ent->str, text, len); <nl> +	ent->str_len = strlen (ent->str); /* Possibly truncated */ <nl>  	ent->indent = 0; <nl>  	ent->left_len = -1; <nl>  
@@ -4042,7 +4042,12 @@ void main_deliver_fn ( <nl>  		log_printf (instance->totemsrp_log_level_security, "Received message is too short...  ignoring %d.\n", msg_len); <nl>  		return; <nl>  	} <nl> - <nl> +	 <nl> +	if ((int)message_header->type >= totemsrp_message_handlers.count) { <nl> +		log_printf (instance->totemsrp_log_level_security, "Type of received message is wrong...  ignoring %d.\n", (int)message_header->type); <nl> +		return; <nl> +	} <nl> +	 <nl>  	/* <nl>  	 * Handle incoming message <nl>  	 */
@@ -305,6 +305,10 @@ int _logsys_system_setup( <nl>  	 * Setup libqb as a subsys <nl>  	 */ <nl>  	i = _logsys_subsys_create ("QB", "array.c"); <nl> +	if (i < 0) { <nl> +		return -1; <nl> +	} <nl> + <nl>  	_logsys_subsys_filename_add (i, "log.c"); <nl>  	_logsys_subsys_filename_add (i, "log_syslog.c"); <nl>  	_logsys_subsys_filename_add (i, "log_blackbox.c");
@@ -166,6 +166,7 @@ static void unlink_all_completed (void) <nl>  	 * here <nl>  	 */ <nl>  	serialize_unlock (); <nl> +	api->timer_delete (corosync_stats_timer_handle); <nl>  	poll_stop (corosync_poll_handle); <nl>  	totempg_finalize (); <nl>  
@@ -237,7 +237,7 @@ ev_view_presentation_transition_start (EvViewPresentation *pview) <nl>   <nl>  	duration = ev_document_transition_get_page_duration (EV_DOCUMENT_TRANSITION (pview->document), <nl>  							     pview->current_page); <nl> -	if (duration > 0) { <nl> +	if (duration >= 0) { <nl>  		        pview->trans_timeout_id = <nl>  				g_timeout_add_seconds (duration, <nl>  						       (GSourceFunc) transition_next_page,
@@ -248,7 +248,6 @@ ev_document_load (EvDocument  *document, <nl>  		 */ <nl>  		priv->uri = g_strdup (uri); <nl>  		priv->n_pages = _ev_document_get_n_pages (document); <nl> -		priv->info = _ev_document_get_info (document); <nl>   <nl>  		for (i = 0; i < priv->n_pages; i++) { <nl>  			EvPage     *page = ev_document_get_page (document, i); <nl> @@ -312,6 +311,8 @@ ev_document_load (EvDocument  *document, <nl>   <nl>  			g_object_unref (page); <nl>  		} <nl> + <nl> +		priv->info = _ev_document_get_info (document); <nl>  	} <nl>   <nl>  	return retval;
@@ -857,6 +857,13 @@ load_thumbnail (const gchar *filename, <nl>    fseek (fp, 12, SEEK_SET); <nl>    /* read the number of chunks */ <nl>    ntoc = READ32 (fp, error) <nl> +  if (ntoc > (G_MAXINT32 / sizeof (guint32))) <nl> +    { <nl> +      g_set_error (error, 0, 0, <nl> +                   "'%s' seems to have an incorrect toc size.", <nl> +                   gimp_filename_to_utf8 (filename)); <nl> +      return -1; <nl> +    } <nl>    positions = g_malloc (ntoc * sizeof (guint32)); <nl>   <nl>    /* enter list of toc(table of contents) */
@@ -744,6 +744,8 @@ siox_cache_remove_fg (gpointer key, <nl>   * Initializes the SIOX segmentator. <nl>   * Creates and returns a SioxState struct that has to be passed to all <nl>   * function calls of this module as it maintaines the state. <nl> + * <nl> +'* Returns: a new siox state structure. <nl>   */ <nl>  SioxState * <nl>  siox_init (TileManager  *pixels, <nl> @@ -806,6 +808,8 @@ siox_init (TileManager  *pixels, <nl>   *               a good value is: { 0.64, 1.28, 2.56 } <nl>   * @smoothness:  boundary smoothness (a good value is 3) <nl>   * @multiblob:   allow multiple blobs (true) or only one (false) <nl> + * @progress_callback: a progress callback <nl> + * @progress_data: data passed to @progress_callback <nl>   * <nl>   * Writes the resulting segmentation into @mask. The region of <nl>   * interest as specified using @x1, @y1, @x2 and @y2 defines the
@@ -174,7 +174,7 @@ save_layer (const gchar    *filename, <nl>                                   gimp_filename_to_utf8(filename)); <nl>   <nl>        /* Attempt to open the output file */ <nl> -      if ((outfile = g_fopen (filename, "wb+")) == NULL) <nl> +      if ((outfile = g_fopen (filename, "w+b")) == NULL) <nl>          { <nl>            g_set_error (error, G_FILE_ERROR, <nl>                         g_file_error_from_errno (errno),
@@ -97,7 +97,7 @@ gimp_temp_buf_new_from_pixbuf (GdkPixbuf  *pixbuf, <nl>    if (gimp_pixbuf_get_format (pixbuf) != format) <nl>      fish = babl_fish (gimp_pixbuf_get_format (pixbuf), format); <nl>   <nl> -  for (i = 0; i < height; ++i) <nl> +  for (i = 0; i < height; i++) <nl>      { <nl>        if (fish) <nl>          babl_process (fish, pixels, data, width); <nl> @@ -320,7 +320,7 @@ gimp_temp_buf_create_pixbuf (GimpTempBuf *temp_buf) <nl>    if (format != gimp_pixbuf_get_format (pixbuf)) <nl>      fish = babl_fish (format, gimp_pixbuf_get_format (pixbuf)); <nl>   <nl> -  for (i = 0; i <= height; ++i) <nl> +  for (i = 0; i < height; i++) <nl>      { <nl>        if (fish) <nl>          babl_process (fish, data, pixels, width);
@@ -634,7 +634,7 @@ save_image (GFile   *file, <nl>                         "%u * %u * %u + 1];\n", <nl>                         width, <nl>                         height, <nl> -                       config->rgb565 ? 2 : (config->alpha ? 4 : 3))) <nl> +                       bpp)) <nl>              goto fail; <nl>          } <nl>   <nl> @@ -645,7 +645,7 @@ save_image (GFile   *file, <nl>                     "  %u, %u, %u,\n", <nl>                     width, <nl>                     height, <nl> -                   config->rgb565 ? 2 : (config->alpha ? 4 : 3))) <nl> +                   bpp)) <nl>          goto fail; <nl>      } <nl>    else /* use macros */ <nl> @@ -653,10 +653,10 @@ save_image (GFile   *file, <nl>        if (! print (output, error, <nl>                     "#define %s_WIDTH (%u)\n" <nl>                     "#define %s_HEIGHT (%u)\n" <nl> -                   "#define %s_BYTES_PER_PIXEL (%u) /* 3:RGB, 4:RGBA */\n", <nl> +                   "#define %s_BYTES_PER_PIXEL (%u) /* 2:RGB16, 3:RGB, 4:RGBA */\n", <nl>                     macro_name, width, <nl>                     macro_name, height, <nl> -                   macro_name, config->alpha ? 4 : 3)) <nl> +                   macro_name, bpp)) <nl>          { <nl>            goto fail; <nl>          } <nl> @@ -773,7 +773,7 @@ save_image (GFile   *file, <nl>                         "%u * %u * %u + 1] =\n", <nl>                         width, <nl>                         height, <nl> -                       config->alpha ? 4 : 3)) <nl> +                       bpp)) <nl>              goto fail; <nl>          } <nl>  
@@ -468,6 +468,16 @@ gimp_parallel_run_async_set_n_threads (gint n_threads) <nl>  { <nl>    gint i; <nl>   <nl> +  /* FIXME:  when the number of GEGL threads is 1, GEGL disables some thread- <nl> +   * safety mechanisms, such that, in particular, concurrent access to the same <nl> +   * buffer is not safe.  ultimately, it should be possible to configure GEGL <nl> +   * to remain thread-safe independently of the number of threads it uses, but <nl> +   * for now, we simply disable parallel asynchronous operations when the <nl> +   * number of threads is 1. <nl> +   */ <nl> +  if (n_threads == 1) <nl> +    n_threads = 0; <nl> + <nl>    n_threads = CLAMP (n_threads, 0, GIMP_PARALLEL_RUN_ASYNC_MAX_THREADS); <nl>   <nl>    if (n_threads > gimp_parallel_run_async_n_threads) /* need more threads */
@@ -139,7 +139,7 @@ gui_unique_win32_idle_open (IdleOpenData *data) <nl>    if (data->file) <nl>      { <nl>        file_open_from_command_line (unique_gimp, data->file, <nl> -                                   data->as_new, NULL, 0); <nl> +                                   data->as_new, NULL); <nl>      } <nl>    else <nl>      { <nl> @@ -249,7 +249,7 @@ gui_unique_quartz_idle_open (GFile *file) <nl>   <nl>    if (file) <nl>      { <nl> -      file_open_from_command_line (unique_gimp, file, FALSE, NULL, 0); <nl> +      file_open_from_command_line (unique_gimp, file, FALSE, NULL); <nl>      } <nl>   <nl>    return FALSE;
@@ -465,11 +465,11 @@ gimp_rectangle_select_tool_cursor_update (GimpTool         *tool, <nl>      { <nl>        gimp_tool_widget_get_cursor (private->widget, coords, state, <nl>                                     &cursor, NULL, &modifier); <nl> - <nl> -      gimp_tool_control_set_cursor          (tool->control, cursor); <nl> -      gimp_tool_control_set_cursor_modifier (tool->control, modifier); <nl>      } <nl>   <nl> +  gimp_tool_control_set_cursor          (tool->control, cursor); <nl> +  gimp_tool_control_set_cursor_modifier (tool->control, modifier); <nl> + <nl>    /* override the previous if shift or ctrl are down */ <nl>    if (state & (gimp_get_extend_selection_mask () | <nl>                 gimp_get_modify_selection_mask ()))
@@ -482,7 +482,7 @@ load_image (const gchar  *filename, <nl>    gint32 volatile image_ID = -1; <nl>    gint32          layer_ID; <nl>    int             fd;           /* File descriptor */ <nl> -  char            buf[BUFLEN];  /* buffer for random things like scanning */ <nl> +  char            buf[BUFLEN + 4];  /* buffer for random things like scanning */ <nl>    PNMInfo        *pnminfo; <nl>    PNMScanner * volatile scan; <nl>    int             ctr;
@@ -188,7 +188,7 @@ void *my_realloc(void *oldpoint, size_t size, myf my_flags) <nl>                           my_flags & MY_THREAD_SPECIFIC); <nl>      } <nl>      else <nl> -      update_malloc_size((longlong) (size - old_size), old_flags); <nl> +      update_malloc_size((longlong)size - (longlong)old_size, old_flags); <nl>    } <nl>   <nl>    DBUG_PRINT("exit",("ptr: %p", point));
@@ -376,6 +376,9 @@ sys_var_thd_table_type  sys_table_type("table_type", <nl>  				       &SV::table_type); <nl>  sys_var_thd_storage_engine sys_storage_engine("storage_engine", <nl>  				       &SV::table_type); <nl> +#ifdef HAVE_REPLICATION <nl> +sys_var_sync_binlog_period sys_sync_binlog_period("sync_binlog", &sync_binlog_period); <nl> +#endif <nl>  sys_var_bool_ptr	sys_sync_frm("sync_frm", &opt_sync_frm); <nl>  sys_var_long_ptr	sys_table_cache_size("table_cache", <nl>  					     &table_cache_size); <nl> @@ -697,6 +700,9 @@ sys_var *sys_variables[]= <nl>    &sys_sql_warnings, <nl>    &sys_sql_notes, <nl>    &sys_storage_engine, <nl> +#ifdef HAVE_REPLICATION <nl> +  &sys_sync_binlog_period, <nl> +#endif <nl>    &sys_sync_frm, <nl>    &sys_table_cache_size, <nl>    &sys_table_lock_wait_timeout, <nl> @@ -992,6 +998,9 @@ struct show_var_st init_vars[]= { <nl>    {"sql_notes",               (char*) &sys_sql_notes,               SHOW_BOOL}, <nl>    {"sql_warnings",            (char*) &sys_sql_warnings,            SHOW_BOOL}, <nl>    {sys_storage_engine.name,   (char*) &sys_storage_engine,          SHOW_SYS}, <nl> +#ifdef HAVE_REPLICATION <nl> +  {sys_sync_binlog_period.name,(char*) &sys_sync_binlog_period,     SHOW_SYS}, <nl> +#endif <nl>    {sys_sync_frm.name,         (char*) &sys_sync_frm,               SHOW_SYS}, <nl>  #ifdef HAVE_TZNAME <nl>    {"system_time_zone",        system_time_zone,                     SHOW_CHAR},
@@ -175,7 +175,7 @@ _rl_fix_last_undo_of_type (type, start, end) <nl>   <nl>    for (rl = rl_undo_list; rl; rl = rl->next) <nl>      { <nl> -      if (rl->what == (uint) type) <nl> +      if (rl->what == (unsigned int) type) <nl>  	{ <nl>  	  rl->start = start; <nl>  	  rl->end = end;
@@ -804,7 +804,6 @@ void plugin_shutdown(void) <nl>      struct st_plugin_int *tmp= dynamic_element(&plugin_array, i, <nl>                                                 struct st_plugin_int *); <nl>      plugin_deinitialize(tmp); <nl> -    plugin_del(tmp); <nl>   <nl>    } <nl>  
@@ -1422,6 +1422,7 @@ mysql_init(MYSQL *mysql) <nl>      bzero((char*) (mysql),sizeof(*(mysql))); <nl>    mysql->options.connect_timeout= CONNECT_TIMEOUT; <nl>    mysql->last_used_con= mysql->next_slave= mysql->master = mysql; <nl> +  mysql->charset=default_charset_info; <nl>    strmov(mysql->net.sqlstate, not_error_sqlstate); <nl>    /* <nl>      By default, we are a replication pivot. The caller must reset it
@@ -588,6 +588,11 @@ ulong acl_getroot(THD *thd, const char *host, const char *ip, const char *user, <nl>  	      /* Prepare certificate (if exists) */ <nl>  	      DBUG_PRINT("info",("checkpoint 1")); <nl>  	      X509* cert=SSL_get_peer_certificate(ssl); <nl> +	      if (!cert) <nl> +	      { <nl> +		user_access=NO_ACCESS; <nl> +		break; <nl> +	      } <nl>  	      DBUG_PRINT("info",("checkpoint 2")); <nl>  	      /* If X509 issuer is speified, we check it... */ <nl>  	      if (acl_user->x509_issuer)
@@ -47,7 +47,7 @@ my_bool _hash_init(HASH *hash, CHARSET_INFO *charset, <nl>  		   uint key_length, hash_get_key get_key, <nl>  		   void (*free_element)(void*), uint flags CALLER_INFO_PROTO); <nl>  void hash_free(HASH *tree); <nl> -void hash_reset(HASH *hash); <nl> +void my_hash_reset(HASH *hash); <nl>  byte *hash_element(HASH *hash,uint idx); <nl>  gptr hash_search(HASH *info,const byte *key,uint length); <nl>  gptr hash_next(HASH *info,const byte *key,uint length);
@@ -286,7 +286,7 @@ garbage_helper(BLOCKNUM b, int64_t UU(size), int64_t UU(address), void *extra) { <nl>      fill_bfe_for_full_read(&bfe, info->h); <nl>      int r = toku_deserialize_brtnode_from(info->f, b, 0, &n, &bfe); <nl>      if (r != 0) { <nl> -        goto exit; <nl> +        goto no_node; <nl>      } <nl>      if (n->height > 0) { <nl>          goto exit; <nl> @@ -299,6 +299,8 @@ garbage_helper(BLOCKNUM b, int64_t UU(size), int64_t UU(address), void *extra) { <nl>          } <nl>      } <nl>  exit: <nl> +    toku_brtnode_free(&n); <nl> +no_node: <nl>      return r; <nl>  } <nl>  
@@ -1,5 +1,5 @@ <nl>  /* <nl> -   Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved. <nl> +   Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved. <nl>   <nl>     This program is free software; you can redistribute it and/or modify <nl>     it under the terms of the GNU General Public License as published by <nl> @@ -216,7 +216,10 @@ ha_rows filesort(THD *thd, TABLE *table, SORT_FIELD *sortorder, uint s_length, <nl>      goto err; <nl>   <nl>    memavl= thd->variables.sortbuff_size; <nl> -  min_sort_memory= max(MIN_SORT_MEMORY, param.sort_length*MERGEBUFF2); <nl> +  min_sort_memory= <nl> +    max(MIN_SORT_MEMORY, <nl> +        ALIGN_SIZE(MERGEBUFF2 * (param.rec_length + sizeof(uchar*)))); <nl> + <nl>    while (memavl >= min_sort_memory) <nl>    { <nl>      ulong old_memavl;
@@ -386,6 +386,13 @@ create_worker_threads(uint n) <nl>  	return threads; <nl>   <nl>  err: <nl> +	while (i > 0) { <nl> +		comp_thread_ctxt_t *thd; <nl> +		i--; <nl> +		thd = threads + i; <nl> +		pthread_mutex_unlock(&thd->ctrl_mutex); <nl> +	} <nl> + <nl>  	my_free(threads); <nl>  	return NULL; <nl>  }
@@ -936,8 +936,8 @@ bool login_connection(THD *thd) <nl>    net->no_send_error= 0; <nl>   <nl>    /* Use "connect_timeout" value during connection phase */ <nl> -  net_set_read_timeout(net, connect_timeout); <nl> -  net_set_write_timeout(net, connect_timeout); <nl> +  my_net_set_read_timeout(net, connect_timeout); <nl> +  my_net_set_write_timeout(net, connect_timeout); <nl>   <nl>    if ((error=check_connection(thd))) <nl>    {						// Wrong permissions <nl> @@ -951,8 +951,8 @@ bool login_connection(THD *thd) <nl>      DBUG_RETURN(1); <nl>    } <nl>    /* Connect completed, set read/write timeouts back to default */ <nl> -  net_set_read_timeout(net, thd->variables.net_read_timeout); <nl> -  net_set_write_timeout(net, thd->variables.net_write_timeout); <nl> +  my_net_set_read_timeout(net, thd->variables.net_read_timeout); <nl> +  my_net_set_write_timeout(net, thd->variables.net_write_timeout); <nl>    DBUG_RETURN(0); <nl>  } <nl>  
@@ -37,7 +37,11 @@ class Field <nl>    void operator=(Field &); <nl>  public: <nl>    static void *operator new(size_t size) {return (void*) sql_alloc((uint) size); } <nl> -  static void operator delete(void *ptr_arg, size_t size) {} /*lint -e715 */ <nl> +  static void operator delete(void *ptr_arg, size_t size) { <nl> +#ifdef PEDANTIC_SAFEMALLOC <nl> +    bfill(ptr_arg, size, 0x8F); <nl> +#endif <nl> +  } <nl>   <nl>    char		*ptr;			// Position to field in record <nl>    uchar		*null_ptr;		// Byte where null_bit is
@@ -56,13 +56,14 @@ base64_encode(const void *src, size_t src_len, char *dst) <nl>   <nl>    for (; i < src_len; len += 4) <nl>    { <nl> +    unsigned c; <nl> + <nl>      if (len == 76) <nl>      { <nl>        len= 0; <nl>        *dst++= '\n'; <nl>      } <nl>   <nl> -    unsigned c; <nl>      c= s[i++]; <nl>      c <<= 8; <nl>   <nl> @@ -216,6 +217,8 @@ main(void) <nl>   <nl>      char * src= (char *) malloc(src_len); <nl>      char * s= src; <nl> +    char * str; <nl> +    char * dst; <nl>   <nl>      for (j= 0; j<src_len; j++) <nl>      { <nl> @@ -224,11 +227,11 @@ main(void) <nl>      } <nl>   <nl>      /* Encode */ <nl> -    char * str= (char *) malloc(base64_needed_encoded_length(src_len)); <nl> +    str= (char *) malloc(base64_needed_encoded_length(src_len)); <nl>      require(base64_encode(src, src_len, str) == 0); <nl>   <nl>      /* Decode */ <nl> -    char * dst= (char *) malloc(base64_needed_decoded_length(strlen(str))); <nl> +    dst= (char *) malloc(base64_needed_decoded_length(strlen(str))); <nl>      dst_len= base64_decode(str, strlen(str), dst); <nl>      require(dst_len == src_len); <nl>  
@@ -336,6 +336,11 @@ int mysql_load(THD *thd,sql_exchange *ex,TABLE_LIST *table_list, <nl>      } <nl>      else <nl>      { <nl> +      /* <nl> +        As already explained above, we need to call end_io_cache() or the last <nl> +        block will be logged only after Execute_load_log_event (which is wrong), <nl> +        when read_info is destroyed. <nl> +      */ <nl>        read_info.end_io_cache();  <nl>        if (lf_info.wrote_create_file) <nl>        {
@@ -2722,9 +2722,9 @@ static int get_schema_tables_record(THD *thd, struct st_table_list *tables, <nl>                    ha_row_type[(uint) share->row_type], <nl>                    NullS); <nl>  #ifdef WITH_PARTITION_STORAGE_ENGINE <nl> -    if (share->db_type == &partition_hton && <nl> -        share->partition_info != NULL &&  <nl> -        ((partition_info*)share->partition_info)->no_parts > 0) <nl> +    if (show_table->s->db_type == &partition_hton &&  <nl> +        show_table->part_info != NULL &&  <nl> +        show_table->part_info->no_parts > 0) <nl>        ptr= strmov(ptr, " partitioned"); <nl>  #endif <nl>      table->field[19]->store(option_buff+1,
@@ -128,7 +128,12 @@ bool Item_subselect::fix_fields(THD *thd_param, TABLE_LIST *tables, Item **ref) <nl>    stmt= thd->current_statement; <nl>   <nl>    char const *save_where= thd->where; <nl> -  int res= engine->prepare(); <nl> +  int res; <nl> + <nl> +  if (check_stack_overrun(thd, (gptr)&res)) <nl> +    return 1; <nl> + <nl> +  res= engine->prepare(); <nl>   <nl>    // all transformetion is done (used by prepared statements) <nl>    changed= 1;
@@ -8600,6 +8600,9 @@ ha_innobase::check( <nl>  					    (ulong) n_rows, <nl>  					    (ulong) n_rows_in_table); <nl>  			is_ok = FALSE; <nl> +			row_mysql_lock_data_dictionary(prebuilt->trx); <nl> +			dict_set_corrupted(index); <nl> +			row_mysql_unlock_data_dictionary(prebuilt->trx); <nl>  		} <nl>  	} <nl>  
@@ -30,6 +30,7 @@ <nl>   <nl>  #include <stdio.h> <nl>  #include <stdlib.h> <nl> +#include <assert.h> <nl>  #include "ihdrbox_manager.h" <nl>   <nl>  ihdrbox_param_t * gene_ihdrbox( metadatalist_param_t *metadatalist, Byte_t *jpipstream) <nl> @@ -37,6 +38,7 @@ ihdrbox_param_t * gene_ihdrbox( metadatalist_param_t *metadatalist, Byte_t *jpip <nl>    ihdrbox_param_t *ihdrbox; <nl>    metadata_param_t *meta; <nl>    box_param_t *jp2h, *ihdr; <nl> +  int bpc_val; <nl>     <nl>    jp2h = NULL; <nl>    meta = metadatalist->first; <nl> @@ -65,7 +67,9 @@ ihdrbox_param_t * gene_ihdrbox( metadatalist_param_t *metadatalist, Byte_t *jpip <nl>    ihdrbox->height = big4( jpipstream+get_DBoxoff(ihdr)); <nl>    ihdrbox->width  = big4( jpipstream+get_DBoxoff(ihdr)+4); <nl>    ihdrbox->nc     = big2( jpipstream+get_DBoxoff(ihdr)+8); <nl> -  ihdrbox->bpc    = *(jpipstream+get_DBoxoff(ihdr)+10)+1; <nl> +  bpc_val = *(jpipstream+get_DBoxoff(ihdr)+10)+1; <nl> +  assert( bpc_val >= 0 && bpc_val <= 255 ); <nl> +  ihdrbox->bpc    = (Byte_t)bpc_val; <nl>   <nl>    free( ihdr); <nl>  
@@ -256,12 +256,16 @@ void OPJ_CALLCONV opj_stream_set_skip_function(opj_stream_t* p_stream, opj_strea <nl>  void OPJ_CALLCONV opj_stream_set_user_data(opj_stream_t* p_stream, void * p_data) <nl>  { <nl>  	opj_stream_private_t* l_stream = (opj_stream_private_t*) p_stream; <nl> +	if (!l_stream) <nl> +		return; <nl>  	l_stream->m_user_data = p_data; <nl>  } <nl>   <nl>  void OPJ_CALLCONV opj_stream_set_user_data_length(opj_stream_t* p_stream, OPJ_UINT64 data_length) <nl>  { <nl>  	opj_stream_private_t* l_stream = (opj_stream_private_t*) p_stream; <nl> +	if (!l_stream) <nl> +		return; <nl>  	l_stream->m_user_data_length = data_length; <nl>  } <nl>  
@@ -25,13 +25,18 @@ <nl>   * POSSIBILITY OF SUCH DAMAGE. <nl>   */ <nl>   <nl> +#ifndef __JPIP_H <nl> +#define __JPIP_H <nl> + <nl>  #include "j2k.h" <nl>   <nl>  // Codestream index box (superbox) <nl> -int jpip_write_cidx(int offset, info_image_t img, j2k_cp_t *j2k_cp); <nl> +int jpip_write_cidx(int offset, info_image_t img, j2k_cp_t *j2k_cp, int version); <nl>   <nl>  // Index Finder Box <nl>  void jpip_write_iptr(int offset, int length); <nl>   <nl>  // File Index Box <nl>  int jpip_write_fidx(int offset_jp2c, int length_jp2c, int offset_idx, int length_idx); <nl> + <nl> +#endif
@@ -101,6 +101,8 @@ router_reload_networkstatus(void) <nl>    entries = tor_listdir(filename); <nl>    SMARTLIST_FOREACH(entries, const char *, fn, { <nl>        char buf[DIGEST_LEN]; <nl> +      if (fn[0] == '.') /* skip . and .. */ <nl> +        continue; <nl>        if (strlen(fn) != HEX_DIGEST_LEN || <nl>            base16_decode(buf, sizeof(buf), fn, strlen(fn))) { <nl>          log_fn(LOG_INFO,
@@ -2270,10 +2270,14 @@ check_private_dir,(const char *dirname, cpd_check_t check, <nl>         * permissions on the directory will be checked again below.*/ <nl>        fd = open(sandbox_intern_string(dirname), O_NOFOLLOW); <nl>   <nl> -      if (fd == -1) <nl> +      if (fd == -1) { <nl> +        log_warn(LD_FS, "Could not reopen recently created directory %s: %s", <nl> +                 dirname, <nl> +                 strerror(errno)); <nl>          return -1; <nl> -      else <nl> +      } else { <nl>          close(fd); <nl> +      } <nl>   <nl>      } else if (!(check & CPD_CHECK)) { <nl>        log_warn(LD_FS, "Directory %s does not exist.", dirname);
@@ -646,6 +646,12 @@ client_get_random_intro(const ed25519_public_key_t *service_pk) <nl>        /* If this pick is in the ExcludeNodes list, we keep its reference so if <nl>         * we ever end up not being able to pick anything else and StrictNodes is <nl>         * unset, we'll use it. */ <nl> +      if (ei_excluded) { <nl> +        /* If something was already here free it. After the loop is gone we <nl> +         * will examine the last excluded intro point, and that's fine since <nl> +         * that's random anyway */ <nl> +        extend_info_free(ei_excluded); <nl> +      } <nl>        ei_excluded = ei; <nl>        continue; <nl>      } <nl> @@ -662,6 +668,7 @@ client_get_random_intro(const ed25519_public_key_t *service_pk) <nl>    if (options->StrictNodes) { <nl>      log_warn(LD_REND, "Every introduction points are in the ExcludeNodes set " <nl>               "and StrictNodes is set. We can't connect."); <nl> +    extend_info_free(ei); <nl>      ei = NULL; <nl>    } <nl>  
@@ -1297,7 +1297,8 @@ connection_edge_process_relay_cell(cell_t *cell, circuit_t *circ, <nl>                 "Begin cell for known stream. Dropping."); <nl>          return 0; <nl>        } <nl> -      if (rh.command == RELAY_COMMAND_BEGIN_DIR) { <nl> +      if (rh.command == RELAY_COMMAND_BEGIN_DIR && <nl> +          circ->purpose != CIRCUIT_PURPOSE_S_REND_JOINED) { <nl>          /* Assign this circuit and its app-ward OR connection a unique ID, <nl>           * so that we can measure download times. The local edge and dir <nl>           * connection will be assigned the same ID when they are created
@@ -1318,7 +1318,8 @@ tor_tls_got_client_hello(tor_tls_t *tls) <nl>      } <nl>   <nl>      tls->got_renegotiate = 1; <nl> -  } else if (tls->server_handshake_count > 2) { <nl> +  } else if (tls->server_handshake_count > 2 && <nl> +             tls->excess_renegotiations_callback) { <nl>      /* We got more than one renegotiation requests. The Tor protocol <nl>         needs just one renegotiation; more than that probably means <nl>         They are trying to DoS us and we have to stop them. We can't
@@ -1719,6 +1719,7 @@ config_dump(config_format_t *fmt, void *options, int minimal) <nl>    result = smartlist_join_strings(elements, "", 0, NULL); <nl>    SMARTLIST_FOREACH(elements, char *, cp, tor_free(cp)); <nl>    smartlist_free(elements); <nl> +  config_free(fmt, defaults); <nl>    return result; <nl>  } <nl>  
@@ -4015,15 +4015,13 @@ control_event_conf_changed(smartlist_t *elements) <nl>    for (i = 0; i < smartlist_len(elements); i += 2) { <nl>      char *k = smartlist_get(elements, i); <nl>      char *v = smartlist_get(elements, i+1); <nl> +    char *tmp; <nl>      if (v == NULL) { <nl> -      char *tmp; <nl>        tor_asprintf(&tmp, "650-%s", k); <nl> -      smartlist_add(lines, tmp); <nl>      } else { <nl> -      char *tmp; <nl>        tor_asprintf(&tmp, "650-%s=%s", k, v); <nl> -      smartlist_add(lines, tmp); <nl>      } <nl> +    smartlist_add(lines, tmp); <nl>    } <nl>    result = smartlist_join_strings(lines, "\r\n", 0, NULL); <nl>    send_control_event(EVENT_CONF_CHANGED, 0,
@@ -641,7 +641,7 @@ hibernate_hard_limit_reached(void) <nl>   * to send/receive this interval. */ <nl>  static int hibernate_soft_limit_reached(void) <nl>  { <nl> -  uint64_t soft_limit = (uint64_t) ((get_options()->AccountingMax) * .99); <nl> +  uint64_t soft_limit = (uint64_t) ((get_options()->AccountingMax) * .95); <nl>    if (!soft_limit) <nl>      return 0; <nl>    return n_bytes_read_in_interval >= soft_limit
@@ -1094,6 +1094,7 @@ static int parse_redirect_line(or_options_t *options, <nl>    tor_assert(line); <nl>   <nl>    r = tor_malloc_zero(sizeof(exit_redirect_t)); <nl> +  elements = smartlist_create(); <nl>    smartlist_split_string(elements, line->value, " ", <nl>                           SPLIT_SKIP_SPACE|SPLIT_IGNORE_BLANK, 0); <nl>    if (smartlist_len(elements) != 2) {
@@ -260,7 +260,7 @@ get_recommended_software_from_directory(const char *str) <nl>        /* We belong to a series with recommended members, and we are newer than <nl>         * any recommended member. We're probably okay. */ <nl>        if (!warned_too_new) { <nl> -        log(LOG_WARN, "This version of Tor (%s) is newer than any in the same series on the reccomended list (%s)", <nl> +        log(LOG_WARN, "This version of Tor (%s) is newer than any in the same series on the recommended list (%s)", <nl>              myversion, versionlist); <nl>          warned_too_new = 1; <nl>        } <nl> @@ -281,7 +281,7 @@ get_recommended_software_from_directory(const char *str) <nl>        /* We belong to a series with no recommended members, and it's <nl>         * newer than any recommended series. We're probably okay. */ <nl>        if (!warned_too_new) { <nl> -        log(LOG_WARN, "This version of Tor (%s) is newer than any on the reccomended list (%s)", <nl> +        log(LOG_WARN, "This version of Tor (%s) is newer than any on the recommended list (%s)", <nl>              myversion, versionlist); <nl>          warned_too_new = 1; <nl>        }
@@ -771,12 +771,9 @@ extended_cell_parse(extended_cell_t *cell_out, <nl>                      const uint8_t command, const uint8_t *payload, <nl>                      size_t payload_len) <nl>  { <nl> -  const uint8_t *eop; <nl> - <nl>    memset(cell_out, 0, sizeof(*cell_out)); <nl>    if (payload_len > RELAY_PAYLOAD_SIZE) <nl>      return -1; <nl> -  eop = payload + payload_len; <nl>   <nl>    switch (command) { <nl>    case RELAY_COMMAND_EXTENDED: <nl> @@ -970,12 +967,11 @@ int <nl>  extended_cell_format(uint8_t *command_out, uint16_t *len_out, <nl>                       uint8_t *payload_out, const extended_cell_t *cell_in) <nl>  { <nl> -  uint8_t *p, *eop; <nl> +  uint8_t *p; <nl>    if (check_extended_cell(cell_in) < 0) <nl>      return -1; <nl>   <nl>    p = payload_out; <nl> -  eop = payload_out + RELAY_PAYLOAD_SIZE; <nl>    memset(p, 0, RELAY_PAYLOAD_SIZE); <nl>   <nl>    switch (cell_in->cell_type) { <nl> @@ -992,6 +988,8 @@ extended_cell_format(uint8_t *command_out, uint16_t *len_out, <nl>        *command_out = RELAY_COMMAND_EXTENDED2; <nl>        *len_out = 2 + cell_in->created_cell.handshake_len; <nl>        set_uint16(payload_out, htons(cell_in->created_cell.handshake_len)); <nl> +      if (2+cell_in->created_cell.handshake_len > RELAY_PAYLOAD_SIZE) <nl> +        return -1; <nl>        memcpy(payload_out+2, cell_in->created_cell.reply, <nl>               cell_in->created_cell.handshake_len); <nl>      }
@@ -55,6 +55,8 @@ public: <nl>  	/// \since Crypto++ 6.0 <nl>  #if defined(CRYPTOPP_DOXYGEN_PROCESSING) <nl>  	static const size_type ELEMS_MAX = ...; <nl> +#elif defined(_MSC_VER) && (_MSC_VER <= 1400) <nl> +	static const size_type ELEMS_MAX = (~(size_type)0)/sizeof(T); <nl>  #elif defined(CRYPTOPP_CXX11_ENUM) <nl>  	enum : size_type {ELEMS_MAX = SIZE_MAX/sizeof(T)}; <nl>  #else <nl> @@ -501,6 +503,8 @@ public: <nl>  	/// \since Crypto++ 6.0 <nl>  #if defined(CRYPTOPP_DOXYGEN_PROCESSING) <nl>  	static const size_type ELEMS_MAX = ...; <nl> +#elif defined(_MSC_VER) && (_MSC_VER <= 1400) <nl> +	static const size_type ELEMS_MAX = (~(size_type)0)/sizeof(T); <nl>  #elif defined(CRYPTOPP_CXX11_ENUM) <nl>  	enum : size_type {ELEMS_MAX = A::ELEMS_MAX}; <nl>  #else
@@ -19,6 +19,8 @@ NAMESPACE_BEGIN(CryptoPP) <nl>  RandomPool::RandomPool() <nl>  	: m_pCipher(new AES::Encryption), m_keySet(false) <nl>  { <nl> +	memset(m_key, 0, m_key.SizeInBytes()); <nl> +	memset(m_seed, 0, m_seed.SizeInBytes()); <nl>  } <nl>   <nl>  void RandomPool::IncorporateEntropy(const byte *input, size_t length)
@@ -844,7 +844,9 @@ size_t jsuGetFreeStack() { <nl>    char ptr; // this is on the stack <nl>    extern void *STACK_BASE; <nl>    uint32_t count =  (uint32_t)((size_t)STACK_BASE - (size_t)&ptr); <nl> -  return 1000000 - count; // give it 1 megabyte of stack <nl> +  const uint32_t max_stack = 1000000; // give it 1 megabyte of stack <nl> +  if (count>max_stack) return 0; <nl> +  return max_stack - count; <nl>  #else <nl>    // stack depth seems pretty platform-specific :( Default to a value that disables it <nl>    return 1000000; // no stack depth check on this platform
@@ -232,7 +232,7 @@ slurmd_task_info_t * task_info_create(int taskid, int gtaskid, <nl>  static inline slurmd_task_info_t * <nl>  job_task_info_by_pid (slurmd_job_t *job, pid_t pid) <nl>  { <nl> -	int i; <nl> +	uint32_t i; <nl>  	for (i = 0; i < job->node_tasks; i++) { <nl>  		if (job->task[i]->pid == pid) <nl>  			return (job->task[i]);
@@ -1419,9 +1419,9 @@ static int _move_account(mysql_conn_t *mysql_conn, uint32_t lft, uint32_t rgt, <nl>  	} <nl>  	xfree(query); <nl>  	if(!(row = mysql_fetch_row(result))) { <nl> -		error("no row"); <nl> +		debug4("Can't move a none existant association"); <nl>  		mysql_free_result(result); <nl> -		return SLURM_ERROR; <nl> +		return SLURM_SUCCESS; <nl>  	} <nl>  	par_left = atoi(row[0]); <nl>  	mysql_free_result(result);
@@ -1157,8 +1157,9 @@ static int _task_layout_lllp_block(launch_tasks_request_msg_t *req, <nl>  				continue; <nl>   <nl>  			sock_inx = i / pu_per_socket; <nl> -			if (socket_tasks[sock_inx] >= req->ntasks_per_socket) <nl> -				continue;  /* Default ntasks_per_socket = INFINITE */ <nl> +			if ((req->ntasks_per_socket != 0) && <nl> +			    (socket_tasks[sock_inx] >= req->ntasks_per_socket)) <nl> +				continue; <nl>  			socket_tasks[sock_inx]++; <nl>   <nl>  			if (!masks[taskcount]) <nl> @@ -1196,6 +1197,8 @@ static int _task_layout_lllp_block(launch_tasks_request_msg_t *req, <nl>  			if (++taskcount >= max_tasks) <nl>  				break; <nl>  		} <nl> +		for (i = 0; i < hw_sockets; i++) <nl> +			socket_tasks[i] = 0; <nl>  	} <nl>  	xfree(socket_tasks); <nl>  
@@ -1549,6 +1549,11 @@ extern int fed_mgr_job_allocate(slurm_msg_t *msg, job_desc_msg_t *job_desc, <nl>  	 * _sib_will_run */ <nl>  	start_now_sib = _find_start_now_sib(msg, job_desc, uid, &avail_sibs); <nl>   <nl> +	if (!avail_sibs) { <nl> +		debug("No cluster responded to sibling will_runs, submitting to self"); <nl> +		avail_sibs = FED_SIBLING_BIT(fed_mgr_cluster_rec->fed.id); <nl> +	} <nl> + <nl>  	if (start_now_sib == NULL) { <nl>  		job_desc->fed_siblings = avail_sibs; <nl>  	} else if (start_now_sib == fed_mgr_cluster_rec) {
@@ -968,7 +968,11 @@ static int _connect_srun_cr(char *addr) <nl>  	unsigned int sa_len; <nl>  	int fd, rc; <nl>   <nl> -	if (addr && (strlen(addr) > sizeof(sa.sun_path))) { <nl> +	if (!addr) { <nl> +		error("%s: socket path name is NULL", __func__); <nl> +		return -1; <nl> +	} <nl> +	if (strlen(addr) >= sizeof(sa.sun_path)) { <nl>  		error("%s: socket path name too long (%s)", __func__, addr); <nl>  		return -1; <nl>  	}
@@ -58,6 +58,8 @@ job_info_to_hv(job_info_t* job_info, HV* hv) <nl>  	STORE_FIELD(hv, job_info, job_state, uint16_t); <nl>  	if(job_info->licenses) <nl>  		STORE_FIELD(hv, job_info, licenses, charp); <nl> +	if(job_info->max_cpus) <nl> +		STORE_FIELD(hv, job_info, max_cpus, charp); <nl>  	STORE_FIELD(hv, job_info, max_nodes, uint32_t); <nl>  	STORE_FIELD(hv, job_info, min_cores, uint16_t); <nl>  	STORE_FIELD(hv, job_info, min_sockets, uint16_t); <nl> @@ -120,6 +122,8 @@ job_info_to_hv(job_info_t* job_info, HV* hv) <nl>  	STORE_FIELD(hv, job_info, submit_time, time_t); <nl>  	STORE_FIELD(hv, job_info, suspend_time, time_t); <nl>  	STORE_FIELD(hv, job_info, time_limit, uint32_t); <nl> +	if(job_info->time_min) <nl> +		STORE_FIELD(hv, job_info, time_min, uint32_t); <nl>  	STORE_FIELD(hv, job_info, user_id, uint32_t); <nl>  	if(job_info->wckey) <nl>  		STORE_FIELD(hv, job_info, wckey, charp);
@@ -258,6 +258,8 @@ main (int argc, char *argv[]) <nl>   <nl>  	_slurmd_fini(); <nl>  	_destroy_conf(); <nl> +	slurm_crypto_fini();	/* must be after _destroy_conf() */ <nl> + <nl>  	info("Slurmd shutdown completing"); <nl>  	log_fini(); <nl>         	return 0; <nl> @@ -1034,7 +1036,6 @@ _slurmd_fini() <nl>  	slurm_conf_destroy(); <nl>  	slurm_proctrack_fini(); <nl>  	slurm_auth_fini(); <nl> -	slurm_crypto_fini(); <nl>  	slurmd_req(NULL);	/* purge memory allocated by slurmd_req() */ <nl>  	return SLURM_SUCCESS; <nl>  }
@@ -1041,7 +1041,7 @@ static int _load_job_state(Buf buffer) <nl>  			jobacct_storage_g_job_complete(acct_db_conn, job_ptr); <nl>  	} <nl>   <nl> -	if(job_ptr->qos) { <nl> +	if(job_ptr->qos && (accounting_enforce & ACCOUNTING_ENFORCE_ASSOCS)) { <nl>  		memset(&qos_rec, 0, sizeof(acct_qos_rec_t)); <nl>  		qos_rec.id = job_ptr->qos; <nl>  		if(_determine_and_validate_qos(job_ptr, &qos_rec)
@@ -1166,7 +1166,7 @@ extern char *ba_set_ionode_str(bitstr_t *ionode_bitmap) <nl>  		if (hl) { <nl>  			ionode_str = hostlist_ranged_string_xmalloc_dims( <nl>  				hl, 5, 0); <nl> -			info("iostring is %s", ionode_str); <nl> +			//info("iostring is %s", ionode_str); <nl>  			hostlist_destroy(hl); <nl>  			hl = NULL; <nl>  		}
@@ -4115,7 +4115,7 @@ extern int job_allocate(job_desc_msg_t * job_specs, int immediate, <nl>  { <nl>  	static time_t sched_update = 0; <nl>  	static int defer_sched = 0; <nl> -	char *key, *sched_params, *tmp_ptr; <nl> +	char *sched_params, *tmp_ptr; <nl>  	int error_code, i; <nl>  	bool no_alloc, top_prio, test_only, too_fragmented, independent; <nl>  	struct job_record *job_ptr; <nl> @@ -4128,9 +4128,9 @@ extern int job_allocate(job_desc_msg_t * job_specs, int immediate, <nl>  			defer_sched = 1; <nl>  		else <nl>  			defer_sched = 0; <nl> -		key = strstr(sched_params, "delay_boot="); <nl> -		if (key) { <nl> -			i = time_str2secs(key + 11); <nl> +		if (sched_params && <nl> +		    (tmp_ptr = strstr(sched_params, "delay_boot="))) { <nl> +			i = time_str2secs(tmp_ptr + 11); <nl>  			if (i != NO_VAL) <nl>  				delay_boot = i; <nl>  		}
@@ -574,6 +574,12 @@ extern void addto_qos_char_list(List char_list, List qos_list, char *names) <nl>  			bad: <nl>  				i++; <nl>  				start = i; <nl> +				if(!names[i]) { <nl> +					info("There is a problem with " <nl> +					     "your line.  It appears you " <nl> +					     "have spaces inside your list."); <nl> +					break; <nl> +				} <nl>  			} <nl>  			i++; <nl>  		}
@@ -2018,6 +2018,14 @@ static void *_agent(void *x) <nl>  			free_buf(buffer); <nl>  			fail_time = 0; <nl>  		} else { <nl> +			/* We still need to free a mult_msg even if we <nl> +			   got a failure. <nl> +			*/ <nl> +			if(list_msg.my_list) { <nl> +				list_msg.my_list = NULL; <nl> +				free_buf(buffer); <nl> +			} <nl> + <nl>  			fail_time = time(NULL); <nl>  		} <nl>  		slurm_mutex_unlock(&agent_lock);
@@ -88,7 +88,7 @@ static uint32_t _update_weighted_freq(struct jobacctinfo *jobacct, <nl>  	jobacct->current_weighted_freq = <nl>  		jobacct->current_weighted_freq + <nl>  		(uint32_t)jobacct->this_sampled_cputime * thisfreq; <nl> -	if (jobacct->tot_cpu) { <nl> +	if (jobacct->tot_cpu >= 1) { <nl>  		return (jobacct->current_weighted_freq / <nl>  			(uint32_t)jobacct->tot_cpu); <nl>  	} else
@@ -234,7 +234,11 @@ job_step_create_allocation(uint32_t job_id) <nl>  	hostlist_uniq(hl); <nl>  	ai->nnodes = hostlist_count(hl); <nl>  	hostlist_destroy(hl); <nl> -	 <nl> +	if (ai->nnodes == 0) { <nl> +		error("No nodes in allocation, can't run job"); <nl> +		goto error; <nl> +	} <nl> + <nl>  	//ai->nnodes         = opt.min_nodes; <nl>  	/* info("node list is now %s %s %d procs",  */ <nl>  /* 	     ai->nodelist, opt.nodelist, */
@@ -783,8 +783,11 @@ static int _attempt_backfill(void) <nl>  		} <nl>  		job_ptr->part_ptr = part_ptr; <nl>   <nl> -		if (debug_flags & DEBUG_FLAG_BACKFILL) <nl> -			info("backfill test for job %u", job_ptr->job_id); <nl> +		if (debug_flags & DEBUG_FLAG_BACKFILL) { <nl> +			info("backfill test for JobID=%u Prio=%u Partition=%s", <nl> +			     job_ptr->job_id, job_ptr->priority, <nl> +			     job_ptr->part_ptr->name); <nl> +		} <nl>   <nl>  		if (max_backfill_job_per_part) { <nl>  			bool skip_job = false;
@@ -283,6 +283,7 @@ int switch_p_libstate_restore (char *dir_name) <nl>  	if (buffer) <nl>  		free_buf(buffer); <nl>  	xfree(data); <nl> +	xfree(ver_str); <nl>   <nl>  	if (error_code == SLURM_SUCCESS) <nl>  		error_code = qsw_init(old_state);
@@ -2125,7 +2125,7 @@ LABEL_FAILURE: <nl>         <nl>        freeTextPath(tp); <nl>        free(tp); <nl> -      goto END; <nl> +      goto NEXT_REPEAT; <nl>   <nl>  LABEL_END: <nl>        { <nl> @@ -2143,6 +2143,7 @@ LABEL_END: <nl>          tsnew->textpath = tp; <nl>          tsnew->textpath->absolute = 1; <nl>        } <nl> +NEXT_REPEAT: <nl>        text_start_length = left_label_position; <nl>        n++; <nl>      } while (n<2);
@@ -1714,6 +1714,12 @@ int msDrawRasterLayerLow(mapObj *map, layerObj *layer, imageObj *image) { <nl>              else <nl>  #endif <nl>              { <nl> +                if( adfGeoTransform[2] != 0.0 || adfGeoTransform[4] != 0.0 ) <nl> +                { <nl> +                    if( layer->debug || map->debug ) <nl> +                        msDebug( "Layer %s has rotational coefficients but we are unable to\nuse them, is projection set?", layer->name ); <nl> +                     <nl> +                } <nl>                  status = msDrawRasterLayerGDAL(map, layer, image, hDS ); <nl>              } <nl>  
@@ -3833,7 +3833,7 @@ char *msSLDGenerateTextSLD(classObj *psClass, layerObj *psLayer, int nVersion) <nl>      snprintf(szTmp, sizeof(szTmp), "<%sTextSymbolizer>\n",  sNameSpace); <nl>      pszSLD = msStringConcatenate(pszSLD, szTmp); <nl>   <nl> -    snprintf(szTmp, sizeof(szTmp), "<%sLabel>%s</%sLabel>\n",  sNameSpace, <nl> +    snprintf(szTmp, sizeof(szTmp), "<%sLabel><ogc:PropertyName>%s</ogc:PropertyName></%sLabel>\n",  sNameSpace, <nl>               psLayer->labelitem, sNameSpace); <nl>      pszSLD = msStringConcatenate(pszSLD, szTmp); <nl>  
@@ -1936,7 +1936,8 @@ mono_local_emulate_ops (MonoCompile *cfg) <nl>  	 * at IR level, instead of inlining the icall wrapper. FIXME <nl>  	 */ <nl>  	if (inlined_wrapper) { <nl> -		mono_decompose_long_opts (cfg); <nl> +		if (!COMPILE_LLVM (cfg)) <nl> +			mono_decompose_long_opts (cfg); <nl>  		if (cfg->opt & (MONO_OPT_CONSPROP | MONO_OPT_COPYPROP)) <nl>  			mono_local_cprop (cfg); <nl>  	}
@@ -220,7 +220,7 @@ mono_class_inflate_generic_type (MonoType *type, MonoGenericInst *ginst, <nl>  		MonoClass *eclass = type->data.klass; <nl>  		MonoClass *nclass; <nl>  		MonoType *nt; <nl> -		if ((eclass->byval_arg.type == MONO_TYPE_MVAR) && gmethod) { <nl> +		if ((eclass->byval_arg.type == MONO_TYPE_MVAR) && gmethod && gmethod->mtype_argv) { <nl>  			nclass = mono_class_from_mono_type (gmethod->mtype_argv [eclass->byval_arg.data.generic_param->num]); <nl>  		} else if ((eclass->byval_arg.type == MONO_TYPE_VAR) && ginst) { <nl>  			nclass = mono_class_from_mono_type (ginst->type_argv [eclass->byval_arg.data.generic_param->num]);
@@ -20,6 +20,13 @@ mini_profiler_emit_instrumentation_call (MonoCompile *cfg, void *func, gboolean <nl>  { <nl>  	gboolean instrument, capture; <nl>   <nl> +	/* <nl> +	 * Do not instrument an inlined method - it becomes <nl> +	 * part of the current method. <nl> +	 */ <nl> +	if (cfg->current_method != cfg->method) <nl> +		return; <nl> + <nl>  	if (entry) { <nl>  		instrument = cfg->prof_flags & MONO_PROFILER_CALL_INSTRUMENTATION_PROLOGUE; <nl>  		capture = cfg->prof_flags & MONO_PROFILER_CALL_INSTRUMENTATION_PROLOGUE_CONTEXT; <nl> @@ -31,8 +38,6 @@ mini_profiler_emit_instrumentation_call (MonoCompile *cfg, void *func, gboolean <nl>  	if (!instrument) <nl>  		return; <nl>   <nl> -	g_assert (cfg->current_method == cfg->method); <nl> - <nl>  	MonoInst *iargs [2]; <nl>   <nl>  	EMIT_NEW_METHODCONST (cfg, iargs [0], cfg->method);
@@ -50,14 +50,14 @@ void check_object (char *start); <nl>   */ <nl>   <nl>  const char*descriptor_types [] = { <nl> +	"INVALID", <nl>  	"run_length", <nl>  	"small_bitmap", <nl> -	"string", <nl>  	"complex", <nl>  	"vector", <nl> -	"array", <nl>  	"large_bitmap", <nl> -	"complex_arr" <nl> +	"complex_arr", <nl> +	"complex_ptrfree" <nl>  }; <nl>   <nl>  static char* describe_nursery_ptr (char *ptr, gboolean need_setup);
@@ -3218,6 +3218,7 @@ compare_type_literals (int class_type, int type_type) <nl>  	case MONO_TYPE_R8: <nl>  	case MONO_TYPE_I: <nl>  	case MONO_TYPE_U: <nl> +	case MONO_TYPE_CLASS: <nl>  		return TRUE; <nl>  	default: <nl>  		return FALSE;
@@ -126,6 +126,10 @@ seq_point_info_add_seq_point (MonoSeqPointInfo *info, SeqPoint *sp, SeqPoint *la <nl>  	guint8 buffer[4]; <nl>  	guint8 len; <nl>   <nl> +	if (!info->has_debug_data && <nl> +		(sp->il_offset == METHOD_ENTRY_IL_OFFSET || sp->il_offset == METHOD_EXIT_IL_OFFSET)) <nl> +		return FALSE; <nl> + <nl>  	/* check that data can be added to the arrays */ <nl>  	g_assert (info->alloc_arrays); <nl>  
@@ -27,13 +27,19 @@ mono_btls_util_asn1_time_to_ticks (ASN1_TIME *time) <nl>  	ASN1_GENERALIZEDTIME *gtime; <nl>  	struct tm tm; <nl>  	int64_t epoch; <nl> +	int ret; <nl>  	 <nl>  	memset (&tm, 0, sizeof (tm)); <nl>   <nl>  	gtime = ASN1_TIME_to_generalizedtime (time, NULL); <nl> -	/* FIXME: check return value of  asn1_generalizedtime_to_tm () */ <nl> -	asn1_generalizedtime_to_tm (&tm, gtime); <nl> +	ret = asn1_generalizedtime_to_tm (&tm, gtime); <nl>  	ASN1_GENERALIZEDTIME_free (gtime); <nl> + <nl> +	/* FIXME: check the return value in managed code */ <nl> +	if (ret == 0) { <nl> +		return 0; <nl> +	} <nl> + <nl>  	epoch = btls_timegm64 (&tm); <nl>   <nl>  	return epoch;
@@ -1545,7 +1545,7 @@ dump_sample_hits (MonoProfiler *prof, StatBuffer *sbuf, int recurse) <nl>  		logbuffer = ensure_logbuf (20 + count * 8); <nl>  		emit_byte (logbuffer, TYPE_SAMPLE | TYPE_SAMPLE_HIT); <nl>  		emit_value (logbuffer, type); <nl> -		emit_uvalue (logbuffer, (prof->startup_time + sample [2]) * 10000); <nl> +		emit_uvalue (logbuffer, prof->startup_time + (uint64_t)sample [2] * (uint64_t)10000); <nl>  		emit_value (logbuffer, count); <nl>  		for (i = 0; i < count; ++i) { <nl>  			emit_ptr (logbuffer, (void*)sample [i + 3]);
@@ -1647,7 +1647,15 @@ parse_public_key (const gchar *key, gchar** pubkey) <nl>  	keylen = strlen (key) >> 1; <nl>  	if (keylen < 1) <nl>  		return FALSE; <nl> -	 <nl> + <nl> +	/* allow the ECMA standard key */ <nl> +	if (strcmp (key, "00000000000000000400000000000000") == 0) { <nl> +		if (pubkey) { <nl> +			arr = g_strdup ("b77a5c561934e089"); <nl> +			*pubkey = arr; <nl> +		} <nl> +		return TRUE; <nl> +	} <nl>  	val = g_ascii_xdigit_value (key [0]) << 4; <nl>  	val |= g_ascii_xdigit_value (key [1]); <nl>  	switch (val) {
@@ -62,10 +62,11 @@ uint32_t calculateEditSoa(SOAData sd, const string& kind) { <nl>      uint32_t inception_serial = localtime_format_YYYYMMDDSS(inception, 1); <nl>      uint32_t dont_increment_after = localtime_format_YYYYMMDDSS(inception + 2*86400, 99); <nl>   <nl> -    if(sd.serial <= dont_increment_after) <nl> -      return (sd.serial + 2); /* "day00" and "day01" are reserved for inception increasing, so increment sd.serial by two */ <nl> -    else if(sd.serial < inception_serial)  <nl> -      return inception_serial; <nl> +    if(sd.serial < inception_serial - 1) { /* less than <inceptionday>00 */ <nl> +      return inception_serial; /* return <inceptionday>01   (skipping <inceptionday>00 as possible value) */ <nl> +    } else if(sd.serial <= dont_increment_after) { /* >= <inceptionday>00 but <= <inceptionday+2>99 */ <nl> +      return (sd.serial + 2); /* "<inceptionday>00" and "<inceptionday>01" are reserved for inception increasing, so increment sd.serial by two */ <nl> +    } <nl>    } <nl>    else if(pdns_iequals(kind,"INCEPTION-WEEK")) { <nl>      time_t inception = getStartOfWeek();
@@ -23,6 +23,7 @@ <nl>  #include "config.h" <nl>  #endif <nl>  #include "geoipbackend.hh" <nl> +#include "pdns/dns_random.hh" <nl>  #include <sstream> <nl>  #include <regex.h> <nl>  #include <glob.h> <nl> @@ -305,7 +306,7 @@ GeoIPBackend::~GeoIPBackend() { <nl>  bool GeoIPBackend::lookup_static(const GeoIPDomain &dom, const DNSName &search, const QType &qtype, const DNSName& qdomain, const std::string &ip, GeoIPLookup &gl, bool v6) { <nl>    const auto i = dom.records.find(search); <nl>    int cumul_probability = 0; <nl> -  int probability_rnd = 1+(random() % 1000); // setting probability=0 means it never is used <nl> +  int probability_rnd = 1+(dns_random(1000)); // setting probability=0 means it never is used <nl>   <nl>    if (i != dom.records.end()) { // return static value <nl>      for(const auto& rr : i->second) {
@@ -524,7 +524,7 @@ int checkZone(DNSSECKeeper &dk, UeberBackend &B, const DNSName& zone, const vect <nl>   <nl>    for(const auto &qname : checkOcclusion) { <nl>      for (const auto &q : recs) { <nl> -      if (q.first.isPartOf(qname.first)) { <nl> +      if (q.first.isPartOf(qname.first) && !checkglue.count(q.first)) { <nl>          cout<<"[Warning] '"<<q.first<<"|"<<q.second.getName()<<"' in zone '"<<zone<<"' is occluded by a "; <nl>          if (qname.second == QType::NS) { <nl>            cout<<"delegation";
@@ -411,6 +411,7 @@ void UeberBackend::lookup(const QType &qtype,const string &qname, DNSPacket *pkt <nl>      int cstat=cacheHas(d_question, d_answers); <nl>      if(cstat<0) { // nothing <nl>        d_negcached=d_cached=false; <nl> +      d_answers.clear();  <nl>        (d_handle.d_hinterBackend=backends[d_handle.i++])->lookup(qtype, qname,pkt_p,zoneId); <nl>      }  <nl>      else if(cstat==0) { <nl> @@ -475,10 +476,6 @@ UeberBackend::handle::~handle() <nl>    instances--; <nl>  } <nl>   <nl> - <nl> - <nl> - <nl> - <nl>  bool UeberBackend::handle::get(DNSResourceRecord &r) <nl>  { <nl>    DLOG(L << "Ueber get() was called for a "<<qtype.getName()<<" record" << endl);
@@ -588,6 +588,9 @@ try <nl>     <nl>    qtype=mdp.d_qtype; <nl>    qclass=mdp.d_qclass; <nl> + <nl> +  d_trc = TSIGRecordContent(); <nl> + <nl>    return 0; <nl>  } <nl>  catch(std::exception& e) {
@@ -262,6 +262,11 @@ shared_ptr<DownstreamState> wrandom(const NumberedServerVector& servers, const C <nl>   <nl>      } <nl>    } <nl> + <nl> +  // Catch poss & sum are empty to avoid SIGFPE <nl> +  if(poss.empty()) <nl> +    return shared_ptr<DownstreamState>(); <nl> + <nl>    int r = random() % sum; <nl>    auto p = upper_bound(poss.begin(), poss.end(),r, [](int r, const decltype(poss)::value_type& a) { return  r < a.first;}); <nl>    if(p==poss.end())
@@ -220,7 +220,7 @@ char *oracle_cb_rewrite_indexname(M_sql_connpool_t *pool, const char *index_name <nl>  	for (max_sect_len=6; max_sect_len>=2; max_sect_len--) { <nl>  		size_t i; <nl>  		/* Don't need position 0 as it is always just "i" for index. truncate from end. */ <nl> -		for (i=num_sects-1; i>0; i++) { <nl> +		for (i=num_sects-1; i>0; i--) { <nl>  			M_buf_truncate(buf, 0); <nl>  			oracle_cb_rewrite_indexname_int(buf, sects, num_sects, max_sect_len, i); <nl>  			if (M_buf_len(buf) <= 30)
@@ -309,6 +309,9 @@ const char* Utils::flowStatus2str(FlowStatus s, AlertType *aType) { <nl>    case status_tcp_connection_refused: <nl>      *aType = alert_suspicious_activity; <nl>      return("TCP connection refused"); <nl> +  case status_ssl_certificate_mismatch: <nl> +    *aType = alert_suspicious_activity; <nl> +    return("SSL certificate mismatch"); <nl>    default: <nl>      return("Unknown status"); <nl>      break;
@@ -474,6 +474,8 @@ void Flow::processDetectedProtocol() { <nl>      break; <nl>   <nl>    case NDPI_PROTOCOL_SSH: <nl> +    if(protos.ssh.client_signature)  free(protos.ssh.client_signature); <nl> +    if(protos.ssh.server_signature)  free(protos.ssh.server_signature); <nl>      protos.ssh.client_signature = strdup(ndpiFlow->protos.ssh.client_signature); <nl>      protos.ssh.server_signature = strdup(ndpiFlow->protos.ssh.server_signature); <nl>      break;
@@ -3290,6 +3290,7 @@ static void handle_cgi_request(struct mg_connection *conn, const char *prog) { <nl>    struct file fout = STRUCT_FILE_INITIALIZER; <nl>    pid_t pid; <nl>   <nl> +  memset(&ri, 0, sizeof(ri)); <nl>    prepare_cgi_environment(conn, prog, &blk); <nl>   <nl>    // CGI must be executed in its own directory. 'dir' must point to the
@@ -76,10 +76,10 @@ typedef enum <nl>      MBEDTLS_ECP_DP_BP384R1,        /*!< Domain parameters for 384-bit Brainpool curve. */ <nl>      MBEDTLS_ECP_DP_BP512R1,        /*!< Domain parameters for 512-bit Brainpool curve. */ <nl>      MBEDTLS_ECP_DP_CURVE25519,     /*!< Domain parameters for Curve25519. */ <nl> -    MBEDTLS_ECP_DP_CURVE448,       /*!< Domain parameters for Curve448. */ <nl>      MBEDTLS_ECP_DP_SECP192K1,      /*!< Domain parameters for 192-bit "Koblitz" curve. */ <nl>      MBEDTLS_ECP_DP_SECP224K1,      /*!< Domain parameters for 224-bit "Koblitz" curve. */ <nl>      MBEDTLS_ECP_DP_SECP256K1,      /*!< Domain parameters for 256-bit "Koblitz" curve. */ <nl> +    MBEDTLS_ECP_DP_CURVE448,       /*!< Domain parameters for Curve448. */ <nl>  } mbedtls_ecp_group_id; <nl>   <nl>  /**
@@ -181,6 +181,9 @@ static int pk_get_ecparams( unsigned char **p, const unsigned char *end, <nl>  { <nl>      int ret; <nl>   <nl> +    if ( end - *p < 1 ) <nl> +        return MBEDTLS_ERR_ASN1_OUT_OF_DATA; <nl> + <nl>      /* Tag may be either OID or SEQUENCE */ <nl>      params->tag = **p; <nl>      if( params->tag != MBEDTLS_ASN1_OID
@@ -2222,7 +2222,8 @@ nautilus_window_slot_switch_new_content_view (NautilusWindowSlot *slot) <nl>  	GtkWidget *widget; <nl>          gboolean reusing_view; <nl>   <nl> -        reusing_view = gtk_widget_get_parent (GTK_WIDGET (slot->details->new_content_view)) != NULL; <nl> +        reusing_view = slot->details->new_content_view && <nl> +                       gtk_widget_get_parent (GTK_WIDGET (slot->details->new_content_view)) != NULL; <nl>          /* We are either reusing the view, so new_content_view and content_view <nl>           * are the same, or the new_content_view is invalid */ <nl>          if (slot->details->new_content_view == NULL || reusing_view)
@@ -291,7 +291,7 @@ nautilus_mime_application_chooser_build_ui (NautilusMimeApplicationChooser *choo <nl>  	gtk_label_set_line_wrap (GTK_LABEL (chooser->details->label), TRUE); <nl>  	gtk_label_set_line_wrap_mode (GTK_LABEL (chooser->details->label), <nl>  				      PANGO_WRAP_WORD_CHAR); <nl> -        gtk_label_set_max_width_chars (GTK_LABEL (chooser->details->label), 60); <nl> +	gtk_label_set_max_width_chars (GTK_LABEL (chooser->details->label), 60); <nl>  	gtk_box_pack_start (GTK_BOX (chooser), chooser->details->label,  <nl>  			    FALSE, FALSE, 0); <nl>  
@@ -4425,7 +4425,8 @@ clicked_within_double_click_interval (NautilusIconContainer *container) <nl>  	/* Stash time for next compare */ <nl>  	last_click_time = current_time; <nl>   <nl> -	return (click_count > 0); <nl> +	/* Only allow double click */ <nl> +	return (click_count == 1); <nl>  } <nl>   <nl>  static void
@@ -68,6 +68,9 @@ class ZMQVan : public Van { <nl>          << "create receiver socket failed: " << zmq_strerror(errno); <nl>      int local = GetEnv("DMLC_LOCAL", 0); <nl>      std::string hostname = node.hostname.empty() ? "*" : node.hostname; <nl> +    if (max_retry == 0) { <nl> +      hostname = "0.0.0.0"; <nl> +    } <nl>      std::string addr = local ? "ipc:///tmp/" : "tcp://" + hostname + ":"; <nl>      int port = node.port; <nl>      unsigned seed = static_cast<unsigned>(time(NULL)+port);
@@ -299,6 +299,10 @@ GF_Err import_file(GF_ISOFile *dest, char *inName, u32 import_flags, Double forc <nl>  				} <nl>  			} <nl>  		} <nl> +		else if (!strnicmp(ext, "prog_id=", 8)) {  <nl> +			prog_id = atoi(ext+8); <nl> +			do_all = 0; <nl> +		} <nl>  		else track_id = atoi(ext); <nl>  	} <nl>  	if (do_audio || do_video || track_id) do_all = 0;
@@ -4069,9 +4069,10 @@ GF_Err audio_sample_entry_Read(GF_Box *s, GF_BitStream *bs) <nl>  	gf_bs_read_data(bs, data, size); <nl>  	for (i=0; i<size-8; i++) { <nl>  		if (GF_4CC((u32)data[i+4], (u8)data[i+5], (u8)data[i+6], (u8)data[i+7]) == GF_ISOM_BOX_TYPE_ESDS) { <nl> +			extern Bool use_dump_mode; <nl>  			GF_BitStream *mybs = gf_bs_new(data + i, size - i, GF_BITSTREAM_READ); <nl>  			if (ptr->esd) { <nl> -				gf_isom_box_del((GF_Box *)ptr->esd); <nl> +				if (!use_dump_mode) gf_isom_box_del((GF_Box *)ptr->esd); <nl>  				ptr->esd=NULL; <nl>  			} <nl>  
@@ -3373,8 +3373,10 @@ GF_Err gf_isom_oinf_read_entry(void *entry, GF_BitStream *bs) <nl>  		op->output_layer_set_idx = gf_bs_read_u16(bs); <nl>  		op->max_temporal_id = gf_bs_read_u8(bs); <nl>  		op->layer_count = gf_bs_read_u8(bs); <nl> -		if (op->layer_count > GF_ARRAY_LENGTH(op->layers_info)) <nl> +		if (op->layer_count > GF_ARRAY_LENGTH(op->layers_info)) { <nl> +			gf_free(op); <nl>  			return GF_NON_COMPLIANT_BITSTREAM; <nl> +		} <nl>  		for (j = 0; j < op->layer_count; j++) { <nl>  			op->layers_info[j].ptl_idx = gf_bs_read_u8(bs); <nl>  			op->layers_info[j].layer_id = gf_bs_read_int(bs, 6);
@@ -1127,7 +1127,7 @@ u32 gf_m4a_get_profile(GF_M4ADecSpecInfo *cfg) <nl>  		if (cfg->nb_chan<=2) <nl>  			return (cfg->base_sr<=24000) ? 0x2C : 0x2D; /*HE@L2 or HE@L3*/ <nl>  		if (cfg->nb_chan<=5) <nl> -			(cfg->base_sr<=48000) ? 0x2E : 0x2F; /*HE@L4 or HE@L5*/ <nl> +			return (cfg->base_sr<=48000) ? 0x2E : 0x2F; /*HE@L4 or HE@L5*/ <nl>  		return (cfg->base_sr<=48000) ? 0x52 : 0x53; /*HE@L6 or HE@L7*/ <nl>  	case 29: /*HE-AACv2 - SBR+PS*/ <nl>  		if (cfg->nb_chan<=2)
@@ -269,6 +269,8 @@ char *gf_text_get_utf8_line(char *szLine, u32 lineSize, FILE *txt_in, s32 unicod <nl>  	} <nl>  	sptr = (u16 *)szLine; <nl>  	i = (u32) gf_utf8_wcstombs(szLineConv, 1024, (const unsigned short **) &sptr); <nl> +	if (i >= (u32)ARRAY_LENGTH(szLineConv)) <nl> +		return NULL; <nl>  	szLineConv[i] = 0; <nl>  	strcpy(szLine, szLineConv); <nl>  	/*this is ugly indeed: since input is UTF16-LE, there are many chances the fgets never reads the \0 after a \n*/
@@ -174,6 +174,7 @@ void IMG_NetIO(void *cbk, GF_NETIO_Parameter *param) <nl>  	e = param->error; <nl>  	/*wait to get the whole file*/ <nl>  	if (!e && (param->msg_type!=GF_NETIO_DATA_TRANSFERED)) return; <nl> +	if ((e==GF_EOS) && (param->msg_type==GF_NETIO_DATA_EXCHANGE)) return; <nl>   <nl>  	if (param->msg_type==GF_NETIO_DATA_TRANSFERED) { <nl>  		szCache = gf_dm_sess_get_cache_name(read->dnload);
@@ -451,8 +451,8 @@ typedef struct <nl>  	u64 FragmentLength; <nl>  	u32 OriginalTrack; <nl>  	u32 finalSampleDescriptionIndex; <nl> -	u32 TimeScale, MediaType, DefaultDuration, InitialTSOffset; <nl> -	u64 last_sample_cts, next_sample_dts; <nl> +	u32 TimeScale, MediaType, DefaultDuration; <nl> +	u64 last_sample_cts, next_sample_dts, InitialTSOffset; <nl>  	Bool all_sample_raps, splitable; <nl>  	u32 split_sample_dts_shift; <nl>  	s32 media_time_to_pres_time_shift; <nl> @@ -926,7 +926,7 @@ static GF_Err gf_media_isom_segment_file(GF_ISOFile *input, const char *output_f <nl>  			char *opt, sKey[100]; <nl>  			sprintf(sKey, "TKID_%d_NextDecodingTime", tf->TrackID); <nl>  			opt = (char *)gf_cfg_get_key(dash_cfg->dash_ctx, RepSecName, sKey); <nl> -			if (opt) tf->InitialTSOffset = atoi(opt); <nl> +			if (opt) sscanf(opt, LLU, & tf->InitialTSOffset); <nl>   <nl>  			/*store presentationTimeOffset on the first rep*/ <nl>  			if (store_dash_params)
@@ -745,6 +745,12 @@ GF_Err adts_dmx_process(GF_Filter *filter) <nl>  			break; <nl>  		} <nl>   <nl> +		if (ctx->hdr.frame_size < ctx->hdr.hdr_size) { <nl> +			GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, ("[ADTSDmx] Corrupted ADTS frame header, resyncing\n")); <nl> +			ctx->nb_frames = 0; <nl> +			goto drop_byte; <nl> +		} <nl> + <nl>  		adts_dmx_check_pid(filter, ctx); <nl>   <nl>  		if (!ctx->is_playing) {
@@ -49,9 +49,10 @@ typedef struct <nl>  static void <nl>  free_pulseaudio_resources (GF_AudioOutput * dr) <nl>  { <nl> +  PulseAudioContext *ctx; <nl>    if (dr == NULL) <nl>      return; <nl> -  PulseAudioContext *ctx = (PulseAudioContext *) dr->opaque; <nl> +  ctx = (PulseAudioContext *) dr->opaque; <nl>    if (ctx == NULL) <nl>      return; <nl>    if (ctx->playback_handle != NULL)
@@ -293,7 +293,11 @@ void load_pkcs11_parameters(struct sc_pkcs11_config *conf, sc_context_t * ctx) <nl>  	/* Set defaults */ <nl>  	conf->plug_and_play = 1; <nl>  	conf->max_virtual_slots = 16; <nl> -	conf->slots_per_card = 4; <nl> +	if (strcmp(ctx->app_name, "onepin-opensc-pkcs11") == 0) { <nl> +		conf->slots_per_card = 1; <nl> +	} else { <nl> +		conf->slots_per_card = 4; <nl> +	} <nl>  	conf->hide_empty_tokens = 1; <nl>  	conf->lock_login = 0; <nl>  	conf->pin_unblock_style = SC_PKCS11_PIN_UNBLOCK_NOT_ALLOWED;
@@ -1599,10 +1599,10 @@ int main(int argc, char * const argv[]) <nl>  	if (opt_startfile) { <nl>  		if(*opt_startfile) { <nl>  			char startpath[1024]; <nl> -			char *argv[] = { startpath }; <nl> +			char *args[] = { startpath }; <nl>   <nl>  			strncpy(startpath, opt_startfile, sizeof(startpath)-1); <nl> -			r = do_cd(1, argv); <nl> +			r = do_cd(1, args); <nl>  			if (r) { <nl>  				printf("unable to select file %s: %s\n", <nl>  					opt_startfile, sc_strerror(r));
@@ -117,6 +117,7 @@ static int parse_dir_record(sc_card_t *card, u8 ** buf, size_t *buflen, <nl>  	if (asn1_dirrecord[2].flags & SC_ASN1_PRESENT) { <nl>  		if (path_len > SC_MAX_PATH_SIZE) { <nl>  			sc_error(card->ctx, "Application path is too long.\n"); <nl> +			free(app); <nl>  			return SC_ERROR_INVALID_ASN1_OBJECT; <nl>  		} <nl>  		memcpy(app->path.value, path, path_len); <nl> @@ -130,8 +131,10 @@ static int parse_dir_record(sc_card_t *card, u8 ** buf, size_t *buflen, <nl>  		app->path.len = 0; <nl>  	if (asn1_dirrecord[3].flags & SC_ASN1_PRESENT) { <nl>  		app->ddo = (u8 *) malloc(ddo_len); <nl> -		if (app->ddo == NULL) <nl> +		if (app->ddo == NULL) { <nl> +			free(app); <nl>  			return SC_ERROR_OUT_OF_MEMORY; <nl> +		} <nl>  		memcpy(app->ddo, ddo, ddo_len); <nl>  		app->ddo_len = ddo_len; <nl>  	} else { <nl> @@ -316,6 +319,7 @@ static int update_transparent(sc_card_t *card, sc_file_t *file) <nl>  		memcpy(buf + buf_size, rec, rec_size); <nl>  		buf_size += rec_size; <nl>  		free(rec); <nl> +		rec=NULL; <nl>  	} <nl>  	if (file->size > buf_size) { <nl>  		tmp = (u8 *) realloc(buf, file->size);
@@ -475,6 +475,9 @@ iso7816_select_file(struct sc_card *card, const struct sc_path *in_path, struct <nl>  	pathlen = in_path->len; <nl>  	pathtype = in_path->type; <nl>   <nl> +	if (file_out != NULL) { <nl> +		*file_out = NULL; <nl> +	} <nl>  	if (in_path->aid.len) { <nl>  		if (!pathlen) { <nl>  			memcpy(path, in_path->aid.value, in_path->aid.len);
@@ -2328,6 +2328,8 @@ sc_pkcs15init_select_intrinsic_id(struct sc_pkcs15_card *p15card, struct sc_prof <nl>  		break; <nl>  	default: <nl>  		sc_log(ctx, "Unsupported ID style: %i", id_style); <nl> +		if (allocated) <nl> +			sc_pkcs15_free_pubkey(pubkey); <nl>  		LOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, "Non supported ID style"); <nl>  	} <nl>   <nl> @@ -3406,6 +3408,7 @@ sc_pkcs15init_authenticate(struct sc_profile *profile, struct sc_pkcs15_card *p1 <nl>  	int  r = 0; <nl>   <nl>  	LOG_FUNC_CALLED(ctx); <nl> +	assert(file != NULL); <nl>  	sc_log(ctx, "path '%s', op=%u", sc_print_path(&file->path), op); <nl>   <nl>  	if (p15card->card->caps & SC_CARD_CAP_USE_FCI_AC) {
@@ -595,6 +595,8 @@ sc_profile_get_file_instance(struct sc_profile *profile, const char *name, <nl>  	file->id += index; <nl>          if(file->type == SC_FILE_TYPE_BSO) { <nl>  		r = sc_profile_add_file(profile, name, file); <nl> +		if (r < 0) <nl> +			sc_file_free(file); <nl>  		LOG_TEST_RET(ctx, r, "Profile error: cannot add BSO file"); <nl>  	} <nl>  	else if (file->path.len)   { <nl> @@ -602,6 +604,8 @@ sc_profile_get_file_instance(struct sc_profile *profile, const char *name, <nl>  		file->path.value[file->path.len - 1] = file->id & 0xFF; <nl>   <nl>  		r = sc_profile_add_file(profile, name, file); <nl> +		if (r < 0) <nl> +			sc_file_free(file); <nl>  		LOG_TEST_RET(ctx, r, "Profile error: cannot add file"); <nl>  	} <nl>  
@@ -1797,7 +1797,7 @@ static int transform_pace_output(u8 *rbuf, size_t rbuflen, <nl>      if (parsed+2 > rbuflen) <nl>          return SC_ERROR_UNKNOWN_DATA_RECEIVED; <nl>      pace_output->mse_set_at_sw1 = rbuf[parsed+0]; <nl> -    pace_output->mse_set_at_sw1 = rbuf[parsed+1]; <nl> +    pace_output->mse_set_at_sw2 = rbuf[parsed+1]; <nl>      parsed += 2; <nl>   <nl>      /* length_CardAccess */
@@ -1108,8 +1108,11 @@ static int westcos_sign_decipher(int mode, sc_card_t *card, <nl>  	BIO *mem = BIO_new(BIO_s_mem()); <nl>  #endif <nl>   <nl> -	if (card == NULL) <nl> +	if (card == NULL) { <nl> +		if (keyfile) <nl> +			sc_file_free(keyfile); <nl>  		return SC_ERROR_INVALID_ARGUMENTS; <nl> +	} <nl>  	sc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, <nl>  		"westcos_sign_decipher outlen=%d\n", outlen); <nl>  	
@@ -4,7 +4,7 @@ <nl>   * <nl>   * Portions Copyright (c) 1996-2010, PostgreSQL Global Development Group <nl>   * <nl> - * $PostgreSQL: pgsql/src/bin/pg_ctl/pg_ctl.c,v 1.118 2010/01/02 16:57:58 momjian Exp $ <nl> + * $PostgreSQL: pgsql/src/bin/pg_ctl/pg_ctl.c,v 1.119 2010/02/19 14:12:19 petere Exp $ <nl>   * <nl>   *------------------------------------------------------------------------- <nl>   */ <nl> @@ -748,7 +748,9 @@ do_start(void) <nl>   <nl>  		if (test_postmaster_connection(false) == false) <nl>  		{ <nl> -			printf(_("could not start server\n")); <nl> +			write_stderr(_("%s: could not start server\n" <nl> +						   "Examine the log output.\n"), <nl> +						 progname); <nl>  			exit(1); <nl>  		} <nl>  		else <nl> @@ -828,7 +830,7 @@ do_stop(void) <nl>  		} <nl>  		print_msg(_(" done\n")); <nl>   <nl> -		printf(_("server stopped\n")); <nl> +		print_msg(_("server stopped\n")); <nl>  	} <nl>  } <nl>   <nl> @@ -907,7 +909,7 @@ do_restart(void) <nl>  		} <nl>   <nl>  		print_msg(_(" done\n")); <nl> -		printf(_("server stopped\n")); <nl> +		print_msg(_("server stopped\n")); <nl>  	} <nl>  	else <nl>  	{
@@ -886,9 +886,14 @@ SyncRepUpdateConfig(void) <nl>  	 */ <nl>  	syncrep_scanner_init(SyncRepStandbyNames); <nl>  	parse_rc = syncrep_yyparse(); <nl> -	Assert(parse_rc == 0); <nl>  	syncrep_scanner_finish(); <nl>   <nl> +	if (parse_rc != 0) <nl> +		ereport(ERROR, <nl> +				(errcode(ERRCODE_SYNTAX_ERROR), <nl> +				 errmsg_internal("synchronous_standby_names parser returned %d", <nl> +								 parse_rc))); <nl> + <nl>  	SyncRepConfig = syncrep_parse_result; <nl>  	syncrep_parse_result = NULL; <nl>  }
@@ -402,7 +402,7 @@ CreateDecodingContext(XLogRecPtr start_lsn, <nl>  	/* call output plugin initialization callback */ <nl>  	old_context = MemoryContextSwitchTo(ctx->context); <nl>  	if (ctx->callbacks.startup_cb != NULL) <nl> -		startup_cb_wrapper(ctx, &ctx->options, true); <nl> +		startup_cb_wrapper(ctx, &ctx->options, false); <nl>  	MemoryContextSwitchTo(old_context); <nl>   <nl>  	ereport(LOG,
@@ -6,7 +6,7 @@ <nl>   * Portions Copyright (c) 1996-2002, PostgreSQL Global Development Group <nl>   * Portions Copyright (c) 1994, Regents of the University of California <nl>   * <nl> - *	$Header: /cvsroot/pgsql/src/backend/parser/analyze.c,v 1.251 2002/10/14 22:14:35 tgl Exp $ <nl> + *	$Header: /cvsroot/pgsql/src/backend/parser/analyze.c,v 1.252 2002/10/20 00:31:53 tgl Exp $ <nl>   * <nl>   *------------------------------------------------------------------------- <nl>   */ <nl> @@ -1454,6 +1454,10 @@ transformRuleStmt(ParseState *pstate, RuleStmt *stmt, <nl>  	if (length(pstate->p_rtable) != 2)	/* naughty, naughty... */ <nl>  		elog(ERROR, "Rule WHERE condition may not contain references to other relations"); <nl>   <nl> +	/* aggregates not allowed (but subselects are okay) */ <nl> +	if (contain_agg_clause(stmt->whereClause)) <nl> +		elog(ERROR, "Rule WHERE condition may not contain aggregate functions"); <nl> + <nl>  	/* save info about sublinks in where clause */ <nl>  	qry->hasSubLinks = pstate->p_hasSubLinks; <nl>  
@@ -212,7 +212,8 @@ join_path_components(char *ret_path, <nl>  	} <nl>  	if (*tail) <nl>  		snprintf(ret_path + strlen(ret_path), MAXPGPATH - strlen(ret_path), <nl> -				 "/%s", tail); <nl> +				/* only add slash if there is something already in head */ <nl> +				 "%s%s", head[0] ? "/" : "", tail); <nl>  } <nl>   <nl>  
@@ -33,7 +33,7 @@ <nl>   *	  ENHANCEMENTS, OR MODIFICATIONS. <nl>   * <nl>   * IDENTIFICATION <nl> - *	  $Header: /cvsroot/pgsql/src/pl/plperl/plperl.c,v 1.39 2003/08/04 00:43:33 momjian Exp $ <nl> + *	  $Header: /cvsroot/pgsql/src/pl/plperl/plperl.c,v 1.40 2003/09/04 15:16:39 tgl Exp $ <nl>   * <nl>   **********************************************************************/ <nl>   <nl> @@ -757,6 +757,10 @@ plperl_build_tuple_argument(HeapTuple tuple, TupleDesc tupdesc) <nl>   <nl>  	for (i = 0; i < tupdesc->natts; i++) <nl>  	{ <nl> +		/* ignore dropped attributes */ <nl> +		if (tupdesc->attrs[i]->attisdropped) <nl> +			continue; <nl> + <nl>  		/************************************************************ <nl>  		 * Get the attribute name <nl>  		 ************************************************************/
@@ -7,7 +7,7 @@ <nl>   * <nl>   * <nl>   * IDENTIFICATION <nl> - *	  $Header: /cvsroot/pgsql/src/bin/psql/Attic/psql.c,v 1.108 1997/11/16 05:32:16 momjian Exp $ <nl> + *	  $Header: /cvsroot/pgsql/src/bin/psql/Attic/psql.c,v 1.109 1997/11/17 05:23:11 momjian Exp $ <nl>   * <nl>   *------------------------------------------------------------------------- <nl>   */ <nl> @@ -2099,7 +2099,7 @@ MainLoop(PsqlSettings *pset, char *query, FILE *source) <nl>  		 * for next command <nl>  		 */ <nl>   <nl> -		if (line == NULL) <nl> +		if (line == NULL || *line == '\0') <nl>  		{		/* 	No more input.	Time to quit, or \i done */ <nl>  			if (!pset->quiet) <nl>  				printf("EOF\n");/* Goes on prompt line */
@@ -3,7 +3,7 @@ <nl>   * <nl>   * Copyright 2000 by PostgreSQL Global Development Group <nl>   * <nl> - * $Header: /cvsroot/pgsql/src/bin/psql/command.c,v 1.63 2001/11/05 17:46:30 momjian Exp $ <nl> + * $Header: /cvsroot/pgsql/src/bin/psql/command.c,v 1.64 2002/01/18 16:14:54 tgl Exp $ <nl>   */ <nl>  #include "postgres_fe.h" <nl>  #include "command.h" <nl> @@ -710,7 +710,7 @@ exec_command(const char *cmd, <nl>  			psql_error("\\%s: missing required argument\n", cmd); <nl>  			success = false; <nl>  		} <nl> -		if (!SetVariable(pset.vars, opt, NULL)) <nl> +		else if (!SetVariable(pset.vars, opt, NULL)) <nl>  		{ <nl>  			psql_error("\\%s: error\n", cmd); <nl>  			success = false;
@@ -380,10 +380,11 @@ lazy_vacuum_rel(Relation onerel, int options, VacuumParams *params, <nl>  							 vacrelstats->pinskipped_pages, <nl>  							 vacrelstats->frozenskipped_pages); <nl>  			appendStringInfo(&buf, <nl> -							 _("tuples: %.0f removed, %.0f remain, %.0f are dead but not yet removable\n"), <nl> +							 _("tuples: %.0f removed, %.0f remain, %.0f are dead but not yet removable, oldest xmin: %u\n"), <nl>  							 vacrelstats->tuples_deleted, <nl>  							 vacrelstats->new_rel_tuples, <nl> -							 vacrelstats->new_dead_tuples); <nl> +							 vacrelstats->new_dead_tuples, <nl> +							 OldestXmin); <nl>  			appendStringInfo(&buf, <nl>  						 _("buffer usage: %d hits, %d misses, %d dirtied\n"), <nl>  							 VacuumPageHit, <nl> @@ -1329,8 +1330,8 @@ lazy_scan_heap(Relation onerel, int options, LVRelStats *vacrelstats, <nl>  	 */ <nl>  	initStringInfo(&buf); <nl>  	appendStringInfo(&buf, <nl> -					 _("%.0f dead row versions cannot be removed yet.\n"), <nl> -					 nkeep); <nl> +					 _("%.0f dead row versions cannot be removed yet, oldest xmin: %u\n"), <nl> +					 nkeep, OldestXmin); <nl>  	appendStringInfo(&buf, _("There were %.0f unused item pointers.\n"), <nl>  					 nunused); <nl>  	appendStringInfo(&buf, ngettext("Skipped %u page due to buffer pins.\n",
@@ -26,7 +26,7 @@ <nl>   * <nl>   * <nl>   * IDENTIFICATION <nl> - *	  $PostgreSQL: pgsql/src/backend/executor/execMain.c,v 1.340 2010/01/06 03:04:01 momjian Exp $ <nl> + *	  $PostgreSQL: pgsql/src/backend/executor/execMain.c,v 1.341 2010/01/08 02:44:00 tgl Exp $ <nl>   * <nl>   *------------------------------------------------------------------------- <nl>   */ <nl> @@ -1546,6 +1546,8 @@ EvalPlanQualFetch(EState *estate, Relation relation, int lockmode, <nl>  					{ <nl>  						/* it was updated, so look at the updated version */ <nl>  						tuple.t_self = update_ctid; <nl> +						/* updated row should have xmin matching this xmax */ <nl> +						priorXmax = update_xmax; <nl>  						continue; <nl>  					} <nl>  					/* tuple was deleted, so give up */
@@ -270,8 +270,9 @@ typedef struct StdRdOptions <nl>   *		from the pov of logical decoding.  Note multiple eval of argument! <nl>   */ <nl>  #define RelationIsUsedAsCatalogTable(relation)	\ <nl> -	((relation)->rd_rel->relkind == RELKIND_RELATION && \ <nl> -	 (relation)->rd_options ? \ <nl> +	((relation)->rd_options && \ <nl> +	 ((relation)->rd_rel->relkind == RELKIND_RELATION || \ <nl> +	  (relation)->rd_rel->relkind == RELKIND_MATVIEW) ? \ <nl>  	 ((StdRdOptions *) (relation)->rd_options)->user_catalog_table : false) <nl>   <nl>  /*
@@ -1354,6 +1354,11 @@ pg_newlocale_from_collation(Oid collid) <nl>  			UCollator  *collator; <nl>  			UErrorCode	status; <nl>   <nl> +			if (strcmp(collcollate, collctype) != 0) <nl> +				ereport(ERROR, <nl> +						(errcode(ERRCODE_FEATURE_NOT_SUPPORTED), <nl> +						 errmsg("collations with different collate and ctype values are not supported by ICU"))); <nl> + <nl>  			status = U_ZERO_ERROR; <nl>  			collator = ucol_open(collcollate, &status); <nl>  			if (U_FAILURE(status))
@@ -834,8 +834,12 @@ Array File::readCSV(int64 length /* = 0 */, char delimiter_char /* = ',' */, <nl>      } <nl>   <nl>      /* 3. Now pass our field back to php */ <nl> -    *comp_end = '\0'; <nl> -    ret.append(String(temp, comp_end - temp, CopyString)); <nl> +    if (comp_end - temp) { <nl> +      *comp_end = '\0'; <nl> +      ret.append(String(temp, comp_end - temp, CopyString)); <nl> +    } else { <nl> +      ret.append(null_variant); <nl> +    } <nl>    } while (bptr < limit); <nl>   <nl>    free(temp);
@@ -499,7 +499,7 @@ bool SSLSocket::setupCrypto(SSLSocket *session /* = NULL */) { <nl>      break; <nl>    case CryptoMethod::ClientTLS: <nl>      m_data->m_client = true; <nl> -    smethod = TLSv1_client_method(); <nl> +    smethod = TLS_client_method(); <nl>      break; <nl>    case CryptoMethod::ServerSSLv23: <nl>      m_data->m_client = false; <nl> @@ -542,7 +542,7 @@ bool SSLSocket::setupCrypto(SSLSocket *session /* = NULL */) { <nl>   <nl>    case CryptoMethod::ServerTLS: <nl>      m_data->m_client = false; <nl> -    smethod = TLSv1_server_method(); <nl> +    smethod = TLS_server_method(); <nl>      break; <nl>    default: <nl>      return false;
@@ -800,7 +800,7 @@ void rfc1867PostHandler(Transport* transport, <nl>          new_val_len = value_len; <nl>          if (php_rfc1867_callback != nullptr) { <nl>            multipart_event_formdata event_formdata; <nl> -          size_t newlength = 0; <nl> +          size_t newlength = new_val_len; <nl>   <nl>            event_formdata.post_bytes_processed = mbuff->read_post_bytes; <nl>            event_formdata.name = param;
@@ -301,8 +301,10 @@ public: <nl>    ArrayData *getLvalPtr(CStrRef k, Variant *&ret, bool copy); <nl>    ArrayData *set(CStrRef k, CVarRef v, bool copy); <nl>    ArrayData *set(CVarRef k, CVarRef v, bool copy); <nl> +  ArrayData *set(const StringData*, CVarRef, bool) = delete; <nl>    ArrayData *setRef(CStrRef k, CVarRef v, bool copy); <nl>    ArrayData *setRef(CVarRef k, CVarRef v, bool copy); <nl> +  ArrayData *setRef(const StringData*, CVarRef, bool) = delete; <nl>    ArrayData *add(CStrRef k, CVarRef v, bool copy); <nl>    ArrayData *add(CVarRef k, CVarRef v, bool copy); <nl>    ArrayData *addLval(CStrRef k, Variant *&ret, bool copy);
@@ -310,6 +310,7 @@ inline Variant f_reset(Variant array) { <nl>    return array.array_iter_reset(); <nl>  } <nl>  inline Variant f_end(Variant array) { <nl> +  array.array_iter_dirty_reset(); <nl>    return array.array_iter_end(); <nl>  } <nl>  inline Variant f_key(Variant array) {
@@ -59,6 +59,7 @@ struct Resumable { <nl>    static void* Create(const ActRec* fp, size_t numSlots, jit::TCA resumeAddr, <nl>                        Offset resumeOffset, size_t objSize) { <nl>      assert(fp); <nl> +    assert(fp->resumed() == clone); <nl>      DEBUG_ONLY auto const func = fp->func(); <nl>      assert(func); <nl>      assert(func->isResumable()); <nl> @@ -76,6 +77,9 @@ struct Resumable { <nl>        auto src = (void *)((uintptr_t)fp - frameSize); <nl>        memcpy(mem, src, frameSize + sizeof(ActRec)); <nl>   <nl> +      // Set resumed flag. <nl> +      actRec->setResumed(); <nl> + <nl>        // Suspend VarEnv if needed <nl>        if (UNLIKELY(fp->hasVarEnv())) { <nl>          fp->getVarEnv()->suspend(fp, actRec); <nl> @@ -86,9 +90,6 @@ struct Resumable { <nl>        memcpy(actRec, fp, sizeof(ActRec)); <nl>      } <nl>   <nl> -    // Set resumed flag. <nl> -    actRec->setResumed(); <nl> - <nl>      // Populate Resumable. <nl>      resumable->m_resumeAddr = resumeAddr; <nl>      resumable->m_resumeOffset = resumeOffset;
@@ -26,9 +26,9 @@ namespace { <nl>  template<typename T> T bad_value() { not_reached(); } <nl>   <nl>  Opcode canonicalOp(Opcode op) { <nl> -  if (op == ElemUX || op == UnsetElem) return UnsetElem; <nl> -  if (op == SetWithRefElem)            return SetWithRefElem; <nl> -  if (op == SetRangeRev)               return SetRange; <nl> +  if (op == ElemUX || op == UnsetElem)     return UnsetElem; <nl> +  if (op == SetWithRefElem)                return SetWithRefElem; <nl> +  if (op == SetRange || op == SetRangeRev) return SetRange; <nl>   <nl>    return opcodeHasFlags(op, MInstrProp) ? SetProp <nl>         : opcodeHasFlags(op, MInstrElem) ? SetElem
@@ -31,10 +31,13 @@ int main(int argc, char** argv) { <nl>      return HPHP::execute_program(argc, argv); <nl>    } <nl>    std::vector<char*> args; <nl> -  args.insert(args.begin(), argv, argv + argc); <nl> +  args.push_back(argv[0]); <nl>    args.push_back("-vRepo.Authoritative=true"); <nl>    args.push_back("-vRepo.Local.Mode=r-"); <nl>    repo = "-vRepo.Local.Path=" + repo; <nl>    args.push_back(const_cast<char*>(repo.c_str())); <nl> +  if (argc > 1) { <nl> +    args.insert(args.end(), argv + 1, argv + argc); <nl> +  } <nl>    return HPHP::execute_program(args.size(), &args[0]); <nl>  }
@@ -298,7 +298,7 @@ void LightProcess::SigChldHandler(int sig, siginfo_t* info, void* ctx) { <nl>    } <nl>    pid_t pid = info->si_pid; <nl>    for (int i = 0; i < g_procsCount; ++i) { <nl> -    if (g_procs[i].m_shadowProcess == pid) { <nl> +    if (g_procs && g_procs[i].m_shadowProcess == pid) { <nl>        // The exited process was a light process. Notify the callback, if any. <nl>        if (s_lostChildHandler) { <nl>          s_lostChildHandler(pid);
@@ -144,6 +144,7 @@ int splash_load_bmp( const char *filename ) <nl>      width = png_get_image_width( png_ptr, info_ptr ); <nl>      height = png_get_image_height( png_ptr, info_ptr ); <nl>   <nl> +    fclose( file ); <nl>      return 1; <nl>  } <nl>  #else
@@ -132,7 +132,7 @@ void ReadJPEG( JPEGReader* pJPEGReader, void* pInputStream, long* pLines, <nl>          } <nl>      } <nl>   <nl> -    jpeg_start_decompress( &cinfo ); <nl> +    jpeg_calc_output_dimensions(&cinfo); <nl>   <nl>      long nWidth = cinfo.output_width; <nl>      long nHeight = cinfo.output_height; <nl> @@ -161,7 +161,6 @@ void ReadJPEG( JPEGReader* pJPEGReader, void* pInputStream, long* pLines, <nl>              J_COLOR_SPACE best_out_color_space = JCS_RGB; <nl>              ScanlineFormat eScanlineFormat = ScanlineFormat::N24BitTcRgb; <nl>              ScanlineFormat eFinalFormat = pAccess->GetScanlineFormat(); <nl> - <nl>              if (eFinalFormat == ScanlineFormat::N32BitTcBgra) <nl>              { <nl>                  best_out_color_space = JCS_EXT_BGRA; <nl> @@ -190,10 +189,12 @@ void ReadJPEG( JPEGReader* pJPEGReader, void* pInputStream, long* pLines, <nl>                  cinfo.out_color_space != JCS_GRAYSCALE && <nl>                  cinfo.out_color_space != best_out_color_space) <nl>              { <nl> -                SAL_WARN("vcl.filter", "jpg with unknown out color space, forcing to :" << best_out_color_space); <nl> +                SAL_WARN("vcl.filter", "jpg with unknown out color space, forcing to :" << best_out_color_space << " gray "); <nl>                  cinfo.out_color_space = best_out_color_space; <nl>              } <nl>   <nl> +            jpeg_start_decompress(&cinfo); <nl> + <nl>              JSAMPLE* aRangeLimit = cinfo.sample_range_limit; <nl>   <nl>              std::vector<sal_uInt8> pScanLineBuffer(nWidth * (bGray ? 1 : nPixelSize));
@@ -130,6 +130,9 @@ static int osl_getHWAddr(const char *ifname, char* hard_addr) <nl>      struct ifreq ifr; <nl>      int so = socket(AF_INET, SOCK_DGRAM, 0); <nl>   <nl> +    if (strlen(ifname) >= sizeof(ifr.ifr_name)) <nl> +        return 0; <nl> + <nl>      strcpy(ifr.ifr_name, ifname); <nl>   <nl>      /*
@@ -492,7 +492,7 @@ int main(int argc, char**argv) { <nl>   <nl>  	 if (!path.length()) { <nl>  	    cout << "The current path is empty." << endl; <nl> -	    retval = 1; <nl> +	    path = '/'; <nl>  	 } <nl>   <nl>  	 // Now try to issue the request
@@ -227,7 +227,7 @@ int XrdConfig::Configure(int argc, char **argv) <nl>     if (*dfltProt != '.' ) <nl>        {char *p = dfltProt; <nl>         while (*p && *p != '.') p++; <nl> -       if (*p == '.') {*p = '\0'; dfltProt = strdup(dfltProt); *p = ',';} <nl> +       if (*p == '.') {*p = '\0'; dfltProt = strdup(dfltProt); *p = '.';} <nl>        } <nl>   <nl>  // Process the options
@@ -102,8 +102,8 @@ unsigned long XrdSysTimer::Report(double &Total_Time) <nl>   <nl>  // Add up the time as a double <nl>  // <nl> -    Total_Time += (double)LastReport.tv_sec + <nl> -                 ((double)(LastReport.tv_usec/1000))/1000.0; <nl> +    Total_Time += static_cast<double>(LastReport.tv_sec) + <nl> +                  static_cast<double>(LastReport.tv_usec/1000)/1000.0; <nl>   <nl>  // Return time <nl>  // <nl> @@ -116,7 +116,7 @@ unsigned long XrdSysTimer::Report(unsigned long &Total_Time) <nl>  { <nl>      unsigned long report_time = Report(); <nl>   <nl> -// Add up the time as a 32-bit value to nearest microsecond (max = 24 days) <nl> +// Add up the time as a 32-bit value to nearest milliseconds (max = 24 days) <nl>  // <nl>      Total_Time += (unsigned long)LastReport.tv_sec*1000 + <nl>                    (unsigned long)(LastReport.tv_usec/1000); <nl> @@ -132,7 +132,7 @@ unsigned long XrdSysTimer::Report(unsigned long long &Total_Time) <nl>  { <nl>      unsigned long report_time = Report(); <nl>   <nl> -// Add up the time as a 64-bit value to nearest microsecond <nl> +// Add up the time as a 64-bit value to nearest milliseconds <nl>  // <nl>      Total_Time += (unsigned long long)LastReport.tv_sec*1000 + <nl>                    (unsigned long long)(LastReport.tv_usec/1000);
@@ -39,6 +39,9 @@ char *strshare_get(const char *str) <nl>  { <nl>  	strshare_t *ss; <nl>   <nl> +	if (str == NULL) <nl> +		return NULL; <nl> + <nl>  	ss = mowgli_patricia_retrieve(strshare_dict, str); <nl>  	if (ss != NULL) <nl>  		ss->refcount++; <nl> @@ -56,6 +59,9 @@ void strshare_unref(char *str) <nl>  { <nl>  	strshare_t *ss; <nl>   <nl> +	if (str == NULL) <nl> +		return NULL; <nl> + <nl>  	ss = (strshare_t *)str - 1; <nl>  	ss->refcount--; <nl>  	if (ss->refcount == 0)
@@ -42,7 +42,10 @@ static void do_sethost(user_t *u, char *host) <nl>  { <nl>  	if (!strcmp(u->vhost, host)) <nl>  		return; <nl> -	mowgli_strlcpy(u->vhost, host, HOSTLEN); <nl> + <nl> +	strshare_unref(u->vhost); <nl> +	u->vhost = strshare_get(host); <nl> + <nl>  	user_sethost(nicksvs.me->me, u, u->vhost); <nl>  } <nl>  
@@ -157,6 +157,7 @@ void help_display_as_subcmd(sourceinfo_t *si, service_t *service, const char *su <nl>  			if (!help_file) <nl>  			{ <nl>  				command_fail(si, fault_nosuch_target, _("Could not get help file for \2%s\2."), command); <nl> +				free(ccommand); <nl>  				return; <nl>  			} <nl>  
@@ -20,7 +20,7 @@ <nl>   <nl>  /* <nl>   * House initialization and main program loop <nl> - * $Id: main.c,v 1.34 2000-07-21 05:18:04 macgyver Exp $ <nl> + * $Id: main.c,v 1.35 2000-07-21 05:18:39 macgyver Exp $ <nl>   */ <nl>   <nl>  /* <nl> @@ -2082,7 +2082,7 @@ int main(int argc, char **argv, char **envp) <nl>    int _umask = 0,c; <nl>    int check_config_syntax = 0; <nl>    struct sockaddr peer; <nl> -  char *cmdopts = "nd:c:p:lhtv" <nl> +  const char *cmdopts = "nd:c:p:lhtv" <nl>   <nl>  #ifdef DEBUG_CORE <nl>      "o"
@@ -24,7 +24,7 @@ <nl>   * DO NOT EDIT BELOW THIS LINE <nl>   * $Archive: mod_sftp.a $ <nl>   * $Libraries: -lcrypto -lz $ <nl> - * $Id: mod_sftp.c,v 1.55 2011-04-20 16:11:15 castaglia Exp $ <nl> + * $Id: mod_sftp.c,v 1.56 2011-05-13 19:00:08 castaglia Exp $ <nl>   */ <nl>   <nl>  #include "mod_sftp.h" <nl> @@ -454,6 +454,10 @@ static uint32_t get_size(const char *bytes, const char *units) { <nl>    } <nl>   <nl>    nbytes = (uint32_t) (res * units_factor); <nl> +  if (nbytes == 0) { <nl> +    errno = EINVAL; <nl> +  } <nl> +  <nl>    return nbytes; <nl>  } <nl>  
@@ -923,11 +923,12 @@ int pr_netio_write_async(pr_netio_stream_t *nstrm, char *buf, size_t buflen) { <nl>   <nl>      if (bwritten < 0) { <nl>        nstrm->strm_errno = errno; <nl> -      fcntl(nstrm->strm_fd, F_SETFL, flags); <nl> +      (void) fcntl(nstrm->strm_fd, F_SETFL, flags); <nl>   <nl> -      if (nstrm->strm_errno == EWOULDBLOCK) <nl> +      if (nstrm->strm_errno == EWOULDBLOCK) { <nl>          /* Give up ... */ <nl>          return total; <nl> +      } <nl>   <nl>        return -1; <nl>      }
@@ -27,7 +27,7 @@ void do_whois(InspIRCd* ServerInstance, User* user, User* dest,unsigned long sig <nl>  	if (dest->registered == REG_ALL) <nl>  	{ <nl>  		ServerInstance->SendWhoisLine(user, dest, 311, "%s %s %s %s * :%s",user->nick.c_str(), dest->nick.c_str(), dest->ident.c_str(), dest->dhost.c_str(), dest->fullname.c_str()); <nl> -		if (user == dest || IS_OPER(user)) <nl> +		if (user == dest || user->HasPrivPermission("users/auspex")) <nl>  		{ <nl>  			ServerInstance->SendWhoisLine(user, dest, 378, "%s %s :is connecting from %s@%s %s", user->nick.c_str(), dest->nick.c_str(), dest->ident.c_str(), dest->host.c_str(), dest->GetIPString()); <nl>  		} <nl> @@ -45,7 +45,7 @@ void do_whois(InspIRCd* ServerInstance, User* user, User* dest,unsigned long sig <nl>  				ServerInstance->SendWhoisLine(user, dest, 319, "%s %s :%s",user->nick.c_str(), dest->nick.c_str(), cl.c_str()); <nl>  			} <nl>  		} <nl> -		if (*ServerInstance->Config->HideWhoisServer && !IS_OPER(user)) <nl> +		if (*ServerInstance->Config->HideWhoisServer && !user->HasPrivPermission("servers/auspex")) <nl>  		{ <nl>  			ServerInstance->SendWhoisLine(user, dest, 312, "%s %s %s :%s",user->nick.c_str(), dest->nick.c_str(), ServerInstance->Config->HideWhoisServer, ServerInstance->Config->Network); <nl>  		} <nl> @@ -64,9 +64,9 @@ void do_whois(InspIRCd* ServerInstance, User* user, User* dest,unsigned long sig <nl>  			ServerInstance->SendWhoisLine(user, dest, 313, "%s %s :is %s %s on %s",user->nick.c_str(), dest->nick.c_str(), (strchr("AEIOUaeiou",dest->oper[0]) ? "an" : "a"),irc::Spacify(dest->oper.c_str()), ServerInstance->Config->Network); <nl>  		} <nl>   <nl> -		if (user == dest || IS_OPER(user)) <nl> +		if (user == dest || user->HasPrivPermission("users/auspex")) <nl>  		{ <nl> -			if (dest->modes[UM_SNOMASK] != 0) <nl> +			if (dest->IsModeSet('s') != 0) <nl>  			{ <nl>  				ServerInstance->SendWhoisLine(user, dest, 379, "%s %s :is using modes +%s +%s", user->nick.c_str(), dest->nick.c_str(), dest->FormatModes(), dest->FormatNoticeMasks()); <nl>  			}
@@ -1247,7 +1247,7 @@ class TreeSocket : public InspSocket <nl>  					if ((ret.substr(0,7) != "ERROR :") && (ret.substr(0,6) != "CAPAB ")) <nl>  					{ <nl>  						int nbytes = from64tobits(out, ret.c_str(), 1024); <nl> -						if (nbytes > 0) <nl> +						if ((nbytes > 0) && (nbytes < 1024)) <nl>  						{ <nl>  							log(DEBUG,"m_spanningtree: decrypt %d bytes",nbytes); <nl>  							ctx->Decrypt(out, result, nbytes, 0);
@@ -57,7 +57,7 @@ class ModuleDenyChannels : public Module <nl>  					if (InspIRCd::Match(redirect, j->second->getString("name"))) <nl>  					{ <nl>  						bool goodchan = false; <nl> -						ConfigTagList goodchans = ServerInstance->Config->ConfTags("badchan"); <nl> +						ConfigTagList goodchans = ServerInstance->Config->ConfTags("goodchan"); <nl>  						for (ConfigIter k = goodchans.first; k != goodchans.second; ++k) <nl>  						{ <nl>  							if (InspIRCd::Match(redirect, k->second->getString("name")))
@@ -189,6 +189,7 @@ class CommandAuthenticate : public Command <nl>  		: Command(Creator, "AUTHENTICATE", 1), authExt(ext), cap(Cap) <nl>  	{ <nl>  		works_before_reg = true; <nl> +		allow_empty_last_param = false; <nl>  	} <nl>   <nl>  	CmdResult Handle (const std::vector<std::string>& parameters, User *user) <nl> @@ -199,6 +200,9 @@ class CommandAuthenticate : public Command <nl>  			if (!cap.ext.get(user)) <nl>  				return CMD_FAILURE; <nl>   <nl> +			if (parameters[0].find(' ') != std::string::npos || parameters[0][0] == ':') <nl> +				return CMD_FAILURE; <nl> + <nl>  			SaslAuthenticator *sasl = authExt.get(user); <nl>  			if (!sasl) <nl>  				authExt.set(user, new SaslAuthenticator(user, parameters[0]));
@@ -1703,7 +1703,7 @@ int InspIRCd::Run() <nl>   <nl>  int main(int argc, char** argv) <nl>  { <nl> -        InspIRCd TittyBiscuits = new InspIRCd(argc, argv); <nl> +        InspIRCd* TittyBiscuits = new InspIRCd(argc, argv); <nl>          TittyBiscuits->Run(); <nl>          delete TittyBiscuits; <nl>          return 0;
@@ -299,6 +299,7 @@ class ModuleSSLOpenSSL : public Module <nl>  		session->sess = SSL_new(ctx); <nl>  		session->status = ISSL_NONE; <nl>  		session->outbound = false; <nl> +		session->cert = NULL; <nl>   <nl>  		if (session->sess == NULL) <nl>  			return;
@@ -382,7 +382,7 @@ class ModuleSilence : public Module <nl>  	int MatchPattern(User* dest, User* source, int pattern) <nl>  	{ <nl>  		/* Server source */ <nl> -		if (!source) <nl> +		if (!source || !dest) <nl>  			return 1; <nl>   <nl>  		silencelist* sl;
@@ -92,7 +92,7 @@ class cmd_shun : public Command <nl>   <nl>  		if(pcnt == 1) <nl>  		{ <nl> -			if (ServerInstance->XLines->DelLine(parameters[0], "S", user)) <nl> +			if (ServerInstance->XLines->DelLine(parameters[0], "SHUN", user)) <nl>  			{ <nl>  				ServerInstance->SNO->WriteToSnoMask('x',"%s Removed shun on %s.",user->nick,parameters[0]); <nl>  			}
@@ -380,6 +380,9 @@ ModuleSQL::ModuleSQL() <nl>   <nl>  void ModuleSQL::init() <nl>  { <nl> +	if (mysql_library_init(0, NULL, NULL)) <nl> +		throw ModuleException("Unable to initialise the MySQL library!"); <nl> + <nl>  	Dispatcher = new DispatcherThread(this); <nl>  	ServerInstance->Threads->Start(Dispatcher); <nl>   <nl> @@ -397,10 +400,13 @@ ModuleSQL::~ModuleSQL() <nl>  		Dispatcher->OnNotify(); <nl>  		delete Dispatcher; <nl>  	} <nl> + <nl>  	for(ConnMap::iterator i = connections.begin(); i != connections.end(); i++) <nl>  	{ <nl>  		delete i->second; <nl>  	} <nl> + <nl> +	mysql_library_end(); <nl>  } <nl>   <nl>  void ModuleSQL::OnRehash(User* user)
@@ -54,6 +54,9 @@ class ModuleRestrictChans : public Module <nl>  	virtual int OnUserPreJoin(User* user, Channel* chan, const char* cname, std::string &privs, const std::string &keygiven) <nl>  	{ <nl>  		irc::string x = cname; <nl> +		if (!IS_LOCAL(user)) <nl> +			return; <nl> + <nl>  		// user is not an oper and its not in the allow list <nl>  		if ((!IS_OPER(user)) && (allowchans.find(x) == allowchans.end())) <nl>  		{
@@ -88,7 +88,14 @@ DownloadItem::~DownloadItem() { <nl>  } <nl>   <nl>  void DownloadItem::OnDownloadUpdated(content::DownloadItem* item) { <nl> -  download_item_->IsDone() ? Emit("done", item->GetState()) : Emit("updated"); <nl> +  if (download_item_->IsDone()) { <nl> +    Emit("done", item->GetState()); <nl> + <nl> +    // Destroy the item once item is downloaded. <nl> +    base::MessageLoop::current()->PostTask(FROM_HERE, GetDestroyClosure()); <nl> +  } else { <nl> +    Emit("updated"); <nl> +  } <nl>  } <nl>   <nl>  void DownloadItem::OnDownloadDestroyed(content::DownloadItem* download_item) {
@@ -48,9 +48,10 @@ void MainDelegate::InitializeResourceBundle() { <nl>    path = pak_dir.Append(FILE_PATH_LITERAL("content_shell.pak")); <nl>  #endif <nl>   <nl> -  ui::ResourceBundle::InitSharedInstanceWithLocale("", NULL, <nl> +  ui::ResourceBundle::InitSharedInstanceWithLocale("", nullptr, <nl>        ui::ResourceBundle::DO_NOT_LOAD_COMMON_RESOURCES); <nl> -  ui::ResourceBundle::GetSharedInstance().AddDataPackFromPath(path, ui::SCALE_FACTOR_100P); <nl> +  ui::ResourceBundle::GetSharedInstance().AddDataPackFromPath( <nl> +      path, ui::GetSupportedScaleFactors()[0]); <nl>    AddDataPackFromPath(&ui::ResourceBundle::GetSharedInstance(), path.DirName()); <nl>  } <nl>  
@@ -29,7 +29,8 @@ MenuBar::MenuBar(views::View* window) <nl>      : background_color_(kDefaultColor), window_(window) { <nl>    RefreshColorCache(); <nl>    UpdateViewColors(); <nl> -  SetLayoutManager(new views::BoxLayout(views::BoxLayout::kHorizontal)); <nl> +  SetLayoutManager(std::make_unique<views::BoxLayout>( <nl> +      views::BoxLayout::kHorizontal)); <nl>    window_->GetFocusManager()->AddFocusChangeListener(this); <nl>  } <nl>  
@@ -1,4 +1,10 @@ <nl>  /* unzip.c -- IO for uncompress .zip files using zlib <nl> + <nl> +   Modified for Quake III Arena to use the Z_Malloc() memory pool; <nl> +   this means a system copy of minizip is not a suitable replacement. <nl> + <nl> +   Based on minizip: <nl> + <nl>     Version 1.01e, February 12th, 2005 <nl>   <nl>     Copyright (C) 1998-2005 Gilles Vollant
@@ -45,8 +45,7 @@ int dump_event_stats(int sd) <nl>  	unsigned int i; <nl>   <nl>  	for (i = 0; i < ARRAY_SIZE(event_count); i++) { <nl> -		nsock_printf(sd, "%s=%u%c", EVENT_TYPE_STR(i), event_count[i], <nl> -		             i == EVENT_USER_FUNCTION ? '\0' : ';'); <nl> +		nsock_printf(sd, "%s=%u;", EVENT_TYPE_STR(i), event_count[i]); <nl>  		/* <nl>  		 * VERSIONFIX: Make EVENT_SLEEP and EVENT_USER_FUNCTION <nl>  		 * appear in linear order in include/nagios.h when we go <nl> @@ -55,6 +54,7 @@ int dump_event_stats(int sd) <nl>  		if (i == 16) <nl>  			i = 97; <nl>  		} <nl> +	nsock_printf_nul(sd, "SQUEUE_ENTRIES=%u", squeue_size(nagios_squeue)); <nl>   <nl>  	return OK; <nl>  	}
@@ -78,7 +78,7 @@ community_del_val (struct community *com, u_int32_t *val) <nl>  	  c = com->size -i -1; <nl>   <nl>  	  if (c > 0) <nl> -	    memcpy (com->val + i, com->val + (i + 1), c * sizeof (val)); <nl> +	    memcpy (com->val + i, com->val + (i + 1), c * sizeof (*val)); <nl>   <nl>  	  com->size--; <nl>  
@@ -735,6 +735,8 @@ int transform_save(struct augeas *aug, struct tree *xfm, <nl>          goto done; <nl>      } <nl>   <nl> +    text = append_newline(text, strlen(text)); <nl> + <nl>      // FIXME: We might have to create intermediary directories <nl>      // to be able to write augnew, but we have no idea what permissions <nl>      // etc. they should get. Just the process default ?
@@ -70,7 +70,7 @@ static const wchar_t *col[]= <nl>      L"magenta", <nl>      L"purple", <nl>      L"cyan", <nl> -    L"white" <nl> +    L"white", <nl>      L"normal" <nl>  } <nl>  ;
@@ -245,7 +245,7 @@ struct parsed_source_t { <nl>      parsed_source_t &operator=(parsed_source_t &&) = default; <nl>  }; <nl>  /// Return a shared pointer to parsed_source_t, or null on failure. <nl> -using parsed_source_ref_t = std::shared_ptr<parsed_source_t>; <nl> +using parsed_source_ref_t = std::shared_ptr<const parsed_source_t>; <nl>  parsed_source_ref_t parse_source(wcstring src, parse_tree_flags_t flags, parse_error_list_t *errors, <nl>                                   parse_token_type_t goal = symbol_job_list); <nl>  
@@ -1626,6 +1626,8 @@ universal_notifier_t::notifier_strategy_t universal_notifier_t::resolve_default_ <nl>      } <nl>  #if FISH_NOTIFYD_AVAILABLE <nl>      return strategy_notifyd; <nl> +#elif defined(__CYGWIN__) <nl> +    return strategy_shmem_polling; <nl>  #else <nl>      return strategy_named_pipe; <nl>  #endif
@@ -81,6 +81,15 @@ namespace tnt <nl>    inline std::string toString(char value, const std::locale&) <nl>    { return std::string(1, value); } <nl>   <nl> +  inline std::string toString(bool value) <nl> +  { <nl> +    static const std::string trueValue = "1"; <nl> +    return value ? trueValue : std::string(); <nl> +  } <nl> + <nl> +  inline std::string toString(bool value, const std::locale&) <nl> +  { return toString(value); } <nl> + <nl>    // convert std::string to some type <nl>   <nl>    template <typename T>
@@ -339,6 +339,12 @@ genop_peep(codegen_scope *s, mrb_code i, int val) <nl>            return 0; <nl>          } <nl>        } <nl> +      if (c0 == OP_LOADNIL) { <nl> +        if (GETARG_B(i) == GETARG_A(i0)) { <nl> +          s->pc--; <nl> +          return 0; <nl> +        } <nl> +      } <nl>        break; <nl>      case OP_JMPIF: <nl>      case OP_JMPNOT:
@@ -2586,7 +2586,7 @@ mrb_str_inspect(mrb_state *mrb, mrb_value str) <nl>          buf[i] = p[i]; <nl>        } <nl>        mrb_str_cat(mrb, result, buf, clen); <nl> -      p += clen; <nl> +      p += clen-1; <nl>        continue; <nl>      } <nl>  #endif
@@ -539,7 +539,9 @@ mrb_read_irep_file(mrb_state *mrb, FILE* fp) <nl>    size_t sirep; <nl>    struct rite_section_header section_header; <nl>    long fpos; <nl> -  const size_t block_size = 1 << 14; <nl> +  size_t block_size = 1 << 14; <nl> +  const uint8_t block_fallback_count = 4; <nl> +  int i; <nl>    const size_t buf_size = sizeof(struct rite_binary_header); <nl>   <nl>    if ((mrb == NULL) || (fp == NULL)) { <nl> @@ -564,7 +566,10 @@ mrb_read_irep_file(mrb_state *mrb, FILE* fp) <nl>    /* verify CRC */ <nl>    fpos = ftell(fp); <nl>    /* You don't need use SIZE_ERROR as block_size is enough small. */ <nl> -  buf = mrb_malloc(mrb, block_size); <nl> +  for (i = 0; i < block_fallback_count; i++,block_size >>= 1){ <nl> +    buf = mrb_malloc(mrb, block_size); <nl> +    if (buf) break;   <nl> +  } <nl>    if (!buf) { <nl>      return MRB_DUMP_GENERAL_FAILURE; <nl>    }
@@ -1500,7 +1500,7 @@ mrb_ptr_to_str(mrb_state *mrb, void *p) <nl>    struct RString *p_str; <nl>    char *p1; <nl>    char *p2; <nl> -  intptr_t n = (intptr_t)p; <nl> +  uintptr_t n = (uintptr_t)p; <nl>   <nl>    p_str = str_new(mrb, NULL, 2 + sizeof(uintptr_t) * CHAR_BIT / 4); <nl>    p1 = p_str->ptr;
@@ -191,6 +191,10 @@ main(void) <nl>      last_code_line[char_index] = '\0'; <nl>  #else <nl>      char* line = readline(code_block_open ? "* " : "> "); <nl> +    if(line == NULL) { <nl> +      printf("\n"); <nl> +      break; <nl> +    } <nl>      strncat(last_code_line, line, sizeof(last_code_line)-1); <nl>      add_history(line); <nl>      free(line);
@@ -581,14 +581,16 @@ mrb_ary_shift(mrb_state *mrb, mrb_value self) <nl>  static mrb_value <nl>  mrb_ary_shift_m(mrb_state *mrb, mrb_value self) <nl>  { <nl> -  struct RArray *a = mrb_ary_ptr(self); <nl> -  mrb_int len = ARY_LEN(a); <nl>    mrb_int n; <nl> -  mrb_value val; <nl>   <nl>    if (mrb_get_args(mrb, "|i", &n) == 0) { <nl>      return mrb_ary_shift(mrb, self); <nl> -  }; <nl> +  } <nl> + <nl> +  struct RArray *a = mrb_ary_ptr(self); <nl> +  mrb_int len = ARY_LEN(a); <nl> +  mrb_value val; <nl> + <nl>    ary_modify_check(mrb, a); <nl>    if (len == 0 || n == 0) return mrb_ary_new(mrb); <nl>    if (n < 0) mrb_raise(mrb, E_ARGUMENT_ERROR, "negative array shift");
@@ -1644,14 +1644,13 @@ gen_hash(codegen_scope *s, node *tree, int val, int limit) <nl>      } <nl>    } <nl>    if (update) { <nl> -    if (len > 0) { <nl> +    if (val && len > 0) { <nl>        pop_n(len*2+1); <nl>        genop_2(s, OP_HASHADD, cursp(), len); <nl>        push(); <nl>      } <nl>      return -1;                  /* variable length */ <nl>    } <nl> -  if (update) return -1; <nl>    return len; <nl>  } <nl>  
@@ -2091,6 +2091,14 @@ route_owner(struct connection *c <nl>  		    continue; <nl>  		if (src->that.port != srd->that.port) <nl>  		    continue; <nl> + <nl> +		/* with old eroutes/routing, we could not do this. This <nl> +		 * allows a host with two IP's to talk to 1 oter host <nl> +		 * with both IP's using two different tunnels. <nl> +		 */ <nl> +		if (!sameaddr(&src->this.host_addr, &srd->this.host_addr)) <nl> +			continue; <nl> + <nl>  		passert(oriented(*d)); <nl>  		if (srd->routing > best_routing) <nl>  		{
@@ -1348,10 +1348,10 @@ stf_status ikev2_send_certreq(struct state *st, struct msg_digest *md, <nl>  			DBG(DBG_CONTROL, <nl>  			    DBG_log("connection is RW, lookup CA candidates")); <nl>   <nl> -			for (gn = ca; gn != NULL; gn = gn->next) { <nl> +			for (ca = gn; ca != NULL; ca = ca->next) { <nl>  				if (!ikev2_build_and_ship_CR(CERT_X509_SIGNATURE, <nl> -						       gn->name, outpbs, <nl> -						       gn->next == NULL ? np : <nl> +						       ca->name, outpbs, <nl> +						       ca->next == NULL ? np : <nl>  						         ISAKMP_NEXT_v2CERTREQ)) <nl>  					return STF_INTERNAL_ERROR; <nl>  			}
@@ -259,6 +259,7 @@ whack_handle(int whackctlfd) <nl>         close(whackfd); <nl>         return; <nl>      } <nl> +    memset(&msg, 0, sizeof(msg)); <nl>      n = read(whackfd, &msg, sizeof(msg)); <nl>      if (n <= 0) <nl>      {
@@ -4746,10 +4746,13 @@ static stf_status ikev2_child_out_tail(struct msg_digest *md) <nl>   <nl>  		DBG_log("ikev2_child_sa_respond returned STF_FAIL with %s", <nl>  				enum_name(&ikev2_notify_names, v2_notify_num)); <nl> +		return ret; /* abort building the response message */ <nl>  	} else if (ret != STF_OK) { <nl>  		DBG_log("ikev2_child_sa_respond returned %s", <nl>  				enum_name(&stfstatus_name, ret)); <nl> +		return ret; /* abort building the response message */ <nl>  	} <nl> + <nl>  	if (!ikev2_padup_pre_encrypt(pst, &e_pbs_cipher)) <nl>  		return STF_INTERNAL_ERROR; <nl>  
@@ -2959,6 +2959,10 @@ show_connections_status(void) <nl>      { <nl>  	count++; <nl>      } <nl> +    if(count == 0)  <nl> +	/* abort early to avoid a malloc(0) that uclibc does not like */ <nl> +	return; <nl> + <nl>      array = alloc_bytes(sizeof(struct connection *)*count, "connection array"); <nl>   <nl>      count=0;
@@ -989,19 +989,20 @@ log_state(struct state *st, enum state_kind new_state) <nl>  	case tun_phase15: tun = "phase15"; break; <nl>  	case tun_phase2:  tun = "phase2";  break; <nl>  	case tun_up:      tun = "up";      break; <nl> -	default:          tun = "unknown"; break; <nl> +	case tun_down:    tun = "down";    break; /* not set anywher */ <nl> +	default:          tun = "down"; break; <nl>  	} <nl>   <nl>  	switch (lc.phase1) { <nl>  	case p1_init:     p1 = "init";    break; <nl>  	case p1_encrypt:  p1 = "encrypt"; break; <nl>  	case p1_auth:     p1 = "auth";    break; <nl> -	default:          p1 = "unknown"; break; <nl> +	default:          p1 = "down"; break; <nl>  	} <nl>   <nl>  	switch (lc.phase2) { <nl>  	case p2_neg:      p2 = "neg";     break; <nl> -	default:          p2 = "unknown";  break; <nl> +	default:          p2 = "down";  break; <nl>  	} <nl>   <nl>  
@@ -198,6 +198,8 @@ cupsdCreateProfile(int job_id,		/* I - Job ID or 0 for none */ <nl>                   " #\"^/usr/bin/\""	/* /usr/bin/... */ <nl>                   " #\"^/usr/libexec/cups$\""	/* /usr/libexec/cups */ <nl>                   " #\"^/usr/libexec/cups/\""	/* /usr/libexec/cups/... */ <nl> +                 " #\"^/usr/libexec/fax$\""	/* /usr/libexec/fax */ <nl> +                 " #\"^/usr/libexec/fax/\""	/* /usr/libexec/fax/... */ <nl>                   " #\"^/usr/sbin$\""	/* /usr/sbin */ <nl>                   " #\"^/usr/sbin/\""	/* /usr/sbin/... */ <nl>  		 " #\"^/Library/Application Support$\"" <nl> @@ -248,6 +250,7 @@ cupsdCreateProfile(int job_id,		/* I - Job ID or 0 for none */ <nl>                   " #\"^/usr/sbin/\""	/* /usr/sbin/... */ <nl>  		 " #\"^%s/\""		/* ServerBin/... */ <nl>  		 " #\"^/Library/Printers/.*/\"" <nl> +		 " #\"^/System/Library/Frameworks/Python.framework/\"" <nl>  		 "))\n", <nl>  		 bin); <nl>    if (RunUser && getenv("CUPS_TESTROOT"))
@@ -994,7 +994,7 @@ cherokee_handler_proxy_init (cherokee_handler_proxy_t *hdl) <nl>  				return ret_eagain; <nl>  			case ret_deny: <nl>  				/* Multiple IPs on a single source */ <nl> -				if (hdl->pconn->addr_current < hdl->pconn->addr_total) { <nl> +				if (hdl->pconn->addr_current < hdl->pconn->addr_total - 1) { <nl>  					hdl->pconn->addr_current += 1; <nl>  					cherokee_socket_close (&hdl->pconn->socket); <nl>  					cherokee_socket_clean (&hdl->pconn->socket); <nl> @@ -1013,16 +1013,15 @@ cherokee_handler_proxy_init (cherokee_handler_proxy_t *hdl) <nl>   <nl>  					/* Spawn a new process <nl>  					 */ <nl> -					ret = cherokee_virtual_server_get_error_log (CONN_VSRV(conn), <nl> -										     &error_writer); <nl> +					ret = cherokee_virtual_server_get_error_log (CONN_VSRV(conn), &error_writer); <nl>  					if (ret != ret_ok) { <nl>  						return ret_error; <nl>  					} <nl>   <nl> -					ret = cherokee_source_interpreter_spawn (SOURCE_INT(hdl->src_ref), <nl> -										 error_writer); <nl> +					ret = cherokee_source_interpreter_spawn (SOURCE_INT(hdl->src_ref), error_writer); <nl>  					switch (ret) { <nl>  					case ret_ok: <nl> +						hdl->pconn->addr_current = 0; <nl>  						break; <nl>  					case ret_eagain: <nl>  						return ret_eagain;
@@ -47,11 +47,15 @@ ExprResolveLhs(struct xkb_context *ctx, const ExprDef *expr, <nl>          *elem_rtrn = xkb_atom_text(ctx, expr->field_ref.element); <nl>          *field_rtrn = xkb_atom_text(ctx, expr->field_ref.field); <nl>          *index_rtrn = NULL; <nl> -        return true; <nl> +        return (*elem_rtrn != NULL && *field_rtrn != NULL); <nl>      case EXPR_ARRAY_REF: <nl>          *elem_rtrn = xkb_atom_text(ctx, expr->array_ref.element); <nl>          *field_rtrn = xkb_atom_text(ctx, expr->array_ref.field); <nl>          *index_rtrn = expr->array_ref.entry; <nl> +	if (expr->array_ref.element != XKB_ATOM_NONE && *elem_rtrn == NULL) <nl> +		return false; <nl> +	if (*field_rtrn == NULL) <nl> +		return false; <nl>          return true; <nl>      default: <nl>          break;
@@ -1099,6 +1099,7 @@ get_controls(struct xkb_keymap *keymap, xcb_connection_t *conn, <nl>          xcb_xkb_get_controls_reply(conn, cookie, NULL); <nl>   <nl>      FAIL_IF_BAD_REPLY(reply, "XkbGetControls"); <nl> +    FAIL_UNLESS(reply->numGroups > 0 && reply->numGroups <= 4); <nl>   <nl>      keymap->enabled_ctrls = translate_controls_mask(reply->enabledControls); <nl>      keymap->num_groups = reply->numGroups;
@@ -387,13 +387,15 @@ TEST(signal, rt_tgsigqueueinfo) { <nl>      "* https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=66dd34ad31e5963d72a700ec3f2449291d322921\n"; <nl>    static siginfo received; <nl>   <nl> -  struct sigaction handler = {}; <nl> +  struct sigaction handler; <nl> +  memset(&handler, 0, sizeof(handler)); <nl>    handler.sa_sigaction = [](int, siginfo_t* siginfo, void*) { received = *siginfo; }; <nl>    handler.sa_flags = SA_SIGINFO; <nl>   <nl>    ASSERT_EQ(0, sigaction(SIGUSR1, &handler, nullptr)); <nl>   <nl> -  siginfo sent = {}; <nl> +  siginfo sent; <nl> +  memset(&sent, 0, sizeof(sent)); <nl>   <nl>    sent.si_code = SI_TKILL; <nl>    ASSERT_EQ(0, syscall(SYS_rt_tgsigqueueinfo, getpid(), gettid(), SIGUSR1, &sent))
@@ -3215,9 +3215,14 @@ void init_default_namespace() { <nl>      g_default_ld_paths = kDefaultLdPaths; <nl>    } <nl>   <nl> +  char real_path[PATH_MAX]; <nl>    std::vector<std::string> ld_default_paths; <nl>    for (size_t i = 0; g_default_ld_paths[i] != nullptr; ++i) { <nl> -    ld_default_paths.push_back(g_default_ld_paths[i]); <nl> +    if (realpath(g_default_ld_paths[i], real_path) != nullptr) { <nl> +      ld_default_paths.push_back(real_path); <nl> +    } else { <nl> +      ld_default_paths.push_back(g_default_ld_paths[i]); <nl> +    } <nl>    } <nl>   <nl>    g_default_namespace.set_default_library_paths(std::move(ld_default_paths));
@@ -135,7 +135,7 @@ extern char*  ptsname(int); <nl>  extern int    ptsname_r(int, char*, size_t); <nl>  extern int    getpt(void); <nl>   <nl> -static __inline__ int grantpt(int __fd) <nl> +static __inline__ int grantpt(int __fd __attribute((unused))) <nl>  { <nl>    (void)__fd; <nl>    return 0;     /* devpts does this all for us! */
@@ -245,6 +245,7 @@ static id_t app_id_from_name(const char* name, bool is_group) { <nl>          appid = android_ids[n].aid; <nl>          // Move the end pointer to the null terminator. <nl>          end += strlen(android_ids[n].name) + 1; <nl> +        break; <nl>        } <nl>      } <nl>    }
@@ -477,6 +477,11 @@ namespace Js <nl>   <nl>      bool JavascriptArray::IsMissingItem(uint32 index) <nl>      { <nl> +        if (this->length <= index) <nl> +        { <nl> +            return false; <nl> +        } <nl> + <nl>          bool isIntArray = false, isFloatArray = false; <nl>          this->GetArrayTypeAndConvert(&isIntArray, &isFloatArray); <nl>   <nl> @@ -5767,7 +5772,7 @@ namespace Js <nl>          // Prototype lookup for missing elements <nl>          if (!pArr->HasNoMissingValues()) <nl>          { <nl> -            for (uint32 i = 0; i < newLen; i++) <nl> +            for (uint32 i = 0; i < newLen && (i + start) < pArr->length; i++) <nl>              { <nl>                  // array type might be changed in the below call to DirectGetItemAtFull <nl>                  // need recheck array type before checking array item [i + start]
@@ -334,10 +334,11 @@ void FrameFactory::rebuildAggregateFrames(ID3v2::Tag *tag) const <nl>       tag->frameList("TDAT").size() == 1) <nl>    { <nl>      TextIdentificationFrame *tdrc = <nl> -      static_cast<TextIdentificationFrame *>(tag->frameList("TDRC").front()); <nl> +      dynamic_cast<TextIdentificationFrame *>(tag->frameList("TDRC").front()); <nl>      UnknownFrame *tdat = static_cast<UnknownFrame *>(tag->frameList("TDAT").front()); <nl>   <nl> -    if(tdrc->fieldList().size() == 1 && <nl> +    if(tdrc && <nl> +       tdrc->fieldList().size() == 1 && <nl>         tdrc->fieldList().front().size() == 4 && <nl>         tdat->data().size() >= 5) <nl>      {
@@ -363,7 +363,7 @@ ByteVector ByteVector::mid(uint index, uint length) const <nl>   <nl>    ConstIterator endIt; <nl>   <nl> -  if(length < 0xffffffff && length + index < size()) <nl> +  if(length < size() - index) <nl>      endIt = d->data.begin() + index + length; <nl>    else <nl>      endIt = d->data.end();
@@ -2478,7 +2478,7 @@ bool check_value_range( void ) <nl>      for ( cmp = 0; cmp < cmpc; cmp++ ) { <nl>      for ( bpos = 0; bpos < 64; bpos++ ) { <nl>          absmax = MAX_V( cmp, bpos ); <nl> -        for ( dpos = 0; dpos < cmpnfo[cmp].bc; dpos++ ) { <nl> +        for ( dpos = 0; dpos < cmpnfo[cmp].bc && dpos < max_dpos[cmp] ; dpos++ ) { <nl>              if ( ( colldata.at_nosync((BlockType)cmp,bpos,dpos) > absmax ) || <nl>                   ( colldata.at_nosync((BlockType)cmp,bpos,dpos) < -absmax ) ) { <nl>                  if (!early_eof_encountered) {
@@ -791,7 +791,9 @@ QPixmap * Covers::get(const Song &song, int size) <nl>   <nl>  void Covers::coverDownloaded(const Song &song, const QImage &img, const QString &file) <nl>  { <nl> -    clearCache(song, img, true); <nl> +    if (!img.isNull()) { <nl> +        clearCache(song, img, true); <nl> +    } <nl>      gotAlbumCover(song, img, file); <nl>  } <nl>  
@@ -1109,6 +1109,10 @@ void FancyTabWidget::SetIcon(int index, const QIcon &icon) <nl>      if (index>0 && index<items_.count()) { <nl>          items_[index].tab_icon_=icon; <nl>      } <nl> +    if (menu_) { <nl> +        menu_->deleteLater(); <nl> +        menu_=0; <nl> +    } <nl>  } <nl>   <nl>  void FancyTabWidget::Recreate()
@@ -134,6 +134,7 @@ CacheItem::CacheItem(const QString &title, const QString &d, const QStringList & <nl>   <nl>  CacheItem::~CacheItem() <nl>  { <nl> +    delete counter; <nl>  } <nl>   <nl>  void CacheItem::update(int itemCount, int space)
@@ -841,6 +841,10 @@ raptor_rss10_build_items(raptor_rss10_serializer_context *rss_serializer) <nl>      s=(raptor_statement*)raptor_sequence_get_at(rss_serializer->triples, i); <nl>      if(!s) <nl>        continue; <nl> +     <nl> +    /* skip triples that are not ? ? <uri> */ <nl> +    if(s->object_type != RAPTOR_IDENTIFIER_TYPE_RESOURCE) <nl> +      continue; <nl>   <nl>      if(s->subject_type == RAPTOR_IDENTIFIER_TYPE_ANONYMOUS) <nl>        fake_uri=raptor_new_uri((unsigned char*)s->subject); <nl> @@ -848,6 +852,8 @@ raptor_rss10_build_items(raptor_rss10_serializer_context *rss_serializer) <nl>        fake_uri=raptor_uri_copy((raptor_uri*)s->subject); <nl>         <nl>      if(raptor_uri_equals(fake_uri, rss_serializer->seq_uri)) { <nl> +      /* found <seq URI> <some predicate> <some URI> triple */ <nl> + <nl>        if(s->predicate_type == RAPTOR_IDENTIFIER_TYPE_ORDINAL) <nl>          ordinal= *((int*)s->predicate); <nl>        else { /* predicate is a resource */
@@ -76,6 +76,9 @@ raptor_stringbuffer_append_turtle_string(raptor_stringbuffer* stringbuffer, <nl>    const unsigned char *s; <nl>    unsigned char *d; <nl>    unsigned char *string=(unsigned char *)RAPTOR_MALLOC(cstring, len+1); <nl> +   <nl> +  if(!string) <nl> +    return -1; <nl>   <nl>    for(s=text, d=string, i=0; i<len; s++, i++) { <nl>      unsigned char c=*s;
@@ -181,9 +181,10 @@ raptor_xml_writer_start_element_common(raptor_xml_writer* xml_writer, <nl>    size_t nspace_declarations_count = 0;   <nl>    unsigned int i; <nl>   <nl> -  /* max is 1 per element and 1 for each attribute + size of declared */ <nl>    if(nstack) { <nl> -    int nspace_max_count = element->attribute_count+1; <nl> +    int nspace_max_count = element->attribute_count * 2; /* attr and value */ <nl> +    if(element->name->nspace) <nl> +      nspace_max_count++; <nl>      if(element->declared_nspaces) <nl>        nspace_max_count += raptor_sequence_size(element->declared_nspaces); <nl>      if(element->xml_language) <nl> @@ -237,7 +238,7 @@ raptor_xml_writer_start_element_common(raptor_xml_writer* xml_writer, <nl>          } <nl>        } <nl>   <nl> -      /* Add the attribute + value */ <nl> +      /* Add the attribute's value */ <nl>        nspace_declarations[nspace_declarations_count].declaration= <nl>          raptor_qname_format_as_xml(element->attributes[i], <nl>                                     &nspace_declarations[nspace_declarations_count].length);
@@ -514,8 +514,11 @@ raptor_rdfxmla_emit_subject_properties(raptor_serializer* serializer, <nl>                  subject->node->count_as_object); <nl>   <nl>    /* Emit any rdf:_n properties collected */ <nl> -  if(raptor_sequence_size(subject->list_items) > 0) <nl> +  if(raptor_sequence_size(subject->list_items) > 0) { <nl>      rv = raptor_rdfxmla_emit_subject_list_items(serializer, subject, depth+1); <nl> +    if(rv) <nl> +      return rv; <nl> +  } <nl>   <nl>    for(i=0, rv=raptor_avltree_cursor_first(subject->properties); <nl>        !rv;
@@ -1,6 +1,6 @@ <nl>  /* -*- Mode: c; c-basic-offset: 2 -*- <nl>   * <nl> - * raptor_serialize_rss.c - Raptor RSS 1.0 serializer <nl> + * raptor_serialize_rss.c - Raptor RSS 1.0 and Atom 1.0 serializers <nl>   * <nl>   * Copyright (C) 2003-2006, David Beckett http://purl.org/net/dajobe/ <nl>   * Copyright (C) 2003-2005, University of Bristol, UK http://www.bristol.ac.uk/ <nl> @@ -779,10 +779,12 @@ raptor_rss10_emit_item(raptor_serializer* serializer, <nl>        } else { <nl>          /* not a URI, must be a literal */ <nl>          raptor_xml_writer_start_element(xml_writer, predicate); <nl> -        if(f == RAPTOR_RSS_FIELD_CONTENT_ENCODED) { <nl> +        if(!is_atom && f == RAPTOR_RSS_FIELD_CONTENT_ENCODED) { <nl>            raptor_xml_writer_raw_counted(xml_writer, (const unsigned char*)"<![CDATA[", 9); <nl>            raptor_xml_writer_raw(xml_writer, (const unsigned char*)field->value); <nl>            raptor_xml_writer_raw_counted(xml_writer, (const unsigned char*)"]]>", 3); <nl> +        } else if(is_atom && f == RAPTOR_RSS_FIELD_ATOM_SUMMARY) { <nl> +          raptor_xml_writer_raw(xml_writer, (const unsigned char*)field->value); <nl>          } else <nl>            raptor_xml_writer_cdata(xml_writer, (const unsigned char*)field->value); <nl>          raptor_xml_writer_end_element(xml_writer, predicate);
@@ -435,9 +435,13 @@ static void CMSExceptionHandler(cmsContext context,cmsUInt32Number severity, <nl>    Image <nl>      *image; <nl>   <nl> +  image=(Image *) NULL; <nl>    cms_exception=(CMSExceptionInfo *) context; <nl> -  image=cms_exception->image; <nl> -  exception=cms_exception->exception; <nl> +  if (cms_exception != (CMSExceptionInfo *) NULL) <nl> +    { <nl> +      image=cms_exception->image; <nl> +      exception=cms_exception->exception; <nl> +    } <nl>    if (image == (Image *) NULL) <nl>      { <nl>        (void) ThrowMagickException(exception,GetMagickModule(),ImageWarning,
@@ -1061,10 +1061,10 @@ MagickExport ResizeFilter *AcquireResizeFilter(const Image *image, <nl>          if (resize_filter->filter == SincFast)  filter_type=SincFastFilter; <nl>          if (resize_filter->filter == Jinc)      filter_type=JincFilter; <nl>          if (resize_filter->filter == CubicBC)   filter_type=CubicFilter; <nl> -        if (resize_filter->filter == Box)       window_type=BoxFilter; <nl> +        if (resize_filter->window == Box)       window_type=BoxFilter; <nl>          if (resize_filter->window == Sinc)      window_type=SincFilter; <nl>          if (resize_filter->window == SincFast)  window_type=SincFastFilter; <nl> -        if (resize_filter->filter == Jinc)      window_type=JincFilter; <nl> +        if (resize_filter->window == Jinc)      window_type=JincFilter; <nl>          if (resize_filter->window == CubicBC)   window_type=CubicFilter; <nl>          /* <nl>            Report Filter Details.
@@ -487,6 +487,7 @@ static ssize_t DecodePSDPixels(const size_t number_compact_pixels, <nl>      length++; <nl>      for (j=0; j < (ssize_t) length; j++) <nl>      { <nl> +      CheckNumberCompactPixels; <nl>        switch (depth) <nl>        { <nl>          case 1: <nl> @@ -525,7 +526,6 @@ static ssize_t DecodePSDPixels(const size_t number_compact_pixels, <nl>            break; <nl>          } <nl>        } <nl> -      CheckNumberCompactPixels; <nl>        compact_pixels++; <nl>      } <nl>    }
@@ -212,6 +212,7 @@ static Image *ReadYCBCRImage(const ImageInfo *image_info, <nl>      if (status == MagickFalse) <nl>      { <nl>        quantum_info=DestroyQuantumInfo(quantum_info); <nl> +      canvas_image=DestroyImage(canvas_image); <nl>        return(DestroyImageList(image)); <nl>      } <nl>      SetImageColorspace(image,YCbCrColorspace,exception);
@@ -3479,7 +3479,9 @@ static MagickBooleanType WriteTIFFImage(const ImageInfo *image_info, <nl>        if ((image_info->interlace == PlaneInterlace) || <nl>            (image_info->interlace == PartitionInterlace)) <nl>          (void) TIFFSetField(tiff,TIFFTAG_PLANARCONFIG,PLANARCONFIG_SEPARATE); <nl> -     rows_per_strip=TIFFDefaultStripSize(tiff,0); <nl> +    rows_per_strip=1; <nl> +    if (TIFFScanlineSize(tiff) != 0) <nl> +      rows_per_strip=TIFFDefaultStripSize(tiff,0); <nl>      option=GetImageOption(image_info,"tiff:rows-per-strip"); <nl>      if (option != (const char *) NULL) <nl>        rows_per_strip=(size_t) strtol(option,(char **) NULL,10);
@@ -1936,7 +1936,7 @@ static Image *ReadPSDImage(const ImageInfo *image_info,ExceptionInfo *exception) <nl>        if (blocks == (unsigned char *) NULL) <nl>          ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed"); <nl>        count=ReadBlob(image,(size_t) length,blocks); <nl> -      if ((count != (ssize_t) length) || <nl> +      if ((count != (ssize_t) length) || (length < 4) || <nl>            (LocaleNCompare((char *) blocks,"8BIM",4) != 0)) <nl>          { <nl>            blocks=(unsigned char *) RelinquishMagickMemory(blocks);
@@ -1908,6 +1908,8 @@ static Image *ReadPSDImage(const ImageInfo *image_info,ExceptionInfo *exception) <nl>            image->alpha_trait=UndefinedPixelTrait; <nl>          } <nl>      } <nl> +  if ((image->depth == 1) && (image->storage_class != PseudoClass)) <nl> +    ThrowReaderException(CorruptImageError, "ImproperImageHeader"); <nl>    has_merged_image=MagickTrue; <nl>    length=ReadBlobMSBLong(image); <nl>    if (length != 0)
@@ -571,6 +571,7 @@ private: <nl>  				} <nl>  			} <nl>  			 <nl> +			UPDATE_TRACE_POINT(); <nl>  			APR_BRIGADE_INSERT_TAIL(bb, b); <nl>   <nl>  			b = apr_bucket_eos_create(r->connection->bucket_alloc);
@@ -304,6 +304,8 @@ public: <nl>  			str_format(aPath, sizeof(aPath), "%s/%s", Data.pPath, pName); <nl>  			Data.pPath = aPath; <nl>  			fs_listdir(Data.pStorage->GetPath(Type, aPath, aBuf, sizeof(aBuf)), FindFileCallback, Type, &Data); <nl> +			if(Data.pBuffer[0]) <nl> +				return 1; <nl>  		} <nl>  		else if(!str_comp(pName, Data.pFilename)) <nl>  		{ <nl> @@ -333,7 +335,11 @@ public: <nl>  		{ <nl>  			// search within all available directories <nl>  			for(int i = 0; i < m_NumPaths; ++i) <nl> +			{ <nl>  				fs_listdir(GetPath(i, pPath, aBuf, sizeof(aBuf)), FindFileCallback, i, &Data); <nl> +				if(pBuffer[0]) <nl> +					return true; <nl> +			} <nl>  		} <nl>  		else if(Type >= 0 && Type < m_NumPaths) <nl>  		{
@@ -150,7 +150,8 @@ void CInput::Update() <nl>  			{ <nl>  				// handle keys <nl>  				case SDL_KEYDOWN: <nl> -					if(Event.key.keysym.unicode < 255)	// ignore_convention <nl> +					// skip private use area of the BMP(contains the unicodes for keyboard function keys on MacOS) <nl> +					if(Event.key.keysym.unicode < 0xE000 || Event.key.keysym.unicode > 0xF8FF)	// ignore_convention <nl>  						AddEvent(Event.key.keysym.unicode, 0, 0); // ignore_convention <nl>                      Key = Event.key.keysym.sym;  // ignore_convention <nl>  					break;
@@ -182,6 +182,7 @@ epoll_init(struct event_base *base) <nl>  		fd = epollop->timerfd = timerfd_create(CLOCK_MONOTONIC, TFD_NONBLOCK|TFD_CLOEXEC); <nl>  		if (epollop->timerfd >= 0) { <nl>  			struct epoll_event epev; <nl> +			memset(&epev, 0, sizeof(epev)); <nl>  			epev.data.fd = epollop->timerfd; <nl>  			epev.events = EPOLLIN; <nl>  			if (epoll_ctl(epollop->epfd, EPOLL_CTL_ADD, fd, &epev) < 0) {
@@ -1426,7 +1426,7 @@ int   Ftp::Do() <nl>        if(state!=CONNECTED_STATE || Error()) <nl>  	 return MOVED; <nl>   <nl> -      if(expect->Has(Expect::FEAT)) <nl> +      if(expect->Has(Expect::FEAT) || conn->quit_sent) <nl>  	 goto usual_return; <nl>   <nl>  #if USE_SSL
@@ -31,7 +31,7 @@ mmvJob::mmvJob(FileAccess *session,const ArgV *args,const char *t,FA::open_mode <nl>  { <nl>     op.set(args->a0()); <nl>     for(int i=args->getindex(); i<args->count(); i++) <nl> -      wcd.push(strdup(args->getarg(i))); <nl> +      wcd.push(xstrdup(args->getarg(i))); <nl>  } <nl>   <nl>  void mmvJob::doOpen() const
@@ -114,7 +114,7 @@ public: <nl>  	 if(o || !n) <nl>  	    return; <nl>  	 downloader=new const TorrentPeer*[blk_count]; <nl> -	 for(int i=0; i<blk_count; i++) <nl> +	 for(unsigned i=0; i<blk_count; i++) <nl>  	    downloader[i]=0; <nl>        } <nl>        const TorrentPeer*& d=downloader[block];
@@ -847,7 +847,12 @@ _zip_read_eocd64(zip_source_t *src, zip_buffer_t *buffer, zip_uint64_t buf_offse <nl>          zip_error_set(error, ZIP_ER_SEEK, EFBIG); <nl>          return NULL; <nl>      } <nl> -    if ((flags & ZIP_CHECKCONS) && offset+size != eocd_offset) { <nl> +    if (offset+size > buf_offset + eocd_offset) { <nl> +	/* cdir spans past EOCD record */ <nl> +	zip_error_set(error, ZIP_ER_INCONS, 0); <nl> +	return NULL; <nl> +    } <nl> +    if ((flags & ZIP_CHECKCONS) && offset+size != buf_offset + eocd_offset) { <nl>  	zip_error_set(error, ZIP_ER_INCONS, 0); <nl>  	return NULL; <nl>      }
@@ -444,6 +444,7 @@ add_data_uncomp(struct zip *za, zip_source_callback cb, void *ud, <nl>   <nl>      zstr.next_out = (Bytef *)b2; <nl>      zstr.avail_out = sizeof(b2); <nl> +    zstr.next_in = NULL; <nl>      zstr.avail_in = 0; <nl>   <nl>      flush = 0;
@@ -105,7 +105,7 @@ _zip_cdir_new(zip_uint64_t nentry, zip_error_t *error) <nl>   <nl>      if (nentry == 0) <nl>  	cd->entry = NULL; <nl> -    else if ((cd->entry=(zip_entry_t *)malloc(sizeof(*(cd->entry))*(size_t)nentry)) == NULL) { <nl> +    else if ((nentry > SIZE_MAX/sizeof(*(cd->entry))) || (cd->entry=(zip_entry_t *)malloc(sizeof(*(cd->entry))*(size_t)nentry)) == NULL) { <nl>  	zip_error_set(error, ZIP_ER_MEMORY, 0); <nl>  	free(cd); <nl>  	return NULL;
@@ -1136,7 +1136,11 @@ int uv_write(uv_write_t* req, uv_stream_t* handle, uv_buf_t bufs[], int bufcnt, <nl>        && "uv_write (unix) does not yet support other types of streams"); <nl>   <nl>    empty_queue = (stream->write_queue_size == 0); <nl> -  assert(stream->fd >= 0); <nl> + <nl> +  if (stream->fd < 0) { <nl> +    uv_err_new((uv_handle_t*)stream, EBADF); <nl> +    return -1; <nl> +  } <nl>   <nl>    ngx_queue_init(&req->queue); <nl>    req->type = UV_WRITE;
@@ -747,7 +747,8 @@ static int uv__ifaddr_exclude(struct ifaddrs *ent) { <nl>      return 1; <nl>    if (ent->ifa_addr == NULL) <nl>      return 1; <nl> -  if (ent->ifa_addr->sa_family == PF_PACKET) <nl> +  if (ent->ifa_addr->sa_family != AF_INET && <nl> +      ent->ifa_addr->sa_family != AF_INET6) <nl>      return 1; <nl>    return 0; <nl>  }
@@ -3611,6 +3611,7 @@ static const char  *static_camera_list[] = <nl>  //"Leica S3", <nl>  "Leica T (Typ 701)", <nl>  "Leica X1", <nl> +"Leica X (Typ 113)", <nl>  "Leica X2", <nl>  "Leica V-LUX1", <nl>  "Leica V-LUX2",
@@ -1144,8 +1144,8 @@ int LibRaw::unpack(void) <nl>                  IO.shrink = 0; <nl>  				S.raw_pitch = S.width*8; <nl>                  // allocate image as temporary buffer, size  <nl> -                imgdata.rawdata.raw_alloc = calloc(S.iwidth*S.iheight,sizeof(*imgdata.image)); <nl> -                imgdata.image = (ushort (*)[4]) imgdata.rawdata.raw_alloc; <nl> +                imgdata.rawdata.raw_alloc = 0; <nl> +                imgdata.image = (ushort (*)[4]) calloc(S.iwidth*S.iheight,sizeof(*imgdata.image)); <nl>                } <nl>              ID.input->seek(libraw_internal_data.unpacker_data.data_offset, SEEK_SET); <nl>   <nl> @@ -1155,6 +1155,12 @@ int LibRaw::unpack(void) <nl>              (this->*load_raw)(); <nl>  			if(load_raw == &LibRaw::unpacked_load_raw && !strcasecmp(imgdata.idata.make,"Nikon")) <nl>  				C.maximum = m_save; <nl> +			if (decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY) <nl> +			{ <nl> +				// successfully decoded legacy image, attach image to raw_alloc <nl> +				imgdata.rawdata.raw_alloc = imgdata.image; <nl> +				imgdata.image = 0;  <nl> +			} <nl>            } <nl>   <nl>          if(imgdata.rawdata.raw_image)
@@ -21,10 +21,10 @@ <nl>  #include <assert.h> <nl>  #include <string.h> <nl>   <nl> -#if defined (__linux__) <nl> -#include <ucontext.h> <nl> -#elif defined (__APPLE__) <nl> +#if defined (__APPLE__) <nl>  #include <sys/ucontext.h> <nl> +#else <nl> +#include <ucontext.h> <nl>  #endif <nl>   <nl>  #include <limits.h>
@@ -217,8 +217,9 @@ int mk_http_init(struct client_request *cr, struct request *sr) <nl>                  } <nl>          } <nl>   <nl> -        /* read permission */  <nl> -        if(sr->file_info->read_access == MK_FILE_FALSE){ <nl> +        /* read permissions and check file */  <nl> +        if(sr->file_info->read_access == MK_FILE_FALSE || <nl> +           sr->file_info->is_directory == MK_FILE_TRUE){ <nl>                  mk_request_error(M_CLIENT_FORBIDDEN, cr, sr, 1, sr->log); <nl>                  return -1;       <nl>          }
@@ -437,7 +437,7 @@ recorder_record_frame (ShellRecorder *recorder) <nl>   <nl>    size = recorder->area.width * recorder->area.height * 4; <nl>   <nl> -  data = g_malloc (recorder->area.width * 4 * recorder->area.height); <nl> +  data = g_malloc (size); <nl>    cogl_framebuffer_read_pixels (cogl_get_draw_framebuffer (), <nl>                                  recorder->area.x, <nl>                                  recorder->area.y,
@@ -6,6 +6,7 @@ <nl>  #include <glib.h> <nl>   <nl>  #include "window.h" <nl> +#include "shell-app-system.h" <nl>   <nl>  /*  <nl>   * This object provides monitoring of system application directories (.desktop files) <nl> @@ -37,7 +38,7 @@ GType shell_app_monitor_get_type (void) G_GNUC_CONST; <nl>   <nl>  ShellAppMonitor* shell_app_monitor_get_default(void); <nl>   <nl> -char *shell_app_monitor_get_window_id (ShellAppMonitor *monitor, MetaWindow *metawin); <nl> +ShellAppInfo *shell_app_monitor_get_window_app (ShellAppMonitor *monitor, MetaWindow *metawin); <nl>   <nl>  /* Get the most popular applications for a given activity */ <nl>  GSList *shell_app_monitor_get_most_used_apps (ShellAppMonitor *monitor,
@@ -174,7 +174,6 @@ gnome_shell_plugin_has_swap_event (GnomeShellPlugin *shell_plugin) <nl>    const char * (* query_extensions_string) (Display *dpy, int screen); <nl>    Bool (* query_extension) (Display *dpy, int *error, int *event); <nl>    MetaScreen *screen; <nl> -  MetaDisplay *display; <nl>    Display *xdisplay; <nl>    const char *glx_extensions; <nl>   <nl> @@ -183,9 +182,8 @@ gnome_shell_plugin_has_swap_event (GnomeShellPlugin *shell_plugin) <nl>      return FALSE; <nl>   <nl>    screen = meta_plugin_get_screen (plugin); <nl> -  display = meta_screen_get_display (screen); <nl>   <nl> -  xdisplay = meta_display_get_xdisplay (display); <nl> +  xdisplay = clutter_x11_get_default_display (); <nl>   <nl>    query_extensions_string = <nl>      (void *) cogl_get_proc_address ("glXQueryExtensionsString");
@@ -152,7 +152,7 @@ st_drawing_area_paint (ClutterActor *self) <nl>   <nl>        cogl_set_source (priv->material); <nl>        cogl_rectangle_with_texture_coords (content_box.x1, content_box.y1, <nl> -                                          width, height, <nl> +                                          content_box.x2, content_box.y2, <nl>                                            0.0f, 0.0f, 1.0f, 1.0f); <nl>      } <nl>  }
@@ -155,7 +155,9 @@ static int DetectFileInspect(ThreadVars *tv, DetectEngineThreadCtx *det_ctx, <nl>          /* if we have a filestore sm with a scope > file (so tx, ssn) we <nl>           * run it here */ <nl>          sm = s->sm_lists[DETECT_SM_LIST_FILEMATCH]; <nl> -        if (sm != NULL && sm->next == NULL && sm->type == DETECT_FILESTORE) { <nl> +        if (sm != NULL && sm->next == NULL && sm->type == DETECT_FILESTORE && <nl> +                sm->ctx != NULL) <nl> +        { <nl>              DetectFilestoreData *fd = sm->ctx; <nl>              if (fd->scope > FILESTORE_SCOPE_DEFAULT) { <nl>                  match = sigmatch_table[sm->type].
@@ -258,7 +258,7 @@ static int DNP3CheckStartBytes(const DNP3LinkHeader *header) <nl>   */ <nl>  static int DNP3ContainsBanner(const uint8_t *input, uint32_t len) <nl>  { <nl> -    return memmem(input, len, banner, strlen(banner)) != NULL; <nl> +    return BasicSearch(input, len, (uint8_t *)banner, strlen(banner)) != NULL; <nl>  } <nl>   <nl>  /**
@@ -92,6 +92,12 @@ void JsonTlsLogJSONExtended(json_t *tjs, SSLState * state) <nl>      json_object_set_new(tjs, "fingerprint", <nl>                          json_string(state->server_connp.cert0_fingerprint)); <nl>   <nl> +    /* tls.sni */ <nl> +    if (state->client_connp.sni) { <nl> +        json_object_set_new(tjs, "sni", <nl> +                            json_string(state->client_connp.sni)); <nl> +    } <nl> + <nl>      /* tls.version */ <nl>      switch (state->server_connp.version) { <nl>          case TLS_VERSION_UNKNOWN:
@@ -74,7 +74,8 @@ int DetectHttpHeaderMatch(ThreadVars *t, DetectEngineThreadCtx *det_ctx, <nl>   <nl>      SCMutexLock(&f->m); <nl>   <nl> -    if (htp_state == NULL) { <nl> +    if (htp_state == NULL || htp_state->connp == NULL || <nl> +        htp_state->connp->conn == NULL) { <nl>          SCLogDebug("No htp state, no match at http header data"); <nl>          goto end; <nl>      }
@@ -221,9 +221,9 @@ TmEcode AlertJsonIPv4(ThreadVars *tv, Packet *p, void *data, PacketQueue *pq, Pa <nl>                         "pri", pa->s->prio, <nl>                         "proto", proto, <nl>                         "srcip", srcip, <nl> -                       "srcport", p->sp, <nl> +                       "sp", p->sp, <nl>                         "dstip", dstip, <nl> -                       "dstport", p->dp <nl> +                       "dp", p->dp <nl>                        ); <nl>   <nl>          if (js == NULL) <nl> @@ -311,9 +311,9 @@ TmEcode AlertJsonIPv6(ThreadVars *tv, Packet *p, void *data, PacketQueue *pq, Pa <nl>                         "pri", pa->s->prio, <nl>                         "proto", proto, <nl>                         "srcip", srcip, <nl> -                       "srcport", p->sp, <nl> +                       "sp", p->sp, <nl>                         "dstip", dstip, <nl> -                       "dstport", p->dp <nl> +                       "dp", p->dp <nl>                        ); <nl>   <nl>          if (js == NULL)
@@ -138,7 +138,7 @@ PIMAGE_DATA_DIRECTORY pe_get_directory_entry( <nl>  { <nl>    PIMAGE_DATA_DIRECTORY result; <nl>   <nl> -  if (pe->header->FileHeader.Machine == 0x8664)  // is a 64-bit PE ? <nl> +  if (pe->header->FileHeader.Machine == IMAGE_FILE_MACHINE_AMD64) <nl>      result = &((PIMAGE_NT_HEADERS64) pe->header)-> <nl>          OptionalHeader.DataDirectory[entry]; <nl>    else <nl> @@ -414,7 +414,7 @@ void pe_parse( <nl>    char section_name[IMAGE_SIZEOF_SHORT_NAME + 1]; <nl>   <nl>  #define OptionalHeader(field) \ <nl> -  (pe->header->FileHeader.Machine == 0x8664 ? \ <nl> +  (pe->header->FileHeader.Machine == IMAGE_FILE_MACHINE_AMD64 ? \ <nl>     ((PIMAGE_NT_HEADERS64) pe->header)->OptionalHeader.field : \ <nl>       pe->header->OptionalHeader.field) <nl>  
@@ -335,8 +335,7 @@ LLVMRustSetDataLayoutFromTargetMachine(LLVMModuleRef Module, <nl>                                         LLVMTargetMachineRef TMR) { <nl>      TargetMachine *Target = unwrap(TMR); <nl>  #if LLVM_VERSION_MINOR >= 7 <nl> -    if (const DataLayout *DL = Target->getDataLayout()) <nl> -        unwrap(Module)->setDataLayout(*DL); <nl> +    unwrap(Module)->setDataLayout(Target->createDataLayout()); <nl>  #elif LLVM_VERSION_MINOR >= 6 <nl>      if (const DataLayout *DL = Target->getSubtargetImpl()->getDataLayout()) <nl>          unwrap(Module)->setDataLayout(DL);
@@ -2773,7 +2773,7 @@ void BasicWriter<Char>::write_double( <nl>            spec.width() > static_cast<unsigned>(n)) { <nl>          width = spec.width(); <nl>          CharPtr p = grow_buffer(width); <nl> -        std::memmove(p + (width - n) / 2, p, n * sizeof(Char)); <nl> +        std::memmove(get(p) + (width - n) / 2, get(p), n * sizeof(Char)); <nl>          fill_padding(p, spec.width(), n, fill); <nl>          return; <nl>        }
@@ -945,7 +945,8 @@ static ssize_t data_source_read_callback(nghttp2_session *session, <nl>      memcpy(buf, stream->upload_mem, nread); <nl>      stream->upload_mem += nread; <nl>      stream->upload_len -= nread; <nl> -    stream->upload_left -= nread; <nl> +    if(data_s->state.infilesize != -1) <nl> +      stream->upload_left -= nread; <nl>    } <nl>   <nl>    if(stream->upload_left == 0)
@@ -1408,6 +1408,7 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi, <nl>   <nl>      case CURLM_STATE_TOOFAST: /* limit-rate exceeded in either direction */ <nl>        /* if both rates are within spec, resume transfer */ <nl> +      Curl_pgrsUpdate(easy->easy_conn); <nl>        if( ( (data->set.max_send_speed == 0) || <nl>              (data->progress.ulspeed < data->set.max_send_speed ))  && <nl>            ( (data->set.max_recv_speed == 0) ||
@@ -1563,13 +1563,14 @@ CURLcode Curl_smtp_escape_eob(struct connectdata *conn, const ssize_t nread) <nl>    if(!scratch || data->set.crlf) { <nl>      oldscratch = scratch; <nl>   <nl> -    scratch = newscratch = malloc(2 * data->set.buffer_size); <nl> +    scratch = newscratch = malloc(2 * UPLOAD_BUFSIZE); <nl>      if(!newscratch) { <nl>        failf(data, "Failed to alloc scratch buffer!"); <nl>   <nl>        return CURLE_OUT_OF_MEMORY; <nl>      } <nl>    } <nl> +  DEBUGASSERT(UPLOAD_BUFSIZE >= nread); <nl>   <nl>    /* Have we already sent part of the EOB? */ <nl>    eob_sent = smtp->eob;
@@ -74,7 +74,7 @@ CURLcode Curl_auth_create_plain_message(struct Curl_easy *data, <nl>    plen = strlen(passwdp); <nl>   <nl>    /* Compute binary message length. Check for overflows. */ <nl> -  if((ulen > SIZE_T_MAX/2) || (plen > (SIZE_T_MAX/2 - 2))) <nl> +  if((ulen > SIZE_T_MAX/4) || (plen > (SIZE_T_MAX/2 - 2))) <nl>      return CURLE_OUT_OF_MEMORY; <nl>    plainlen = 2 * ulen + plen + 2; <nl>  
@@ -1002,10 +1002,10 @@ static SECStatus SelectClientCert(void *arg, PRFileDesc *sock, <nl>    struct ssl_connect_data *connssl = (struct ssl_connect_data *)arg; <nl>    struct Curl_easy *data = connssl->data; <nl>    const char *nickname = connssl->client_nickname; <nl> +  static const char pem_slotname[] = "PEM Token #1"; <nl>   <nl>    if(connssl->obj_clicert) { <nl>      /* use the cert/key provided by PEM reader */ <nl> -    static const char pem_slotname[] = "PEM Token #1"; <nl>      SECItem cert_der = { 0, NULL, 0 }; <nl>      void *proto_win = SSL_RevealPinArg(sock); <nl>      struct CERTCertificateStr *cert; <nl> @@ -1067,6 +1067,12 @@ static SECStatus SelectClientCert(void *arg, PRFileDesc *sock, <nl>    if(NULL == nickname) <nl>      nickname = "[unknown]"; <nl>   <nl> +  if(!strncmp(nickname, pem_slotname, sizeof(pem_slotname) - 1U)) { <nl> +    failf(data, "NSS: refusing previously loaded certificate from file: %s", <nl> +          nickname); <nl> +    return SECFailure; <nl> +  } <nl> + <nl>    if(NULL == *pRetKey) { <nl>      failf(data, "NSS: private key not found for certificate: %s", nickname); <nl>      return SECFailure;
@@ -1798,7 +1798,7 @@ static CURLcode ftp_state_mdtm_resp(struct connectdata *conn, <nl>        switch(data->set.timecondition) { <nl>        case CURL_TIMECOND_IFMODSINCE: <nl>        default: <nl> -        if(data->info.filetime < data->set.timevalue) { <nl> +        if(data->info.filetime <= data->set.timevalue) { <nl>            infof(data, "The requested document is not new enough\n"); <nl>            ftp->no_transfer = TRUE; /* mark this to not transfer data */ <nl>            state(conn, FTP_STOP);
@@ -1217,6 +1217,8 @@ CURLcode Curl_disconnect(struct connectdata *conn) <nl>      free(conn->allocptr.cookie); <nl>    if(conn->allocptr.host) <nl>      free(conn->allocptr.host); <nl> +  if(conn->allocptr.cookiehost) <nl> +    free(conn->allocptr.cookiehost); <nl>   <nl>    if(conn->proxyhost) <nl>      free(conn->proxyhost);
@@ -153,17 +153,21 @@ CURLcode Curl_close(struct SessionHandle *data) <nl>    Curl_SSL_Close_All(data); <nl>  #endif <nl>   <nl> +  if(data->state.auth_host) <nl> +    free(data->state.auth_host); <nl> + <nl>    if(data->change.proxy_alloc) <nl>      free(data->change.proxy); <nl> + <nl>    if(data->change.referer_alloc) <nl>      free(data->change.referer); <nl> + <nl>    if(data->change.url_alloc) <nl>      free(data->change.url); <nl>   <nl>    if(data->state.headerbuff) <nl>      free(data->state.headerbuff); <nl>   <nl> - <nl>    if(data->set.cookiejar) <nl>      /* we have a "destination" for all the cookies to get dumped to */ <nl>      Curl_cookie_output(data->cookies, data->set.cookiejar); <nl> @@ -1762,7 +1766,6 @@ static CURLcode Connect(struct SessionHandle *data, <nl>      conn->protocol |= PROT_HTTP; <nl>      conn->curl_do = Curl_http; <nl>      conn->curl_done = Curl_http_done; <nl> -    conn->curl_close = Curl_http_close; <nl>    } <nl>    else if (strequal(conn->protostr, "HTTPS")) { <nl>  #ifdef USE_SSLEAY <nl> @@ -1775,7 +1778,6 @@ static CURLcode Connect(struct SessionHandle *data, <nl>      conn->curl_do = Curl_http; <nl>      conn->curl_done = Curl_http_done; <nl>      conn->curl_connect = Curl_http_connect; <nl> -    conn->curl_close = Curl_http_close; <nl>   <nl>  #else /* USE_SSLEAY */ <nl>      failf(data, LIBCURL_NAME <nl> @@ -1795,7 +1797,6 @@ static CURLcode Connect(struct SessionHandle *data, <nl>      conn->protocol |= PROT_GOPHER; <nl>      conn->curl_do = Curl_http; <nl>      conn->curl_done = Curl_http_done; <nl> -    conn->curl_close = Curl_http_close; <nl>    } <nl>    else if(strequal(conn->protostr, "FTP") || <nl>            strequal(conn->protostr, "FTPS")) { <nl> @@ -1827,7 +1828,6 @@ static CURLcode Connect(struct SessionHandle *data, <nl>        } <nl>        conn->curl_do = Curl_http; <nl>        conn->curl_done = Curl_http_done; <nl> -      conn->curl_close = Curl_http_close; <nl>      } <nl>      else { <nl>        conn->curl_do = Curl_ftp;
@@ -328,6 +328,11 @@ CURLcode Curl_sasl_create_gssapi_user_message(struct SessionHandle *data, <nl>      /* Release the package buffer as it is not required anymore */ <nl>      s_pSecFn->FreeContextBuffer(SecurityPackage); <nl>   <nl> +    /* Allocate our response buffer */ <nl> +    krb5->output_token = malloc(krb5->token_max); <nl> +    if(!krb5->output_token) <nl> +      return CURLE_OUT_OF_MEMORY; <nl> + <nl>      /* Generate our SPN */ <nl>      krb5->spn = Curl_sasl_build_spn(service, data->easy_conn->host.name); <nl>      if(!krb5->spn) <nl> @@ -341,11 +346,6 @@ CURLcode Curl_sasl_create_gssapi_user_message(struct SessionHandle *data, <nl>   <nl>        /* Allow proper cleanup of the identity structure */ <nl>        krb5->p_identity = &krb5->identity; <nl> - <nl> -      /* Allocate our response buffer */ <nl> -      krb5->output_token = malloc(krb5->token_max); <nl> -      if(!krb5->output_token) <nl> -        return CURLE_OUT_OF_MEMORY; <nl>      } <nl>      else <nl>        /* Use the current Windows user */
@@ -651,7 +651,10 @@ static CURLcode ssh_statemach_act(struct connectdata *conn) <nl>        break; <nl>   <nl>      case SSH_SESSION_FREE: <nl> -      libssh2_session_free(ssh->ssh_session); <nl> +      rc = libssh2_session_free(ssh->ssh_session); <nl> +      if (rc == LIBSSH2_ERROR_EAGAIN) { <nl> +        break; <nl> +      } <nl>        ssh->ssh_session = NULL; <nl>        state(conn, SSH_STOP); <nl>        result = sshc->actualCode;
@@ -305,11 +305,15 @@ CURLcode Curl_output_negotiate(struct connectdata *conn, bool proxy) <nl>        infof(conn->data, "Make SPNEGO Initial Token failed\n"); <nl>      } <nl>      else { <nl> -      free(neg_ctx->output_token.value); <nl> +      free(responseToken); <nl>        responseToken = NULL; <nl> +      free(neg_ctx->output_token.value); <nl>        neg_ctx->output_token.value = malloc(spnegoTokenLength); <nl> -      if(neg_ctx->output_token.value == NULL) <nl> +      if(neg_ctx->output_token.value == NULL) { <nl> +        free(spnegoToken); <nl> +        spnegoToken = NULL; <nl>          return CURLE_OUT_OF_MEMORY; <nl> +      } <nl>        memcpy(neg_ctx->output_token.value, spnegoToken,spnegoTokenLength); <nl>        neg_ctx->output_token.length = spnegoTokenLength; <nl>        free(spnegoToken);
@@ -117,6 +117,14 @@ Sys_Print <nl>  ============== <nl>  */ <nl>  void Sys_Print( const char *msg ) { <nl> +	// TTimo - prefix for text that shows up in console but not in notify <nl> +	// backported from RTCW <nl> +	if ( !Q_strncmp( msg, "[skipnotify]", 12 ) ) { <nl> +		msg += 12; <nl> +	} <nl> +	if ( msg[0] == '*' ) { <nl> +		msg += 1; <nl> +	} <nl>  	Conbuf_AppendText( msg ); <nl>  } <nl>  
@@ -160,6 +160,8 @@ qboolean Sys_LowPhysicalMemory() <nl>  	if (!bAsked)	// just in case it takes a little time for GlobalMemoryStatus() to gather stats on <nl>  	{				//	stuff we don't care about such as virtual mem etc. <nl>  		bAsked = qtrue; <nl> + <nl> +		stat.dwLength = sizeof (stat); <nl>  		GlobalMemoryStatusEx (&stat); <nl>  	} <nl>  	if (sys_lowmem->integer)
@@ -281,6 +281,7 @@ void NPC_ChoosePainAnimation( gentity_t *self, gentity_t *other, vec3_t point, i <nl>  				|| PM_RollingAnim( self->client->ps.legsAnim ) <nl>  				|| (BG_FlippingAnim( self->client->ps.legsAnim )&&!PM_InCartwheel( self->client->ps.legsAnim )) ) <nl>  			{//strong attacks, rolls, knockdowns, flips and spins cannot be interrupted by pain <nl> +				return; <nl>  			} <nl>  			else <nl>  			{//play an anim
@@ -597,11 +597,14 @@ make_pch(void) <nl>  # ifdef __clang__ <nl>          "-emit-pch", <nl>  # endif <nl> -        "-o", pch_file, header_file, <nl> +        "-o", NULL, NULL, <nl>          NULL, <nl>      }; <nl>      char **args; <nl> +    int len = sizeof(rest_args) / sizeof(const char *); <nl>   <nl> +    rest_args[len - 2] = header_file; <nl> +    rest_args[len - 3] = pch_file; <nl>      verbose(2, "Creating precompiled header"); <nl>      args = form_args(3, CC_COMMON_ARGS, CC_CODEFLAG_ARGS, rest_args); <nl>      if (args == NULL) {
@@ -512,7 +512,7 @@ accept_precallback(rb_fde_t *F, struct sockaddr *addr, rb_socklen_t addrlen, voi <nl>  		return 0; <nl>  	} <nl>   <nl> -	aconf = find_dline(addr, AF_INET); <nl> +	aconf = find_dline(addr, addr->sa_family); <nl>  	if(aconf != NULL && (aconf->status & CONF_EXEMPTDLINE)) <nl>  		return 1; <nl>  	
@@ -174,7 +174,7 @@ rehash_txlines(struct Client *source_p) <nl>  	{ <nl>  		aconf = ptr->data; <nl>   <nl> -		if(!aconf->hold) <nl> +		if(!aconf->hold || aconf->lifetime) <nl>  			continue; <nl>   <nl>  		free_conf(aconf); <nl> @@ -199,7 +199,7 @@ rehash_tresvs(struct Client *source_p) <nl>  	{ <nl>  		aconf = ptr->data; <nl>   <nl> -		if(!aconf->hold) <nl> +		if(!aconf->hold || aconf->lifetime) <nl>  			continue; <nl>   <nl>  		free_conf(aconf); <nl> @@ -211,7 +211,7 @@ rehash_tresvs(struct Client *source_p) <nl>  	{ <nl>  		aconf = ptr->data; <nl>   <nl> -		if(!aconf->hold) <nl> +		if(!aconf->hold || aconf->lifetime) <nl>  			continue; <nl>   <nl>  		free_conf(aconf);
@@ -855,7 +855,14 @@ void color_cmyk_to_rgb(opj_image_t *image) <nl>  	w = image->comps[0].w; <nl>  	h = image->comps[0].h; <nl>   <nl> -	if(image->numcomps < 4) return; <nl> +	if ( <nl> +			(image->numcomps < 4) <nl> +		 || (image->comps[0].dx != image->comps[1].dx) || (image->comps[0].dx != image->comps[2].dx) || (image->comps[0].dx != image->comps[3].dx) <nl> +		 || (image->comps[0].dy != image->comps[1].dy) || (image->comps[0].dy != image->comps[2].dy) || (image->comps[0].dy != image->comps[3].dy) <nl> +			) { <nl> +		fprintf(stderr,"%s:%d:color_cmyk_to_rgb\n\tCAN NOT CONVERT\n", __FILE__,__LINE__); <nl> +		return; <nl> +	} <nl>   <nl>  	max = w * h; <nl>  	
@@ -268,7 +268,7 @@ void opj_tcd_makelayer( opj_tcd_t *tcd, <nl>                                                                          n = passno + 1; <nl>                                                                  continue; <nl>                                                          } <nl> -                                                        if (thresh - (dd / dr) <= DBL_EPSILON) /* do not rely on float equality, check with DBL_EPSILON margin */ <nl> +                                                        if (thresh - (dd / dr) < DBL_EPSILON) /* do not rely on float equality, check with DBL_EPSILON margin */ <nl>                                                                  n = passno + 1; <nl>                                                  } <nl>  
@@ -3436,7 +3436,7 @@ static int ssl_parse_client_psk_identity( mbedtls_ssl_context *ssl, unsigned cha <nl>      /* <nl>       * Receive client pre-shared key identity name <nl>       */ <nl> -    if( *p + 2 > end ) <nl> +    if( end - *p < 2 ) <nl>      { <nl>          MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client key exchange message" ) ); <nl>          return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE ); <nl> @@ -3445,7 +3445,7 @@ static int ssl_parse_client_psk_identity( mbedtls_ssl_context *ssl, unsigned cha <nl>      n = ( (*p)[0] << 8 ) | (*p)[1]; <nl>      *p += 2; <nl>   <nl> -    if( n < 1 || n > 65535 || *p + n > end ) <nl> +    if( n < 1 || n > 65535 || n > (size_t) ( end - *p ) ) <nl>      { <nl>          MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client key exchange message" ) ); <nl>          return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );
@@ -358,8 +358,9 @@ int mbedtls_md_hmac_starts( mbedtls_md_context_t *ctx, const unsigned char *key, <nl>   <nl>      if( ( ret = ctx->md_info->starts_func( ctx->md_ctx ) ) != 0 ) <nl>          goto cleanup; <nl> -    ret = ctx->md_info->update_func( ctx->md_ctx, ipad, <nl> -                                     ctx->md_info->block_size ); <nl> +    if( ( ret = ctx->md_info->update_func( ctx->md_ctx, ipad, <nl> +                                           ctx->md_info->block_size ) ) != 0 ) <nl> +        goto cleanup; <nl>   <nl>  cleanup: <nl>      mbedtls_zeroize( sum, sizeof( sum ) );
@@ -2870,6 +2870,9 @@ int ssl_session_reset( ssl_context *ssl ) <nl>      ssl->out_msglen = 0; <nl>      ssl->out_left = 0; <nl>   <nl> +    ssl->mfl_code = SSL_MAX_FRAG_LEN_NONE; <nl> +    ssl->max_frag_len = SSL_MAX_CONTENT_LEN; <nl> + <nl>      ssl->transform_in = NULL; <nl>      ssl->transform_out = NULL; <nl>  
@@ -39,7 +39,7 @@ <nl>  #include <sys/param.h> <nl>  #if defined(sun) <nl>  #include <kstat.h> <nl> -#else <nl> +#elif !defined(__linux__) <nl>  /* for BSD's sysctl */ <nl>  #include <sys/sysctl.h> <nl>  #endif
@@ -3,7 +3,7 @@ <nl>   * Project : miniupnp <nl>   * Web : http://miniupnp.free.fr/ <nl>   * Author : Thomas BERNARD <nl> - * copyright (c) 2005-2016 Thomas Bernard <nl> + * copyright (c) 2005-2017 Thomas Bernard <nl>   * This software is subjet to the conditions detailed in the <nl>   * provided LICENCE file. */ <nl>  /*#include <syslog.h>*/ <nl> @@ -201,6 +201,7 @@ connectToMiniSSDPD(const char * socketpath) <nl>  #endif /* #ifdef MINIUPNPC_SET_SOCKET_TIMEOUT */ <nl>  	if(!socketpath) <nl>  		socketpath = "/var/run/minissdpd.sock"; <nl> +	memset(&addr, 0, sizeof(addr)); <nl>  	addr.sun_family = AF_UNIX; <nl>  	strncpy(addr.sun_path, socketpath, sizeof(addr.sun_path)); <nl>  	/* TODO : check if we need to handle the EINTR */
@@ -1850,7 +1850,7 @@ GetOutboundPinholeTimeout(struct upnphttp * h, const char * action, const char * <nl>  	rem_port = GetValueFromNameValueList(&data, "RemotePort"); <nl>  	protocol = GetValueFromNameValueList(&data, "Protocol"); <nl>   <nl> -	if (!int_port || !ext_port || !protocol) <nl> +	if (!int_port || !rem_port || !protocol) <nl>  	{ <nl>  		ClearNameValueList(&data); <nl>  		SoapError(h, 402, "Invalid Args");
@@ -658,6 +658,7 @@ void processRequest(struct reqelem * req) <nl>  			syslog(LOG_ERR, "cannot allocate memory"); <nl>  			goto error; <nl>  		} <nl> +		memset(newserv, 0, sizeof(struct service));	/* set pointers to NULL */ <nl>  		if(containsForbiddenChars(p, l)) { <nl>  			syslog(LOG_ERR, "bad request (st contains forbidden chars)"); <nl>  			goto error;
@@ -475,6 +475,7 @@ try_entry(const SimpleConfEntry *const entry, const char *line, <nl>                  out_pnt++; <nl>                  state = STATE_TEMPLATE_RCHAR; <nl>              } else { <nl> +                free(arg); <nl>                  return ENTRYRESULT_INVALID_ENTRY; <nl>              } <nl>              continue;
@@ -477,11 +477,10 @@ algtype(Type *t) <nl>   <nl>  	if(issimple[t->etype] || isptr[t->etype] || iscomplex[t->etype] || <nl>  		t->etype == TCHAN || t->etype == TFUNC || t->etype == TMAP) { <nl> -		if (t->width == widthptr) { <nl> +		if(t->width == widthptr) <nl>  			a = AMEMWORD; <nl> -		} else { <nl> +		else <nl>  			a = AMEM;	// just bytes (int, ptr, etc) <nl> -		} <nl>  	} else if(t->etype == TSTRING) <nl>  		a = ASTRING;	// string <nl>  	else if(isnilinter(t))
@@ -312,7 +312,8 @@ runtimesetsig(int32 i, GoSighandler *fn, bool restart) <nl>  	if(fn == runtimesighandler) <nl>  		fn = (void*)runtimesigtramp; <nl>  	sa.sa_handler = fn; <nl> -	if(runtimert_sigaction(i, &sa, nil, sizeof(sa.sa_mask)) != 0) <nl> +	// Qemu rejects rt_sigaction of SIGRTMAX (64). <nl> +	if(runtimert_sigaction(i, &sa, nil, sizeof(sa.sa_mask)) != 0 && i != 64) <nl>  		runtimethrow("rt_sigaction failure"); <nl>  } <nl>  
@@ -40,9 +40,8 @@ int TS_OBJ_print_bio(BIO *bio, const ASN1_OBJECT *obj) <nl>  { <nl>      char obj_txt[128]; <nl>   <nl> -    int len = OBJ_obj2txt(obj_txt, sizeof(obj_txt), obj, 0); <nl> -    BIO_write(bio, obj_txt, len); <nl> -    BIO_write(bio, "\n", 1); <nl> +    OBJ_obj2txt(obj_txt, sizeof(obj_txt), obj, 0); <nl> +    BIO_printf(bio, "%s\n", obj_txt); <nl>   <nl>      return 1; <nl>  }
@@ -141,7 +141,7 @@ int BIO_get_port(const char *str, unsigned short *port_ptr) <nl>  int BIO_sock_error(int sock) <nl>  { <nl>      int j = 0, i; <nl> -    socklen_t size = 0; <nl> +    socklen_t size = sizeof(j); <nl>   <nl>      /* <nl>       * Note: under Windows the third parameter is of type (char *) whereas <nl> @@ -151,7 +151,7 @@ int BIO_sock_error(int sock) <nl>       */ <nl>      i = getsockopt(sock, SOL_SOCKET, SO_ERROR, (void *)&j, &size); <nl>      if (i < 0) <nl> -        return (1); <nl> +        return (get_last_socket_error()); <nl>      else <nl>          return (j); <nl>  }
@@ -2106,12 +2106,12 @@ int ssl3_send_certificate_request(SSL *s) <nl>  				{ <nl>  				name=sk_X509_NAME_value(sk,i); <nl>  				j=i2d_X509_NAME(name,NULL); <nl> -				if (!BUF_MEM_grow_clean(buf,4+n+j+2)) <nl> +				if (!BUF_MEM_grow_clean(buf,SSL_HM_HEADER_LENGTH(s)+n+j+2)) <nl>  					{ <nl>  					SSLerr(SSL_F_SSL3_SEND_CERTIFICATE_REQUEST,ERR_R_BUF_LIB); <nl>  					goto err; <nl>  					} <nl> -				p=(unsigned char *)&(buf->data[4+n]); <nl> +				p = ssl_handshake_start(s) + n; <nl>  				if (!(s->options & SSL_OP_NETSCAPE_CA_DN_BUG)) <nl>  					{ <nl>  					s2n(j,p);
@@ -159,6 +159,8 @@ static int compute_key(unsigned char *key, const BIGNUM *pub_key, DH *dh) <nl>          goto err; <nl>      BN_CTX_start(ctx); <nl>      tmp = BN_CTX_get(ctx); <nl> +    if (tmp == NULL) <nl> +        goto err; <nl>   <nl>      if (dh->priv_key == NULL) { <nl>          DHerr(DH_F_COMPUTE_KEY, DH_R_NO_PRIVATE_VALUE);
@@ -703,9 +703,10 @@ static int rsa_item_verify(EVP_MD_CTX *ctx, const ASN1_ITEM *it, void *asn, <nl>          RSAerr(RSA_F_RSA_ITEM_VERIFY, RSA_R_UNSUPPORTED_SIGNATURE_TYPE); <nl>          return -1; <nl>      } <nl> -    if (rsa_pss_to_ctx(ctx, NULL, sigalg, pkey)) <nl> +    if (rsa_pss_to_ctx(ctx, NULL, sigalg, pkey) > 0) { <nl>          /* Carry on */ <nl>          return 2; <nl> +    } <nl>      return -1; <nl>  } <nl>  
@@ -3162,6 +3162,7 @@ static int tls_decrypt_ticket(SSL *s, const unsigned char *etick, <nl>      if (sdec == NULL <nl>              || EVP_DecryptUpdate(ctx, sdec, &slen, p, eticklen) <= 0) { <nl>          EVP_CIPHER_CTX_free(ctx); <nl> +        OPENSSL_free(sdec); <nl>          return -1; <nl>      } <nl>      if (EVP_DecryptFinal(ctx, sdec + slen, &mlen) <= 0) {
@@ -106,6 +106,11 @@ static int pkey_gost_ctrl(EVP_PKEY_CTX *ctx, int type, int p1, void *p2) <nl>  			return 1; <nl>  		case EVP_PKEY_CTRL_SET_IV: <nl>  			pctx->shared_ukm=OPENSSL_malloc((int)p1); <nl> +			if (pctx->shared_ukm == NULL) <nl> +				{ <nl> +				GOSTerr(GOST_F_PKEY_GOST_CTRL, ERR_R_MALLOC_FAILURE); <nl> +				return 0; <nl> +				} <nl>  			memcpy(pctx->shared_ukm,p2,(int) p1); <nl>  			return 1; <nl>  		case EVP_PKEY_CTRL_PEER_KEY:
@@ -120,6 +120,7 @@ void EC_GROUP_clear_free(EC_GROUP *group) <nl>  		group->meth->group_clear_finish(group); <nl>  	else if (group->meth != NULL && group->meth->group_finish != 0) <nl>  		group->meth->group_finish(group); <nl> +	memset(point, 0, sizeof *group); <nl>  	OPENSSL_free(group); <nl>  	} <nl>   <nl> @@ -206,6 +207,7 @@ void EC_POINT_clear_free(EC_POINT *point) <nl>  		point->meth->point_clear_finish(point); <nl>  	else if (point->meth != NULL && point->meth->point_finish != 0) <nl>  		point->meth->point_finish(point); <nl> +	memset(point, 0, sizeof *point); <nl>  	OPENSSL_free(point); <nl>  	} <nl>  
@@ -342,6 +342,12 @@ char *ip; <nl>  	s=socket(AF_INET,SOCK_STREAM,SOCKET_PROTOCOL); <nl>   <nl>  	if (s == INVALID_SOCKET) goto err; <nl> +#if defined SOL_SOCKET && defined SO_REUSEADDR <nl> +		{ <nl> +		int i = 1; <nl> +		setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &i, sizeof i); <nl> +		} <nl> +#endif <nl>  	if (bind(s,(struct sockaddr *)&server,sizeof(server)) == -1) <nl>  		{ <nl>  #ifndef WINDOWS
@@ -2481,6 +2481,8 @@ static int init_ssl_connection(SSL *con) <nl>              BIO_ADDR_free(client); <nl>              dtlslisten = 0; <nl>              i = SSL_accept(con); <nl> +        } else { <nl> +            BIO_ADDR_free(client); <nl>          } <nl>      } else <nl>  #endif
@@ -773,6 +773,7 @@ int SSL_add_dir_cert_subjects_to_stack(STACK_OF(X509_NAME) *stack, <nl>  	ret = 1; <nl>   <nl>  err:	 <nl> +	if (d) closedir(d); <nl>  	CRYPTO_w_unlock(CRYPTO_LOCK_READDIR); <nl>  	return ret; <nl>  	} <nl> @@ -798,7 +799,7 @@ int SSL_add_dir_cert_subjects_to_stack(STACK_OF(X509_NAME) *stack, <nl>  		SYSerr(SYS_F_OPENDIR, get_last_sys_error()); <nl>  		ERR_add_error_data(3, "opendir('", dir, "')"); <nl>  		SSLerr(SSL_F_SSL_ADD_DIR_CERT_SUBJECTS_TO_STACK, ERR_R_SYS_LIB); <nl> -		goto err; <nl> +		goto err_noclose; <nl>  		} <nl>  	 <nl>  	do  <nl> @@ -819,10 +820,11 @@ int SSL_add_dir_cert_subjects_to_stack(STACK_OF(X509_NAME) *stack, <nl>  			goto err; <nl>  		} <nl>  	while (FindNextFile(hFind, &FindFileData) != FALSE); <nl> -	FindClose(hFind); <nl>  	ret = 1; <nl>   <nl> -err:	 <nl> +err: <nl> +	FindClose(hFind); <nl> +err_noclose:	 <nl>  	CRYPTO_w_unlock(CRYPTO_LOCK_READDIR); <nl>  	return ret; <nl>  	}
@@ -266,6 +266,7 @@ const EVP_CIPHER *FIPS_evp_des_ede_cbc(void); <nl>  const EVP_CIPHER *FIPS_evp_des_ede_cfb64(void); <nl>  const EVP_CIPHER *FIPS_evp_des_ede_ecb(void); <nl>  const EVP_CIPHER *FIPS_evp_des_ede_ofb(void); <nl> +const EVP_CIPHER *FIPS_evp_enc_null(void); <nl>  const EVP_MD *FIPS_evp_sha1(void); <nl>  const EVP_MD *FIPS_evp_sha224(void); <nl>  const EVP_MD *FIPS_evp_sha256(void);
@@ -66,18 +66,18 @@ void BIO_ADDR_clear(BIO_ADDR *ap) <nl>  int BIO_ADDR_make(BIO_ADDR *ap, const struct sockaddr *sa) <nl>  { <nl>      if (sa->sa_family == AF_INET) { <nl> -        ap->s_in = *(const struct sockaddr_in *)sa; <nl> +        memcpy(&(ap->s_in), sa, sizeof(struct sockaddr_in)); <nl>          return 1; <nl>      } <nl>  #ifdef AF_INET6 <nl>      if (sa->sa_family == AF_INET6) { <nl> -        ap->s_in6 = *(const struct sockaddr_in6 *)sa; <nl> +        memcpy(&(ap->s_in6), sa, sizeof(struct sockaddr_in6)); <nl>          return 1; <nl>      } <nl>  #endif <nl>  #ifdef AF_UNIX <nl>      if (sa->sa_family == AF_UNIX) { <nl> -        ap->s_un = *(const struct sockaddr_un *)sa; <nl> +        memcpy(&(ap->s_un), sa, sizeof(struct sockaddr_un)); <nl>          return 1; <nl>      } <nl>  #endif
@@ -59,6 +59,12 @@ <nl>  #ifndef HEADER_STORE_H <nl>  #define HEADER_STORE_H <nl>   <nl> +#include <openssl/opensslconf.h> <nl> + <nl> +#ifdef OPENSSL_NO_STORE <nl> +#error STORE is disabled. <nl> +#endif <nl> + <nl>  #include <openssl/ossl_typ.h> <nl>  #ifndef OPENSSL_NO_DEPRECATED <nl>  #include <openssl/evp.h>
@@ -126,6 +126,11 @@ static int rand_add(const void *buf, int num, double add) <nl>      if (!num) <nl>          return 1; <nl>   <nl> +#ifdef PREDICT <nl> +    if (rand_predictable) <nl> +        return 1; <nl> +#endif <nl> + <nl>      /* <nl>       * (Based on the rand(3) manpage) <nl>       *
@@ -41,7 +41,6 @@ <nl>  #include "../checksums.c" <nl>  #include "../gcj_mlc.c" <nl>  #include "../headers.c" <nl> -#include "../malloc.c" <nl>  #include "../new_hblk.c" <nl>  #include "../obj_map.c" <nl>  #include "../ptr_chck.c" <nl> @@ -53,6 +52,7 @@ <nl>  #include "../dbg_mlc.c" <nl>  #include "../finalize.c" <nl>  #include "../fnlz_mlc.c" <nl> +#include "../malloc.c" <nl>  #include "../mallocx.c" <nl>  #include "../mark.c" <nl>  #include "../mark_rts.c"
@@ -372,8 +372,13 @@ void * malloc(size_t lb) <nl>    } <nl>  #endif /* GC_LINUX_THREADS */ <nl>   <nl> +#ifndef SIZE_MAX <nl> +#define SIZE_MAX (~(size_t)0) <nl> +#endif <nl>  void * calloc(size_t n, size_t lb) <nl>  { <nl> +    if (lb && n > SIZE_MAX / lb) <nl> +      return NULL; <nl>  #   if defined(GC_LINUX_THREADS) /* && !defined(USE_PROC_FOR_LIBRARIES) */ <nl>          /* libpthread allocated some memory that is only pointed to by  */ <nl>          /* mmapped thread stacks.  Make sure it's not collectable.      */
@@ -374,12 +374,16 @@ void * malloc(size_t lb) <nl>    } <nl>  #endif /* GC_LINUX_THREADS */ <nl>   <nl> -#ifndef SIZE_MAX <nl> -#define SIZE_MAX (~(size_t)0) <nl> +#include <limits.h> <nl> +#ifdef SIZE_MAX <nl> +# define GC_SIZE_MAX SIZE_MAX <nl> +#else <nl> +# define GC_SIZE_MAX (~(size_t)0) <nl>  #endif <nl> + <nl>  void * calloc(size_t n, size_t lb) <nl>  { <nl> -    if (lb && n > SIZE_MAX / lb) <nl> +    if (lb && n > GC_SIZE_MAX / lb) <nl>        return NULL; <nl>  #   if defined(GC_LINUX_THREADS) /* && !defined(USE_PROC_FOR_LIBRARIES) */ <nl>          /* libpthread allocated some memory that is only pointed to by  */
@@ -1219,6 +1219,13 @@ bool extract_sockaddr(char *url, char **sockaddr_url, char **sockaddr_port) <nl>   <nl>  	if (url_len < 1) <nl>  		return false; <nl> +	 <nl> +	if (url_len >= sizeof(url_address)) <nl> +	{ <nl> +		applog(LOG_WARNING, "%s: Truncating overflowed address '%.*s'", <nl> +		       __func__, url_len, url_begin); <nl> +		url_len = sizeof(url_address) - 1; <nl> +	} <nl>   <nl>  	sprintf(url_address, "%.*s", url_len, url_begin); <nl>  
@@ -995,6 +995,7 @@ static void avalon_shutdown(struct thr_info *thr) <nl>  } <nl>   <nl>  struct device_drv avalon_drv = { <nl> +	.drv_id = DRIVER_AVALON, <nl>  	.dname = "avalon", <nl>  	.name = "AVA", <nl>  	.drv_detect = avalon_detect,
@@ -172,7 +172,7 @@ static bool klondike_get_stats(struct cgpu_info *klncgpu) <nl>  	for (dev = 0; dev <= slaves; dev++) { <nl>  		char *reply = SendCmdGetReply(klncgpu, 'S', dev, 0, NULL); <nl>  		if (reply != NULL) <nl> -			klninfo->status[dev] = *(WORKSTATUS *)(reply+2); <nl> +			memcpy((void *)(&(klninfo->status[dev])), reply+2, sizeof(klninfo->status[dev])); <nl>  	} <nl>  	wr_unlock(&(klninfo->stat_lock)); <nl>  	
@@ -1525,12 +1525,13 @@ static bool setup_stratum_socket(struct pool *pool) <nl>   <nl>  		break; <nl>  	} <nl> -	freeaddrinfo(servinfo); <nl>  	if (p == NULL) { <nl>  		applog(LOG_WARNING, "Failed to find servinfo on %s:%s", <nl>  		       pool->sockaddr_url, pool->stratum_port); <nl> +		freeaddrinfo(servinfo); <nl>  		return false; <nl>  	} <nl> +	freeaddrinfo(servinfo); <nl>   <nl>  	if (!pool->sockbuf) { <nl>  		pool->sockbuf = calloc(RBUFSIZE, 1);
@@ -1333,6 +1333,9 @@ static char *parse_config(json_t *config, bool fileconf) <nl>  		/* We don't handle subtables. */ <nl>  		assert(!(opt->type & OPT_SUBTABLE)); <nl>   <nl> +		if (!opt->names) <nl> +			continue; <nl> + <nl>  		/* Pull apart the option name(s). */ <nl>  		name = strdup(opt->names); <nl>  		for (p = strtok(name, "|"); p; p = strtok(NULL, "|")) {
@@ -5701,6 +5701,9 @@ begin_bench: <nl>  	pthread_detach(thr->pth); <nl>  #endif <nl>   <nl> +	for (i = 0; i < mining_threads + opt_queue; i++) <nl> +		queue_request(NULL, false); <nl> + <nl>  	/* main loop - simply wait for workio thread to exit. This is not the <nl>  	 * normal exit path and only occurs should the workio_thread die <nl>  	 * unexpectedly */
@@ -1147,6 +1147,11 @@ static bool queue_request(void) <nl>  	struct thr_info *thr = &thr_info[0]; <nl>  	struct workio_cmd *wc; <nl>   <nl> +	/* If we've been generating lots of local work we may already have <nl> +	 * enough in the queue */ <nl> +	if (requests_queued() >= opt_queue + mining_threads) <nl> +		return true; <nl> + <nl>  	/* fill out work request message */ <nl>  	wc = calloc(1, sizeof(*wc)); <nl>  	if (unlikely(!wc)) { <nl> @@ -1163,6 +1168,7 @@ static bool queue_request(void) <nl>  		workio_cmd_free(wc); <nl>  		return false; <nl>  	} <nl> +	getwork_requested++; <nl>  	inc_queued(); <nl>  	return true; <nl>  } <nl> @@ -1233,8 +1239,6 @@ static bool get_work(struct work *work, bool queued) <nl>  	bool ret = false; <nl>  	int failures = 0; <nl>   <nl> -	getwork_requested++; <nl> - <nl>  retry: <nl>  	if (unlikely(!queued && !queue_request())) { <nl>  		applog(LOG_WARNING, "Failed to queue_request in get_work");
@@ -407,6 +407,7 @@ SERVER* cmdline(int argc, char *argv[]) { <nl>  	} <nl>  	serve=g_new0(SERVER, 1); <nl>  	serve->authname = g_strdup(default_authname); <nl> +	serve->virtstyle=VIRT_IPLIT; <nl>  	while((c=getopt_long(argc, argv, "-a:C:cl:mo:rp:", long_options, &i))>=0) { <nl>  		switch (c) { <nl>  		case 1: <nl> @@ -1525,7 +1526,8 @@ int serveloop(GArray* servers) { <nl>  					} <nl>  					/* child */ <nl>  					g_hash_table_destroy(children); <nl> -					for(i=0;i<servers->len,serve=(g_array_index(servers, SERVER*, i));i++) { <nl> +					for(i=0;i<servers->len;i++) { <nl> +						serve=g_array_index(servers, SERVER*, i); <nl>  						close(serve->socket); <nl>  					} <nl>  					/* FALSE does not free the
@@ -1427,6 +1427,7 @@ CLIENT* handle_starttls(CLIENT* client, int opt, GArray* servers, uint32_t cflag <nl>   <nl>  	if (ret < 0) { <nl>  		gnutls_deinit(*session); <nl> +		g_free(session); <nl>  		return NULL; <nl>  	} <nl>  	client->tls_session = session;
@@ -269,10 +269,10 @@ int exptrim(struct nbd_request* req, CLIENT* client) { <nl>  			next.fhandle = -1; <nl>  			next.startoff = client->exportsize; <nl>  		} <nl> -		if(cur.startoff <= req->from && next.startoff - cur.startoff <= req->len) { <nl> +		if(cur.startoff <= req->from && next.startoff - cur.startoff >= req->len) { <nl>  			off_t reqoff = req->from - cur.startoff; <nl>  			off_t curlen = next.startoff - reqoff; <nl> -			off_t reqlen = curlen - reqoff > req->len ? curlen - reqoff : req->len; <nl> +			off_t reqlen = curlen - reqoff > req->len ? req->len : curlen - reqoff; <nl>  			punch_hole(cur.fhandle, reqoff, reqlen); <nl>  		} <nl>  		cur = next;
@@ -444,6 +444,7 @@ int main(int argc, char *argv[]) { <nl>  	uint32_t cflags=0; <nl>  	uint32_t opts=0; <nl>  	sigset_t block, old; <nl> +	struct sigaction sa; <nl>  	struct option long_options[] = { <nl>  		{ "block-size", required_argument, NULL, 'b' }, <nl>  		{ "check", required_argument, NULL, 'c' }, <nl> @@ -585,6 +586,10 @@ int main(int argc, char *argv[]) { <nl>  		if (daemon(0,0) < 0) <nl>  			err("Cannot detach from terminal"); <nl>  	} <nl> + <nl> +	memset(&sa, 0, sizeof(sa)); <nl> +	sa.sa_handler = SIG_IGN; <nl> +	sigaction(SIGCHLD, &a, NULL); <nl>  #endif <nl>  	do { <nl>  #ifndef NOFORK
@@ -1525,7 +1525,7 @@ Value listtransactions(const Array& params, bool fHelp) <nl>          if (pacentry != 0) <nl>              AcentryToJSON(*pacentry, strAccount, ret); <nl>   <nl> -        if (ret.size() >= (nCount+nFrom)) break; <nl> +        if ((int)ret.size() >= (nCount+nFrom)) break; <nl>      } <nl>      // ret is newest to oldest <nl>      
@@ -192,10 +192,10 @@ public: <nl>          // which has units satoshis-per-kilobyte. <nl>          // If you'd pay more than 1/3 in fees <nl>          // to spend something, then we consider it dust. <nl> -        // A typical txout is 33 bytes big, and will <nl> +        // A typical txout is 34 bytes big, and will <nl>          // need a CTxIn of at least 148 bytes to spend, <nl>          // so dust is a txout less than 54 uBTC <nl> -        // (5430 satoshis) with default nMinRelayTxFee <nl> +        // (5460 satoshis) with default nMinRelayTxFee <nl>          return ((nValue*1000)/(3*((int)GetSerializeSize(SER_DISK,0)+148)) < nMinRelayTxFee); <nl>      } <nl>  
@@ -3830,7 +3830,7 @@ CBlock* CreateNewBlock(CReserveKey& reservekey) <nl>                  int64 nValueIn = coins.vout[txin.prevout.n].nValue; <nl>                  nTotalIn += nValueIn; <nl>   <nl> -                int nConf = pindexPrev->nHeight - coins.nHeight; <nl> +                int nConf = pindexPrev->nHeight - coins.nHeight + 1; <nl>   <nl>                  dPriority += (double)nValueIn * nConf; <nl>              }
@@ -1662,6 +1662,9 @@ static int common_to_cil(char *key, void *data, void *UNUSED(arg)) <nl>   <nl>  	arr.count = 0; <nl>  	arr.perms = calloc(common->permissions.nprim, sizeof(*arr.perms)); <nl> +	if (arr.perms == NULL) { <nl> +		goto exit; <nl> +	} <nl>  	rc = hashtab_map(common->permissions.table, class_perm_to_array, &arr); <nl>  	if (rc != 0) { <nl>  		goto exit; <nl> @@ -1952,6 +1955,9 @@ static int class_to_cil(int indent, struct policydb *pdb, struct avrule_block *U <nl>   <nl>  	arr.count = 0; <nl>  	arr.perms = calloc(class->permissions.nprim, sizeof(*arr.perms)); <nl> +	if (arr.perms == NULL) { <nl> +		goto exit; <nl> +	} <nl>  	rc = hashtab_map(class->permissions.table, class_perm_to_array, &arr); <nl>  	if (rc != 0) { <nl>  		goto exit;
@@ -2225,7 +2225,7 @@ qqueueStart(qqueue_t *pThis) /* this is the ConstructionFinalizer */ <nl>  	 * influenced by properties which might have been set after queueConstruct () <nl>  	 */ <nl>  	if(pThis->pqParent == NULL) { <nl> -		pThis->mut = (pthread_mutex_t *) MALLOC (sizeof (pthread_mutex_t)); <nl> +		CHKmalloc(pThis->mut = (pthread_mutex_t *) MALLOC (sizeof (pthread_mutex_t))); <nl>  		pthread_mutex_init(pThis->mut, NULL); <nl>  	} else { <nl>  		/* child queue, we need to use parent's mutex */ <nl> @@ -2324,6 +2324,10 @@ qqueueStart(qqueue_t *pThis) /* this is the ConstructionFinalizer */ <nl>  	CHKiRet(statsobj.ConstructFinalize(pThis->statsobj)); <nl>   <nl>  finalize_it: <nl> +	if(iRet != RS_RET_OK) { <nl> +		if(pThis->mut != NULL) <nl> +			free(pThis->mut); <nl> +	} <nl>  	RETiRet; <nl>  } <nl>  
@@ -1356,6 +1356,7 @@ BEGINrunInput <nl>  #endif <nl>   <nl>  CODESTARTrunInput <nl> +	CHKmalloc(pReadfds); <nl>  	if(runModConf->bOmitLocalLogging && nfd == 1) <nl>  		ABORT_FINALIZE(RS_RET_OK); <nl>  	/* this is an endless loop - it is terminated when the thread is
@@ -4,7 +4,7 @@ <nl>   * <nl>   * Module begun 2008-10-09 by Rainer Gerhards (based on previous code from syslogd.c) <nl>   * <nl> - * Copyright 2008-2014 Rainer Gerhards and Adiscon GmbH. <nl> + * Copyright 2008-2015 Rainer Gerhards and Adiscon GmbH. <nl>   * <nl>   * This file is part of the rsyslog runtime library. <nl>   * <nl> @@ -280,7 +280,7 @@ rsRetVal <nl>  parserConstructViaModAndName(modInfo_t *__restrict__ pMod, uchar *const __restrict__ pName, void *pInst) <nl>  { <nl>  	rsRetVal localRet; <nl> -	parser_t *pParser; <nl> +	parser_t *pParser = NULL; <nl>  	DEFiRet; <nl>   <nl>  	if(pInst == NULL && pMod->mod.pm.newParserInst != NULL) { <nl> @@ -303,6 +303,8 @@ parserConstructViaModAndName(modInfo_t *__restrict__ pMod, uchar *const __restri <nl>  	pParser->pInst = pInst; <nl>  	CHKiRet(parserConstructFinalize(pParser)); <nl>  finalize_it: <nl> +	if(iRet != RS_RET_OK) <nl> +		free(pParser); <nl>  	RETiRet; <nl>  } <nl>  BEGINobjDestruct(parser) /* be sure to specify the object type also in END and CODESTART macros! */
@@ -1374,7 +1374,7 @@ string_replace_regex (const char *string, void *regex, const char *replace, <nl>      int length, length_replace, start_offset, i, rc, end, last_match; <nl>      regmatch_t regex_match[100]; <nl>   <nl> -    if (!string) <nl> +    if (!string || !regex) <nl>          return NULL; <nl>   <nl>      length = strlen (string) + 1;
@@ -2019,7 +2019,8 @@ gui_chat_draw (struct t_gui_buffer *buffer, int clear_chat) <nl>   <nl>              if (clear_chat) <nl>              { <nl> -                snprintf (format_empty, 32, "%%-%ds", ptr_win->win_chat_width); <nl> +                snprintf (format_empty, sizeof (format_empty), <nl> +                          "%%-%ds", ptr_win->win_chat_width); <nl>                  for (i = 0; i < ptr_win->win_chat_height; i++) <nl>                  { <nl>                      mvwprintw (GUI_WINDOW_OBJECTS(ptr_win)->win_chat, i, 0,
@@ -351,6 +351,8 @@ gui_window_set_custom_color_fg (WINDOW *window, int fg) <nl>      { <nl>          current_bg = window_current_style_bg; <nl>           <nl> +        gui_window_remove_color_style (window, A_BOLD); <nl> +         <nl>          if ((fg > 0) && (fg & GUI_COLOR_EXTENDED_FLAG)) <nl>          { <nl>              gui_window_set_color (window, <nl> @@ -359,7 +361,6 @@ gui_window_set_custom_color_fg (WINDOW *window, int fg) <nl>          } <nl>          else if (fg < GUI_CURSES_NUM_WEECHAT_COLORS) <nl>          { <nl> -            gui_window_remove_color_style (window, A_BOLD); <nl>              attributes = gui_weechat_colors[fg].attributes; <nl>              gui_window_set_color_style (window, attributes); <nl>              fg = gui_weechat_colors[fg].foreground;
@@ -82,6 +82,10 @@ trigger_callback_replace_regex (struct t_trigger *trigger, <nl>   <nl>      for (i = 0; i < trigger->regex_count; i++) <nl>      { <nl> +        /* if regex is not set (invalid), skip it */ <nl> +        if (!trigger->regex[i].regex) <nl> +            continue; <nl> + <nl>          ptr_key = (trigger->regex[i].variable) ? <nl>              trigger->regex[i].variable : <nl>              trigger_hook_regex_default_var[weechat_config_integer (trigger->options[TRIGGER_OPTION_HOOK])];
@@ -200,6 +200,8 @@ static int archive_string_append_unicode(struct archive_string *, <nl>  static struct archive_string * <nl>  archive_string_append(struct archive_string *as, const char *p, size_t s) <nl>  { <nl> +	if (s == 0) <nl> +		return (as); <nl>  	if (archive_string_ensure(as, as->length + s + 1) == NULL) <nl>  		return (NULL); <nl>  	memmove(as->s + as->length, p, s);
@@ -1040,6 +1040,9 @@ atol10(const char *p, size_t char_cnt) <nl>  	uint64_t l; <nl>  	int digit; <nl>   <nl> +	if (char_cnt == 0) <nl> +		return (0); <nl> + <nl>  	l = 0; <nl>  	digit = *p - '0'; <nl>  	while (digit >= 0 && digit < 10  && char_cnt-- > 0) { <nl> @@ -1054,7 +1057,10 @@ atol8(const char *p, size_t char_cnt) <nl>  { <nl>  	int64_t l; <nl>  	int digit; <nl> -         <nl> + <nl> +	if (char_cnt == 0) <nl> +		return (0); <nl> + <nl>  	l = 0; <nl>  	while (char_cnt-- > 0) { <nl>  		if (*p >= '0' && *p <= '7')
@@ -165,9 +165,10 @@ static int <nl>  archive_compressor_xz_init_stream(struct archive_write_filter *f, <nl>      struct private_data *data) <nl>  { <nl> +	static const lzma_stream lzma_stram_init = LZMA_STREAM_INIT; <nl>  	int ret; <nl>   <nl> -	data->stream = (lzma_stream)LZMA_STREAM_INIT; <nl> +	data->stream = lzma_stram_init; <nl>  	data->stream.next_out = data->compressed; <nl>  	data->stream.avail_out = data->compressed_buffer_size; <nl>  	if (f->code == ARCHIVE_COMPRESSION_XZ)
@@ -98,7 +98,10 @@ archive_entry_xattr_add_entry(struct archive_entry *entry, <nl>  		/* XXX Error XXX */ <nl>  		return; <nl>   <nl> -	xp->name = strdup(name); <nl> +	if ((xp->name = strdup(name)) == NULL) <nl> +		/* XXX Error XXX */ <nl> +		return; <nl> + <nl>  	if ((xp->value = malloc(size)) != NULL) { <nl>  		memcpy(xp->value, value, size); <nl>  		xp->size = size;
@@ -4089,8 +4089,9 @@ rollback: <nl>  		    xmlFree(exec->errString); <nl>  		exec->errString = xmlStrdup(value); <nl>  		exec->errState = exec->state; <nl> -		memcpy(exec->errCounts, exec->counts, <nl> -		       exec->comp->nbCounters * sizeof(int)); <nl> +                if (exec->comp->nbCounters) <nl> +                    memcpy(exec->errCounts, exec->counts, <nl> +                           exec->comp->nbCounters * sizeof(int)); <nl>  	    } <nl>   <nl>  	    /*
@@ -620,7 +620,7 @@ efile_readdir(Efile_error* errInfo,	/* Where to return error codes. */ <nl>  	if (IS_DOT_OR_DOTDOT(dirp->d_name)) <nl>  	    continue; <nl>  	buffer[0] = '\0'; <nl> -	strncat(buffer, dirp->d_name, size-1); <nl> +	strncat(buffer, dirp->d_name, (*size)-1); <nl>  	*size = strlen(dirp->d_name); <nl>  	return 1; <nl>      }
@@ -143,6 +143,10 @@ static size_t add_index_color(char *buf, size_t buflen, format_flag flags, char <nl>    if (!(flags & MUTT_FORMAT_INDEX)) <nl>      return 0; <nl>   <nl> +  /* this item is going to be passed to an external filter */ <nl> +  if (flags & MUTT_FORMAT_NOFILTER) <nl> +    return 0; <nl> + <nl>    if (color == MT_COLOR_INDEX) <nl>    { /* buf might be uninitialized other cases */ <nl>      len = mutt_strlen(buf);
@@ -2688,7 +2688,9 @@ CHECK_IMAP_ACL(IMAP_ACL_DELETE); <nl>    if (IsHeader (extra)) <nl>    { <nl>      Context->msgnotreadyet = -1; <nl> -    if (rc != -1) <nl> +    if (rc == -1 || rc == OP_MAIN_NEXT_UNDELETED || rc == OP_NEXT_ENTRY) <nl> +      OldHdr = NULL; <nl> +    else <nl>      { <nl>        TopLine = topline; <nl>        OldHdr = extra->hdr;
@@ -635,6 +635,13 @@ static void cmd_parse_status(struct ImapData *idata, char *s) <nl>        idata->status = IMAP_FATAL; <nl>        return; <nl>      } <nl> + <nl> +    if (strlen(idata->buf) < litlen) <nl> +    { <nl> +      mutt_debug(1, "Error parsing STATUS mailbox\n"); <nl> +      return; <nl> +    } <nl> + <nl>      mailbox = idata->buf; <nl>      s = mailbox + litlen; <nl>      *s = '\0';
@@ -1275,11 +1275,13 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */ <nl>      /* Draw formated compose status line */ <nl>      if (menu->redraw & REDRAW_STATUS)  <nl>      { <nl> -       	compose_status_line (buf, sizeof (buf), 0, menu, NONULL(ComposeFormat)); <nl> +	compose_status_line (buf, sizeof (buf), 0, menu, NONULL(ComposeFormat)); <nl>  	CLEARLINE (option (OPTSTATUSONTOP) ? 0 : LINES-2); <nl>  	SETCOLOR (MT_COLOR_STATUS); <nl> -	printw ("%-*.*s", COLS, COLS, buf); <nl> +	BKGDSET (MT_COLOR_STATUS); <nl> +	mutt_paddstr (COLS, buf); <nl>  	SETCOLOR (MT_COLOR_NORMAL); <nl> +	BKGDSET (MT_COLOR_NORMAL); <nl>  	menu->redraw &= ~REDRAW_STATUS; <nl>      } <nl>    }
@@ -397,6 +397,10 @@ int mx_get_magic (const char *path) <nl>      snprintf (tmp, sizeof (tmp), "%s/.mew-cache", path); <nl>      if (access (tmp, F_OK) == 0) <nl>        return (M_MH); <nl> +     <nl> +    snprintf (tmp, sizeof (tmp), "%s/.sylpheed_cache", path); <nl> +    if (access (tmp, F_OK) == 0) <nl> +      return (M_MH); <nl>   <nl>      /*  <nl>       * ok, this isn't an mh folder, but mh mode can be used to read
@@ -221,7 +221,7 @@ void mutt_pipe_message_to_state (HEADER *h, STATE *s) <nl>   <nl>    mutt_copy_message (s->fpout, Context, h, <nl>  		     option (OPTPIPEDECODE) ? M_CM_DECODE | M_CM_CHARCONV : 0, <nl> -		     option (OPTPIPEDECODE) ? CH_FROM | CH_WEED | CH_DECODE : CH_FROM); <nl> +		     option (OPTPIPEDECODE) ? CH_FROM | CH_WEED | CH_DECODE | CH_REORDER : CH_FROM); <nl>  } <nl>   <nl>  int mutt_pipe_message (HEADER *h)
@@ -1324,8 +1324,8 @@ static int process_results(struct cgpu_info *bflsc, int dev, char *pbuf, int *no <nl>   <nl>  	if (lines < QUE_RES_LINES_MIN) { <nl>  		tmp = str_text(pbuf); <nl> -		applog(LOG_ERR, "%s%i:%s result too small (%s) ignored", <nl> -					bflsc->drv->name, bflsc->device_id, xlink, tmp); <nl> +		applog(LOG_ERR, "%s%i:%s result of %d too small (%s) ignored", <nl> +					bflsc->drv->name, bflsc->device_id, xlink, lines, tmp); <nl>  		free(tmp); <nl>  		goto arigatou; <nl>  	}
@@ -3103,7 +3103,8 @@ retry: <nl>  			ret = true; <nl>  			goto out; <nl>  		} <nl> -		if (requested && requests_queued() > 1 && !pool_tset(pool, &pool->lagging)) { <nl> +		if (requested && requests_queued() >= opt_queue + mining_threads && <nl> +		    !pool_tset(pool, &pool->lagging)) { <nl>  			applog(LOG_WARNING, "Pool %d not providing work fast enough", <nl>  				pool->pool_no); <nl>  			pool->localgen_occasions++;
@@ -1753,7 +1753,8 @@ void kill_work(void) <nl>   <nl>  	/* Kill the watchdog thread */ <nl>  	thr = &thr_info[watchdog_thr_id]; <nl> -	pthread_cancel(*thr->pth); <nl> +	if (thr->pth) <nl> +		pthread_cancel(*thr->pth); <nl>   <nl>  	/* Stop the mining threads*/ <nl>  	for (i = 0; i < mining_threads; i++) { <nl> @@ -1767,9 +1768,11 @@ void kill_work(void) <nl>   <nl>  	/* Stop the others */ <nl>  	thr = &thr_info[stage_thr_id]; <nl> -	pthread_cancel(*thr->pth); <nl> +	if (thr->pth) <nl> +		pthread_cancel(*thr->pth); <nl>  	thr = &thr_info[longpoll_thr_id]; <nl> -	pthread_cancel(*thr->pth); <nl> +	if (thr->pth) <nl> +		pthread_cancel(*thr->pth); <nl>   <nl>  	wc = calloc(1, sizeof(*wc)); <nl>  	if (unlikely(!wc)) {
@@ -1035,7 +1035,8 @@ mm_answer_skeyrespond(int sock, Buffer *m) <nl>  	debug3("%s: sending authenticated: %d", __func__, authok); <nl>  	mm_request_send(sock, MONITOR_ANS_SKEYRESPOND, m); <nl>   <nl> -	auth_method = "skey"; <nl> +	auth_method = "keyboard-interactive"; <nl> +	auth_submethod = "skey"; <nl>   <nl>  	return (authok != 0); <nl>  }
@@ -423,7 +423,7 @@ static int tcmu_rbd_lock_break(struct tcmu_device *dev, char **orig_owner) <nl>  		tcmu_dev_err(dev, "Could not break lock from %s. (Err %d)\n", <nl>  			     owners[0], ret); <nl>  		if (ret == -ETIMEDOUT) <nl> -			return ret; <nl> +			goto free_owners; <nl>   <nl>  		ret = -EAGAIN; <nl>  		if (!*orig_owner) {
@@ -295,14 +295,17 @@ void CAnalyzerCCpp::GetIndependentBuldIdPC(const std::string& pBuildIdPC, std::s <nl>              line += pBuildIdPC[ii]; <nl>              ii++; <nl>          } <nl> -        while (!isspace(line[jj]) && jj < line.length()) <nl> +        while (line[jj] != '+' && jj < line.length()) <nl>          { <nl>              jj++; <nl>          } <nl>          jj++; <nl> -        while (!isspace(line[jj]) && jj < line.length()) <nl> +        while (line[jj] != '@' && jj < line.length()) <nl>          { <nl> -            pIndependentBuildIdPC += line[jj]; <nl> +            if (!isspace(line[jj])) <nl> +            { <nl> +                pIndependentBuildIdPC += line[jj]; <nl> +            } <nl>              jj++; <nl>          } <nl>          ii++;
@@ -182,6 +182,9 @@ int main(int argc, char **argv) <nl>          if (u != 0) <nl>              strcpy(path_env, "PATH=/usr/bin:/bin:"BIN_DIR); <nl>          putenv(path_env); <nl> + <nl> +        /* Use safe umask */ <nl> +        umask(0022); <nl>      } <nl>   <nl>      execvp(EXECUTABLE, (char **)args);
@@ -363,10 +363,6 @@ static void remote_recv_cb (EV_P_ ev_io *w, int revents) { <nl>   <nl>      ssize_t r = recv(remote->fd, server->buf, BUF_SIZE, 0); <nl>   <nl> -    if (verbose) { <nl> -        LOGD("remote recv: %d byte", (int)r); <nl> -    } <nl> - <nl>      if (r == 0) { <nl>          // connection closed <nl>          close_and_free_remote(EV_A_ remote);
@@ -182,8 +182,12 @@ void ChatLineModelItem::computeWrapList() const { <nl>    line.setNumColumns(length); <nl>    layout.endLayout(); <nl>   <nl> -  while((idx = finder.toNextBoundary()) >= 0 && idx < length) { <nl> -    idx++;  // the boundary is *before* the actual character <nl> +  while((idx = finder.toNextBoundary()) >= 0 && idx <= length) { <nl> +    if(idx < length) <nl> +      idx++;  // the boundary is *before* the actual character <nl> + <nl> +    if(idx == oldidx) <nl> +      continue; <nl>   <nl>      word.start = oldidx; <nl>      int wordend = idx;
@@ -546,7 +546,7 @@ NetworkId PostgreSqlStorage::createNetwork(UserId user, const NetworkInfo &info) <nl>   <nl>  void PostgreSqlStorage::bindNetworkInfo(QSqlQuery &query, const NetworkInfo &info) { <nl>    query.bindValue(":networkname", info.networkName); <nl> -  query.bindValue(":identityid", info.identity.toInt()); <nl> +  query.bindValue(":identityid", info.identity.isValid() ? info.identity.toInt() : QVariant()); <nl>    query.bindValue(":encodingcodec", QString(info.codecForEncoding)); <nl>    query.bindValue(":decodingcodec", QString(info.codecForDecoding)); <nl>    query.bindValue(":servercodec", QString(info.codecForServer));
@@ -134,7 +134,7 @@ mpc2k_write_header (SF_PRIVATE *psf, int calc_length) <nl>  	if (psf->is_pipe == SF_FALSE) <nl>  		psf_fseek (psf, 0, SEEK_SET) ; <nl>   <nl> -	snprintf (sample_name, sizeof (sample_name), "%s            ", psf->filename) ; <nl> +	snprintf (sample_name, sizeof (sample_name), "%s                    ", psf->filename) ; <nl>   <nl>  	psf_binheader_writef (psf, "e11b", 1, 4, sample_name, make_size_t (HEADER_NAME_LEN)) ; <nl>  	psf_binheader_writef (psf, "e111", 100, 0, (psf->sf.channels - 1) & 1) ;
@@ -470,7 +470,7 @@ static void merge_param(HashTable *params, zval *zdata, zval ***current_param, z <nl>  			while (Z_TYPE_PP(zdata_ptr) == IS_ARRAY <nl>  			&&	SUCCESS == zend_hash_get_current_data(Z_ARRVAL_PP(zdata_ptr), (void *) &test_ptr) <nl>  			) { <nl> -				if (Z_TYPE_PP(test_ptr) == IS_ARRAY) { <nl> +				if (Z_TYPE_PP(test_ptr) == IS_ARRAY && Z_TYPE_PP(ptr) == IS_ARRAY) { <nl>   <nl>  					/* now find key in ptr */ <nl>  					if (HASH_KEY_IS_STRING == zend_hash_get_current_key_ex(Z_ARRVAL_PP(zdata_ptr), &hkey.str, &hkey.len, &hkey.num, hkey.dup, NULL)) {
@@ -47,7 +47,7 @@ ImagingPcdDecode(Imaging im, ImagingCodecState state, UINT8* buf, int bytes) <nl>  	    out[0] = ptr[x]; <nl>  	    out[1] = ptr[(x+4*state->xsize)/2]; <nl>  	    out[2] = ptr[(x+5*state->xsize)/2]; <nl> -	    out += 4; <nl> +	    out += 3; <nl>  	} <nl>   <nl>  	state->shuffle((UINT8*) im->image[state->y], <nl> @@ -62,7 +62,7 @@ ImagingPcdDecode(Imaging im, ImagingCodecState state, UINT8* buf, int bytes) <nl>  	    out[0] = ptr[x+state->xsize]; <nl>  	    out[1] = ptr[(x+4*state->xsize)/2]; <nl>  	    out[2] = ptr[(x+5*state->xsize)/2]; <nl> -	    out += 4; <nl> +	    out += 3; <nl>  	} <nl>   <nl>  	state->shuffle((UINT8*) im->image[state->y],
@@ -40,8 +40,7 @@ ImagingFliDecode(Imaging im, ImagingCodecState state, UINT8* buf, Py_ssize_t byt <nl>  	return 0; <nl>   <nl>      /* We don't decode anything unless we have a full chunk in the <nl> -       input buffer (on the other hand, the Python part of the driver <nl> -       makes sure this is always the case) */ <nl> +       input buffer */ <nl>   <nl>      ptr = buf; <nl>   <nl> @@ -52,6 +51,10 @@ ImagingFliDecode(Imaging im, ImagingCodecState state, UINT8* buf, Py_ssize_t byt <nl>      /* Make sure this is a frame chunk.  The Python driver takes <nl>         case of other chunk types. */ <nl>   <nl> +    if (bytes < 8) { <nl> +        state->errcode = IMAGING_CODEC_OVERRUN; <nl> +        return -1; <nl> +    } <nl>      if (I16(ptr+4) != 0xF1FA) { <nl>  	state->errcode = IMAGING_CODEC_UNKNOWN; <nl>  	return -1;
@@ -95,15 +95,20 @@ opj_bool  opj_procedure_list_add_procedure (opj_procedure_list_t * p_validation_ <nl>  		(p_validation_list->m_nb_max_procedures == p_validation_list->m_nb_procedures) <nl>  	{ <nl>  		p_validation_list->m_nb_max_procedures += OPJ_VALIDATION_SIZE; <nl> -		p_validation_list->m_procedures = (opj_procedure*)opj_realloc( <nl> +                opj_procedure * new_procedures = (opj_procedure*)opj_realloc( <nl>  		p_validation_list->m_procedures,p_validation_list->m_nb_max_procedures * sizeof(opj_procedure)); <nl>  		if <nl> -			(! p_validation_list->m_procedures) <nl> +			(! new_procedures) <nl>  		{ <nl> +			opj_free(p_validation_list->m_procedures); <nl>  			p_validation_list->m_nb_max_procedures = 0; <nl>  			p_validation_list->m_nb_procedures = 0; <nl>  			return OPJ_FALSE; <nl>  		} <nl> +                else <nl> +                { <nl> +			p_validation_list->m_procedures = new_procedures; <nl> +                } <nl>  	} <nl>  	p_validation_list->m_procedures[p_validation_list->m_nb_procedures] = p_procedure; <nl>  	++p_validation_list->m_nb_procedures;
@@ -268,7 +268,7 @@ void opj_tcd_makelayer( opj_tcd_t *tcd, <nl>                                                                          n = passno + 1; <nl>                                                                  continue; <nl>                                                          } <nl> -                                                        if (thresh - (dd / dr) <= DBL_EPSILON) /* do not rely on float equality, check with DBL_EPSILON margin */ <nl> +                                                        if (thresh - (dd / dr) < DBL_EPSILON) /* do not rely on float equality, check with DBL_EPSILON margin */ <nl>                                                                  n = passno + 1; <nl>                                                  } <nl>  
@@ -335,7 +335,8 @@ bool ZrtpSdesStream::createSdesProfile(char *cryptoString, size_t *maxLen) { <nl>      /* Get B64 code for master key and master salt */ <nl>      b64Len = b64Encode(keySalt, keyLenBytes + saltLenBytes, b64keySalt, sizeof(b64keySalt)); <nl>      b64keySalt[b64Len] = '\0'; <nl> -    *maxLen = snprintf(cryptoString, *maxLen, "%d %s inline:%s", tag, pSuite->name, b64keySalt); <nl> +    memset(cryptoString, 0, *maxLen); <nl> +    *maxLen = snprintf(cryptoString, *maxLen-1, "%d %s inline:%s", tag, pSuite->name, b64keySalt); <nl>   <nl>      memset(keySalt, 0, sizeof(keySalt)); <nl>      return true;
@@ -116,11 +116,8 @@ void File::UpdateConnectionFields(Connection* conn) <nl>   <nl>  	Val* conns = val->Lookup(conns_idx); <nl>   <nl> -	bool is_first = false; <nl> - <nl>  	if ( ! conns ) <nl>  		{ <nl> -		is_first = true; <nl>  		conns = empty_connection_table(); <nl>  		val->Assign(conns_idx, conns); <nl>  		} <nl> @@ -131,7 +128,7 @@ void File::UpdateConnectionFields(Connection* conn) <nl>  		Val* conn_val = conn->BuildConnVal(); <nl>  		conns->AsTableVal()->Assign(idx, conn_val); <nl>   <nl> -		if ( ! is_first && FileEventAvailable(file_over_new_connection) ) <nl> +		if ( FileEventAvailable(file_over_new_connection) ) <nl>  			{ <nl>  			val_list* vl = new val_list(); <nl>  			vl->append(val->Ref());
@@ -252,14 +252,15 @@ void IRC_Analyzer::DeliverStream(int length, const u_char* line, bool orig) <nl>  			{ <nl>  			vector<string> parts = SplitWords(params, ' '); <nl>   <nl> -			// Remove nick name. <nl> -			parts.erase(parts.begin()); <nl> -			if ( parts.size() < 2 ) <nl> +			if ( parts.size() < 3 ) <nl>  				{ <nl>  				Weird("irc_invalid_names_line"); <nl>  				return; <nl>  				} <nl>   <nl> +			// Remove nick name. <nl> +			parts.erase(parts.begin()); <nl> + <nl>  			string type = parts[0]; <nl>  			string channel = parts[1]; <nl>  
@@ -2561,7 +2561,13 @@ void qtcDefaultSettings(Options *opts) <nl>      opts->shadeMenubarOnlyWhenActive=false; <nl>      opts->thin=THIN_BUTTONS; <nl>      opts->tbarBtns=TBTN_STANDARD; <nl> +#ifdef _WIN32 <nl> +    opts->scrollbarType=SCROLLBAR_WINDOWS; <nl> +#elif defined __APPLE__ <nl> +    opts->scrollbarType=SCROLLBAR_NONE; <nl> +#else <nl>      opts->scrollbarType=SCROLLBAR_KDE; <nl> +#endif <nl>      opts->buttonEffect=EFFECT_SHADOW; <nl>      opts->focus=FOCUS_GLOW; <nl>      opts->lvButton=false;
@@ -668,6 +668,10 @@ static plist_t parse_bin_node(struct bplist_data *bplist, const char** object) <nl>          return parse_string_node(object, size); <nl>   <nl>      case BPLIST_UNICODE: <nl> +        if (size*2 < size) { <nl> +            PLIST_BIN_ERR("%s: Integer overflow when calculating BPLIST_UNICODE data size.\n", __func__); <nl> +            return NULL; <nl> +        } <nl>          if (*object + size*2 > bplist->offset_table) { <nl>              PLIST_BIN_ERR("%s: BPLIST_UNICODE data bytes point outside of valid range\n", __func__); <nl>              return NULL;
@@ -662,7 +662,9 @@ static void node_from_xml(parse_ctx ctx, plist_t *plist) <nl>                  return; <nl>              } <nl>              if (*(ctx->pos-1) == '/') { <nl> -                tag[ctx->pos - p - 1] = '\0'; <nl> +                int idx = ctx->pos - p - 1; <nl> +                if (idx < taglen) <nl> +                    tag[idx] = '\0'; <nl>                  is_empty = 1; <nl>              } <nl>              ctx->pos++;
@@ -53,6 +53,7 @@ static char* smyrnaDir;    /* path to directory containin smyrna data files */ <nl>  char* smyrnaGlade; <nl>  unsigned char SmyrnaVerbose; <nl>   <nl> +#if 0 <nl>  infixtoposfic(char* infix,char* posfix,int bfsize) <nl>  { <nl>  	char a=NULL; <nl> @@ -104,9 +105,7 @@ infixtoposfic(char* infix,char* posfix,int bfsize) <nl>  	} <nl>  	posfix[ind2]='\0'; <nl>  } <nl> - <nl> - <nl> - <nl> +#endif <nl>   <nl>  /* smyrnaPath: <nl>   * Construct pathname for smyrna data file.
@@ -19,6 +19,8 @@ <nl>  #include "gvcjob.h" <nl>  #include "gvio.h" <nl>   <nl> +extern "C" char *xml_string(char* str); <nl> + <nl>  namespace Visio <nl>  { <nl>  	static const float INCHES_PER_POINT = 1.0 / 72.0; <nl> @@ -70,7 +72,7 @@ namespace Visio <nl>  	 <nl>  	void Run::Print(GVJ_t* job, unsigned int index) const <nl>  	{ <nl> -		gvprintf(job, "<pp IX='%d'/><cp IX='%d'/>%s\n", index, index, _text ? _text : "");	/* para mark + char mark + actual text */ <nl> +		gvprintf(job, "<pp IX='%d'/><cp IX='%d'/>%s\n", index, index, _text ? xml_string(_text) : "");	/* para mark + char mark + actual text */ <nl>  	} <nl>  	 <nl>  	Text* Text::CreateText(GVJ_t* job, pointf p, textpara_t* para)
@@ -373,6 +373,7 @@ static void round_corners(GVC_t * gvc, node_t * n, point * A, int sides, <nl>  	    int j = 0; <nl>  	    char* fillc = findFill(n); <nl>  	    point* pts = N_GNEW(2*sides,point); <nl> +    	    gvrender_begin_context(gvc); <nl>  	    gvrender_set_pencolor (gvc, fillc); <nl>  	    gvrender_set_fillcolor (gvc, fillc); <nl>  	    for (seg = 0; seg < sides; seg++) { <nl> @@ -386,6 +387,7 @@ static void round_corners(GVC_t * gvc, node_t * n, point * A, int sides, <nl>  		    P2PF(B[4 * seg + 2 + i], BF[i]); <nl>  		gvrender_beziercurve(gvc, BF, 4, FALSE, FALSE, TRUE); <nl>  	    } <nl> +    	    gvrender_end_context(gvc); <nl>  	} <nl>  	pencolor(gvc, n); <nl>  	for (seg = 0; seg < sides; seg++) {
@@ -611,8 +611,6 @@ void term_stop(void) <nl>  { <nl>  	terminfo_stop(current_term); <nl>  	kill(getpid(), SIGTSTP); <nl> -	terminfo_cont(current_term); <nl> -	irssi_redraw(); <nl>  } <nl>   <nl>  static int input_utf8(const unsigned char *buffer, int size, unichar *result)
@@ -1056,6 +1056,8 @@ static void view_bookmarks_check(TEXT_BUFFER_VIEW_REC *view, LINE_REC *line) <nl>  			if (new_line != NULL) { <nl>  				g_hash_table_insert(view->bookmarks, <nl>  						    tmp->data, new_line); <nl> +			} else { <nl> +				g_free(tmp->data); <nl>  			} <nl>  		} <nl>  		g_slist_free(rec.remove_list);
@@ -408,6 +408,9 @@ static int sig_autoremove(void) <nl>   <nl>  		/* Close only logs with private messages */ <nl>  		logitem = log->items->data; <nl> +		if (logitem->servertag == NULL) <nl> +			continue; <nl> + <nl>  		server = server_find_tag(logitem->servertag); <nl>  		if (logitem->type == LOG_ITEM_TARGET && <nl>  		    server != NULL && !server->ischannel(*logitem->name))
@@ -77,11 +77,11 @@ const char *get_irssi_config(void) <nl>  static void read_settings(void) <nl>  { <nl>  #ifndef WIN32 <nl> -	int signals[] = { <nl> +	static int signals[] = { <nl>  		SIGHUP, SIGINT, SIGQUIT, SIGTERM, <nl>  		SIGALRM, SIGUSR1, SIGUSR2 <nl>  	}; <nl> -	char *signames[] = { <nl> +	static char *signames[] = { <nl>  		"hup", "int", "quit", "term", <nl>  		"alrm", "usr1", "usr2" <nl>  	};
@@ -940,7 +940,7 @@ verify_callback (int preverify_ok, X509_STORE_CTX * ctx) <nl>        if (opt->verify_export_cert) <nl>          { <nl>            gc = gc_new(); <nl> -          if (tmp_file=get_peer_cert(ctx, opt->verify_export_cert,&gc)) <nl> +          if ((tmp_file=get_peer_cert(ctx, opt->verify_export_cert,&gc))) <nl>             { <nl>               setenv_str(opt->es, "peer_cert", tmp_file); <nl>             }
@@ -41,6 +41,12 @@ <nl>   * development environment. <nl>   */ <nl>   <nl> +/* MSVC headers do not define this macro, so do it here */ <nl> +#ifndef IN6_ARE_ADDR_EQUAL <nl> +#define IN6_ARE_ADDR_EQUAL(a,b) \ <nl> +  (memcmp ((const void*)(a), (const void*)(b), sizeof (struct in6_addr)) == 0) <nl> +#endif <nl> + <nl>  void init_win32 (void); <nl>  void uninit_win32 (void); <nl>  
@@ -35,7 +35,7 @@ <nl>  #include "file.h" <nl>   <nl>  #ifndef lint <nl> -FILE_RCSID("@(#)$File: cdf.c,v 1.61 2014/06/04 17:23:19 christos Exp $") <nl> +FILE_RCSID("@(#)$File: cdf.c,v 1.62 2014/06/04 17:26:07 christos Exp $") <nl>  #endif <nl>   <nl>  #include <assert.h> <nl> @@ -816,7 +816,11 @@ cdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h, <nl>  	if (cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1) <nl>  		goto out; <nl>  	for (i = 0; i < sh.sh_properties; i++) { <nl> -		size_t ofs = CDF_GETUINT32(p, (i << 1) + 1); <nl> +		size_t tail = (i << 1) + 1; <nl> +		if (cdf_check_stream_offset(sst, h, p, tail * sizeof(uint32_t), <nl> +		    __LINE__) == -1) <nl> +			goto out; <nl> +		size_t ofs = CDF_GETUINT32(p, tail); <nl>  		q = (const uint8_t *)(const void *) <nl>  		    ((const char *)(const void *)p + ofs <nl>  		    - 2 * sizeof(uint32_t));
@@ -92,6 +92,10 @@ run_int_from_pos (struct __int_data *int_data) <nl>          { <nl>            const OPCODE *curr = &__program[int_data->pos]; <nl>            completion = __opfuncs[curr->op_idx](*curr, int_data); <nl> + <nl> +          JERRY_ASSERT( !ecma_is_completion_value_normal( completion) <nl> +                        || ecma_is_completion_value_normal_simple_value(completion, <nl> +                                                                        ECMA_SIMPLE_VALUE_EMPTY) ); <nl>          } while ( completion.type == ECMA_COMPLETION_TYPE_NORMAL ); <nl>   <nl>        if ( completion.type == ECMA_COMPLETION_TYPE_BREAK )
@@ -1769,6 +1769,7 @@ ikev1_n_print(netdissect_options *ndo, u_char tpay _U_, <nl>  		    } <nl>  		case IPSECDOI_NTYPE_REPLAY_STATUS: <nl>  			ND_PRINT((ndo," status=(")); <nl> +			ND_TCHECK_32BITS(cp); <nl>  			ND_PRINT((ndo,"replay detection %sabled", <nl>  				  EXTRACT_32BITS(cp) ? "en" : "dis")); <nl>  			ND_PRINT((ndo,")"));
@@ -42,7 +42,9 @@ <nl>  #include "addrtoname.h" <nl>  #include "extract.h" <nl>   <nl> - <nl> +/* <nl> + * RFC 3561 <nl> + */ <nl>  struct aodv_rreq { <nl>  	uint8_t		rreq_type;	/* AODV message type (1) */ <nl>  	uint8_t		rreq_flags;	/* various flags */ <nl> @@ -178,12 +180,17 @@ aodv_extension(netdissect_options *ndo, <nl>  { <nl>  	const struct aodv_hello *ah; <nl>   <nl> +	ND_TCHECK(*ep); <nl>  	switch (ep->type) { <nl>  	case AODV_EXT_HELLO: <nl>  		ah = (const struct aodv_hello *)(const void *)ep; <nl>  		ND_TCHECK(*ah); <nl>  		if (length < sizeof(struct aodv_hello)) <nl>  			goto trunc; <nl> +		if (ep->length < 4) { <nl> +			ND_PRINT((ndo, "\n\text HELLO - bad length %u", ep->length)); <nl> +			break; <nl> +		} <nl>  		ND_PRINT((ndo, "\n\text HELLO %ld ms", <nl>  		    (unsigned long)EXTRACT_32BITS(&ah->interval))); <nl>  		break;
@@ -389,8 +389,7 @@ ospf6_print_lshdr(netdissect_options *ndo, <nl>  { <nl>  	if ((const u_char *)(lshp + 1) > dataend) <nl>  		goto trunc; <nl> -	ND_TCHECK(lshp->ls_type); <nl> -	ND_TCHECK(lshp->ls_seq); <nl> +	ND_TCHECK(lshp->ls_length);	/* last field of struct lsa6_hdr */ <nl>   <nl>  	ND_PRINT((ndo, "\n\t  Advertising Router %s, seq 0x%08x, age %us, length %u", <nl>                 ipaddr_string(ndo, &lshp->ls_router),
@@ -735,6 +735,7 @@ ospf6_decode_v3(netdissect_options *ndo, <nl>  	case OSPF_TYPE_HELLO: { <nl>  		register const struct hello6 *hellop = (const struct hello6 *)((const uint8_t *)op + OSPF6HDR_LEN); <nl>   <nl> +		ND_TCHECK_32BITS(&hellop->hello_options); <nl>  		ND_PRINT((ndo, "\n\tOptions [%s]", <nl>  		          bittok2str(ospf6_option_values, "none", <nl>  		          EXTRACT_32BITS(&hellop->hello_options))));
@@ -518,6 +518,10 @@ dhcp6opt_print(netdissect_options *ndo, <nl>  			ND_PRINT((ndo, "...)")); <nl>  			break; <nl>  		case DH6OPT_RECONF_MSG: <nl> +			if (optlen != 1) { <nl> +				ND_PRINT((ndo, " ?)")); <nl> +				break; <nl> +			} <nl>  			tp = (const u_char *)(dh6o + 1); <nl>  			switch (*tp) { <nl>  			case DH6_RENEW:
@@ -181,7 +181,7 @@ arcnet_if_print(netdissect_options *ndo, const struct pcap_pkthdr *h, const u_ch <nl>  	u_int seqid = 0; <nl>  	u_char arc_type; <nl>   <nl> -	if (caplen < ARC_HDRLEN) { <nl> +	if (caplen < ARC_HDRLEN || length < ARC_HDRLEN) { <nl>  		ND_PRINT((ndo, "[|arcnet]")); <nl>  		return (caplen); <nl>  	} <nl> @@ -202,14 +202,14 @@ arcnet_if_print(netdissect_options *ndo, const struct pcap_pkthdr *h, const u_ch <nl>  	} <nl>   <nl>  	if (phds) { <nl> -		if (caplen < ARC_HDRNEWLEN) { <nl> +		if (caplen < ARC_HDRNEWLEN || length < ARC_HDRNEWLEN) { <nl>  			arcnet_print(ndo, p, length, 0, 0, 0); <nl>  			ND_PRINT((ndo, "[|phds]")); <nl>  			return (caplen); <nl>  		} <nl>   <nl>  		if (ap->arc_flag == 0xff) { <nl> -			if (caplen < ARC_HDRNEWLEN_EXC) { <nl> +			if (caplen < ARC_HDRNEWLEN_EXC || length < ARC_HDRNEWLEN_EXC) { <nl>  				arcnet_print(ndo, p, length, 0, 0, 0); <nl>  				ND_PRINT((ndo, "[|phds extended]")); <nl>  				return (caplen); <nl> @@ -268,7 +268,7 @@ arcnet_linux_if_print(netdissect_options *ndo, const struct pcap_pkthdr *h, cons <nl>  	int archdrlen = 0; <nl>  	u_char arc_type; <nl>   <nl> -	if (caplen < ARC_LINUX_HDRLEN) { <nl> +	if (caplen < ARC_LINUX_HDRLEN || length < ARC_LINUX_HDRLEN) { <nl>  		ND_PRINT((ndo, "[|arcnet]")); <nl>  		return (caplen); <nl>  	} <nl> @@ -279,7 +279,7 @@ arcnet_linux_if_print(netdissect_options *ndo, const struct pcap_pkthdr *h, cons <nl>  	switch (arc_type) { <nl>  	default: <nl>  		archdrlen = ARC_LINUX_HDRNEWLEN; <nl> -		if (caplen < ARC_LINUX_HDRNEWLEN) { <nl> +		if (caplen < ARC_LINUX_HDRNEWLEN || length < ARC_LINUX_HDRNEWLEN) { <nl>  			ND_PRINT((ndo, "[|arcnet]")); <nl>  			return (caplen); <nl>  		}
@@ -152,9 +152,11 @@ vrrp_print(netdissect_options *ndo, <nl>  		if (version == 3 && ND_TTEST2(bp[0], len)) { <nl>  			uint16_t cksum = nextproto4_cksum(ndo, (const struct ip *)bp2, bp, <nl>  				len, len, IPPROTO_VRRP); <nl> -			if (cksum) <nl> +			if (cksum) { <nl> +				ND_TCHECK_16BITS(&bp[6]); <nl>  				ND_PRINT((ndo, ", (bad vrrp cksum %x)", <nl>  					EXTRACT_16BITS(&bp[6]))); <nl> +			} <nl>  		} <nl>   <nl>  		ND_PRINT((ndo, ", addrs"));
@@ -548,7 +548,8 @@ handle_ctrl_proto(netdissect_options *ndo, <nl>  		/* RFC 1661 says this is intended to be human readable */ <nl>  		if (len > 8) { <nl>  			ND_PRINT((ndo, "\n\t  Message\n\t    ")); <nl> -			fn_printn(tptr + 4, len - 4, ndo->ndo_snapend); <nl> +			if (fn_printn(tptr + 4, len - 4, ndo->ndo_snapend)) <nl> +				goto trunc; <nl>  		} <nl>  		break; <nl>  	case CPCODES_TIME_REM:
@@ -141,7 +141,7 @@ ieee802_15_4_if_print(netdissect_options *ndo, <nl>  			return hdrlen; <nl>  		} <nl>  		if (ndo->ndo_vflag) <nl> -			ND_PRINT((ndo,"%04x:%s ", panid, le64addr_string(ndo, p + 2))); <nl> +			ND_PRINT((ndo,"%04x:%s ", panid, le64addr_string(ndo, p))); <nl>  		p += 8; <nl>  		caplen -= 8; <nl>  		hdrlen += 8;
@@ -1131,6 +1131,7 @@ icmp6_print(netdissect_options *ndo, <nl>  		if (ndo->ndo_vflag) { <nl>  			ND_TCHECK(dp->icmp6_data16[0]); <nl>  			ND_PRINT((ndo,", id 0x%04x", EXTRACT_16BITS(&dp->icmp6_data16[0]))); <nl> +			ND_TCHECK(dp->icmp6_data16[1]); <nl>  			if (dp->icmp6_data16[1] & 0xc0) <nl>  				ND_PRINT((ndo," ")); <nl>  			if (dp->icmp6_data16[1] & 0x80)
@@ -2351,6 +2351,8 @@ bgp_capabilities_print(netdissect_options *ndo, <nl>                             opt[i+5])); <nl>                      break; <nl>                  case BGP_CAPCODE_RESTART: <nl> +                    /* Restart Flags (4 bits), Restart Time in seconds (12 bits) */ <nl> +                    ND_TCHECK_16BITS(opt + i + 2); <nl>                      ND_PRINT((ndo, "\n\t\tRestart Flags: [%s], Restart Time %us", <nl>                             ((opt[i+2])&0x80) ? "R" : "none", <nl>                             EXTRACT_16BITS(opt+i+2)&0xfff));
@@ -263,9 +263,8 @@ wb_prep(netdissect_options *ndo, <nl>  	const u_char *ep = ndo->ndo_snapend; <nl>   <nl>  	ND_PRINT((ndo, " wb-prep:")); <nl> -	if (len < sizeof(*prep)) { <nl> +	if (len < sizeof(*prep) || !ND_TTEST(*prep)) <nl>  		return (-1); <nl> -	} <nl>  	n = EXTRACT_32BITS(&prep->pp_n); <nl>  	ps = (const struct pgstate *)(prep + 1); <nl>  	while (--n >= 0 && ND_TTEST(*ps)) { <nl> @@ -419,31 +418,37 @@ wb_print(netdissect_options *ndo, <nl>  	case PT_ID: <nl>  		if (wb_id(ndo, (const struct pkt_id *)(ph + 1), len) >= 0) <nl>  			return; <nl> +		ND_PRINT((ndo, "%s", tstr)); <nl>  		break; <nl>   <nl>  	case PT_RREQ: <nl>  		if (wb_rreq(ndo, (const struct pkt_rreq *)(ph + 1), len) >= 0) <nl>  			return; <nl> +		ND_PRINT((ndo, "%s", tstr)); <nl>  		break; <nl>   <nl>  	case PT_RREP: <nl>  		if (wb_rrep(ndo, (const struct pkt_rrep *)(ph + 1), len) >= 0) <nl>  			return; <nl> +		ND_PRINT((ndo, "%s", tstr)); <nl>  		break; <nl>   <nl>  	case PT_DRAWOP: <nl>  		if (wb_drawop(ndo, (const struct pkt_dop *)(ph + 1), len) >= 0) <nl>  			return; <nl> +		ND_PRINT((ndo, "%s", tstr)); <nl>  		break; <nl>   <nl>  	case PT_PREQ: <nl>  		if (wb_preq(ndo, (const struct pkt_preq *)(ph + 1), len) >= 0) <nl>  			return; <nl> +		ND_PRINT((ndo, "%s", tstr)); <nl>  		break; <nl>   <nl>  	case PT_PREP: <nl>  		if (wb_prep(ndo, (const struct pkt_prep *)(ph + 1), len) >= 0) <nl>  			return; <nl> +		ND_PRINT((ndo, "%s", tstr)); <nl>  		break; <nl>   <nl>  	default:
@@ -1699,6 +1699,7 @@ icmp6_nodeinfo_print(netdissect_options *ndo, u_int icmp6len, const u_char *bp, <nl>   <nl>  		needcomma = 0; <nl>   <nl> +		ND_TCHECK2(*dp, sizeof(*ni6)); <nl>  		ni6 = (const struct icmp6_nodeinfo *)dp; <nl>  		ND_PRINT((ndo," node information reply")); <nl>  		ND_PRINT((ndo," ("));	/*)*/ <nl> @@ -1753,6 +1754,7 @@ icmp6_nodeinfo_print(netdissect_options *ndo, u_int icmp6len, const u_char *bp, <nl>  				ND_PRINT((ndo,", ")); <nl>  			ND_PRINT((ndo,"DNS name")); <nl>  			cp = (const u_char *)(ni6 + 1) + 4; <nl> +			ND_TCHECK(cp[0]); <nl>  			if (cp[0] == ep - cp - 1) { <nl>  				/* icmp-name-lookup-03, pascal string */ <nl>  				if (ndo->ndo_vflag)
@@ -1861,6 +1861,8 @@ isis_print_is_reach_subtlv(netdissect_options *ndo, <nl>              break; <nl>          case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS: /* fall through */ <nl>          case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS_OLD: <nl> +            if (subl == 0) <nl> +                break; <nl>              ND_PRINT((ndo, "%sBandwidth Constraints Model ID: %s (%u)", <nl>                     ident, <nl>                     tok2str(diffserv_te_bc_values, "unknown", *tptr), <nl> @@ -1868,7 +1870,6 @@ isis_print_is_reach_subtlv(netdissect_options *ndo, <nl>              tptr++; <nl>              /* decode BCs until the subTLV ends */ <nl>              for (te_class = 0; te_class < (subl-1)/4; te_class++) { <nl> -                ND_TCHECK2(*tptr, 4); <nl>                  bw.i = EXTRACT_32BITS(tptr); <nl>                  ND_PRINT((ndo, "%s  Bandwidth constraint CT%u: %.3f Mbps", <nl>                         ident,
@@ -1258,7 +1258,8 @@ AP4_AtomMetaDataValue::ToInteger() const <nl>  +---------------------------------------------------------------------*/ <nl>  AP4_DataAtom::AP4_DataAtom(const AP4_MetaData::Value& value) : <nl>      AP4_Atom(AP4_ATOM_TYPE_DATA, AP4_ATOM_HEADER_SIZE), <nl> -    m_DataType(DATA_TYPE_BINARY) <nl> +    m_DataType(DATA_TYPE_BINARY), <nl> +    m_Source(NULL) <nl>  { <nl>      AP4_MemoryByteStream* memory = new AP4_MemoryByteStream(); <nl>      AP4_Size payload_size = 8; <nl> @@ -1334,7 +1335,8 @@ AP4_DataAtom::AP4_DataAtom(const AP4_MetaData::Value& value) : <nl>  |   AP4_DataAtom::AP4_DataAtom <nl>  +---------------------------------------------------------------------*/ <nl>  AP4_DataAtom::AP4_DataAtom(AP4_UI32 size, AP4_ByteStream& stream) : <nl> -    AP4_Atom(AP4_ATOM_TYPE_DATA, size) <nl> +    AP4_Atom(AP4_ATOM_TYPE_DATA, size), <nl> +    m_Source(NULL) <nl>  { <nl>      if (size < AP4_ATOM_HEADER_SIZE+8) return; <nl>  
@@ -304,6 +304,7 @@ public: <nl>      // base methods <nl>      virtual ~AP4_AtomParent(); <nl>      AP4_List<AP4_Atom>& GetChildren() { return m_Children; } <nl> +    AP4_Result          CopyChildren(AP4_AtomParent& destination) const; <nl>      virtual AP4_Result  AddChild(AP4_Atom* child, int position = -1); <nl>      virtual AP4_Result  RemoveChild(AP4_Atom* child); <nl>      virtual AP4_Result  DeleteChild(AP4_Atom::Type type, AP4_Ordinal index = 0);
@@ -1015,6 +1015,7 @@ static void zone_timer(int fd, short flg, void *arg) <nl>  	z = container_of(el, struct DNSZone, lnode); <nl>  	ctx->zone_state = 1; <nl>  	ctx->cur_zone = z; <nl> +	ctx->active++; <nl>  	impl_query_soa_serial(ctx, z->zonename); <nl>  } <nl>  
@@ -152,7 +152,7 @@ static struct { <nl>   <nl>  int ParseCaffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config) <nl>  { <nl> -    uint32_t chan_chunk = 0, channel_layout = 0, bcount; <nl> +    uint32_t chan_chunk = 0, desc_chunk = 0, channel_layout = 0, bcount; <nl>      unsigned char *channel_identities = NULL; <nl>      unsigned char *channel_reorder = NULL; <nl>      int64_t total_samples = 0, infilesize; <nl> @@ -218,6 +218,7 @@ int ParseCaffHeaderConfig (FILE *infile, char *infilename, char *fourcc, Wavpack <nl>              } <nl>   <nl>              WavpackBigEndianToNative (&caf_audio_format, CAFAudioFormatFormat); <nl> +            desc_chunk = 1; <nl>   <nl>              if (debug_logging_mode) { <nl>                  char formatstr [5]; <nl> @@ -458,7 +459,7 @@ int ParseCaffHeaderConfig (FILE *infile, char *infilename, char *fourcc, Wavpack <nl>          else if (!strncmp (caf_chunk_header.mChunkType, "data", 4)) {     // on the data chunk, get size and exit loop <nl>              uint32_t mEditCount; <nl>   <nl> -            if (!DoReadFile (infile, &mEditCount, sizeof (mEditCount), &bcount) || <nl> +            if (!desc_chunk || !DoReadFile (infile, &mEditCount, sizeof (mEditCount), &bcount) || <nl>                  bcount != sizeof (mEditCount)) { <nl>                      error_line ("%s is not a valid .CAF file!", infilename); <nl>                      return WAVPACK_SOFT_ERROR;
@@ -407,7 +407,7 @@ close_uzbl (WebKitWebView *page, GArray *argv, GString *result) { <nl>      if (uzbl.gui.main_window) <nl>          gtk_widget_destroy(uzbl.gui.main_window); <nl>      else if (uzbl.gui.plug) <nl> -        gtk_widget_destroy(uzbl.gui.plug); <nl> +        gtk_widget_destroy(GTK_WIDGET(uzbl.gui.plug)); <nl>   <nl>      gtk_main_quit (); <nl>  }
@@ -1615,16 +1615,20 @@ static PyObject* elements_to_dict(PyObject* self, const char* string, int max, <nl>              PyObject* InvalidBSON = _error("InvalidBSON"); <nl>              PyErr_SetNone(InvalidBSON); <nl>              Py_DECREF(InvalidBSON); <nl> +            Py_DECREF(dict); <nl>              return NULL; <nl>          } <nl>          name = PyUnicode_DecodeUTF8(string + position, name_length, "strict"); <nl>          if (!name) { <nl> +            Py_DECREF(dict); <nl>              return NULL; <nl>          } <nl>          position += name_length + 1; <nl>          value = get_value(self, string, &position, type, <nl>                            max - position, as_class, tz_aware, uuid_subtype); <nl>          if (!value) { <nl> +            Py_DECREF(name); <nl> +            Py_DECREF(dict); <nl>              return NULL; <nl>          } <nl>  
@@ -32,9 +32,8 @@ static char const *hwstr(unsigned short sa_family); <nl>  int update_device_info(struct Interface *iface) <nl>  { <nl>  	struct ifreq ifr; <nl> - <nl> +	memset(&ifr, 0, sizeof(ifr)); <nl>  	strncpy(ifr.ifr_name, iface->Name, IFNAMSIZ - 1); <nl> -	ifr.ifr_name[IFNAMSIZ - 1] = '\0'; <nl>   <nl>  	if (ioctl(sock, SIOCGIFMTU, &ifr) < 0) { <nl>  		flog(LOG_ERR, "ioctl(SIOCGIFMTU) failed for %s: %s", iface->Name, strerror(errno));
@@ -1420,7 +1420,7 @@ int len; <nl>  		} <nl>   <nl>  		/* Not so likely to happen. */ <nl> -		if (vallen >= len + sizeof (rhostname)) { <nl> +		if (len - vallen >= sizeof (rhostname)) { <nl>  			dbglog("EAP: trimming really long peer name down"); <nl>  			BCOPY(inp + vallen, rhostname, sizeof (rhostname) - 1); <nl>  			rhostname[sizeof (rhostname) - 1] = '\0'; <nl> @@ -1846,7 +1846,7 @@ int len; <nl>  		} <nl>   <nl>  		/* Not so likely to happen. */ <nl> -		if (vallen >= len + sizeof (rhostname)) { <nl> +		if (len - vallen >= sizeof (rhostname)) { <nl>  			dbglog("EAP: trimming really long peer name down"); <nl>  			BCOPY(inp + vallen, rhostname, sizeof (rhostname) - 1); <nl>  			rhostname[sizeof (rhostname) - 1] = '\0';
@@ -73,7 +73,7 @@ <nl>   * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. <nl>   */ <nl>   <nl> -#define RCSID	"$Id: auth.c,v 1.90 2002/12/04 23:03:32 paulus Exp $" <nl> +#define RCSID	"$Id: auth.c,v 1.91 2003/02/16 22:25:49 paulus Exp $" <nl>   <nl>  #include <stdio.h> <nl>  #include <stddef.h> <nl> @@ -605,6 +605,9 @@ link_established(unit) <nl>  	    && protp->lowerup != NULL) <nl>  	    (*protp->lowerup)(unit); <nl>   <nl> +    if (!auth_required && noauth_addrs != NULL) <nl> +	set_allowed_addrs(unit, NULL, NULL) <nl> + <nl>      if (auth_required && !(go->neg_upap || go->neg_chap || go->neg_eap)) { <nl>  	/* <nl>  	 * We wanted the peer to authenticate itself, and it refused:
@@ -862,7 +862,9 @@ static int slab_rebalance_move(void) { <nl>                              // Only safe to hold slabs lock because refcount <nl>                              // can't drop to 0 until we release item lock. <nl>                              STORAGE_delete(storage, it); <nl> +                            pthread_mutex_unlock(&slabs_lock); <nl>                              do_item_unlink(it, hv); <nl> +                            pthread_mutex_lock(&slabs_lock); <nl>                          } <nl>                          status = MOVE_BUSY; <nl>                      } else {
@@ -3148,7 +3148,9 @@ static int try_read_command(conn *c) { <nl>                      ++ptr; <nl>                  } <nl>   <nl> -                if (strcmp(ptr, "get ") && strcmp(ptr, "gets ")) { <nl> +                if (ptr - c->rcurr > 100 || <nl> +                    (strncmp(ptr, "get ", 4) && strncmp(ptr, "gets ", 5))) { <nl> + <nl>                      conn_set_state(c, conn_closing); <nl>                      return 1; <nl>                  }
@@ -747,10 +747,10 @@ static void slab_rebalance_finish(void) { <nl>       * We always kill the "first"/"oldest" slab page in the slab_list, so <nl>       * shuffle the page list backwards and decrement. <nl>       */ <nl> +    s_cls->slabs--; <nl>      for (x = 0; x < s_cls->slabs; x++) { <nl>          s_cls->slab_list[x] = s_cls->slab_list[x+1]; <nl>      } <nl> -    s_cls->slabs--; <nl>   <nl>      memset(slab_rebal.slab_start, 0, (size_t)settings.item_size_max); <nl>  
@@ -150,7 +150,9 @@ typedef struct _stritem { <nl>           + (item)->nsuffix \ <nl>           + (((item)->it_flags & ITEM_CAS) ? sizeof(uint64_t) : 0)) <nl>   <nl> -#define ITEM_ntotal(item) (sizeof(struct _stritem) + (item)->nkey + 1 + (item)->nsuffix + (item)->nbytes) <nl> +#define ITEM_ntotal(item) (sizeof(struct _stritem) + (item)->nkey + 1 \ <nl> +         + (item)->nsuffix + (item)->nbytes \ <nl> +         + (((item)->it_flags & ITEM_CAS) ? sizeof(uint64_t) : 0)) <nl>   <nl>  /** <nl>   * NOTE: If you modify this table you _MUST_ update the function state_text
@@ -377,7 +377,8 @@ void iobuf_remove(struct iobuf *io, size_t n) { <nl>   <nl>  static size_t ns_out(struct ns_connection *nc, const void *buf, size_t len) { <nl>    if (nc->flags & NSF_UDP) { <nl> -    long n = sendto(nc->sock, buf, len, 0, &nc->sa.sa, sizeof(nc->sa.sin)); <nl> +    long n = sendto(nc->sock, (const char *) buf, len, 0, &nc->sa.sa, <nl> +                    sizeof(nc->sa.sin)); <nl>      DBG(("%p %d send %ld (%d %s)", nc, nc->sock, n, errno, strerror(errno))); <nl>      return n < 0 ? 0 : n; <nl>    } else {
@@ -2698,6 +2698,7 @@ void mg_send_digest_auth_request(struct mg_connection *c) { <nl>              "realm=\"%s\", nonce=\"%lu\"\r\n\r\n", <nl>              conn->server->config_options[AUTH_DOMAIN], <nl>              (unsigned long) time(NULL)); <nl> +  close_local_endpoint(conn); <nl>  } <nl>   <nl>  // Use the global passwords file, if specified by auth_gpass option,
@@ -5961,6 +5961,12 @@ static int mg_http_multipart_wait_for_boundary(struct mg_connection *c) { <nl>    struct mbuf *io = &c->recv_mbuf; <nl>    struct mg_http_proto_data *pd = mg_http_get_proto_data(c); <nl>   <nl> +  if (pd->mp_stream.boundary == NULL) { <nl> +    pd->mp_stream.state = MPS_FINALIZE; <nl> +    DBG(("Invalid request: boundary not initilaized")); <nl> +    return 0; <nl> +  } <nl> + <nl>    if ((int) io->len < pd->mp_stream.boundary_len + 2) { <nl>      return 0; <nl>    }
@@ -113,8 +113,10 @@ authreg_t authreg_init(c2s_t c2s, char *name) { <nl>   <nl>  /** shutdown the authreg system */ <nl>  void authreg_free(authreg_t ar) { <nl> -    if(ar->free != NULL) (ar->free)(ar); <nl> -    free(ar); <nl> +    if (ar) { <nl> +        if(ar->free != NULL) (ar->free)(ar); <nl> +        free(ar); <nl> +    } <nl>  } <nl>   <nl>  /** auth get handler */
@@ -70,7 +70,7 @@ <nl>   <nl>   <nl>  #define MIO_ALLOC_FD(m, rfd)    _mio_alloc_fd(m, rfd) <nl> -#define MIO_FREE_FD(m, mfd)     free(mfd) <nl> +#define MIO_FREE_FD(m, mfd)     if(mfd){free(mfd);mfd=NULL;} <nl>   <nl>  #define MIO_REMOVE_FD(m, mfd) \ <nl>      do {                                                                \
@@ -735,8 +735,8 @@ PyImaging_CreateWindowWin32(PyObject* self, PyObject* args) <nl>   <nl>      /* register window callback */ <nl>      Py_INCREF(callback); <nl> -    SetWindowLong(wnd, 0, (LONG) callback); <nl> -    SetWindowLong(wnd, sizeof(callback), (LONG) PyThreadState_Get()); <nl> +    SetWindowLongPtr(wnd, 0, (LONG_PTR) callback); <nl> +    SetWindowLongPtr(wnd, sizeof(callback), (LONG_PTR) PyThreadState_Get()); <nl>   <nl>      Py_BEGIN_ALLOW_THREADS <nl>      ShowWindow(wnd, SW_SHOWNORMAL);
@@ -1914,7 +1914,7 @@ static int oidc_post_config(apr_pool_t *pool, apr_pool_t *p1, apr_pool_t *p2, <nl>  	} <nl>   <nl>  	ap_log_error(APLOG_MARK, APLOG_INFO, 0, s, <nl> -			"%s - init - cjose %s, %s, EC=%s, GCM=%s, Redis=%s", <nl> +			"%s - init - cjose %s, %s, EC=%s, GCM=%s, Redis=%s, JQ=%s", <nl>  			NAMEVERSION, <nl>  			cjose_version(), <nl>  			OPENSSL_VERSION_TEXT, <nl> @@ -1925,7 +1925,13 @@ static int oidc_post_config(apr_pool_t *pool, apr_pool_t *p1, apr_pool_t *p2, <nl>  #else <nl>  			"no" <nl>  #endif <nl> -			); <nl> +			, <nl> +#ifdef USE_LIBJQ <nl> +			"yes" <nl> +#else <nl> +			"no" <nl> +#endif <nl> +	); <nl>   <nl>  	curl_global_init(CURL_GLOBAL_ALL); <nl>  	OpenSSL_add_all_digests();
@@ -3698,6 +3698,9 @@ PyArray_FromString(char *data, npy_intp slen, PyArray_Descr *dtype, <nl>   <nl>      if (dtype == NULL) { <nl>          dtype=PyArray_DescrFromType(NPY_DEFAULT_TYPE); <nl> +        if (dtype == NULL) { <nl> +            return NULL; <nl> +        } <nl>      } <nl>      if (PyDataType_FLAGCHK(dtype, NPY_ITEM_IS_POINTER) || <nl>                      PyDataType_REFCHK(dtype)) {
@@ -214,9 +214,6 @@ static PyUFuncGenericFunction frexp_functions[] = { <nl>  #endif <nl>  }; <nl>   <nl> -static void * blank3_data[] = { (void *)NULL, (void *)NULL, (void *)NULL}; <nl> -static void * blank6_data[] = { (void *)NULL, (void *)NULL, (void *)NULL, <nl> -                                (void *)NULL, (void *)NULL, (void *)NULL}; <nl>  static char frexp_signatures[] = { <nl>  #ifdef HAVE_FREXPF <nl>      NPY_HALF, NPY_HALF, NPY_INT, <nl> @@ -227,6 +224,7 @@ static char frexp_signatures[] = { <nl>      ,NPY_LONGDOUBLE, NPY_LONGDOUBLE, NPY_INT <nl>  #endif <nl>  }; <nl> +static void * blank_data[12]; <nl>   <nl>  #if NPY_SIZEOF_LONG == NPY_SIZEOF_INT <nl>  #define LDEXP_LONG(typ) typ##_ldexp <nl> @@ -357,14 +355,16 @@ InitOtherOperators(PyObject *dictionary) { <nl>      int num; <nl>   <nl>      num = sizeof(frexp_functions) / sizeof(frexp_functions[0]); <nl> -    f = PyUFunc_FromFuncAndData(frexp_functions, blank3_data, <nl> +    assert(sizeof(blank_data) / sizeof(blank_data[0]) >= num); <nl> +    f = PyUFunc_FromFuncAndData(frexp_functions, blank_data, <nl>                                  frexp_signatures, num, <nl>                                  1, 2, PyUFunc_None, "frexp", frdoc, 0); <nl>      PyDict_SetItemString(dictionary, "frexp", f); <nl>      Py_DECREF(f); <nl>   <nl>      num = sizeof(ldexp_functions) / sizeof(ldexp_functions[0]); <nl> -    f = PyUFunc_FromFuncAndData(ldexp_functions, blank6_data, <nl> +    assert(sizeof(blank_data) / sizeof(blank_data[0]) >= num); <nl> +    f = PyUFunc_FromFuncAndData(ldexp_functions, blank_data, <nl>                                  ldexp_signatures, num, <nl>                                  2, 1, PyUFunc_None, "ldexp", lddoc, 0); <nl>      PyDict_SetItemString(dictionary, "ldexp", f);
@@ -1500,6 +1500,10 @@ PyArray_EquivTypenums(int typenum1, int typenum2) <nl>      PyArray_Descr *d1, *d2; <nl>      npy_bool ret; <nl>   <nl> +    if (typenum1 == typenum2) { <nl> +        return NPY_SUCCEED; <nl> +    } <nl> + <nl>      d1 = PyArray_DescrFromType(typenum1); <nl>      d2 = PyArray_DescrFromType(typenum2); <nl>      ret = PyArray_EquivTypes(d1, d2);
@@ -394,6 +394,9 @@ static void receive_udppacket(node_t *n, vpn_packet_t *inpkt) { <nl>  void receive_tcppacket(connection_t *c, const char *buffer, int len) { <nl>  	vpn_packet_t outpkt; <nl>   <nl> +	if(len > sizeof outpkt.data) <nl> +		return; <nl> + <nl>  	outpkt.len = len; <nl>  	if(c->options & OPTION_TCPONLY) <nl>  		outpkt.priority = 0;
@@ -1,6 +1,6 @@ <nl>  /* <nl>      meta.c -- handle the meta communication <nl> -    Copyright (C) 2000-2009 Guus Sliepen <guus@tinc-vpn.org>, <nl> +    Copyright (C) 2000-2013 Guus Sliepen <guus@tinc-vpn.org>, <nl>                    2000-2005 Ivo Timmermans <nl>                    2006      Scott Lamb <slamb@slamb.org> <nl>   <nl> @@ -190,7 +190,7 @@ bool receive_meta(connection_t *c) { <nl>  							logger(LOG_ERR, "Invalid response from proxy server"); <nl>  							return false; <nl>  						} <nl> -						if(c->buffer[1] == 0xff) { <nl> +						if(c->buffer[1] == (char)0xff) { <nl>  							logger(LOG_ERR, "Proxy request rejected: unsuitable authentication method"); <nl>  							return false; <nl>  						}
@@ -2049,6 +2049,9 @@ int decodeInstruction(struct InternalInstruction* insn, <nl>   <nl>  	insn->length = (size_t)(insn->readerCursor - insn->startLocation); <nl>   <nl> +	if (insn->length > 15) <nl> +		return -1; <nl> + <nl>  	// dbgprintf(insn, "Read from 0x%llx to 0x%llx: length %zu", <nl>  	// 		startLoc, insn->readerCursor, insn->length); <nl>  
@@ -959,6 +959,7 @@ bool X86_getInstruction(csh ud, const uint8_t *code, size_t code_len, <nl>  			reader(&info, &b1, address); <nl>  			reader(&info, &b2, address + 1); <nl>  			if (b1 == 0x0f && b2 == 0xff) { <nl> +				instr->Opcode = X86_UD0; <nl>  				instr->OpcodePub = X86_INS_UD0; <nl>  				strncpy(instr->assembly, "ud0", 4); <nl>  				if (instr->flat_insn->detail) {
@@ -128,7 +128,7 @@ CAMLextern struct caml__roots_block *local_roots;  /* defined in roots.c */ <nl>     Use [CAMLlocalN] to declare an array of [value]s. <nl>   <nl>     Your function may raise and exception or return a [value] with the <nl> -   [CAMLreturn1] macro.  Its argument is simply the [value] returned by <nl> +   [CAMLreturn] macro.  Its argument is simply the [value] returned by <nl>     your function.  Do NOT directly return a [value] with the [return] <nl>     keyword.  If your function returns void, use [CAMLreturn0]. <nl>  
@@ -105,7 +105,7 @@ CAMLprim value caml_bytes_set(value str, value index, value newval) <nl>   */ <nl>  CAMLprim value caml_string_set(value str, value index, value newval) <nl>  { <nl> -  return caml_string_set(str,index,newval); <nl> +  return caml_bytes_set(str,index,newval); <nl>  } <nl>   <nl>  
@@ -223,7 +223,11 @@ void CenterWindowOnHostApplication(wxTopLevelWindow *win) <nl>      EnumWindows(EnumProcessWindowsCallback, (LPARAM) &data); <nl>   <nl>      if (data.biggest.IsEmpty()) <nl> -        return; // no window to center on <nl> +    { <nl> +        // no parent window to center on, so center on the screen <nl> +        win->Center(); <nl> +        return; <nl> +    } <nl>   <nl>      const wxRect& host(data.biggest); <nl>  
@@ -601,6 +601,14 @@ class Inode { <nl>      int c = exporting_issued | snap_caps; <nl>      if ((c & mask) == mask) <nl>        return true; <nl> +    // prefer auth cap <nl> +    if (auth_cap && <nl> +	cap_is_valid(auth_cap) && <nl> +	(auth_cap->issued & mask) == mask) { <nl> +      touch_cap(auth_cap); <nl> +      return true; <nl> +    } <nl> +    // try any cap <nl>      for (map<int,InodeCap*>::iterator it = caps.begin(); <nl>           it != caps.end(); <nl>           it++) {
@@ -150,7 +150,10 @@ public: <nl>      set_tid(rtid); <nl>    } <nl>    MOSDSubOp() {} <nl> +private: <nl> +  ~MOSDSubOp() {} <nl>   <nl> +public: <nl>    const char *get_type_name() { return "osd_sub_op"; } <nl>    void print(ostream& out) { <nl>      out << "osd_sub_op(" << reqid
@@ -839,7 +839,7 @@ int validate_pool(IoCtx &io_ctx, CephContext *cct) { <nl>                                             snap_name), <nl>                                 boost::bind(&ImageWatcher::notify_snap_remove, <nl>                                             ictx->image_watcher, snap_name)); <nl> -      if (r < 0 && r != -EEXIST) { <nl> +      if (r < 0 && r != -ENOENT) { <nl>          return r; <nl>        } <nl>      } else {
@@ -1799,6 +1799,11 @@ int FileStore::mount() <nl>    } <nl>   <nl>    dout(5) << "mount op_seq is " << initial_op_seq << dendl; <nl> +  if (initial_op_seq == 0) { <nl> +    derr << "mount initial op seq is 0; something is wrong" << dendl; <nl> +    ret = -EINVAL; <nl> +    goto close_current_fd; <nl> +  } <nl>   <nl>    if (!btrfs_stable_commits) { <nl>      // mark current/ as non-snapshotted so that we don't rollback away
@@ -1125,12 +1125,12 @@ static int do_cache_evict(IoCtx& io_ctx, string oid) <nl>   <nl>  static int do_cache_flush_evict_all(IoCtx& io_ctx, bool blocking) <nl>  { <nl> -  int r; <nl>    int errors = 0; <nl>    try { <nl>      librados::ObjectIterator i = io_ctx.objects_begin(); <nl>      librados::ObjectIterator i_end = io_ctx.objects_end(); <nl>      for (; i != i_end; ++i) { <nl> +      int r; <nl>        cout << i->first << "\t" << i->second << std::endl; <nl>        if (i->second.size()) { <nl>  	io_ctx.locator_set_key(i->second);
@@ -1091,7 +1091,7 @@ CInode* Server::rdlock_path_pin_ref(MDRequest *mdr, bool want_auth) <nl>    // open ref inode <nl>    CInode *ref = 0; <nl>    if (trace.empty()) <nl> -    ref = mdcache->get_root(); <nl> +    ref = mdcache->get_inode(refpath.get_ino()); <nl>    else { <nl>      CDentry *dn = trace[trace.size()-1]; <nl>  
@@ -17,7 +17,7 @@ <nl>  #include "XioConnection.h" <nl>  #include "XioMessenger.h" <nl>  #include "messages/MDataPing.h" <nl> - <nl> +#include "msg/msg_types.h" <nl>  #include "auth/none/AuthNoneProtocol.h" // XXX <nl>   <nl>  #include "include/assert.h" <nl> @@ -398,7 +398,7 @@ int XioConnection::on_msg_req(struct xio_session *session, <nl>        peer_type = hdr.peer_type; <nl>        peer_addr = hdr.addr; <nl>        peer.addr = peer_addr; <nl> -      peer.name = hdr.hdr->src; <nl> +      peer.name = entity_name_t(hdr.hdr->src); <nl>        if (xio_conn_type == XioConnection::PASSIVE) { <nl>  	/* XXX kick off feature/authn/authz negotiation <nl>  	 * nb:  very possibly the active side should initiate this, but
@@ -341,7 +341,7 @@ void PG::merge_log(ObjectStore::Transaction& t, <nl>      list<Log::Entry>::iterator p = log.log.end(); <nl>      while (p != log.log.begin()) { <nl>        p--; <nl> -      if (p->version.version <= log.top.version) { <nl> +      if (p->version <= log.top) { <nl>  	dout(10) << "merge_log split point is " << *p << dendl; <nl>   <nl>  	if (p->version < log.top && p->version < oldest_update) {
@@ -8,16 +8,16 @@ bool MonCaps::get_next_token(string s, size_t& pos, string& token) <nl>    int start = s.find_first_not_of(" \t", pos); <nl>    int end; <nl>   <nl> +  if (start < 0) { <nl> +    return false;  <nl> +  } <nl> + <nl>    if (s[start] == '=' || s[start] == ',' || s[start] == ';') { <nl>      end = start + 1; <nl>    } else { <nl>      end = s.find_first_of(";,= \t", start+1); <nl>    } <nl>   <nl> -  if (start < 0) { <nl> -    return false;  <nl> -  } <nl> - <nl>    if (end < 0) { <nl>      end=s.size(); <nl>    }
@@ -1419,6 +1419,9 @@ int RGWPostObj_ObjStore::read_form_part_header(struct post_form_part* const part <nl>      } <nl>   <nl>      r = read_line(bl, chunk_size, reached_boundary, done); <nl> +    if (r < 0) { <nl> +      return r; <nl> +    } <nl>    } <nl>   <nl>    return 0;
@@ -485,7 +485,7 @@ int OSDMonitor::reweight_by_utilization(int oload, std::string& out_str, <nl>        } <nl>      } <nl>   <nl> -    if (num_pg_copies / num_osds < g_conf->mon_reweight_min_pgs_per_osd) { <nl> +    if (!num_osds || (num_pg_copies / num_osds < g_conf->mon_reweight_min_pgs_per_osd)) { <nl>        ostringstream oss; <nl>        oss << "Refusing to reweight: we only have " << num_pg_copies <nl>  	  << " PGs across " << num_osds << " osds!\n";
@@ -2241,11 +2241,13 @@ bool OSDMonitor::update_pools_status() <nl>        if (!pool_is_full) <nl>  	continue; <nl>   <nl> -      if ((uint64_t)sum.num_bytes >= pool.quota_max_bytes) { <nl> +      if (pool.quota_max_bytes > 0 && <nl> +          (uint64_t)sum.num_bytes >= pool.quota_max_bytes) { <nl>          mon->clog.warn() << "pool '" << pool_name << "' is full" <nl>                           << " (reached quota's max_bytes: " <nl>                           << si_t(pool.quota_max_bytes) << ")"; <nl> -      } else if ((uint64_t)sum.num_objects >= pool.quota_max_objects) { <nl> +      } else if (pool.quota_max_objects > 0 && <nl> +		 (uint64_t)sum.num_objects >= pool.quota_max_objects) { <nl>          mon->clog.warn() << "pool '" << pool_name << "' is full" <nl>                           << " (reached quota's max_objects: " <nl>                           << pool.quota_max_objects << ")";
@@ -828,7 +828,7 @@ protected: <nl>      list<ObjectStore::Transaction*> tls; <nl>       <nl>      RepModify() : pg(NULL), ctx(NULL), applied(false), committed(false), ackerosd(-1), <nl> -		  bytes_written(0) {} <nl> +		  epoch_started(0), bytes_written(0) {} <nl>    }; <nl>   <nl>    struct C_OSD_RepModifyApply : public Context {
@@ -1933,9 +1933,11 @@ void CInode::add_waiter(uint64_t tag, Context *c) <nl>    //  make sure its not the inode that is explicitly ambiguous|freezing|frozen <nl>    if (((tag & WAIT_SINGLEAUTH) && !state_test(STATE_AMBIGUOUSAUTH)) || <nl>        ((tag & WAIT_UNFREEZE) && !is_frozen_inode() && !is_freezing_inode())) { <nl> +    dout(15) << "passing waiter up tree" << dendl; <nl>      parent->dir->add_waiter(tag, c); <nl>      return; <nl>    } <nl> +  dout(15) << "taking waiter here" << dendl; <nl>    MDSCacheObject::add_waiter(tag, c); <nl>  } <nl>   <nl> @@ -2018,7 +2020,7 @@ void CInode::auth_unpin(void *by) <nl>    assert(auth_pins >= 0); <nl>   <nl>    if (parent) <nl> -    parent->adjust_nested_auth_pins(-1, -1, this); <nl> +    parent->adjust_nested_auth_pins(-1, -1, by); <nl>   <nl>    if (is_freezing_inode() && <nl>        auth_pins == auth_pin_freeze_allowance) {
@@ -30,7 +30,7 @@ struct MOSDScrub : public Message { <nl>    MOSDScrub() {} <nl>    MOSDScrub(ceph_fsid& f) : <nl>      Message(MSG_OSD_SCRUB), <nl> -    fsid(f) {} <nl> +    fsid(f), repair(false) {} <nl>    MOSDScrub(ceph_fsid& f, vector<pg_t>& pgs, bool r) : <nl>      Message(MSG_OSD_SCRUB), <nl>      fsid(f), scrub_pgs(pgs), repair(r) {}
@@ -1312,7 +1312,7 @@ int FileStore::_detect_fs() <nl>    char fn[PATH_MAX]; <nl>    int x = rand(); <nl>    int y = x+1; <nl> -  snprintf(fn, sizeof(fn), "%s/fsid", basedir.c_str()); <nl> +  snprintf(fn, sizeof(fn), "%s/whoami", basedir.c_str()); <nl>    int ret = do_setxattr(fn, "user.test", &x, sizeof(x)); <nl>    if (ret >= 0) <nl>      ret = do_getxattr(fn, "user.test", &y, sizeof(y));
@@ -9382,7 +9382,7 @@ int RGWRados::flush_read_list(struct get_obj_data *d) <nl>      bufferlist& bl = *iter; <nl>      r = d->client_cb->handle_data(bl, 0, bl.length()); <nl>      if (r < 0) { <nl> -      dout(0) << "ERROR: flush_read_list(): d->client_c->handle_data() returned " << r << dendl; <nl> +      dout(0) << "ERROR: flush_read_list(): d->client_cb->handle_data() returned " << r << dendl; <nl>        break; <nl>      } <nl>    }
@@ -333,6 +333,13 @@ crush_make_straw_bucket(int type, <nl>   <nl>  	i=0; <nl>  	while (i < size) { <nl> +		/* zero weight items get 0 length straws! */ <nl> +		if (weights[reverse[i]] == 0) { <nl> +			bucket->straws[reverse[i]] = 0; <nl> +			i++; <nl> +			continue; <nl> +		} <nl> + <nl>  		/* set this item's straw */ <nl>  		bucket->straws[reverse[i]] = straw * 0x10000; <nl>  		/*printf("item %d at %d weight %d straw %d (%lf)\n",
@@ -371,7 +371,7 @@ sr_t *CInode::project_snaprealm(snapid_t snapid) <nl>    } else { <nl>      new_srnode = new sr_t(); <nl>      new_srnode->created = snapid; <nl> -    new_srnode->current_parent_since = snapid; <nl> +    new_srnode->current_parent_since = get_oldest_snap(); <nl>    } <nl>    dout(10) << "project_snaprealm " << new_srnode << dendl; <nl>    projected_nodes.back()->snapnode = new_srnode;
@@ -2936,6 +2936,8 @@ void take_min_markers(IterIn first, IterIn last, IterOut dest) <nl>    } <nl>  } <nl>   <nl> +} // anonymous namespace <nl> + <nl>  class DataLogTrimCR : public RGWCoroutine { <nl>    RGWRados *store; <nl>    RGWHTTPManager *http; <nl> @@ -3077,8 +3079,6 @@ int DataLogTrimPollCR::operate() <nl>    return 0; <nl>  } <nl>   <nl> -} // anonymous namespace <nl> - <nl>  RGWCoroutine* create_data_log_trim_cr(RGWRados *store, <nl>                                        RGWHTTPManager *http, <nl>                                        int num_shards, utime_t interval)
@@ -923,6 +923,8 @@ int RGWRados::prepare_atomic_for_write(RGWRadosCtx *rctx, rgw_obj& obj, librados <nl>    do { <nl>      r = prepare_atomic_for_write_impl(rctx, obj, io_ctx, actual_obj, op, pstate); <nl>    } while (r == -ECANCELED); <nl> + <nl> +  return r; <nl>  } <nl>   <nl>  /**
@@ -9,6 +9,8 @@ <nl>   */ <nl>   <nl>  int tcp_read(int sd, char *buf, int len) { <nl> +  if (sd < 0) <nl> +    return -1; <nl>    struct pollfd pfd; <nl>    pfd.fd = sd; <nl>    pfd.events = POLLIN | POLLHUP | POLLRDHUP | POLLNVAL | POLLERR; <nl> @@ -39,6 +41,8 @@ int tcp_read(int sd, char *buf, int len) { <nl>  } <nl>   <nl>  int tcp_write(int sd, const char *buf, int len) { <nl> +  if (sd < 0) <nl> +    return -1; <nl>    struct pollfd pfd; <nl>    pfd.fd = sd; <nl>    pfd.events = POLLOUT | POLLHUP | POLLRDHUP | POLLNVAL | POLLERR;
@@ -520,8 +520,6 @@ OPTION(osd_mon_shutdown_timeout, OPT_DOUBLE, 5) <nl>  OPTION(osd_max_object_size, OPT_U64, 100*1024L*1024L*1024L) // OSD's maximum object size <nl>  OPTION(osd_max_attr_size, OPT_U64, 0) <nl>   <nl> -OPTION(filestore, OPT_BOOL, false) <nl> - <nl>  /// filestore wb throttle limits <nl>  OPTION(filestore_wbthrottle_enable, OPT_BOOL, true) <nl>  OPTION(filestore_wbthrottle_btrfs_bytes_start_flusher, OPT_U64, 41943040)
@@ -4273,6 +4273,14 @@ int FileStore::_collection_move_rename(coll_t oldcid, const ghobject_t& oldoid, <nl>    int r = 0; <nl>    int dstcmp, srccmp; <nl>   <nl> +  if (replaying) { <nl> +    /* If the destination collection doesn't exist during replay, <nl> +     * we need to delete the src object and continue on <nl> +     */ <nl> +    if (!collection_exists(c)) <nl> +      goto out_rm_src; <nl> +  } <nl> + <nl>    dstcmp = _check_replay_guard(c, o, spos); <nl>    if (dstcmp < 0) <nl>      goto out_rm_src;
@@ -60,7 +60,10 @@ class MMDSMap : public Message { <nl>      epoch = mm->get_epoch(); <nl>      mm->encode(encoded); <nl>    } <nl> +private: <nl> +  ~MMDSMap() {} <nl>   <nl> +public: <nl>    const char *get_type_name() { return "mdsmap"; } <nl>    void print(ostream& out) { <nl>      out << "mdsmap(e " << epoch << ")";
@@ -1810,6 +1810,9 @@ int ceph_setxattr(struct dentry *dentry, const char *name, <nl>  	if (strncmp(name, "user.", 5) != 0) <nl>  		return -EOPNOTSUPP; <nl>   <nl> +	if (_ceph_match_vir_xattr(name) != NULL) <nl> +		return -EOPNOTSUPP; <nl> + <nl>  	/* copy value into some pages */ <nl>  	nr_pages = calc_pages_for(0, size); <nl>  	if (nr_pages) {
@@ -6139,6 +6139,15 @@ void Server::handle_client_rename(MDRequestRef& mdr) <nl>  				  &remote_wrlocks, auth_pin_freeze)) <nl>      return; <nl>   <nl> +  if (!check_access(mdr, srcdn->get_dir()->get_inode(), MAY_WRITE)) <nl> +    return; <nl> + <nl> +  if (!check_access(mdr, destdn->get_dir()->get_inode(), MAY_WRITE)) <nl> +    return; <nl> + <nl> +  if (!check_access(mdr, srci, MAY_WRITE)) <nl> +    return; <nl> + <nl>    if (oldin && <nl>        oldin->is_dir() && <nl>        _dir_is_nonempty(mdr, oldin)) {
@@ -6532,5 +6532,8 @@ int OSD::init_op_flags(OpRequestRef op) <nl>      } <nl>    } <nl>   <nl> +  if (op->rmw_flags == 0) <nl> +    return -EINVAL; <nl> + <nl>    return 0; <nl>  }
@@ -418,6 +418,7 @@ int HashIndex::pre_split_folder(uint32_t pg_num, uint64_t expected_num_objs) <nl>    // the below logic is inspired by rados.h#ceph_stable_mod, <nl>    // it basically determines how many sub-folders should we <nl>    // create for splitting <nl> +  assert(pg_num_bits > 0); // otherwise BAD_SHIFT <nl>    if (((1 << (pg_num_bits - 1)) | ps) >= pg_num) { <nl>      ++split_bits; <nl>    } <nl> @@ -430,6 +431,7 @@ int HashIndex::pre_split_folder(uint32_t pg_num, uint64_t expected_num_objs) <nl>      leavies = leavies >> 4; <nl>    } <nl>    for (uint32_t i = 0; i < subs; ++i) { <nl> +    assert(split_bits <= 4); // otherwise BAD_SHIFT <nl>      int v = tmp_id | (i << ((4 - split_bits) % 4)); <nl>      paths.push_back(to_hex(v)); <nl>      ret = create_path(paths);
@@ -296,6 +296,9 @@ public: <nl>      pg_temp.reset(new map<pg_t,vector<int32_t> >(*o.pg_temp)); <nl>      osd_uuid.reset(new vector<uuid_d>(*o.osd_uuid)); <nl>   <nl> +    if (o.osd_primary_affinity) <nl> +      osd_primary_affinity.reset(new vector<__u32>(*o.osd_primary_affinity)); <nl> + <nl>      // NOTE: this still references shared entity_addr_t's. <nl>      osd_addrs.reset(new addrs_s(*o.osd_addrs)); <nl>  
@@ -6111,6 +6111,7 @@ void OSD::handle_osd_map(MOSDMap *m) <nl>  		<< " but failed to encode full with correct crc; requesting" <nl>  		<< dendl; <nl>  	clog->warn() << "failed to encode map e" << e << " with expected crc\n"; <nl> +	delete o; <nl>  	MMonGetOSDMap *req = new MMonGetOSDMap; <nl>  	req->request_full(e, last); <nl>  	monc->send_mon_message(req);
@@ -2035,7 +2035,7 @@ extern "C" int rados_pool_list(rados_t cluster, char *buf, size_t len) <nl>    if (r < 0) <nl>      return r; <nl>   <nl> -  if (!buf) <nl> +  if (len > 0 && !buf) <nl>      return -EINVAL; <nl>   <nl>    char *b = buf;
@@ -385,6 +385,9 @@ int BlockDevice::read(uint64_t off, uint64_t len, bufferlist *pbl, IOContext *io <nl>    } <nl>    pbl->clear(); <nl>    pbl->push_back(p); <nl> +  dout(40) << "data: "; <nl> +  pbl->hexdump(*_dout); <nl> +  *_dout << dendl; <nl>   out: <nl>    Mutex::Locker l(ioc->lock); <nl>    --ioc->num_reading;
@@ -431,6 +431,7 @@ bool CephXAuthorizer::verify_reply(bufferlist::iterator& indata) <nl>      } <nl>    } catch (buffer::error *e) { <nl>      dout(0) << "verify_authorizer_reply exception in decode_decrypt with " << session_key << dendl; <nl> +    delete e; <nl>      return false; <nl>    } <nl>  
@@ -724,11 +724,14 @@ void ceph_handle_snap(struct ceph_mds_client *mdsc, <nl>  				continue; <nl>  			ci = ceph_inode(inode); <nl>  			spin_lock(&inode->i_lock); <nl> +			if (!ci->i_snap_realm) <nl> +				goto split_skip_inode; <nl>  			ceph_put_snap_realm(mdsc, ci->i_snap_realm); <nl>  			list_add(&ci->i_snap_realm_item, <nl>  				 &realm->inodes_with_caps); <nl>  			ci->i_snap_realm = realm; <nl>  			realm->nref++; <nl> +		split_skip_inode: <nl>  			spin_unlock(&inode->i_lock); <nl>  			iput(inode); <nl>  		}
@@ -1147,6 +1147,10 @@ int TNEFParse(TNEFStruct *TNEF) { <nl>    while (TNEFGetHeader(TNEF, &type, &size) == 0) { <nl>      DEBUG2(TNEF->Debug, 2, "Header says type=0x%X, size=%u", type, size); <nl>      DEBUG2(TNEF->Debug, 2, "Header says type=%u, size=%u", type, size); <nl> +    if(size == 0) { <nl> +      printf("ERROR: Field with size of 0\n"); <nl> +      return YTNEF_ERROR_READING_DATA; <nl> +    } <nl>      data = calloc(size, sizeof(BYTE)); <nl>      ALLOCCHECK(data); <nl>      if (TNEFRawRead(TNEF, data, size, &header_checksum) < 0) {
@@ -305,6 +305,7 @@ static char *feh_magick_load_image(char *filename) <nl>  		if (!WIFEXITED(status) || (WEXITSTATUS(status) != 0)) { <nl>  			close(fd); <nl>  			unlink(sfn); <nl> +			free(sfn); <nl>  			sfn = NULL; <nl>   <nl>  			if (!opt.quiet) {
@@ -426,7 +426,7 @@ void winwidget_render_image(winwidget winwid, int resize, int alias) <nl>  		smaller = ((winwid->im_w < max_w) <nl>  			   && (winwid->im_h < max_h)); <nl>   <nl> -		if (!smaller || (opt.zoom_mode == ZOOM_MODE_FILL)) { <nl> +		if (!smaller || opt.zoom_mode) { <nl>  			double ratio = 0.0; <nl>   <nl>  			/* Image is larger than the screen (so wants shrinking), or it's <nl> @@ -580,6 +580,9 @@ double feh_calc_needed_zoom(double *zoom, int orig_w, int orig_h, int dest_w, in <nl>   <nl>  	ratio = ((double) orig_w / orig_h) / ((double) dest_w / dest_h); <nl>   <nl> +	if (opt.zoom_mode == ZOOM_MODE_MAX) <nl> +		ratio = 1.0 / ratio; <nl> + <nl>  	if (ratio > 1.0) <nl>  		*zoom = ((double) dest_w / orig_w); <nl>  	else
@@ -285,6 +285,9 @@ static int put_hash_callback(VALUE key, VALUE val, VALUE context){ <nl>      case T_STRING: <nl>        bson_byte_buffer_put_bson_key(b, key, validating_keys); <nl>        break; <nl> +    case T_SYMBOL: <nl> +      bson_byte_buffer_put_bson_key(b, rb_sym_to_s(key), validating_keys); <nl> +      break; <nl>      default: <nl>        rb_bson_byte_buffer_put_cstring(buffer, rb_funcall(key, rb_intern("to_bson_key"),1,validating_keys)); <nl>    }
@@ -17,6 +17,10 @@ <nl>  #define INT642NUM(v) LL2NUM(v) <nl>  #endif <nl>   <nl> +#ifndef DBL2NUM <nl> +#define DBL2NUM(dbl) rb_float_new(dbl) <nl> +#endif <nl> + <nl>  #ifndef HOST_NAME_MAX <nl>  #define HOST_NAME_MAX 256 <nl>  #endif
@@ -4061,9 +4061,7 @@ next_state_class(CClassNode* cc, OnigCodePoint* vs, enum CCVALTYPE* type, <nl>      } <nl>    } <nl>   <nl> -  if (*state != CCS_START) <nl> -    *state = CCS_VALUE; <nl> - <nl> +  *state = CCS_VALUE; <nl>    *type  = CCV_CLASS; <nl>    return 0; <nl>  } <nl> @@ -4348,6 +4346,12 @@ parse_char_class(Node** np, OnigToken* tok, UChar** src, UChar* end, <nl>            CC_ESC_WARN(env, (UChar* )"-"); <nl>            goto range_end_val; <nl>          } <nl> + <nl> +        if (val_type == CCV_CLASS) { <nl> +          r = ONIGERR_UNMATCHED_RANGE_SPECIFIER_IN_CHAR_CLASS; <nl> +          goto err; <nl> +        } <nl> + <nl>          state = CCS_RANGE; <nl>        } <nl>        else if (state == CCS_START) {
@@ -1442,12 +1442,18 @@ is_allowed_callout_name(OnigEncoding enc, UChar* name, UChar* name_end) <nl>    UChar* p; <nl>    OnigCodePoint c; <nl>   <nl> +  if (name >= name_end) return 0; <nl> + <nl>    p = name; <nl>    while (p < name_end) { <nl>      c = ONIGENC_MBC_TO_CODE(enc, p, name_end); <nl>      if (! IS_ALLOWED_CODE_IN_CALLOUT_NAME(c)) <nl>        return 0; <nl>   <nl> +    if (p == name) { <nl> +      if (c >= '0' && c <= '9') return 0; <nl> +    } <nl> + <nl>      p += ONIGENC_MBC_ENC_LEN(enc, p); <nl>    } <nl>  
@@ -182,6 +182,8 @@ ONIG_EXTERN int onigenc_unicode_apply_all_case_fold P_((OnigCaseFoldType flag, O <nl>      addr = OnigUnicodeFolds2 + (buk)->index;\ <nl>    else if ((buk)->fold_len == 3)\ <nl>      addr = OnigUnicodeFolds3 + (buk)->index;\ <nl> +  else\ <nl> +    addr = 0;\ <nl>  } while (0) <nl>   <nl>  extern OnigCodePoint OnigUnicodeFolds1[];
@@ -2177,6 +2177,8 @@ int CActIf::takeAction(CContext& c, sockstream& fs) <nl>  	StoreResult(&m_coSql, res); <nl>  	CheckForRows(*res, 1); <nl>  	FetchRow(*res, row); <nl> +	if (row[0] == NULL) <nl> +		return ERR_NODATA; <nl>  	if (modifier == CMS_ST_ARTICLE && param.attrType() != "" && !m_bStrictType) <nl>  	{ <nl>  		field = param.attribute();
@@ -635,6 +635,10 @@ int32_t json_object_get_int(const struct json_object *jso) <nl>  		return INT32_MAX; <nl>  	return (int32_t) cint64; <nl>    case json_type_double: <nl> +    if (jso->o.c_double <= INT32_MIN) <nl> +      return INT32_MIN; <nl> +    if (jso->o.c_double >= INT32_MAX) <nl> +      return INT32_MAX; <nl>      return (int32_t)jso->o.c_double; <nl>    case json_type_boolean: <nl>      return jso->o.c_boolean;
@@ -57,11 +57,13 @@ static char *check_dir_or_file(const char *name) { <nl>  					if (ptr && strlen(ptr) == strlen("/firejail")) { <nl>  						if (arg_debug) <nl>  							printf("firejail exec symlink detected\n"); <nl> +						free(actual_path); <nl>  						free(fname); <nl>  						fname = NULL; <nl>  						i++; <nl>  						continue; <nl>  					} <nl> +					free(actual_path); <nl>  				} <nl>  				 <nl>  			}		
@@ -221,16 +221,18 @@ static void WritePixels(struct ngiflib_img * i, struct ngiflib_decode_context * <nl>  			if(p->mode & NGIFLIB_MODE_INDEXED) { <nl>  #endif /* NGIFLIB_INDEXED_ONLY */ <nl>  				for(j = (int)tocopy; j > 0; j--) { <nl> -					if(*pixels != p->transparent_color) *(context->frbuff_p.p8++) = *pixels; <nl> +					if(*pixels != p->transparent_color) *context->frbuff_p.p8 = *pixels; <nl>  					pixels++; <nl> +					context->frbuff_p.p8++; <nl>  				} <nl>  #ifndef NGIFLIB_INDEXED_ONLY <nl>  			} else { <nl>  				for(j = (int)tocopy; j > 0; j--) { <nl>  					if(*pixels != p->transparent_color) { <nl> -						*(context->frbuff_p.p32++) = GifIndexToTrueColor(i->palette, *pixels); <nl> +						*context->frbuff_p.p32 = GifIndexToTrueColor(i->palette, *pixels); <nl>  					} <nl>  					pixels++; <nl> +					context->frbuff_p.p32++; <nl>  				} <nl>  			} <nl>  #endif /* NGIFLIB_INDEXED_ONLY */
@@ -123,8 +123,12 @@ Handle<Value> ODBC::New(const Arguments& args) { <nl>    dbo->Wrap(args.Holder()); <nl>    dbo->m_hEnv = NULL; <nl>     <nl> +  uv_mutex_lock(&ODBC::g_odbcMutex); <nl> +   <nl>    int ret = SQLAllocEnv( &dbo->m_hEnv ); <nl>     <nl> +  uv_mutex_unlock(&ODBC::g_odbcMutex); <nl> +   <nl>    //TODO: check if ret succeeded, if not, throw error to javascript land <nl>    if (!SQL_SUCCEEDED(ret)) { <nl>      //TODO: do something.
@@ -115,7 +115,7 @@ int main(int argc, char *argv[]) <nl>  		    "dosfslabel: labels can be no longer than 11 characters\n"); <nl>  	    exit(1); <nl>  	} <nl> -        for (i = 0; i < 11; i++) <nl> +        for (i = 0; label[i] && i < 11; i++) <nl>            /* don't know if here should be more strict !uppercase(label[i])*/ <nl>            if (islower(label[i])) { <nl>              fprintf(stderr,
@@ -988,6 +988,9 @@ IW_IMPL(int) iw_read_bmp_file(struct iw_context *ctx, struct iw_iodescr *iodescr <nl>  done: <nl>  	if(!retval) { <nl>  		iw_set_error(ctx,"BMP read failed"); <nl> +		// If we didn't call iw_set_input_image, 'img' still belongs to us, <nl> +		// so free its contents. <nl> +		iw_free(ctx, img.pixels); <nl>  	} <nl>  	return retval; <nl>  }
@@ -280,6 +280,15 @@ _gsp_app_manager_handle_delete (GspAppManager *manager, <nl>                  return; <nl>          } <nl>   <nl> +        if (index < position) { <nl> +                /* it got deleted, but in a position earlier than the current <nl> +                 * one. This happens when the user file was changed and became <nl> +                 * identical to the system file; in this case, the user file is <nl> +                 * simply removed. */ <nl> +                 g_assert (index == 0); <nl> +                 return; <nl> +        } <nl> + <nl>          if (position == index && <nl>              (system_position == index || system_position == G_MAXUINT)) { <nl>                  /* the file used by the user was deleted, and there's no other
@@ -167,6 +167,8 @@ check_user_token (const char *authfile, <nl>  		{ <nl>  		  if(verbose) <nl>  		      D (debug_file, "Match user/token as %s/%s", username, otp_id); <nl> + <nl> +		  fclose(opwfile); <nl>  		  return AUTH_FOUND; <nl>  		} <nl>  	    }
@@ -285,10 +285,12 @@ static int create_zone_index(const char *directory, timelib_tzdb *db) <nl>  							db_index[index_next].pos = data_size; <nl>  							data_size += length; <nl>  							free(tzfile_data); <nl> + <nl> +							index_next++; <nl> +						} else { <nl> +							free(db_index[index_next].id); <nl>  						} <nl>  					} <nl> - <nl> -					index_next++; <nl>  				} <nl>  			} <nl>  
@@ -65,6 +65,7 @@ <nl>  #endif <nl>  #include "tls.h" <nl>   <nl> +#define MAX_TEXTCHAT_SIZE 10485760 /* 10MB */ <nl>   <nl>  /* <nl>   * rfbClientLog prints a time-stamped message to the log file (stderr). <nl> @@ -2159,6 +2160,8 @@ HandleRFBServerMessage(rfbClient* client) <nl>                client->HandleTextChat(client, (int)rfbTextChatFinished, NULL); <nl>            break; <nl>        default: <nl> +	  if(msg.tc.length > MAX_TEXTCHAT_SIZE) <nl> +	      return FALSE; <nl>            buffer=malloc(msg.tc.length+1); <nl>            if (!ReadFromRFBServer(client, buffer, msg.tc.length)) <nl>            {
@@ -173,7 +173,7 @@ vips_malloc( VipsObject *object, size_t size ) <nl>  { <nl>  	void *buf; <nl>   <nl> -	buf = g_malloc( size ); <nl> +	buf = g_malloc0( size ); <nl>   <nl>          if( object ) { <nl>  		g_signal_connect( object, "postclose",  <nl> @@ -317,7 +317,7 @@ vips_tracked_malloc( size_t size ) <nl>  	 */ <nl>  	size += 16; <nl>   <nl> -        if( !(buf = g_try_malloc( size )) ) { <nl> +        if( !(buf = g_try_malloc0( size )) ) { <nl>  #ifdef DEBUG <nl>  		g_assert_not_reached(); <nl>  #endif /*DEBUG*/
@@ -522,7 +522,7 @@ static int jsR_hasproperty(js_State *J, js_Object *obj, const char *name) <nl>   <nl>  	else if (obj->type == JS_CREGEXP) { <nl>  		if (!strcmp(name, "source")) { <nl> -			js_pushliteral(J, obj->u.r.source); <nl> +			js_pushstring(J, obj->u.r.source); <nl>  			return 1; <nl>  		} <nl>  		if (!strcmp(name, "global")) {
@@ -199,7 +199,7 @@ int data_on_connection(int fd, callback_remove_handler remove) <nl>  			p+=strlen(network_line); <nl>   <nl>   <nl> -		} else if ( !strncmp(network_line, "GET_DN ", strlen("GET_DN ")) && msg_id != UINT32_MAX && network_client_get_version(fd) > 0) { <nl> +		} else if ( !strncmp(network_line, "GET_DN ", strlen("GET_DN ")) && msg_id != UINT32_MAX && version > PROTOCOL_UNKNOWN && version < PROTOCOL_3) { <nl>   <nl>  			univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, "RECV: GET_DN"); <nl>  
@@ -943,6 +943,8 @@ ipf_extract_frags_from_batch(struct ipf *ipf, struct dp_packet_batch *pb, <nl>              ovs_mutex_lock(&ipf->ipf_lock); <nl>              if (!ipf_handle_frag(ipf, pkt, dl_type, zone, now, hash_basis)) { <nl>                  dp_packet_batch_refill(pb, pkt, pb_idx); <nl> +            } else { <nl> +                dp_packet_delete(pkt); <nl>              } <nl>              ovs_mutex_unlock(&ipf->ipf_lock); <nl>          } else {
@@ -4783,7 +4783,7 @@ int dbd_bind_ph(SV *sth, imp_sth_t *imp_sth, SV *param, SV *value, <nl>    int rc; <nl>    int param_num= SvIV(param); <nl>    int idx= param_num - 1; <nl> -  char err_msg[64]; <nl> +  char *err_msg; <nl>    D_imp_xxh(sth); <nl>   <nl>  #if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION <nl> @@ -4826,9 +4826,9 @@ int dbd_bind_ph(SV *sth, imp_sth_t *imp_sth, SV *param, SV *value, <nl>    { <nl>      if (! looks_like_number(value)) <nl>      { <nl> -      sprintf(err_msg, <nl> +      err_msg = SvPVX(sv_2mortal(newSVpvf( <nl>                "Binding non-numeric field %d, value %s as a numeric!", <nl> -              param_num, neatsvpv(value,0)); <nl> +              param_num, neatsvpv(value,0)))); <nl>        do_error(sth, JW_ERR_ILLEGAL_PARAM_NUM, err_msg, NULL); <nl>      } <nl>    }
@@ -4050,6 +4050,8 @@ process: <nl>            Renew(fbh->data, fbh->length, char); <nl>            buffer->buffer_length= fbh->length; <nl>            buffer->buffer= (char *) fbh->data; <nl> +          imp_sth->stmt->bind[i].buffer_length = fbh->length; <nl> +          imp_sth->stmt->bind[i].buffer = (char *)fbh->data; <nl>   <nl>            if (DBIc_TRACE_LEVEL(imp_xxh) >= 2) { <nl>              int j;
@@ -165,8 +165,9 @@ uint32_t skip(Protocol_& prot, TType arg_type) { <nl>        result += prot.readListEnd(); <nl>        return result; <nl>      } <nl> -    default: <nl> -      return 0; <nl> +    default: { <nl> +      TProtocolException::throwInvalidSkipType(arg_type); <nl> +    } <nl>    } <nl>  } <nl>  
@@ -757,10 +757,11 @@ TEE_Result tee_mmu_check_access_rights(const struct user_ta_ctx *utc, <nl>  				       size_t len) <nl>  { <nl>  	uaddr_t a; <nl> +	uaddr_t end_addr = 0; <nl>  	size_t addr_incr = MIN(CORE_MMU_USER_CODE_SIZE, <nl>  			       CORE_MMU_USER_PARAM_SIZE); <nl>   <nl> -	if (ADD_OVERFLOW(uaddr, len, &a)) <nl> +	if (ADD_OVERFLOW(uaddr, len, &end_addr)) <nl>  		return TEE_ERROR_ACCESS_DENIED; <nl>   <nl>  	if ((flags & TEE_MEMORY_ACCESS_NONSECURE) && <nl> @@ -775,7 +776,7 @@ TEE_Result tee_mmu_check_access_rights(const struct user_ta_ctx *utc, <nl>  	   !tee_mmu_is_vbuf_inside_ta_private(utc, (void *)uaddr, len)) <nl>  		return TEE_ERROR_ACCESS_DENIED; <nl>   <nl> -	for (a = uaddr; a < (uaddr + len); a += addr_incr) { <nl> +	for (a = ROUNDDOWN(uaddr, addr_incr); a < end_addr; a += addr_incr) { <nl>  		uint32_t attr; <nl>  		TEE_Result res; <nl>  
@@ -1014,6 +1014,8 @@ const char *szInsecureArgumentOptions[] = { <nl>  	"$", <nl>  	"<", <nl>  	">", <nl> +	"\n", <nl> +	"\r", <nl>  	NULL <nl>  }; <nl>  
@@ -354,7 +354,9 @@ matchCurrentInput( <nl>  		const InString *input, int pos, const widechar *passInstructions, int passIC) { <nl>  	int k; <nl>  	int kk = pos; <nl> -	for (k = passIC + 2; k < passIC + 2 + passInstructions[passIC + 1]; k++) <nl> +	for (k = passIC + 2; <nl> +			((k < passIC + 2 + passInstructions[passIC + 1]) && (kk < input->length)); <nl> +			k++) <nl>  		if (input->chars[kk] == ENDSEGMENT || passInstructions[k] != input->chars[kk++]) <nl>  			return 0; <nl>  	return 1;
@@ -219,6 +219,11 @@ int af_get_page(AFFILE *af,int64_t pagenum,unsigned char *data,size_t *bytes) <nl>  	    return -3;			// read error <nl>  	} <nl>   <nl> +	/* Sanity check to avoid undefined behaviour when calling malloc below with pagesize from a corrupt AFF image. */ <nl> +	if(af->image_pagesize <= 0 || af->image_pagesize > 16*1024*1024) <nl> +	    return -1; <nl> + <nl> + <nl>  	/* Now uncompress directly into the buffer provided by the caller, unless the caller didn't <nl>  	 * provide a buffer. If that happens, allocate our own... <nl>  	 */
@@ -99,11 +99,12 @@ int mgos_upd_begin(struct mgos_upd_hal_ctx *ctx, struct json_token *parts) { <nl>      return -1; <nl>    } <nl>    uint32_t fw_addr = 0; <nl> +  uint32_t fs_addr = 0; <nl>    if (json_scanf(parts->ptr, parts->len, <nl>                   "{fw: {src: %T, addr: %u, cs_sha1: %T}, " <nl> -                 "fs: {src: %T, cs_sha1: %T}}", <nl> +                 "fs: {src: %T, addr: %u, cs_sha1: %T}}", <nl>                   &ctx->fw_file_name, &fw_addr, &ctx->fw_cs_sha1, <nl> -                 &ctx->fs_file_name, &ctx->fs_cs_sha1) != 5) { <nl> +                 &ctx->fs_file_name, &fs_addr, &ctx->fs_cs_sha1) != 6) { <nl>      ctx->status_msg = "Incomplete update package"; <nl>      return -3; <nl>    } <nl> @@ -117,9 +118,11 @@ int mgos_upd_begin(struct mgos_upd_hal_ctx *ctx, struct json_token *parts) { <nl>    if (!mgos_upd_boot_get_state(&bs)) return -5; <nl>    int inactive_slot = (bs.active_slot == 0 ? 1 : 0); <nl>    get_slot_info(inactive_slot, &ctx->write_slot); <nl> -  /* To facilitate changing firmware location via OTA, we change fw_addr */ <nl> +  /* To allow changing flash layout via OTA, take {fw,fs}_addr from manifest. */ <nl>    ctx->write_slot.fw_addr = <nl>        (ctx->write_slot.id * FW_SLOT_SIZE) + (fw_addr & (FW_SLOT_SIZE - 1)); <nl> +  ctx->write_slot.fs_addr = <nl> +      (ctx->write_slot.id * FW_SLOT_SIZE) + (fs_addr & (FW_SLOT_SIZE - 1)); <nl>   <nl>    LOG(LL_INFO, <nl>        ("Slot %d, FW: %.*s -> 0x%x, FS %.*s -> 0x%x", ctx->write_slot.id,
@@ -1590,7 +1590,7 @@ static const char *stbvox_vertex_program = <nl>        "uniform vec3 normal_table[32];\n" <nl>   <nl>        #ifndef STBVOX_CONFIG_OPENGL_MODELVIEW <nl> -         "uniform mat44 model_view;\n" <nl> +         "uniform mat4x4 model_view;\n" <nl>        #endif <nl>   <nl>        // fragment output data
@@ -59,6 +59,7 @@ void stb_leakcheck_free(void *ptr) <nl>        if (mi->next) <nl>           mi->next->prev = mi->prev; <nl>        #endif <nl> +      free(ptr); <nl>     } <nl>  } <nl>  
@@ -5806,6 +5806,10 @@ static SEL_TREE *get_func_mm_tree(RANGE_OPT_PARAM *param, Item_func *cond_func, <nl>   <nl>    switch (cond_func->functype()) { <nl>   <nl> +  case Item_func::XOR_FUNC: <nl> +    DBUG_RETURN(NULL); // Always true (don't use range access on XOR). <nl> +    break;             // See WL#5800 <nl> + <nl>    case Item_func::NE_FUNC: <nl>      tree= get_ne_mm_tree(param, cond_func, field, value, value, cmp_type); <nl>      break;
@@ -185,6 +185,9 @@ private: <nl>  		const page_size_t&	page_size, <nl>  		const ulint		lob_length) <nl>  	{ <nl> +		/* Disable a performance optimization */ <nl> +		return(true); <nl> + <nl>  		const ulint limit <nl>  			= page_size.physical() * LOB_BIG_THRESHOLD_SIZE; <nl>  		return(lob_length >= limit); <nl> @@ -195,6 +198,9 @@ private: <nl>  	@return true if LOB is big enough, false otherwise. */ <nl>  	bool is_big(const page_size_t& page_size) const <nl>  	{ <nl> +		/* Disable a performance optimization */ <nl> +		return(true); <nl> + <nl>  		const ulint limit <nl>  			= page_size.physical() * LOB_BIG_THRESHOLD_SIZE; <nl>  		const ulint lob_length = length();
@@ -1144,7 +1144,7 @@ innobase_next_autoinc( <nl>  		} else { <nl>  			next_value = current + increment; <nl>  		} <nl> -	} else { <nl> +	} else if (max_value > current) { <nl>  		if (current > offset) { <nl>  			next_value = ((current - offset) / increment) + 1; <nl>  		} else { <nl> @@ -1168,6 +1168,8 @@ innobase_next_autoinc( <nl>  				next_value += offset; <nl>  			} <nl>  		} <nl> +	} else { <nl> +		next_value = max_value; <nl>  	} <nl>   <nl>  	ut_a(next_value <= max_value);
@@ -549,7 +549,7 @@ JOIN::prepare(Item ***rref_pointer_array, <nl>          there. Such fields don't contain any data to sort. <nl>        */ <nl>        if (!real_order && <nl> -          (item->type() != Item::Item::FIELD_ITEM || <nl> +          (item->type() != Item::FIELD_ITEM || <nl>             ((Item_field *) item)->field->maybe_null() || <nl>             ((Item_field *) item)->field->sort_length())) <nl>          real_order= TRUE;
@@ -1961,7 +1961,7 @@ TABLE *Delayed_insert::get_local_table(THD* client_thd) <nl>    my_ptrdiff_t adjust_ptrs; <nl>    Field **field,**org_field, *found_next_number_field; <nl>    TABLE *copy; <nl> -  TABLE_SHARE *share= table->s; <nl> +  TABLE_SHARE *share; <nl>    uchar *bitmap; <nl>    DBUG_ENTER("Delayed_insert::get_local_table"); <nl>   <nl> @@ -1985,6 +1985,7 @@ TABLE *Delayed_insert::get_local_table(THD* client_thd) <nl>        goto error; <nl>      } <nl>    } <nl> +  share= table->s; <nl>   <nl>    /* <nl>      Allocate memory for the TABLE object, the field pointers array, and
@@ -6088,6 +6088,8 @@ lock_table_locks_check( <nl>  	ut_a(table != NULL); <nl>  	ut_ad(lock_mutex_own()); <nl>   <nl> +	rw_lock_s_lock(&trx_sys->lock); <nl> + <nl>  	for (trx = UT_LIST_GET_FIRST(trx_sys->trx_list); <nl>  	     trx != NULL; <nl>  	     trx = UT_LIST_GET_NEXT(trx_list, trx)) { <nl> @@ -6110,6 +6112,8 @@ lock_table_locks_check( <nl>  		} <nl>  	} <nl>   <nl> +	rw_lock_s_unlock(&trx_sys->lock); <nl> + <nl>  	return(NULL); <nl>  } <nl>  #endif /* UNIV_DEBUG */
@@ -6212,7 +6212,7 @@ bool mysql_create_table(THD *thd, TABLE_LIST *create_table, <nl>      if (!result && !thd->is_plugin_fake_ddl()) <nl>        result= trans_commit_stmt(thd) || trans_commit_implicit(thd); <nl>   <nl> -    if (result) <nl> +    if (result && !thd->is_plugin_fake_ddl()) <nl>      { <nl>        trans_rollback_stmt(thd); <nl>        /*
@@ -67,6 +67,7 @@ Guardian::Guardian(Thread_registry *thread_registry_arg, <nl>    monitoring_interval(monitoring_interval_arg), <nl>    thread_registry(thread_registry_arg), <nl>    instance_map(instance_map_arg), <nl> +  guarded_instances(0), <nl>    shutdown_requested(FALSE) <nl>  { <nl>    pthread_mutex_init(&LOCK_guardian, 0);
@@ -186,6 +186,13 @@ Relay_log_info::~Relay_log_info() <nl>    mysql_mutex_destroy(&pending_jobs_lock); <nl>    mysql_cond_destroy(&pending_jobs_cond); <nl>   <nl> +  if(workers_copy_pfs.size()) <nl> +  { <nl> +    for (int i= workers_copy_pfs.size() - 1; i >= 0; i--) <nl> +      delete workers_copy_pfs[i]; <nl> +    workers_copy_pfs.clear(); <nl> +  } <nl> + <nl>    if(!rli_fake) <nl>    { <nl>      my_atomic_rwlock_destroy(&slave_open_temp_tables_lock);
@@ -553,9 +553,11 @@ ha_innobase::check_if_supported_inplace_alter( <nl>   <nl>  	/* We don't support change encryption attribute with <nl>  	inplace algorithm. */ <nl> -	if (strncmp(this->table->s->encrypt_type.str, <nl> -			altered_table->s->encrypt_type.str, <nl> -			altered_table->s->encrypt_type.length) != 0) { <nl> +	char*	old_encryption = this->table->s->encrypt_type.str; <nl> +	char*	new_encryption = altered_table->s->encrypt_type.str; <nl> + <nl> +	if (Encryption::is_none(old_encryption) <nl> +	    != Encryption::is_none(new_encryption)) { <nl>  		ha_alter_info->unsupported_reason = <nl>  			innobase_get_err_msg( <nl>  				ER_UNSUPPORTED_ALTER_ENCRYPTION_INPLACE);
@@ -2149,7 +2149,7 @@ int <nl>  Tablespace_client::get_tablespace_info(CreateFilegroupImplReq* rep) <nl>  { <nl>    Ptr<Tsman::Tablespace> ts_ptr;   <nl> -  if(m_tsman->m_tablespace_hash.find(ts_ptr, m_tablespace_id)); <nl> +  if(m_tsman->m_tablespace_hash.find(ts_ptr, m_tablespace_id)) <nl>    { <nl>      rep->tablespace.extent_size = ts_ptr.p->m_extent_size; <nl>      rep->tablespace.logfile_group_id = 
@@ -2187,6 +2187,9 @@ void st_select_lex_unit::exclude_level() <nl>          if (s->context.outer_context == &sl->context) <nl>            s->context.outer_context= sl->context.outer_context; <nl>        } <nl> +      if (u->fake_select_lex && <nl> +          u->fake_select_lex->context.outer_context == &sl->context) <nl> +        u->fake_select_lex->context.outer_context= sl->context.outer_context; <nl>        u->master= master; <nl>        last= &(u->next); <nl>      }
@@ -231,6 +231,8 @@ int sha256_password_auth_client(MYSQL_PLUGIN_VIO *vio, MYSQL *mysql) <nl>        if (passwd_len > sizeof(passwd_scramble)) <nl>        { <nl>          /* password too long for the buffer */ <nl> +        if (got_public_key_from_server) <nl> +          RSA_free(public_key); <nl>          DBUG_RETURN(CR_ERROR); <nl>        } <nl>        memmove(passwd_scramble, mysql->passwd, passwd_len); <nl> @@ -247,6 +249,8 @@ int sha256_password_auth_client(MYSQL_PLUGIN_VIO *vio, MYSQL *mysql) <nl>        if (passwd_len + 41 >= (unsigned) cipher_length) <nl>        { <nl>          /* password message is to long */ <nl> +        if (got_public_key_from_server) <nl> +          RSA_free(public_key); <nl>          DBUG_RETURN(CR_ERROR); <nl>        } <nl>        RSA_public_encrypt(passwd_len, (unsigned char *) passwd_scramble,
@@ -123,6 +123,12 @@ post_init_event_thread(THD *thd) <nl>      VOID(sigemptyset(&set));                    // Get mask in use <nl>    VOID(pthread_sigmask(SIG_UNBLOCK,&set,&thd->block_signals)); <nl>  #endif <nl> +  pthread_mutex_lock(&LOCK_thread_count); <nl> +  threads.append(thd); <nl> +  thread_count++; <nl> +  thread_running++; <nl> +  pthread_mutex_unlock(&LOCK_thread_count); <nl> + <nl>    return FALSE; <nl>  } <nl>   <nl> @@ -182,9 +188,6 @@ pre_init_event_thread(THD* thd) <nl>    thd->client_capabilities|= CLIENT_MULTI_RESULTS; <nl>    pthread_mutex_lock(&LOCK_thread_count); <nl>    thd->thread_id= thread_id++; <nl> -  threads.append(thd); <nl> -  thread_count++; <nl> -  thread_running++; <nl>    pthread_mutex_unlock(&LOCK_thread_count); <nl>   <nl>    /*
@@ -2152,7 +2152,8 @@ buf_get_latched_pages_number(void) <nl>   <nl>                 block = buf_pool_get_nth_block(buf_pool, i); <nl>   <nl> -               if ((block->buf_fix_count != 0) || (block->io_fix != 0)) <nl> +               if (((block->buf_fix_count != 0) || (block->io_fix != 0)) && <nl> +                    block->magic_n == BUF_BLOCK_MAGIC_N ) <nl>                         fixed_pages_number++; <nl>          } <nl>  
@@ -2420,6 +2420,9 @@ row_log_table_apply_op( <nl>  		next_mrec = mrec + rec_offs_data_size(offsets); <nl>   <nl>  		if (log->table->n_v_cols) { <nl> +			if (next_mrec + 2 > mrec_end) { <nl> +				return(NULL); <nl> +			} <nl>  			next_mrec += mach_read_from_2(next_mrec); <nl>  		} <nl>  
@@ -278,6 +278,7 @@ NdbApiSignal::set(Uint8  trace, <nl>   <nl>  void <nl>  NdbApiSignal::copyFrom(const NdbApiSignal * src){ <nl> +  theSignalId             = src->theSignalId; <nl>    theVerId_signalNumber   = src->theVerId_signalNumber; <nl>    theReceiversBlockNumber = src->theReceiversBlockNumber; <nl>    theSendersBlockRef      = src->theSendersBlockRef; <nl> @@ -292,11 +293,4 @@ NdbApiSignal::copyFrom(const NdbApiSignal * src){ <nl>      dstData[i] = srcData[i]; <nl>   <nl>    setDataPtr(dstData); <nl> -   <nl> -  /** <nl> -   * NOTE that theSignalId is used as data ptr <nl> -   *   and should not be copied <nl> -   * NOTE that theSendersSignalId is used as next pointer <nl> -   *   and should not be copied <nl> -   */ <nl>  }
@@ -1467,6 +1467,9 @@ int TLSX_ValidateEllipticCurves(CYASSL* ssl, byte first, byte second) { <nl>      int            sig       = 0; /* valitade signature */ <nl>      int            key       = 0; /* validate key       */ <nl>   <nl> +    (void)oid; <nl> +    (void)octets; <nl> + <nl>      if (!extension) <nl>          return 1; /* no suite restriction */ <nl>  
@@ -16662,6 +16662,9 @@ void wolfSSL_X509_STORE_CTX_set_time(WOLFSSL_X509_STORE_CTX* ctx, <nl>  { <nl>      (void)flags; <nl>   <nl> +    if (ctx == NULL) <nl> +        return; <nl> + <nl>      ctx->param->check_time = t; <nl>      ctx->param->flags |= WOLFSSL_USE_CHECK_TIME; <nl>  }
@@ -4123,7 +4123,8 @@ static int DoCertificate(CYASSL* ssl, byte* input, word32* inOutIdx, <nl>                  ret = KEYUSE_ENCIPHER_E; <nl>              } <nl>              if ((ssl->specs.sig_algo == rsa_sa_algo || <nl> -                    ssl->specs.sig_algo == ecc_dsa_sa_algo) && <nl> +                    (ssl->specs.sig_algo == ecc_dsa_sa_algo && <nl> +                         !ssl->specs.static_ecdh)) && <nl>                  (dCert.extKeyUsage & KEYUSE_DIGITAL_SIG) == 0) { <nl>                  CYASSL_MSG("KeyUse Digital Sig not set"); <nl>                  ret = KEYUSE_SIGNATURE_E;
@@ -69,7 +69,7 @@ void echoclient_test(void* args) <nl>  #if defined(CYASSL_DTLS) <nl>      method  = DTLSv1_client_method(); <nl>  #elif  !defined(NO_TLS) <nl> -    method = TLSv1_2_client_method(); <nl> +    method = CyaSSLv23_client_method(); <nl>  #else <nl>      method = SSLv3_client_method(); <nl>  #endif
@@ -15783,6 +15783,11 @@ int SetCipherList(WOLFSSL_CTX* ctx, Suites* suites, const char* list) <nl>                  } <nl>              #endif /* WOLFSSL_DTLS */ <nl>   <nl> +                if (idx + 1 >= WOLFSSL_MAX_SUITE_SZ) { <nl> +                    WOLFSSL_MSG("WOLFSSL_MAX_SUITE_SZ set too low"); <nl> +                    return 0; /* suites buffer not large enough, error out */ <nl> +                } <nl> + <nl>                  suites->suites[idx++] = (XSTRSTR(name, "TLS13"))  ? TLS13_BYTE <nl>                                        : (XSTRSTR(name, "CHACHA")) ? CHACHA_BYTE <nl>                                        : (XSTRSTR(name, "QSH"))    ? QSH_BYTE
@@ -217,6 +217,9 @@ int of_irq_parse_raw(const __be32 *addr, struct of_phandle_args *out_irq) <nl>  				goto fail; <nl>  			} <nl>   <nl> +			if (!of_device_is_available(newpar)) <nl> +				match = 0; <nl> + <nl>  			/* Get #interrupt-cells and #address-cells of new <nl>  			 * parent <nl>  			 */
@@ -1226,6 +1226,7 @@ xfs_fs_statfs( <nl>  	struct xfs_inode	*ip = XFS_I(dentry->d_inode); <nl>  	__uint64_t		fakeinos, id; <nl>  	xfs_extlen_t		lsize; <nl> +	__int64_t		ffree; <nl>   <nl>  	statp->f_type = XFS_SB_MAGIC; <nl>  	statp->f_namelen = MAXNAMELEN - 1; <nl> @@ -1249,7 +1250,11 @@ xfs_fs_statfs( <nl>  		statp->f_files = min_t(typeof(statp->f_files), <nl>  					statp->f_files, <nl>  					mp->m_maxicount); <nl> -	statp->f_ffree = statp->f_files - (sbp->sb_icount - sbp->sb_ifree); <nl> + <nl> +	/* make sure statp->f_ffree does not underflow */ <nl> +	ffree = statp->f_files - (sbp->sb_icount - sbp->sb_ifree); <nl> +	statp->f_ffree = max_t(__int64_t, ffree, 0); <nl> + <nl>  	spin_unlock(&mp->m_sb_lock); <nl>   <nl>  	if ((ip->i_d.di_flags & XFS_DIFLAG_PROJINHERIT) ||
@@ -561,6 +561,12 @@ static int rdac_check_sense(struct scsi_device *sdev, <nl>  	struct rdac_dh_data *h = get_rdac_data(sdev); <nl>  	switch (sense_hdr->sense_key) { <nl>  	case NOT_READY: <nl> +		if (sense_hdr->asc == 0x04 && sense_hdr->ascq == 0x01) <nl> +			/* LUN Not Ready - Logical Unit Not Ready and is in <nl> +			* the process of becoming ready <nl> +			* Just retry. <nl> +			*/ <nl> +			return ADD_TO_MLQUEUE; <nl>  		if (sense_hdr->asc == 0x04 && sense_hdr->ascq == 0x81) <nl>  			/* LUN Not Ready - Storage firmware incompatible <nl>  			 * Manual code synchonisation required.
@@ -521,10 +521,14 @@ affs_remount(struct super_block *sb, int *flags, char *data) <nl>  	int			 root_block; <nl>  	unsigned long		 mount_flags; <nl>  	int			 res = 0; <nl> -	char			*new_opts = kstrdup(data, GFP_KERNEL); <nl> +	char			*new_opts; <nl>  	char			 volume[32]; <nl>  	char			*prefix = NULL; <nl>   <nl> +	new_opts = kstrdup(data, GFP_KERNEL); <nl> +	if (!new_opts) <nl> +		return -ENOMEM; <nl> + <nl>  	pr_debug("%s(flags=0x%x,opts=\"%s\")\n", __func__, *flags, data); <nl>   <nl>  	sync_filesystem(sb);
@@ -422,8 +422,12 @@ static void sh_mobile_ceu_videobuf_release(struct vb2_buffer *vb) <nl>  		pcdev->active = NULL; <nl>  	} <nl>   <nl> -	/* Doesn't hurt also if the list is empty */ <nl> -	list_del_init(&buf->queue); <nl> +	/* <nl> +	 * Doesn't hurt also if the list is empty, but it hurts, if queuing the <nl> +	 * buffer failed, and .buf_init() hasn't been called <nl> +	 */ <nl> +	if (buf->queue.next) <nl> +		list_del_init(&buf->queue); <nl>   <nl>  	spin_unlock_irq(&pcdev->lock); <nl>  }
@@ -471,6 +471,8 @@ static int pci_dio_auto_attach(struct comedi_device *dev, <nl>  	else <nl>  		dev->iobase = pci_resource_start(pcidev, 2); <nl>   <nl> +	pci_dio_reset(dev); <nl> + <nl>  	ret = comedi_alloc_subdevices(dev, board->nsubdevs); <nl>  	if (ret) <nl>  		return ret; <nl> @@ -543,8 +545,6 @@ static int pci_dio_auto_attach(struct comedi_device *dev, <nl>  		comedi_8254_subdevice_init(s, dev->pacer); <nl>  	} <nl>   <nl> -	pci_dio_reset(dev); <nl> - <nl>  	return 0; <nl>  } <nl>  
@@ -772,7 +772,7 @@ static struct in_ifaddr *rtm_to_ifaddr(struct net *net, struct nlmsghdr *nlh, <nl>  		ci = nla_data(tb[IFA_CACHEINFO]); <nl>  		if (!ci->ifa_valid || ci->ifa_prefered > ci->ifa_valid) { <nl>  			err = -EINVAL; <nl> -			goto errout; <nl> +			goto errout_free; <nl>  		} <nl>  		*pvalid_lft = ci->ifa_valid; <nl>  		*pprefered_lft = ci->ifa_prefered; <nl> @@ -780,6 +780,8 @@ static struct in_ifaddr *rtm_to_ifaddr(struct net *net, struct nlmsghdr *nlh, <nl>   <nl>  	return ifa; <nl>   <nl> +errout_free: <nl> +	inet_free_ifa(ifa); <nl>  errout: <nl>  	return ERR_PTR(err); <nl>  }
@@ -1560,7 +1560,7 @@ static void switched_to_dl(struct rq *rq, struct task_struct *p) <nl>  	if (unlikely(p->dl.dl_throttled)) <nl>  		return; <nl>   <nl> -	if (p->on_rq || rq->curr != p) { <nl> +	if (p->on_rq && rq->curr != p) { <nl>  #ifdef CONFIG_SMP <nl>  		if (rq->dl.overloaded && push_dl_task(rq) && rq != task_rq(p)) <nl>  			/* Only reschedule if pushing failed */
@@ -489,6 +489,7 @@ static void ati_remote_input_report(struct urb *urb, struct pt_regs *regs) <nl>  		input_regs(dev, regs); <nl>  		input_event(dev, ati_remote_tbl[index].type, <nl>  			ati_remote_tbl[index].code, 1); <nl> +		input_sync(dev); <nl>  		input_event(dev, ati_remote_tbl[index].type, <nl>  			ati_remote_tbl[index].code, 0); <nl>  		input_sync(dev);
@@ -113,9 +113,8 @@ static int pcmad_ai_insn_read(struct comedi_device *dev, <nl>  		data[n] = inb(dev->iobase + PCMAD_LSB); <nl>  		data[n] |= (inb(dev->iobase + PCMAD_MSB) << 8); <nl>   <nl> -		if (devpriv->twos_comp) { <nl> +		if (devpriv->twos_comp) <nl>  			data[n] ^= (1 << (this_board->n_ai_bits - 1)); <nl> -		} <nl>  	} <nl>   <nl>  	return n; <nl> @@ -168,9 +167,8 @@ static int pcmad_detach(struct comedi_device *dev) <nl>  { <nl>  	printk("comedi%d: pcmad: remove\n", dev->minor); <nl>   <nl> -	if (dev->irq) { <nl> +	if (dev->irq) <nl>  		free_irq(dev->irq, dev); <nl> -	} <nl>  	if (dev->iobase) <nl>  		release_region(dev->iobase, PCMAD_SIZE); <nl>  
@@ -571,7 +571,9 @@ static void tegra_uart_rx_dma_complete(void *args) <nl>   <nl>  	tegra_uart_handle_rx_pio(tup, port); <nl>  	if (tty) { <nl> +		spin_unlock_irqrestore(&u->lock, flags); <nl>  		tty_flip_buffer_push(port); <nl> +		spin_lock_irqsave(&u->lock, flags); <nl>  		tty_kref_put(tty); <nl>  	} <nl>  	tegra_uart_start_rx_dma(tup); <nl> @@ -583,11 +585,13 @@ static void tegra_uart_rx_dma_complete(void *args) <nl>  	spin_unlock_irqrestore(&u->lock, flags); <nl>  } <nl>   <nl> -static void tegra_uart_handle_rx_dma(struct tegra_uart_port *tup) <nl> +static void tegra_uart_handle_rx_dma(struct tegra_uart_port *tup, <nl> +		unsigned long *flags) <nl>  { <nl>  	struct dma_tx_state state; <nl>  	struct tty_struct *tty = tty_port_tty_get(&tup->uport.state->port); <nl>  	struct tty_port *port = &tup->uport.state->port; <nl> +	struct uart_port *u = &tup->uport; <nl>  	int count; <nl>   <nl>  	/* Deactivate flow control to stop sender */ <nl> @@ -604,7 +608,9 @@ static void tegra_uart_handle_rx_dma(struct tegra_uart_port *tup) <nl>   <nl>  	tegra_uart_handle_rx_pio(tup, port); <nl>  	if (tty) { <nl> +		spin_unlock_irqrestore(&u->lock, *flags); <nl>  		tty_flip_buffer_push(port); <nl> +		spin_lock_irqsave(&u->lock, *flags); <nl>  		tty_kref_put(tty); <nl>  	} <nl>  	tegra_uart_start_rx_dma(tup); <nl> @@ -671,7 +677,7 @@ static irqreturn_t tegra_uart_isr(int irq, void *data) <nl>  		iir = tegra_uart_read(tup, UART_IIR); <nl>  		if (iir & UART_IIR_NO_INT) { <nl>  			if (is_rx_int) { <nl> -				tegra_uart_handle_rx_dma(tup); <nl> +				tegra_uart_handle_rx_dma(tup, &flags); <nl>  				if (tup->rx_in_progress) { <nl>  					ier = tup->ier_shadow; <nl>  					ier |= (UART_IER_RLSI | UART_IER_RTOIE |
@@ -117,8 +117,10 @@ void rtl92e_set_key(struct net_device *dev, u8 EntryNo, u8 KeyIndex, <nl>  		} <nl>  	} <nl>  	priv->rtllib->is_set_key = true; <nl> -	if (EntryNo >= TOTAL_CAM_ENTRY) <nl> +	if (EntryNo >= TOTAL_CAM_ENTRY) { <nl>  		netdev_info(dev, "%s(): Invalid CAM entry\n", __func__); <nl> +		return; <nl> +	} <nl>   <nl>  	RT_TRACE(COMP_SEC, <nl>  		 "====>to rtl92e_set_key(), dev:%p, EntryNo:%d, KeyIndex:%d,KeyType:%d, MacAddr %pM\n",
@@ -45,6 +45,7 @@ static void *arm64_swiotlb_alloc_coherent(struct device *dev, size_t size, <nl>  	if (IS_ENABLED(CONFIG_DMA_CMA)) { <nl>  		struct page *page; <nl>   <nl> +		size = PAGE_ALIGN(size); <nl>  		page = dma_alloc_from_contiguous(dev, size >> PAGE_SHIFT, <nl>  							get_order(size)); <nl>  		if (!page)
@@ -734,11 +734,11 @@ int __init mvebu_mbus_init(const char *soc, phys_addr_t mbuswins_phys_base, <nl>  { <nl>  	const struct of_device_id *of_id; <nl>   <nl> -	for (of_id = of_mvebu_mbus_ids; of_id->compatible; of_id++) <nl> +	for (of_id = of_mvebu_mbus_ids; of_id->compatible[0]; of_id++) <nl>  		if (!strcmp(of_id->compatible, soc)) <nl>  			break; <nl>   <nl> -	if (!of_id->compatible) { <nl> +	if (!of_id->compatible[0]) { <nl>  		pr_err("could not find a matching SoC family\n"); <nl>  		return -ENODEV; <nl>  	}
@@ -966,6 +966,7 @@ struct em28xx_board em28xx_boards[] = { <nl>  	}, <nl>  	[EM2820_BOARD_PROLINK_PLAYTV_USB2] = { <nl>  		.name         = "Pixelview Prolink PlayTV USB 2.0", <nl> +		.has_snapshot_button = 1, <nl>  		.tda9887_conf = TDA9887_PRESENT, <nl>  		.tuner_type   = TUNER_YMEC_TVF_5533MF, <nl>  		.decoder      = EM28XX_SAA711X,
@@ -124,7 +124,7 @@ void recalc_sigpending_and_wake(struct task_struct *t) <nl>   <nl>  void recalc_sigpending(void) <nl>  { <nl> -	if (!recalc_sigpending_tsk(current)) <nl> +	if (!recalc_sigpending_tsk(current) && !freezing(current)) <nl>  		clear_thread_flag(TIF_SIGPENDING); <nl>   <nl>  }
@@ -375,7 +375,7 @@ static acpi_status __init check_mcfg_resource(struct acpi_resource *res, <nl>  		if (!fixmem32) <nl>  			return AE_OK; <nl>  		if ((mcfg_res->start >= fixmem32->address) && <nl> -		    (mcfg_res->end < (fixmem32->address + <nl> +		    (mcfg_res->end <= (fixmem32->address + <nl>  				      fixmem32->address_length))) { <nl>  			mcfg_res->flags = 1; <nl>  			return AE_CTRL_TERMINATE; <nl> @@ -392,7 +392,7 @@ static acpi_status __init check_mcfg_resource(struct acpi_resource *res, <nl>  		return AE_OK; <nl>   <nl>  	if ((mcfg_res->start >= address.minimum) && <nl> -	    (mcfg_res->end < (address.minimum + address.address_length))) { <nl> +	    (mcfg_res->end <= (address.minimum + address.address_length))) { <nl>  		mcfg_res->flags = 1; <nl>  		return AE_CTRL_TERMINATE; <nl>  	} <nl> @@ -439,7 +439,7 @@ static int __init is_mmconf_reserved(check_reserved_t is_reserved, <nl>  	u64 old_size = size; <nl>  	int valid = 0; <nl>   <nl> -	while (!is_reserved(addr, addr + size - 1, E820_RESERVED)) { <nl> +	while (!is_reserved(addr, addr + size, E820_RESERVED)) { <nl>  		size >>= 1; <nl>  		if (size < (16UL<<20)) <nl>  			break;
@@ -76,12 +76,9 @@ static const struct ixgbevf_info *ixgbevf_info_tbl[] = { <nl>   * { Vendor ID, Device ID, SubVendor ID, SubDevice ID, <nl>   *   Class, Class Mask, private data (not used) } <nl>   */ <nl> -static struct pci_device_id ixgbevf_pci_tbl[] = { <nl> -	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82599_VF), <nl> -	board_82599_vf}, <nl> -	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_X540_VF), <nl> -	board_X540_vf}, <nl> - <nl> +static DEFINE_PCI_DEVICE_TABLE(ixgbevf_pci_tbl) = { <nl> +	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82599_VF), board_82599_vf }, <nl> +	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_X540_VF), board_X540_vf }, <nl>  	/* required last entry */ <nl>  	{0, } <nl>  };
@@ -662,6 +662,12 @@ static struct drm_display_mode *drm_mode_detailed(struct drm_device *dev, <nl>  		return NULL; <nl>  	} <nl>   <nl> +	/* Some EDIDs have bogus h/vtotal values */ <nl> +	if (mode->hsync_end > mode->htotal) <nl> +		mode->htotal = mode->hsync_end + 1; <nl> +	if (mode->vsync_end > mode->vtotal) <nl> +		mode->vtotal = mode->vsync_end + 1; <nl> + <nl>  	drm_mode_set_name(mode); <nl>   <nl>  	if (pt->misc & DRM_EDID_PT_INTERLACED)
@@ -92,7 +92,7 @@ static int __init orion_nand_probe(struct platform_device *pdev) <nl>   <nl>  	res = platform_get_resource(pdev, IORESOURCE_MEM, 0); <nl>  	if (!res) { <nl> -		err = -ENODEV; <nl> +		ret = -ENODEV; <nl>  		goto no_res; <nl>  	} <nl>  
@@ -4899,8 +4899,10 @@ static int netdev_tx(struct sk_buff *skb, struct net_device *dev) <nl>  			struct sk_buff *org_skb = skb; <nl>   <nl>  			skb = dev_alloc_skb(org_skb->len); <nl> -			if (!skb) <nl> -				return NETDEV_TX_BUSY; <nl> +			if (!skb) { <nl> +				rc = NETDEV_TX_BUSY; <nl> +				goto unlock; <nl> +			} <nl>  			skb_copy_and_csum_dev(org_skb, skb->data); <nl>  			org_skb->ip_summed = 0; <nl>  			skb->len = org_skb->len; <nl> @@ -4914,7 +4916,7 @@ static int netdev_tx(struct sk_buff *skb, struct net_device *dev) <nl>  		netif_stop_queue(dev); <nl>  		rc = NETDEV_TX_BUSY; <nl>  	} <nl> - <nl> +unlock: <nl>  	spin_unlock_irq(&hw_priv->hwlock); <nl>   <nl>  	return rc;
@@ -2617,8 +2617,9 @@ static int l2cap_parse_conf_req(struct sock *sk, void *data) <nl>  			break; <nl>  		} <nl>   <nl> -		if (!l2cap_mode_supported(pi->mode, pi->conn->feat_mask)) <nl> +		if (pi->mode != rfc.mode) <nl>  			return -ECONNREFUSED; <nl> + <nl>  		break; <nl>  	default: <nl>  		pi->mode = l2cap_select_mode(rfc.mode, pi->conn->feat_mask);
@@ -166,7 +166,9 @@ static int nci_add_new_protocol(struct nci_dev *ndev, <nl>  	struct rf_tech_specific_params_nfcf_poll *nfcf_poll; <nl>  	__u32 protocol; <nl>   <nl> -	if (rf_protocol == NCI_RF_PROTOCOL_T2T) <nl> +	if (rf_protocol == NCI_RF_PROTOCOL_T1T) <nl> +		protocol = NFC_PROTO_JEWEL_MASK; <nl> +	else if (rf_protocol == NCI_RF_PROTOCOL_T2T) <nl>  		protocol = NFC_PROTO_MIFARE_MASK; <nl>  	else if (rf_protocol == NCI_RF_PROTOCOL_ISO_DEP) <nl>  		if (rf_tech_and_mode == NCI_NFC_A_PASSIVE_POLL_MODE)
@@ -880,6 +880,8 @@ static void igmp_heard_query(struct in_device *in_dev, struct sk_buff *skb, <nl>  		 * to be intended in a v3 query. <nl>  		 */ <nl>  		max_delay = IGMPV3_MRC(ih3->code)*(HZ/IGMP_TIMER_SCALE); <nl> +		if (!max_delay) <nl> +			max_delay = 1;	/* can't mod w/ 0 */ <nl>  	} else { /* v3 */ <nl>  		if (!pskb_may_pull(skb, sizeof(struct igmpv3_query))) <nl>  			return;
@@ -280,7 +280,7 @@ static void raise_dtr(struct isi_port *port) <nl>  } <nl>   <nl>  /* card->lock HAS to be held */ <nl> -static inline void drop_dtr(struct isi_port *port) <nl> +static void drop_dtr(struct isi_port *port) <nl>  { <nl>  	struct isi_board *card = port->card; <nl>  	unsigned long base = card->base;
@@ -70,6 +70,13 @@ void unregister_memory_isolate_notifier(struct notifier_block *nb) <nl>  } <nl>  EXPORT_SYMBOL(unregister_memory_isolate_notifier); <nl>   <nl> +static void memory_block_release(struct device *dev) <nl> +{ <nl> +	struct memory_block *mem = container_of(dev, struct memory_block, dev); <nl> + <nl> +	kfree(mem); <nl> +} <nl> + <nl>  /* <nl>   * register_memory - Setup a sysfs device for a memory block <nl>   */ <nl> @@ -80,6 +87,7 @@ int register_memory(struct memory_block *memory) <nl>   <nl>  	memory->dev.bus = &memory_subsys; <nl>  	memory->dev.id = memory->start_section_nr / sections_per_block; <nl> +	memory->dev.release = memory_block_release; <nl>   <nl>  	error = device_register(&memory->dev); <nl>  	return error; <nl> @@ -635,7 +643,6 @@ int remove_memory_block(unsigned long node_id, struct mem_section *section, <nl>  		mem_remove_simple_file(mem, phys_device); <nl>  		mem_remove_simple_file(mem, removable); <nl>  		unregister_memory(mem); <nl> -		kfree(mem); <nl>  	} else <nl>  		kobject_put(&mem->dev.kobj); <nl>  
@@ -246,13 +246,13 @@ static int ne2k_pci_init_one(struct pci_dev *pdev, <nl>   <nl>  	if (!ioaddr || ((pci_resource_flags (pdev, 0) & IORESOURCE_IO) == 0)) { <nl>  		dev_err(&pdev->dev, "no I/O resource at PCI BAR #0\n"); <nl> -		return -ENODEV; <nl> +		goto err_out; <nl>  	} <nl>   <nl>  	if (request_region (ioaddr, NE_IO_EXTENT, DRV_NAME) == NULL) { <nl>  		dev_err(&pdev->dev, "I/O resource 0x%x @ 0x%lx busy\n", <nl>  			NE_IO_EXTENT, ioaddr); <nl> -		return -EBUSY; <nl> +		goto err_out; <nl>  	} <nl>   <nl>  	reg0 = inb(ioaddr); <nl> @@ -392,6 +392,8 @@ err_out_free_netdev: <nl>  	free_netdev (dev); <nl>  err_out_free_res: <nl>  	release_region (ioaddr, NE_IO_EXTENT); <nl> +err_out: <nl> +	pci_disable_device(pdev); <nl>  	return -ENODEV; <nl>  } <nl>  
@@ -726,6 +726,9 @@ int l2cap_chan_check_security(struct l2cap_chan *chan) <nl>  	struct l2cap_conn *conn = chan->conn; <nl>  	__u8 auth_type; <nl>   <nl> +	if (conn->hcon->type == LE_LINK) <nl> +		return smp_conn_security(conn->hcon, chan->sec_level); <nl> + <nl>  	auth_type = l2cap_get_auth_type(chan); <nl>   <nl>  	return hci_conn_security(conn->hcon, chan->sec_level, auth_type);
@@ -462,7 +462,7 @@ static int __devinit twl_rtc_probe(struct platform_device *pdev) <nl>  	if (ret < 0) <nl>  		goto out1; <nl>   <nl> -	ret = request_irq(irq, twl_rtc_interrupt, <nl> +	ret = request_threaded_irq(irq, NULL, twl_rtc_interrupt, <nl>  				IRQF_TRIGGER_RISING, <nl>  				dev_name(&rtc->dev), rtc); <nl>  	if (ret < 0) {
@@ -1907,7 +1907,7 @@ static struct sk_buff *receive_copy(struct sky2_port *sky2, <nl>  		pci_dma_sync_single_for_device(sky2->hw->pdev, re->data_addr, <nl>  					       length, PCI_DMA_FROMDEVICE); <nl>  		re->skb->ip_summed = CHECKSUM_NONE; <nl> -		__skb_put(skb, length); <nl> +		skb_put(skb, length); <nl>  	} <nl>  	return skb; <nl>  } <nl> @@ -1970,7 +1970,7 @@ static struct sk_buff *receive_new(struct sky2_port *sky2, <nl>  	if (skb_shinfo(skb)->nr_frags) <nl>  		skb_put_frags(skb, hdr_space, length); <nl>  	else <nl> -		skb_put(skb, hdr_space); <nl> +		skb_put(skb, length); <nl>  	return skb; <nl>  } <nl>  
@@ -143,8 +143,7 @@ void hw_cursor_setData(struct lynx_cursor *cursor, <nl>  		iowrite16(data, pbuffer); <nl>   <nl>  		/* assume pitch is 1,2,4,8,...*/ <nl> -		if ((i+1) % pitch == 0) <nl> -		{ <nl> +		if ((i + 1) % pitch == 0) { <nl>  			/* need a return */ <nl>  			pstart += offset; <nl>  			pbuffer = pstart;
@@ -784,7 +784,7 @@ static int pagemap_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end, <nl>   <nl>  	/* find the first VMA at or above 'addr' */ <nl>  	vma = find_vma(walk->mm, addr); <nl> -	if (pmd_trans_huge_lock(pmd, vma) == 1) { <nl> +	if (vma && pmd_trans_huge_lock(pmd, vma) == 1) { <nl>  		for (; addr != end; addr += PAGE_SIZE) { <nl>  			unsigned long offset; <nl>  
@@ -278,8 +278,8 @@ struct code_page_data <nl>  #define DNODE_MAGIC   0x77e40aae <nl>   <nl>  struct dnode { <nl> -  u32 magic;				/* 77e4 0aae */ <nl> -  u32 first_free;			/* offset from start of dnode to <nl> +  __le32 magic;				/* 77e4 0aae */ <nl> +  __le32 first_free;			/* offset from start of dnode to <nl>  					   first free dir entry */ <nl>  #ifdef __LITTLE_ENDIAN <nl>    u8 root_dnode: 1;			/* Is it root dnode? */ <nl> @@ -293,9 +293,9 @@ struct dnode { <nl>    u8 root_dnode: 1;			/* Is it root dnode? */ <nl>  #endif <nl>    u8 increment_me2[3]; <nl> -  secno up;				/* (root dnode) directory's fnode <nl> +  __le32 up;				/* (root dnode) directory's fnode <nl>  					   (nonroot) parent dnode */ <nl> -  dnode_secno self;			/* pointer to this dnode */ <nl> +  __le32 self;			/* pointer to this dnode */ <nl>    u8 dirent[2028];			/* one or more dirents */ <nl>  }; <nl>  
@@ -118,7 +118,7 @@ struct connect_attr { <nl>  	void *arg; <nl>  	enum AUTHTYPE auth_type; <nl>  	u8 ch; <nl> -	void *pJoinParams; <nl> +	void *params; <nl>  }; <nl>   <nl>  struct rcvd_async_info { <nl> @@ -1024,7 +1024,7 @@ static s32 Handle_Connect(struct host_if_drv *hif_drv, <nl>   <nl>  	PRINT_INFO(HOSTINF_DBG, "Saving connection parameters in global structure\n"); <nl>   <nl> -	ptstrJoinBssParam = (struct join_bss_param *)pstrHostIFconnectAttr->pJoinParams; <nl> +	ptstrJoinBssParam = (struct join_bss_param *)pstrHostIFconnectAttr->params; <nl>  	if (ptstrJoinBssParam == NULL) { <nl>  		PRINT_ER("Required BSSID not found\n"); <nl>  		s32Error = -ENOENT; <nl> @@ -3616,7 +3616,7 @@ s32 host_int_set_join_req(struct host_if_drv *hif_drv, u8 *pu8bssid, <nl>  	msg.body.con_info.ch = u8channel; <nl>  	msg.body.con_info.result = pfConnectResult; <nl>  	msg.body.con_info.arg = pvUserArg; <nl> -	msg.body.con_info.pJoinParams = pJoinParams; <nl> +	msg.body.con_info.params = pJoinParams; <nl>  	msg.drv = hif_drv ; <nl>   <nl>  	if (pu8bssid != NULL) {
@@ -138,7 +138,7 @@ idtoname_request(struct cache_detail *cd, struct cache_head *ch, char **bpp, <nl>  	char idstr[11]; <nl>   <nl>  	qword_add(bpp, blen, ent->authname); <nl> -	snprintf(idstr, sizeof(idstr), "%d", ent->id); <nl> +	snprintf(idstr, sizeof(idstr), "%u", ent->id); <nl>  	qword_add(bpp, blen, ent->type == IDMAP_TYPE_GROUP ? "group" : "user"); <nl>  	qword_add(bpp, blen, idstr); <nl>   <nl> @@ -165,7 +165,7 @@ idtoname_show(struct seq_file *m, struct cache_detail *cd, struct cache_head *h) <nl>  		return 0; <nl>  	} <nl>  	ent = container_of(h, struct ent, h); <nl> -	seq_printf(m, "%s %s %d", ent->authname, <nl> +	seq_printf(m, "%s %s %u", ent->authname, <nl>  			ent->type == IDMAP_TYPE_GROUP ? "group" : "user", <nl>  			ent->id); <nl>  	if (test_bit(CACHE_VALID, &h->flags)) <nl> @@ -349,7 +349,7 @@ nametoid_show(struct seq_file *m, struct cache_detail *cd, struct cache_head *h) <nl>  			ent->type == IDMAP_TYPE_GROUP ? "group" : "user", <nl>  			ent->name); <nl>  	if (test_bit(CACHE_VALID, &h->flags)) <nl> -		seq_printf(m, " %d", ent->id); <nl> +		seq_printf(m, " %u", ent->id); <nl>  	seq_printf(m, "\n"); <nl>  	return 0; <nl>  }
@@ -588,8 +588,8 @@ struct pcmcia_device * pcmcia_device_add(struct pcmcia_socket *s, unsigned int f <nl>  	p_dev->socket = s; <nl>  	p_dev->device_no = (s->device_count++); <nl>  	p_dev->func   = function; <nl> -	if (s->functions < function) <nl> -		s->functions = function; <nl> +	if (s->functions <= function) <nl> +		s->functions = function + 1; <nl>   <nl>  	p_dev->dev.bus = &pcmcia_bus_type; <nl>  	p_dev->dev.parent = s->dev.dev;
@@ -950,6 +950,12 @@ static int virtscsi_probe(struct virtio_device *vdev) <nl>  	u32 num_queues; <nl>  	struct scsi_host_template *hostt; <nl>   <nl> +	if (!vdev->config->get) { <nl> +		dev_err(&vdev->dev, "%s failure: config access disabled\n", <nl> +			__func__); <nl> +		return -EINVAL; <nl> +	} <nl> + <nl>  	/* We need to know how many queues before we allocate. */ <nl>  	num_queues = virtscsi_config_get(vdev, num_queues) ? : 1; <nl>  
@@ -1517,6 +1517,8 @@ static int vpbe_display_g_register(struct file *file, void *priv, <nl>  			struct v4l2_dbg_register *reg) <nl>  { <nl>  	struct v4l2_dbg_match *match = &reg->match; <nl> +	struct vpbe_fh *fh = file->private_data; <nl> +	struct vpbe_device *vpbe_dev = fh->disp_dev->vpbe_dev; <nl>   <nl>  	if (match->type >= 2) { <nl>  		v4l2_subdev_call(vpbe_dev->venc,
@@ -161,12 +161,14 @@ static void ib_ucm_cleanup_events(struct ib_ucm_context *ctx) <nl>  				    struct ib_ucm_event, ctx_list); <nl>  		list_del(&uevent->file_list); <nl>  		list_del(&uevent->ctx_list); <nl> +		mutex_unlock(&ctx->file->file_mutex); <nl>   <nl>  		/* clear incoming connections. */ <nl>  		if (ib_ucm_new_cm_id(uevent->resp.event)) <nl>  			ib_destroy_cm_id(uevent->cm_id); <nl>   <nl>  		kfree(uevent); <nl> +		mutex_lock(&ctx->file->file_mutex); <nl>  	} <nl>  	mutex_unlock(&ctx->file->file_mutex); <nl>  }
@@ -849,13 +849,13 @@ static void tun_sock_write_space(struct sock *sk) <nl>  	if (sk->sk_sleep && waitqueue_active(sk->sk_sleep)) <nl>  		wake_up_interruptible_sync(sk->sk_sleep); <nl>   <nl> -	tun = container_of(sk, struct tun_sock, sk)->tun; <nl> +	tun = tun_sk(sk)->tun; <nl>  	kill_fasync(&tun->fasync, SIGIO, POLL_OUT); <nl>  } <nl>   <nl>  static void tun_sock_destruct(struct sock *sk) <nl>  { <nl> -	free_netdev(container_of(sk, struct tun_sock, sk)->tun->dev); <nl> +	free_netdev(tun_sk(sk)->tun->dev); <nl>  } <nl>   <nl>  static struct proto tun_proto = { <nl> @@ -990,7 +990,7 @@ static int tun_set_iff(struct net *net, struct file *file, struct ifreq *ifr) <nl>  		sk->sk_write_space = tun_sock_write_space; <nl>  		sk->sk_sndbuf = INT_MAX; <nl>   <nl> -		container_of(sk, struct tun_sock, sk)->tun = tun; <nl> +		tun_sk(sk)->tun = tun; <nl>   <nl>  		security_tun_dev_post_create(sk); <nl>  
@@ -849,11 +849,13 @@ int ext4_da_write_inline_data_begin(struct address_space *mapping, <nl>  	handle_t *handle; <nl>  	struct page *page; <nl>  	struct ext4_iloc iloc; <nl> +	int retries; <nl>   <nl>  	ret = ext4_get_inode_loc(inode, &iloc); <nl>  	if (ret) <nl>  		return ret; <nl>   <nl> +retry_journal: <nl>  	handle = ext4_journal_start(inode, EXT4_HT_INODE, 1); <nl>  	if (IS_ERR(handle)) { <nl>  		ret = PTR_ERR(handle); <nl> @@ -875,6 +877,11 @@ int ext4_da_write_inline_data_begin(struct address_space *mapping, <nl>  							    inode, <nl>  							    flags, <nl>  							    fsdata); <nl> +		ext4_journal_stop(handle); <nl> +		handle = NULL; <nl> +		if (ret == -ENOSPC && <nl> +		    ext4_should_retry_alloc(inode->i_sb, &retries)) <nl> +			goto retry_journal; <nl>  		goto out; <nl>  	} <nl>  
@@ -263,7 +263,7 @@ int wusbhc_chid_set(struct wusbhc *wusbhc, const struct wusb_ckhdid *chid) <nl>  { <nl>  	int result = 0; <nl>   <nl> -	if (memcmp(chid, &wusb_ckhdid_zero, sizeof(chid)) == 0) <nl> +	if (memcmp(chid, &wusb_ckhdid_zero, sizeof(*chid)) == 0) <nl>  		chid = NULL; <nl>   <nl>  	mutex_lock(&wusbhc->mutex);
@@ -25,7 +25,7 @@ struct ci_hdrc_usb2_priv { <nl>  	struct clk		*clk; <nl>  }; <nl>   <nl> -static struct ci_hdrc_platform_data ci_default_pdata = { <nl> +static const struct ci_hdrc_platform_data ci_default_pdata = { <nl>  	.capoffset	= DEF_CAPOFFSET, <nl>  	.flags		= CI_HDRC_DISABLE_STREAMING, <nl>  }; <nl> @@ -37,8 +37,10 @@ static int ci_hdrc_usb2_probe(struct platform_device *pdev) <nl>  	struct ci_hdrc_platform_data *ci_pdata = dev_get_platdata(dev); <nl>  	int ret; <nl>   <nl> -	if (!ci_pdata) <nl> -		ci_pdata = &ci_default_pdata; <nl> +	if (!ci_pdata) { <nl> +		ci_pdata = devm_kmalloc(dev, sizeof(*ci_pdata), GFP_KERNEL); <nl> +		*ci_pdata = ci_default_pdata;	/* struct copy */ <nl> +	} <nl>   <nl>  	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL); <nl>  	if (!priv)
@@ -3755,6 +3755,13 @@ static struct l2cap_chan *l2cap_connect(struct l2cap_conn *conn, <nl>   <nl>  	sk = chan->sk; <nl>   <nl> +	/* For certain devices (ex: HID mouse), support for authentication, <nl> +	 * pairing and bonding is optional. For such devices, inorder to avoid <nl> +	 * the ACL alive for too long after L2CAP disconnection, reset the ACL <nl> +	 * disc_timeout back to HCI_DISCONN_TIMEOUT during L2CAP connect. <nl> +	 */ <nl> +	conn->hcon->disc_timeout = HCI_DISCONN_TIMEOUT; <nl> + <nl>  	bacpy(&bt_sk(sk)->src, conn->src); <nl>  	bacpy(&bt_sk(sk)->dst, conn->dst); <nl>  	chan->psm  = psm;
@@ -133,6 +133,15 @@ static void bcma_sprom_extract_r8(struct bcma_bus *bus, const u16 *sprom) <nl>  		v = sprom[SPOFF(SSB_SPROM8_IL0MAC) + i]; <nl>  		*(((__be16 *)bus->sprom.il0mac) + i) = cpu_to_be16(v); <nl>  	} <nl> + <nl> +	bus->sprom.board_rev = sprom[SPOFF(SSB_SPROM8_BOARDREV)]; <nl> + <nl> +	bus->sprom.boardflags_lo = sprom[SPOFF(SSB_SPROM8_BFLLO)]; <nl> +	bus->sprom.boardflags_hi = sprom[SPOFF(SSB_SPROM8_BFLHI)]; <nl> +	bus->sprom.boardflags2_lo = sprom[SPOFF(SSB_SPROM8_BFL2LO)]; <nl> +	bus->sprom.boardflags2_hi = sprom[SPOFF(SSB_SPROM8_BFL2HI)]; <nl> + <nl> +	bus->sprom.country_code = sprom[SPOFF(SSB_SPROM8_CCODE)]; <nl>  } <nl>   <nl>  int bcma_sprom_get(struct bcma_bus *bus)
@@ -229,8 +229,7 @@ int cfg80211_mgd_wext_giwessid(struct net_device *dev, <nl>  		data->flags = 1; <nl>  		data->length = wdev->wext.connect.ssid_len; <nl>  		memcpy(ssid, wdev->wext.connect.ssid, data->length); <nl> -	} else <nl> -		data->flags = 0; <nl> +	} <nl>  	wdev_unlock(wdev); <nl>   <nl>  	return 0; <nl> @@ -306,8 +305,6 @@ int cfg80211_mgd_wext_giwap(struct net_device *dev, <nl>  	wdev_lock(wdev); <nl>  	if (wdev->current_bss) <nl>  		memcpy(ap_addr->sa_data, wdev->current_bss->pub.bssid, ETH_ALEN); <nl> -	else if (wdev->wext.connect.bssid) <nl> -		memcpy(ap_addr->sa_data, wdev->wext.connect.bssid, ETH_ALEN); <nl>  	else <nl>  		memset(ap_addr->sa_data, 0, ETH_ALEN); <nl>  	wdev_unlock(wdev);
@@ -324,14 +324,14 @@ static struct vmap_area *alloc_vmap_area(unsigned long size, <nl>   <nl>  	BUG_ON(size & ~PAGE_MASK); <nl>   <nl> -	addr = ALIGN(vstart, align); <nl> - <nl>  	va = kmalloc_node(sizeof(struct vmap_area), <nl>  			gfp_mask & GFP_RECLAIM_MASK, node); <nl>  	if (unlikely(!va)) <nl>  		return ERR_PTR(-ENOMEM); <nl>   <nl>  retry: <nl> +	addr = ALIGN(vstart, align); <nl> + <nl>  	spin_lock(&vmap_area_lock); <nl>  	/* XXX: could have a last_hole cache */ <nl>  	n = vmap_area_root.rb_node;
@@ -2253,14 +2253,20 @@ static int masked_set_action_to_set_action_attr(const struct nlattr *a, <nl>  						struct sk_buff *skb) <nl>  { <nl>  	const struct nlattr *ovs_key = nla_data(a); <nl> +	struct nlattr *nla; <nl>  	size_t key_len = nla_len(ovs_key) / 2; <nl>   <nl>  	/* Revert the conversion we did from a non-masked set action to <nl>  	 * masked set action. <nl>  	 */ <nl> -	if (nla_put(skb, OVS_ACTION_ATTR_SET, nla_len(a) - key_len, ovs_key)) <nl> +	nla = nla_nest_start(skb, OVS_ACTION_ATTR_SET); <nl> +	if (!nla) <nl>  		return -EMSGSIZE; <nl>   <nl> +	if (nla_put(skb, nla_type(ovs_key), key_len, nla_data(ovs_key))) <nl> +		return -EMSGSIZE; <nl> + <nl> +	nla_nest_end(skb, nla); <nl>  	return 0; <nl>  } <nl>  
@@ -3690,8 +3690,8 @@ static __always_inline void *__do_kmalloc(size_t size, gfp_t flags, <nl>  	 * functions. <nl>  	 */ <nl>  	cachep = __find_general_cachep(size, flags); <nl> -	if (unlikely(cachep == NULL)) <nl> -		return NULL; <nl> +	if (unlikely(ZERO_OR_NULL_PTR(cachep))) <nl> +		return cachep; <nl>  	return __cache_alloc(cachep, flags, caller); <nl>  } <nl>  
@@ -1096,17 +1096,17 @@ cifs_parse_mount_options(char *options, const char *devname, <nl>  				return 1; <nl>  			} <nl>  		} else if (strnicmp(data, "uid", 3) == 0) { <nl> -			if (value && *value) { <nl> +			if (value && *value) <nl>  				vol->linux_uid = <nl>  					simple_strtoul(value, &value, 0); <nl> +		} else if (strnicmp(data, "forceuid", 8) == 0) { <nl>  				vol->override_uid = 1; <nl> -			} <nl>  		} else if (strnicmp(data, "gid", 3) == 0) { <nl> -			if (value && *value) { <nl> +			if (value && *value) <nl>  				vol->linux_gid = <nl>  					simple_strtoul(value, &value, 0); <nl> +		} else if (strnicmp(data, "forcegid", 8) == 0) { <nl>  				vol->override_gid = 1; <nl> -			} <nl>  		} else if (strnicmp(data, "file_mode", 4) == 0) { <nl>  			if (value && *value) { <nl>  				vol->file_mode =
@@ -191,7 +191,7 @@ static void * unflatten_dt_node(void *blob, <nl>  	if (!pathp) <nl>  		return mem; <nl>   <nl> -	allocl = l++; <nl> +	allocl = ++l; <nl>   <nl>  	/* version 0x10 has a more compact unit name here instead of the full <nl>  	 * path. we accumulate the full path size using "fpsize", we'll rebuild
@@ -168,7 +168,7 @@ static irqreturn_t pcf8563_irq(int irq, void *dev_id) <nl>   <nl>  	err = pcf8563_get_alarm_mode(pcf8563->client, NULL, &pending); <nl>  	if (err) <nl> -		return err; <nl> +		return IRQ_NONE; <nl>   <nl>  	if (pending) { <nl>  		rtc_update_irq(pcf8563->rtc, 1, RTC_IRQF | RTC_AF);
@@ -1921,7 +1921,7 @@ static void vmx_queue_exception(struct kvm_vcpu *vcpu, unsigned nr, <nl>  	struct vcpu_vmx *vmx = to_vmx(vcpu); <nl>  	u32 intr_info = nr | INTR_INFO_VALID_MASK; <nl>   <nl> -	if (nr == PF_VECTOR && is_guest_mode(vcpu) && <nl> +	if (!reinject && nr == PF_VECTOR && is_guest_mode(vcpu) && <nl>  	    !vmx->nested.nested_run_pending && nested_pf_handled(vcpu)) <nl>  		return; <nl>   <nl> @@ -7053,9 +7053,9 @@ static void __vmx_complete_interrupts(struct kvm_vcpu *vcpu, <nl>  	case INTR_TYPE_HARD_EXCEPTION: <nl>  		if (idt_vectoring_info & VECTORING_INFO_DELIVER_CODE_MASK) { <nl>  			u32 err = vmcs_read32(error_code_field); <nl> -			kvm_queue_exception_e(vcpu, vector, err); <nl> +			kvm_requeue_exception_e(vcpu, vector, err); <nl>  		} else <nl> -			kvm_queue_exception(vcpu, vector); <nl> +			kvm_requeue_exception(vcpu, vector); <nl>  		break; <nl>  	case INTR_TYPE_SOFT_INTR: <nl>  		vcpu->arch.event_exit_inst_len = vmcs_read32(instr_len_field); <nl> @@ -8013,7 +8013,7 @@ static void vmcs12_save_pending_event(struct kvm_vcpu *vcpu, <nl>  	u32 idt_vectoring; <nl>  	unsigned int nr; <nl>   <nl> -	if (vcpu->arch.exception.pending) { <nl> +	if (vcpu->arch.exception.pending && vcpu->arch.exception.reinject) { <nl>  		nr = vcpu->arch.exception.nr; <nl>  		idt_vectoring = nr | VECTORING_INFO_VALID_MASK; <nl>  
@@ -64,6 +64,7 @@ MODULE_PARM_DESC(reset_mode, "0: auto, 1: warm only (default: 0)"); <nl>  static const struct pci_device_id ath10k_pci_id_table[] = { <nl>  	{ PCI_VDEVICE(ATHEROS, QCA988X_2_0_DEVICE_ID) }, /* PCI-E QCA988X V2 */ <nl>  	{ PCI_VDEVICE(ATHEROS, QCA6174_2_1_DEVICE_ID) }, /* PCI-E QCA6174 V2.1 */ <nl> +	{ PCI_VDEVICE(ATHEROS, QCA99X0_2_0_DEVICE_ID) }, /* PCI-E QCA99X0 V2 */ <nl>  	{0} <nl>  }; <nl>   <nl> @@ -78,6 +79,7 @@ static const struct ath10k_pci_supp_chip ath10k_pci_supp_chips[] = { <nl>  	{ QCA6174_2_1_DEVICE_ID, QCA6174_HW_3_0_CHIP_ID_REV }, <nl>  	{ QCA6174_2_1_DEVICE_ID, QCA6174_HW_3_1_CHIP_ID_REV }, <nl>  	{ QCA6174_2_1_DEVICE_ID, QCA6174_HW_3_2_CHIP_ID_REV }, <nl> +	{ QCA99X0_2_0_DEVICE_ID, QCA99X0_HW_2_0_CHIP_ID_REV }, <nl>  }; <nl>   <nl>  static void ath10k_pci_buffer_cleanup(struct ath10k *ar);
@@ -2913,6 +2913,11 @@ skip_msix: <nl>  	} else <nl>  		ql_log(ql_log_warn, vha, 0x0039, <nl>  		    "MSI-X; Falling back-to INTa mode -- %d.\n", ret); <nl> + <nl> +	/* Skip INTx on ISP82xx. */ <nl> +	if (!ha->flags.msi_enabled && IS_QLA82XX(ha)) <nl> +		return QLA_FUNCTION_FAILED; <nl> + <nl>  skip_msi: <nl>   <nl>  	ret = request_irq(ha->pdev->irq, ha->isp_ops->intr_handler,
@@ -92,7 +92,7 @@ struct fbcon_ops { <nl>  #define attr_fgcol(fgshift,s)    \ <nl>  	(((s) >> (fgshift)) & 0x0f) <nl>  #define attr_bgcol(bgshift,s)    \ <nl> -	(((s) >> (bgshift)) & 0x07) <nl> +	(((s) >> (bgshift)) & 0x0f) <nl>   <nl>  /* Monochrome */ <nl>  #define attr_bold(s) \
@@ -347,6 +347,7 @@ static int rt2500usb_config_key(struct rt2x00_dev *rt2x00dev, <nl>  { <nl>  	u32 mask; <nl>  	u16 reg; <nl> +	enum cipher curr_cipher; <nl>   <nl>  	if (crypto->cmd == SET_KEY) { <nl>  		/* <nl> @@ -357,6 +358,7 @@ static int rt2500usb_config_key(struct rt2x00_dev *rt2x00dev, <nl>  		mask = TXRX_CSR0_KEY_ID.bit_mask; <nl>   <nl>  		rt2500usb_register_read(rt2x00dev, TXRX_CSR0, &reg); <nl> +		curr_cipher = rt2x00_get_field16(reg, TXRX_CSR0_ALGORITHM); <nl>  		reg &= mask; <nl>   <nl>  		if (reg && reg == mask) <nl> @@ -365,6 +367,14 @@ static int rt2500usb_config_key(struct rt2x00_dev *rt2x00dev, <nl>  		reg = rt2x00_get_field16(reg, TXRX_CSR0_KEY_ID); <nl>   <nl>  		key->hw_key_idx += reg ? ffz(reg) : 0; <nl> +		/* <nl> +		 * Hardware requires that all keys use the same cipher <nl> +		 * (e.g. TKIP-only, AES-only, but not TKIP+AES). <nl> +		 * If this is not the first key, compare the cipher with the <nl> +		 * first one and fall back to SW crypto if not the same. <nl> +		 */ <nl> +		if (key->hw_key_idx > 0 && crypto->cipher != curr_cipher) <nl> +			return -EOPNOTSUPP; <nl>   <nl>  		rt2500usb_register_multiwrite(rt2x00dev, reg, <nl>  					      crypto->key, sizeof(crypto->key));
@@ -53,7 +53,7 @@ int ocrdma_query_gid(struct ib_device *ibdev, u8 port, <nl>   <nl>  	dev = get_ocrdma_dev(ibdev); <nl>  	memset(sgid, 0, sizeof(*sgid)); <nl> -	if (index > OCRDMA_MAX_SGID) <nl> +	if (index >= OCRDMA_MAX_SGID) <nl>  		return -EINVAL; <nl>   <nl>  	memcpy(sgid, &dev->sgid_tbl[index], sizeof(*sgid));
@@ -673,11 +673,17 @@ static long uvc_v4l2_do_ioctl(struct file *file, unsigned int cmd, void *arg) <nl>  	{ <nl>  		struct v4l2_fmtdesc *fmt = arg; <nl>  		struct uvc_format *format; <nl> +		enum v4l2_buf_type type = fmt->type; <nl> +		__u32 index = fmt->index; <nl>   <nl>  		if (fmt->type != video->streaming->type || <nl>  		    fmt->index >= video->streaming->nformats) <nl>  			return -EINVAL; <nl>   <nl> +		memset(fmt, 0, sizeof(*fmt)); <nl> +		fmt->index = index; <nl> +		fmt->type = type; <nl> + <nl>  		format = &video->streaming->format[fmt->index]; <nl>  		fmt->flags = 0; <nl>  		if (format->flags & UVC_FMT_FLAG_COMPRESSED)
@@ -833,7 +833,8 @@ void ipath_clear_freeze(struct ipath_devdata *dd) <nl>  	 */ <nl>  	for (i = 0; i < dd->ipath_pioavregs; i++) { <nl>  		/* deal with 6110 chip bug */ <nl> -		im = i > 3 ? i ^ 1 : i; <nl> +		im = (i > 3 && (dd->ipath_flags & IPATH_SWAP_PIOBUFS)) ? <nl> +			i ^ 1 : i; <nl>  		val = ipath_read_kreg64(dd, (0x1000 / sizeof(u64)) + im); <nl>  		dd->ipath_pioavailregs_dma[i] = cpu_to_le64(val); <nl>  		dd->ipath_pioavailshadow[i] = val;
@@ -2159,6 +2159,8 @@ static int tun_chr_open(struct inode *inode, struct file * file) <nl>  	set_bit(SOCK_EXTERNALLY_ALLOCATED, &tfile->socket.flags); <nl>  	INIT_LIST_HEAD(&tfile->next); <nl>   <nl> +	sock_set_flag(&tfile->sk, SOCK_ZEROCOPY); <nl> + <nl>  	return 0; <nl>  } <nl>  
@@ -4106,15 +4106,8 @@ static void valleyview_set_rps(struct drm_device *dev, u8 val) <nl>  */ <nl>  static void vlv_set_rps_idle(struct drm_i915_private *dev_priv) <nl>  { <nl> -	struct drm_device *dev = dev_priv->dev; <nl>  	u32 val = dev_priv->rps.idle_freq; <nl>   <nl> -	/* CHV don't need to force the gfx clock */ <nl> -	if (IS_CHERRYVIEW(dev)) { <nl> -		valleyview_set_rps(dev_priv->dev, val); <nl> -		return; <nl> -	} <nl> - <nl>  	if (dev_priv->rps.cur_freq <= val) <nl>  		return; <nl>  
@@ -7,6 +7,8 @@ <nl>  #ifndef _ASM_ARM_SYSCALL_H <nl>  #define _ASM_ARM_SYSCALL_H <nl>   <nl> +#include <linux/audit.h> /* for AUDIT_ARCH_* */ <nl> +#include <linux/elf.h> /* for ELF_EM */ <nl>  #include <linux/err.h> <nl>  #include <linux/sched.h> <nl>   <nl> @@ -95,4 +97,11 @@ static inline void syscall_set_arguments(struct task_struct *task, <nl>  	memcpy(&regs->ARM_r0 + i, args, n * sizeof(args[0])); <nl>  } <nl>   <nl> +static inline int syscall_get_arch(struct task_struct *task, <nl> +				   struct pt_regs *regs) <nl> +{ <nl> +	/* ARM tasks don't change audit architectures on the fly. */ <nl> +	return AUDIT_ARCH_ARM; <nl> +} <nl> + <nl>  #endif /* _ASM_ARM_SYSCALL_H */
@@ -2990,6 +2990,9 @@ int mlx4_QP_ATTACH_wrapper(struct mlx4_dev *dev, int slave, <nl>  	u8 steer_type_mask = 2; <nl>  	enum mlx4_steer_type type = (gid[7] & steer_type_mask) >> 1; <nl>   <nl> +	if (dev->caps.steering_mode != MLX4_STEERING_MODE_B0) <nl> +		return -EINVAL; <nl> + <nl>  	qpn = vhcr->in_modifier & 0xffffff; <nl>  	err = get_res(dev, slave, qpn, RES_QP, &rqp); <nl>  	if (err)
@@ -2433,14 +2433,12 @@ int snd_soc_put_volsw_2r_sx(struct snd_kcontrol *kcontrol, <nl>  	if (oval != val) { <nl>  		ret = snd_soc_write(codec, mc->reg, val); <nl>  		if (ret < 0) <nl> -			return 0; <nl> -		ret = 1; <nl> +			return ret; <nl>  	} <nl>  	if (ovalr != valr) { <nl>  		ret = snd_soc_write(codec, mc->rreg, valr); <nl>  		if (ret < 0) <nl> -			return 0; <nl> -		ret = 1; <nl> +			return ret; <nl>  	} <nl>   <nl>  	return 0;
@@ -836,6 +836,11 @@ xfs_qm_reset_dqcounts( <nl>  		 */ <nl>  		xfs_dqcheck(mp, ddq, id+j, type, XFS_QMOPT_DQREPAIR, <nl>  			    "xfs_quotacheck"); <nl> +		/* <nl> +		 * Reset type in case we are reusing group quota file for <nl> +		 * project quotas or vice versa <nl> +		 */ <nl> +		ddq->d_flags = type; <nl>  		ddq->d_bcount = 0; <nl>  		ddq->d_icount = 0; <nl>  		ddq->d_rtbcount = 0;
@@ -746,8 +746,7 @@ mv64xxx_of_config(struct mv64xxx_i2c_data *drv_data, <nl>  	} <nl>  	tclk = clk_get_rate(drv_data->clk); <nl>   <nl> -	rc = of_property_read_u32(np, "clock-frequency", &bus_freq); <nl> -	if (rc) <nl> +	if (of_property_read_u32(np, "clock-frequency", &bus_freq)) <nl>  		bus_freq = 100000; /* 100kHz by default */ <nl>   <nl>  	if (!mv64xxx_find_baud_factors(bus_freq, tclk,
@@ -895,13 +895,15 @@ static void alc_init_auto_hp(struct hda_codec *codec) <nl>  	if (present == 3) <nl>  		spec->automute_hp_lo = 1; /* both HP and LO automute */ <nl>   <nl> -	if (!cfg->speaker_pins[0]) { <nl> +	if (!cfg->speaker_pins[0] && <nl> +	    cfg->line_out_type == AUTO_PIN_SPEAKER_OUT) { <nl>  		memcpy(cfg->speaker_pins, cfg->line_out_pins, <nl>  		       sizeof(cfg->speaker_pins)); <nl>  		cfg->speaker_outs = cfg->line_outs; <nl>  	} <nl>   <nl> -	if (!cfg->hp_pins[0]) { <nl> +	if (!cfg->hp_pins[0] && <nl> +	    cfg->line_out_type == AUTO_PIN_HP_OUT) { <nl>  		memcpy(cfg->hp_pins, cfg->line_out_pins, <nl>  		       sizeof(cfg->hp_pins)); <nl>  		cfg->hp_outs = cfg->line_outs; <nl> @@ -920,6 +922,7 @@ static void alc_init_auto_hp(struct hda_codec *codec) <nl>  		spec->automute_mode = ALC_AUTOMUTE_PIN; <nl>  	} <nl>  	if (spec->automute && cfg->line_out_pins[0] && <nl> +	    cfg->speaker_pins[0] && <nl>  	    cfg->line_out_pins[0] != cfg->hp_pins[0] && <nl>  	    cfg->line_out_pins[0] != cfg->speaker_pins[0]) { <nl>  		for (i = 0; i < cfg->line_outs; i++) {
@@ -328,6 +328,7 @@ static int em_gio_probe(struct platform_device *pdev) <nl>  	gpio_chip->request = em_gio_request; <nl>  	gpio_chip->free = em_gio_free; <nl>  	gpio_chip->label = name; <nl> +	gpio_chip->dev = &pdev->dev; <nl>  	gpio_chip->owner = THIS_MODULE; <nl>  	gpio_chip->base = pdata->gpio_base; <nl>  	gpio_chip->ngpio = pdata->number_of_pins;
@@ -828,7 +828,6 @@ static void hot_add_req(struct work_struct *dummy) <nl>  	memset(&resp, 0, sizeof(struct dm_hot_add_response)); <nl>  	resp.hdr.type = DM_MEM_HOT_ADD_RESPONSE; <nl>  	resp.hdr.size = sizeof(struct dm_hot_add_response); <nl> -	resp.hdr.trans_id = atomic_inc_return(&trans_id); <nl>   <nl>  #ifdef CONFIG_MEMORY_HOTPLUG <nl>  	pg_start = dm->ha_wrk.ha_page_range.finfo.start_page; <nl> @@ -890,6 +889,7 @@ static void hot_add_req(struct work_struct *dummy) <nl>  		pr_info("Memory hot add failed\n"); <nl>   <nl>  	dm->state = DM_INITIALIZED; <nl> +	resp.hdr.trans_id = atomic_inc_return(&trans_id); <nl>  	vmbus_sendpacket(dm->dev->channel, &resp, <nl>  			sizeof(struct dm_hot_add_response), <nl>  			(unsigned long)NULL, <nl> @@ -1076,7 +1076,6 @@ static void balloon_up(struct work_struct *dummy) <nl>  		bl_resp = (struct dm_balloon_response *)send_buffer; <nl>  		memset(send_buffer, 0, PAGE_SIZE); <nl>  		bl_resp->hdr.type = DM_BALLOON_RESPONSE; <nl> -		bl_resp->hdr.trans_id = atomic_inc_return(&trans_id); <nl>  		bl_resp->hdr.size = sizeof(struct dm_balloon_response); <nl>  		bl_resp->more_pages = 1; <nl>   <nl> @@ -1104,6 +1103,7 @@ static void balloon_up(struct work_struct *dummy) <nl>  		 */ <nl>   <nl>  		do { <nl> +			bl_resp->hdr.trans_id = atomic_inc_return(&trans_id); <nl>  			ret = vmbus_sendpacket(dm_device.dev->channel, <nl>  						bl_resp, <nl>  						bl_resp->hdr.size,
@@ -78,10 +78,9 @@ static int _rtl92e_wx_set_rate(struct net_device *dev, <nl>  	return ret; <nl>  } <nl>   <nl> - <nl> -static int r8192_wx_set_rts(struct net_device *dev, <nl> -			     struct iw_request_info *info, <nl> -			     union iwreq_data *wrqu, char *extra) <nl> +static int _rtl92e_wx_set_rts(struct net_device *dev, <nl> +			      struct iw_request_info *info, <nl> +			      union iwreq_data *wrqu, char *extra) <nl>  { <nl>  	int ret; <nl>  	struct r8192_priv *priv = rtllib_priv(dev); <nl> @@ -1137,7 +1136,7 @@ static iw_handler r8192_wx_handlers[] = { <nl>  	[IW_IOCTL(SIOCGIWNICKN)] = _rtl92e_wx_get_nick, <nl>  	[IW_IOCTL(SIOCSIWRATE)] = _rtl92e_wx_set_rate, <nl>  	[IW_IOCTL(SIOCGIWRATE)] = _rtl92e_wx_get_rate, <nl> -	[IW_IOCTL(SIOCSIWRTS)] = r8192_wx_set_rts, <nl> +	[IW_IOCTL(SIOCSIWRTS)] = _rtl92e_wx_set_rts, <nl>  	[IW_IOCTL(SIOCGIWRTS)] = _rtl92e_wx_get_rts, <nl>  	[IW_IOCTL(SIOCSIWFRAG)] = _rtl92e_wx_set_frag, <nl>  	[IW_IOCTL(SIOCGIWFRAG)] = _rtl92e_wx_get_frag,
@@ -307,6 +307,7 @@ static int sysfs_dentry_revalidate(struct dentry *dentry, struct nameidata *nd) <nl>  { <nl>  	struct sysfs_dirent *sd; <nl>  	int is_dir; <nl> +	int type; <nl>   <nl>  	if (nd->flags & LOOKUP_RCU) <nl>  		return -ECHILD; <nl> @@ -326,6 +327,13 @@ static int sysfs_dentry_revalidate(struct dentry *dentry, struct nameidata *nd) <nl>  	if (strcmp(dentry->d_name.name, sd->s_name) != 0) <nl>  		goto out_bad; <nl>   <nl> +	/* The sysfs dirent has been moved to a different namespace */ <nl> +	type = KOBJ_NS_TYPE_NONE; <nl> +	if (sd->s_parent) <nl> +		type = sysfs_ns_type(sd->s_parent); <nl> +	if (type && (sysfs_info(dentry->d_sb)->ns[type] != sd->s_ns)) <nl> +		goto out_bad; <nl> + <nl>  	mutex_unlock(&sysfs_mutex); <nl>  out_valid: <nl>  	return 1;
@@ -654,15 +654,15 @@ static void eth_port_start(struct net_device *dev) <nl>  	/* Assignment of Tx CTRP of given queue */ <nl>  	tx_curr_desc = pep->tx_curr_desc_q; <nl>  	wrl(pep, ETH_C_TX_DESC_1, <nl> -	    (u32) ((struct tx_desc *)pep->tx_desc_dma + tx_curr_desc)); <nl> +	    (u32) (pep->tx_desc_dma + tx_curr_desc * sizeof(struct tx_desc))); <nl>   <nl>  	/* Assignment of Rx CRDP of given queue */ <nl>  	rx_curr_desc = pep->rx_curr_desc_q; <nl>  	wrl(pep, ETH_C_RX_DESC_0, <nl> -	    (u32) ((struct rx_desc *)pep->rx_desc_dma + rx_curr_desc)); <nl> +	    (u32) (pep->rx_desc_dma + rx_curr_desc * sizeof(struct rx_desc))); <nl>   <nl>  	wrl(pep, ETH_F_RX_DESC_0, <nl> -	    (u32) ((struct rx_desc *)pep->rx_desc_dma + rx_curr_desc)); <nl> +	    (u32) (pep->rx_desc_dma + rx_curr_desc * sizeof(struct rx_desc))); <nl>   <nl>  	/* Clear all interrupts */ <nl>  	wrl(pep, INT_CAUSE, 0);
@@ -94,11 +94,15 @@ pl_set_QuickLink_features(struct usbnet *dev, int val) <nl>   <nl>  static int pl_reset(struct usbnet *dev) <nl>  { <nl> +	int status; <nl> + <nl>  	/* some units seem to need this reset, others reject it utterly. <nl>  	 * FIXME be more like "naplink" or windows drivers. <nl>  	 */ <nl> -	(void) pl_set_QuickLink_features(dev, <nl> +	status = pl_set_QuickLink_features(dev, <nl>  		PL_S_EN|PL_RESET_OUT|PL_RESET_IN|PL_PEER_E); <nl> +	if (status != 0 && netif_msg_probe(dev)) <nl> +		netif_dbg(dev, link, dev->net, "pl_reset --> %d\n", status); <nl>  	return 0; <nl>  } <nl>  
@@ -3057,9 +3057,13 @@ int regulator_bulk_enable(int num_consumers, <nl>  	return 0; <nl>   <nl>  err: <nl> -	pr_err("Failed to enable %s: %d\n", consumers[i].supply, ret); <nl> -	while (--i >= 0) <nl> -		regulator_disable(consumers[i].consumer); <nl> +	for (i = 0; i < num_consumers; i++) { <nl> +		if (consumers[i].ret < 0) <nl> +			pr_err("Failed to enable %s: %d\n", consumers[i].supply, <nl> +			       consumers[i].ret); <nl> +		else <nl> +			regulator_disable(consumers[i].consumer); <nl> +	} <nl>   <nl>  	return ret; <nl>  }
@@ -1422,6 +1422,7 @@ static int __load_segment_descriptor(struct x86_emulate_ctxt *ctxt, <nl>  	ulong desc_addr; <nl>  	int ret; <nl>  	u16 dummy; <nl> +	u32 base3 = 0; <nl>   <nl>  	memset(&seg_desc, 0, sizeof seg_desc); <nl>   <nl> @@ -1538,9 +1539,14 @@ static int __load_segment_descriptor(struct x86_emulate_ctxt *ctxt, <nl>  		ret = write_segment_descriptor(ctxt, selector, &seg_desc); <nl>  		if (ret != X86EMUL_CONTINUE) <nl>  			return ret; <nl> +	} else if (ctxt->mode == X86EMUL_MODE_PROT64) { <nl> +		ret = ctxt->ops->read_std(ctxt, desc_addr+8, &base3, <nl> +				sizeof(base3), &ctxt->exception); <nl> +		if (ret != X86EMUL_CONTINUE) <nl> +			return ret; <nl>  	} <nl>  load: <nl> -	ctxt->ops->set_segment(ctxt, selector, &seg_desc, 0, seg); <nl> +	ctxt->ops->set_segment(ctxt, selector, &seg_desc, base3, seg); <nl>  	return X86EMUL_CONTINUE; <nl>  exception: <nl>  	emulate_exception(ctxt, err_vec, err_code, true);
@@ -1488,7 +1488,11 @@ struct nvme_iod *nvme_map_user_pages(struct nvme_dev *dev, int write, <nl>  		goto put_pages; <nl>  	} <nl>   <nl> +	err = -ENOMEM; <nl>  	iod = nvme_alloc_iod(count, length, GFP_KERNEL); <nl> +	if (!iod) <nl> +		goto put_pages; <nl> + <nl>  	sg = iod->sg; <nl>  	sg_init_table(sg, count); <nl>  	for (i = 0; i < count; i++) { <nl> @@ -1501,7 +1505,6 @@ struct nvme_iod *nvme_map_user_pages(struct nvme_dev *dev, int write, <nl>  	sg_mark_end(&sg[i - 1]); <nl>  	iod->nents = count; <nl>   <nl> -	err = -ENOMEM; <nl>  	nents = dma_map_sg(&dev->pci_dev->dev, sg, count, <nl>  				write ? DMA_TO_DEVICE : DMA_FROM_DEVICE); <nl>  	if (!nents)
@@ -1160,7 +1160,8 @@ static int sdhci_esdhc_imx_probe(struct platform_device *pdev) <nl>  	 * to something insane.  Change it back here. <nl>  	 */ <nl>  	if (esdhc_is_usdhc(imx_data)) { <nl> -		writel(0x08100810, host->ioaddr + ESDHC_WTMK_LVL); <nl> +		writel(0x10401040, host->ioaddr + ESDHC_WTMK_LVL); <nl> + <nl>  		host->quirks2 |= SDHCI_QUIRK2_PRESET_VALUE_BROKEN; <nl>  		host->mmc->caps |= MMC_CAP_1_8V_DDR; <nl>  
@@ -2101,8 +2101,6 @@ ext4_ext_in_cache(struct inode *inode, ext4_lblk_t block, <nl>  /* <nl>   * ext4_ext_rm_idx: <nl>   * removes index from the index block. <nl> - * It's used in truncate case only, thus all requests are for <nl> - * last index in the block only. <nl>   */ <nl>  static int ext4_ext_rm_idx(handle_t *handle, struct inode *inode, <nl>  			struct ext4_ext_path *path) <nl> @@ -2120,6 +2118,13 @@ static int ext4_ext_rm_idx(handle_t *handle, struct inode *inode, <nl>  	err = ext4_ext_get_access(handle, inode, path); <nl>  	if (err) <nl>  		return err; <nl> + <nl> +	if (path->p_idx != EXT_LAST_INDEX(path->p_hdr)) { <nl> +		int len = EXT_LAST_INDEX(path->p_hdr) - path->p_idx; <nl> +		len *= sizeof(struct ext4_extent_idx); <nl> +		memmove(path->p_idx, path->p_idx + 1, len); <nl> +	} <nl> + <nl>  	le16_add_cpu(&path->p_hdr->eh_entries, -1); <nl>  	err = ext4_ext_dirty(handle, inode, path); <nl>  	if (err)
@@ -2212,6 +2212,7 @@ static int mv643xx_eth_stop(struct net_device *dev) <nl>  	struct mv643xx_eth_private *mp = netdev_priv(dev); <nl>  	int i; <nl>   <nl> +	wrlp(mp, INT_MASK_EXT, 0x00000000); <nl>  	wrlp(mp, INT_MASK, 0x00000000); <nl>  	rdlp(mp, INT_MASK); <nl>  
@@ -949,6 +949,7 @@ int usbatm_usb_probe(struct usb_interface *intf, const struct usb_device_id *id, <nl>  	struct usb_device *usb_dev = interface_to_usbdev(intf); <nl>  	struct usbatm_data *instance; <nl>  	char *buf; <nl> +	size_t instance_size = sizeof(*instance) + sizeof(struct urb *) * (num_rcv_urbs + num_snd_urbs); <nl>  	int error = -ENOMEM; <nl>  	int i, length; <nl>  	int need_heavy; <nl> @@ -960,14 +961,13 @@ int usbatm_usb_probe(struct usb_interface *intf, const struct usb_device_id *id, <nl>  			intf->altsetting->desc.bInterfaceNumber); <nl>   <nl>  	/* instance init */ <nl> -	instance = kmalloc(sizeof(*instance) + sizeof(struct urb *) * (num_rcv_urbs + num_snd_urbs), <nl> -			   GFP_KERNEL); <nl> +	instance = kmalloc(instance_size, GFP_KERNEL); <nl>  	if (!instance) { <nl>  		dev_dbg(dev, "%s: no memory for instance data!\n", __func__); <nl>  		return -ENOMEM; <nl>  	} <nl>   <nl> -	memset(instance, 0, sizeof(*instance)); <nl> +	memset(instance, 0, instance_size); <nl>   <nl>  	/* public fields */ <nl>   <nl> @@ -1051,6 +1051,8 @@ int usbatm_usb_probe(struct usb_interface *intf, const struct usb_device_id *id, <nl>  			goto fail_unbind; <nl>  		} <nl>   <nl> +		instance->urbs[i] = urb; <nl> + <nl>  		buffer = kmalloc(channel->buf_size, GFP_KERNEL); <nl>  		if (!buffer) { <nl>  			dev_dbg(dev, "%s: no memory for buffer %d!\n", __func__, i); <nl> @@ -1078,7 +1080,6 @@ int usbatm_usb_probe(struct usb_interface *intf, const struct usb_device_id *id, <nl>   <nl>  		vdbg("%s: alloced buffer 0x%p buf size %u urb 0x%p", <nl>  		     __func__, urb->transfer_buffer, urb->transfer_buffer_length, urb); <nl> -		instance->urbs[i] = urb; <nl>  	} <nl>   <nl>  	if (need_heavy && driver->heavy_init) {
@@ -1852,7 +1852,6 @@ static void collapse_huge_page(struct mm_struct *mm, <nl>  		set_pmd_at(mm, address, pmd, _pmd); <nl>  		spin_unlock(&mm->page_table_lock); <nl>  		anon_vma_unlock(vma->anon_vma); <nl> -		mem_cgroup_uncharge_page(new_page); <nl>  		goto out; <nl>  	} <nl>   <nl> @@ -1898,6 +1897,7 @@ out_up_write: <nl>  	return; <nl>   <nl>  out: <nl> +	mem_cgroup_uncharge_page(new_page); <nl>  #ifdef CONFIG_NUMA <nl>  	put_page(new_page); <nl>  #endif
@@ -56,6 +56,10 @@ static char config[MAX_PARAM_LENGTH]; <nl>  module_param_string(netconsole, config, MAX_PARAM_LENGTH, 0); <nl>  MODULE_PARM_DESC(netconsole, " netconsole=[src-port]@[src-ip]/[dev],[tgt-port]@<tgt-ip>/[tgt-macaddr]"); <nl>   <nl> +static bool oops_only = false; <nl> +module_param(oops_only, bool, 0600); <nl> +MODULE_PARM_DESC(oops_only, "Only log oops messages"); <nl> + <nl>  #ifndef	MODULE <nl>  static int __init option_setup(char *opt) <nl>  { <nl> @@ -683,6 +687,8 @@ static void write_msg(struct console *con, const char *msg, unsigned int len) <nl>  	struct netconsole_target *nt; <nl>  	const char *tmp; <nl>   <nl> +	if (oops_only && !oops_in_progress) <nl> +		return; <nl>  	/* Avoid taking lock and disabling interrupts unnecessarily */ <nl>  	if (list_empty(&target_list)) <nl>  		return;
@@ -2059,6 +2059,7 @@ int tcp_disconnect(struct sock *sk, int flags) <nl>  	tp->snd_ssthresh = TCP_INFINITE_SSTHRESH; <nl>  	tp->snd_cwnd_cnt = 0; <nl>  	tp->bytes_acked = 0; <nl> +	tp->window_clamp = 0; <nl>  	tcp_set_ca_state(sk, TCP_CA_Open); <nl>  	tcp_clear_retrans(tp); <nl>  	inet_csk_delack_init(sk);
@@ -196,6 +196,10 @@ __alloc_bootmem_core(struct bootmem_data *bdata, unsigned long size, <nl>  	if (limit && bdata->node_boot_start >= limit) <nl>  		return NULL; <nl>   <nl> +	/* on nodes without memory - bootmem_map is NULL */ <nl> +	if (!bdata->node_bootmem_map) <nl> +		return NULL; <nl> + <nl>  	end_pfn = bdata->node_low_pfn; <nl>  	limit = PFN_DOWN(limit); <nl>  	if (limit && end_pfn > limit)
@@ -26,6 +26,7 @@ <nl>   * if_sdio_card_to_host() to pad the data. <nl>   */ <nl>   <nl> +#include <linux/kernel.h> <nl>  #include <linux/moduleparam.h> <nl>  #include <linux/firmware.h> <nl>  #include <linux/netdevice.h> <nl> @@ -581,7 +582,7 @@ static int if_sdio_prog_real(struct if_sdio_card *card) <nl>  				chunk_size, (chunk_size + 31) / 32 * 32); <nl>  */ <nl>  			ret = sdio_writesb(card->func, card->ioport, <nl> -				chunk_buffer, (chunk_size + 31) / 32 * 32); <nl> +				chunk_buffer, roundup(chunk_size, 32)); <nl>  			if (ret) <nl>  				goto release; <nl>  
@@ -2769,6 +2769,7 @@ static int nl80211_get_mesh_params(struct sk_buff *skb, <nl>   <nl>   nla_put_failure: <nl>  	genlmsg_cancel(msg, hdr); <nl> +	nlmsg_free(msg); <nl>  	err = -EMSGSIZE; <nl>   out: <nl>  	/* Cleanup */ <nl> @@ -2960,6 +2961,7 @@ static int nl80211_get_reg(struct sk_buff *skb, struct genl_info *info) <nl>   <nl>  nla_put_failure: <nl>  	genlmsg_cancel(msg, hdr); <nl> +	nlmsg_free(msg); <nl>  	err = -EMSGSIZE; <nl>  out: <nl>  	mutex_unlock(&cfg80211_mutex);
@@ -108,10 +108,12 @@ static int iio_read_first_n_kfifo(struct iio_buffer *r, <nl>  	int ret, copied; <nl>  	struct iio_kfifo *kf = iio_to_kfifo(r); <nl>   <nl> -	if (n < r->bytes_per_datum) <nl> +	if (n < r->bytes_per_datum || r->bytes_per_datum == 0) <nl>  		return -EINVAL; <nl>   <nl>  	ret = kfifo_to_user(&kf->kf, buf, n, &copied); <nl> +	if (ret < 0) <nl> +		return ret; <nl>   <nl>  	return copied; <nl>  }
@@ -4420,9 +4420,16 @@ EXPORT_SYMBOL_GPL(snd_soc_unregister_codec); <nl>  int snd_soc_of_parse_card_name(struct snd_soc_card *card, <nl>  			       const char *propname) <nl>  { <nl> -	struct device_node *np = card->dev->of_node; <nl> +	struct device_node *np; <nl>  	int ret; <nl>   <nl> +	if (!card->dev) { <nl> +		pr_err("card->dev is not set before calling %s\n", __func__); <nl> +		return -EINVAL; <nl> +	} <nl> + <nl> +	np = card->dev->of_node; <nl> + <nl>  	ret = of_property_read_string_index(np, propname, 0, &card->name); <nl>  	/* <nl>  	 * EINVAL means the property does not exist. This is fine providing
@@ -2257,6 +2257,8 @@ int bond_arp_rcv(const struct sk_buff *skb, struct bonding *bond, <nl>  	__be32 sip, tip; <nl>  	int alen; <nl>   <nl> +	slave->last_arp_rx = jiffies; <nl> + <nl>  	if (skb->protocol != __cpu_to_be16(ETH_P_ARP)) <nl>  		return RX_HANDLER_ANOTHER; <nl>  
@@ -58,6 +58,8 @@ static ssize_t kpagecount_read(struct file *file, char __user *buf, <nl>  		pfn++; <nl>  		out++; <nl>  		count -= KPMSIZE; <nl> + <nl> +		cond_resched(); <nl>  	} <nl>   <nl>  	*ppos += (char __user *)out - buf; <nl> @@ -219,6 +221,8 @@ static ssize_t kpageflags_read(struct file *file, char __user *buf, <nl>  		pfn++; <nl>  		out++; <nl>  		count -= KPMSIZE; <nl> + <nl> +		cond_resched(); <nl>  	} <nl>   <nl>  	*ppos += (char __user *)out - buf; <nl> @@ -267,6 +271,8 @@ static ssize_t kpagecgroup_read(struct file *file, char __user *buf, <nl>  		pfn++; <nl>  		out++; <nl>  		count -= KPMSIZE; <nl> + <nl> +		cond_resched(); <nl>  	} <nl>   <nl>  	*ppos += (char __user *)out - buf;
@@ -734,6 +734,7 @@ static const struct super_operations hugetlbfs_ops = { <nl>  	.delete_inode	= hugetlbfs_delete_inode, <nl>  	.drop_inode	= hugetlbfs_drop_inode, <nl>  	.put_super	= hugetlbfs_put_super, <nl> +	.show_options	= generic_show_options, <nl>  }; <nl>   <nl>  static int <nl> @@ -817,6 +818,8 @@ hugetlbfs_fill_super(struct super_block *sb, void *data, int silent) <nl>  	struct hugetlbfs_config config; <nl>  	struct hugetlbfs_sb_info *sbinfo; <nl>   <nl> +	save_mount_options(sb, data); <nl> + <nl>  	config.nr_blocks = -1; /* No limit on size by default */ <nl>  	config.nr_inodes = -1; /* No limit on number of inodes by default */ <nl>  	config.uid = current->fsuid;
@@ -63,7 +63,7 @@ static int sd_set_##thename(struct gspca_dev *gspca_dev, s32 val)\ <nl>  \ <nl>  	sd->vcur.thename = val;\ <nl>  	if (gspca_dev->streaming)\ <nl> -		sd->dev_camera_settings(gspca_dev);\ <nl> +		sd->waitSet = 1;\ <nl>  	return 0;\ <nl>  } \ <nl>  static int sd_get_##thename(struct gspca_dev *gspca_dev, s32 *val)\
@@ -910,12 +910,18 @@ static int xc2028_set_tv_freq(struct dvb_frontend *fe, <nl>  			      struct analog_parameters *p) <nl>  { <nl>  	struct xc2028_data *priv = fe->tuner_priv; <nl> +	fe_bandwidth_t bw; <nl> + <nl> +	/* FIXME: Maybe there are more 6 MHz video standards */ <nl> +	if (p->std & V4L2_STD_MN) <nl> +		bw = BANDWIDTH_6_MHZ; <nl> +	else <nl> +		bw = BANDWIDTH_8_MHZ; <nl>   <nl>  	tuner_dbg("%s called\n", __FUNCTION__); <nl>   <nl>  	return generic_set_tv_freq(fe, 62500l * p->frequency, T_ANALOG_TV, <nl> -				   p->std, BANDWIDTH_8_MHZ); <nl> -				   /* XXX Are some analog standards 6MHz? */ <nl> +				   p->std, bw); <nl>  } <nl>   <nl>  static int xc2028_set_params(struct dvb_frontend *fe,
@@ -193,15 +193,16 @@ static void recalculate_apic_map(struct kvm *kvm) <nl>  	kvm_for_each_vcpu(i, vcpu, kvm) { <nl>  		struct kvm_lapic *apic = vcpu->arch.apic; <nl>  		u16 cid, lid; <nl> -		u32 ldr; <nl> - <nl> -		new->phys_map[kvm_apic_id(apic)] = apic; <nl> +		u32 ldr, aid; <nl>   <nl> +		aid = kvm_apic_id(apic); <nl>  		ldr = kvm_apic_get_reg(apic, APIC_LDR); <nl>  		cid = apic_cluster_id(new, ldr); <nl>  		lid = apic_logical_id(new, ldr); <nl>   <nl> -		if (lid) <nl> +		if (aid < ARRAY_SIZE(new->phys_map)) <nl> +			new->phys_map[aid] = apic; <nl> +		if (lid && cid < ARRAY_SIZE(new->logical_map)) <nl>  			new->logical_map[cid][ffs(lid) - 1] = apic; <nl>  	} <nl>  out:
@@ -684,8 +684,10 @@ int nfc_llcp_send_i_frame(struct nfc_llcp_sock *sock, <nl>   <nl>  		pdu = llcp_allocate_pdu(sock, LLCP_PDU_I, <nl>  					frag_len + LLCP_SEQUENCE_SIZE); <nl> -		if (pdu == NULL) <nl> +		if (pdu == NULL) { <nl> +			kfree(msg_data); <nl>  			return -ENOMEM; <nl> +		} <nl>   <nl>  		skb_put(pdu, LLCP_SEQUENCE_SIZE); <nl>  
@@ -291,7 +291,7 @@ static const struct of_device_id ppc_clk_ids[] __initconst = { <nl>  	{} <nl>  }; <nl>   <nl> -static struct platform_driver ppc_corenet_clk_driver __initdata = { <nl> +static struct platform_driver ppc_corenet_clk_driver = { <nl>  	.driver = { <nl>  		.name = "ppc_corenet_clock", <nl>  		.of_match_table = ppc_clk_ids,
@@ -69,7 +69,7 @@ static int check_in_drive_lists (ide_drive_t *drive, const char **list) <nl>  static u8 svwks_ratemask (ide_drive_t *drive) <nl>  { <nl>  	struct pci_dev *dev     = HWIF(drive)->pci_dev; <nl> -	u8 mode; <nl> +	u8 mode = 0; <nl>   <nl>  	if (!svwks_revision) <nl>  		pci_read_config_byte(dev, PCI_REVISION_ID, &svwks_revision);
@@ -188,6 +188,13 @@ static int i2o_cfg_parms(unsigned long arg, unsigned int type) <nl>  	if (!dev) <nl>  		return -ENXIO; <nl>   <nl> +	/* <nl> +	 * Stop users being able to try and allocate arbitary amounts <nl> +	 * of DMA space. 64K is way more than sufficient for this. <nl> +	 */ <nl> +	if (kcmd.oplen > 65536) <nl> +		return -EMSGSIZE; <nl> + <nl>  	ops = memdup_user(kcmd.opbuf, kcmd.oplen); <nl>  	if (IS_ERR(ops)) <nl>  		return PTR_ERR(ops);
@@ -922,7 +922,8 @@ static int cfg80211_netdev_notifier_call(struct notifier_block * nb, <nl>  		 * Configure power management to the driver here so that its <nl>  		 * correctly set also after interface type changes etc. <nl>  		 */ <nl> -		if (wdev->iftype == NL80211_IFTYPE_STATION && <nl> +		if ((wdev->iftype == NL80211_IFTYPE_STATION || <nl> +		     wdev->iftype == NL80211_IFTYPE_P2P_CLIENT) && <nl>  		    rdev->ops->set_power_mgmt) <nl>  			if (rdev->ops->set_power_mgmt(wdev->wiphy, dev, <nl>  						      wdev->ps,
@@ -1306,8 +1306,8 @@ int genwqe_device_create(struct genwqe_dev *cd) <nl>  					    genwqe_attribute_groups, <nl>  					    GENWQE_DEVNAME "%u_card", <nl>  					    cd->card_idx); <nl> -	if (cd->dev == NULL) { <nl> -		rc = -ENODEV; <nl> +	if (IS_ERR(cd->dev)) { <nl> +		rc = PTR_ERR(cd->dev); <nl>  		goto err_cdev; <nl>  	} <nl>  
@@ -1201,7 +1201,6 @@ no_dma: <nl>  			break; <nl>  		} <nl>  		s->maxdata = board->ai_maxdata; <nl> -		s->len_chanlist = MAX_CHANLIST_LEN; <nl>  		s->range_table = board->rangelist_ai; <nl>  		if (board->board_type == boardACL8216) <nl>  			s->insn_read = acl8216_ai_insn_read; <nl> @@ -1209,13 +1208,14 @@ no_dma: <nl>  			s->insn_read = pcl812_ai_insn_read; <nl>   <nl>  		devpriv->use_MPC = board->haveMPC508; <nl> -		s->cancel = pcl812_ai_cancel; <nl>  		if (dev->irq) { <nl>  			dev->read_subdev = s; <nl>  			s->subdev_flags |= SDF_CMD_READ; <nl> +			s->len_chanlist = MAX_CHANLIST_LEN; <nl>  			s->do_cmdtest = pcl812_ai_cmdtest; <nl>  			s->do_cmd = pcl812_ai_cmd; <nl>  			s->poll = pcl812_ai_poll; <nl> +			s->cancel = pcl812_ai_cancel; <nl>  		} <nl>  		switch (board->board_type) { <nl>  		case boardPCL812PG:
@@ -6618,6 +6618,9 @@ static int md_open(struct block_device *bdev, fmode_t mode) <nl>  	struct mddev *mddev = mddev_find(bdev->bd_dev); <nl>  	int err; <nl>   <nl> +	if (!mddev) <nl> +		return -ENODEV; <nl> + <nl>  	if (mddev->gendisk != bdev->bd_disk) { <nl>  		/* we are racing with mddev_put which is discarding this <nl>  		 * bd_disk.
@@ -73,7 +73,7 @@ static int imx6q_revision(void) <nl>  	} <nl>  } <nl>   <nl> -void imx6q_restart(char mode, const char *cmd) <nl> +static void imx6q_restart(char mode, const char *cmd) <nl>  { <nl>  	struct device_node *np; <nl>  	void __iomem *wdog_base; <nl> @@ -256,7 +256,7 @@ put_node: <nl>  	of_node_put(np); <nl>  } <nl>   <nl> -struct platform_device imx6q_cpufreq_pdev = { <nl> +static struct platform_device imx6q_cpufreq_pdev = { <nl>  	.name = "imx6q-cpufreq", <nl>  }; <nl>  
@@ -133,6 +133,7 @@ unsigned int nf_iterate(struct list_head *head, <nl>   <nl>  		/* Optimization: we don't need to hold module <nl>  		   reference here, since function can't sleep. --RR */ <nl> +repeat: <nl>  		verdict = elem->hook(hook, skb, indev, outdev, okfn); <nl>  		if (verdict != NF_ACCEPT) { <nl>  #ifdef CONFIG_NETFILTER_DEBUG <nl> @@ -145,7 +146,7 @@ unsigned int nf_iterate(struct list_head *head, <nl>  #endif <nl>  			if (verdict != NF_REPEAT) <nl>  				return verdict; <nl> -			*i = (*i)->prev; <nl> +			goto repeat; <nl>  		} <nl>  	} <nl>  	return NF_ACCEPT;
@@ -3337,7 +3337,7 @@ void btrfsic_unmount(struct btrfs_root *root, <nl>  				btrfsic_block_link_free(l); <nl>  		} <nl>   <nl> -		if (b_all->is_iodone) <nl> +		if (b_all->is_iodone || b_all->never_written) <nl>  			btrfsic_block_free(b_all); <nl>  		else <nl>  			printk(KERN_INFO "btrfs: attempt to free %c-block"
@@ -197,6 +197,8 @@ void dump_trace(struct task_struct *task, struct pt_regs *regs, <nl>  				if (UNW_SP(&info) >= PAGE_OFFSET) { <nl>  					ops->warning(data, "Leftover inexact backtrace:\n"); <nl>  					stack = (void *)UNW_SP(&info); <nl> +					if (!stack) <nl> +						return; <nl>  				} else <nl>  					ops->warning(data, "Full inexact backtrace again:\n"); <nl>  			} else if (call_trace >= 1)
@@ -291,8 +291,18 @@ static int arch_build_bp_info(struct perf_event *bp) <nl>  		break; <nl>  #endif <nl>  	default: <nl> +		/* AMD range breakpoint */ <nl>  		if (!is_power_of_2(bp->attr.bp_len)) <nl>  			return -EINVAL; <nl> +		if (bp->attr.bp_addr & (bp->attr.bp_len - 1)) <nl> +			return -EINVAL; <nl> +		/* <nl> +		 * It's impossible to use a range breakpoint to fake out <nl> +		 * user vs kernel detection because bp_len - 1 can't <nl> +		 * have the high bit set.  If we ever allow range instruction <nl> +		 * breakpoints, then we'll have to check for kprobe-blacklisted <nl> +		 * addresses anywhere in the range. <nl> +		 */ <nl>  		if (!cpu_has_bpext) <nl>  			return -EOPNOTSUPP; <nl>  		info->mask = bp->attr.bp_len - 1;
@@ -616,6 +616,9 @@ static u8 sdhci_calc_timeout(struct sdhci_host *host, struct mmc_command *cmd) <nl>  		target_timeout = data->timeout_ns / 1000 + <nl>  			data->timeout_clks / host->clock; <nl>   <nl> +	if (host->quirks & SDHCI_QUIRK_DATA_TIMEOUT_USES_SDCLK) <nl> +		host->timeout_clk = host->clock / 1000; <nl> + <nl>  	/* <nl>  	 * Figure out needed cycles. <nl>  	 * We do this in steps in order to fit inside a 32 bit int. <nl> @@ -626,6 +629,7 @@ static u8 sdhci_calc_timeout(struct sdhci_host *host, struct mmc_command *cmd) <nl>  	 *     => <nl>  	 *     (1) / (2) > 2^6 <nl>  	 */ <nl> +	BUG_ON(!host->timeout_clk); <nl>  	count = 0; <nl>  	current_timeout = (1 << 13) * 1000 / host->timeout_clk; <nl>  	while (current_timeout < target_timeout) { <nl> @@ -1901,9 +1905,6 @@ int sdhci_add_host(struct sdhci_host *host) <nl>  	if (caps & SDHCI_TIMEOUT_CLK_UNIT) <nl>  		host->timeout_clk *= 1000; <nl>   <nl> -	if (host->quirks & SDHCI_QUIRK_DATA_TIMEOUT_USES_SDCLK) <nl> -		host->timeout_clk = host->clock / 1000; <nl> - <nl>  	/* <nl>  	 * Set host parameters. <nl>  	 */
@@ -1381,7 +1381,7 @@ asmlinkage long sys_accept(int fd, struct sockaddr __user *upeer_sockaddr, <nl>   <nl>  	err = sock_attach_fd(newsock, newfile); <nl>  	if (err < 0) <nl> -		goto out_fd; <nl> +		goto out_fd_simple; <nl>   <nl>  	err = security_socket_accept(sock, newsock); <nl>  	if (err) <nl> @@ -1414,6 +1414,11 @@ out_put: <nl>  	fput_light(sock->file, fput_needed); <nl>  out: <nl>  	return err; <nl> +out_fd_simple: <nl> +	sock_release(newsock); <nl> +	put_filp(newfile); <nl> +	put_unused_fd(newfd); <nl> +	goto out_put; <nl>  out_fd: <nl>  	fput(newfile); <nl>  	put_unused_fd(newfd);
@@ -75,7 +75,12 @@ intel_dp_max_link_bw(struct intel_dp *intel_dp) <nl>  	case DP_LINK_BW_1_62: <nl>  	case DP_LINK_BW_2_7: <nl>  		break; <nl> +	case DP_LINK_BW_5_4: /* 1.2 capable displays may advertise higher bw */ <nl> +		max_link_bw = DP_LINK_BW_2_7; <nl> +		break; <nl>  	default: <nl> +		WARN(1, "invalid max DP link bw val %x, using 1.62Gbps\n", <nl> +		     max_link_bw); <nl>  		max_link_bw = DP_LINK_BW_1_62; <nl>  		break; <nl>  	}
@@ -494,6 +494,8 @@ static int bug_handler(struct pt_regs *regs, unsigned int esr) <nl>  		break; <nl>   <nl>  	case BUG_TRAP_TYPE_WARN: <nl> +		/* Ideally, report_bug() should backtrace for us... but no. */ <nl> +		dump_backtrace(regs, NULL); <nl>  		break; <nl>   <nl>  	default:
@@ -100,6 +100,8 @@ void (*mach_beep)(unsigned int, unsigned int); <nl>  #if defined(CONFIG_ISA) && defined(MULTI_ISA) <nl>  int isa_type; <nl>  int isa_sex; <nl> +EXPORT_SYMBOL(isa_type); <nl> +EXPORT_SYMBOL(isa_sex); <nl>  #endif <nl>   <nl>  extern int amiga_parse_bootinfo(const struct bi_record *);
@@ -125,7 +125,7 @@ static u8 opcode_table[256] = { <nl>  	/* 0x88 - 0x8F */ <nl>  	ByteOp | DstMem | SrcReg | ModRM | Mov, DstMem | SrcReg | ModRM | Mov, <nl>  	ByteOp | DstReg | SrcMem | ModRM | Mov, DstReg | SrcMem | ModRM | Mov, <nl> -	0, 0, 0, DstMem | SrcNone | ModRM | Mov, <nl> +	0, ModRM | DstReg, 0, DstMem | SrcNone | ModRM | Mov, <nl>  	/* 0x90 - 0x9F */ <nl>  	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ImplicitOps, 0, 0, 0, <nl>  	/* 0xA0 - 0xA7 */ <nl> @@ -1022,6 +1022,9 @@ push: <nl>  		break; <nl>  	case 0x88 ... 0x8b:	/* mov */ <nl>  		goto mov; <nl> +	case 0x8d: /* lea r16/r32, m */ <nl> +		dst.val = modrm_val; <nl> +		break; <nl>  	case 0x8f:		/* pop (sole member of Grp1a) */ <nl>  		/* 64-bit mode: POP always pops a 64-bit operand. */ <nl>  		if (mode == X86EMUL_MODE_PROT64)
@@ -1912,6 +1912,15 @@ static struct request *get_request(request_queue_t *q, int rw, struct bio *bio, <nl>  	} <nl>   <nl>  get_rq: <nl> +	/* <nl> +	 * Only allow batching queuers to allocate up to 50% over the defined <nl> +	 * limit of requests, otherwise we could have thousands of requests <nl> +	 * allocated with any setting of ->nr_requests <nl> +	 */ <nl> +	if (rl->count[rw] >= (3 * q->nr_requests / 2)) { <nl> +		spin_unlock_irq(q->queue_lock); <nl> +		goto out; <nl> +	} <nl>  	rl->count[rw]++; <nl>  	rl->starved[rw] = 0; <nl>  	if (rl->count[rw] >= queue_congestion_on_threshold(q))
@@ -3341,6 +3341,7 @@ static int velocity_set_coalesce(struct net_device *dev, <nl>  { <nl>  	struct velocity_info *vptr = netdev_priv(dev); <nl>  	int max_us = 0x3f * 64; <nl> +	unsigned long flags; <nl>   <nl>  	/* 6 bits of  */ <nl>  	if (ecmd->tx_coalesce_usecs > max_us) <nl> @@ -3362,6 +3363,7 @@ static int velocity_set_coalesce(struct net_device *dev, <nl>  			ecmd->tx_coalesce_usecs); <nl>   <nl>  	/* Setup the interrupt suppression and queue timers */ <nl> +	spin_lock_irqsave(&vptr->lock, flags); <nl>  	mac_disable_int(vptr->mac_regs); <nl>  	setup_adaptive_interrupts(vptr); <nl>  	setup_queue_timers(vptr); <nl> @@ -3369,6 +3371,7 @@ static int velocity_set_coalesce(struct net_device *dev, <nl>  	mac_write_int_mask(vptr->int_mask, vptr->mac_regs); <nl>  	mac_clear_isr(vptr->mac_regs); <nl>  	mac_enable_int(vptr->mac_regs); <nl> +	spin_unlock_irqrestore(&vptr->lock, flags); <nl>   <nl>  	return 0; <nl>  }
@@ -97,8 +97,8 @@ static ssize_t dev_attr_show(struct kobject *kobj, struct attribute *attr, <nl>  	if (dev_attr->show) <nl>  		ret = dev_attr->show(dev, dev_attr, buf); <nl>  	if (ret >= (ssize_t)PAGE_SIZE) { <nl> -		printk("dev_attr_show: %pSR returned bad count\n", <nl> -		       dev_attr->show); <nl> +		print_symbol("dev_attr_show: %s returned bad count\n", <nl> +				(unsigned long)dev_attr->show); <nl>  	} <nl>  	return ret; <nl>  }
@@ -904,7 +904,7 @@ alloc_new_skb: <nl>  			 * because we have no idea what fragment will be <nl>  			 * the last. <nl>  			 */ <nl> -			if (datalen == length) <nl> +			if (datalen == length + fraggap) <nl>  				alloclen += rt->u.dst.trailer_len; <nl>   <nl>  			if (transhdrlen) {
@@ -1237,8 +1237,8 @@ nfsd4_getdeviceinfo(struct svc_rqst *rqstp, <nl>  		nfserr = ops->proc_getdeviceinfo(exp->ex_path.mnt->mnt_sb, gdp); <nl>   <nl>  	gdp->gd_notify_types &= ops->notify_types; <nl> -	exp_put(exp); <nl>  out: <nl> +	exp_put(exp); <nl>  	return nfserr; <nl>  } <nl>  
@@ -156,6 +156,9 @@ out_up: <nl>   */ <nl>  static int w1_f23_write(struct w1_slave *sl, int addr, int len, const u8 *data) <nl>  { <nl> +#ifdef CONFIG_W1_SLAVE_DS2433_CRC <nl> +	struct w1_f23_data *f23 = sl->family_data; <nl> +#endif <nl>  	u8 wrbuf[4]; <nl>  	u8 rdbuf[W1_PAGE_SIZE + 3]; <nl>  	u8 es = (addr + len - 1) & 0x1f; <nl> @@ -196,7 +199,9 @@ static int w1_f23_write(struct w1_slave *sl, int addr, int len, const u8 *data) <nl>   <nl>  	/* Reset the bus to wake up the EEPROM (this may not be needed) */ <nl>  	w1_reset_bus(sl->master); <nl> - <nl> +#ifdef CONFIG_W1_SLAVE_DS2433_CRC <nl> +	f23->validcrc &= ~(1 << (addr >> W1_PAGE_BITS)); <nl> +#endif <nl>  	return 0; <nl>  } <nl>  
@@ -142,6 +142,7 @@ static int pm860x_led_dt_init(struct platform_device *pdev, <nl>  			of_property_read_u32(np, "marvell,88pm860x-iset", <nl>  					     &iset); <nl>  			data->iset = PM8606_LED_CURRENT(iset); <nl> +			of_node_put(np); <nl>  			break; <nl>  		} <nl>  	}
@@ -1285,7 +1285,7 @@ static int virtnet_set_channels(struct net_device *dev, <nl>  	if (channels->rx_count || channels->tx_count || channels->other_count) <nl>  		return -EINVAL; <nl>   <nl> -	if (queue_pairs > vi->max_queue_pairs) <nl> +	if (queue_pairs > vi->max_queue_pairs || queue_pairs == 0) <nl>  		return -EINVAL; <nl>   <nl>  	get_online_cpus();
@@ -148,7 +148,7 @@ static void *cramfs_read(struct super_block *sb, unsigned int offset, unsigned i <nl>  { <nl>  	struct address_space *mapping = sb->s_bdev->bd_inode->i_mapping; <nl>  	struct page *pages[BLKS_PER_BUF]; <nl> -	unsigned i, blocknr, buffer, unread; <nl> +	unsigned i, blocknr, buffer; <nl>  	unsigned long devsize; <nl>  	char *data; <nl>   <nl> @@ -175,7 +175,6 @@ static void *cramfs_read(struct super_block *sb, unsigned int offset, unsigned i <nl>  	devsize = mapping->host->i_size >> PAGE_CACHE_SHIFT; <nl>   <nl>  	/* Ok, read in BLKS_PER_BUF pages completely first. */ <nl> -	unread = 0; <nl>  	for (i = 0; i < BLKS_PER_BUF; i++) { <nl>  		struct page *page = NULL; <nl>  
@@ -895,8 +895,6 @@ static int netxen_nic_open(struct net_device *netdev) <nl>   <nl>  	/* Done here again so that even if phantom sw overwrote it, <nl>  	 * we set it */ <nl> -	if (adapter->macaddr_set) <nl> -		adapter->macaddr_set(adapter, netdev->dev_addr); <nl>  	if (adapter->init_port <nl>  	    && adapter->init_port(adapter, adapter->portnum) != 0) { <nl>  	    del_timer_sync(&adapter->watchdog_timer); <nl> @@ -904,6 +902,8 @@ static int netxen_nic_open(struct net_device *netdev) <nl>  				netxen_nic_driver_name, adapter->portnum); <nl>  		return -EIO; <nl>  	} <nl> +	if (adapter->macaddr_set) <nl> +		adapter->macaddr_set(adapter, netdev->dev_addr); <nl>   <nl>  	netxen_nic_set_link_parameters(adapter); <nl>  
@@ -935,6 +935,9 @@ static ssize_t macvtap_do_read(struct macvtap_queue *q, <nl>  		/* Nothing to read, let's sleep */ <nl>  		schedule(); <nl>  	} <nl> +	if (!noblock) <nl> +		finish_wait(sk_sleep(&q->sk), &wait); <nl> + <nl>  	if (skb) { <nl>  		ret = macvtap_put_user(q, skb, to); <nl>  		if (unlikely(ret < 0)) <nl> @@ -942,8 +945,6 @@ static ssize_t macvtap_do_read(struct macvtap_queue *q, <nl>  		else <nl>  			consume_skb(skb); <nl>  	} <nl> -	if (!noblock) <nl> -		finish_wait(sk_sleep(&q->sk), &wait); <nl>  	return ret; <nl>  } <nl>  
@@ -297,7 +297,7 @@ static struct urb *uas_alloc_sense_urb(struct uas_dev_info *devinfo, gfp_t gfp, <nl>  	if (!urb) <nl>  		goto out; <nl>   <nl> -	iu = kmalloc(sizeof(*iu), gfp); <nl> +	iu = kzalloc(sizeof(*iu), gfp); <nl>  	if (!iu) <nl>  		goto free; <nl>   <nl> @@ -328,7 +328,7 @@ static struct urb *uas_alloc_cmd_urb(struct uas_dev_info *devinfo, gfp_t gfp, <nl>  	if (len < 0) <nl>  		len = 0; <nl>  	len = ALIGN(len, 4); <nl> -	iu = kmalloc(sizeof(*iu) + len, gfp); <nl> +	iu = kzalloc(sizeof(*iu) + len, gfp); <nl>  	if (!iu) <nl>  		goto free; <nl>  
@@ -3482,7 +3482,7 @@ static int __init d40_of_probe(struct platform_device *pdev, <nl>  			       struct device_node *np) <nl>  { <nl>  	struct stedma40_platform_data *pdata; <nl> -	int num_memcpy = 0; <nl> +	int num_phy = 0, num_memcpy = 0; <nl>  	const const __be32 *list; <nl>   <nl>  	pdata = devm_kzalloc(&pdev->dev, <nl> @@ -3491,6 +3491,11 @@ static int __init d40_of_probe(struct platform_device *pdev, <nl>  	if (!pdata) <nl>  		return -ENOMEM; <nl>   <nl> +	/* If absent this value will be obtained from h/w. */ <nl> +	of_property_read_u32(np, "dma-channels", &num_phy); <nl> +	if (num_phy > 0) <nl> +		pdata->num_of_phy_chans = num_phy; <nl> + <nl>  	list = of_get_property(np, "memcpy-channels", &num_memcpy); <nl>  	num_memcpy /= sizeof(*list); <nl>  
@@ -1112,8 +1112,11 @@ static ide_startstop_t cdrom_read_intr (ide_drive_t *drive) <nl>  	 */ <nl>  	if (dma) { <nl>  		info->dma = 0; <nl> -		if ((dma_error = HWIF(drive)->ide_dma_end(drive))) <nl> +		dma_error = HWIF(drive)->ide_dma_end(drive); <nl> +		if (dma_error) { <nl> +			printk(KERN_ERR "%s: DMA read error\n", drive->name); <nl>  			ide_dma_off(drive); <nl> +		} <nl>  	} <nl>   <nl>  	if (cdrom_decode_status(drive, 0, &stat))
@@ -155,6 +155,9 @@ static ssize_t oz_cdev_write(struct file *filp, const char __user *buf, <nl>  	struct oz_app_hdr *app_hdr; <nl>  	struct oz_serial_ctx *ctx; <nl>   <nl> +	if (count > sizeof(ei->data) - sizeof(*elt) - sizeof(*app_hdr)) <nl> +		return -EINVAL; <nl> + <nl>  	spin_lock_bh(&g_cdev.lock); <nl>  	pd = g_cdev.active_pd; <nl>  	if (pd)
@@ -27,8 +27,8 @@ struct ipc64_perm { <nl>  	unsigned char		__pad1[4 - sizeof(__kernel_mode_t)]; <nl>  	unsigned short		seq; <nl>  	unsigned short		__pad2; <nl> -	unsigned long		__unused1; <nl> -	unsigned long		__unused2; <nl> +	__kernel_ulong_t	__unused1; <nl> +	__kernel_ulong_t	__unused2; <nl>  }; <nl>   <nl>  #endif /* __ASM_GENERIC_IPCBUF_H */
@@ -241,6 +241,10 @@ nouveau_abi16_ioctl_channel_alloc(ABI16_IOCTL_ARGS) <nl>   <nl>  	if (unlikely(!abi16)) <nl>  		return -ENOMEM; <nl> + <nl> +	if (!drm->channel) <nl> +		return nouveau_abi16_put(abi16, -ENODEV); <nl> + <nl>  	client = nv_client(abi16->client); <nl>   <nl>  	if (init->fb_ctxdma_handle == ~0 || init->tt_ctxdma_handle == ~0)
@@ -715,6 +715,8 @@ int __kvm_set_memory_region(struct kvm *kvm, <nl>  		goto out; <nl>  	if (mem->guest_phys_addr & (PAGE_SIZE - 1)) <nl>  		goto out; <nl> +	if (mem->userspace_addr & (PAGE_SIZE - 1)) <nl> +		goto out; <nl>  	if (mem->slot >= KVM_MEMORY_SLOTS + KVM_PRIVATE_MEM_SLOTS) <nl>  		goto out; <nl>  	if (mem->guest_phys_addr + mem->memory_size < mem->guest_phys_addr)
@@ -197,8 +197,8 @@ static void send_handler(struct ib_mad_agent *agent, <nl>  		memcpy(timeout->mad.data, packet->mad.data, <nl>  		       sizeof (struct ib_mad_hdr)); <nl>   <nl> -		if (!queue_packet(file, agent, timeout)) <nl> -				return; <nl> +		if (queue_packet(file, agent, timeout)) <nl> +			kfree(timeout); <nl>  	} <nl>  out: <nl>  	kfree(packet);
@@ -1529,9 +1529,9 @@ EXPORT_SYMBOL_GPL(usbnet_resume); <nl>   <nl>  static int __init usbnet_init(void) <nl>  { <nl> -	/* compiler should optimize this out */ <nl> -	BUILD_BUG_ON (sizeof (((struct sk_buff *)0)->cb) <nl> -			< sizeof (struct skb_data)); <nl> +	/* Compiler should optimize this out. */ <nl> +	BUILD_BUG_ON( <nl> +		FIELD_SIZEOF(struct sk_buff, cb) < sizeof(struct skb_data)); <nl>   <nl>  	random_ether_addr(node_id); <nl>  	return 0;
@@ -1371,6 +1371,7 @@ struct disk_events { <nl>  	struct gendisk		*disk;		/* the associated disk */ <nl>  	spinlock_t		lock; <nl>   <nl> +	struct mutex		block_mutex;	/* protects blocking */ <nl>  	int			block;		/* event blocking depth */ <nl>  	unsigned int		pending;	/* events already sent out */ <nl>  	unsigned int		clearing;	/* events being cleared */ <nl> @@ -1438,12 +1439,20 @@ void disk_block_events(struct gendisk *disk) <nl>  	if (!ev) <nl>  		return; <nl>   <nl> +	/* <nl> +	 * Outer mutex ensures that the first blocker completes canceling <nl> +	 * the event work before further blockers are allowed to finish. <nl> +	 */ <nl> +	mutex_lock(&ev->block_mutex); <nl> + <nl>  	spin_lock_irqsave(&ev->lock, flags); <nl>  	cancel = !ev->block++; <nl>  	spin_unlock_irqrestore(&ev->lock, flags); <nl>   <nl>  	if (cancel) <nl>  		cancel_delayed_work_sync(&disk->ev->dwork); <nl> + <nl> +	mutex_unlock(&ev->block_mutex); <nl>  } <nl>   <nl>  static void __disk_unblock_events(struct gendisk *disk, bool check_now) <nl> @@ -1751,6 +1760,7 @@ static void disk_add_events(struct gendisk *disk) <nl>  	INIT_LIST_HEAD(&ev->node); <nl>  	ev->disk = disk; <nl>  	spin_lock_init(&ev->lock); <nl> +	mutex_init(&ev->block_mutex); <nl>  	ev->block = 1; <nl>  	ev->poll_msecs = -1; <nl>  	INIT_DELAYED_WORK(&ev->dwork, disk_events_workfn);
@@ -1998,6 +1998,7 @@ static int __exit usba_udc_remove(struct platform_device *pdev) <nl>  		gpio_free(udc->vbus_pin); <nl>   <nl>  	free_irq(udc->irq, udc); <nl> +	kfree(usba_ep); <nl>  	iounmap(udc->fifo); <nl>  	iounmap(udc->regs); <nl>  	clk_put(udc->hclk);
@@ -736,6 +736,10 @@ static unsigned int inline norm_fsc8(struct cx88_tvnorm *norm) <nl>  { <nl>  	static const unsigned int ntsc = 28636360; <nl>  	static const unsigned int pal  = 35468950; <nl> +	static const unsigned int palm  = 28604892; <nl> + <nl> +	if (norm->id & V4L2_STD_PAL_M) <nl> +		return palm; <nl>   <nl>  	return (norm->id & V4L2_STD_625_50) ? pal : ntsc; <nl>  } <nl> @@ -749,6 +753,11 @@ static unsigned int inline norm_notchfilter(struct cx88_tvnorm *norm) <nl>   <nl>  static unsigned int inline norm_htotal(struct cx88_tvnorm *norm) <nl>  { <nl> +	/* Should always be Line Draw Time / (4*FSC) */ <nl> + <nl> +	if (norm->id & V4L2_STD_PAL_M) <nl> +		return 909; <nl> + <nl>  	return (norm->id & V4L2_STD_625_50) ? 1135 : 910; <nl>  } <nl>  
@@ -53,7 +53,7 @@ static int ath10k_pci_post_rx_pipe(struct ath10k_pci_pipe *pipe_info, <nl>  static void ath10k_pci_rx_pipe_cleanup(struct ath10k_pci_pipe *pipe_info); <nl>  static void ath10k_pci_stop_ce(struct ath10k *ar); <nl>  static void ath10k_pci_device_reset(struct ath10k *ar); <nl> -static int ath10k_pci_reset_target(struct ath10k *ar); <nl> +static int ath10k_pci_wait_for_target_init(struct ath10k *ar); <nl>  static int ath10k_pci_start_intr(struct ath10k *ar); <nl>  static void ath10k_pci_stop_intr(struct ath10k *ar); <nl>   <nl> @@ -1857,7 +1857,7 @@ static int ath10k_pci_hif_power_up(struct ath10k *ar) <nl>  	 */ <nl>  	ath10k_pci_device_reset(ar); <nl>   <nl> -	ret = ath10k_pci_reset_target(ar); <nl> +	ret = ath10k_pci_wait_for_target_init(ar); <nl>  	if (ret) <nl>  		goto err_irq; <nl>   <nl> @@ -2257,7 +2257,7 @@ static void ath10k_pci_stop_intr(struct ath10k *ar) <nl>  		pci_disable_msi(ar_pci->pdev); <nl>  } <nl>   <nl> -static int ath10k_pci_reset_target(struct ath10k *ar) <nl> +static int ath10k_pci_wait_for_target_init(struct ath10k *ar) <nl>  { <nl>  	struct ath10k_pci *ar_pci = ath10k_pci_priv(ar); <nl>  	int wait_limit = 300; /* 3 sec */
@@ -161,6 +161,7 @@ static const struct ac97_codec_id snd_ac97_codec_ids[] = { <nl>  { 0x50534304, 0xffffffff, "UCB1400",		patch_ucb1400,	NULL }, <nl>  { 0x53494c20, 0xffffffe0, "Si3036,8",		mpatch_si3036,	mpatch_si3036, AC97_MODEM_PATCH }, <nl>  { 0x54524102, 0xffffffff, "TR28022",		NULL,		NULL }, <nl> +{ 0x54524103, 0xffffffff, "TR28023",		NULL,		NULL }, <nl>  { 0x54524106, 0xffffffff, "TR28026",		NULL,		NULL }, <nl>  { 0x54524108, 0xffffffff, "TR28028",		patch_tritech_tr28028,	NULL }, // added by xin jin [07/09/99] <nl>  { 0x54524123, 0xffffffff, "TR28602",		NULL,		NULL }, // only guess --jk [TR28023 = eMicro EM28023 (new CT1297)] <nl> @@ -169,7 +170,7 @@ static const struct ac97_codec_id snd_ac97_codec_ids[] = { <nl>  { 0x56494170, 0xffffffff, "VIA1617A",		patch_vt1617a,	NULL }, // modified VT1616 with S/PDIF <nl>  { 0x56494182, 0xffffffff, "VIA1618",		NULL,		NULL }, <nl>  { 0x57454301, 0xffffffff, "W83971D",		NULL,		NULL }, <nl> -{ 0x574d4c00, 0xffffffff, "WM9701A",		NULL,		NULL }, <nl> +{ 0x574d4c00, 0xffffffff, "WM9701,WM9701A",	NULL,		NULL }, <nl>  { 0x574d4C03, 0xffffffff, "WM9703,WM9707,WM9708,WM9717", patch_wolfson03, NULL}, <nl>  { 0x574d4C04, 0xffffffff, "WM9704M,WM9704Q",	patch_wolfson04, NULL}, <nl>  { 0x574d4C05, 0xffffffff, "WM9705,WM9710",	patch_wolfson05, NULL},
@@ -830,6 +830,9 @@ static int __init mbcs_init(void) <nl>  { <nl>  	int rv; <nl>   <nl> +	if (!ia64_platform_is("sn2")) <nl> +		return -ENODEV; <nl> + <nl>  	// Put driver into chrdevs[].  Get major number. <nl>  	rv = register_chrdev(mbcs_major, DEVICE_NAME, &mbcs_ops); <nl>  	if (rv < 0) {
@@ -319,13 +319,13 @@ int pci_dev_present(const struct pci_device_id *ids) <nl>  	WARN_ON(in_interrupt()); <nl>  	while (ids->vendor || ids->subvendor || ids->class_mask) { <nl>  		found = pci_get_dev_by_id(ids, NULL); <nl> -		if (found) <nl> -			goto exit; <nl> +		if (found) { <nl> +			pci_dev_put(found); <nl> +			return 1; <nl> +		} <nl>  		ids++; <nl>  	} <nl> -exit: <nl> -	if (found) <nl> -		return 1; <nl> + <nl>  	return 0; <nl>  } <nl>  EXPORT_SYMBOL(pci_dev_present);
@@ -473,9 +473,12 @@ static int it913x_identify_state(struct usb_device *udev, <nl>  	else <nl>  		props->adapter[0].fe[0].stream.u.bulk.buffersize = <nl>  			TS_BUFFER_SIZE_PID; <nl> -	if (it913x_config.dual_mode) <nl> +	if (it913x_config.dual_mode) { <nl>  		props->adapter[1].fe[0].stream.u.bulk.buffersize = <nl>  			props->adapter[0].fe[0].stream.u.bulk.buffersize; <nl> +		props->num_adapters = 2; <nl> +	} else <nl> +		props->num_adapters = 1; <nl>   <nl>  	ret = ite_firmware_select(udev, props); <nl>   <nl> @@ -499,10 +502,8 @@ static int it913x_identify_state(struct usb_device *udev, <nl>  			if (ret != 0) <nl>  				ret = it913x_wr_reg(udev, DEV_0, <nl>  					GPIOH1_O, 0x0); <nl> -			props->num_adapters = 2; <nl>  		} <nl> -	} else <nl> -		props->num_adapters = 1; <nl> +	} <nl>   <nl>  	reg = it913x_read_reg(udev, IO_MUX_POWER_CLK); <nl>  
@@ -599,7 +599,7 @@ out: <nl>  	return err; <nl>  no_route: <nl>  	kfree_skb(nskb); <nl> -	IP_INC_STATS_BH(sock_net(asoc->base.sk), IPSTATS_MIB_OUTNOROUTES); <nl> +	IP_INC_STATS(sock_net(asoc->base.sk), IPSTATS_MIB_OUTNOROUTES); <nl>   <nl>  	/* FIXME: Returning the 'err' will effect all the associations <nl>  	 * associated with a socket, although only one of the paths of the
@@ -64,15 +64,15 @@ static int dapm_up_seq[] = { <nl>  	[snd_soc_dapm_pga] = 7, <nl>  	[snd_soc_dapm_adc] = 8, <nl>  	[snd_soc_dapm_hp] = 9, <nl> -	[snd_soc_dapm_spk] = 10, <nl> -	[snd_soc_dapm_post] = 11, <nl> +	[snd_soc_dapm_spk] = 9, <nl> +	[snd_soc_dapm_post] = 10, <nl>  }; <nl>   <nl>  static int dapm_down_seq[] = { <nl>  	[snd_soc_dapm_pre] = 0, <nl>  	[snd_soc_dapm_adc] = 1, <nl>  	[snd_soc_dapm_hp] = 2, <nl> -	[snd_soc_dapm_spk] = 3, <nl> +	[snd_soc_dapm_spk] = 2, <nl>  	[snd_soc_dapm_pga] = 4, <nl>  	[snd_soc_dapm_mixer_named_ctl] = 5, <nl>  	[snd_soc_dapm_mixer] = 5,
@@ -348,8 +348,12 @@ static void notify_ring(struct drm_device *dev, <nl>  			struct intel_ring_buffer *ring) <nl>  { <nl>  	struct drm_i915_private *dev_priv = dev->dev_private; <nl> -	u32 seqno = ring->get_seqno(ring); <nl> +	u32 seqno; <nl> + <nl> +	if (ring->obj == NULL) <nl> +		return; <nl>   <nl> +	seqno = ring->get_seqno(ring); <nl>  	trace_i915_gem_request_complete(dev, seqno); <nl>   <nl>  	ring->irq_seqno = seqno;
@@ -236,15 +236,11 @@ loop: <nl>  	cur_trans->start_time = get_seconds(); <nl>  	cur_trans->dirty_bg_run = 0; <nl>   <nl> +	memset(&cur_trans->delayed_refs, 0, sizeof(cur_trans->delayed_refs)); <nl> + <nl>  	cur_trans->delayed_refs.href_root = RB_ROOT; <nl>  	cur_trans->delayed_refs.dirty_extent_root = RB_ROOT; <nl>  	atomic_set(&cur_trans->delayed_refs.num_entries, 0); <nl> -	cur_trans->delayed_refs.num_heads_ready = 0; <nl> -	cur_trans->delayed_refs.pending_csums = 0; <nl> -	cur_trans->delayed_refs.num_heads = 0; <nl> -	cur_trans->delayed_refs.flushing = 0; <nl> -	cur_trans->delayed_refs.run_delayed_start = 0; <nl> -	cur_trans->delayed_refs.qgroup_to_skip = 0; <nl>   <nl>  	/* <nl>  	 * although the tree mod log is per file system and not per transaction,
@@ -561,6 +561,8 @@ static void __init sclp_add_standby_memory(void) <nl>  	add_memory_merged(0); <nl>  } <nl>   <nl> +#define MEM_SCT_SIZE (1UL << SECTION_SIZE_BITS) <nl> + <nl>  static void __init insert_increment(u16 rn, int standby, int assigned) <nl>  { <nl>  	struct memory_increment *incr, *new_incr; <nl> @@ -573,7 +575,7 @@ static void __init insert_increment(u16 rn, int standby, int assigned) <nl>  	new_incr->rn = rn; <nl>  	new_incr->standby = standby; <nl>  	if (!standby) <nl> -		new_incr->usecount = 1; <nl> +		new_incr->usecount = rzm > MEM_SCT_SIZE ? rzm/MEM_SCT_SIZE : 1; <nl>  	last_rn = 0; <nl>  	prev = &sclp_mem_list; <nl>  	list_for_each_entry(incr, &sclp_mem_list, list) {
@@ -1218,7 +1218,7 @@ static int soc_post_component_init(struct snd_soc_card *card, <nl>   <nl>  #ifdef CONFIG_DEBUG_FS <nl>  	/* add DPCM sysfs entries */ <nl> -	if (!dai_link->dynamic) <nl> +	if (!dailess && !dai_link->dynamic) <nl>  		goto out; <nl>   <nl>  	ret = soc_dpcm_debugfs_add(rtd);
@@ -292,7 +292,8 @@ static int hist_browser__run(struct hist_browser *self, const char *title) <nl>  { <nl>  	int key; <nl>  	int exit_keys[] = { 'a', '?', 'h', 'C', 'd', 'D', 'E', 't', <nl> -			    NEWT_KEY_ENTER, NEWT_KEY_RIGHT, NEWT_KEY_LEFT, 0, }; <nl> +			    NEWT_KEY_ENTER, NEWT_KEY_RIGHT, NEWT_KEY_LEFT, <nl> +			    NEWT_KEY_TAB, NEWT_KEY_UNTAB, 0, }; <nl>   <nl>  	self->b.entries = &self->hists->entries; <nl>  	self->b.nr_entries = self->hists->nr_entries; <nl> @@ -859,6 +860,7 @@ int hists__browse(struct hists *self, const char *helpline, <nl>  					"E         Expand all callchains\n" <nl>  					"d         Zoom into current DSO\n" <nl>  					"t         Zoom into current Thread\n" <nl> +					"TAB/UNTAB Switch events\n" <nl>  					"q/CTRL+C  Exit browser"); <nl>  			continue; <nl>  		case NEWT_KEY_ENTER: <nl> @@ -997,6 +999,7 @@ int hists__tui_browse_tree(struct rb_root *self, const char *help, int evidx) <nl>  			if (nd == first) <nl>  				continue; <nl>  			nd = rb_prev(nd); <nl> +			break; <nl>  		default: <nl>  			return key; <nl>  		}
@@ -725,6 +725,7 @@ static int acpi_fujitsu_add(struct acpi_device *device) <nl>   <nl>  err_unregister_input_dev: <nl>  	input_unregister_device(input); <nl> +	input = NULL; <nl>  err_free_input_dev: <nl>  	input_free_device(input); <nl>  err_stop: <nl> @@ -738,8 +739,6 @@ static int acpi_fujitsu_remove(struct acpi_device *device, int type) <nl>   <nl>  	input_unregister_device(input); <nl>   <nl> -	input_free_device(input); <nl> - <nl>  	fujitsu->acpi_handle = NULL; <nl>   <nl>  	return 0; <nl> @@ -930,6 +929,7 @@ static int acpi_fujitsu_hotkey_add(struct acpi_device *device) <nl>   <nl>  err_unregister_input_dev: <nl>  	input_unregister_device(input); <nl> +	input = NULL; <nl>  err_free_input_dev: <nl>  	input_free_device(input); <nl>  err_free_fifo: <nl> @@ -953,8 +953,6 @@ static int acpi_fujitsu_hotkey_remove(struct acpi_device *device, int type) <nl>   <nl>  	input_unregister_device(input); <nl>   <nl> -	input_free_device(input); <nl> - <nl>  	kfifo_free(&fujitsu_hotkey->fifo); <nl>   <nl>  	fujitsu_hotkey->acpi_handle = NULL;
@@ -7736,7 +7736,8 @@ static int remove_and_add_spares(struct mddev *mddev, <nl>  		       !test_bit(Bitmap_sync, &rdev->flags))) <nl>  			continue; <nl>   <nl> -		rdev->recovery_offset = 0; <nl> +		if (rdev->saved_raid_disk < 0) <nl> +			rdev->recovery_offset = 0; <nl>  		if (mddev->pers-> <nl>  		    hot_add_disk(mddev, rdev) == 0) { <nl>  			if (sysfs_link_rdev(mddev, rdev))
@@ -161,6 +161,9 @@ postchange: <nl>  		current_multiplier); <nl>  	} <nl>  #endif <nl> +	if (err) <nl> +		freqs.new = freqs.old; <nl> + <nl>  	cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE); <nl>  	return err; <nl>  }
@@ -3775,8 +3775,14 @@ drm_hdmi_avi_infoframe_from_display_mode(struct hdmi_avi_infoframe *frame, <nl>   <nl>  	frame->picture_aspect = HDMI_PICTURE_ASPECT_NONE; <nl>   <nl> -	/* Populate picture aspect ratio from CEA mode list */ <nl> -	if (frame->video_code > 0) <nl> +	/* <nl> +	 * Populate picture aspect ratio from either <nl> +	 * user input (if specified) or from the CEA mode list. <nl> +	 */ <nl> +	if (mode->picture_aspect_ratio == HDMI_PICTURE_ASPECT_4_3 || <nl> +		mode->picture_aspect_ratio == HDMI_PICTURE_ASPECT_16_9) <nl> +		frame->picture_aspect = mode->picture_aspect_ratio; <nl> +	else if (frame->video_code > 0) <nl>  		frame->picture_aspect = drm_get_cea_aspect_ratio( <nl>  						frame->video_code); <nl>  
@@ -4641,6 +4641,11 @@ static long btrfs_ioctl_qgroup_assign(struct file *file, void __user *arg) <nl>  						sa->src, sa->dst); <nl>  	} <nl>   <nl> +	/* update qgroup status and info */ <nl> +	err = btrfs_run_qgroups(trans, root->fs_info); <nl> +	if (err < 0) <nl> +		btrfs_error(root->fs_info, ret, <nl> +			    "failed to update qgroup status and info\n"); <nl>  	err = btrfs_end_transaction(trans, root); <nl>  	if (err && !ret) <nl>  		ret = err;
@@ -2756,6 +2756,9 @@ isdn_net_setcfg(isdn_net_ioctl_cfg * cfg) <nl>  			char *c, <nl>  			*e; <nl>   <nl> +			if (strnlen(cfg->drvid, sizeof(cfg->drvid)) == <nl> +					sizeof(cfg->drvid)) <nl> +				return -EINVAL; <nl>  			drvidx = -1; <nl>  			chidx = -1; <nl>  			strcpy(drvid, cfg->drvid);
@@ -466,7 +466,7 @@ static int get_v4lctrl(struct i2c_client *client, struct v4l2_control *ctrl) <nl>  		ctrl->value = cx25840_read(client, 0x420) >> 1; <nl>  		break; <nl>  	case V4L2_CID_HUE: <nl> -		ctrl->value = cx25840_read(client, 0x422); <nl> +		ctrl->value = (s8)cx25840_read(client, 0x422); <nl>  		break; <nl>  	case V4L2_CID_AUDIO_VOLUME: <nl>  	case V4L2_CID_AUDIO_BASS:
@@ -526,6 +526,15 @@ int cap_task_kill(struct task_struct *p, struct siginfo *info, <nl>  	if (info != SEND_SIG_NOINFO && (is_si_special(info) || SI_FROMKERNEL(info))) <nl>  		return 0; <nl>   <nl> +	/* <nl> +	 * Running a setuid root program raises your capabilities. <nl> +	 * Killing your own setuid root processes was previously <nl> +	 * allowed. <nl> +	 * We must preserve legacy signal behavior in this case. <nl> +	 */ <nl> +	if (p->euid == 0 && p->uid == current->uid) <nl> +		return 0; <nl> + <nl>  	/* sigcont is permitted within same session */ <nl>  	if (sig == SIGCONT && (task_session_nr(current) == task_session_nr(p))) <nl>  		return 0;
@@ -452,8 +452,7 @@ int <nl>  nfs3svc_decode_symlinkargs(struct svc_rqst *rqstp, __be32 *p, <nl>  					struct nfsd3_symlinkargs *args) <nl>  { <nl> -	unsigned int len; <nl> -	int avail; <nl> +	unsigned int len, avail; <nl>  	char *old, *new; <nl>  	struct kvec *vec; <nl>   <nl> @@ -486,7 +485,8 @@ nfs3svc_decode_symlinkargs(struct svc_rqst *rqstp, __be32 *p, <nl>  	/* now copy next page if there is one */ <nl>  	if (len && !avail && rqstp->rq_arg.page_len) { <nl>  		avail = rqstp->rq_arg.page_len; <nl> -		if (avail > PAGE_SIZE) avail = PAGE_SIZE; <nl> +		if (avail > PAGE_SIZE) <nl> +			avail = PAGE_SIZE; <nl>  		old = page_address(rqstp->rq_arg.pages[0]); <nl>  	} <nl>  	while (len && avail && *old) {
@@ -1086,6 +1086,12 @@ static void set_connectable_complete(struct hci_dev *hdev, u8 status) <nl>  	if (!cmd) <nl>  		goto unlock; <nl>   <nl> +	if (status) { <nl> +		u8 mgmt_err = mgmt_status(status); <nl> +		cmd_status(cmd->sk, cmd->index, cmd->opcode, mgmt_err); <nl> +		goto remove_cmd; <nl> +	} <nl> + <nl>  	cp = cmd->param; <nl>  	if (cp->val) <nl>  		changed = !test_and_set_bit(HCI_CONNECTABLE, &hdev->dev_flags); <nl> @@ -1097,6 +1103,7 @@ static void set_connectable_complete(struct hci_dev *hdev, u8 status) <nl>  	if (changed) <nl>  		new_settings(hdev, cmd->sk); <nl>   <nl> +remove_cmd: <nl>  	mgmt_pending_remove(cmd); <nl>   <nl>  unlock:
@@ -440,7 +440,7 @@ static void atombios_crtc_program_ss(struct drm_crtc *crtc, <nl>  		case ATOM_PPLL_INVALID: <nl>  			return; <nl>  		} <nl> -		args.v2.ucEnable = enable; <nl> +		args.v3.ucEnable = enable; <nl>  		if ((ss->percentage == 0) || (ss->type & ATOM_EXTERNAL_SS_MASK)) <nl>  			args.v3.ucEnable = ATOM_DISABLE; <nl>  	} else if (ASIC_IS_DCE4(rdev)) {
@@ -332,6 +332,7 @@ static int setup_routing_entry(struct kvm_irq_routing_table *rt, <nl>  	 */ <nl>  	hlist_for_each_entry(ei, n, &rt->map[ue->gsi], link) <nl>  		if (ei->type == KVM_IRQ_ROUTING_MSI || <nl> +		    ue->type == KVM_IRQ_ROUTING_MSI || <nl>  		    ue->u.irqchip.irqchip == ei->irqchip.irqchip) <nl>  			return r; <nl>  
@@ -2060,8 +2060,10 @@ asmlinkage long sys_futex(u32 __user *uaddr, int op, u32 val, <nl>  	} <nl>  	/* <nl>  	 * requeue parameter in 'utime' if cmd == FUTEX_REQUEUE. <nl> +	 * number of waiters to wake in 'utime' if cmd == FUTEX_WAKE_OP. <nl>  	 */ <nl> -	if (cmd == FUTEX_REQUEUE || cmd == FUTEX_CMP_REQUEUE) <nl> +	if (cmd == FUTEX_REQUEUE || cmd == FUTEX_CMP_REQUEUE || <nl> +	    cmd == FUTEX_WAKE_OP) <nl>  		val2 = (u32) (unsigned long) utime; <nl>   <nl>  	return do_futex(uaddr, op, val, tp, uaddr2, val2, val3);
@@ -3842,7 +3842,7 @@ int __init option_setup(char *str) <nl>   <nl>      TRACE2(("option_setup() str %s\n", str ? str:"NULL"));  <nl>   <nl> -    while (cur && isdigit(*cur) && i <= MAXHA) { <nl> +    while (cur && isdigit(*cur) && i < MAXHA) { <nl>          ints[i++] = simple_strtoul(cur, NULL, 0); <nl>          if ((cur = strchr(cur, ',')) != NULL) cur++; <nl>      }
@@ -26,8 +26,12 @@ static void stop_nop_trace(struct trace_array *tr) <nl>   <nl>  static void nop_trace_init(struct trace_array *tr) <nl>  { <nl> +	int cpu; <nl>  	ctx_trace = tr; <nl>   <nl> +	for_each_online_cpu(cpu) <nl> +		tracing_reset(tr->data[cpu]); <nl> + <nl>  	if (tr->ctrl) <nl>  		start_nop_trace(tr); <nl>  }
@@ -32,6 +32,8 @@ static inline pgtable_t pte_alloc_one(struct mm_struct *mm, unsigned long addres <nl>  { <nl>  	struct page *pte; <nl>  	pte = alloc_pages(GFP_KERNEL|__GFP_REPEAT|__GFP_ZERO, 0); <nl> +	if (!pte) <nl> +		return NULL; <nl>  	pgtable_page_ctor(pte); <nl>  	return pte; <nl>  }
@@ -164,7 +164,8 @@ __do_user_fault(struct task_struct *tsk, unsigned long addr, <nl>  	struct siginfo si; <nl>   <nl>  #ifdef CONFIG_DEBUG_USER <nl> -	if (user_debug & UDBG_SEGV) { <nl> +	if (((user_debug & UDBG_SEGV) && (sig == SIGSEGV)) || <nl> +	    ((user_debug & UDBG_BUS)  && (sig == SIGBUS))) { <nl>  		printk(KERN_DEBUG "%s: unhandled page fault (%d) at 0x%08lx, code 0x%03x\n", <nl>  		       tsk->comm, sig, addr, fsr); <nl>  		show_pte(tsk->mm, addr);
@@ -1533,10 +1533,9 @@ static int gpmc_probe_dt(struct platform_device *pdev) <nl>  			 of_node_cmp(child->name, "nor") == 0) <nl>  			ret = gpmc_probe_generic_child(pdev, child); <nl>   <nl> -		if (ret < 0) { <nl> +		if (WARN(ret < 0, "%s: probing gpmc child %s failed\n", <nl> +			 __func__, child->full_name)) <nl>  			of_node_put(child); <nl> -			return ret; <nl> -		} <nl>  	} <nl>   <nl>  	return 0;
@@ -1642,6 +1642,7 @@ static int wm8995_probe(struct snd_soc_codec *codec) <nl>   <nl>  	if (ret != 0x8995) { <nl>  		dev_err(codec->dev, "Invalid device ID: %#x\n", ret); <nl> +		ret = -EINVAL; <nl>  		goto err_reg_enable; <nl>  	} <nl>  
@@ -510,6 +510,8 @@ static int hpb_dmae_chan_probe(struct hpb_dmae_device *hpbdev, int id) <nl>  	} <nl>   <nl>  	schan = &new_hpb_chan->shdma_chan; <nl> +	schan->max_xfer_len = HPB_DMA_TCR_MAX; <nl> + <nl>  	shdma_chan_probe(sdev, schan, id); <nl>   <nl>  	if (pdev->id >= 0)
@@ -11,6 +11,7 @@ <nl>   * 	(C) Copyright 2000 Alex deVries <alex@onefishtwo.ca> <nl>   *      (C) Copyright 2001 John Marvin <jsm fc hp com> <nl>   *      (C) Copyright 2003 Grant Grundler <grundler parisc-linux org> <nl> + *	(C) Copyright 2005 Kyle McMartin <kyle@parisc-linux.org> <nl>   * <nl>   *	This program is free software; you can redistribute it and/or <nl>   *	modify it under the terms of the GNU General Public License as <nl> @@ -405,6 +406,7 @@ static void __devinit superio_serial_init(void) <nl>           <nl>  	serial[0].iobase = sio_dev.sp1_base; <nl>  	serial[0].irq = SP1_IRQ; <nl> +	spin_lock_init(&serial[0].lock); <nl>   <nl>  	retval = early_serial_setup(&serial[0]); <nl>  	if (retval < 0) { <nl> @@ -414,6 +416,7 @@ static void __devinit superio_serial_init(void) <nl>   <nl>  	serial[1].iobase = sio_dev.sp2_base; <nl>  	serial[1].irq = SP2_IRQ; <nl> +	spin_lock_init(&serial[1].lock); <nl>  	retval = early_serial_setup(&serial[1]); <nl>   <nl>  	if (retval < 0)
@@ -1404,9 +1404,10 @@ int usb_serial_register_drivers(struct usb_serial_driver *const serial_drivers[] <nl>   <nl>  	/* we only set the reset_resume field if the serial_driver has one */ <nl>  	for (sd = serial_drivers; *sd; ++sd) { <nl> -		if ((*sd)->reset_resume) <nl> +		if ((*sd)->reset_resume) { <nl>  			udriver->reset_resume = usb_serial_reset_resume; <nl>  			break; <nl> +		} <nl>  	} <nl>   <nl>  	rc = usb_register(udriver);
@@ -2661,6 +2661,10 @@ static int ext4_mb_init_per_dev_proc(struct super_block *sb) <nl>  	struct proc_dir_entry *proc; <nl>  	char devname[64]; <nl>   <nl> +	if (proc_root_ext4 == NULL) { <nl> +		sbi->s_mb_proc = NULL; <nl> +		return -EINVAL; <nl> +	} <nl>  	bdevname(sb->s_bdev, devname); <nl>  	sbi->s_mb_proc = proc_mkdir(devname, proc_root_ext4); <nl>  
@@ -77,7 +77,7 @@ static const u32 cipher_suites[] = { <nl>  }; <nl>   <nl>  static const struct ieee80211_txrx_stypes <nl> -	wilc_wfi_cfg80211_mgmt_types[NL80211_IFTYPE_MAX] = { <nl> +	wilc_wfi_cfg80211_mgmt_types[NUM_NL80211_IFTYPES] = { <nl>  	[NL80211_IFTYPE_STATION] = { <nl>  		.tx = 0xffff, <nl>  		.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |
@@ -1924,36 +1924,30 @@ xfs_showargs( <nl>   <nl>  	if (mp->m_logbufs > 0) <nl>  		seq_printf(m, "," MNTOPT_LOGBUFS "=%d", mp->m_logbufs); <nl> - <nl>  	if (mp->m_logbsize > 0) <nl>  		seq_printf(m, "," MNTOPT_LOGBSIZE "=%dk", mp->m_logbsize >> 10); <nl>   <nl>  	if (mp->m_logname) <nl>  		seq_printf(m, "," MNTOPT_LOGDEV "=%s", mp->m_logname); <nl> - <nl>  	if (mp->m_rtname) <nl>  		seq_printf(m, "," MNTOPT_RTDEV "=%s", mp->m_rtname); <nl>   <nl>  	if (mp->m_dalign > 0) <nl>  		seq_printf(m, "," MNTOPT_SUNIT "=%d", <nl>  				(int)XFS_FSB_TO_BB(mp, mp->m_dalign)); <nl> - <nl>  	if (mp->m_swidth > 0) <nl>  		seq_printf(m, "," MNTOPT_SWIDTH "=%d", <nl>  				(int)XFS_FSB_TO_BB(mp, mp->m_swidth)); <nl>   <nl>  	if (!(mp->m_flags & XFS_MOUNT_COMPAT_ATTR)) <nl>  		seq_printf(m, "," MNTOPT_ATTR2); <nl> - <nl>  	if (!(mp->m_flags & XFS_MOUNT_COMPAT_IOSIZE)) <nl>  		seq_printf(m, "," MNTOPT_LARGEIO); <nl> +	if (!(mp->m_flags & XFS_MOUNT_BARRIER)) <nl> +		seq_printf(m, "," MNTOPT_NOBARRIER); <nl>   <nl>  	if (!(vfsp->vfs_flag & VFS_32BITINODES)) <nl>  		seq_printf(m, "," MNTOPT_64BITINODE); <nl> - <nl> -	if (!(vfsp->vfs_flag & XFS_MOUNT_BARRIER)) <nl> -		seq_printf(m, "," MNTOPT_NOBARRIER); <nl> - <nl>  	if (vfsp->vfs_flag & VFS_GRPID) <nl>  		seq_printf(m, "," MNTOPT_GRPID); <nl>  
@@ -19,6 +19,7 @@ static int maprom_read (struct mtd_info *, loff_t, size_t, size_t *, u_char *); <nl>  static int maprom_write (struct mtd_info *, loff_t, size_t, size_t *, const u_char *); <nl>  static void maprom_nop (struct mtd_info *); <nl>  static struct mtd_info *map_rom_probe(struct map_info *map); <nl> +static int maprom_erase (struct mtd_info *mtd, struct erase_info *info); <nl>   <nl>  static struct mtd_chip_driver maprom_chipdrv = { <nl>  	.probe	= map_rom_probe, <nl> @@ -42,6 +43,7 @@ static struct mtd_info *map_rom_probe(struct map_info *map) <nl>  	mtd->read = maprom_read; <nl>  	mtd->write = maprom_write; <nl>  	mtd->sync = maprom_nop; <nl> +	mtd->erase = maprom_erase; <nl>  	mtd->flags = MTD_CAP_ROM; <nl>  	mtd->erasesize = map->size; <nl>  	mtd->writesize = 1; <nl> @@ -71,6 +73,12 @@ static int maprom_write (struct mtd_info *mtd, loff_t to, size_t len, size_t *re <nl>  	return -EIO; <nl>  } <nl>   <nl> +static int maprom_erase (struct mtd_info *mtd, struct erase_info *info) <nl> +{ <nl> +	/* We do our best 8) */ <nl> +	return -EROFS; <nl> +} <nl> + <nl>  static int __init map_rom_init(void) <nl>  { <nl>  	register_mtd_chip_driver(&maprom_chipdrv);
@@ -320,7 +320,7 @@ int snd_pcm_hw_refine(struct snd_pcm_substream *substream, <nl>                      snd_mask_max(&params->masks[SNDRV_PCM_HW_PARAM_CHANNELS])) { <nl>  			changed = substream->ops->ioctl(substream, <nl>  					SNDRV_PCM_IOCTL1_FIFO_SIZE, params); <nl> -			if (params < 0) <nl> +			if (changed < 0) <nl>  				return changed; <nl>  		} <nl>  	}
@@ -3383,8 +3383,8 @@ extern struct pernet_operations __net_initdata loopback_net_ops; <nl>   <nl>  static inline const char *netdev_name(const struct net_device *dev) <nl>  { <nl> -	if (dev->reg_state != NETREG_REGISTERED) <nl> -		return "(unregistered net_device)"; <nl> +	if (!dev->name[0] || strchr(dev->name, '%')) <nl> +		return "(unnamed net_device)"; <nl>  	return dev->name; <nl>  } <nl>  
@@ -1053,7 +1053,7 @@ static struct of_device_id octeon_cf_match[] = { <nl>  	}, <nl>  	{}, <nl>  }; <nl> -MODULE_DEVICE_TABLE(of, octeon_i2c_match); <nl> +MODULE_DEVICE_TABLE(of, octeon_cf_match); <nl>   <nl>  static struct platform_driver octeon_cf_driver = { <nl>  	.probe		= octeon_cf_probe,
@@ -3505,7 +3505,7 @@ int ocfs2_xattr_set(struct inode *inode, <nl>  	int ret, credits, ref_meta = 0, ref_credits = 0; <nl>  	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb); <nl>  	struct inode *tl_inode = osb->osb_tl_inode; <nl> -	struct ocfs2_xattr_set_ctxt ctxt = { NULL, NULL, }; <nl> +	struct ocfs2_xattr_set_ctxt ctxt = { NULL, NULL, NULL, }; <nl>  	struct ocfs2_refcount_tree *ref_tree = NULL; <nl>   <nl>  	struct ocfs2_xattr_info xi = { <nl> @@ -3609,13 +3609,14 @@ int ocfs2_xattr_set(struct inode *inode, <nl>  	if (IS_ERR(ctxt.handle)) { <nl>  		ret = PTR_ERR(ctxt.handle); <nl>  		mlog_errno(ret); <nl> -		goto cleanup; <nl> +		goto out_free_ac; <nl>  	} <nl>   <nl>  	ret = __ocfs2_xattr_set_handle(inode, di, &xi, &xis, &xbs, &ctxt); <nl>   <nl>  	ocfs2_commit_trans(osb, ctxt.handle); <nl>   <nl> +out_free_ac: <nl>  	if (ctxt.data_ac) <nl>  		ocfs2_free_alloc_context(ctxt.data_ac); <nl>  	if (ctxt.meta_ac)
@@ -70,6 +70,13 @@ static void xen_pcibk_control_isr(struct pci_dev *dev, int reset) <nl>  		enable ? "enable" : "disable"); <nl>   <nl>  	if (enable) { <nl> +		/* <nl> +		 * The MSI or MSI-X should not have an IRQ handler. Otherwise <nl> +		 * if the guest terminates we BUG_ON in free_msi_irqs. <nl> +		 */ <nl> +		if (dev->msi_enabled || dev->msix_enabled) <nl> +			goto out; <nl> + <nl>  		rc = request_irq(dev_data->irq, <nl>  				xen_pcibk_guest_interrupt, IRQF_SHARED, <nl>  				dev_data->irq_name, dev);
@@ -1218,6 +1218,8 @@ static int ff_layout_write_done_cb(struct rpc_task *task, <nl>  	    hdr->res.verf->committed == NFS_DATA_SYNC) <nl>  		ff_layout_set_layoutcommit(hdr); <nl>   <nl> +	/* zero out fattr since we don't care DS attr at all */ <nl> +	hdr->fattr.valid = 0; <nl>  	if (task->tk_status >= 0) <nl>  		nfs_writeback_update_inode(hdr); <nl>  
@@ -235,8 +235,9 @@ int amdgpu_gem_userptr_ioctl(struct drm_device *dev, void *data, <nl>  	    AMDGPU_GEM_USERPTR_REGISTER)) <nl>  		return -EINVAL; <nl>   <nl> -	if (!(args->flags & AMDGPU_GEM_USERPTR_ANONONLY) || <nl> -		   !(args->flags & AMDGPU_GEM_USERPTR_REGISTER)) { <nl> +	if (!(args->flags & AMDGPU_GEM_USERPTR_READONLY) && ( <nl> +	     !(args->flags & AMDGPU_GEM_USERPTR_ANONONLY) || <nl> +	     !(args->flags & AMDGPU_GEM_USERPTR_REGISTER))) { <nl>   <nl>  		/* if we want to write to it we must require anonymous <nl>  		   memory and install a MMU notifier */
@@ -342,7 +342,7 @@ static int cnic_send_nlmsg(struct cnic_local *cp, u32 type, <nl>  	while (retry < 3) { <nl>  		rc = 0; <nl>  		rcu_read_lock(); <nl> -		ulp_ops = rcu_dereference(cnic_ulp_tbl[CNIC_ULP_ISCSI]); <nl> +		ulp_ops = rcu_dereference(cp->ulp_ops[CNIC_ULP_ISCSI]); <nl>  		if (ulp_ops) <nl>  			rc = ulp_ops->iscsi_nl_send_msg( <nl>  				cp->ulp_handle[CNIC_ULP_ISCSI], <nl> @@ -3244,7 +3244,8 @@ static int cnic_copy_ulp_stats(struct cnic_dev *dev, int ulp_type) <nl>  	int rc; <nl>   <nl>  	mutex_lock(&cnic_lock); <nl> -	ulp_ops = cnic_ulp_tbl_prot(ulp_type); <nl> +	ulp_ops = rcu_dereference_protected(cp->ulp_ops[ulp_type], <nl> +					    lockdep_is_held(&cnic_lock)); <nl>  	if (ulp_ops && ulp_ops->cnic_get_stats) <nl>  		rc = ulp_ops->cnic_get_stats(cp->ulp_handle[ulp_type]); <nl>  	else
@@ -351,8 +351,10 @@ again: <nl>  	 */ <nl>  	if (type != TRANS_JOIN_NOLOCK && <nl>  	    !__sb_start_write(root->fs_info->sb, SB_FREEZE_FS, false)) { <nl> -		if (type == TRANS_JOIN_FREEZE) <nl> +		if (type == TRANS_JOIN_FREEZE) { <nl> +			kmem_cache_free(btrfs_trans_handle_cachep, h); <nl>  			return ERR_PTR(-EPERM); <nl> +		} <nl>  		sb_start_intwrite(root->fs_info->sb); <nl>  	} <nl>  
@@ -158,7 +158,7 @@ static void unlink_from_unused(struct inet_peer *p) <nl>  #define lookup(_daddr,_stack) 					\ <nl>  ({								\ <nl>  	struct inet_peer *u, **v;				\ <nl> -	if (_stack) {						\ <nl> +	if (_stack != NULL) {					\ <nl>  		stackptr = _stack;				\ <nl>  		*stackptr++ = &peer_root;			\ <nl>  	}							\ <nl> @@ -169,7 +169,7 @@ static void unlink_from_unused(struct inet_peer *p) <nl>  			v = &u->avl_left;			\ <nl>  		else						\ <nl>  			v = &u->avl_right;			\ <nl> -		if (_stack)					\ <nl> +		if (_stack != NULL)				\ <nl>  			*stackptr++ = v;			\ <nl>  		u = *v;						\ <nl>  	}							\
@@ -229,7 +229,7 @@ netxen_setup_minidump(struct netxen_adapter *adapter) <nl>  				adapter->mdump.md_template; <nl>  	adapter->mdump.md_capture_buff = NULL; <nl>  	adapter->mdump.fw_supports_md = 1; <nl> -	adapter->mdump.md_enabled = 1; <nl> +	adapter->mdump.md_enabled = 0; <nl>   <nl>  	return err; <nl>  
@@ -1256,6 +1256,7 @@ static void request_firmware_work_func(struct work_struct *work) <nl>  	put_device(fw_work->device); /* taken in request_firmware_nowait() */ <nl>   <nl>  	module_put(fw_work->module); <nl> +	kfree_const(fw_work->name); <nl>  	kfree(fw_work); <nl>  } <nl>   <nl> @@ -1295,7 +1296,9 @@ request_firmware_nowait( <nl>  		return -ENOMEM; <nl>   <nl>  	fw_work->module = module; <nl> -	fw_work->name = name; <nl> +	fw_work->name = kstrdup_const(name, gfp); <nl> +	if (!fw_work->name) <nl> +		return -ENOMEM; <nl>  	fw_work->device = device; <nl>  	fw_work->context = context; <nl>  	fw_work->cont = cont; <nl> @@ -1303,6 +1306,7 @@ request_firmware_nowait( <nl>  		(uevent ? FW_OPT_UEVENT : FW_OPT_USERHELPER); <nl>   <nl>  	if (!try_module_get(module)) { <nl> +		kfree_const(fw_work->name); <nl>  		kfree(fw_work); <nl>  		return -EFAULT; <nl>  	}
@@ -673,7 +673,10 @@ xfs_vn_fiemap( <nl>  		bm.bmv_length = BTOBB(length); <nl>   <nl>  	/* We add one because in getbmap world count includes the header */ <nl> -	bm.bmv_count = fieinfo->fi_extents_max + 1; <nl> +	bm.bmv_count = !fieinfo->fi_extents_max ? MAXEXTNUM : <nl> +					fieinfo->fi_extents_max + 1; <nl> +	bm.bmv_count = min_t(__s32, bm.bmv_count, <nl> +			     (PAGE_SIZE * 16 / sizeof(struct getbmapx))); <nl>  	bm.bmv_iflags = BMV_IF_PREALLOC; <nl>  	if (fieinfo->fi_flags & FIEMAP_FLAG_XATTR) <nl>  		bm.bmv_iflags |= BMV_IF_ATTRFORK;
@@ -515,6 +515,14 @@ int etnaviv_gpu_init(struct etnaviv_gpu *gpu) <nl>  		goto fail; <nl>  	} <nl>   <nl> +	/* Exclude VG cores with FE2.0 */ <nl> +	if (gpu->identity.features & chipFeatures_PIPE_VG && <nl> +	    gpu->identity.features & chipFeatures_FE20) { <nl> +		dev_info(gpu->dev, "Ignoring GPU with VG and FE2.0\n"); <nl> +		ret = -ENXIO; <nl> +		goto fail; <nl> +	} <nl> + <nl>  	ret = etnaviv_hw_reset(gpu); <nl>  	if (ret) <nl>  		goto fail;
@@ -247,6 +247,10 @@ static void __devinit pci_fixed_bar_fixup(struct pci_dev *dev) <nl>  	u32 size; <nl>  	int i; <nl>   <nl> +	/* Must have extended configuration space */ <nl> +	if (dev->cfg_size < PCIE_CAP_OFFSET + 4) <nl> +		return; <nl> + <nl>  	/* Fixup the BAR sizes for fixed BAR devices and make them unmoveable */ <nl>  	offset = fixed_bar_cap(dev->bus, dev->devfn); <nl>  	if (!offset || PCI_DEVFN(2, 0) == dev->devfn ||
@@ -4287,6 +4287,11 @@ static int changed_cb(struct btrfs_root *left_root, <nl>  	if (ret < 0) <nl>  		goto out; <nl>   <nl> +	/* Ignore non-FS objects */ <nl> +	if (key->objectid == BTRFS_FREE_INO_OBJECTID || <nl> +	    key->objectid == BTRFS_FREE_SPACE_OBJECTID) <nl> +		goto out; <nl> + <nl>  	if (key->type == BTRFS_INODE_ITEM_KEY) <nl>  		ret = changed_inode(sctx, result); <nl>  	else if (key->type == BTRFS_INODE_REF_KEY)
@@ -899,6 +899,9 @@ static struct nft_stats __percpu *nft_stats_alloc(const struct nlattr *attr) <nl>  static void nft_chain_stats_replace(struct nft_base_chain *chain, <nl>  				    struct nft_stats __percpu *newstats) <nl>  { <nl> +	if (newstats == NULL) <nl> +		return; <nl> + <nl>  	if (chain->stats) { <nl>  		struct nft_stats __percpu *oldstats = <nl>  				nft_dereference(chain->stats);
@@ -260,10 +260,14 @@ int xgbe_mdio_register(struct xgbe_prv_data *pdata) <nl>  		of_node_put(phy_node); <nl>  		goto err_phy_device; <nl>  	} <nl> +	if (!phydev->dev.driver) { <nl> +		dev_err(pdata->dev, "phy driver probe failed\n"); <nl> +		ret = -EIO; <nl> +		goto err_phy_device; <nl> +	} <nl>   <nl>  	/* Add a reference to the PHY driver so it can't be unloaded */ <nl> -	pdata->phy_module = phydev->dev.driver ? <nl> -			    phydev->dev.driver->owner : NULL; <nl> +	pdata->phy_module = phydev->dev.driver->owner; <nl>  	if (!try_module_get(pdata->phy_module)) { <nl>  		dev_err(pdata->dev, "try_module_get failed\n"); <nl>  		ret = -EIO;
@@ -6105,7 +6105,7 @@ void kvm_arch_commit_memory_region(struct kvm *kvm, <nl>  				int user_alloc) <nl>  { <nl>   <nl> -	int npages = mem->memory_size >> PAGE_SHIFT; <nl> +	int nr_mmu_pages = 0, npages = mem->memory_size >> PAGE_SHIFT; <nl>   <nl>  	if (!user_alloc && !old.user_alloc && old.rmap && !npages) { <nl>  		int ret; <nl> @@ -6120,12 +6120,12 @@ void kvm_arch_commit_memory_region(struct kvm *kvm, <nl>  			       "failed to munmap memory\n"); <nl>  	} <nl>   <nl> +	if (!kvm->arch.n_requested_mmu_pages) <nl> +		nr_mmu_pages = kvm_mmu_calculate_mmu_pages(kvm); <nl> + <nl>  	spin_lock(&kvm->mmu_lock); <nl> -	if (!kvm->arch.n_requested_mmu_pages) { <nl> -		unsigned int nr_mmu_pages = kvm_mmu_calculate_mmu_pages(kvm); <nl> +	if (nr_mmu_pages) <nl>  		kvm_mmu_change_mmu_pages(kvm, nr_mmu_pages); <nl> -	} <nl> - <nl>  	kvm_mmu_slot_remove_write_access(kvm, mem->slot); <nl>  	spin_unlock(&kvm->mmu_lock); <nl>  }
@@ -1407,6 +1407,7 @@ int nfs_atomic_open(struct inode *dir, struct dentry *dentry, <nl>  	struct dentry *res; <nl>  	struct iattr attr = { .ia_valid = ATTR_OPEN }; <nl>  	struct inode *inode; <nl> +	unsigned int lookup_flags = 0; <nl>  	int err; <nl>   <nl>  	/* Expect a negative dentry */ <nl> @@ -1429,6 +1430,7 @@ int nfs_atomic_open(struct inode *dir, struct dentry *dentry, <nl>  			 */ <nl>  			return -ENOENT; <nl>  		} <nl> +		lookup_flags = LOOKUP_OPEN|LOOKUP_DIRECTORY; <nl>  		goto no_open; <nl>  	} <nl>   <nl> @@ -1479,7 +1481,7 @@ out: <nl>  	return err; <nl>   <nl>  no_open: <nl> -	res = nfs_lookup(dir, dentry, 0); <nl> +	res = nfs_lookup(dir, dentry, lookup_flags); <nl>  	err = PTR_ERR(res); <nl>  	if (IS_ERR(res)) <nl>  		goto out;
@@ -506,8 +506,9 @@ static int mlx4_en_complete_rx_desc(struct mlx4_en_priv *priv, <nl>  				 PCI_DMA_FROMDEVICE); <nl>  	} <nl>  	/* Adjust size of last fragment to match actual length */ <nl> -	skb_frags_rx[nr - 1].size = length - <nl> -		priv->frag_info[nr - 1].frag_prefix_size; <nl> +	if (nr > 0) <nl> +		skb_frags_rx[nr - 1].size = length - <nl> +			priv->frag_info[nr - 1].frag_prefix_size; <nl>  	return nr; <nl>   <nl>  fail:
@@ -247,7 +247,9 @@ good_area: <nl>  	return handle_mm_fault(mm, vma, addr & PAGE_MASK, flags); <nl>   <nl>  check_stack: <nl> -	if (vma->vm_flags & VM_GROWSDOWN && !expand_stack(vma, addr)) <nl> +	/* Don't allow expansion below FIRST_USER_ADDRESS */ <nl> +	if (vma->vm_flags & VM_GROWSDOWN && <nl> +	    addr >= FIRST_USER_ADDRESS && !expand_stack(vma, addr)) <nl>  		goto good_area; <nl>  out: <nl>  	return fault;
@@ -111,11 +111,11 @@ static struct mtd_partition collie_partitions[] = { <nl>   <nl>  static void collie_set_vpp(int vpp) <nl>  { <nl> -	write_scoop_reg(&colliescoop_device.dev, SCOOP_GPCR, read_scoop_reg(SCOOP_GPCR) | COLLIE_SCP_VPEN); <nl> +	write_scoop_reg(&colliescoop_device.dev, SCOOP_GPCR, read_scoop_reg(&colliescoop_device.dev, SCOOP_GPCR) | COLLIE_SCP_VPEN); <nl>  	if (vpp) <nl> -		write_scoop_reg(&colliescoop_device.dev, SCOOP_GPWR, read_scoop_reg(SCOOP_GPWR) | COLLIE_SCP_VPEN); <nl> +		write_scoop_reg(&colliescoop_device.dev, SCOOP_GPWR, read_scoop_reg(&colliescoop_device.dev, SCOOP_GPWR) | COLLIE_SCP_VPEN); <nl>  	else <nl> -		write_scoop_reg(&colliescoop_device.dev, SCOOP_GPWR, read_scoop_reg(SCOOP_GPWR) & ~COLLIE_SCP_VPEN); <nl> +		write_scoop_reg(&colliescoop_device.dev, SCOOP_GPWR, read_scoop_reg(&colliescoop_device.dev, SCOOP_GPWR) & ~COLLIE_SCP_VPEN); <nl>  } <nl>   <nl>  static struct flash_platform_data collie_flash_data = {
@@ -3675,6 +3675,11 @@ static int pci_probe(struct pci_dev *dev, <nl>   <nl>  	reg_write(ohci, OHCI1394_IsoXmitIntMaskSet, ~0); <nl>  	ohci->it_context_support = reg_read(ohci, OHCI1394_IsoXmitIntMaskSet); <nl> +	/* JMicron JMB38x often shows 0 at first read, just ignore it */ <nl> +	if (!ohci->it_context_support) { <nl> +		ohci_notice(ohci, "overriding IsoXmitIntMask\n"); <nl> +		ohci->it_context_support = 0xf; <nl> +	} <nl>  	reg_write(ohci, OHCI1394_IsoXmitIntMaskClear, ~0); <nl>  	ohci->it_context_mask = ohci->it_context_support; <nl>  	ohci->n_it = hweight32(ohci->it_context_mask);
@@ -1184,6 +1184,7 @@ static int new_term(struct parse_events_term **_term, int type_val, <nl>  		term->val.str = str; <nl>  		break; <nl>  	default: <nl> +		free(term); <nl>  		return -EINVAL; <nl>  	} <nl>  
@@ -931,7 +931,7 @@ out_err: <nl>  	 * errors we try again until the max number of retries is reached. <nl>  	 */ <nl>  	if (result != -EHOSTUNREACH && result != -ENETUNREACH && <nl> -	    result != -ENETDOWN && result != EINVAL <nl> +	    result != -ENETDOWN && result != -EINVAL <nl>  	    && result != -EPROTONOSUPPORT) { <nl>  		lowcomms_connect_sock(con); <nl>  		result = 0;
@@ -133,6 +133,8 @@ static int mga_vram_init(struct mga_device *mdev) <nl>  { <nl>  	void __iomem *mem; <nl>  	struct apertures_struct *aper = alloc_apertures(1); <nl> +	if (!aper) <nl> +		return -ENOMEM; <nl>   <nl>  	/* BAR 0 is VRAM */ <nl>  	mdev->mc.vram_base = pci_resource_start(mdev->dev->pdev, 0);
@@ -4088,9 +4088,10 @@ vxge_probe(struct pci_dev *pdev, const struct pci_device_id *pre) <nl>  		driver_config->config_dev_cnt = 0; <nl>  		driver_config->total_dev_cnt = 0; <nl>  		driver_config->g_no_cpus = 0; <nl> -		driver_config->vpath_per_dev = max_config_vpath; <nl>  	} <nl>   <nl> +	driver_config->vpath_per_dev = max_config_vpath; <nl> + <nl>  	driver_config->total_dev_cnt++; <nl>  	if (++driver_config->config_dev_cnt > max_config_dev) { <nl>  		ret = 0;
@@ -511,6 +511,10 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data) <nl>  	struct btrfs_root *root = btrfs_sb(sb); <nl>  	int ret; <nl>   <nl> +	ret = btrfs_parse_options(root, data); <nl> +	if (ret) <nl> +		return -EINVAL; <nl> + <nl>  	if ((*flags & MS_RDONLY) == (sb->s_flags & MS_RDONLY)) <nl>  		return 0; <nl>  
@@ -691,7 +691,7 @@ static int dapm_mux_update_power(struct snd_soc_dapm_widget *widget, <nl>  	return 0; <nl>  } <nl>   <nl> -/* test and update the power status of a mixer widget */ <nl> +/* test and update the power status of a mixer or switch widget */ <nl>  static int dapm_mixer_update_power(struct snd_soc_dapm_widget *widget, <nl>  				   struct snd_kcontrol *kcontrol, int reg, <nl>  				   int val_mask, int val, int invert) <nl> @@ -699,7 +699,8 @@ static int dapm_mixer_update_power(struct snd_soc_dapm_widget *widget, <nl>  	struct snd_soc_dapm_path *path; <nl>  	int found = 0; <nl>   <nl> -	if (widget->id != snd_soc_dapm_mixer) <nl> +	if (widget->id != snd_soc_dapm_mixer && <nl> +	    widget->id != snd_soc_dapm_switch) <nl>  		return -ENODEV; <nl>   <nl>  	if (!snd_soc_test_bits(widget->codec, reg, val_mask, val))
@@ -2446,6 +2446,11 @@ static int sh_eth_drv_probe(struct platform_device *pdev) <nl>  		} <nl>  		mdp->tsu_addr = ioremap(rtsu->start, <nl>  					resource_size(rtsu)); <nl> +		if (mdp->tsu_addr == NULL) { <nl> +			ret = -ENOMEM; <nl> +			dev_err(&pdev->dev, "TSU ioremap failed.\n"); <nl> +			goto out_release; <nl> +		} <nl>  		mdp->port = devno % 2; <nl>  		ndev->features = NETIF_F_HW_VLAN_FILTER; <nl>  	}
@@ -469,6 +469,8 @@ static int virtscsi_queuecommand(struct Scsi_Host *sh, struct scsi_cmnd *sc) <nl>  			      sizeof cmd->req.cmd, sizeof cmd->resp.cmd, <nl>  			      GFP_ATOMIC) >= 0) <nl>  		ret = 0; <nl> +	else <nl> +		mempool_free(cmd, virtscsi_cmd_pool); <nl>   <nl>  out: <nl>  	return ret;
@@ -172,21 +172,25 @@ int dccp_parse_options(struct sock *sk, struct sk_buff *skb) <nl>  			opt_recv->dccpor_timestamp_echo = ntohl(*(__be32 *)value); <nl>   <nl>  			dccp_pr_debug("%s rx opt: TIMESTAMP_ECHO=%u, len=%d, " <nl> -				      "ackno=%llu, ",  dccp_role(sk), <nl> +				      "ackno=%llu", dccp_role(sk), <nl>  				      opt_recv->dccpor_timestamp_echo, <nl>  				      len + 2, <nl>  				      (unsigned long long) <nl>  				      DCCP_SKB_CB(skb)->dccpd_ack_seq); <nl>   <nl>   <nl> -			if (len == 4) <nl> +			if (len == 4) { <nl> +				dccp_pr_debug_cat("\n"); <nl>  				break; <nl> +			} <nl>   <nl>  			if (len == 6) <nl>  				elapsed_time = ntohs(*(__be16 *)(value + 4)); <nl>  			else <nl>  				elapsed_time = ntohl(*(__be32 *)(value + 4)); <nl>   <nl> +			dccp_pr_debug_cat(", ELAPSED_TIME=%d\n", elapsed_time); <nl> + <nl>  			/* Give precedence to the biggest ELAPSED_TIME */ <nl>  			if (elapsed_time > opt_recv->dccpor_elapsed_time) <nl>  				opt_recv->dccpor_elapsed_time = elapsed_time;
@@ -352,6 +352,7 @@ static void cx24120_check_cmd(struct cx24120_state *state, u8 id) <nl>  	case CMD_DISEQC_MSG2: <nl>  	case CMD_SETVOLTAGE: <nl>  	case CMD_SETTONE: <nl> +	case CMD_DISEQC_BURST: <nl>  		cx24120_msg_mpeg_output_global_config(state, 0); <nl>  		/* Old driver would do a msleep(100) here */ <nl>  	default:
@@ -847,7 +847,7 @@ static int __cpuinit comp_pool_callback(struct notifier_block *nfb, <nl>  		ehca_gen_dbg("CPU: %x (CPU_PREPARE)", cpu); <nl>  		if (!create_comp_task(pool, cpu)) { <nl>  			ehca_gen_err("Can't create comp_task for cpu: %x", cpu); <nl> -			return NOTIFY_BAD; <nl> +			return notifier_from_errno(-ENOMEM); <nl>  		} <nl>  		break; <nl>  	case CPU_UP_CANCELED:
@@ -1182,10 +1182,10 @@ static void rv6xx_program_display_gap(struct radeon_device *rdev) <nl>  	u32 tmp = RREG32(CG_DISPLAY_GAP_CNTL); <nl>   <nl>  	tmp &= ~(DISP1_GAP_MCHG_MASK | DISP2_GAP_MCHG_MASK); <nl> -	if (RREG32(AVIVO_D1CRTC_CONTROL) & AVIVO_CRTC_EN) { <nl> +	if (rdev->pm.dpm.new_active_crtcs & 1) { <nl>  		tmp |= DISP1_GAP_MCHG(R600_PM_DISPLAY_GAP_VBLANK); <nl>  		tmp |= DISP2_GAP_MCHG(R600_PM_DISPLAY_GAP_IGNORE); <nl> -	} else if (RREG32(AVIVO_D2CRTC_CONTROL) & AVIVO_CRTC_EN) { <nl> +	} else if (rdev->pm.dpm.new_active_crtcs & 2) { <nl>  		tmp |= DISP1_GAP_MCHG(R600_PM_DISPLAY_GAP_IGNORE); <nl>  		tmp |= DISP2_GAP_MCHG(R600_PM_DISPLAY_GAP_VBLANK); <nl>  	} else {
@@ -486,19 +486,22 @@ static gpa_t FNAME(gva_to_gpa)(struct kvm_vcpu *vcpu, gva_t vaddr) <nl>  static void FNAME(prefetch_page)(struct kvm_vcpu *vcpu, <nl>  				 struct kvm_mmu_page *sp) <nl>  { <nl> -	int i; <nl> +	int i, offset = 0; <nl>  	pt_element_t *gpt; <nl>  	struct page *page; <nl>   <nl> -	if (sp->role.metaphysical || PTTYPE == 32) { <nl> +	if (sp->role.metaphysical <nl> +	    || (PTTYPE == 32 && sp->role.level > PT_PAGE_TABLE_LEVEL)) { <nl>  		nonpaging_prefetch_page(vcpu, sp); <nl>  		return; <nl>  	} <nl>   <nl> +	if (PTTYPE == 32) <nl> +		offset = sp->role.quadrant << PT64_LEVEL_BITS; <nl>  	page = gfn_to_page(vcpu->kvm, sp->gfn); <nl>  	gpt = kmap_atomic(page, KM_USER0); <nl>  	for (i = 0; i < PT64_ENT_PER_PAGE; ++i) <nl> -		if (is_present_pte(gpt[i])) <nl> +		if (is_present_pte(gpt[offset + i])) <nl>  			sp->spt[i] = shadow_trap_nonpresent_pte; <nl>  		else <nl>  			sp->spt[i] = shadow_notrap_nonpresent_pte;
@@ -279,7 +279,7 @@ static void cyberjack_read_int_callback(struct urb *urb) <nl>   <nl>  		old_rdtodo = priv->rdtodo; <nl>   <nl> -		if (old_rdtodo + size < old_rdtodo) { <nl> +		if (old_rdtodo > SHRT_MAX - size) { <nl>  			dev_dbg(dev, "To many bulk_in urbs to do.\n"); <nl>  			spin_unlock(&priv->lock); <nl>  			goto resubmit;
@@ -54,7 +54,8 @@ static void scatterwalk_pagedone(struct scatter_walk *walk, int out, <nl>  		struct page *page; <nl>   <nl>  		page = sg_page(walk->sg) + ((walk->offset - 1) >> PAGE_SHIFT); <nl> -		flush_dcache_page(page); <nl> +		if (!PageSlab(page)) <nl> +			flush_dcache_page(page); <nl>  	} <nl>   <nl>  	if (more) {
@@ -151,7 +151,7 @@ void kvm_check_async_pf_completion(struct kvm_vcpu *vcpu) <nl>  		spin_unlock(&vcpu->async_pf.lock); <nl>   <nl>  		kvm_arch_async_page_ready(vcpu, work); <nl> -		kvm_arch_async_page_present(vcpu, work); <nl> +		kvm_async_page_present_async(vcpu, work); <nl>   <nl>  		list_del(&work->queue); <nl>  		vcpu->async_pf.queued--;
@@ -416,7 +416,8 @@ static int gpio_setup_irq(struct gpio_desc *desc, struct device *dev, <nl>  	return 0; <nl>   <nl>  free_sd: <nl> -	sysfs_put(pdesc->value_sd); <nl> +	if (pdesc) <nl> +		sysfs_put(pdesc->value_sd); <nl>  free_id: <nl>  	idr_remove(&pdesc_idr, id); <nl>  	desc->flags &= GPIO_FLAGS_MASK;
@@ -153,7 +153,7 @@ static int mxs_dcp_start_dma(struct dcp_async_ctx *actx) <nl>  	struct dcp *sdcp = global_sdcp; <nl>  	const int chan = actx->chan; <nl>  	uint32_t stat; <nl> -	int ret; <nl> +	unsigned long ret; <nl>  	struct dcp_dma_desc *desc = &sdcp->coh->desc[actx->chan]; <nl>   <nl>  	dma_addr_t desc_phys = dma_map_single(sdcp->dev, desc, sizeof(*desc),
@@ -1318,6 +1318,10 @@ int ip_mroute_setsockopt(struct sock *sk, int optname, char __user *optval, unsi <nl>  		if (get_user(v, (u32 __user *)optval)) <nl>  			return -EFAULT; <nl>   <nl> +		/* "pimreg%u" should not exceed 16 bytes (IFNAMSIZ) */ <nl> +		if (v != RT_TABLE_DEFAULT && v >= 1000000000) <nl> +			return -EINVAL; <nl> + <nl>  		rtnl_lock(); <nl>  		ret = 0; <nl>  		if (sk == rtnl_dereference(mrt->mroute_sk)) {
@@ -785,6 +785,8 @@ static int mx2_camera_set_bus_param(struct soc_camera_device *icd, <nl>  	if (ret < 0) <nl>  		return ret; <nl>   <nl> +	if (common_flags & SOCAM_PCLK_SAMPLE_RISING) <nl> +		csicr1 |= CSICR1_REDGE; <nl>  	if (common_flags & SOCAM_PCLK_SAMPLE_FALLING) <nl>  		csicr1 |= CSICR1_INV_PCLK; <nl>  	if (common_flags & SOCAM_VSYNC_ACTIVE_HIGH)
@@ -673,7 +673,10 @@ void mei_hbm_dispatch(struct mei_device *dev, struct mei_msg_hdr *hdr) <nl>   <nl>  	case HOST_ENUM_RES_CMD: <nl>  		enum_res = (struct hbm_host_enum_response *) mei_msg; <nl> -		memcpy(dev->me_clients_map, enum_res->valid_addresses, 32); <nl> +		BUILD_BUG_ON(sizeof(dev->me_clients_map) <nl> +				< sizeof(enum_res->valid_addresses)); <nl> +		memcpy(dev->me_clients_map, enum_res->valid_addresses, <nl> +			sizeof(enum_res->valid_addresses)); <nl>  		if (dev->dev_state == MEI_DEV_INIT_CLIENTS && <nl>  		    dev->hbm_state == MEI_HBM_ENUM_CLIENTS) { <nl>  				dev->init_clients_timer = 0;
@@ -350,6 +350,9 @@ static int hostap_set_generic_element(PSDevice pDevice, <nl>  { <nl>  	PSMgmtObject    pMgmt = pDevice->pMgmt; <nl>   <nl> +	if (param->u.generic_elem.len > sizeof(pMgmt->abyWPAIE)) <nl> +		return -EINVAL; <nl> + <nl>  	memcpy(pMgmt->abyWPAIE, <nl>  	       param->u.generic_elem.data, <nl>  	       param->u.generic_elem.len
@@ -242,7 +242,7 @@ void __init tsc_calibrate(void) <nl>  	if (hpet) { <nl>  		printk(KERN_INFO "TSC calibrated against HPET\n"); <nl>  		if (hpet2 < hpet1) <nl> -			hpet2 += 0x100000000; <nl> +			hpet2 += 0x100000000UL; <nl>  		hpet2 -= hpet1; <nl>  		tsc1 = (hpet2 * hpet_readl(HPET_PERIOD)) / 1000000; <nl>  	} else {
@@ -405,7 +405,7 @@ static int dm9601_bind(struct usbnet *dev, struct usb_interface *intf) <nl>  	dev->net->ethtool_ops = &dm9601_ethtool_ops; <nl>  	dev->net->hard_header_len += DM_TX_OVERHEAD; <nl>  	dev->hard_mtu = dev->net->mtu + dev->net->hard_header_len; <nl> -	dev->rx_urb_size = dev->net->mtu + DM_RX_OVERHEAD; <nl> +	dev->rx_urb_size = dev->net->mtu + ETH_HLEN + DM_RX_OVERHEAD; <nl>   <nl>  	dev->mii.dev = dev->net; <nl>  	dev->mii.mdio_read = dm9601_mdio_read;
@@ -171,7 +171,7 @@ static void alloc_init_pmd(struct mm_struct *mm, pud_t *pud, <nl>  			if (!pmd_none(old_pmd)) { <nl>  				flush_tlb_all(); <nl>  				if (pmd_table(old_pmd)) { <nl> -					phys_addr_t table = __pa(pte_offset_map(&old_pmd, 0)); <nl> +					phys_addr_t table = pmd_page_paddr(old_pmd); <nl>  					if (!WARN_ON_ONCE(slab_is_available())) <nl>  						memblock_free(table, PAGE_SIZE); <nl>  				} <nl> @@ -232,7 +232,7 @@ static void alloc_init_pud(struct mm_struct *mm, pgd_t *pgd, <nl>  			if (!pud_none(old_pud)) { <nl>  				flush_tlb_all(); <nl>  				if (pud_table(old_pud)) { <nl> -					phys_addr_t table = __pa(pmd_offset(&old_pud, 0)); <nl> +					phys_addr_t table = pud_page_paddr(old_pud); <nl>  					if (!WARN_ON_ONCE(slab_is_available())) <nl>  						memblock_free(table, PAGE_SIZE); <nl>  				}
@@ -174,6 +174,8 @@ static SENSOR_DEVICE_ATTR(temp4_input, S_IRUGO, show_temp, NULL, 3); <nl>     REG: count of 90kHz pulses / revolution */ <nl>  static int fan_from_reg(u16 reg) <nl>  { <nl> +	if (reg == 0 || reg == 0xffff) <nl> +		return 0; <nl>  	return 90000 * 60 / reg; <nl>  } <nl>  
@@ -309,7 +309,7 @@ static int vfat_create_shortname(struct inode *dir, struct nls_table *nls, <nl>  { <nl>  	struct fat_mount_options *opts = &MSDOS_SB(dir->i_sb)->options; <nl>  	wchar_t *ip, *ext_start, *end, *name_start; <nl> -	unsigned char base[9], ext[4], buf[8], *p; <nl> +	unsigned char base[9], ext[4], buf[5], *p; <nl>  	unsigned char charbuf[NLS_MAX_CHARSET_SIZE]; <nl>  	int chl, chi; <nl>  	int sz = 0, extlen, baselen, i, numtail_baselen, numtail2_baselen; <nl> @@ -467,7 +467,7 @@ static int vfat_create_shortname(struct inode *dir, struct nls_table *nls, <nl>  			return 0; <nl>  	} <nl>   <nl> -	i = jiffies & 0xffff; <nl> +	i = jiffies; <nl>  	sz = (jiffies >> 16) & 0x7; <nl>  	if (baselen > 2) { <nl>  		baselen = numtail2_baselen; <nl> @@ -476,7 +476,7 @@ static int vfat_create_shortname(struct inode *dir, struct nls_table *nls, <nl>  	name_res[baselen + 4] = '~'; <nl>  	name_res[baselen + 5] = '1' + sz; <nl>  	while (1) { <nl> -		sprintf(buf, "%04X", i); <nl> +		snprintf(buf, sizeof(buf), "%04X", i & 0xffff); <nl>  		memcpy(&name_res[baselen], buf, 4); <nl>  		if (vfat_find_form(dir, name_res) < 0) <nl>  			break;
@@ -226,7 +226,7 @@ static void blade_image_blit(struct tridentfb_par *par, const char *data, <nl>  	writemmr(par, DST1, point(x, y)); <nl>  	writemmr(par, DST2, point(x + w - 1, y + h - 1)); <nl>   <nl> -	memcpy(par->io_virt + 0x10000, data, 4 * size); <nl> +	iowrite32_rep(par->io_virt + 0x10000, data, size); <nl>  } <nl>   <nl>  static void blade_copy_rect(struct tridentfb_par *par,
@@ -130,6 +130,9 @@ static int chacha_decrypt(struct aead_request *req) <nl>  	struct scatterlist *src, *dst; <nl>  	int err; <nl>   <nl> +	if (rctx->cryptlen == 0) <nl> +		goto skip; <nl> + <nl>  	chacha_iv(creq->iv, req, 1); <nl>   <nl>  	sg_init_table(rctx->src, 2); <nl> @@ -150,6 +153,7 @@ static int chacha_decrypt(struct aead_request *req) <nl>  	if (err) <nl>  		return err; <nl>   <nl> +skip: <nl>  	return poly_verify_tag(req); <nl>  } <nl>   <nl> @@ -415,6 +419,9 @@ static int chacha_encrypt(struct aead_request *req) <nl>  	struct scatterlist *src, *dst; <nl>  	int err; <nl>   <nl> +	if (req->cryptlen == 0) <nl> +		goto skip; <nl> + <nl>  	chacha_iv(creq->iv, req, 1); <nl>   <nl>  	sg_init_table(rctx->src, 2); <nl> @@ -435,6 +442,7 @@ static int chacha_encrypt(struct aead_request *req) <nl>  	if (err) <nl>  		return err; <nl>   <nl> +skip: <nl>  	return poly_genkey(req); <nl>  } <nl>  
@@ -677,11 +677,13 @@ xfs_trans_dqresv( <nl>  			if (!softlimit) <nl>  				softlimit = q->qi_isoftlimit; <nl>   <nl> -			if (hardlimit > 0ULL && count >= hardlimit) { <nl> +			if (hardlimit > 0ULL && <nl> +			    hardlimit < ninos + count) { <nl>  				xfs_quota_warn(mp, dqp, QUOTA_NL_IHARDWARN); <nl>  				goto error_return; <nl>  			} <nl> -			if (softlimit > 0ULL && count >= softlimit) { <nl> +			if (softlimit > 0ULL && <nl> +			    softlimit < ninos + count) { <nl>  				if  ((timer != 0 && get_seconds() > timer) || <nl>  				     (warns != 0 && warns >= warnlimit)) { <nl>  					xfs_quota_warn(mp, dqp,
@@ -407,6 +407,10 @@ static int snd_compr_allocate_buffer(struct snd_compr_stream *stream, <nl>  	unsigned int buffer_size; <nl>  	void *buffer; <nl>   <nl> +	if (params->buffer.fragment_size == 0 || <nl> +	    params->buffer.fragments > SIZE_MAX / params->buffer.fragment_size) <nl> +		return -EINVAL; <nl> + <nl>  	buffer_size = params->buffer.fragment_size * params->buffer.fragments; <nl>  	if (stream->ops->copy) { <nl>  		buffer = NULL;
@@ -336,7 +336,7 @@ i915_gem_set_tiling(struct drm_device *dev, void *data, <nl>  	} <nl>   <nl>  	mutex_lock(&dev->struct_mutex); <nl> -	if (i915_gem_obj_is_pinned(obj) || obj->framebuffer_references) { <nl> +	if (obj->pin_display || obj->framebuffer_references) { <nl>  		ret = -EBUSY; <nl>  		goto err; <nl>  	}
@@ -984,7 +984,7 @@ void btrfs_unplug_io_fn(struct backing_dev_info *bdi, struct page *page) <nl>   <nl>  static int setup_bdi(struct btrfs_fs_info *info, struct backing_dev_info *bdi) <nl>  { <nl> -#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23) <nl> +#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,23) <nl>  	bdi_init(bdi); <nl>  #endif <nl>  	bdi->ra_pages	= default_backing_dev_info.ra_pages; <nl> @@ -1378,7 +1378,7 @@ fail: <nl>   <nl>  	kfree(extent_root); <nl>  	kfree(tree_root); <nl> -#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23) <nl> +#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,23) <nl>  	bdi_destroy(&fs_info->bdi); <nl>  #endif <nl>  	kfree(fs_info); <nl> @@ -1645,7 +1645,7 @@ int close_ctree(struct btrfs_root *root) <nl>  	btrfs_close_devices(fs_info->fs_devices); <nl>  	btrfs_mapping_tree_free(&fs_info->mapping_tree); <nl>   <nl> -#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23) <nl> +#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,23) <nl>  	bdi_destroy(&fs_info->bdi); <nl>  #endif <nl>  
@@ -1045,8 +1045,10 @@ int l2tp_xmit_skb(struct l2tp_session *session, struct sk_buff *skb, int hdr_len <nl>  	headroom = NET_SKB_PAD + sizeof(struct iphdr) + <nl>  		uhlen + hdr_len; <nl>  	old_headroom = skb_headroom(skb); <nl> -	if (skb_cow_head(skb, headroom)) <nl> +	if (skb_cow_head(skb, headroom)) { <nl> +		dev_kfree_skb(skb); <nl>  		goto abort; <nl> +	} <nl>   <nl>  	new_headroom = skb_headroom(skb); <nl>  	skb_orphan(skb);
@@ -415,7 +415,7 @@ static int nand_block_checkbad(struct mtd_info *mtd, loff_t ofs, int getchip, <nl>   * Wait for the ready pin, after a command <nl>   * The timeout is catched later. <nl>   */ <nl> -static void nand_wait_ready(struct mtd_info *mtd) <nl> +void nand_wait_ready(struct mtd_info *mtd) <nl>  { <nl>  	struct nand_chip *chip = mtd->priv; <nl>  	unsigned long timeo = jiffies + 2; <nl> @@ -429,6 +429,7 @@ static void nand_wait_ready(struct mtd_info *mtd) <nl>  	} while (time_before(jiffies, timeo)); <nl>  	led_trigger_event(nand_led_trigger, LED_OFF); <nl>  } <nl> +EXPORT_SYMBOL_GPL(nand_wait_ready); <nl>   <nl>  /** <nl>   * nand_command - [DEFAULT] Send command to NAND device
@@ -595,7 +595,7 @@ unsigned short get_dma_curr_ycount(unsigned int channel) <nl>  } <nl>  EXPORT_SYMBOL(get_dma_curr_ycount); <nl>   <nl> -void *_dma_memcpy(void *dest, const void *src, size_t size) <nl> +static void *__dma_memcpy(void *dest, const void *src, size_t size) <nl>  { <nl>  	int direction;	/* 1 - address decrease, 0 - address increase */ <nl>  	int flag_align;	/* 1 - address aligned,  0 - address unaligned */ <nl> @@ -744,8 +744,8 @@ void *dma_memcpy(void *dest, const void *src, size_t size) <nl>  	bulk = (size >> 16) << 16; <nl>  	rest = size - bulk; <nl>  	if (bulk) <nl> -		_dma_memcpy(dest, src, bulk); <nl> -	addr = _dma_memcpy(dest+bulk, src+bulk, rest); <nl> +		__dma_memcpy(dest, src, bulk); <nl> +	addr = __dma_memcpy(dest+bulk, src+bulk, rest); <nl>  	return addr; <nl>  } <nl>  
@@ -2187,6 +2187,7 @@ static int nfs_get_sb(struct file_system_type *fs_type, <nl>  	if (data->version == 4) { <nl>  		error = nfs4_try_mount(flags, dev_name, data, mnt); <nl>  		kfree(data->client_address); <nl> +		kfree(data->nfs_server.export_path); <nl>  		goto out; <nl>  	} <nl>  #endif	/* CONFIG_NFS_V4 */
@@ -158,6 +158,7 @@ static int queue_init(void *priv, struct vb2_queue *src_vq, <nl>  	src_vq->ops = &g2d_qops; <nl>  	src_vq->mem_ops = &vb2_dma_contig_memops; <nl>  	src_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer); <nl> +	src_vq->timestamp_type = V4L2_BUF_FLAG_TIMESTAMP_COPY; <nl>   <nl>  	ret = vb2_queue_init(src_vq); <nl>  	if (ret) <nl> @@ -169,6 +170,7 @@ static int queue_init(void *priv, struct vb2_queue *src_vq, <nl>  	dst_vq->ops = &g2d_qops; <nl>  	dst_vq->mem_ops = &vb2_dma_contig_memops; <nl>  	dst_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer); <nl> +	dst_vq->timestamp_type = V4L2_BUF_FLAG_TIMESTAMP_COPY; <nl>   <nl>  	return vb2_queue_init(dst_vq); <nl>  } <nl> @@ -635,6 +637,9 @@ static irqreturn_t g2d_isr(int irq, void *prv) <nl>  	BUG_ON(src == NULL); <nl>  	BUG_ON(dst == NULL); <nl>   <nl> +	dst->v4l2_buf.timecode = src->v4l2_buf.timecode; <nl> +	dst->v4l2_buf.timestamp = src->v4l2_buf.timestamp; <nl> + <nl>  	v4l2_m2m_buf_done(src, VB2_BUF_STATE_DONE); <nl>  	v4l2_m2m_buf_done(dst, VB2_BUF_STATE_DONE); <nl>  	v4l2_m2m_job_finish(dev->m2m_dev, ctx->m2m_ctx);
@@ -402,7 +402,7 @@ static struct inotify_watch *create_watch(struct inotify_device *dev, <nl>  		return ERR_PTR(ret); <nl>  	} <nl>   <nl> -	dev->last_wd = ret; <nl> +	dev->last_wd = watch->wd; <nl>  	watch->mask = mask; <nl>  	atomic_set(&watch->count, 0); <nl>  	INIT_LIST_HEAD(&watch->d_list);
@@ -1285,7 +1285,7 @@ static int setup_ctxt(struct qib_pportdata *ppd, int ctxt, <nl>  	strlcpy(rcd->comm, current->comm, sizeof(rcd->comm)); <nl>  	ctxt_fp(fp) = rcd; <nl>  	qib_stats.sps_ctxts++; <nl> -	dd->freectxts++; <nl> +	dd->freectxts--; <nl>  	ret = 0; <nl>  	goto bail; <nl>   <nl> @@ -1794,7 +1794,7 @@ static int qib_close(struct inode *in, struct file *fp) <nl>  		if (dd->pageshadow) <nl>  			unlock_expected_tids(rcd); <nl>  		qib_stats.sps_ctxts--; <nl> -		dd->freectxts--; <nl> +		dd->freectxts++; <nl>  	} <nl>   <nl>  	mutex_unlock(&qib_mutex);
@@ -1228,7 +1228,7 @@ static int __init parse_crashkernel_mem(char 			*cmdline, <nl>  	} while (*cur++ == ','); <nl>   <nl>  	if (*crash_size > 0) { <nl> -		while (*cur != ' ' && *cur != '@') <nl> +		while (*cur && *cur != ' ' && *cur != '@') <nl>  			cur++; <nl>  		if (*cur == '@') { <nl>  			cur++;
@@ -559,6 +559,7 @@ static struct ib_mr *mthca_reg_phys_mr(struct ib_pd       *pd, <nl>  				  convert_access(acc), mr); <nl>   <nl>  	if (err) { <nl> +		kfree(page_list); <nl>  		kfree(mr); <nl>  		return ERR_PTR(err); <nl>  	}
@@ -297,8 +297,10 @@ static int get_dma_channel(struct device_node *ssi_np, <nl>  	 * dai->platform name should already point to an allocated buffer. <nl>  	 */ <nl>  	ret = of_address_to_resource(dma_channel_np, 0, &res); <nl> -	if (ret) <nl> +	if (ret) { <nl> +		of_node_put(dma_channel_np); <nl>  		return ret; <nl> +	} <nl>  	snprintf((char *)dai->platform_name, DAI_NAME_SIZE, "%llx.%s", <nl>  		 (unsigned long long) res.start, dma_channel_np->name); <nl>  
@@ -4952,16 +4952,18 @@ static void __atapi_pio_bytes(struct ata_queued_cmd *qc, unsigned int bytes) <nl>  { <nl>  	int do_write = (qc->tf.flags & ATA_TFLAG_WRITE); <nl>  	struct scatterlist *sg = qc->__sg; <nl> +	struct scatterlist *lsg = sg_last(qc->__sg, qc->n_elem); <nl>  	struct ata_port *ap = qc->ap; <nl>  	struct page *page; <nl>  	unsigned char *buf; <nl>  	unsigned int offset, count; <nl> +	int no_more_sg = 0; <nl>   <nl>  	if (qc->curbytes + bytes >= qc->nbytes) <nl>  		ap->hsm_task_state = HSM_ST_LAST; <nl>   <nl>  next_sg: <nl> -	if (unlikely(qc->cursg == sg_last(qc->__sg, qc->n_elem))) { <nl> +	if (unlikely(no_more_sg)) { <nl>  		/* <nl>  		 * The end of qc->sg is reached and the device expects <nl>  		 * more data to transfer. In order not to overrun qc->sg <nl> @@ -5023,6 +5025,9 @@ next_sg: <nl>  	qc->cursg_ofs += count; <nl>   <nl>  	if (qc->cursg_ofs == sg->length) { <nl> +		if (qc->cursg == lsg) <nl> +			no_more_sg = 1; <nl> + <nl>  		qc->cursg = sg_next(qc->cursg); <nl>  		qc->cursg_ofs = 0; <nl>  	}
@@ -350,6 +350,10 @@ static void __init h2_init_smc91x(void) <nl>   <nl>  static struct i2c_board_info __initdata h2_i2c_board_info[] = { <nl>  	{ <nl> +		I2C_BOARD_INFO("tps65010", 0x48), <nl> +		.type           = "tps65010", <nl> +		.irq            = OMAP_GPIO_IRQ(58), <nl> +	}, { <nl>  		I2C_BOARD_INFO("isp1301_omap", 0x2d), <nl>  		.type		= "isp1301_omap", <nl>  		.irq		= OMAP_GPIO_IRQ(2),
@@ -584,7 +584,8 @@ static int __devinit fealnx_init_one(struct pci_dev *pdev, <nl>  	if (np->flags == HAS_MII_XCVR) { <nl>  		int phy, phy_idx = 0; <nl>   <nl> -		for (phy = 1; phy < 32 && phy_idx < 4; phy++) { <nl> +		for (phy = 1; phy < 32 && phy_idx < ARRAY_SIZE(np->phys); <nl> +			       phy++) { <nl>  			int mii_status = mdio_read(dev, phy, 1); <nl>   <nl>  			if (mii_status != 0xffff && mii_status != 0x0000) {
@@ -1049,6 +1049,8 @@ static ssize_t trans_stat_show(struct device *dev, <nl>  	if (!devfreq->stop_polling && <nl>  			devfreq_update_status(devfreq, devfreq->previous_freq)) <nl>  		return 0; <nl> +	if (max_state == 0) <nl> +		return sprintf(buf, "Not Supported.\n"); <nl>   <nl>  	len = sprintf(buf, "     From  :   To\n"); <nl>  	len += sprintf(buf + len, "           :");
@@ -363,6 +363,9 @@ struct inode *ovl_d_select_inode(struct dentry *dentry, unsigned file_flags) <nl>  		ovl_path_upper(dentry, &realpath); <nl>  	} <nl>   <nl> +	if (realpath.dentry->d_flags & DCACHE_OP_SELECT_INODE) <nl> +		return realpath.dentry->d_op->d_select_inode(realpath.dentry, file_flags); <nl> + <nl>  	return d_backing_inode(realpath.dentry); <nl>  } <nl>  
@@ -210,7 +210,7 @@ static int a2mp_discover_rsp(struct amp_mgr *mgr, struct sk_buff *skb, <nl>  		BT_DBG("Remote AMP id %d type %d status %d", cl->id, cl->type, <nl>  		       cl->status); <nl>   <nl> -		if (cl->id != AMP_ID_BREDR && cl->type == HCI_AMP) { <nl> +		if (cl->id != AMP_ID_BREDR && cl->type != AMP_TYPE_BREDR) { <nl>  			struct a2mp_info_req req; <nl>   <nl>  			found = true;
@@ -441,6 +441,8 @@ static int mmc_sdio_resume(struct mmc_host *host) <nl>  	mmc_claim_host(host); <nl>  	err = mmc_sdio_init_card(host, host->ocr, host->card, <nl>  				 (host->pm_flags & MMC_PM_KEEP_POWER)); <nl> +	if (!err && host->sdio_irqs) <nl> +		mmc_signal_sdio_irq(host); <nl>  	mmc_release_host(host); <nl>   <nl>  	/*
@@ -695,6 +695,7 @@ static int snd_usb_pcm_check_knot(struct snd_pcm_runtime *runtime, <nl>  				  struct snd_usb_substream *subs) <nl>  { <nl>  	struct audioformat *fp; <nl> +	int *rate_list; <nl>  	int count = 0, needs_knot = 0; <nl>  	int err; <nl>   <nl> @@ -708,7 +709,8 @@ static int snd_usb_pcm_check_knot(struct snd_pcm_runtime *runtime, <nl>  	if (!needs_knot) <nl>  		return 0; <nl>   <nl> -	subs->rate_list.list = kmalloc(sizeof(int) * count, GFP_KERNEL); <nl> +	subs->rate_list.list = rate_list = <nl> +		kmalloc(sizeof(int) * count, GFP_KERNEL); <nl>  	if (!subs->rate_list.list) <nl>  		return -ENOMEM; <nl>  	subs->rate_list.count = count; <nl> @@ -717,7 +719,7 @@ static int snd_usb_pcm_check_knot(struct snd_pcm_runtime *runtime, <nl>  	list_for_each_entry(fp, &subs->fmt_list, list) { <nl>  		int i; <nl>  		for (i = 0; i < fp->nr_rates; i++) <nl> -			subs->rate_list.list[count++] = fp->rate_table[i]; <nl> +			rate_list[count++] = fp->rate_table[i]; <nl>  	} <nl>  	err = snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE, <nl>  					 &subs->rate_list);
@@ -9503,6 +9503,7 @@ static int nl80211_set_wowlan(struct sk_buff *skb, struct genl_info *info) <nl>  	if (new_triggers.tcp && new_triggers.tcp->sock) <nl>  		sock_release(new_triggers.tcp->sock); <nl>  	kfree(new_triggers.tcp); <nl> +	kfree(new_triggers.nd_config); <nl>  	return err; <nl>  } <nl>  #endif
@@ -252,7 +252,7 @@ static s8 link_speed; <nl>  static u8 ch_no; <nl>  static u8 set_ip[2][4]; <nl>  static u8 get_ip[2][4]; <nl> -static u32 gu32InactiveTime; <nl> +static u32 inactive_time; <nl>  static u8 gu8DelBcn; <nl>  static u32 gu32WidConnRstHack; <nl>   <nl> @@ -2257,7 +2257,7 @@ static s32 Handle_Get_InActiveTime(struct host_if_drv *hif_drv, <nl>   <nl>  	strWID.id = (u16)WID_GET_INACTIVE_TIME; <nl>  	strWID.type = WID_INT; <nl> -	strWID.val = (s8 *)&gu32InactiveTime; <nl> +	strWID.val = (s8 *)&inactive_time; <nl>  	strWID.size = sizeof(u32); <nl>   <nl>   <nl> @@ -2269,8 +2269,7 @@ static s32 Handle_Get_InActiveTime(struct host_if_drv *hif_drv, <nl>  		return -EFAULT; <nl>  	} <nl>   <nl> - <nl> -	PRINT_D(CFG80211_DBG, "Getting inactive time : %d\n", gu32InactiveTime); <nl> +	PRINT_D(CFG80211_DBG, "Getting inactive time : %d\n", inactive_time); <nl>   <nl>  	up(&hif_drv->hSemInactiveTime); <nl>   <nl> @@ -3851,7 +3850,7 @@ s32 host_int_get_inactive_time(struct host_if_drv *hif_drv, <nl>   <nl>  	down(&hif_drv->hSemInactiveTime); <nl>   <nl> -	*pu32InactiveTime = gu32InactiveTime; <nl> +	*pu32InactiveTime = inactive_time; <nl>   <nl>  	return s32Error; <nl>  }
@@ -160,9 +160,15 @@ EXPORT_SYMBOL_GPL(ip_build_and_send_pkt); <nl>  static inline int ip_finish_output2(struct sk_buff *skb) <nl>  { <nl>  	struct dst_entry *dst = skb->dst; <nl> +	struct rtable *rt = (struct rtable *)dst; <nl>  	struct net_device *dev = dst->dev; <nl>  	int hh_len = LL_RESERVED_SPACE(dev); <nl>   <nl> +	if (rt->rt_type == RTN_MULTICAST) <nl> +		IP_INC_STATS(IPSTATS_MIB_OUTMCASTPKTS); <nl> +	else if (rt->rt_type == RTN_BROADCAST) <nl> +		IP_INC_STATS(IPSTATS_MIB_OUTBCASTPKTS); <nl> + <nl>  	/* Be paranoid, rather than too clever. */ <nl>  	if (unlikely(skb_headroom(skb) < hh_len && dev->hard_header)) { <nl>  		struct sk_buff *skb2;
@@ -2991,13 +2991,13 @@ void __devinit bttv_idcard(struct bttv *btv) <nl>   <nl>  	if (UNSET != audiomux[0]) { <nl>  		gpiobits = 0; <nl> -		for (i = 0; i < 5; i++) { <nl> +		for (i = 0; i < 4; i++) { <nl>  			bttv_tvcards[btv->c.type].gpiomux[i] = audiomux[i]; <nl>  			gpiobits |= audiomux[i]; <nl>  		} <nl>  	} else { <nl>  		gpiobits = audioall; <nl> -		for (i = 0; i < 5; i++) { <nl> +		for (i = 0; i < 4; i++) { <nl>  			bttv_tvcards[btv->c.type].gpiomux[i] = audioall; <nl>  		} <nl>  	}
@@ -211,6 +211,7 @@ success: <nl>  	mmu_notifier_invalidate_range_end(mm, start, end); <nl>  	vm_stat_account(mm, oldflags, vma->vm_file, -nrpages); <nl>  	vm_stat_account(mm, newflags, vma->vm_file, nrpages); <nl> +	perf_event_mmap(vma); <nl>  	return 0; <nl>   <nl>  fail: <nl> @@ -299,7 +300,6 @@ SYSCALL_DEFINE3(mprotect, unsigned long, start, size_t, len, <nl>  		error = mprotect_fixup(vma, &prev, nstart, tmp, newflags); <nl>  		if (error) <nl>  			goto out; <nl> -		perf_event_mmap(vma); <nl>  		nstart = tmp; <nl>   <nl>  		if (nstart < prev->vm_end)
@@ -1650,8 +1650,12 @@ radeon_atom_encoder_dpms_dig(struct drm_encoder *encoder, int mode) <nl>  			atombios_dig_encoder_setup(encoder, ATOM_ENABLE, 0); <nl>  			atombios_dig_transmitter_setup(encoder, ATOM_TRANSMITTER_ACTION_SETUP, 0, 0); <nl>  			atombios_dig_transmitter_setup(encoder, ATOM_TRANSMITTER_ACTION_ENABLE, 0, 0); <nl> -			/* some early dce3.2 boards have a bug in their transmitter control table */ <nl> -			if ((rdev->family != CHIP_RV710) && (rdev->family != CHIP_RV730)) <nl> +			/* some dce3.x boards have a bug in their transmitter control table. <nl> +			 * ACTION_ENABLE_OUTPUT can probably be dropped since ACTION_ENABLE <nl> +			 * does the same thing and more. <nl> +			 */ <nl> +			if ((rdev->family != CHIP_RV710) && (rdev->family != CHIP_RV730) && <nl> +			    (rdev->family != CHIP_RS880)) <nl>  				atombios_dig_transmitter_setup(encoder, ATOM_TRANSMITTER_ACTION_ENABLE_OUTPUT, 0, 0); <nl>  		} <nl>  		if (ENCODER_MODE_IS_DP(atombios_get_encoder_mode(encoder)) && connector) {
@@ -82,7 +82,7 @@ dma_addr_t xhci_trb_virt_to_dma(struct xhci_segment *seg, <nl>  		return 0; <nl>  	/* offset in TRBs */ <nl>  	segment_offset = trb - seg->trbs; <nl> -	if (segment_offset > TRBS_PER_SEGMENT) <nl> +	if (segment_offset >= TRBS_PER_SEGMENT) <nl>  		return 0; <nl>  	return seg->dma + (segment_offset * sizeof(*trb)); <nl>  }
@@ -503,6 +503,9 @@ void sctp_transport_lower_cwnd(struct sctp_transport *transport, <nl>  		transport->ssthresh = max(transport->cwnd/2, <nl>  					  4*transport->asoc->pathmtu); <nl>  		transport->cwnd = transport->asoc->pathmtu; <nl> + <nl> +		/* T3-rtx also clears fast recovery on the transport */ <nl> +		transport->fast_recovery = 0; <nl>  		break; <nl>   <nl>  	case SCTP_LOWER_CWND_FAST_RTX:
@@ -1165,6 +1165,7 @@ int saa7134_g_ctrl(struct file *file, void *priv, struct v4l2_control *c) <nl>  	} <nl>  	return 0; <nl>  } <nl> +EXPORT_SYMBOL_GPL(saa7134_g_ctrl); <nl>   <nl>  int saa7134_s_ctrl(struct file *file, void *f, struct v4l2_control *c) <nl>  { <nl> @@ -1278,6 +1279,7 @@ error: <nl>  	mutex_unlock(&dev->lock); <nl>  	return err; <nl>  } <nl> +EXPORT_SYMBOL_GPL(saa7134_s_ctrl); <nl>   <nl>  /* ------------------------------------------------------------------ */ <nl>   <nl> @@ -1685,6 +1687,7 @@ int saa7134_queryctrl(struct file *file, void *priv, struct v4l2_queryctrl *c) <nl>  	*c = (NULL != ctrl) ? *ctrl : no_ctrl; <nl>  	return 0; <nl>  } <nl> +EXPORT_SYMBOL_GPL(saa7134_queryctrl); <nl>   <nl>  static int saa7134_enum_input(struct file *file, void *priv, <nl>  					struct v4l2_input *i)
@@ -1267,6 +1267,9 @@ arch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0, <nl>  			return (mm->free_area_cache = addr-len); <nl>  	} <nl>   <nl> +	if (mm->mmap_base < len) <nl> +		goto bottomup; <nl> + <nl>  	addr = mm->mmap_base-len; <nl>   <nl>  	do { <nl> @@ -1288,6 +1291,7 @@ arch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0, <nl>  		addr = vma->vm_start-len; <nl>  	} while (len < vma->vm_start); <nl>   <nl> +bottomup: <nl>  	/* <nl>  	 * A failed mmap() very likely causes application failure, <nl>  	 * so fall back to the bottom-up function here. This scenario
@@ -538,6 +538,7 @@ static int dev_ifsioc(unsigned int fd, unsigned int cmd, unsigned long arg) <nl>  		 * cannot be fixed without breaking all existing apps. <nl>  		 */ <nl>  		case TUNSETIFF: <nl> +		case TUNGETIFF: <nl>  		case SIOCGIFFLAGS: <nl>  		case SIOCGIFMETRIC: <nl>  		case SIOCGIFMTU: <nl> @@ -1982,6 +1983,11 @@ COMPATIBLE_IOCTL(TUNSETNOCSUM) <nl>  COMPATIBLE_IOCTL(TUNSETDEBUG) <nl>  COMPATIBLE_IOCTL(TUNSETPERSIST) <nl>  COMPATIBLE_IOCTL(TUNSETOWNER) <nl> +COMPATIBLE_IOCTL(TUNSETLINK) <nl> +COMPATIBLE_IOCTL(TUNSETGROUP) <nl> +COMPATIBLE_IOCTL(TUNGETFEATURES) <nl> +COMPATIBLE_IOCTL(TUNSETOFFLOAD) <nl> +COMPATIBLE_IOCTL(TUNSETTXFILTER) <nl>  /* Big V */ <nl>  COMPATIBLE_IOCTL(VT_SETMODE) <nl>  COMPATIBLE_IOCTL(VT_GETMODE) <nl> @@ -2573,6 +2579,7 @@ HANDLE_IOCTL(SIOCGIFPFLAGS, dev_ifsioc) <nl>  HANDLE_IOCTL(SIOCGIFTXQLEN, dev_ifsioc) <nl>  HANDLE_IOCTL(SIOCSIFTXQLEN, dev_ifsioc) <nl>  HANDLE_IOCTL(TUNSETIFF, dev_ifsioc) <nl> +HANDLE_IOCTL(TUNGETIFF, dev_ifsioc) <nl>  HANDLE_IOCTL(SIOCETHTOOL, ethtool_ioctl) <nl>  HANDLE_IOCTL(SIOCBONDENSLAVE, bond_ioctl) <nl>  HANDLE_IOCTL(SIOCBONDRELEASE, bond_ioctl)
@@ -1653,7 +1653,7 @@ static int ethtool_phys_id(struct net_device *dev, void __user *useraddr) <nl>  	if (rc == 0) { <nl>  		/* Driver will handle this itself */ <nl>  		schedule_timeout_interruptible( <nl> -			id.data ? id.data : MAX_SCHEDULE_TIMEOUT); <nl> +			id.data ? (id.data * HZ) : MAX_SCHEDULE_TIMEOUT); <nl>  	} else { <nl>  		/* Driver expects to be called periodically */ <nl>  		do {
@@ -520,6 +520,7 @@ static int econet_getname(struct socket *sock, struct sockaddr *uaddr, <nl>  	if (peer) <nl>  		return -EOPNOTSUPP; <nl>   <nl> +	memset(sec, 0, sizeof(*sec)); <nl>  	mutex_lock(&econet_mutex); <nl>   <nl>  	sk = sock->sk;
@@ -620,9 +620,9 @@ static int long_term_keys_show(struct seq_file *f, void *ptr) <nl>  	struct list_head *p, *n; <nl>   <nl>  	hci_dev_lock(hdev); <nl> -	list_for_each_safe(p, n, &hdev->link_keys) { <nl> +	list_for_each_safe(p, n, &hdev->long_term_keys) { <nl>  		struct smp_ltk *ltk = list_entry(p, struct smp_ltk, list); <nl> -		seq_printf(f, "%pMR (type %u) %u %u %u %.4x %*phN %*phN\\n", <nl> +		seq_printf(f, "%pMR (type %u) %u 0x%02x %u %.4x %*phN %*phN\n", <nl>  			   &ltk->bdaddr, ltk->bdaddr_type, ltk->authenticated, <nl>  			   ltk->type, ltk->enc_size, __le16_to_cpu(ltk->ediv), <nl>  			   8, ltk->rand, 16, ltk->val);
@@ -859,7 +859,7 @@ static enum i40e_media_type i40e_get_media_type(struct i40e_hw *hw) <nl>  } <nl>   <nl>  #define I40E_PF_RESET_WAIT_COUNT_A0	200 <nl> -#define I40E_PF_RESET_WAIT_COUNT	110 <nl> +#define I40E_PF_RESET_WAIT_COUNT	200 <nl>  /** <nl>   * i40e_pf_reset - Reset the PF <nl>   * @hw: pointer to the hardware structure
@@ -26,8 +26,6 @@ <nl>  #include <asm/pmu.h> <nl>  #include <asm/stacktrace.h> <nl>   <nl> -static struct platform_device *pmu_device; <nl> - <nl>  /* <nl>   * Hardware lock to serialize accesses to PMU registers. Needed for the <nl>   * read/modify/write sequences. <nl> @@ -85,6 +83,7 @@ struct arm_pmu { <nl>  	atomic_t	active_events; <nl>  	struct mutex	reserve_mutex; <nl>  	u64		max_period; <nl> +	struct platform_device	*plat_device; <nl>  }; <nl>   <nl>  /* Set at runtime when we know what CPU type we are. */ <nl> @@ -374,7 +373,8 @@ validate_group(struct perf_event *event) <nl>   <nl>  static irqreturn_t armpmu_platform_irq(int irq, void *dev) <nl>  { <nl> -	struct arm_pmu_platdata *plat = dev_get_platdata(&pmu_device->dev); <nl> +	struct platform_device *plat_device = armpmu->plat_device; <nl> +	struct arm_pmu_platdata *plat = dev_get_platdata(&plat_device->dev); <nl>   <nl>  	return plat->handle_irq(irq, dev, armpmu->handle_irq); <nl>  } <nl> @@ -383,6 +383,7 @@ static void <nl>  armpmu_release_hardware(void) <nl>  { <nl>  	int i, irq, irqs; <nl> +	struct platform_device *pmu_device = armpmu->plat_device; <nl>   <nl>  	irqs = min(pmu_device->num_resources, num_possible_cpus()); <nl>   <nl> @@ -404,6 +405,7 @@ armpmu_reserve_hardware(void) <nl>  	struct arm_pmu_platdata *plat; <nl>  	irq_handler_t handle_irq; <nl>  	int i, err, irq, irqs; <nl> +	struct platform_device *pmu_device = armpmu->plat_device; <nl>   <nl>  	err = reserve_pmu(ARM_PMU_DEVICE_CPU); <nl>  	if (err) { <nl> @@ -657,7 +659,7 @@ static struct platform_device_id armpmu_plat_device_ids[] = { <nl>   <nl>  static int __devinit armpmu_device_probe(struct platform_device *pdev) <nl>  { <nl> -	pmu_device = pdev; <nl> +	armpmu->plat_device = pdev; <nl>  	return 0; <nl>  } <nl>  
@@ -13,6 +13,9 @@ void print_stack_trace(struct stack_trace *trace, int spaces) <nl>  { <nl>  	int i, j; <nl>   <nl> +	if (WARN_ON(!trace->entries)) <nl> +		return; <nl> + <nl>  	for (i = 0; i < trace->nr_entries; i++) { <nl>  		unsigned long ip = trace->entries[i]; <nl>  
@@ -1813,7 +1813,7 @@ static const struct net_device_ops amd8111e_netdev_ops = { <nl>  static int amd8111e_probe_one(struct pci_dev *pdev, <nl>  				  const struct pci_device_id *ent) <nl>  { <nl> -	int err,i,pm_cap; <nl> +	int err, i; <nl>  	unsigned long reg_addr,reg_len; <nl>  	struct amd8111e_priv* lp; <nl>  	struct net_device* dev; <nl> @@ -1842,7 +1842,7 @@ static int amd8111e_probe_one(struct pci_dev *pdev, <nl>  	pci_set_master(pdev); <nl>   <nl>  	/* Find power-management capability. */ <nl> -	if((pm_cap = pci_find_capability(pdev, PCI_CAP_ID_PM))==0){ <nl> +	if (!pdev->pm_cap) { <nl>  		printk(KERN_ERR "amd8111e: No Power Management capability, " <nl>  		       "exiting.\n"); <nl>  		err = -ENODEV; <nl> @@ -1875,7 +1875,7 @@ static int amd8111e_probe_one(struct pci_dev *pdev, <nl>  	lp = netdev_priv(dev); <nl>  	lp->pci_dev = pdev; <nl>  	lp->amd8111e_net_dev = dev; <nl> -	lp->pm_cap = pm_cap; <nl> +	lp->pm_cap = pdev->pm_cap; <nl>   <nl>  	spin_lock_init(&lp->lock); <nl>  
@@ -2848,7 +2848,7 @@ int do_sigtimedwait(const sigset_t *which, siginfo_t *info, <nl>  		recalc_sigpending(); <nl>  		spin_unlock_irq(&tsk->sighand->siglock); <nl>   <nl> -		timeout = schedule_timeout_interruptible(timeout); <nl> +		timeout = freezable_schedule_timeout_interruptible(timeout); <nl>   <nl>  		spin_lock_irq(&tsk->sighand->siglock); <nl>  		__set_task_blocked(tsk, &tsk->real_blocked);
@@ -1636,7 +1636,7 @@ int brcmf_fws_hdrpull(struct brcmf_pub *drvr, int ifidx, s16 signal_len, <nl>  	if (!signal_len) <nl>  		return 0; <nl>  	/* if flow control disabled, skip to packet data and leave */ <nl> -	if (!fws->fw_signals) { <nl> +	if ((!fws) || (!fws->fw_signals)) { <nl>  		skb_pull(skb, signal_len); <nl>  		return 0; <nl>  	}
@@ -294,6 +294,10 @@ static int omap3_onenand_read_bufferram(struct mtd_info *mtd, int area, <nl>  	if (bram_offset & 3 || (size_t)buf & 3 || count < 384) <nl>  		goto out_copy; <nl>   <nl> +	/* panic_write() may be in an interrupt context */ <nl> +	if (in_interrupt()) <nl> +		goto out_copy; <nl> + <nl>  	if (buf >= high_memory) { <nl>  		struct page *p1; <nl>  
@@ -266,6 +266,8 @@ static int crypto_ccm_auth(struct aead_request *req, struct scatterlist *plain, <nl>  	if (assoclen) { <nl>  		pctx->ilen = format_adata(idata, assoclen); <nl>  		get_data_to_compute(cipher, pctx, req->assoc, req->assoclen); <nl> +	} else { <nl> +		pctx->ilen = 0; <nl>  	} <nl>   <nl>  	/* compute plaintext into mac */
@@ -1469,7 +1469,7 @@ mwifiex_update_curr_bss_params(struct mwifiex_private *priv, u8 *bssid, <nl>  			       s32 rssi, const u8 *ie_buf, size_t ie_len, <nl>  			       u16 beacon_period, u16 cap_info_bitmap, u8 band) <nl>  { <nl> -	struct mwifiex_bssdescriptor *bss_desc = NULL; <nl> +	struct mwifiex_bssdescriptor *bss_desc; <nl>  	int ret; <nl>  	unsigned long flags; <nl>  	u8 *beacon_ie; <nl> @@ -1484,6 +1484,7 @@ mwifiex_update_curr_bss_params(struct mwifiex_private *priv, u8 *bssid, <nl>   <nl>  	beacon_ie = kmemdup(ie_buf, ie_len, GFP_KERNEL); <nl>  	if (!beacon_ie) { <nl> +		kfree(bss_desc); <nl>  		dev_err(priv->adapter->dev, " failed to alloc beacon_ie\n"); <nl>  		return -ENOMEM; <nl>  	}
@@ -306,6 +306,7 @@ static void i915_hotplug_work_func(struct work_struct *work) <nl>  	struct drm_mode_config *mode_config = &dev->mode_config; <nl>  	struct intel_encoder *encoder; <nl>   <nl> +	mutex_lock(&mode_config->mutex); <nl>  	DRM_DEBUG_KMS("running encoder hotplug functions\n"); <nl>   <nl>  	list_for_each_entry(encoder, &mode_config->encoder_list, base.head) <nl> @@ -314,6 +315,8 @@ static void i915_hotplug_work_func(struct work_struct *work) <nl>   <nl>  	/* Just fire off a uevent and let userspace tell us what to do */ <nl>  	drm_helper_hpd_irq_event(dev); <nl> + <nl> +	mutex_unlock(&mode_config->mutex); <nl>  } <nl>   <nl>  static void i915_handle_rps_change(struct drm_device *dev)
@@ -1652,7 +1652,7 @@ static int __devinit piix_init_one(struct pci_dev *pdev, <nl>  		u8 tmp; <nl>  		pci_read_config_byte(pdev, PIIX_SCC, &tmp); <nl>  		if (tmp == PIIX_AHCI_DEVICE) { <nl> -			int rc = piix_disable_ahci(pdev); <nl> +			rc = piix_disable_ahci(pdev); <nl>  			if (rc) <nl>  				return rc; <nl>  		}
@@ -471,6 +471,8 @@ static bool compliance_mode_recovery_timer_quirk_check(void) <nl>   <nl>  	dmi_product_name = dmi_get_system_info(DMI_PRODUCT_NAME); <nl>  	dmi_sys_vendor = dmi_get_system_info(DMI_SYS_VENDOR); <nl> +	if (!dmi_product_name || !dmi_sys_vendor) <nl> +		return false; <nl>   <nl>  	if (!(strstr(dmi_sys_vendor, "Hewlett-Packard"))) <nl>  		return false;
@@ -509,6 +509,8 @@ static int rtl8187_add_interface(struct ieee80211_hw *dev, <nl>  		return -EOPNOTSUPP; <nl>  	} <nl>   <nl> +	priv->vif = conf->vif; <nl> + <nl>  	rtl818x_iowrite8(priv, &priv->map->EEPROM_CMD, RTL818X_EEPROM_CMD_CONFIG); <nl>  	for (i = 0; i < ETH_ALEN; i++) <nl>  		rtl818x_iowrite8(priv, &priv->map->MAC[i], <nl> @@ -523,6 +525,7 @@ static void rtl8187_remove_interface(struct ieee80211_hw *dev, <nl>  { <nl>  	struct rtl8187_priv *priv = dev->priv; <nl>  	priv->mode = IEEE80211_IF_TYPE_MNTR; <nl> +	priv->vif = NULL; <nl>  } <nl>   <nl>  static int rtl8187_config(struct ieee80211_hw *dev, struct ieee80211_conf *conf)
@@ -1347,7 +1347,7 @@ static int __init wb_module_init(void) <nl>   <nl>  	err = map_bios(); <nl>  	if (err) <nl> -		return err; <nl> +		goto err_free_keymap; <nl>   <nl>  	err = platform_driver_register(&wistron_driver); <nl>  	if (err) <nl> @@ -1371,6 +1371,8 @@ static int __init wb_module_init(void) <nl>  	platform_driver_unregister(&wistron_driver); <nl>   err_unmap_bios: <nl>  	unmap_bios(); <nl> + err_free_keymap: <nl> +	kfree(keymap); <nl>   <nl>  	return err; <nl>  }
@@ -162,10 +162,16 @@ static int wm8993_put_dc_servo(struct snd_kcontrol *kcontrol, <nl>  			       struct snd_ctl_elem_value *ucontrol) <nl>  { <nl>  	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol); <nl> +	struct wm_hubs_data *hubs = codec->private_data; <nl>  	int ret; <nl>   <nl>  	ret = snd_soc_put_volsw_2r(kcontrol, ucontrol); <nl>   <nl> +	/* If we're applying an offset correction then updating the <nl> +	 * callibration would be likely to introduce further offsets. */ <nl> +	if (hubs->dcs_codes) <nl> +		return ret; <nl> + <nl>  	/* Only need to do this if the outputs are active */ <nl>  	if (snd_soc_read(codec, WM8993_POWER_MANAGEMENT_1) <nl>  	    & (WM8993_HPOUT1L_ENA | WM8993_HPOUT1R_ENA))
@@ -320,7 +320,7 @@ __asm__ __volatile__(					\ <nl>  ({								\ <nl>  	long __gu_err, __gu_val;				\ <nl>  	__get_user_size(__gu_val,(ptr),(size),__gu_err);	\ <nl> -	(x) = (__typeof__(*(ptr)))__gu_val;			\ <nl> +	(x) = (__force __typeof__(*(ptr)))__gu_val;			\ <nl>  	__gu_err;						\ <nl>  }) <nl>   <nl> @@ -330,7 +330,7 @@ __asm__ __volatile__(					\ <nl>  	const __typeof__(*(ptr)) *__gu_addr = (ptr);			\ <nl>  	if (access_ok(VERIFY_READ,__gu_addr,size))			\ <nl>  		__get_user_size(__gu_val,__gu_addr,(size),__gu_err);	\ <nl> -	(x) = (__typeof__(*(ptr)))__gu_val;				\ <nl> +	(x) = (__force __typeof__(*(ptr)))__gu_val;				\ <nl>  	__gu_err;							\ <nl>  }) <nl>  
@@ -75,7 +75,7 @@ static unsigned long iommu_range_alloc(struct iommu_table *tbl, <nl>  	/* This allocator was derived from x86_64's bit string search */ <nl>   <nl>  	/* Sanity check */ <nl> -	if (unlikely(npages) == 0) { <nl> +	if (unlikely(npages == 0)) { <nl>  		if (printk_ratelimit()) <nl>  			WARN_ON(1); <nl>  		return DMA_ERROR_CODE;
@@ -2777,6 +2777,8 @@ static int dr_interception(struct vcpu_svm *svm) <nl>  			kvm_register_write(&svm->vcpu, reg, val); <nl>  	} <nl>   <nl> +	skip_emulated_instruction(&svm->vcpu); <nl> + <nl>  	return 1; <nl>  } <nl>  
@@ -1045,6 +1045,7 @@ static struct nvme_iod *nvme_map_user_pages(struct nvme_dev *dev, int write, <nl>  		length -= (PAGE_SIZE - offset); <nl>  		offset = 0; <nl>  	} <nl> +	sg_mark_end(&sg[i - 1]); <nl>   <nl>  	err = -ENOMEM; <nl>  	nents = dma_map_sg(&dev->pci_dev->dev, sg, count,
@@ -12722,6 +12722,9 @@ static int bnx2x_init_dev(struct bnx2x *bp, struct pci_dev *pdev, <nl>  	pci_write_config_dword(bp->pdev, PCICFG_GRC_ADDRESS, <nl>  			       PCICFG_VENDOR_ID_OFFSET); <nl>   <nl> +	/* Set PCIe reset type to fundamental for EEH recovery */ <nl> +	pdev->needs_freset = 1; <nl> + <nl>  	/* AER (Advanced Error reporting) configuration */ <nl>  	rc = pci_enable_pcie_error_reporting(pdev); <nl>  	if (!rc)
@@ -133,10 +133,6 @@ static int of_platform_serial_setup(struct platform_device *ofdev, <nl>  	if (of_find_property(np, "no-loopback-test", NULL)) <nl>  		port->flags |= UPF_SKIP_TEST; <nl>   <nl> -	ret = of_alias_get_id(np, "serial"); <nl> -	if (ret >= 0) <nl> -		port->line = ret; <nl> - <nl>  	port->dev = &ofdev->dev; <nl>   <nl>  	switch (type) {
@@ -1155,7 +1155,7 @@ static void balloon_up(struct work_struct *dummy) <nl>  	floor = compute_balloon_floor(); <nl>   <nl>  	/* Refuse to balloon below the floor, keep the 2M granularity. */ <nl> -	if (val.freeram - num_pages < floor) { <nl> +	if (val.freeram < num_pages || val.freeram - num_pages < floor) { <nl>  		num_pages = val.freeram > floor ? (val.freeram - floor) : 0; <nl>  		num_pages -= num_pages % PAGES_IN_2M; <nl>  	}
@@ -2941,6 +2941,7 @@ done: <nl>  		break; <nl>   <nl>  	case L2CAP_MODE_STREAMING: <nl> +		l2cap_txwin_setup(chan); <nl>  		rfc.mode            = L2CAP_MODE_STREAMING; <nl>  		rfc.txwin_size      = 0; <nl>  		rfc.max_transmit    = 0;
@@ -3397,7 +3397,7 @@ int __init ip_rt_init(void) <nl>  					0, <nl>  					&rt_hash_log, <nl>  					&rt_hash_mask, <nl> -					0); <nl> +					rhash_entries ? 0 : 512 * 1024); <nl>  	memset(rt_hash_table, 0, (rt_hash_mask + 1) * sizeof(struct rt_hash_bucket)); <nl>  	rt_hash_lock_init(); <nl>  
@@ -679,6 +679,7 @@ static dma_cookie_t imxdma_tx_submit(struct dma_async_tx_descriptor *tx) <nl>  	unsigned long flags; <nl>   <nl>  	spin_lock_irqsave(&imxdma->lock, flags); <nl> +	list_move_tail(imxdmac->ld_free.next, &imxdmac->ld_queue); <nl>  	cookie = dma_cookie_assign(tx); <nl>  	spin_unlock_irqrestore(&imxdma->lock, flags); <nl>  
@@ -909,6 +909,8 @@ static void parse_dacl(struct cifs_acl *pdacl, char *end_of_acl, <nl>  		umode_t group_mask = S_IRWXG; <nl>  		umode_t other_mask = S_IRWXU | S_IRWXG | S_IRWXO; <nl>   <nl> +		if (num_aces > ULONG_MAX / sizeof(struct cifs_ace *)) <nl> +			return; <nl>  		ppace = kmalloc(num_aces * sizeof(struct cifs_ace *), <nl>  				GFP_KERNEL); <nl>  		if (!ppace) {
@@ -103,8 +103,10 @@ static int xfrm6_fill_dst(struct xfrm_dst *xdst, struct net_device *dev, <nl>  	dev_hold(dev); <nl>   <nl>  	xdst->u.rt6.rt6i_idev = in6_dev_get(dev); <nl> -	if (!xdst->u.rt6.rt6i_idev) <nl> +	if (!xdst->u.rt6.rt6i_idev) { <nl> +		dev_put(dev); <nl>  		return -ENODEV; <nl> +	} <nl>   <nl>  	rt6_transfer_peer(&xdst->u.rt6, rt); <nl>  
@@ -1827,7 +1827,7 @@ static int __devinit sh_mobile_ceu_probe(struct platform_device *pdev) <nl>   <nl>  	res = platform_get_resource(pdev, IORESOURCE_MEM, 0); <nl>  	irq = platform_get_irq(pdev, 0); <nl> -	if (!res || !irq) { <nl> +	if (!res || (int)irq <= 0) { <nl>  		dev_err(&pdev->dev, "Not enough CEU platform resources.\n"); <nl>  		err = -ENODEV; <nl>  		goto exit;
@@ -4286,6 +4286,7 @@ static int l2cap_create_channel_req(struct l2cap_conn *conn, <nl>   <nl>  		mgr->bredr_chan = chan; <nl>  		chan->hs_hcon = hs_hcon; <nl> +		chan->fcs = L2CAP_FCS_NONE; <nl>  		conn->mtu = hdev->block_mtu; <nl>  	} <nl>  
@@ -344,7 +344,7 @@ static struct mmc_blk_ioc_data *mmc_blk_ioctl_copy_from_user( <nl>  	struct mmc_blk_ioc_data *idata; <nl>  	int err; <nl>   <nl> -	idata = kzalloc(sizeof(*idata), GFP_KERNEL); <nl> +	idata = kmalloc(sizeof(*idata), GFP_KERNEL); <nl>  	if (!idata) { <nl>  		err = -ENOMEM; <nl>  		goto out; <nl> @@ -364,7 +364,7 @@ static struct mmc_blk_ioc_data *mmc_blk_ioctl_copy_from_user( <nl>  	if (!idata->buf_bytes) <nl>  		return idata; <nl>   <nl> -	idata->buf = kzalloc(idata->buf_bytes, GFP_KERNEL); <nl> +	idata->buf = kmalloc(idata->buf_bytes, GFP_KERNEL); <nl>  	if (!idata->buf) { <nl>  		err = -ENOMEM; <nl>  		goto idata_err;
@@ -411,6 +411,7 @@ nfsd4_decode_fattr(struct nfsd4_compoundargs *argp, u32 *bmval, <nl>  		label->data = kzalloc(dummy32 + 1, GFP_KERNEL); <nl>  		if (!label->data) <nl>  			return nfserr_jukebox; <nl> +		label->len = dummy32; <nl>  		defer_free(argp, kfree, label->data); <nl>  		memcpy(label->data, buf, dummy32); <nl>  	}
@@ -2788,9 +2788,7 @@ xfs_qm_freelist_destroy(xfs_frlist_t *ql) <nl>  		xfs_qm_dqdestroy(dqp); <nl>  		dqp = nextdqp; <nl>  	} <nl> -	/* <nl> -	 * Don't bother about unlocking. <nl> -	 */ <nl> +	mutex_unlock(&ql->qh_lock); <nl>  	mutex_destroy(&ql->qh_lock); <nl>   <nl>  	ASSERT(ql->qh_nelems == 0);
@@ -834,7 +834,7 @@ static ssize_t <nl>  store_fc_rport_dev_loss_tmo(struct device *dev, struct device_attribute *attr, <nl>  			    const char *buf, size_t count) <nl>  { <nl> -	int val; <nl> +	unsigned long val; <nl>  	struct fc_rport *rport = transport_class_to_rport(dev); <nl>  	struct Scsi_Host *shost = rport_to_shost(rport); <nl>  	struct fc_internal *i = to_fc_internal(shost->transportt); <nl> @@ -847,6 +847,12 @@ store_fc_rport_dev_loss_tmo(struct device *dev, struct device_attribute *attr, <nl>  	if ((*cp && (*cp != '\n')) || (val < 0)) <nl>  		return -EINVAL; <nl>   <nl> +	/* <nl> +	 * Check for overflow; dev_loss_tmo is u32 <nl> +	 */ <nl> +	if (val > UINT_MAX) <nl> +		return -EINVAL; <nl> + <nl>  	/* <nl>  	 * If fast_io_fail is off we have to cap <nl>  	 * dev_loss_tmo at SCSI_DEVICE_BLOCK_MAX_TIMEOUT <nl> @@ -2865,7 +2871,7 @@ void <nl>  fc_remote_port_delete(struct fc_rport  *rport) <nl>  { <nl>  	struct Scsi_Host *shost = rport_to_shost(rport); <nl> -	int timeout = rport->dev_loss_tmo; <nl> +	unsigned long timeout = rport->dev_loss_tmo; <nl>  	unsigned long flags; <nl>   <nl>  	/*
@@ -2989,6 +2989,7 @@ brcmf_notify_sched_scan_results(struct brcmf_if *ifp, <nl>  		} <nl>   <nl>  		set_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status); <nl> +		cfg->escan_info.run = brcmf_run_escan; <nl>  		err = brcmf_do_escan(cfg, wiphy, ifp, request); <nl>  		if (err) { <nl>  			clear_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status);
@@ -981,8 +981,8 @@ static void hsmmc_command_incomplete(struct omap_hsmmc_host *host, <nl>  	if (host->data) { <nl>  		omap_hsmmc_reset_controller_fsm(host, SRD); <nl>  		omap_hsmmc_dma_cleanup(host, err); <nl> -	} <nl> - <nl> +	} else if (host->mrq && host->mrq->cmd) <nl> +		host->mrq->cmd->error = err; <nl>  } <nl>   <nl>  static void omap_hsmmc_do_irq(struct omap_hsmmc_host *host, int status)
@@ -972,7 +972,7 @@ static const struct usb_device_id option_ids[] = { <nl>  	{ USB_DEVICE(OLIVETTI_VENDOR_ID, OLIVETTI_PRODUCT_OLICARD100) }, <nl>  	{ USB_DEVICE(CELOT_VENDOR_ID, CELOT_PRODUCT_CT680M) }, /* CT-650 CDMA 450 1xEVDO modem */ <nl>  	{ USB_DEVICE(ONDA_VENDOR_ID, ONDA_MT825UP) }, /* ONDA MT825UP modem */ <nl> -	{ USB_DEVICE_AND_INTERFACE_INFO(SAMSUNG_VENDOR_ID, SAMSUNG_PRODUCT_GT_B3730, USB_CLASS_CDC_DATA, 0x00, 0x00) }, /* Samsung GT-B3730/GT-B3710 LTE USB modem.*/ <nl> +	{ USB_DEVICE_AND_INTERFACE_INFO(SAMSUNG_VENDOR_ID, SAMSUNG_PRODUCT_GT_B3730, USB_CLASS_CDC_DATA, 0x00, 0x00) }, /* Samsung GT-B3730 LTE USB modem.*/ <nl>  	{ } /* Terminating entry */ <nl>  }; <nl>  MODULE_DEVICE_TABLE(usb, option_ids); <nl> @@ -1109,6 +1109,12 @@ static int option_probe(struct usb_serial *serial, <nl>  		serial->interface->cur_altsetting->desc.bInterfaceNumber == 1) <nl>  		return -ENODEV; <nl>   <nl> +	/* Don't bind network interface on Samsung GT-B3730, it is handled by a separate module */ <nl> +	if (serial->dev->descriptor.idVendor == SAMSUNG_VENDOR_ID && <nl> +		serial->dev->descriptor.idProduct == SAMSUNG_PRODUCT_GT_B3730 && <nl> +		serial->interface->cur_altsetting->desc.bInterfaceClass != USB_CLASS_CDC_DATA) <nl> +		return -ENODEV; <nl> + <nl>  	data = serial->private = kzalloc(sizeof(struct usb_wwan_intf_private), GFP_KERNEL); <nl>   <nl>  	if (!data)
@@ -446,7 +446,7 @@ int mthca_init_db_tab(struct mthca_dev *dev) <nl>   <nl>  	init_MUTEX(&dev->db_tab->mutex); <nl>   <nl> -	dev->db_tab->npages     = dev->uar_table.uarc_size / PAGE_SIZE; <nl> +	dev->db_tab->npages     = dev->uar_table.uarc_size / 4096; <nl>  	dev->db_tab->max_group1 = 0; <nl>  	dev->db_tab->min_group2 = dev->db_tab->npages - 1; <nl>  
@@ -187,7 +187,7 @@ void ieee80211_txb_free(struct ieee80211_txb *txb) <nl>  } <nl>   <nl>  static struct ieee80211_txb *ieee80211_alloc_txb(int nr_frags, int txb_size, <nl> -						 int gfp_mask) <nl> +						 unsigned int gfp_mask) <nl>  { <nl>  	struct ieee80211_txb *txb; <nl>  	int i;
@@ -389,6 +389,7 @@ static void ppp_cp_parse_cr(struct net_device *dev, u16 pid, u8 id, <nl>  	for (opt = data; len; len -= opt[1], opt += opt[1]) { <nl>  		if (len < 2 || len < opt[1]) { <nl>  			dev->stats.rx_errors++; <nl> +			kfree(out); <nl>  			return; /* bad packet, drop silently */ <nl>  		} <nl>  
@@ -866,6 +866,7 @@ EXPORT_SYMBOL_GPL(tda18271_attach); <nl>  MODULE_DESCRIPTION("NXP TDA18271HD analog / digital tuner driver"); <nl>  MODULE_AUTHOR("Michael Krufky <mkrufky@linuxtv.org>"); <nl>  MODULE_LICENSE("GPL"); <nl> +MODULE_VERSION("0.1"); <nl>   <nl>  /* <nl>   * Overrides for Emacs so that we follow Linus's tabbing style.
@@ -1337,8 +1337,6 @@ static int pm860x_probe(struct snd_soc_codec *codec) <nl>  		} <nl>  	} <nl>   <nl> -	pm860x_set_bias_level(codec, SND_SOC_BIAS_STANDBY); <nl> - <nl>  	return 0; <nl>   <nl>  out: <nl> @@ -1354,7 +1352,6 @@ static int pm860x_remove(struct snd_soc_codec *codec) <nl>   <nl>  	for (i = 3; i >= 0; i--) <nl>  		free_irq(pm860x->irq[i], pm860x); <nl> -	pm860x_set_bias_level(codec, SND_SOC_BIAS_OFF); <nl>  	return 0; <nl>  } <nl>  
@@ -1267,7 +1267,7 @@ static void terminate_walk(struct nameidata *nd) <nl>   * so we keep a cache of "no, this doesn't need follow_link" <nl>   * for the common case. <nl>   */ <nl> -static inline int do_follow_link(struct inode *inode, int follow) <nl> +static inline int should_follow_link(struct inode *inode, int follow) <nl>  { <nl>  	if (unlikely(!(inode->i_opflags & IOP_NOFOLLOW))) { <nl>  		if (likely(inode->i_op->follow_link)) <nl> @@ -1303,7 +1303,7 @@ static inline int walk_component(struct nameidata *nd, struct path *path, <nl>  		terminate_walk(nd); <nl>  		return -ENOENT; <nl>  	} <nl> -	if (do_follow_link(inode, follow)) { <nl> +	if (should_follow_link(inode, follow)) { <nl>  		if (nd->flags & LOOKUP_RCU) { <nl>  			if (unlikely(unlazy_walk(nd, path->dentry))) { <nl>  				terminate_walk(nd);
@@ -141,9 +141,8 @@ gk20a_pllg_calc_rate(struct gk20a_clk *clk) <nl>   <nl>  	rate = clk->parent_rate * clk->n; <nl>  	divider = clk->m * pl_to_div[clk->pl]; <nl> -	do_div(rate, divider); <nl>   <nl> -	return rate / 2; <nl> +	return rate / divider / 2; <nl>  } <nl>   <nl>  static int
@@ -2092,6 +2092,11 @@ static int __smiapp_sel_supported(struct v4l2_subdev *subdev, <nl>  		    == SMIAPP_DIGITAL_CROP_CAPABILITY_INPUT_CROP) <nl>  			return 0; <nl>  		return -EINVAL; <nl> +	case V4L2_SEL_TGT_NATIVE_SIZE: <nl> +		if (ssd == sensor->pixel_array <nl> +		    && sel->pad == SMIAPP_PA_PAD_SRC) <nl> +			return 0; <nl> +		return -EINVAL; <nl>  	case V4L2_SEL_TGT_COMPOSE: <nl>  	case V4L2_SEL_TGT_COMPOSE_BOUNDS: <nl>  		if (sel->pad == ssd->source_pad) <nl> @@ -2190,6 +2195,7 @@ static int __smiapp_get_selection(struct v4l2_subdev *subdev, <nl>   <nl>  	switch (sel->target) { <nl>  	case V4L2_SEL_TGT_CROP_BOUNDS: <nl> +	case V4L2_SEL_TGT_NATIVE_SIZE: <nl>  		if (ssd == sensor->pixel_array) { <nl>  			sel->r.left = sel->r.top = 0; <nl>  			sel->r.width =
@@ -498,6 +498,11 @@ struct map *machine__new_module(struct machine *machine, u64 start, <nl>  	if (kmod_path__parse_name(&m, filename)) <nl>  		return NULL; <nl>   <nl> +	map = map_groups__find_by_name(&machine->kmaps, MAP__FUNCTION, <nl> +				       m.name); <nl> +	if (map) <nl> +		goto out; <nl> + <nl>  	dso = machine__module_dso(machine, &m, filename); <nl>  	if (dso == NULL) <nl>  		goto out;
@@ -634,7 +634,7 @@ nouveau_bo_move_flips(struct ttm_buffer_object *bo, bool evict, bool intr, <nl>  	if (ret) <nl>  		goto out; <nl>   <nl> -	ret = nouveau_bo_move_m2mf(bo, true, intr, no_wait, new_mem); <nl> +	ret = nouveau_bo_move_m2mf(bo, evict, intr, no_wait, new_mem); <nl>  	if (ret) <nl>  		goto out; <nl>  
@@ -1717,9 +1717,9 @@ static netdev_tx_t rtl8139_start_xmit (struct sk_buff *skb, <nl>  		if (len < ETH_ZLEN) <nl>  			memset(tp->tx_buf[entry], 0, ETH_ZLEN); <nl>  		skb_copy_and_csum_dev(skb, tp->tx_buf[entry]); <nl> -		dev_kfree_skb(skb); <nl> +		dev_kfree_skb_any(skb); <nl>  	} else { <nl> -		dev_kfree_skb(skb); <nl> +		dev_kfree_skb_any(skb); <nl>  		dev->stats.tx_dropped++; <nl>  		return NETDEV_TX_OK; <nl>  	}
@@ -1911,6 +1911,9 @@ static int patch_stac922x(struct hda_codec *codec) <nl>  		 */ <nl>  		printk(KERN_INFO "hda_codec: STAC922x, Apple subsys_id=%x\n", codec->subsystem_id); <nl>  		switch (codec->subsystem_id) { <nl> +		case 0x106b0a00: /* MacBook First generatoin */ <nl> +			spec->board_config = STAC_MACBOOK; <nl> +			break; <nl>  		case 0x106b0200: /* MacBook Pro first generation */ <nl>  			spec->board_config = STAC_MACBOOK_PRO_V1; <nl>  			break;
@@ -327,6 +327,7 @@ intel_crt_load_detect(struct drm_crtc *crtc, struct intel_encoder *intel_encoder <nl>  	if (IS_I9XX(dev)) { <nl>  		uint32_t pipeconf = I915_READ(pipeconf_reg); <nl>  		I915_WRITE(pipeconf_reg, pipeconf | PIPECONF_FORCE_BORDER); <nl> +		POSTING_READ(pipeconf_reg); <nl>  		/* Wait for next Vblank to substitue <nl>  		 * border color for Color info */ <nl>  		intel_wait_for_vblank(dev, pipe);
@@ -212,8 +212,8 @@ static void ibmveth_replenish_buffer_pool(struct ibmveth_adapter *adapter, struc <nl>  			break; <nl>  		} <nl>   <nl> -		free_index = pool->consumer_index++ % pool->size; <nl> -		pool->consumer_index = free_index; <nl> +		free_index = pool->consumer_index; <nl> +		pool->consumer_index = (pool->consumer_index + 1) % pool->size; <nl>  		index = pool->free_map[free_index]; <nl>   <nl>  		ibmveth_assert(index != IBM_VETH_INVALID_MAP); <nl> @@ -329,8 +329,10 @@ static void ibmveth_remove_buffer_from_pool(struct ibmveth_adapter *adapter, u64 <nl>  			 adapter->rx_buff_pool[pool].buff_size, <nl>  			 DMA_FROM_DEVICE); <nl>   <nl> -	free_index = adapter->rx_buff_pool[pool].producer_index++ % adapter->rx_buff_pool[pool].size; <nl> -	adapter->rx_buff_pool[pool].producer_index = free_index; <nl> +	free_index = adapter->rx_buff_pool[pool].producer_index; <nl> +	adapter->rx_buff_pool[pool].producer_index <nl> +		= (adapter->rx_buff_pool[pool].producer_index + 1) <nl> +		% adapter->rx_buff_pool[pool].size; <nl>  	adapter->rx_buff_pool[pool].free_map[free_index] = index; <nl>   <nl>  	mb();
@@ -602,6 +602,10 @@ static int pci_netmos_init(struct pci_dev *dev) <nl>  	/* subdevice 0x00PS means <P> parallel, <S> serial */ <nl>  	unsigned int num_serial = dev->subsystem_device & 0xf; <nl>   <nl> +	if (dev->subsystem_vendor == PCI_VENDOR_ID_IBM && <nl> +			dev->subsystem_device == 0x0299) <nl> +		return 0; <nl> + <nl>  	if (num_serial == 0) <nl>  		return -ENODEV; <nl>  	return num_serial; <nl> @@ -3096,6 +3100,10 @@ static struct pci_device_id serial_pci_tbl[] = { <nl>  		0, <nl>  		pbn_b0_8_115200 }, <nl>   <nl> +	{	PCI_VENDOR_ID_NETMOS, PCI_DEVICE_ID_NETMOS_9835, <nl> +		PCI_VENDOR_ID_IBM, 0x0299, <nl> +		0, 0, pbn_b0_bt_2_115200 }, <nl> + <nl>  	/* <nl>  	 * These entries match devices with class COMMUNICATION_SERIAL, <nl>  	 * COMMUNICATION_MODEM or COMMUNICATION_MULTISERIAL
@@ -332,6 +332,7 @@ static void reset_connection(struct ceph_connection *con) <nl>  		con->out_msg = NULL; <nl>  	} <nl>  	con->in_seq = 0; <nl> +	con->in_seq_acked = 0; <nl>  } <nl>   <nl>  /*
@@ -1464,7 +1464,7 @@ static void bmc150_accel_unregister_triggers(struct bmc150_accel_data *data, <nl>  { <nl>  	int i; <nl>   <nl> -	for (i = from; i >= 0; i++) { <nl> +	for (i = from; i >= 0; i--) { <nl>  		if (data->triggers[i].indio_trig) { <nl>  			iio_trigger_unregister(data->triggers[i].indio_trig); <nl>  			data->triggers[i].indio_trig = NULL;
@@ -1420,9 +1420,10 @@ int esas2r_ioctl_handler(void *hostdata, int cmd, void __user *arg) <nl>   <nl>  		rq = esas2r_alloc_request(a); <nl>  		if (rq == NULL) { <nl> -			up(&a->nvram_semaphore); <nl> -			ioctl->data.prw.code = 0; <nl> -			break; <nl> +			kfree(ioctl); <nl> +			esas2r_log(ESAS2R_LOG_WARN, <nl> +			   "could not allocate an internal request"); <nl> +			return -ENOMEM; <nl>  		} <nl>   <nl>  		code = esas2r_write_params(a, rq,
@@ -666,7 +666,7 @@ static struct dma_chan *of_dma_sirfsoc_xlate(struct of_phandle_args *dma_spec, <nl>  	struct sirfsoc_dma *sdma = ofdma->of_dma_data; <nl>  	unsigned int request = dma_spec->args[0]; <nl>   <nl> -	if (request > SIRFSOC_DMA_CHANNELS) <nl> +	if (request >= SIRFSOC_DMA_CHANNELS) <nl>  		return NULL; <nl>   <nl>  	return dma_get_slave_channel(&sdma->channels[request].chan);
@@ -338,7 +338,7 @@ static void __init of_omap2_apll_setup(struct device_node *node) <nl>  	const char *parent_name; <nl>  	u32 val; <nl>   <nl> -	ad = kzalloc(sizeof(*clk_hw), GFP_KERNEL); <nl> +	ad = kzalloc(sizeof(*ad), GFP_KERNEL); <nl>  	clk_hw = kzalloc(sizeof(*clk_hw), GFP_KERNEL); <nl>  	init = kzalloc(sizeof(*init), GFP_KERNEL); <nl>  
@@ -2844,7 +2844,6 @@ int try_to_free_buffers(struct page *page) <nl>   <nl>  	spin_lock(&mapping->private_lock); <nl>  	ret = drop_buffers(page, &buffers_to_free); <nl> -	spin_unlock(&mapping->private_lock); <nl>   <nl>  	/* <nl>  	 * If the filesystem writes its buffers by hand (eg ext3) <nl> @@ -2855,9 +2854,14 @@ int try_to_free_buffers(struct page *page) <nl>  	 * Also, during truncate, discard_buffer will have marked all <nl>  	 * the page's buffers clean.  We discover that here and clean <nl>  	 * the page also. <nl> +	 * <nl> +	 * private_lock must be held over this entire operation in order <nl> +	 * to synchronise against __set_page_dirty_buffers and prevent the <nl> +	 * dirty bit from being lost. <nl>  	 */ <nl>  	if (ret) <nl>  		cancel_dirty_page(page, PAGE_CACHE_SIZE); <nl> +	spin_unlock(&mapping->private_lock); <nl>  out: <nl>  	if (buffers_to_free) { <nl>  		struct buffer_head *bh = buffers_to_free;
@@ -1782,6 +1782,7 @@ enum { <nl>  	ALC889_FIXUP_IMAC91_VREF, <nl>  	ALC882_FIXUP_INV_DMIC, <nl>  	ALC882_FIXUP_NO_PRIMARY_HP, <nl> +	ALC887_FIXUP_ASUS_BASS, <nl>  }; <nl>   <nl>  static void alc889_fixup_coef(struct hda_codec *codec, <nl> @@ -2105,6 +2106,13 @@ static const struct hda_fixup alc882_fixups[] = { <nl>  		.type = HDA_FIXUP_FUNC, <nl>  		.v.func = alc882_fixup_no_primary_hp, <nl>  	}, <nl> +	[ALC887_FIXUP_ASUS_BASS] = { <nl> +		.type = HDA_FIXUP_PINS, <nl> +		.v.pins = (const struct hda_pintbl[]) { <nl> +			{0x16, 0x99130130}, /* bass speaker */ <nl> +			{} <nl> +		}, <nl> +	}, <nl>  }; <nl>   <nl>  static const struct snd_pci_quirk alc882_fixup_tbl[] = { <nl> @@ -2138,6 +2146,7 @@ static const struct snd_pci_quirk alc882_fixup_tbl[] = { <nl>  	SND_PCI_QUIRK(0x1043, 0x1873, "ASUS W90V", ALC882_FIXUP_ASUS_W90V), <nl>  	SND_PCI_QUIRK(0x1043, 0x1971, "Asus W2JC", ALC882_FIXUP_ASUS_W2JC), <nl>  	SND_PCI_QUIRK(0x1043, 0x835f, "Asus Eee 1601", ALC888_FIXUP_EEE1601), <nl> +	SND_PCI_QUIRK(0x1043, 0x84bc, "ASUS ET2700", ALC887_FIXUP_ASUS_BASS), <nl>  	SND_PCI_QUIRK(0x104d, 0x9047, "Sony Vaio TT", ALC889_FIXUP_VAIO_TT), <nl>  	SND_PCI_QUIRK(0x104d, 0x905a, "Sony Vaio Z", ALC882_FIXUP_NO_PRIMARY_HP), <nl>  	SND_PCI_QUIRK(0x104d, 0x9043, "Sony Vaio VGC-LN51JGB", ALC882_FIXUP_NO_PRIMARY_HP),
@@ -589,13 +589,17 @@ static netdev_tx_t bt_xmit(struct sk_buff *skb, struct net_device *netdev) <nl>  	int err = 0; <nl>  	bdaddr_t addr; <nl>  	u8 addr_type; <nl> +	struct sk_buff *tmpskb; <nl>   <nl>  	/* We must take a copy of the skb before we modify/replace the ipv6 <nl>  	 * header as the header could be used elsewhere <nl>  	 */ <nl> -	skb = skb_unshare(skb, GFP_ATOMIC); <nl> -	if (!skb) <nl> +	tmpskb = skb_unshare(skb, GFP_ATOMIC); <nl> +	if (!tmpskb) { <nl> +		kfree_skb(skb); <nl>  		return NET_XMIT_DROP; <nl> +	} <nl> +	skb = tmpskb; <nl>   <nl>  	/* Return values from setup_header() <nl>  	 *  <0 - error, packet is dropped
@@ -1108,7 +1108,7 @@ int tcp_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg, <nl>  	if (unlikely(tp->repair)) { <nl>  		if (tp->repair_queue == TCP_RECV_QUEUE) { <nl>  			copied = tcp_send_rcvq(sk, msg, size); <nl> -			goto out; <nl> +			goto out_nopush; <nl>  		} <nl>   <nl>  		err = -EINVAL; <nl> @@ -1282,6 +1282,7 @@ wait_for_memory: <nl>  out: <nl>  	if (copied) <nl>  		tcp_push(sk, flags, mss_now, tp->nonagle, size_goal); <nl> +out_nopush: <nl>  	release_sock(sk); <nl>  	return copied + copied_syn; <nl>  
@@ -648,7 +648,7 @@ void em28xx_uninit_isoc(struct em28xx *dev) <nl>   */ <nl>  int em28xx_init_isoc(struct em28xx *dev) <nl>  { <nl> -	/* change interface to 3 which allowes the biggest packet sizes */ <nl> +	/* change interface to 3 which allows the biggest packet sizes */ <nl>  	int i, errCode; <nl>  	const int sb_size = EM28XX_NUM_PACKETS * dev->max_pkt_size; <nl>   <nl> @@ -673,6 +673,7 @@ int em28xx_init_isoc(struct em28xx *dev) <nl>  					("unable to allocate %i bytes for transfer buffer %i\n", <nl>  					 sb_size, i); <nl>  			em28xx_uninit_isoc(dev); <nl> +			usb_free_urb(urb); <nl>  			return -ENOMEM; <nl>  		} <nl>  		memset(dev->transfer_buffer[i], 0, sb_size);
@@ -43,7 +43,7 @@ struct mpc5xxx_can_data { <nl>  			 int *mscan_clksrc); <nl>  }; <nl>   <nl> -#ifdef CONFIG_PPC_MPC5200 <nl> +#ifdef CONFIG_PPC_MPC52xx <nl>  static struct of_device_id __devinitdata mpc52xx_cdm_ids[] = { <nl>  	{ .compatible = "fsl,mpc5200-cdm", }, <nl>  	{} <nl> @@ -84,7 +84,7 @@ static u32 __devinit mpc52xx_can_get_clock(struct of_device *ofdev, <nl>  	/* Determine SYS_XTAL_IN frequency from the clock domain settings */ <nl>  	np_cdm = of_find_matching_node(NULL, mpc52xx_cdm_ids); <nl>  	if (!np_cdm) { <nl> -		dev_err(&of->dev, "can't get clock node!\n"); <nl> +		dev_err(&ofdev->dev, "can't get clock node!\n"); <nl>  		return 0; <nl>  	} <nl>  	cdm = of_iomap(np_cdm, 0); <nl> @@ -101,14 +101,14 @@ static u32 __devinit mpc52xx_can_get_clock(struct of_device *ofdev, <nl>   <nl>  	return freq; <nl>  } <nl> -#else /* !CONFIG_PPC_MPC5200 */ <nl> +#else /* !CONFIG_PPC_MPC52xx */ <nl>  static u32 __devinit mpc52xx_can_get_clock(struct of_device *ofdev, <nl>  					   const char *clock_name, <nl>  					   int *mscan_clksrc) <nl>  { <nl>  	return 0; <nl>  } <nl> -#endif /* CONFIG_PPC_MPC5200 */ <nl> +#endif /* CONFIG_PPC_MPC52xx */ <nl>   <nl>  #ifdef CONFIG_PPC_MPC512x <nl>  struct mpc512x_clockctl {
@@ -62,14 +62,14 @@ void usbhs_pkt_push(struct usbhs_pipe *pipe, struct usbhs_pkt *pkt, <nl>  	struct device *dev = usbhs_priv_to_dev(priv); <nl>  	unsigned long flags; <nl>   <nl> -	/********************  spin lock ********************/ <nl> -	usbhs_lock(priv, flags); <nl> - <nl>  	if (!done) { <nl>  		dev_err(dev, "no done function\n"); <nl>  		return; <nl>  	} <nl>   <nl> +	/********************  spin lock ********************/ <nl> +	usbhs_lock(priv, flags); <nl> + <nl>  	if (!pipe->handler) { <nl>  		dev_err(dev, "no handler function\n"); <nl>  		pipe->handler = &usbhsf_null_handler;
@@ -2076,7 +2076,7 @@ static int cgroup_attach_proc(struct cgroup *cgrp, struct task_struct *leader) <nl>  	if (!group) <nl>  		return -ENOMEM; <nl>  	/* pre-allocate to guarantee space while iterating in rcu read-side. */ <nl> -	retval = flex_array_prealloc(group, 0, group_size - 1, GFP_KERNEL); <nl> +	retval = flex_array_prealloc(group, 0, group_size, GFP_KERNEL); <nl>  	if (retval) <nl>  		goto out_free_group_list; <nl>  
@@ -220,7 +220,7 @@ int sensor_hub_set_feature(struct hid_sensor_hub_device *hsdev, u32 report_id, <nl>  	if (buffer_size) { <nl>  		for (i = 0; i < buffer_size; ++i) { <nl>  			hid_set_field(report->field[field_index], i, <nl> -				      cpu_to_le32(*buf32)); <nl> +				      (__force __s32)cpu_to_le32(*buf32)); <nl>  			++buf32; <nl>  		} <nl>  	} <nl> @@ -228,7 +228,7 @@ int sensor_hub_set_feature(struct hid_sensor_hub_device *hsdev, u32 report_id, <nl>  		value = 0; <nl>  		memcpy(&value, (u8 *)buf32, remaining_bytes); <nl>  		hid_set_field(report->field[field_index], i, <nl> -			      cpu_to_le32(value)); <nl> +			      (__force __s32)cpu_to_le32(value)); <nl>  	} <nl>  	hid_hw_request(hsdev->hdev, report, HID_REQ_SET_REPORT); <nl>  	hid_hw_wait(hsdev->hdev);
@@ -616,7 +616,8 @@ batadv_purge_outstanding_packets(struct batadv_priv *bat_priv, <nl>  		 * we delete only packets belonging to the given interface <nl>  		 */ <nl>  		if ((hard_iface) && <nl> -		    (forw_packet->if_incoming != hard_iface)) <nl> +		    (forw_packet->if_incoming != hard_iface) && <nl> +		    (forw_packet->if_outgoing != hard_iface)) <nl>  			continue; <nl>   <nl>  		spin_unlock_bh(&bat_priv->forw_bcast_list_lock);
@@ -111,6 +111,7 @@ struct Qdisc_ops <nl>   <nl>  	int 			(*enqueue)(struct sk_buff *, struct Qdisc *); <nl>  	struct sk_buff *	(*dequeue)(struct Qdisc *); <nl> +	struct sk_buff *	(*peek)(struct Qdisc *); <nl>  	int 			(*requeue)(struct sk_buff *, struct Qdisc *); <nl>  	unsigned int		(*drop)(struct Qdisc *); <nl>  
@@ -345,8 +345,11 @@ intel_find_pll_ironlake_dp(const intel_limit_t *, struct drm_crtc *crtc, <nl>  static inline u32 /* units of 100MHz */ <nl>  intel_fdi_link_freq(struct drm_device *dev) <nl>  { <nl> -	struct drm_i915_private *dev_priv = dev->dev_private; <nl> -	return (I915_READ(FDI_PLL_BIOS_0) & FDI_PLL_FB_CLOCK_MASK) + 2; <nl> +	if (IS_GEN5(dev)) { <nl> +		struct drm_i915_private *dev_priv = dev->dev_private; <nl> +		return (I915_READ(FDI_PLL_BIOS_0) & FDI_PLL_FB_CLOCK_MASK) + 2; <nl> +	} else <nl> +		return 27; <nl>  } <nl>   <nl>  static const intel_limit_t intel_limits_i8xx_dvo = {
@@ -845,6 +845,9 @@ static int __init ubi_mtd_param_parse(const char *val, struct kernel_param *kp) <nl>  	char *pbuf = &buf[0]; <nl>  	char *tokens[3] = {NULL, NULL, NULL}; <nl>   <nl> +	if (!val) <nl> +		return -EINVAL; <nl> + <nl>  	if (mtd_devs == UBI_MAX_DEVICES) { <nl>  		printk("UBI error: too many parameters, max. is %d\n", <nl>  		       UBI_MAX_DEVICES);
@@ -346,7 +346,9 @@ int ocfs2_cluster_connect(const char *stack_name, <nl>   <nl>  	strlcpy(new_conn->cc_name, group, GROUP_NAME_MAX + 1); <nl>  	new_conn->cc_namelen = grouplen; <nl> -	strlcpy(new_conn->cc_cluster_name, cluster_name, CLUSTER_NAME_MAX + 1); <nl> +	if (cluster_name_len) <nl> +		strlcpy(new_conn->cc_cluster_name, cluster_name, <nl> +			CLUSTER_NAME_MAX + 1); <nl>  	new_conn->cc_cluster_name_len = cluster_name_len; <nl>  	new_conn->cc_recovery_handler = recovery_handler; <nl>  	new_conn->cc_recovery_data = recovery_data;
@@ -2059,6 +2059,10 @@ static int ath6kl_wow_suspend(struct ath6kl *ar, struct cfg80211_wowlan *wow) <nl>  	u8 index = 0; <nl>  	__be32 ips[MAX_IP_ADDRS]; <nl>   <nl> +	/* The FW currently can't support multi-vif WoW properly. */ <nl> +	if (ar->num_vif > 1) <nl> +		return -EIO; <nl> + <nl>  	vif = ath6kl_vif_first(ar); <nl>  	if (!vif) <nl>  		return -EIO; <nl> @@ -3137,6 +3141,10 @@ static int ath6kl_cfg80211_sscan_start(struct wiphy *wiphy, <nl>  	if (vif->sme_state != SME_DISCONNECTED) <nl>  		return -EBUSY; <nl>   <nl> +	/* The FW currently can't support multi-vif WoW properly. */ <nl> +	if (ar->num_vif > 1) <nl> +		return -EIO; <nl> + <nl>  	ath6kl_cfg80211_scan_complete_event(vif, true); <nl>   <nl>  	ret = ath6kl_set_probed_ssids(ar, vif, request->ssids,
@@ -238,7 +238,7 @@ int svc_create_xprt(struct svc_serv *serv, const char *xprt_name, <nl>  		list_add(&newxprt->xpt_list, &serv->sv_permsocks); <nl>  		spin_unlock_bh(&serv->sv_lock); <nl>  		newport = svc_xprt_local_port(newxprt); <nl> -		clear_bit(XPT_BUSY, &newxprt->xpt_flags); <nl> +		svc_xprt_received(newxprt); <nl>  		return newport; <nl>  	} <nl>   err:
@@ -2086,6 +2086,10 @@ static int gfar_start_xmit(struct sk_buff *skb, struct net_device *dev) <nl>  			kfree_skb(skb); <nl>  			return NETDEV_TX_OK; <nl>  		} <nl> + <nl> +		/* Steal sock reference for processing TX time stamps */ <nl> +		swap(skb_new->sk, skb->sk); <nl> +		swap(skb_new->destructor, skb->destructor); <nl>  		kfree_skb(skb); <nl>  		skb = skb_new; <nl>  	}
@@ -223,7 +223,7 @@ static void untag_chunk(struct node *p) <nl>  { <nl>  	struct audit_chunk *chunk = find_chunk(p); <nl>  	struct fsnotify_mark *entry = &chunk->mark; <nl> -	struct audit_chunk *new; <nl> +	struct audit_chunk *new = NULL; <nl>  	struct audit_tree *owner; <nl>  	int size = chunk->count - 1; <nl>  	int i, j; <nl> @@ -232,9 +232,14 @@ static void untag_chunk(struct node *p) <nl>   <nl>  	spin_unlock(&hash_lock); <nl>   <nl> +	if (size) <nl> +		new = alloc_chunk(size); <nl> + <nl>  	spin_lock(&entry->lock); <nl>  	if (chunk->dead || !entry->i.inode) { <nl>  		spin_unlock(&entry->lock); <nl> +		if (new) <nl> +			free_chunk(new); <nl>  		goto out; <nl>  	} <nl>   <nl> @@ -255,9 +260,9 @@ static void untag_chunk(struct node *p) <nl>  		goto out; <nl>  	} <nl>   <nl> -	new = alloc_chunk(size); <nl>  	if (!new) <nl>  		goto Fallback; <nl> + <nl>  	fsnotify_duplicate_mark(&new->mark, entry); <nl>  	if (fsnotify_add_mark(&new->mark, new->mark.group, new->mark.i.inode, NULL, 1)) { <nl>  		free_chunk(new);
@@ -235,6 +235,10 @@ static int vq_memory_access_ok(void __user *log_base, struct vhost_memory *mem, <nl>  			       int log_all) <nl>  { <nl>  	int i; <nl> + <nl> +        if (!mem) <nl> +                return 0; <nl> + <nl>  	for (i = 0; i < mem->nregions; ++i) { <nl>  		struct vhost_memory_region *m = mem->regions + i; <nl>  		unsigned long a = m->userspace_addr;
@@ -360,7 +360,7 @@ static struct qdisc_size_table *qdisc_get_stab(struct nlattr *opt) <nl>  		tsize = nla_len(tb[TCA_STAB_DATA]) / sizeof(u16); <nl>  	} <nl>   <nl> -	if (!s || tsize != s->tsize || (!tab && tsize > 0)) <nl> +	if (tsize != s->tsize || (!tab && tsize > 0)) <nl>  		return ERR_PTR(-EINVAL); <nl>   <nl>  	spin_lock(&qdisc_stab_lock);
@@ -380,7 +380,7 @@ asmlinkage long sys_ptrace(long request, long pid, unsigned long addr, long data <nl>  			break; <nl>   <nl>  		switch (addr) {  <nl> -		case 0 ... sizeof(struct user_regs_struct): <nl> +		case 0 ... sizeof(struct user_regs_struct) - sizeof(long): <nl>  			tmp = getreg(child, addr); <nl>  			break; <nl>  		case offsetof(struct user, u_debugreg[0]): <nl> @@ -425,7 +425,7 @@ asmlinkage long sys_ptrace(long request, long pid, unsigned long addr, long data <nl>  			break; <nl>   <nl>  		switch (addr) {  <nl> -		case 0 ... sizeof(struct user_regs_struct):  <nl> +		case 0 ... sizeof(struct user_regs_struct) - sizeof(long): <nl>  			ret = putreg(child, addr, data); <nl>  			break; <nl>  		/* Disallows to set a breakpoint into the vsyscall */
@@ -422,7 +422,7 @@ static int twl4030_kp_probe(struct platform_device *pdev) <nl>  err3: <nl>  	/* mask all events - we don't care about the result */ <nl>  	(void) twl4030_kpwrite_u8(kp, 0xff, KEYP_IMR1); <nl> -	free_irq(kp->irq, NULL); <nl> +	free_irq(kp->irq, kp); <nl>  err2: <nl>  	input_unregister_device(input); <nl>  	input = NULL;
@@ -4513,7 +4513,13 @@ again: <nl>  		space_info->flush = 1; <nl>  	} else if (!ret && space_info->flags & BTRFS_BLOCK_GROUP_METADATA) { <nl>  		used += orig_bytes; <nl> -		if (need_do_async_reclaim(space_info, root->fs_info, used) && <nl> +		/* <nl> +		 * We will do the space reservation dance during log replay, <nl> +		 * which means we won't have fs_info->fs_root set, so don't do <nl> +		 * the async reclaim as we will panic. <nl> +		 */ <nl> +		if (!root->fs_info->log_root_recovering && <nl> +		    need_do_async_reclaim(space_info, root->fs_info, used) && <nl>  		    !work_busy(&root->fs_info->async_reclaim_work)) <nl>  			queue_work(system_unbound_wq, <nl>  				   &root->fs_info->async_reclaim_work);
@@ -265,7 +265,8 @@ static void xlr_make_tx_desc(struct nlm_fmn_msg *msg, unsigned long addr, <nl>  		((u64)fr_stn_id << 54)	|	/* Free back id */ <nl>  		(u64)0 << 40		|	/* Set len to 0 */ <nl>  		((u64)physkb  & 0xffffffff));	/* 32bit address */ <nl> -	msg->msg2 = msg->msg3 = 0; <nl> +	msg->msg2 = 0; <nl> +	msg->msg3 = 0; <nl>  } <nl>   <nl>  static void __maybe_unused xlr_wakeup_queue(unsigned long dev)
@@ -512,6 +512,12 @@ int iio_str_to_fixpoint(const char *str, int fract_mult, <nl>  	int i = 0, f = 0; <nl>  	bool integer_part = true, negative = false; <nl>   <nl> +	if (fract_mult == 0) { <nl> +		*fract = 0; <nl> + <nl> +		return kstrtoint(str, 0, integer); <nl> +	} <nl> + <nl>  	if (str[0] == '-') { <nl>  		negative = true; <nl>  		str++; <nl> @@ -571,6 +577,9 @@ static ssize_t iio_write_channel_info(struct device *dev, <nl>  	if (indio_dev->info->write_raw_get_fmt) <nl>  		switch (indio_dev->info->write_raw_get_fmt(indio_dev, <nl>  			this_attr->c, this_attr->address)) { <nl> +		case IIO_VAL_INT: <nl> +			fract_mult = 0; <nl> +			break; <nl>  		case IIO_VAL_INT_PLUS_MICRO: <nl>  			fract_mult = 100000; <nl>  			break;
@@ -356,7 +356,7 @@ static int rtas_excl_open(struct inode *inode, struct file *file) <nl>   <nl>  	/* Enforce exclusive open with use count of PDE */ <nl>  	spin_lock(&flash_file_open_lock); <nl> -	if (atomic_read(&dp->count) > 1) { <nl> +	if (atomic_read(&dp->count) > 2) { <nl>  		spin_unlock(&flash_file_open_lock); <nl>  		return -EBUSY; <nl>  	}
@@ -978,6 +978,8 @@ static void nvme_cancel_ios(struct nvme_queue *nvmeq, bool timeout) <nl>   <nl>  		if (timeout && !time_after(now, info[cmdid].timeout)) <nl>  			continue; <nl> +		if (info[cmdid].ctx == CMD_CTX_CANCELLED) <nl> +			continue; <nl>  		dev_warn(nvmeq->q_dmadev, "Cancelling I/O %d\n", cmdid); <nl>  		ctx = cancel_cmdid(nvmeq, cmdid, &fn); <nl>  		fn(nvmeq->dev, ctx, &cqe);
@@ -235,6 +235,7 @@ nouveau_pm_profile_set(struct drm_device *dev, const char *profile) <nl>  		return -EPERM; <nl>   <nl>  	strncpy(string, profile, sizeof(string)); <nl> +	string[sizeof(string) - 1] = 0; <nl>  	if ((ptr = strchr(string, '\n'))) <nl>  		*ptr = '\0'; <nl>  
@@ -1533,7 +1533,6 @@ static void fix_read_error(conf_t *conf, mddev_t *mddev, r10bio_t *r10_bio) <nl>  			    test_bit(In_sync, &rdev->flags)) { <nl>  				atomic_inc(&rdev->nr_pending); <nl>  				rcu_read_unlock(); <nl> -				atomic_add(s, &rdev->corrected_errors); <nl>  				if (sync_page_io(rdev, <nl>  						 r10_bio->devs[sl].addr + <nl>  						 sect, <nl> @@ -1598,6 +1597,7 @@ static void fix_read_error(conf_t *conf, mddev_t *mddev, r10bio_t *r10_bio) <nl>  					       (unsigned long long)( <nl>  						       sect + rdev->data_offset), <nl>  					       bdevname(rdev->bdev, b)); <nl> +					atomic_add(s, &rdev->corrected_errors); <nl>  				} <nl>   <nl>  				rdev_dec_pending(rdev, mddev);
@@ -419,7 +419,7 @@ struct hda_bus { <nl>   <nl>  	/* codec linked list */ <nl>  	struct list_head codec_list; <nl> -	struct hda_codec *caddr_tbl[HDA_MAX_CODEC_ADDRESS]; /* caddr -> codec */ <nl> +	struct hda_codec *caddr_tbl[HDA_MAX_CODEC_ADDRESS + 1]; /* caddr -> codec */ <nl>   <nl>  	struct semaphore cmd_mutex; <nl>  
@@ -722,6 +722,8 @@ static int mlx5e_create_main_flow_table(struct mlx5e_priv *priv) <nl>  	u8 *dmac; <nl>   <nl>  	g = kcalloc(9, sizeof(*g), GFP_KERNEL); <nl> +	if (!g) <nl> +		return -ENOMEM; <nl>   <nl>  	g[0].log_sz = 2; <nl>  	g[0].match_criteria_enable = MLX5_MATCH_OUTER_HEADERS;
@@ -379,7 +379,11 @@ static int perl_start_script(const char *script, int argc, const char **argv) <nl>  		goto error; <nl>  	} <nl>   <nl> -	perl_run(my_perl); <nl> +	if (perl_run(my_perl)) { <nl> +		err = -1; <nl> +		goto error; <nl> +	} <nl> + <nl>  	if (SvTRUE(ERRSV)) { <nl>  		err = -1; <nl>  		goto error;
@@ -4772,8 +4772,10 @@ int pci_get_new_domain_nr(void) <nl>  void pci_bus_assign_domain_nr(struct pci_bus *bus, struct device *parent) <nl>  { <nl>  	static int use_dt_domains = -1; <nl> -	int domain = of_get_pci_domain_nr(parent->of_node); <nl> +	int domain = -1; <nl>   <nl> +	if (parent) <nl> +		domain = of_get_pci_domain_nr(parent->of_node); <nl>  	/* <nl>  	 * Check DT domain and use_dt_domains values. <nl>  	 *
@@ -294,6 +294,8 @@ static void __save_error_info(struct super_block *sb, const char *func, <nl>  	struct ext4_super_block *es = EXT4_SB(sb)->s_es; <nl>   <nl>  	EXT4_SB(sb)->s_mount_state |= EXT4_ERROR_FS; <nl> +	if (bdev_read_only(sb->s_bdev)) <nl> +		return; <nl>  	es->s_state |= cpu_to_le16(EXT4_ERROR_FS); <nl>  	es->s_last_error_time = cpu_to_le32(get_seconds()); <nl>  	strncpy(es->s_last_error_func, func, sizeof(es->s_last_error_func));
@@ -1033,11 +1033,12 @@ static void iwl_irq_tasklet_legacy(struct iwl_priv *priv) <nl>  		handled |= (CSR_INT_BIT_FH_RX | CSR_INT_BIT_SW_RX); <nl>  	} <nl>   <nl> +	/* This "Tx" DMA channel is used only for loading uCode */ <nl>  	if (inta & CSR_INT_BIT_FH_TX) { <nl> -		IWL_DEBUG_ISR(priv, "Tx interrupt\n"); <nl> +		IWL_DEBUG_ISR(priv, "uCode load interrupt\n"); <nl>  		priv->isr_stats.tx++; <nl>  		handled |= CSR_INT_BIT_FH_TX; <nl> -		/* FH finished to write, send event */ <nl> +		/* Wake up uCode load routine, now that load is complete */ <nl>  		priv->ucode_write_complete = 1; <nl>  		wake_up_interruptible(&priv->wait_command_queue); <nl>  	} <nl> @@ -1234,12 +1235,13 @@ static void iwl_irq_tasklet(struct iwl_priv *priv) <nl>  		iwl_leds_background(priv); <nl>  	} <nl>   <nl> +	/* This "Tx" DMA channel is used only for loading uCode */ <nl>  	if (inta & CSR_INT_BIT_FH_TX) { <nl>  		iwl_write32(priv, CSR_FH_INT_STATUS, CSR49_FH_INT_TX_MASK); <nl> -		IWL_DEBUG_ISR(priv, "Tx interrupt\n"); <nl> +		IWL_DEBUG_ISR(priv, "uCode load interrupt\n"); <nl>  		priv->isr_stats.tx++; <nl>  		handled |= CSR_INT_BIT_FH_TX; <nl> -		/* FH finished to write, send event */ <nl> +		/* Wake up uCode load routine, now that load is complete */ <nl>  		priv->ucode_write_complete = 1; <nl>  		wake_up_interruptible(&priv->wait_command_queue); <nl>  	}
@@ -1108,9 +1108,9 @@ void gfs2_inplace_release(struct gfs2_inode *ip) <nl>  { <nl>  	struct gfs2_blkreserv *rs = ip->i_res; <nl>   <nl> -	gfs2_blkrsv_put(ip); <nl>  	if (rs->rs_rgd_gh.gh_gl) <nl>  		gfs2_glock_dq_uninit(&rs->rs_rgd_gh); <nl> +	gfs2_blkrsv_put(ip); <nl>  } <nl>   <nl>  /**
@@ -2489,6 +2489,10 @@ static int atomic_open(struct nameidata *nd, struct dentry *dentry, <nl>  			dput(dentry); <nl>  			dentry = file->f_path.dentry; <nl>  		} <nl> +		if (create_error && dentry->d_inode == NULL) { <nl> +			error = create_error; <nl> +			goto out; <nl> +		} <nl>  		goto looked_up; <nl>  	} <nl>  
@@ -742,7 +742,7 @@ fail: <nl>  	kvm_unregister_irq_mask_notifier(kvm, 0, &pit->mask_notifier); <nl>  	kvm_unregister_irq_ack_notifier(kvm, &pit_state->irq_ack_notifier); <nl>  	kvm_free_irq_source_id(kvm, pit->irq_source_id); <nl> - <nl> +	destroy_workqueue(pit->wq); <nl>  	kfree(pit); <nl>  	return NULL; <nl>  }
@@ -526,7 +526,7 @@ static int imx1_pinctrl_parse_functions(struct device_node *np, <nl>  	/* Initialise function */ <nl>  	func->name = np->name; <nl>  	func->num_groups = of_get_child_count(np); <nl> -	if (func->num_groups <= 0) <nl> +	if (func->num_groups == 0) <nl>  		return -EINVAL; <nl>   <nl>  	func->groups = devm_kzalloc(info->dev,
@@ -190,6 +190,10 @@ store_dh_state(struct device *dev, struct device_attribute *attr, <nl>  	struct scsi_device_handler *scsi_dh; <nl>  	int err = -EINVAL; <nl>   <nl> +	if (sdev->sdev_state == SDEV_CANCEL || <nl> +	    sdev->sdev_state == SDEV_DEL) <nl> +		return -ENODEV; <nl> + <nl>  	if (!sdev->scsi_dh_data) { <nl>  		/* <nl>  		 * Attach to a device handler
@@ -1467,8 +1467,9 @@ int __pm_genpd_add_device(struct generic_pm_domain *genpd, struct device *dev, <nl>  		goto out; <nl>  	} <nl>   <nl> -	if (genpd->attach_dev) <nl> -		genpd->attach_dev(genpd, dev); <nl> +	ret = genpd->attach_dev ? genpd->attach_dev(genpd, dev) : 0; <nl> +	if (ret) <nl> +		goto out; <nl>   <nl>  	genpd->device_count++; <nl>  	genpd->max_off_time_changed = true;
@@ -427,6 +427,9 @@ void tveeprom_hauppauge_analog(struct i2c_client *c, struct tveeprom *tvee, <nl>  	const char *t_fmt_name2[8] = { " none", "", "", "", "", "", "", "" }; <nl>   <nl>  	memset(tvee, 0, sizeof(*tvee)); <nl> +	tvee->tuner_type = TUNER_ABSENT; <nl> +	tvee->tuner2_type = TUNER_ABSENT; <nl> + <nl>  	done = len = beenhere = 0; <nl>   <nl>  	/* Different eeprom start offsets for em28xx, cx2388x and cx23418 */
@@ -576,7 +576,6 @@ int radix_tree_tag_get(struct radix_tree_root *root, <nl>  { <nl>  	unsigned int height, shift; <nl>  	struct radix_tree_node *node; <nl> -	int saw_unset_tag = 0; <nl>   <nl>  	/* check the root's tag bit */ <nl>  	if (!root_tag_get(root, tag)) <nl> @@ -603,15 +602,10 @@ int radix_tree_tag_get(struct radix_tree_root *root, <nl>  			return 0; <nl>   <nl>  		offset = (index >> shift) & RADIX_TREE_MAP_MASK; <nl> - <nl> -		/* <nl> -		 * This is just a debug check.  Later, we can bale as soon as <nl> -		 * we see an unset tag. <nl> -		 */ <nl>  		if (!tag_get(node, tag, offset)) <nl> -			saw_unset_tag = 1; <nl> +			return 0; <nl>  		if (height == 1) <nl> -			return !!tag_get(node, tag, offset); <nl> +			return 1; <nl>  		node = rcu_dereference_raw(node->slots[offset]); <nl>  		shift -= RADIX_TREE_MAP_SHIFT; <nl>  		height--;
@@ -914,8 +914,9 @@ static void storvsc_handle_error(struct vmscsi_request *vm_srb, <nl>  		do_work = true; <nl>  		process_err_fn = storvsc_remove_lun; <nl>  		break; <nl> -	case (SRB_STATUS_ABORTED | SRB_STATUS_AUTOSENSE_VALID): <nl> -		if ((asc == 0x2a) && (ascq == 0x9)) { <nl> +	case SRB_STATUS_ABORTED: <nl> +		if (vm_srb->srb_status & SRB_STATUS_AUTOSENSE_VALID && <nl> +		    (asc == 0x2a) && (ascq == 0x9)) { <nl>  			do_work = true; <nl>  			process_err_fn = storvsc_device_scan; <nl>  			/*
@@ -8970,6 +8970,7 @@ static void thinkpad_acpi_module_exit(void) <nl>  	kfree(thinkpad_id.bios_version_str); <nl>  	kfree(thinkpad_id.ec_version_str); <nl>  	kfree(thinkpad_id.model_str); <nl> +	kfree(thinkpad_id.nummodel_str); <nl>  } <nl>   <nl>  
@@ -3464,7 +3464,7 @@ static int nl80211_trigger_scan(struct sk_buff *skb, struct genl_info *info) <nl>  				    tmp) { <nl>  			enum ieee80211_band band = nla_type(attr); <nl>   <nl> -			if (band < 0 || band > IEEE80211_NUM_BANDS) { <nl> +			if (band < 0 || band >= IEEE80211_NUM_BANDS) { <nl>  				err = -EINVAL; <nl>  				goto out_free; <nl>  			}
@@ -485,8 +485,9 @@ static const char *get_input_type(struct hda_gnode *node, unsigned int *pinctl) <nl>  			return "Front Aux"; <nl>  		return "Aux"; <nl>  	case AC_JACK_MIC_IN: <nl> -		if (node->pin_caps & <nl> -		    (AC_PINCAP_VREF_80 << AC_PINCAP_VREF_SHIFT)) <nl> +		if (pinctl && <nl> +		    (node->pin_caps & <nl> +		     (AC_PINCAP_VREF_80 << AC_PINCAP_VREF_SHIFT))) <nl>  			*pinctl |= AC_PINCTL_VREF_80; <nl>  		if ((location & 0x0f) == AC_JACK_LOC_FRONT) <nl>  			return "Front Mic";
@@ -1307,8 +1307,10 @@ mptctl_getiocinfo (unsigned long arg, unsigned int data_size) <nl>  	else <nl>  		karg->adapterType = MPT_IOCTL_INTERFACE_SCSI; <nl>   <nl> -	if (karg->hdr.port > 1) <nl> +	if (karg->hdr.port > 1) { <nl> +		kfree(karg); <nl>  		return -EINVAL; <nl> +	} <nl>  	port = karg->hdr.port; <nl>   <nl>  	karg->port = port;
@@ -3275,11 +3275,9 @@ i915_gem_object_bind_to_vm(struct drm_i915_gem_object *obj, <nl>  	} <nl>   <nl>  search_free: <nl> -	/* FIXME: Some tests are failing when they receive a reloc of 0. To <nl> -	 * prevent this, we simply don't allow the 0th offset. */ <nl>  	ret = drm_mm_insert_node_in_range_generic(&vm->mm, &vma->node, <nl>  						  size, alignment, <nl> -						  obj->cache_level, 1, gtt_max, <nl> +						  obj->cache_level, 0, gtt_max, <nl>  						  DRM_MM_SEARCH_DEFAULT); <nl>  	if (ret) { <nl>  		ret = i915_gem_evict_something(dev, vm, size, alignment,
@@ -3240,7 +3240,7 @@ void intel_disable_gt_powersave(struct drm_device *dev) <nl>  { <nl>  	if (IS_IRONLAKE_M(dev)) <nl>  		ironlake_disable_drps(dev); <nl> -	if (INTEL_INFO(dev)->gen >= 6 && !IS_VALLEYVIEW(dev)) <nl> +	else if (INTEL_INFO(dev)->gen >= 6 && !IS_VALLEYVIEW(dev)) <nl>  		gen6_disable_rps(dev); <nl>  } <nl>   <nl> @@ -3250,9 +3250,7 @@ void intel_enable_gt_powersave(struct drm_device *dev) <nl>  		ironlake_enable_drps(dev); <nl>  		ironlake_enable_rc6(dev); <nl>  		intel_init_emon(dev); <nl> -	} <nl> - <nl> -	if ((IS_GEN6(dev) || IS_GEN7(dev)) && !IS_VALLEYVIEW(dev)) { <nl> +	} else if ((IS_GEN6(dev) || IS_GEN7(dev)) && !IS_VALLEYVIEW(dev)) { <nl>  		gen6_enable_rps(dev); <nl>  		gen6_update_ring_freq(dev); <nl>  	}
@@ -624,14 +624,14 @@ static void gdrom_readdisk_dma(struct work_struct *work) <nl>  		ctrl_outb(1, GDROM_DMA_STATUS_REG); <nl>  		wait_event_interruptible_timeout(request_queue, <nl>  			gd.transfer == 0, GDROM_DEFAULT_TIMEOUT); <nl> -		err = gd.transfer; <nl> +		err = gd.transfer ? -EIO : 0; <nl>  		gd.transfer = 0; <nl>  		gd.pending = 0; <nl>  		/* now seek to take the request spinlock <nl>  		* before handling ending the request */ <nl>  		spin_lock(&gdrom_lock); <nl>  		list_del_init(&req->queuelist); <nl> -		end_dequeued_request(req, 1 - err); <nl> +		__blk_end_request(req, err, blk_rq_bytes(req)); <nl>  	} <nl>  	spin_unlock(&gdrom_lock); <nl>  	kfree(read_command);
@@ -72,3 +72,5 @@ int __devinit of_mtd_parse_partitions(struct device *dev, <nl>  	return nr_parts; <nl>  } <nl>  EXPORT_SYMBOL(of_mtd_parse_partitions); <nl> + <nl> +MODULE_LICENSE("GPL");
@@ -2378,7 +2378,7 @@ int vb2_mmap(struct vb2_queue *q, struct vm_area_struct *vma) <nl>  { <nl>  	unsigned long off = vma->vm_pgoff << PAGE_SHIFT; <nl>  	struct vb2_buffer *vb; <nl> -	unsigned int buffer, plane; <nl> +	unsigned int buffer = 0, plane = 0; <nl>  	int ret; <nl>  	unsigned long length; <nl>  
@@ -173,7 +173,7 @@ static struct sock *run_bpf(struct sock_reuseport *reuse, u16 socks, <nl>   <nl>  	/* temporarily advance data past protocol header */ <nl>  	if (!pskb_pull(skb, hdr_len)) { <nl> -		consume_skb(nskb); <nl> +		kfree_skb(nskb); <nl>  		return NULL; <nl>  	} <nl>  	index = bpf_prog_run_save_cb(prog, skb);
@@ -322,6 +322,10 @@ int wl12xx_allocate_link(struct wl1271 *wl, struct wl12xx_vif *wlvif, u8 *hlid) <nl>  	__set_bit(link, wl->links_map); <nl>  	__set_bit(link, wlvif->links_map); <nl>  	spin_unlock_irqrestore(&wl->wl_lock, flags); <nl> + <nl> +	/* take the last "freed packets" value from the current FW status */ <nl> +	wl->links[link].prev_freed_pkts = <nl> +			wl->fw_status_2->counters.tx_lnk_free_pkts[link]; <nl>  	*hlid = link; <nl>  	return 0; <nl>  }
@@ -847,7 +847,7 @@ static void iso_callback(struct fw_iso_context *context, u32 cycle, <nl>  	struct client *client = data; <nl>  	struct iso_interrupt_event *e; <nl>   <nl> -	e = kzalloc(sizeof(*e) + header_length, GFP_ATOMIC); <nl> +	e = kmalloc(sizeof(*e) + header_length, GFP_ATOMIC); <nl>  	if (e == NULL) <nl>  		return; <nl>  
@@ -3895,6 +3895,8 @@ static void b43legacy_remove(struct ssb_device *dev) <nl>  	cancel_work_sync(&wl->firmware_load); <nl>   <nl>  	B43legacy_WARN_ON(!wl); <nl> +	if (!wldev->fw.ucode) <nl> +		return;			/* NULL if fw never loaded */ <nl>  	if (wl->current_dev == wldev) <nl>  		ieee80211_unregister_hw(wl->hw); <nl>  
@@ -377,7 +377,7 @@ out: <nl>   <nl>  #define FLASH_RESET			0xF0 <nl>   <nl> -#define FLASH_SIZE                      0x200000 <nl> +#define ASD_FLASH_SIZE                  0x200000 <nl>  #define FLASH_DIR_COOKIE                "*** ADAPTEC FLASH DIRECTORY *** " <nl>  #define FLASH_NEXT_ENTRY_OFFS		0x2000 <nl>  #define FLASH_MAX_DIR_ENTRIES		32 <nl> @@ -609,7 +609,7 @@ static int asd_find_flash_dir(struct asd_ha_struct *asd_ha, <nl>  			      struct asd_flash_dir *flash_dir) <nl>  { <nl>  	u32 v; <nl> -	for (v = 0; v < FLASH_SIZE; v += FLASH_NEXT_ENTRY_OFFS) { <nl> +	for (v = 0; v < ASD_FLASH_SIZE; v += FLASH_NEXT_ENTRY_OFFS) { <nl>  		asd_read_flash_seg(asd_ha, flash_dir, v, <nl>  				   sizeof(FLASH_DIR_COOKIE)-1); <nl>  		if (memcmp(flash_dir->cookie, FLASH_DIR_COOKIE,
@@ -1461,6 +1461,15 @@ dasd_eckd_check_characteristics(struct dasd_device *device) <nl>  				"Read device characteristic failed, rc=%d", rc); <nl>  		goto out_err3; <nl>  	} <nl> + <nl> +	if ((device->features & DASD_FEATURE_USERAW) && <nl> +	    !(private->rdc_data.facilities.RT_in_LR)) { <nl> +		dev_err(&device->cdev->dev, "The storage server does not " <nl> +			"support raw-track access\n"); <nl> +		rc = -EINVAL; <nl> +		goto out_err3; <nl> +	} <nl> + <nl>  	/* find the valid cylinder size */ <nl>  	if (private->rdc_data.no_cyl == LV_COMPAT_CYL && <nl>  	    private->rdc_data.long_no_cyl)
@@ -326,6 +326,7 @@ static int ocfs2_truncate_file(struct inode *inode, <nl>  		   (unsigned long long)OCFS2_I(inode)->ip_blkno, <nl>  		   (unsigned long long)new_i_size); <nl>   <nl> +	unmap_mapping_range(inode->i_mapping, new_i_size + PAGE_SIZE - 1, 0, 1); <nl>  	truncate_inode_pages(inode->i_mapping, new_i_size); <nl>   <nl>  	fe = (struct ocfs2_dinode *) di_bh->b_data;
@@ -2404,6 +2404,16 @@ static int nl80211_send_iface(struct sk_buff *msg, u32 portid, u32 seq, int flag <nl>  		} <nl>  	} <nl>   <nl> +	if (rdev->ops->get_tx_power) { <nl> +		int dbm, ret; <nl> + <nl> +		ret = rdev_get_tx_power(rdev, wdev, &dbm); <nl> +		if (ret == 0 && <nl> +		    nla_put_u32(msg, NL80211_ATTR_WIPHY_TX_POWER_LEVEL, <nl> +				DBM_TO_MBM(dbm))) <nl> +			goto nla_put_failure; <nl> +	} <nl> + <nl>  	if (wdev->ssid_len) { <nl>  		if (nla_put(msg, NL80211_ATTR_SSID, wdev->ssid_len, wdev->ssid)) <nl>  			goto nla_put_failure;
@@ -1494,6 +1494,9 @@ pnfs_update_layout(struct inode *ino, <nl>  	if (!pnfs_enabled_sb(NFS_SERVER(ino))) <nl>  		goto out; <nl>   <nl> +	if (iomode == IOMODE_READ && i_size_read(ino) == 0) <nl> +		goto out; <nl> + <nl>  	if (pnfs_within_mdsthreshold(ctx, ino, iomode)) <nl>  		goto out; <nl>  
@@ -569,7 +569,8 @@ retry: <nl>  		list_add_tail(&cap->session_caps, &session->s_caps); <nl>  		session->s_nr_caps++; <nl>  		spin_unlock(&session->s_cap_lock); <nl> -	} <nl> +	} else if (new_cap) <nl> +		ceph_put_cap(mdsc, new_cap); <nl>   <nl>  	if (!ci->i_snap_realm) { <nl>  		/*
@@ -711,8 +711,7 @@ static int snd_emu1010_load_firmware(struct snd_emu10k1 *emu, const char *filena <nl>  static int emu1010_firmware_thread(void *data) <nl>  { <nl>  	struct snd_emu10k1 *emu = data; <nl> -	int tmp, tmp2; <nl> -	int reg; <nl> +	u32 tmp, tmp2, reg; <nl>  	int err; <nl>   <nl>  	for (;;) { <nl> @@ -758,7 +757,7 @@ static int emu1010_firmware_thread(void *data) <nl>  			snd_printk(KERN_INFO "emu1010: Audio Dock Firmware loaded\n"); <nl>  			snd_emu1010_fpga_read(emu, EMU_DOCK_MAJOR_REV, &tmp); <nl>  			snd_emu1010_fpga_read(emu, EMU_DOCK_MINOR_REV, &tmp2); <nl> -			snd_printk(KERN_INFO "Audio Dock ver:%d.%d\n", <nl> +			snd_printk(KERN_INFO "Audio Dock ver: %u.%u\n", <nl>  				   tmp, tmp2); <nl>  			/* Sync clocking between 1010 and Dock */ <nl>  			/* Allow DLL to settle */ <nl> @@ -805,8 +804,7 @@ static int emu1010_firmware_thread(void *data) <nl>  static int snd_emu10k1_emu1010_init(struct snd_emu10k1 *emu) <nl>  { <nl>  	unsigned int i; <nl> -	int tmp, tmp2; <nl> -	int reg; <nl> +	u32 tmp, tmp2, reg; <nl>  	int err; <nl>  	const char *filename = NULL; <nl>   <nl> @@ -888,7 +886,7 @@ static int snd_emu10k1_emu1010_init(struct snd_emu10k1 *emu) <nl>  	snd_printk(KERN_INFO "emu1010: Hana Firmware loaded\n"); <nl>  	snd_emu1010_fpga_read(emu, EMU_HANA_MAJOR_REV, &tmp); <nl>  	snd_emu1010_fpga_read(emu, EMU_HANA_MINOR_REV, &tmp2); <nl> -	snd_printk(KERN_INFO "emu1010: Hana version: %d.%d\n", tmp, tmp2); <nl> +	snd_printk(KERN_INFO "emu1010: Hana version: %u.%u\n", tmp, tmp2); <nl>  	/* Enable 48Volt power to Audio Dock */ <nl>  	snd_emu1010_fpga_write(emu, EMU_HANA_DOCK_PWR, EMU_HANA_DOCK_PWR_ON); <nl>  
@@ -810,11 +810,16 @@ void sctp_assoc_control_transport(struct sctp_association *asoc, <nl>  		break; <nl>   <nl>  	case SCTP_TRANSPORT_DOWN: <nl> -		/* if the transort was never confirmed, do not transition it <nl> -		 * to inactive state. <nl> +		/* If the transport was never confirmed, do not transition it <nl> +		 * to inactive state.  Also, release the cached route since <nl> +		 * there may be a better route next time. <nl>  		 */ <nl>  		if (transport->state != SCTP_UNCONFIRMED) <nl>  			transport->state = SCTP_INACTIVE; <nl> +		else { <nl> +			dst_release(transport->dst); <nl> +			transport->dst = NULL; <nl> +		} <nl>   <nl>  		spc_state = SCTP_ADDR_UNREACHABLE; <nl>  		break;
@@ -573,7 +573,7 @@ void sctp_transport_burst_limited(struct sctp_transport *t) <nl>  	u32 old_cwnd = t->cwnd; <nl>  	u32 max_burst_bytes; <nl>   <nl> -	if (t->burst_limited) <nl> +	if (t->burst_limited || asoc->max_burst == 0) <nl>  		return; <nl>   <nl>  	max_burst_bytes = t->flight_size + (asoc->max_burst * asoc->pathmtu);
@@ -1819,6 +1819,7 @@ static void vmlinux_path__exit(void) <nl>  { <nl>  	while (--vmlinux_path__nr_entries >= 0) <nl>  		zfree(&vmlinux_path[vmlinux_path__nr_entries]); <nl> +	vmlinux_path__nr_entries = 0; <nl>   <nl>  	zfree(&vmlinux_path); <nl>  }
@@ -317,7 +317,7 @@ static const intel_limit_t intel_limits_vlv_dac = { <nl>  	.m1 = { .min = 2, .max = 3 }, <nl>  	.m2 = { .min = 11, .max = 156 }, <nl>  	.p = { .min = 10, .max = 30 }, <nl> -	.p1 = { .min = 1, .max = 3 }, <nl> +	.p1 = { .min = 2, .max = 3 }, <nl>  	.p2 = { .dot_limit = 270000, <nl>  		.p2_slow = 2, .p2_fast = 20 }, <nl>  }; <nl> @@ -330,7 +330,7 @@ static const intel_limit_t intel_limits_vlv_hdmi = { <nl>  	.m1 = { .min = 2, .max = 3 }, <nl>  	.m2 = { .min = 11, .max = 156 }, <nl>  	.p = { .min = 10, .max = 30 }, <nl> -	.p1 = { .min = 2, .max = 3 }, <nl> +	.p1 = { .min = 3, .max = 3 }, <nl>  	.p2 = { .dot_limit = 270000, <nl>  		.p2_slow = 2, .p2_fast = 20 }, <nl>  }; <nl> @@ -688,7 +688,7 @@ vlv_find_best_dpll(const intel_limit_t *limit, struct drm_crtc *crtc, <nl>   <nl>  	/* based on hardware requirement, prefer smaller n to precision */ <nl>  	for (clock.n = limit->n.min; clock.n <= max_n; clock.n++) { <nl> -		for (clock.p1 = limit->p1.max; clock.p1 > limit->p1.min; clock.p1--) { <nl> +		for (clock.p1 = limit->p1.max; clock.p1 >= limit->p1.min; clock.p1--) { <nl>  			for (clock.p2 = limit->p2.p2_fast; clock.p2 > 0; <nl>  			     clock.p2 -= clock.p2 > 10 ? 2 : 1) { <nl>  				clock.p = clock.p1 * clock.p2;
@@ -759,8 +759,9 @@ static struct sk_buff *be_insert_vlan_in_pkt(struct be_adapter *adapter, <nl>   <nl>  	if (vlan_tx_tag_present(skb)) { <nl>  		vlan_tag = be_get_tx_vlan_tag(adapter, skb); <nl> -		__vlan_put_tag(skb, vlan_tag); <nl> -		skb->vlan_tci = 0; <nl> +		skb = __vlan_put_tag(skb, vlan_tag); <nl> +		if (skb) <nl> +			skb->vlan_tci = 0; <nl>  	} <nl>   <nl>  	return skb;
@@ -277,7 +277,9 @@ <nl>  	INTEL_VGA_DEVICE(0x191D, info)  /* WKS GT2 */ <nl>   <nl>  #define INTEL_SKL_GT3_IDS(info) \ <nl> +	INTEL_VGA_DEVICE(0x1923, info), /* ULT GT3 */ \ <nl>  	INTEL_VGA_DEVICE(0x1926, info), /* ULT GT3 */ \ <nl> +	INTEL_VGA_DEVICE(0x1927, info), /* ULT GT3 */ \ <nl>  	INTEL_VGA_DEVICE(0x192B, info), /* Halo GT3 */ \ <nl>  	INTEL_VGA_DEVICE(0x192A, info)  /* SRV GT3 */ <nl>  
@@ -862,7 +862,7 @@ static void mac80211_hwsim_tx_frame_nl(struct ieee80211_hw *hw, <nl>  	if (skb_queue_len(&data->pending) >= MAX_QUEUE) { <nl>  		/* Droping until WARN_QUEUE level */ <nl>  		while (skb_queue_len(&data->pending) >= WARN_QUEUE) <nl> -			skb_dequeue(&data->pending); <nl> +			ieee80211_free_txskb(hw, skb_dequeue(&data->pending)); <nl>  	} <nl>   <nl>  	skb = genlmsg_new(GENLMSG_DEFAULT_SIZE, GFP_ATOMIC); <nl> @@ -921,6 +921,7 @@ static void mac80211_hwsim_tx_frame_nl(struct ieee80211_hw *hw, <nl>   <nl>  nla_put_failure: <nl>  	printk(KERN_DEBUG "mac80211_hwsim: error occurred in %s\n", __func__); <nl> +	ieee80211_free_txskb(hw, my_skb); <nl>  } <nl>   <nl>  static bool hwsim_chans_compat(struct ieee80211_channel *c1,
@@ -722,6 +722,8 @@ static void r600_cs_parser_fini(struct radeon_cs_parser *parser, int error) <nl>  	kfree(parser->relocs); <nl>  	for (i = 0; i < parser->nchunks; i++) { <nl>  		kfree(parser->chunks[i].kdata); <nl> +		kfree(parser->chunks[i].kpage[0]); <nl> +		kfree(parser->chunks[i].kpage[1]); <nl>  	} <nl>  	kfree(parser->chunks); <nl>  	kfree(parser->chunks_array);
@@ -7729,6 +7729,8 @@ int perf_event_init_context(struct task_struct *child, int ctxn) <nl>  	 * swapped under us. <nl>  	 */ <nl>  	parent_ctx = perf_pin_task_context(parent, ctxn); <nl> +	if (!parent_ctx) <nl> +		return 0; <nl>   <nl>  	/* <nl>  	 * No need to check if parent_ctx != NULL here; since we saw
@@ -114,6 +114,7 @@ int snd_soc_codec_set_cache_io(struct snd_soc_codec *codec, <nl>  			       enum snd_soc_control_type control) <nl>  { <nl>  	struct regmap_config config; <nl> +	int ret; <nl>   <nl>  	memset(&config, 0, sizeof(config)); <nl>  	codec->write = hw_write; <nl> @@ -141,6 +142,11 @@ int snd_soc_codec_set_cache_io(struct snd_soc_codec *codec, <nl>  	case SND_SOC_REGMAP: <nl>  		/* Device has made its own regmap arrangements */ <nl>  		codec->using_regmap = true; <nl> + <nl> +		ret = regmap_get_val_bytes(codec->control_data); <nl> +		/* Errors are legitimate for non-integer byte multiples */ <nl> +		if (ret > 0) <nl> +			codec->val_bytes = ret; <nl>  		break; <nl>   <nl>  	default:
@@ -1615,7 +1615,7 @@ static int ath10k_station_assoc(struct ath10k *ar, struct ath10k_vif *arvif, <nl>  		return ret; <nl>  	} <nl>   <nl> -	if (!sta->wme) { <nl> +	if (!sta->wme && !reassoc) { <nl>  		arvif->num_legacy_stations++; <nl>  		ret  = ath10k_recalc_rtscts_prot(arvif); <nl>  		if (ret) {
@@ -427,7 +427,7 @@ int isci_task_lu_reset(struct domain_device *dev, u8 *lun) <nl>  	int ret; <nl>   <nl>  	spin_lock_irqsave(&ihost->scic_lock, flags); <nl> -	idev = isci_lookup_device(dev); <nl> +	idev = isci_get_device(dev->lldd_dev); <nl>  	spin_unlock_irqrestore(&ihost->scic_lock, flags); <nl>   <nl>  	dev_dbg(&ihost->pdev->dev, <nl> @@ -507,7 +507,7 @@ int isci_task_abort_task(struct sas_task *task) <nl>  	if (!(task->task_state_flags & SAS_TASK_STATE_DONE) && <nl>  	    (task->task_state_flags & SAS_TASK_AT_INITIATOR) && <nl>  	    old_request) <nl> -		idev = isci_lookup_device(task->dev); <nl> +		idev = isci_get_device(task->dev->lldd_dev); <nl>   <nl>  	spin_unlock(&task->task_state_lock); <nl>  	spin_unlock_irqrestore(&ihost->scic_lock, flags); <nl> @@ -593,6 +593,9 @@ int isci_task_abort_task(struct sas_task *task) <nl>  					    ISCI_ABORT_TASK_TIMEOUT_MS); <nl>  	} <nl>  out: <nl> +	dev_warn(&ihost->pdev->dev, <nl> +		 "%s: Done; dev = %p, task = %p , old_request == %p\n", <nl> +		 __func__, idev, task, old_request); <nl>  	isci_put_device(idev); <nl>  	return ret; <nl>  }
@@ -1124,6 +1124,7 @@ static int get_info(struct net *net, void __user *user, <nl>  			private = &tmp; <nl>  		} <nl>  #endif <nl> +		memset(&info, 0, sizeof(info)); <nl>  		info.valid_hooks = t->valid_hooks; <nl>  		memcpy(info.hook_entry, private->hook_entry, <nl>  		       sizeof(info.hook_entry));
@@ -680,8 +680,10 @@ static long nvm_ioctl_info(struct file *file, void __user *arg) <nl>  	info->tgtsize = tgt_iter; <nl>  	up_write(&nvm_lock); <nl>   <nl> -	if (copy_to_user(arg, info, sizeof(struct nvm_ioctl_info))) <nl> +	if (copy_to_user(arg, info, sizeof(struct nvm_ioctl_info))) { <nl> +		kfree(info); <nl>  		return -EFAULT; <nl> +	} <nl>   <nl>  	kfree(info); <nl>  	return 0; <nl> @@ -724,8 +726,11 @@ static long nvm_ioctl_get_devices(struct file *file, void __user *arg) <nl>   <nl>  	devices->nr_devices = i; <nl>   <nl> -	if (copy_to_user(arg, devices, sizeof(struct nvm_ioctl_get_devices))) <nl> +	if (copy_to_user(arg, devices, <nl> +			 sizeof(struct nvm_ioctl_get_devices))) { <nl> +		kfree(devices); <nl>  		return -EFAULT; <nl> +	} <nl>   <nl>  	kfree(devices); <nl>  	return 0;
@@ -234,6 +234,13 @@ UNUSUAL_DEV(  0x0421, 0x0495, 0x0370, 0x0370, <nl>  		USB_SC_DEVICE, USB_PR_DEVICE, NULL, <nl>  		US_FL_MAX_SECTORS_64 ), <nl>   <nl> +/* Patch submitted by Victor A. Santos <victoraur.santos@gmail.com> */ <nl> +UNUSUAL_DEV(  0x0421, 0x05af, 0x0742, 0x0742, <nl> +		"Nokia", <nl> +		"305", <nl> +		USB_SC_DEVICE, USB_PR_DEVICE, NULL, <nl> +		US_FL_MAX_SECTORS_64), <nl> + <nl>  /* Patch submitted by Mikhail Zolotaryov <lebon@lebon.org.ua> */ <nl>  UNUSUAL_DEV(  0x0421, 0x06aa, 0x1110, 0x1110, <nl>  		"Nokia",
@@ -1336,6 +1336,12 @@ _xfs_buf_ioapply( <nl>  	int		size; <nl>  	int		i; <nl>   <nl> +	/* <nl> +	 * Make sure we capture only current IO errors rather than stale errors <nl> +	 * left over from previous use of the buffer (e.g. failed readahead). <nl> +	 */ <nl> +	bp->b_error = 0; <nl> + <nl>  	if (bp->b_flags & XBF_WRITE) { <nl>  		if (bp->b_flags & XBF_SYNCIO) <nl>  			rw = WRITE_SYNC;
@@ -1366,6 +1366,7 @@ struct btrfs_root *btrfs_create_tree(struct btrfs_trans_handle *trans, <nl>  fail: <nl>  	if (leaf) { <nl>  		btrfs_tree_unlock(leaf); <nl> +		free_extent_buffer(root->commit_root); <nl>  		free_extent_buffer(leaf); <nl>  	} <nl>  	kfree(root);
@@ -4852,6 +4852,9 @@ static void b43_op_stop(struct ieee80211_hw *hw) <nl>   <nl>  	cancel_work_sync(&(wl->beacon_update_trigger)); <nl>   <nl> +	if (!dev) <nl> +		goto out; <nl> + <nl>  	mutex_lock(&wl->mutex); <nl>  	if (b43_status(dev) >= B43_STAT_STARTED) { <nl>  		dev = b43_wireless_core_stop(dev); <nl> @@ -4863,7 +4866,7 @@ static void b43_op_stop(struct ieee80211_hw *hw) <nl>   <nl>  out_unlock: <nl>  	mutex_unlock(&wl->mutex); <nl> - <nl> +out: <nl>  	cancel_work_sync(&(wl->txpower_adjust_work)); <nl>  } <nl>  
@@ -1325,8 +1325,11 @@ int do_huge_pmd_numa_page(struct mm_struct *mm, struct vm_area_struct *vma, <nl>   <nl>  check_same: <nl>  	spin_lock(&mm->page_table_lock); <nl> -	if (unlikely(!pmd_same(pmd, *pmdp))) <nl> +	if (unlikely(!pmd_same(pmd, *pmdp))) { <nl> +		/* Someone else took our fault */ <nl> +		current_nid = -1; <nl>  		goto out_unlock; <nl> +	} <nl>  clear_pmdnuma: <nl>  	pmd = pmd_mknonnuma(pmd); <nl>  	set_pmd_at(mm, haddr, pmdp, pmd);
@@ -615,7 +615,7 @@ static int filter_ack(struct ieee80211_hw *hw, struct ieee80211_hdr *rx_hdr, <nl>  		struct ieee80211_hdr *tx_hdr; <nl>   <nl>  		tx_hdr = (struct ieee80211_hdr *)skb->data; <nl> -		if (likely(!compare_ether_addr(tx_hdr->addr2, rx_hdr->addr1))) <nl> +		if (likely(!memcmp(tx_hdr->addr2, rx_hdr->addr1, ETH_ALEN))) <nl>  		{ <nl>  			__skb_unlink(skb, q); <nl>  			tx_status(hw, skb, IEEE80211_TX_STAT_ACK, stats->signal, 1);
@@ -336,5 +336,7 @@ __append_chain(struct callchain_node *root, struct ip_callchain *chain, <nl>  void append_chain(struct callchain_node *root, struct ip_callchain *chain, <nl>  		  struct symbol **syms) <nl>  { <nl> +	if (!chain->nr) <nl> +		return; <nl>  	__append_chain_children(root, chain, syms, 0); <nl>  }
@@ -834,9 +834,6 @@ static int nf_tables_newchain(struct sock *nlsk, struct sk_buff *skb, <nl>  	if (IS_ERR(table)) <nl>  		return PTR_ERR(table); <nl>   <nl> -	if (table->use == UINT_MAX) <nl> -		return -EOVERFLOW; <nl> - <nl>  	chain = NULL; <nl>  	name = nla[NFTA_CHAIN_NAME]; <nl>   <nl> @@ -899,6 +896,9 @@ static int nf_tables_newchain(struct sock *nlsk, struct sk_buff *skb, <nl>  		goto notify; <nl>  	} <nl>   <nl> +	if (table->use == UINT_MAX) <nl> +		return -EOVERFLOW; <nl> + <nl>  	if (nla[NFTA_CHAIN_HOOK]) { <nl>  		struct nf_hook_ops *ops; <nl>  		nf_hookfn *hookfn;
@@ -346,7 +346,9 @@ int radeon_ring_alloc(struct radeon_device *rdev, struct radeon_ring *ring, unsi <nl>  		if (ndw < ring->ring_free_dw) { <nl>  			break; <nl>  		} <nl> +		mutex_unlock(&ring->mutex); <nl>  		r = radeon_fence_wait_next(rdev, radeon_ring_index(rdev, ring)); <nl> +		mutex_lock(&ring->mutex); <nl>  		if (r) <nl>  			return r; <nl>  	}
@@ -90,15 +90,15 @@ Dot11d_UpdateCountryIe( <nl>  		pTriple = (PCHNL_TXPOWER_TRIPLE)((u8 *)pTriple + 3); <nl>  	} <nl>  	printk("Channel List:"); <nl> -	for(i=1; i<= MAX_CHANNEL_NUMBER; i++) <nl> -		if(pDot11dInfo->channel_map[i] > 0) <nl> +	for (i = 1; i <= MAX_CHANNEL_NUMBER; i++) <nl> +		if (pDot11dInfo->channel_map[i] > 0) <nl>  			printk(" %d", i); <nl>  	printk("\n"); <nl>   <nl>  	UPDATE_CIE_SRC(dev, pTaddr); <nl>   <nl>  	pDot11dInfo->CountryIeLen = CoutryIeLen; <nl> -	memcpy(pDot11dInfo->CountryIeBuf, pCoutryIe,CoutryIeLen); <nl> +	memcpy(pDot11dInfo->CountryIeBuf, pCoutryIe, CoutryIeLen); <nl>  	pDot11dInfo->State = DOT11D_STATE_LEARNED; <nl>  } <nl>   <nl> @@ -157,7 +157,7 @@ int IsLegalChannel( <nl>  		printk("IsLegalChannel(): Invalid Channel\n"); <nl>  		return 0; <nl>  	} <nl> -	if(pDot11dInfo->channel_map[channel] > 0) <nl> +	if (pDot11dInfo->channel_map[channel] > 0) <nl>  		return 1; <nl>  	return 0; <nl>  } <nl> @@ -183,7 +183,7 @@ int ToLegalChannel( <nl>  		return default_chn; <nl>  	} <nl>   <nl> -	if(pDot11dInfo->channel_map[channel] > 0) <nl> +	if (pDot11dInfo->channel_map[channel] > 0) <nl>  		return channel; <nl>   <nl>  	return default_chn;
@@ -29,6 +29,8 @@ DEFINE_MUTEX(fuse_mutex); <nl>   <nl>  #define FUSE_SUPER_MAGIC 0x65735546 <nl>   <nl> +#define FUSE_DEFAULT_BLKSIZE 512 <nl> + <nl>  struct fuse_mount_data { <nl>  	int fd; <nl>  	unsigned rootmode; <nl> @@ -355,7 +357,7 @@ static int parse_fuse_opt(char *opt, struct fuse_mount_data *d, int is_bdev) <nl>  	char *p; <nl>  	memset(d, 0, sizeof(struct fuse_mount_data)); <nl>  	d->max_read = ~0; <nl> -	d->blksize = 512; <nl> +	d->blksize = FUSE_DEFAULT_BLKSIZE; <nl>   <nl>  	while ((p = strsep(&opt, ",")) != NULL) { <nl>  		int token; <nl> @@ -440,6 +442,9 @@ static int fuse_show_options(struct seq_file *m, struct vfsmount *mnt) <nl>  		seq_puts(m, ",allow_other"); <nl>  	if (fc->max_read != ~0) <nl>  		seq_printf(m, ",max_read=%u", fc->max_read); <nl> +	if (mnt->mnt_sb->s_bdev && <nl> +	    mnt->mnt_sb->s_blocksize != FUSE_DEFAULT_BLKSIZE) <nl> +		seq_printf(m, ",blksize=%lu", mnt->mnt_sb->s_blocksize); <nl>  	return 0; <nl>  } <nl>  
@@ -184,6 +184,7 @@ static int msp430_ir_init(struct budget_ci *budget_ci) <nl>  	dev->input_phys = budget_ci->ir.phys; <nl>  	dev->input_id.bustype = BUS_PCI; <nl>  	dev->input_id.version = 1; <nl> +	dev->scanmask = 0xff; <nl>  	if (saa->pci->subsystem_vendor) { <nl>  		dev->input_id.vendor = saa->pci->subsystem_vendor; <nl>  		dev->input_id.product = saa->pci->subsystem_device;
@@ -40,14 +40,14 @@ struct tracepoint { <nl>  	do {								\ <nl>  		void **it_func;						\ <nl>  									\ <nl> -		rcu_read_lock_sched();					\ <nl> +		rcu_read_lock_sched_notrace();				\ <nl>  		it_func = rcu_dereference((tp)->funcs);			\ <nl>  		if (it_func) {						\ <nl>  			do {						\ <nl>  				((void(*)(proto))(*it_func))(args);	\ <nl>  			} while (*(++it_func));				\ <nl>  		}							\ <nl> -		rcu_read_unlock_sched();				\ <nl> +		rcu_read_unlock_sched_notrace();			\ <nl>  	} while (0) <nl>   <nl>  /*
@@ -1870,7 +1870,6 @@ scsi_reset_provider(struct scsi_device *dev, int flag) <nl>  		rtn = FAILED; <nl>  	} <nl>   <nl> -	scsi_delete_timer(scmd); <nl>  	scsi_next_command(scmd); <nl>  	return rtn; <nl>  }
@@ -1061,7 +1061,7 @@ int i2400m_firmware_check(struct i2400m *i2400m) <nl>  		goto error_bad_major; <nl>  	} <nl>  	result = 0; <nl> -	if (minor < I2400M_HDIv_MINOR_2 && minor > I2400M_HDIv_MINOR) <nl> +	if (minor > I2400M_HDIv_MINOR_2 || minor < I2400M_HDIv_MINOR) <nl>  		dev_warn(dev, "untested minor fw version %u.%u.%u\n", <nl>  			 major, minor, branch); <nl>  	/* Yes, we ignore the branch -- we don't have to track it */
@@ -1582,9 +1582,9 @@ e1000_configure_tx(struct e1000_adapter *adapter) <nl>  	} <nl>   <nl>  	/* Set the default values for the Tx Inter Packet Gap timer */ <nl> - <nl> -	if (hw->media_type == e1000_media_type_fiber || <nl> -	    hw->media_type == e1000_media_type_internal_serdes) <nl> +	if (adapter->hw.mac_type <= e1000_82547_rev_2 && <nl> +	    (hw->media_type == e1000_media_type_fiber || <nl> +	     hw->media_type == e1000_media_type_internal_serdes)) <nl>  		tipg = DEFAULT_82543_TIPG_IPGT_FIBER; <nl>  	else <nl>  		tipg = DEFAULT_82543_TIPG_IPGT_COPPER;
@@ -321,6 +321,11 @@ static struct s3c_gpio_cfg gpio_2bit_cfg_eint11 = { <nl>  	.get_pull	= s3c_gpio_getpull_updown, <nl>  }; <nl>   <nl> +int s3c64xx_gpio2int_gpn(struct gpio_chip *chip, unsigned pin) <nl> +{ <nl> +	return IRQ_EINT(0) + pin; <nl> +} <nl> + <nl>  static struct s3c_gpio_chip gpio_2bit[] = { <nl>  	{ <nl>  		.base	= S3C64XX_GPF_BASE, <nl> @@ -353,6 +358,7 @@ static struct s3c_gpio_chip gpio_2bit[] = { <nl>  			.base	= S3C64XX_GPN(0), <nl>  			.ngpio	= S3C64XX_GPIO_N_NR, <nl>  			.label	= "GPN", <nl> +			.to_irq = s3c64xx_gpio2int_gpn, <nl>  		}, <nl>  	}, { <nl>  		.base	= S3C64XX_GPO_BASE,
@@ -128,9 +128,11 @@ static int i915_dma_cleanup(struct drm_device * dev) <nl>  	if (dev->irq_enabled) <nl>  		drm_irq_uninstall(dev); <nl>   <nl> +	mutex_lock(&dev->struct_mutex); <nl>  	intel_cleanup_ring_buffer(dev, &dev_priv->render_ring); <nl>  	if (HAS_BSD(dev)) <nl>  		intel_cleanup_ring_buffer(dev, &dev_priv->bsd_ring); <nl> +	mutex_unlock(&dev->struct_mutex); <nl>   <nl>  	/* Clear the HWS virtual address at teardown */ <nl>  	if (I915_NEED_GFX_HWS(dev))
@@ -253,6 +253,8 @@ static int ch7006_encoder_create_resources(struct drm_encoder *encoder, <nl>  	drm_mode_create_tv_properties(dev, NUM_TV_NORMS, ch7006_tv_norm_names); <nl>   <nl>  	priv->scale_property = drm_property_create_range(dev, 0, "scale", 0, 2); <nl> +	if (!priv->scale_property) <nl> +		return -ENOMEM; <nl>   <nl>  	drm_object_attach_property(&connector->base, conf->tv_select_subconnector_property, <nl>  				      priv->select_subconnector);
@@ -1585,6 +1585,7 @@ xlog_recover_add_to_trans( <nl>  		"bad number of regions (%d) in inode log format", <nl>  				  in_f->ilf_size); <nl>  			ASSERT(0); <nl> +			free(ptr); <nl>  			return XFS_ERROR(EIO); <nl>  		} <nl>  
@@ -307,6 +307,7 @@ void acpi_gpiochip_request_interrupts(struct gpio_chip *chip) <nl>  	acpi_walk_resources(handle, "_AEI", <nl>  			    acpi_gpiochip_request_interrupt, acpi_gpio); <nl>  } <nl> +EXPORT_SYMBOL_GPL(acpi_gpiochip_request_interrupts); <nl>   <nl>  /** <nl>   * acpi_gpiochip_free_interrupts() - Free GPIO ACPI event interrupts. <nl> @@ -346,6 +347,7 @@ void acpi_gpiochip_free_interrupts(struct gpio_chip *chip) <nl>  		kfree(event); <nl>  	} <nl>  } <nl> +EXPORT_SYMBOL_GPL(acpi_gpiochip_free_interrupts); <nl>   <nl>  int acpi_dev_add_driver_gpios(struct acpi_device *adev, <nl>  			      const struct acpi_gpio_mapping *gpios)
@@ -159,7 +159,7 @@ static ssize_t solos_param_show(struct device *dev, struct device_attribute *att <nl>   <nl>  	buflen = strlen(attr->attr.name) + 10; <nl>   <nl> -	skb = alloc_skb(buflen, GFP_KERNEL); <nl> +	skb = alloc_skb(sizeof(*header) + buflen, GFP_KERNEL); <nl>  	if (!skb) { <nl>  		dev_warn(&card->dev->dev, "Failed to allocate sk_buff in solos_param_show()\n"); <nl>  		return -ENOMEM; <nl> @@ -215,7 +215,7 @@ static ssize_t solos_param_store(struct device *dev, struct device_attribute *at <nl>   <nl>  	buflen = strlen(attr->attr.name) + 11 + count; <nl>   <nl> -	skb = alloc_skb(buflen, GFP_KERNEL); <nl> +	skb = alloc_skb(sizeof(*header) + buflen, GFP_KERNEL); <nl>  	if (!skb) { <nl>  		dev_warn(&card->dev->dev, "Failed to allocate sk_buff in solos_param_store()\n"); <nl>  		return -ENOMEM;
@@ -25,7 +25,7 @@ static void batadv_hash_init(struct batadv_hashtable *hash) <nl>  { <nl>  	uint32_t i; <nl>   <nl> -	for (i = 0 ; i < hash->size; i++) { <nl> +	for (i = 0; i < hash->size; i++) { <nl>  		INIT_HLIST_HEAD(&hash->table[i]); <nl>  		spin_lock_init(&hash->list_locks[i]); <nl>  	}
@@ -963,6 +963,16 @@ int cfg80211_mlme_mgmt_tx(struct cfg80211_registered_device *rdev, <nl>  			if (memcmp(mgmt->bssid, dev->dev_addr, ETH_ALEN)) <nl>  				err = -EINVAL; <nl>  			break; <nl> +		case NL80211_IFTYPE_MESH_POINT: <nl> +			if (memcmp(mgmt->sa, mgmt->bssid, ETH_ALEN)) { <nl> +				err = -EINVAL; <nl> +				break; <nl> +			} <nl> +			/* <nl> +			 * check for mesh DA must be done by driver as <nl> +			 * cfg80211 doesn't track the stations <nl> +			 */ <nl> +			break; <nl>  		default: <nl>  			err = -EOPNOTSUPP; <nl>  			break;
@@ -740,10 +740,18 @@ p9_client_rpc(struct p9_client *c, int8_t type, const char *fmt, ...) <nl>  			c->status = Disconnected; <nl>  		goto reterr; <nl>  	} <nl> +again: <nl>  	/* Wait for the response */ <nl>  	err = wait_event_interruptible(*req->wq, <nl>  				       req->status >= REQ_STATUS_RCVD); <nl>   <nl> +	if ((err == -ERESTARTSYS) && (c->status == Connected) <nl> +				  && (type == P9_TFLUSH)) { <nl> +		sigpending = 1; <nl> +		clear_thread_flag(TIF_SIGPENDING); <nl> +		goto again; <nl> +	} <nl> + <nl>  	if (req->status == REQ_STATUS_ERROR) { <nl>  		p9_debug(P9_DEBUG_ERROR, "req_status error %d\n", req->t_err); <nl>  		err = req->t_err;
@@ -560,6 +560,8 @@ void qlcnic_set_multi(struct net_device *netdev) <nl>  			netdev_for_each_mc_addr(ha, netdev) { <nl>  				cur = kzalloc(sizeof(struct qlcnic_mac_list_s), <nl>  					      GFP_ATOMIC); <nl> +				if (cur == NULL) <nl> +					break; <nl>  				memcpy(cur->mac_addr, <nl>  				       ha->addr, ETH_ALEN); <nl>  				list_add_tail(&cur->list, &adapter->vf_mc_list);
@@ -748,8 +748,12 @@ static void exynos5_powerdown_conf(enum sys_powerdown mode) <nl>  void exynos_sys_powerdown_conf(enum sys_powerdown mode) <nl>  { <nl>  	unsigned int i; <nl> +	const struct exynos_pmu_data *pmu_data; <nl> + <nl> +	if (!pmu_context) <nl> +		return; <nl>   <nl> -	const struct exynos_pmu_data *pmu_data = pmu_context->pmu_data; <nl> +	pmu_data = pmu_context->pmu_data; <nl>   <nl>  	if (pmu_data->powerdown_conf) <nl>  		pmu_data->powerdown_conf(mode);
@@ -252,6 +252,10 @@ static acpi_status pnpacpi_allocated_resource(struct acpi_resource *res, <nl>  	case ACPI_RESOURCE_TYPE_GENERIC_REGISTER: <nl>  		break; <nl>   <nl> +	case ACPI_RESOURCE_TYPE_SERIAL_BUS: <nl> +		/* serial bus connections (I2C/SPI/UART) are not pnp */ <nl> +		break; <nl> + <nl>  	default: <nl>  		dev_warn(&dev->dev, "unknown resource type %d in _CRS\n", <nl>  			 res->type);
@@ -114,8 +114,8 @@ static int emumousebtn_input_register(void) <nl>  	if (!emumousebtn) <nl>  		return -ENOMEM; <nl>   <nl> -	lockdep_set_class(emumousebtn->event_lock, &emumousebtn_event_class); <nl> -	lockdep_set_class(emumousebtn->mutex, &emumousebtn_mutex_class); <nl> +	lockdep_set_class(&emumousebtn->event_lock, &emumousebtn_event_class); <nl> +	lockdep_set_class(&emumousebtn->mutex, &emumousebtn_mutex_class); <nl>   <nl>  	emumousebtn->name = "Macintosh mouse button emulation"; <nl>  	emumousebtn->id.bustype = BUS_ADB;
@@ -407,7 +407,7 @@ static int exynos_bus_probe(struct platform_device *pdev) <nl>  	/* Parse the device-tree to get the resource information */ <nl>  	ret = exynos_bus_parse_of(np, bus); <nl>  	if (ret < 0) <nl> -		goto err; <nl> +		return ret; <nl>   <nl>  	profile = devm_kzalloc(dev, sizeof(*profile), GFP_KERNEL); <nl>  	if (!profile) {
@@ -393,6 +393,10 @@ static struct urb *usbtv_setup_iso_transfer(struct usbtv *usbtv) <nl>  	ip->transfer_flags = URB_ISO_ASAP; <nl>  	ip->transfer_buffer = kzalloc(size * USBTV_ISOC_PACKETS, <nl>  						GFP_KERNEL); <nl> +	if (!ip->transfer_buffer) { <nl> +		usb_free_urb(ip); <nl> +		return NULL; <nl> +	} <nl>  	ip->complete = usbtv_iso_cb; <nl>  	ip->number_of_packets = USBTV_ISOC_PACKETS; <nl>  	ip->transfer_buffer_length = size * USBTV_ISOC_PACKETS;
@@ -306,6 +306,7 @@ static int tpm_binary_bios_measurements_show(struct seq_file *m, void *v) <nl>  	/* 5th: delimiter */ <nl>  	seq_putc(m, '\0'); <nl>   <nl> +	kfree(eventname); <nl>  	return 0; <nl>  } <nl>   <nl> @@ -353,6 +354,7 @@ static int tpm_ascii_bios_measurements_show(struct seq_file *m, void *v) <nl>  	/* 4th: eventname <= max + \'0' delimiter */ <nl>  	seq_printf(m, " %s\n", eventname); <nl>   <nl> +	kfree(eventname); <nl>  	return 0; <nl>  } <nl>  
@@ -209,7 +209,7 @@ static struct drm_driver driver = { <nl>  	.minor = DRIVER_MINOR, <nl>  	.patchlevel = DRIVER_PATCHLEVEL, <nl>   <nl> -	.gem_free_object = ast_gem_free_object, <nl> +	.gem_free_object_unlocked = ast_gem_free_object, <nl>  	.dumb_create = ast_dumb_create, <nl>  	.dumb_map_offset = ast_dumb_mmap_offset, <nl>  	.dumb_destroy = drm_gem_dumb_destroy,
@@ -3562,6 +3562,9 @@ qla24xx_reset_adapter(scsi_qla_host_t *vha) <nl>  	WRT_REG_DWORD(&reg->hccr, HCCRX_REL_RISC_PAUSE); <nl>  	RD_REG_DWORD(&reg->hccr); <nl>  	spin_unlock_irqrestore(&ha->hardware_lock, flags); <nl> + <nl> +	if (IS_NOPOLLING_TYPE(ha)) <nl> +		ha->isp_ops->enable_intrs(ha); <nl>  } <nl>   <nl>  /* On sparc systems, obtain port and node WWN from firmware
@@ -466,6 +466,12 @@ static int virtballoon_probe(struct virtio_device *vdev) <nl>  	struct virtio_balloon *vb; <nl>  	int err; <nl>   <nl> +	if (!vdev->config->get) { <nl> +		dev_err(&vdev->dev, "%s failure: config access disabled\n", <nl> +			__func__); <nl> +		return -EINVAL; <nl> +	} <nl> + <nl>  	vdev->priv = vb = kmalloc(sizeof(*vb), GFP_KERNEL); <nl>  	if (!vb) { <nl>  		err = -ENOMEM;
@@ -336,8 +336,8 @@ static int pcf8563_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *tm) <nl>  		__func__, buf[0], buf[1], buf[2], buf[3]); <nl>   <nl>  	tm->time.tm_min = bcd2bin(buf[0] & 0x7F); <nl> -	tm->time.tm_hour = bcd2bin(buf[1] & 0x7F); <nl> -	tm->time.tm_mday = bcd2bin(buf[2] & 0x1F); <nl> +	tm->time.tm_hour = bcd2bin(buf[1] & 0x3F); <nl> +	tm->time.tm_mday = bcd2bin(buf[2] & 0x3F); <nl>  	tm->time.tm_wday = bcd2bin(buf[3] & 0x7); <nl>  	tm->time.tm_mon = -1; <nl>  	tm->time.tm_year = -1;
@@ -569,6 +569,9 @@ static void _gb_power_supplies_release(struct gb_power_supplies *supplies) <nl>  { <nl>  	int i; <nl>   <nl> +	if (!supplies->supply) <nl> +		return; <nl> + <nl>  	mutex_lock(&supplies->supplies_lock); <nl>  	for (i = 0; i < supplies->supplies_count; i++) <nl>  		_gb_power_supply_release(&supplies->supply[i]);
@@ -1832,6 +1832,11 @@ static int vb2_internal_streamon(struct vb2_queue *q, enum v4l2_buf_type type) <nl>  		return -EINVAL; <nl>  	} <nl>   <nl> +	if (!q->num_buffers) { <nl> +		dprintk(1, "streamon: no buffers have been allocated\n"); <nl> +		return -EINVAL; <nl> +	} <nl> + <nl>  	/* <nl>  	 * If any buffers were queued before streamon, <nl>  	 * we can now pass them to driver for processing.
@@ -305,11 +305,15 @@ static void wl1271_tx_fill_hdr(struct wl1271 *wl, struct wl12xx_vif *wlvif, <nl>  	if (is_dummy || !wlvif) <nl>  		rate_idx = 0; <nl>  	else if (wlvif->bss_type != BSS_TYPE_AP_BSS) { <nl> -		/* if the packets are destined for AP (have a STA entry) <nl> -		   send them with AP rate policies, otherwise use default <nl> -		   basic rates */ <nl> +		/* <nl> +		 * if the packets are destined for AP (have a STA entry) <nl> +		 * send them with AP rate policies (EAPOLs are an exception), <nl> +		 * otherwise use default basic rates <nl> +		 */ <nl>  		if (control->flags & IEEE80211_TX_CTL_NO_CCK_RATE) <nl>  			rate_idx = wlvif->sta.p2p_rate_idx; <nl> +		else if (skb->protocol == cpu_to_be16(ETH_P_PAE)) <nl> +			rate_idx = wlvif->sta.basic_rate_idx; <nl>  		else if (control->control.sta) <nl>  			rate_idx = wlvif->sta.ap_rate_idx; <nl>  		else
@@ -476,7 +476,7 @@ qed_ll2_rxq_completion_gsi(struct qed_hwfn *p_hwfn, <nl>  static int qed_ll2_rxq_completion_reg(struct qed_hwfn *p_hwfn, <nl>  				      struct qed_ll2_info *p_ll2_conn, <nl>  				      union core_rx_cqe_union *p_cqe, <nl> -				      unsigned long lock_flags, <nl> +				      unsigned long *p_lock_flags, <nl>  				      bool b_last_cqe) <nl>  { <nl>  	struct qed_ll2_rx_queue *p_rx = &p_ll2_conn->rx_queue; <nl> @@ -497,10 +497,10 @@ static int qed_ll2_rxq_completion_reg(struct qed_hwfn *p_hwfn, <nl>  			  "Mismatch between active_descq and the LL2 Rx chain\n"); <nl>  	list_add_tail(&p_pkt->list_entry, &p_rx->free_descq); <nl>   <nl> -	spin_unlock_irqrestore(&p_rx->lock, lock_flags); <nl> +	spin_unlock_irqrestore(&p_rx->lock, *p_lock_flags); <nl>  	qed_ll2b_complete_rx_packet(p_hwfn, p_ll2_conn->my_id, <nl>  				    p_pkt, &p_cqe->rx_cqe_fp, b_last_cqe); <nl> -	spin_lock_irqsave(&p_rx->lock, lock_flags); <nl> +	spin_lock_irqsave(&p_rx->lock, *p_lock_flags); <nl>   <nl>  	return 0; <nl>  } <nl> @@ -540,7 +540,8 @@ static int qed_ll2_rxq_completion(struct qed_hwfn *p_hwfn, void *cookie) <nl>  			break; <nl>  		case CORE_RX_CQE_TYPE_REGULAR: <nl>  			rc = qed_ll2_rxq_completion_reg(p_hwfn, p_ll2_conn, <nl> -							cqe, flags, b_last_cqe); <nl> +							cqe, &flags, <nl> +							b_last_cqe); <nl>  			break; <nl>  		default: <nl>  			rc = -EIO;
@@ -605,6 +605,8 @@ static int qat_alg_sgl_to_bufl(struct qat_crypto_instance *inst, <nl>  		goto err; <nl>   <nl>  	for_each_sg(assoc, sg, assoc_n, i) { <nl> +		if (!sg->length) <nl> +			continue; <nl>  		bufl->bufers[bufs].addr = dma_map_single(dev, <nl>  							 sg_virt(sg), <nl>  							 sg->length,
@@ -250,6 +250,10 @@ static int synaptics_board_id(struct psmouse *psmouse) <nl>  	struct synaptics_data *priv = psmouse->private; <nl>  	unsigned char bid[3]; <nl>   <nl> +	/* firmwares prior 7.5 have no board_id encoded */ <nl> +	if (SYN_ID_FULL(priv->identity) < 0x705) <nl> +		return 0; <nl> + <nl>  	if (synaptics_send_cmd(psmouse, SYN_QUE_MODES, bid)) <nl>  		return -1; <nl>  	priv->board_id = ((bid[0] & 0xfc) << 6) | bid[1];
@@ -1220,7 +1220,12 @@ static void conf_message_callback(const char *fmt, va_list ap) <nl>   <nl>  static void show_help(struct menu *menu) <nl>  { <nl> -	struct gstr help = str_new(); <nl> +	struct gstr help; <nl> + <nl> +	if (!menu) <nl> +		return; <nl> + <nl> +	help = str_new(); <nl>  	menu_get_ext_help(menu, &help); <nl>  	show_scroll_win(main_window, _(menu_get_prompt(menu)), str_get(&help)); <nl>  	str_free(&help);
@@ -1882,6 +1882,10 @@ retry: <nl>  		return 0; <nl>   <nl>  	n_group = ext4_get_group_number(sb, n_blocks_count - 1); <nl> +	if (n_group > (0xFFFFFFFFUL / EXT4_INODES_PER_GROUP(sb))) { <nl> +		ext4_warning(sb, "resize would cause inodes_count overflow"); <nl> +		return -EINVAL; <nl> +	} <nl>  	ext4_get_group_no_and_offset(sb, o_blocks_count - 1, &o_group, &offset); <nl>   <nl>  	n_desc_blocks = num_desc_blocks(sb, n_group + 1);
@@ -339,6 +339,11 @@ int kvmppc_handle_exit(struct kvm_run *run, struct kvm_vcpu *vcpu, <nl>  		} <nl>  		break; <nl>   <nl> +	case BOOKE_INTERRUPT_FP_UNAVAIL: <nl> +		kvmppc_queue_exception(vcpu, exit_nr); <nl> +		r = RESUME_GUEST; <nl> +		break; <nl> + <nl>  	case BOOKE_INTERRUPT_DATA_STORAGE: <nl>  		vcpu->arch.dear = vcpu->arch.fault_dear; <nl>  		vcpu->arch.esr = vcpu->arch.fault_esr;
@@ -168,6 +168,11 @@ int hfsplus_find_cat(struct super_block *sb, u32 cnid, <nl>  		return -EIO; <nl>  	} <nl>   <nl> +	if (be16_to_cpu(tmp.thread.nodeName.length) > 255) { <nl> +		printk(KERN_ERR "hfs: catalog name length corrupted\n"); <nl> +		return -EIO; <nl> +	} <nl> + <nl>  	hfsplus_cat_build_key_uni(fd->search_key, be32_to_cpu(tmp.thread.parentID), <nl>  				 &tmp.thread.nodeName); <nl>  	return hfs_brec_find(fd);
@@ -669,6 +669,9 @@ static int netlink_bind(struct socket *sock, struct sockaddr *addr, <nl>  	struct sockaddr_nl *nladdr = (struct sockaddr_nl *)addr; <nl>  	int err; <nl>   <nl> +	if (addr_len < sizeof(struct sockaddr_nl)) <nl> +		return -EINVAL; <nl> + <nl>  	if (nladdr->nl_family != AF_NETLINK) <nl>  		return -EINVAL; <nl>  
@@ -354,10 +354,14 @@ drm_do_get_edid(struct drm_connector *connector, struct i2c_adapter *adapter) <nl>  				break; <nl>  			} <nl>  		} <nl> -		if (i == 4) <nl> + <nl> +		if (i == 4 && print_bad_edid) { <nl>  			dev_warn(connector->dev->dev, <nl>  			 "%s: Ignoring invalid EDID block %d.\n", <nl>  			 drm_get_connector_name(connector), j); <nl> + <nl> +			connector->bad_edid_counter++; <nl> +		} <nl>  	} <nl>   <nl>  	if (valid_extensions != block[0x7e]) {
@@ -232,11 +232,18 @@ static struct notifier_block panic_block = { <nl>   <nl>  static int __init reboot_setup(void) <nl>  { <nl> +	int res; <nl> + <nl>  	_machine_restart = sgi_machine_restart; <nl>  	_machine_halt = sgi_machine_halt; <nl>  	pm_power_off = sgi_machine_power_off; <nl>   <nl> -	request_irq(SGI_PANEL_IRQ, panel_int, 0, "Front Panel", NULL); <nl> +	res = request_irq(SGI_PANEL_IRQ, panel_int, 0, "Front Panel", NULL); <nl> +	if (res) { <nl> +		printk(KERN_ERR "Allocation of front panel IRQ failed\n"); <nl> +		return res; <nl> +	} <nl> + <nl>  	init_timer(&blink_timer); <nl>  	blink_timer.function = blink_timeout; <nl>  	atomic_notifier_chain_register(&panic_notifier_list, &panic_block);
@@ -457,6 +457,8 @@ static int br_afspec(struct net_bridge *br, <nl>  		if (nla_len(attr) != sizeof(struct bridge_vlan_info)) <nl>  			return -EINVAL; <nl>  		vinfo = nla_data(attr); <nl> +		if (!vinfo->vid || vinfo->vid >= VLAN_VID_MASK) <nl> +			return -EINVAL; <nl>  		if (vinfo->flags & BRIDGE_VLAN_INFO_RANGE_BEGIN) { <nl>  			if (vinfo_start) <nl>  				return -EINVAL;
@@ -322,10 +322,10 @@ static void wacom_i4_parse_pen_report(struct wacom_data *wdata, <nl>   <nl>  	switch (data[1]) { <nl>  	case 0x80: /* Out of proximity report */ <nl> -		wdata->tool = 0; <nl>  		input_report_key(input, BTN_TOUCH, 0); <nl>  		input_report_abs(input, ABS_PRESSURE, 0); <nl>  		input_report_key(input, wdata->tool, 0); <nl> +		wdata->tool = 0; <nl>  		input_sync(input); <nl>  		break; <nl>  	case 0xC2: /* Tool report */
@@ -1142,7 +1142,12 @@ ext4_move_extents(struct file *o_filp, struct file *d_filp, <nl>  			orig_inode->i_ino, donor_inode->i_ino); <nl>  		return -EINVAL; <nl>  	} <nl> - <nl> +	/* TODO: This is non obvious task to swap blocks for inodes with full <nl> +	   jornaling enabled */ <nl> +	if (ext4_should_journal_data(orig_inode) || <nl> +	    ext4_should_journal_data(donor_inode)) { <nl> +		return -EINVAL; <nl> +	} <nl>  	/* Protect orig and donor inodes against a truncate */ <nl>  	mext_inode_double_lock(orig_inode, donor_inode); <nl>  
@@ -37,13 +37,14 @@ static int gr2d_init(struct host1x_client *client) <nl>  { <nl>  	struct tegra_drm_client *drm = host1x_to_drm_client(client); <nl>  	struct tegra_drm *tegra = dev_get_drvdata(client->parent); <nl> +	unsigned long flags = HOST1X_SYNCPT_HAS_BASE; <nl>  	struct gr2d *gr2d = to_gr2d(drm); <nl>   <nl>  	gr2d->channel = host1x_channel_request(client->dev); <nl>  	if (!gr2d->channel) <nl>  		return -ENOMEM; <nl>   <nl> -	client->syncpts[0] = host1x_syncpt_request(client->dev, 0); <nl> +	client->syncpts[0] = host1x_syncpt_request(client->dev, flags); <nl>  	if (!client->syncpts[0]) { <nl>  		host1x_channel_free(gr2d->channel); <nl>  		return -ENOMEM;
@@ -207,7 +207,7 @@ dt3155_start_acq(struct dt3155_priv *pd) <nl>  	struct vb2_buffer *vb = pd->curr_buf; <nl>  	dma_addr_t dma_addr; <nl>   <nl> -	dma_addr = vb2_dma_contig_plane_paddr(vb, 0); <nl> +	dma_addr = vb2_dma_contig_plane_dma_addr(vb, 0); <nl>  	iowrite32(dma_addr, pd->regs + EVEN_DMA_START); <nl>  	iowrite32(dma_addr + img_width, pd->regs + ODD_DMA_START); <nl>  	iowrite32(img_width, pd->regs + EVEN_DMA_STRIDE); <nl> @@ -374,7 +374,7 @@ dt3155_irq_handler_even(int irq, void *dev_id) <nl>  	ivb = list_first_entry(&ipd->dmaq, typeof(*ivb), done_entry); <nl>  	list_del(&ivb->done_entry); <nl>  	ipd->curr_buf = ivb; <nl> -	dma_addr = vb2_dma_contig_plane_paddr(ivb, 0); <nl> +	dma_addr = vb2_dma_contig_plane_dma_addr(ivb, 0); <nl>  	iowrite32(dma_addr, ipd->regs + EVEN_DMA_START); <nl>  	iowrite32(dma_addr + img_width, ipd->regs + ODD_DMA_START); <nl>  	iowrite32(img_width, ipd->regs + EVEN_DMA_STRIDE);
@@ -524,6 +524,12 @@ static int p9_virtio_probe(struct virtio_device *vdev) <nl>  	int err; <nl>  	struct virtio_chan *chan; <nl>   <nl> +	if (!vdev->config->get) { <nl> +		dev_err(&vdev->dev, "%s failure: config access disabled\n", <nl> +			__func__); <nl> +		return -EINVAL; <nl> +	} <nl> + <nl>  	chan = kmalloc(sizeof(struct virtio_chan), GFP_KERNEL); <nl>  	if (!chan) { <nl>  		pr_err("Failed to allocate virtio 9P channel\n");
@@ -1377,7 +1377,8 @@ bc_svc_process(struct svc_serv *serv, struct rpc_rqst *req, <nl>  						sizeof(req->rq_snd_buf)); <nl>  		return bc_send(req); <nl>  	} else { <nl> -		/* Nothing to do to drop request */ <nl> +		/* drop request */ <nl> +		xprt_free_bc_request(req); <nl>  		return 0; <nl>  	} <nl>  }
@@ -327,6 +327,8 @@ static void set_times(struct tca6507_chip *tca, int bank) <nl>  	int result; <nl>   <nl>  	result = choose_times(tca->bank[bank].ontime, &c1, &c2); <nl> +	if (result < 0) <nl> +		return; <nl>  	dev_dbg(&tca->client->dev, <nl>  		"Chose on  times %d(%d) %d(%d) for %dms\n", <nl>  		c1, time_codes[c1],
@@ -662,10 +662,14 @@ tso_sq_no_longer_full: <nl>  				nesnic->sq_head &= nesnic->sq_size-1; <nl>  			} <nl>  		} else { <nl> -			nesvnic->linearized_skbs++; <nl>  			hoffset = skb_transport_header(skb) - skb->data; <nl>  			nhoffset = skb_network_header(skb) - skb->data; <nl> -			skb_linearize(skb); <nl> +			if (skb_linearize(skb)) { <nl> +				nesvnic->tx_sw_dropped++; <nl> +				kfree_skb(skb); <nl> +				return NETDEV_TX_OK; <nl> +			} <nl> +			nesvnic->linearized_skbs++; <nl>  			skb_set_transport_header(skb, hoffset); <nl>  			skb_set_network_header(skb, nhoffset); <nl>  			if (!nes_nic_send(skb, netdev))
@@ -950,7 +950,7 @@ void ieee80211_process_addba_request(struct ieee80211_local *local, <nl>   <nl>  	/* prepare reordering buffer */ <nl>  	tid_agg_rx->reorder_buf = <nl> -		kmalloc(buf_size * sizeof(struct sk_buff *), GFP_ATOMIC); <nl> +		kcalloc(buf_size, sizeof(struct sk_buff *), GFP_ATOMIC); <nl>  	if (!tid_agg_rx->reorder_buf) { <nl>  #ifdef CONFIG_MAC80211_HT_DEBUG <nl>  		if (net_ratelimit()) <nl> @@ -960,8 +960,6 @@ void ieee80211_process_addba_request(struct ieee80211_local *local, <nl>  		kfree(sta->ampdu_mlme.tid_rx[tid]); <nl>  		goto end; <nl>  	} <nl> -	memset(tid_agg_rx->reorder_buf, 0, <nl> -		buf_size * sizeof(struct sk_buff *)); <nl>   <nl>  	if (local->ops->ampdu_action) <nl>  		ret = local->ops->ampdu_action(hw, IEEE80211_AMPDU_RX_START,
@@ -173,7 +173,7 @@ static u32 asle_set_backlight(struct drm_device *dev, u32 bclp) <nl>  		return ASLE_BACKLIGHT_FAILED; <nl>   <nl>  	intel_panel_set_backlight(dev, bclp, 255); <nl> -	iowrite32((bclp*0x64)/0xff | ASLE_CBLV_VALID, &asle->cblv); <nl> +	iowrite32(DIV_ROUND_UP(bclp * 100, 255) | ASLE_CBLV_VALID, &asle->cblv); <nl>   <nl>  	return 0; <nl>  }
@@ -3497,6 +3497,9 @@ static int fd_ioctl(struct block_device *bdev, fmode_t mode, unsigned int cmd, <nl>  	    ((cmd & 0x80) && !capable(CAP_SYS_ADMIN))) <nl>  		return -EPERM; <nl>   <nl> +	if (WARN_ON(size < 0 || size > sizeof(inparam))) <nl> +		return -EINVAL; <nl> + <nl>  	/* copyin */ <nl>  	CLEARSTRUCT(&inparam); <nl>  	if (_IOC_DIR(cmd) & _IOC_WRITE)
@@ -655,9 +655,13 @@ int iwctl_giwaplist(struct net_device *dev, struct iw_request_info *info, <nl>  		return -EINVAL; <nl>   <nl>  	sock = kzalloc(sizeof(struct sockaddr) * IW_MAX_AP, GFP_KERNEL); <nl> +	if (sock == NULL) <nl> +		return -ENOMEM; <nl>  	qual = kzalloc(sizeof(struct iw_quality) * IW_MAX_AP, GFP_KERNEL); <nl> -	if (sock == NULL || qual == NULL) <nl> +	if (qual == NULL) { <nl> +		kfree(sock); <nl>  		return -ENOMEM; <nl> +	} <nl>   <nl>  	for (ii = 0, jj = 0; ii < MAX_BSS_NUM; ii++) { <nl>  		if (!pBSS[ii].bActive)
@@ -707,6 +707,8 @@ static bool vgic_its_check_device_id(struct kvm *kvm, struct vgic_its *its, <nl>  			   &indirect_ptr, sizeof(indirect_ptr))) <nl>  		return false; <nl>   <nl> +	indirect_ptr = le64_to_cpu(indirect_ptr); <nl> + <nl>  	/* check the valid bit of the first level entry */ <nl>  	if (!(indirect_ptr & BIT_ULL(63))) <nl>  		return false;
@@ -2029,6 +2029,8 @@ static void lro_add_page(struct adapter *adap, struct sge_qset *qs, <nl>  	pci_unmap_single(adap->pdev, pci_unmap_addr(sd, dma_addr), <nl>  			 fl->buf_size, PCI_DMA_FROMDEVICE); <nl>   <nl> +	prefetch(&qs->lro_frag_tbl); <nl> + <nl>  	rx_frag += nr_frags; <nl>  	rx_frag->page = sd->pg_chunk.page; <nl>  	rx_frag->page_offset = sd->pg_chunk.offset + offset; <nl> @@ -2997,6 +2999,7 @@ int t3_sge_alloc_qset(struct adapter *adapter, unsigned int id, int nports, <nl>  		     V_NEWTIMER(q->rspq.holdoff_tmr)); <nl>   <nl>  	mod_timer(&q->tx_reclaim_timer, jiffies + TX_RECLAIM_PERIOD); <nl> + <nl>  	return 0; <nl>   <nl>  err_unlock:
@@ -3301,9 +3301,11 @@ void ieee80211_init_tx_queue(struct ieee80211_sub_if_data *sdata, <nl>  	if (sta) { <nl>  		txqi->txq.sta = &sta->sta; <nl>  		sta->sta.txq[tid] = &txqi->txq; <nl> +		txqi->txq.tid = tid; <nl>  		txqi->txq.ac = ieee802_1d_to_ac[tid & 7]; <nl>  	} else { <nl>  		sdata->vif.txq = &txqi->txq; <nl> +		txqi->txq.tid = 0; <nl>  		txqi->txq.ac = IEEE80211_AC_BE; <nl>  	} <nl>  }
@@ -867,6 +867,14 @@ int netvsc_send(struct hv_device *device, <nl>  	packet->send_buf_index = NETVSC_INVALID_INDEX; <nl>  	packet->cp_partial = false; <nl>   <nl> +	/* Send control message directly without accessing msd (Multi-Send <nl> +	 * Data) field which may be changed during data packet processing. <nl> +	 */ <nl> +	if (!skb) { <nl> +		cur_send = packet; <nl> +		goto send_now; <nl> +	} <nl> + <nl>  	msdp = &net_device->msd[q_idx]; <nl>   <nl>  	/* batch packets in send buffer if possible */ <nl> @@ -939,6 +947,7 @@ int netvsc_send(struct hv_device *device, <nl>  		} <nl>  	} <nl>   <nl> +send_now: <nl>  	if (cur_send) <nl>  		ret = netvsc_send_pkt(cur_send, net_device, pb, skb); <nl>  
@@ -260,7 +260,7 @@ struct NDIS_802_11_KEY { <nl>  	__le32 KeyLength; <nl>  	u8 Bssid[6]; <nl>  	u8 Padding[6]; <nl> -	__le64 KeyRSC; <nl> +	u8 KeyRSC[8]; <nl>  	u8 KeyMaterial[32]; <nl>  } __attribute__((packed)); <nl>   <nl> @@ -1508,7 +1508,7 @@ static int rndis_iw_set_encode_ext(struct net_device *dev, <nl>  	struct usbnet *usbdev = dev->priv; <nl>  	struct rndis_wext_private *priv = get_rndis_wext_priv(usbdev); <nl>  	struct NDIS_802_11_KEY ndis_key; <nl> -	int i, keyidx, ret; <nl> +	int keyidx, ret; <nl>  	u8 *addr; <nl>   <nl>  	keyidx = wrqu->encoding.flags & IW_ENCODE_INDEX; <nl> @@ -1543,9 +1543,7 @@ static int rndis_iw_set_encode_ext(struct net_device *dev, <nl>  	ndis_key.KeyIndex = cpu_to_le32(keyidx); <nl>   <nl>  	if (ext->ext_flags & IW_ENCODE_EXT_RX_SEQ_VALID) { <nl> -		for (i = 0; i < 6; i++) <nl> -			ndis_key.KeyRSC |= <nl> -				cpu_to_le64(ext->rx_seq[i] << (i * 8)); <nl> +		memcpy(ndis_key.KeyRSC, ext->rx_seq, 6); <nl>  		ndis_key.KeyIndex |= cpu_to_le32(1 << 29); <nl>  	} <nl>  
@@ -138,6 +138,7 @@ static struct regulator_ops max77693_charger_ops = { <nl>  	.n_voltages	= 4,					\ <nl>  	.ops		= &max77693_safeout_ops,		\ <nl>  	.type		= REGULATOR_VOLTAGE,			\ <nl> +	.owner		= THIS_MODULE,				\ <nl>  	.volt_table	= max77693_safeout_table,		\ <nl>  	.vsel_reg	= MAX77693_CHG_REG_SAFEOUT_CTRL,	\ <nl>  	.vsel_mask	= SAFEOUT_CTRL_SAFEOUT##_num##_MASK,	\
@@ -621,6 +621,9 @@ static void mce_async_callback(struct urb *urb, struct pt_regs *regs) <nl>  		mceusb_dev_printdata(ir, urb->transfer_buffer, 0, len, true); <nl>  	} <nl>   <nl> +	/* the transfer buffer and urb were allocated in mce_request_packet */ <nl> +	kfree(urb->transfer_buffer); <nl> +	usb_free_urb(urb); <nl>  } <nl>   <nl>  /* request incoming or send outgoing usb packet - used to initialize remote */
@@ -191,6 +191,8 @@ static void __del_gref(struct gntalloc_gref *gref) <nl>   <nl>  		if (!gnttab_end_foreign_access_ref(gref->gref_id, 0)) <nl>  			return; <nl> + <nl> +		gnttab_free_grant_reference(gref->gref_id); <nl>  	} <nl>   <nl>  	gref_size--;
@@ -374,7 +374,7 @@ static int __devinit ne2k_pci_init_one (struct pci_dev *pdev, <nl>  	dev->ethtool_ops = &ne2k_pci_ethtool_ops; <nl>  	NS8390_init(dev, 0); <nl>   <nl> -	memcpy(dev->dev_addr, SA_prom, 6); <nl> +	memcpy(dev->dev_addr, SA_prom, dev->addr_len); <nl>  	memcpy(dev->perm_addr, dev->dev_addr, dev->addr_len); <nl>   <nl>  	i = register_netdev(dev);
@@ -2824,7 +2824,7 @@ static int __devinit velocity_found1(struct pci_dev *pdev, const struct pci_devi <nl>  	netif_napi_add(dev, &vptr->napi, velocity_poll, VELOCITY_NAPI_WEIGHT); <nl>   <nl>  	dev->features |= NETIF_F_HW_VLAN_TX | NETIF_F_HW_VLAN_FILTER | <nl> -		NETIF_F_HW_VLAN_RX | NETIF_F_IP_CSUM | NETIF_F_SG; <nl> +		NETIF_F_HW_VLAN_RX | NETIF_F_IP_CSUM; <nl>   <nl>  	ret = register_netdev(dev); <nl>  	if (ret < 0)
@@ -550,7 +550,7 @@ static void acm_waker(struct work_struct *waker) <nl>  static int acm_tty_open(struct tty_struct *tty, struct file *filp) <nl>  { <nl>  	struct acm *acm; <nl> -	int rv = -EINVAL; <nl> +	int rv = -ENODEV; <nl>  	int i; <nl>  	dbg("Entering acm_tty_open."); <nl>  
@@ -1402,6 +1402,7 @@ static enum pool_mode get_pool_mode(struct pool *pool) <nl>  static void set_pool_mode(struct pool *pool, enum pool_mode new_mode) <nl>  { <nl>  	int r; <nl> +	struct pool_c *pt = pool->ti->private; <nl>  	enum pool_mode old_mode = pool->pf.mode; <nl>   <nl>  	switch (new_mode) { <nl> @@ -1448,6 +1449,11 @@ static void set_pool_mode(struct pool *pool, enum pool_mode new_mode) <nl>  	} <nl>   <nl>  	pool->pf.mode = new_mode; <nl> +	/* <nl> +	 * The pool mode may have changed, sync it so bind_control_target() <nl> +	 * doesn't cause an unexpected mode transition on resume. <nl> +	 */ <nl> +	pt->adjusted_pf.mode = new_mode; <nl>  } <nl>   <nl>  /*
@@ -51,13 +51,13 @@ static int recv_control_msg(struct au0828_dev *dev, u16 request, u32 value, <nl>  u32 au0828_readreg(struct au0828_dev *dev, u16 reg) <nl>  { <nl>  	recv_control_msg(dev, CMD_REQUEST_IN, 0, reg, dev->ctrlmsg, 1); <nl> -	dprintk(8, "%s(0x%x) = 0x%x\n", __func__, reg, dev->ctrlmsg[0]); <nl> +	dprintk(8, "%s(0x%04x) = 0x%02x\n", __func__, reg, dev->ctrlmsg[0]); <nl>  	return dev->ctrlmsg[0]; <nl>  } <nl>   <nl>  u32 au0828_writereg(struct au0828_dev *dev, u16 reg, u32 val) <nl>  { <nl> -	dprintk(8, "%s(0x%x, 0x%x)\n", __func__, reg, val); <nl> +	dprintk(8, "%s(0x%04x, 0x%02x)\n", __func__, reg, val); <nl>  	return send_control_msg(dev, CMD_REQUEST_OUT, val, reg, <nl>  				dev->ctrlmsg, 0); <nl>  }
@@ -1444,7 +1444,7 @@ usbnet_probe (struct usb_interface *udev, const struct usb_device_id *prod) <nl>   <nl>  	status = register_netdev (net); <nl>  	if (status) <nl> -		goto out3; <nl> +		goto out4; <nl>  	netif_info(dev, probe, dev->net, <nl>  		   "register '%s' at usb-%s-%s, %s, %pM\n", <nl>  		   udev->dev.driver->name, <nl> @@ -1462,6 +1462,8 @@ usbnet_probe (struct usb_interface *udev, const struct usb_device_id *prod) <nl>   <nl>  	return 0; <nl>   <nl> +out4: <nl> +	usb_free_urb(dev->interrupt); <nl>  out3: <nl>  	if (info->unbind) <nl>  		info->unbind (dev, udev);
@@ -2306,7 +2306,7 @@ intel_fill_fb_ggtt_view(struct i915_ggtt_view *view, struct drm_framebuffer *fb, <nl>  	tile_size = intel_tile_size(dev_priv); <nl>   <nl>  	cpp = drm_format_plane_cpp(fb->pixel_format, 0); <nl> -	tile_width = intel_tile_width(dev_priv, cpp, fb->modifier[0]); <nl> +	tile_width = intel_tile_width(dev_priv, fb->modifier[0], cpp); <nl>  	tile_height = tile_size / tile_width; <nl>   <nl>  	info->width_pages = DIV_ROUND_UP(fb->pitches[0], tile_width);
@@ -1514,6 +1514,7 @@ batadv_nc_skb_decode_packet(struct batadv_priv *bat_priv, struct sk_buff *skb, <nl>  	struct ethhdr *ethhdr, ethhdr_tmp; <nl>  	uint8_t *orig_dest, ttl, ttvn; <nl>  	unsigned int coding_len; <nl> +	int err; <nl>   <nl>  	/* Save headers temporarily */ <nl>  	memcpy(&coded_packet_tmp, skb->data, sizeof(coded_packet_tmp)); <nl> @@ -1568,8 +1569,11 @@ batadv_nc_skb_decode_packet(struct batadv_priv *bat_priv, struct sk_buff *skb, <nl>  			 coding_len); <nl>   <nl>  	/* Resize decoded skb if decoded with larger packet */ <nl> -	if (nc_packet->skb->len > coding_len + h_size) <nl> -		pskb_trim_rcsum(skb, coding_len + h_size); <nl> +	if (nc_packet->skb->len > coding_len + h_size) { <nl> +		err = pskb_trim_rcsum(skb, coding_len + h_size); <nl> +		if (err) <nl> +			return NULL; <nl> +	} <nl>   <nl>  	/* Create decoded unicast packet */ <nl>  	unicast_packet = (struct batadv_unicast_packet *)skb->data;
@@ -1429,6 +1429,11 @@ static int __blkdev_put(struct block_device *bdev, fmode_t mode, int for_part) <nl>  		WARN_ON_ONCE(bdev->bd_holders); <nl>  		sync_blockdev(bdev); <nl>  		kill_bdev(bdev); <nl> +		/* ->release can cause the old bdi to disappear, <nl> +		 * so must switch it out first <nl> +		 */ <nl> +		bdev_inode_switch_bdi(bdev->bd_inode, <nl> +					&default_backing_dev_info); <nl>  	} <nl>  	if (bdev->bd_contains == bdev) { <nl>  		if (disk->fops->release) <nl> @@ -1442,8 +1447,6 @@ static int __blkdev_put(struct block_device *bdev, fmode_t mode, int for_part) <nl>  		disk_put_part(bdev->bd_part); <nl>  		bdev->bd_part = NULL; <nl>  		bdev->bd_disk = NULL; <nl> -		bdev_inode_switch_bdi(bdev->bd_inode, <nl> -					&default_backing_dev_info); <nl>  		if (bdev != bdev->bd_contains) <nl>  			victim = bdev->bd_contains; <nl>  		bdev->bd_contains = NULL;
@@ -916,7 +916,7 @@ static struct intel_iommu *device_to_iommu(struct device *dev, u8 *bus, u8 *devf <nl>  				 * which we used for the IOMMU lookup. Strictly speaking <nl>  				 * we could do this for all PCI devices; we only need to <nl>  				 * get the BDF# from the scope table for ACPI matches. */ <nl> -				if (pdev->is_virtfn) <nl> +				if (pdev && pdev->is_virtfn) <nl>  					goto got_pdev; <nl>   <nl>  				*bus = drhd->devices[i].bus;
@@ -70,7 +70,7 @@ void __init s3c6400_init_irq(void) <nl>  	s3c64xx_init_irq(~0 & ~(0xf << 5), ~0); <nl>  } <nl>   <nl> -struct sysdev_class s3c6400_sysclass = { <nl> +static struct sysdev_class s3c6400_sysclass = { <nl>  	.name	= "s3c6400-core", <nl>  }; <nl>  
@@ -2891,7 +2891,7 @@ netxen_sysfs_read_crb(struct file *filp, struct kobject *kobj, <nl>  		struct bin_attribute *attr, <nl>  		char *buf, loff_t offset, size_t size) <nl>  { <nl> -	struct device *dev = container_of(kobj, struct device, kobj); <nl> +	struct device *dev = kobj_to_dev(kobj); <nl>  	struct netxen_adapter *adapter = dev_get_drvdata(dev); <nl>  	u32 data; <nl>  	u64 qmdata; <nl> @@ -2919,7 +2919,7 @@ netxen_sysfs_write_crb(struct file *filp, struct kobject *kobj, <nl>  		struct bin_attribute *attr, <nl>  		char *buf, loff_t offset, size_t size) <nl>  { <nl> -	struct device *dev = container_of(kobj, struct device, kobj); <nl> +	struct device *dev = kobj_to_dev(kobj); <nl>  	struct netxen_adapter *adapter = dev_get_drvdata(dev); <nl>  	u32 data; <nl>  	u64 qmdata; <nl> @@ -2960,7 +2960,7 @@ netxen_sysfs_read_mem(struct file *filp, struct kobject *kobj, <nl>  		struct bin_attribute *attr, <nl>  		char *buf, loff_t offset, size_t size) <nl>  { <nl> -	struct device *dev = container_of(kobj, struct device, kobj); <nl> +	struct device *dev = kobj_to_dev(kobj); <nl>  	struct netxen_adapter *adapter = dev_get_drvdata(dev); <nl>  	u64 data; <nl>  	int ret; <nl> @@ -2981,7 +2981,7 @@ static ssize_t netxen_sysfs_write_mem(struct file *filp, struct kobject *kobj, <nl>  		struct bin_attribute *attr, char *buf, <nl>  		loff_t offset, size_t size) <nl>  { <nl> -	struct device *dev = container_of(kobj, struct device, kobj); <nl> +	struct device *dev = kobj_to_dev(kobj); <nl>  	struct netxen_adapter *adapter = dev_get_drvdata(dev); <nl>  	u64 data; <nl>  	int ret; <nl> @@ -3018,7 +3018,7 @@ netxen_sysfs_read_dimm(struct file *filp, struct kobject *kobj, <nl>  		struct bin_attribute *attr, <nl>  		char *buf, loff_t offset, size_t size) <nl>  { <nl> -	struct device *dev = container_of(kobj, struct device, kobj); <nl> +	struct device *dev = kobj_to_dev(kobj); <nl>  	struct netxen_adapter *adapter = dev_get_drvdata(dev); <nl>  	struct net_device *netdev = adapter->netdev; <nl>  	struct netxen_dimm_cfg dimm;
@@ -745,9 +745,9 @@ static int do_vmbus_entry(const char *filename, struct hv_vmbus_device_id *id, <nl>  			  char *alias) <nl>  { <nl>  	int i; <nl> -	char guid_name[((sizeof(struct hv_vmbus_device_id) + 1)) * 2]; <nl> +	char guid_name[((sizeof(id->guid) + 1)) * 2]; <nl>   <nl> -	for (i = 0; i < (sizeof(struct hv_vmbus_device_id) * 2); i += 2) <nl> +	for (i = 0; i < (sizeof(id->guid) * 2); i += 2) <nl>  		sprintf(&guid_name[i], "%02x", id->guid[i/2]); <nl>   <nl>  	strcpy(alias, "vmbus:");
@@ -26,13 +26,15 @@ void save_stack_trace(struct stack_trace *trace) <nl>   <nl>  		/* Bogus frame pointer? */ <nl>  		if (fp < (thread_base + sizeof(struct thread_info)) || <nl> -		    fp >= (thread_base + THREAD_SIZE)) <nl> +		    fp > (thread_base + THREAD_SIZE - sizeof(struct sparc_stackf))) <nl>  			break; <nl>   <nl>  		sf = (struct sparc_stackf *) fp; <nl>  		regs = (struct pt_regs *) (sf + 1); <nl>   <nl> -		if ((regs->magic & ~0x1ff) == PT_REGS_MAGIC) { <nl> +		if (((unsigned long)regs <= <nl> +		     (thread_base + THREAD_SIZE - sizeof(*regs))) && <nl> +		    (regs->magic & ~0x1ff) == PT_REGS_MAGIC) { <nl>  			if (!(regs->tstate & TSTATE_PRIV)) <nl>  				break; <nl>  			pc = regs->tpc;
@@ -41,6 +41,10 @@ __ieee80211_get_channel_mode(struct ieee80211_local *local, <nl>  			if (!sdata->u.ap.beacon) <nl>  				continue; <nl>  			break; <nl> +		case NL80211_IFTYPE_MESH_POINT: <nl> +			if (!sdata->wdev.mesh_id_len) <nl> +				continue; <nl> +			break; <nl>  		default: <nl>  			break; <nl>  		}
@@ -362,12 +362,19 @@ void ipoib_mcast_carrier_on_task(struct work_struct *work) <nl>  { <nl>  	struct ipoib_dev_priv *priv = container_of(work, struct ipoib_dev_priv, <nl>  						   carrier_on_task); <nl> +	struct ib_port_attr attr; <nl>   <nl>  	/* <nl>  	 * Take rtnl_lock to avoid racing with ipoib_stop() and <nl>  	 * turning the carrier back on while a device is being <nl>  	 * removed. <nl>  	 */ <nl> +	if (ib_query_port(priv->ca, priv->port, &attr) || <nl> +	    attr.state != IB_PORT_ACTIVE) { <nl> +		ipoib_dbg(priv, "Keeping carrier off until IB port is active\n"); <nl> +		return; <nl> +	} <nl> + <nl>  	rtnl_lock(); <nl>  	netif_carrier_on(priv->dev); <nl>  	rtnl_unlock();
@@ -253,7 +253,7 @@ int i915_gem_stolen_setup_compression(struct drm_device *dev, int size, int fb_c <nl>  	if (!drm_mm_initialized(&dev_priv->mm.stolen)) <nl>  		return -ENODEV; <nl>   <nl> -	if (size < dev_priv->fbc.uncompressed_size) <nl> +	if (size <= dev_priv->fbc.uncompressed_size) <nl>  		return 0; <nl>   <nl>  	/* Release any current block */
@@ -654,7 +654,8 @@ int __cpu_disable(void) <nl>  	/* disable all external interrupts */ <nl>  	cr_parms.orvals[0] = 0; <nl>  	cr_parms.andvals[0] = ~(1 << 15 | 1 << 14 | 1 << 13 | 1 << 11 | <nl> -				1 << 10 | 1 <<	9 | 1 <<  6 | 1 <<  4); <nl> +				1 << 10 | 1 <<	9 | 1 <<  6 | 1 <<  5 | <nl> +				1 <<  4); <nl>  	/* disable all I/O interrupts */ <nl>  	cr_parms.orvals[6] = 0; <nl>  	cr_parms.andvals[6] = ~(1 << 31 | 1 << 30 | 1 << 29 | 1 << 28 |
@@ -1050,7 +1050,7 @@ static int nfs_open_revalidate(struct dentry *dentry, struct nameidata *nd) <nl>  	struct inode *dir; <nl>  	int openflags, ret = 0; <nl>   <nl> -	if (!is_atomic_open(nd)) <nl> +	if (!is_atomic_open(nd) || d_mountpoint(dentry)) <nl>  		goto no_open; <nl>  	parent = dget_parent(dentry); <nl>  	dir = parent->d_inode;
@@ -687,6 +687,11 @@ static int i2o_cfg_passthru32(struct file *file, unsigned cmnd, <nl>  		} <nl>  		size = size >> 16; <nl>  		size *= 4; <nl> +		if (size > sizeof(rmsg)) { <nl> +			rcode = -EINVAL; <nl> +			goto sg_list_cleanup; <nl> +		} <nl> + <nl>  		/* Copy in the user's I2O command */ <nl>  		if (copy_from_user(rmsg, user_msg, size)) { <nl>  			rcode = -EFAULT; <nl> @@ -922,6 +927,11 @@ static int i2o_cfg_passthru(unsigned long arg) <nl>  		} <nl>  		size = size >> 16; <nl>  		size *= 4; <nl> +		if (size > sizeof(rmsg)) { <nl> +			rcode = -EFAULT; <nl> +			goto sg_list_cleanup; <nl> +		} <nl> + <nl>  		/* Copy in the user's I2O command */ <nl>  		if (copy_from_user(rmsg, user_msg, size)) { <nl>  			rcode = -EFAULT;
@@ -119,7 +119,7 @@ TODO: <nl>   <nl>  #define PCI9111_REGISTER_AD_FIFO_VALUE			0x00 /* AD Data stored <nl>  								in FIFO */ <nl> -#define PCI9111_REGISTER_DA_OUTPUT			0x00 <nl> +#define PCI9111_AO_REG					0x00 <nl>  #define PCI9111_DIO_REG					0x02 <nl>  #define PCI9111_REGISTER_EXTENDED_IO_PORTS		0x04 <nl>  #define PCI9111_REGISTER_AD_CHANNEL_CONTROL		0x06 /* Channel <nl> @@ -229,11 +229,6 @@ TODO: <nl>  		&PCI9111_HR_AI_RESOLUTION_MASK) \ <nl>  			^ PCI9111_HR_AI_RESOLUTION_2_CMP_BIT) <nl>   <nl> -#define pci9111_ao_set_data(data) \ <nl> -	outw(data&PCI9111_AO_RESOLUTION_MASK, \ <nl> -		dev->iobase + PCI9111_REGISTER_DA_OUTPUT) <nl> - <nl> - <nl>  static const struct comedi_lrange pci9111_hr_ai_range = { <nl>  	5, <nl>  	{ <nl> @@ -1055,7 +1050,8 @@ pci9111_ao_insn_write(struct comedi_device *dev, <nl>  	int i; <nl>   <nl>  	for (i = 0; i < insn->n; i++) { <nl> -		pci9111_ao_set_data(data[i]); <nl> +		outw(data[i] & PCI9111_AO_RESOLUTION_MASK, <nl> +			dev->iobase + PCI9111_AO_REG); <nl>  		dev_private->ao_readback = data[i]; <nl>  	} <nl>  
@@ -1598,6 +1598,9 @@ static int start_afu(struct cxlflash_cfg *cfg) <nl>   <nl>  	init_pcr(cfg); <nl>   <nl> +	/* After an AFU reset, RRQ entries are stale, clear them */ <nl> +	memset(&afu->rrq_entry, 0, sizeof(afu->rrq_entry)); <nl> + <nl>  	/* Initialize RRQ pointers */ <nl>  	afu->hrrq_start = &afu->rrq_entry[0]; <nl>  	afu->hrrq_end = &afu->rrq_entry[NUM_RRQ_ENTRY - 1];
@@ -1845,8 +1845,8 @@ cifs_put_tcon(struct cifsTconInfo *tcon) <nl>  	CIFSSMBTDis(xid, tcon); <nl>  	_FreeXid(xid); <nl>   <nl> -	tconInfoFree(tcon); <nl>  	cifs_fscache_release_super_cookie(tcon); <nl> +	tconInfoFree(tcon); <nl>  	cifs_put_smb_ses(ses); <nl>  } <nl>  
@@ -64,8 +64,8 @@ <nl>   <nl>  #define DRV_MODULE_NAME		"tg3" <nl>  #define PFX DRV_MODULE_NAME	": " <nl> -#define DRV_MODULE_VERSION	"3.81" <nl> -#define DRV_MODULE_RELDATE	"September 5, 2007" <nl> +#define DRV_MODULE_VERSION	"3.82" <nl> +#define DRV_MODULE_RELDATE	"October 5, 2007" <nl>   <nl>  #define TG3_DEF_MAC_MODE	0 <nl>  #define TG3_DEF_RX_MODE		0
@@ -472,7 +472,7 @@ int extcon_register_interest(struct extcon_specific_cable_nb *obj, <nl>   <nl>  		obj->cable_index = extcon_find_cable_index(obj->edev, cable_name); <nl>  		if (obj->cable_index < 0) <nl> -			return -ENODEV; <nl> +			return obj->cable_index; <nl>   <nl>  		obj->user_nb = nb; <nl>  
@@ -80,7 +80,8 @@ static void printl(const char *fmt, ...) <nl>   <nl>  	kfifo_put(tcpw.fifo, tbuf, len); <nl>  	wake_up(&tcpw.wait); <nl> -} <nl> +} __attribute__ ((format (printf, 1, 2))); <nl> + <nl>   <nl>  /* <nl>   * Hook inserted to be called before each receive packet.
@@ -2382,7 +2382,9 @@ void em28xx_card_setup(struct em28xx *dev) <nl>  	} <nl>   <nl>  	em28xx_tuner_setup(dev); <nl> -	em28xx_ir_init(dev); <nl> + <nl> +	if(!disable_ir) <nl> +		em28xx_ir_init(dev); <nl>  } <nl>   <nl>  
@@ -1198,6 +1198,9 @@ static int __init parse_memmap_opt(char *p) <nl>  	char *oldp; <nl>  	u64 start_at, mem_size; <nl>   <nl> +	if (!p) <nl> +		return -EINVAL; <nl> + <nl>  	if (!strcmp(p, "exactmap")) { <nl>  #ifdef CONFIG_CRASH_DUMP <nl>  		/*
@@ -183,6 +183,7 @@ static void maxiradio_remove(struct pci_dev *pdev) <nl>  	outb(0, dev->io); <nl>  	v4l2_device_unregister(v4l2_dev); <nl>  	release_region(pci_resource_start(pdev, 0), pci_resource_len(pdev, 0)); <nl> +	kfree(dev); <nl>  } <nl>   <nl>  static struct pci_device_id maxiradio_pci_tbl[] = {
@@ -3632,6 +3632,12 @@ static int inet6_rtm_getroute(struct sk_buff *in_skb, struct nlmsghdr *nlh) <nl>  		rt = (struct rt6_info *)ip6_route_output(net, NULL, &fl6); <nl>  	} <nl>   <nl> +	if (rt == net->ipv6.ip6_null_entry) { <nl> +		err = rt->dst.error; <nl> +		ip6_rt_put(rt); <nl> +		goto errout; <nl> +	} <nl> + <nl>  	skb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL); <nl>  	if (!skb) { <nl>  		ip6_rt_put(rt);
@@ -1211,7 +1211,11 @@ static void free_unnecessary_pages(void) <nl>  		to_free_highmem = alloc_highmem - save; <nl>  	} else { <nl>  		to_free_highmem = 0; <nl> -		to_free_normal -= save - alloc_highmem; <nl> +		save -= alloc_highmem; <nl> +		if (to_free_normal > save) <nl> +			to_free_normal -= save; <nl> +		else <nl> +			to_free_normal = 0; <nl>  	} <nl>   <nl>  	memory_bm_position_reset(&copy_bm);
@@ -1698,6 +1698,9 @@ static int i915_context_status(struct seq_file *m, void *unused) <nl>  	} <nl>   <nl>  	list_for_each_entry(ctx, &dev_priv->context_list, link) { <nl> +		if (ctx->obj == NULL) <nl> +			continue; <nl> + <nl>  		seq_puts(m, "HW context "); <nl>  		describe_ctx(m, ctx); <nl>  		for_each_ring(ring, dev_priv, i)
@@ -3128,10 +3128,6 @@ static void valleyview_irq_preinstall(struct drm_device *dev) <nl>  	I915_WRITE(RING_IMR(GEN6_BSD_RING_BASE), 0); <nl>  	I915_WRITE(RING_IMR(BLT_RING_BASE), 0); <nl>   <nl> -	/* and GT */ <nl> -	I915_WRITE(GTIIR, I915_READ(GTIIR)); <nl> -	I915_WRITE(GTIIR, I915_READ(GTIIR)); <nl> - <nl>  	gen5_gt_irq_reset(dev); <nl>   <nl>  	I915_WRITE(DPINVGTT, DPINVGTT_STATUS_MASK);
@@ -26,6 +26,8 @@ <nl>  #include "dvb_frontend.h" <nl>  #include "au8522_priv.h" <nl>   <nl> +MODULE_LICENSE("GPL"); <nl> + <nl>  static int debug; <nl>   <nl>  #define dprintk(arg...)\
@@ -138,7 +138,7 @@ struct net_device *alloc_rtllib(int sizeof_priv) <nl>  	rtllib_softmac_init(ieee); <nl>   <nl>  	ieee->pHTInfo = kzalloc(sizeof(struct rt_hi_throughput), GFP_KERNEL); <nl> -	if (ieee->pHTInfo == NULL) <nl> +	if (!ieee->pHTInfo) <nl>  		return NULL; <nl>   <nl>  	HTUpdateDefaultSetting(ieee);
@@ -907,7 +907,7 @@ u32 mp_query_psd(struct adapter *pAdapter, u8 *data) <nl>  		sscanf(data, "pts =%d, start =%d, stop =%d", &psd_pts, &psd_start, &psd_stop); <nl>  	} <nl>   <nl> -	_rtw_memset(data, '\0', sizeof(data)); <nl> +	_rtw_memset(data, '\0', sizeof(*data)); <nl>   <nl>  	i = psd_start; <nl>  	while (i < psd_stop) {
@@ -635,7 +635,7 @@ static int sd_init(struct gspca_dev *gspca_dev) <nl>  	struct sd *sd = (struct sd *) gspca_dev; <nl>  	int i; <nl>  	u16 sensor_id; <nl> -	u8 test_byte; <nl> +	u8 test_byte = 0; <nl>  	u16 reg80, reg8e; <nl>   <nl>  	static const u8 read_indexs[] =
@@ -172,6 +172,9 @@ int bench_futex_requeue(int argc, const char **argv, <nl>  		gettimeofday(&end, NULL); <nl>  		timersub(&end, &start, &runtime); <nl>   <nl> +		if (nrequeued > nthreads) <nl> +			nrequeued = nthreads; <nl> + <nl>  		update_stats(&requeued_stats, nrequeued); <nl>  		update_stats(&requeuetime_stats, runtime.tv_usec); <nl>   <nl> @@ -190,7 +193,6 @@ int bench_futex_requeue(int argc, const char **argv, <nl>  			if (ret) <nl>  				err(EXIT_FAILURE, "pthread_join"); <nl>  		} <nl> - <nl>  	} <nl>   <nl>  	/* cleanup & report results */
@@ -476,11 +476,12 @@ static int nilfs_statfs(struct dentry *dentry, struct kstatfs *buf) <nl>  { <nl>  	struct super_block *sb = dentry->d_sb; <nl>  	struct nilfs_sb_info *sbi = NILFS_SB(sb); <nl> +	struct the_nilfs *nilfs = sbi->s_nilfs; <nl> +	u64 id = huge_encode_dev(sb->s_bdev->bd_dev); <nl>  	unsigned long long blocks; <nl>  	unsigned long overhead; <nl>  	unsigned long nrsvblocks; <nl>  	sector_t nfreeblocks; <nl> -	struct the_nilfs *nilfs = sbi->s_nilfs; <nl>  	int err; <nl>   <nl>  	/* <nl> @@ -514,6 +515,9 @@ static int nilfs_statfs(struct dentry *dentry, struct kstatfs *buf) <nl>  	buf->f_files = atomic_read(&sbi->s_inodes_count); <nl>  	buf->f_ffree = 0; /* nilfs_count_free_inodes(sb); */ <nl>  	buf->f_namelen = NILFS_NAME_LEN; <nl> +	buf->f_fsid.val[0] = (u32)id; <nl> +	buf->f_fsid.val[1] = (u32)(id >> 32); <nl> + <nl>  	return 0; <nl>  } <nl>  
@@ -372,7 +372,8 @@ int commit_creds(struct cred *new) <nl>  	    old->fsuid != new->fsuid || <nl>  	    old->fsgid != new->fsgid || <nl>  	    !cap_issubset(new->cap_permitted, old->cap_permitted)) { <nl> -		set_dumpable(task->mm, suid_dumpable); <nl> +		if (task->mm) <nl> +			set_dumpable(task->mm, suid_dumpable); <nl>  		task->pdeath_signal = 0; <nl>  		smp_wmb(); <nl>  	}
@@ -430,9 +430,9 @@ static int __devinit xencons_probe(struct xenbus_device *dev, <nl>  	if (devid == 0) <nl>  		return -ENODEV; <nl>   <nl> -	info = kzalloc(sizeof(struct xencons_info), GFP_KERNEL | __GFP_ZERO); <nl> +	info = kzalloc(sizeof(struct xencons_info), GFP_KERNEL); <nl>  	if (!info) <nl> -		goto error_nomem; <nl> +		return -ENOMEM; <nl>  	dev_set_drvdata(&dev->dev, info); <nl>  	info->xbdev = dev; <nl>  	info->vtermno = xenbus_devid_to_vtermno(devid);
@@ -816,6 +816,11 @@ int snd_usb_caiaq_audio_init(struct snd_usb_caiaqdev *cdev) <nl>  		return -EINVAL; <nl>  	} <nl>   <nl> +	if (cdev->n_streams < 2) { <nl> +		dev_err(dev, "bogus number of streams: %d\n", cdev->n_streams); <nl> +		return -EINVAL; <nl> +	} <nl> + <nl>  	ret = snd_pcm_new(cdev->chip.card, cdev->product_name, 0, <nl>  			cdev->n_audio_out, cdev->n_audio_in, &cdev->pcm); <nl>  
@@ -3615,6 +3615,7 @@ static int decode_attr_fs_locations(struct xdr_stream *xdr, uint32_t *bitmap, st <nl>  	status = 0; <nl>  	if (unlikely(!(bitmap[0] & FATTR4_WORD0_FS_LOCATIONS))) <nl>  		goto out; <nl> +	bitmap[0] &= ~FATTR4_WORD0_FS_LOCATIONS; <nl>  	status = -EIO; <nl>  	/* Ignore borken servers that return unrequested attrs */ <nl>  	if (unlikely(res == NULL))
@@ -551,7 +551,8 @@ int dn_fib_dump(struct sk_buff *skb, struct netlink_callback *cb) <nl>  		if (t < s_t) <nl>  			continue; <nl>  		if (t > s_t) <nl> -			memset(&cb->args[1], 0, sizeof(cb->args)-sizeof(int)); <nl> +			memset(&cb->args[1], 0, <nl> +			       sizeof(cb->args) - sizeof(cb->args[0])); <nl>  		tb = dn_fib_get_table(t, 0); <nl>  		if (tb == NULL) <nl>  			continue;
@@ -637,7 +637,6 @@ struct cardstate *gigaset_initcs(struct gigaset_driver *drv, int channels, <nl>  		err("maximum number of devices exceeded"); <nl>  		return NULL; <nl>  	} <nl> -	mutex_init(&cs->mutex); <nl>   <nl>  	gig_dbg(DEBUG_INIT, "allocating bcs[0..%d]", channels - 1); <nl>  	cs->bcs = kmalloc(channels * sizeof(struct bc_state), GFP_KERNEL); <nl> @@ -898,8 +897,10 @@ int gigaset_shutdown(struct cardstate *cs) <nl>  { <nl>  	mutex_lock(&cs->mutex); <nl>   <nl> -	if (!(cs->flags & VALID_MINOR)) <nl> +	if (!(cs->flags & VALID_MINOR)) { <nl> +		mutex_unlock(&cs->mutex); <nl>  		return -1; <nl> +	} <nl>   <nl>  	cs->waiting = 1; <nl>   <nl> @@ -1086,6 +1087,7 @@ struct gigaset_driver *gigaset_initdriver(unsigned minor, unsigned minors, <nl>  		drv->cs[i].driver = drv; <nl>  		drv->cs[i].ops = drv->ops; <nl>  		drv->cs[i].minor_index = i; <nl> +		mutex_init(&drv->cs[i].mutex); <nl>  	} <nl>   <nl>  	gigaset_if_initdriver(drv, procname, devname);
@@ -68,7 +68,7 @@ static int fsl_pcie_check_link(struct pci_controller *hose) <nl>  	if (hose->indirect_type & PPC_INDIRECT_TYPE_FSL_CFG_REG_LINK) { <nl>  		if (hose->ops->read == fsl_indirect_read_config) { <nl>  			struct pci_bus bus; <nl> -			bus.number = 0; <nl> +			bus.number = hose->first_busno; <nl>  			bus.sysdata = hose; <nl>  			bus.ops = hose->ops; <nl>  			indirect_read_config(&bus, 0, PCIE_LTSSM, 4, &val);
@@ -327,6 +327,9 @@ static bool extra_info_update_ongoing(void) <nl>  		ovl = omap_dss_get_overlay(i); <nl>  		op = get_ovl_priv(ovl); <nl>   <nl> +		if (!ovl->manager) <nl> +			continue; <nl> + <nl>  		mp = get_mgr_priv(ovl->manager); <nl>   <nl>  		if (!mp->enabled)
@@ -601,6 +601,14 @@ void ieee80211_recalc_ps(struct ieee80211_local *local, s32 latency) <nl>  	list_for_each_entry(sdata, &local->interfaces, list) { <nl>  		if (!ieee80211_sdata_running(sdata)) <nl>  			continue; <nl> +		if (sdata->vif.type == NL80211_IFTYPE_AP) { <nl> +			/* If an AP vif is found, then disable PS <nl> +			 * by setting the count to zero thereby setting <nl> +			 * ps_sdata to NULL. <nl> +			 */ <nl> +			count = 0; <nl> +			break; <nl> +		} <nl>  		if (sdata->vif.type != NL80211_IFTYPE_STATION) <nl>  			continue; <nl>  		found = sdata;
@@ -221,7 +221,7 @@ static int egalax_probe(struct hid_device *hdev, const struct hid_device_id *id) <nl>  	struct egalax_data *td; <nl>  	struct hid_report *report; <nl>   <nl> -	td = kmalloc(sizeof(struct egalax_data), GFP_KERNEL); <nl> +	td = kzalloc(sizeof(struct egalax_data), GFP_KERNEL); <nl>  	if (!td) { <nl>  		dev_err(&hdev->dev, "cannot allocate eGalax data\n"); <nl>  		return -ENOMEM;
@@ -318,6 +318,8 @@ static int bcma_get_next_core(struct bcma_bus *bus, u32 __iomem **eromptr, <nl>  		switch (core->id.id) { <nl>  		case BCMA_CORE_4706_MAC_GBIT_COMMON: <nl>  		case BCMA_CORE_NS_CHIPCOMMON_B: <nl> +		case BCMA_CORE_PMU: <nl> +		case BCMA_CORE_GCI: <nl>  		/* Not used yet: case BCMA_CORE_OOB_ROUTER: */ <nl>  			break; <nl>  		default:
@@ -311,10 +311,12 @@ static int copy_packet(struct urb *urb, u32 header, u8 **ptr, u8 *endp, <nl>  		case TM6000_URB_MSG_PTS: <nl>  			break; <nl>  		case TM6000_URB_MSG_AUDIO: <nl> -/* Need some code to process audio */ <nl> -printk ("%ld: cmd=%s, size=%d\n", jiffies, <nl> +			/* Need some code to process audio */ <nl> +			printk ("%ld: cmd=%s, size=%d\n", jiffies, <nl>  				tm6000_msg_type[cmd],size); <nl>  			break; <nl> +		case TM6000_URB_MSG_VBI: <nl> +			break; <nl>  		default: <nl>  			dprintk (dev, V4L2_DEBUG_ISOC, "cmd=%s, size=%d\n", <nl>  						tm6000_msg_type[cmd],size);
@@ -637,6 +637,8 @@ static int INIT start_bunzip(struct bunzip_data **bdp, void *inbuf, int len, <nl>   <nl>  	/* Allocate bunzip_data.  Most fields initialize to zero. */ <nl>  	bd = *bdp = malloc(i); <nl> +	if (!bd) <nl> +		return RETVAL_OUT_OF_MEMORY; <nl>  	memset(bd, 0, sizeof(struct bunzip_data)); <nl>  	/* Setup input buffer */ <nl>  	bd->inbuf = inbuf; <nl> @@ -664,6 +666,8 @@ static int INIT start_bunzip(struct bunzip_data **bdp, void *inbuf, int len, <nl>  	bd->dbufSize = 100000*(i-BZh0); <nl>   <nl>  	bd->dbuf = large_malloc(bd->dbufSize * sizeof(int)); <nl> +	if (!bd->dbuf) <nl> +		return RETVAL_OUT_OF_MEMORY; <nl>  	return RETVAL_OK; <nl>  } <nl>   <nl> @@ -686,7 +690,7 @@ STATIC int INIT bunzip2(unsigned char *buf, int len, <nl>   <nl>  	if (!outbuf) { <nl>  		error("Could not allocate output bufer"); <nl> -		return -1; <nl> +		return RETVAL_OUT_OF_MEMORY; <nl>  	} <nl>  	if (buf) <nl>  		inbuf = buf; <nl> @@ -694,6 +698,7 @@ STATIC int INIT bunzip2(unsigned char *buf, int len, <nl>  		inbuf = malloc(BZIP2_IOBUF_SIZE); <nl>  	if (!inbuf) { <nl>  		error("Could not allocate input bufer"); <nl> +		i = RETVAL_OUT_OF_MEMORY; <nl>  		goto exit_0; <nl>  	} <nl>  	i = start_bunzip(&bd, inbuf, len, fill); <nl> @@ -720,11 +725,14 @@ STATIC int INIT bunzip2(unsigned char *buf, int len, <nl>  	} else if (i == RETVAL_UNEXPECTED_OUTPUT_EOF) { <nl>  		error("Compressed file ends unexpectedly"); <nl>  	} <nl> +	if (!bd) <nl> +		goto exit_1; <nl>  	if (bd->dbuf) <nl>  		large_free(bd->dbuf); <nl>  	if (pos) <nl>  		*pos = bd->inbufPos; <nl>  	free(bd); <nl> +exit_1: <nl>  	if (!buf) <nl>  		free(inbuf); <nl>  exit_0:
@@ -812,6 +812,8 @@ static struct usb_request *isp1760_ep_alloc_request(struct usb_ep *ep, <nl>  	struct isp1760_request *req; <nl>   <nl>  	req = kzalloc(sizeof(*req), gfp_flags); <nl> +	if (!req) <nl> +		return NULL; <nl>   <nl>  	return &req->req; <nl>  }
@@ -2049,7 +2049,7 @@ struct cyttsp4 *cyttsp4_probe(const struct cyttsp4_bus_ops *ops, <nl>  	cd->irq = gpio_to_irq(cd->cpdata->irq_gpio); <nl>  	if (cd->irq < 0) { <nl>  		rc = -EINVAL; <nl> -		goto error_free_cd; <nl> +		goto error_free_xfer; <nl>  	} <nl>   <nl>  	dev_set_drvdata(dev, cd); <nl> @@ -2117,6 +2117,8 @@ error_request_irq: <nl>  	if (cd->cpdata->init) <nl>  		cd->cpdata->init(cd->cpdata, 0, dev); <nl>  	dev_set_drvdata(dev, NULL); <nl> +error_free_xfer: <nl> +	kfree(cd->xfer_buf); <nl>  error_free_cd: <nl>  	kfree(cd); <nl>  error_alloc_data:
@@ -1031,6 +1031,8 @@ static int dummy_udc_probe(struct platform_device *pdev) <nl>  	int		rc; <nl>   <nl>  	dum = *((void **)dev_get_platdata(&pdev->dev)); <nl> +	/* Clear usb_gadget region for new registration to udc-core */ <nl> +	memzero_explicit(&dum->gadget, sizeof(struct usb_gadget)); <nl>  	dum->gadget.name = gadget_name; <nl>  	dum->gadget.ops = &dummy_ops; <nl>  	dum->gadget.max_speed = USB_SPEED_SUPER;
@@ -605,13 +605,13 @@ int ath9k_hw_rxprocdesc(struct ath_hw *ah, struct ath_desc *ds, <nl>  		 * reported, then decryption and MIC errors are irrelevant, <nl>  		 * the frame is going to be dropped either way <nl>  		 */ <nl> -		if (ads.ds_rxstatus8 & AR_CRCErr) <nl> -			rs->rs_status |= ATH9K_RXERR_CRC; <nl> -		else if (ads.ds_rxstatus8 & AR_PHYErr) { <nl> +		if (ads.ds_rxstatus8 & AR_PHYErr) { <nl>  			rs->rs_status |= ATH9K_RXERR_PHY; <nl>  			phyerr = MS(ads.ds_rxstatus8, AR_PHYErrCode); <nl>  			rs->rs_phyerr = phyerr; <nl> -		} else if (ads.ds_rxstatus8 & AR_DecryptCRCErr) <nl> +		} else if (ads.ds_rxstatus8 & AR_CRCErr) <nl> +			rs->rs_status |= ATH9K_RXERR_CRC; <nl> +		else if (ads.ds_rxstatus8 & AR_DecryptCRCErr) <nl>  			rs->rs_status |= ATH9K_RXERR_DECRYPT; <nl>  		else if (ads.ds_rxstatus8 & AR_MichaelErr) <nl>  			rs->rs_status |= ATH9K_RXERR_MIC;
@@ -441,7 +441,7 @@ static int __devinit cpm_i2c_setup(struct cpm_i2c *cpm) <nl>  	init_waitqueue_head(&cpm->i2c_wait); <nl>   <nl>  	cpm->irq = of_irq_to_resource(ofdev->node, 0, NULL); <nl> -	if (cpm->irq == NO_IRQ) <nl> +	if (!cpm->irq) <nl>  		return -EINVAL; <nl>   <nl>  	/* Install interrupt handler. */
@@ -1550,6 +1550,11 @@ static int pn533_poll_complete(struct pn533 *dev, void *arg, <nl>  	if (!rc) <nl>  		goto done; <nl>   <nl> +	if (!dev->poll_mod_count) { <nl> +		nfc_dev_dbg(&dev->interface->dev, "Polling has been stoped."); <nl> +		goto done; <nl> +	} <nl> + <nl>  	pn533_poll_next_mod(dev); <nl>  	queue_work(dev->wq, &dev->poll_work); <nl>  
@@ -217,12 +217,22 @@ static void driver_remove_groups(struct device_driver *drv, <nl>  int driver_register(struct device_driver *drv) <nl>  { <nl>  	int ret; <nl> +	struct device_driver *other; <nl>   <nl>  	if ((drv->bus->probe && drv->probe) || <nl>  	    (drv->bus->remove && drv->remove) || <nl>  	    (drv->bus->shutdown && drv->shutdown)) <nl>  		printk(KERN_WARNING "Driver '%s' needs updating - please use " <nl>  			"bus_type methods\n", drv->name); <nl> + <nl> +	other = driver_find(drv->name, drv->bus); <nl> +	if (other) { <nl> +		put_driver(other); <nl> +		printk(KERN_ERR "Error: Driver '%s' is already registered, " <nl> +			"aborting...\n", drv->name); <nl> +		return -EEXIST; <nl> +	} <nl> + <nl>  	ret = bus_add_driver(drv); <nl>  	if (ret) <nl>  		return ret;
@@ -2036,7 +2036,7 @@ static int fman_init(struct fman *fman) <nl>  	/* allocate MURAM for FIFO according to total size */ <nl>  	fman->fifo_offset = fman_muram_alloc(fman->muram, <nl>  					     fman->state->total_fifo_size); <nl> -	if (IS_ERR_VALUE(fman->cam_offset)) { <nl> +	if (IS_ERR_VALUE(fman->fifo_offset)) { <nl>  		free_init_resources(fman); <nl>  		dev_err(fman->dev, "%s: MURAM alloc for BMI FIFO failed\n", <nl>  			__func__);
@@ -3869,6 +3869,14 @@ static int device_notifier(struct notifier_block *nb, <nl>  	    action != BUS_NOTIFY_DEL_DEVICE) <nl>  		return 0; <nl>   <nl> +	/* <nl> +	 * If the device is still attached to a device driver we can't <nl> +	 * tear down the domain yet as DMA mappings may still be in use. <nl> +	 * Wait for the BUS_NOTIFY_UNBOUND_DRIVER event to do that. <nl> +	 */ <nl> +	if (action == BUS_NOTIFY_DEL_DEVICE && dev->driver != NULL) <nl> +		return 0; <nl> + <nl>  	domain = find_domain(dev); <nl>  	if (!domain) <nl>  		return 0;
@@ -487,6 +487,14 @@ static void wmi_evt_connect(struct wil6210_priv *wil, int id, void *d, int len) <nl>  			return; <nl>  		} <nl>  		del_timer_sync(&wil->connect_timer); <nl> +	} else if ((wdev->iftype == NL80211_IFTYPE_AP) || <nl> +		   (wdev->iftype == NL80211_IFTYPE_P2P_GO)) { <nl> +		if (wil->sta[evt->cid].status != wil_sta_unused) { <nl> +			wil_err(wil, "%s: AP: Invalid status %d for CID %d\n", <nl> +				__func__, wil->sta[evt->cid].status, evt->cid); <nl> +			mutex_unlock(&wil->mutex); <nl> +			return; <nl> +		} <nl>  	} <nl>   <nl>  	/* FIXME FW can transmit only ucast frames to peer */
@@ -742,7 +742,7 @@ static void reparent_leader(struct task_struct *father, struct task_struct *p, <nl>  { <nl>  	list_move_tail(&p->sibling, &p->real_parent->children); <nl>   <nl> -	if (task_detached(p)) <nl> +	if (p->exit_state == EXIT_DEAD) <nl>  		return; <nl>  	/* <nl>  	 * If this is a threaded reparent there is no need to
@@ -862,6 +862,11 @@ static int usb_serial_probe(struct usb_interface *interface, <nl>  			num_ports = type->num_ports; <nl>  	} <nl>   <nl> +	if (num_ports > MAX_NUM_PORTS) { <nl> +		dev_warn(ddev, "too many ports requested: %d\n", num_ports); <nl> +		num_ports = MAX_NUM_PORTS; <nl> +	} <nl> + <nl>  	serial->num_ports = num_ports; <nl>  	serial->num_bulk_in = num_bulk_in; <nl>  	serial->num_bulk_out = num_bulk_out;
@@ -1758,10 +1758,6 @@ nfsd_rename(struct svc_rqst *rqstp, struct svc_fh *ffhp, char *fname, int flen, <nl>  	tdentry = tfhp->fh_dentry; <nl>  	tdir = tdentry->d_inode; <nl>   <nl> -	err = (rqstp->rq_vers == 2) ? nfserr_acces : nfserr_xdev; <nl> -	if (ffhp->fh_export != tfhp->fh_export) <nl> -		goto out; <nl> - <nl>  	err = nfserr_perm; <nl>  	if (!flen || isdotent(fname, flen) || !tlen || isdotent(tname, tlen)) <nl>  		goto out; <nl> @@ -1802,6 +1798,8 @@ nfsd_rename(struct svc_rqst *rqstp, struct svc_fh *ffhp, char *fname, int flen, <nl>  	host_err = -EXDEV; <nl>  	if (ffhp->fh_export->ex_path.mnt != tfhp->fh_export->ex_path.mnt) <nl>  		goto out_dput_new; <nl> +	if (ffhp->fh_export->ex_path.dentry != tfhp->fh_export->ex_path.dentry) <nl> +		goto out_dput_new; <nl>   <nl>  	host_err = nfsd_break_lease(odentry->d_inode); <nl>  	if (host_err)
@@ -1743,8 +1743,10 @@ struct fib_table *fib_trie_unmerge(struct fib_table *oldtb) <nl>  				local_l = fib_find_node(lt, &local_tp, l->key); <nl>   <nl>  			if (fib_insert_alias(lt, local_tp, local_l, new_fa, <nl> -					     NULL, l->key)) <nl> +					     NULL, l->key)) { <nl> +				kmem_cache_free(fn_alias_kmem, new_fa); <nl>  				goto out; <nl> +			} <nl>  		} <nl>   <nl>  		/* stop loop if key wrapped back to 0 */
@@ -299,11 +299,10 @@ static int tilcdc_irq_postinstall(struct drm_device *dev) <nl>  	struct tilcdc_drm_private *priv = dev->dev_private; <nl>   <nl>  	/* enable FIFO underflow irq: */ <nl> -	if (priv->rev == 1) { <nl> +	if (priv->rev == 1) <nl>  		tilcdc_set(dev, LCDC_RASTER_CTRL_REG, LCDC_V1_UNDERFLOW_INT_ENA); <nl> -	} else { <nl> +	else <nl>  		tilcdc_set(dev, LCDC_INT_ENABLE_SET_REG, LCDC_V2_UNDERFLOW_INT_ENA); <nl> -	} <nl>   <nl>  	return 0; <nl>  }
@@ -121,7 +121,7 @@ static int clk_cpu_on_set_rate(struct clk_hw *hwclk, unsigned long rate, <nl>  	if (!cpuclk->pmu_dfs) <nl>  		return -ENODEV; <nl>   <nl> -	cur_rate = __clk_get_rate(hwclk->clk); <nl> +	cur_rate = clk_hw_get_rate(hwclk); <nl>   <nl>  	reg = readl(cpuclk->reg_base + SYS_CTRL_CLK_DIVIDER_CTRL2_OFFSET); <nl>  	fabric_div = (reg >> SYS_CTRL_CLK_DIVIDER_CTRL2_NBCLK_RATIO_SHIFT) & <nl> @@ -197,7 +197,6 @@ static void __init of_cpu_clk_setup(struct device_node *node) <nl>  	for_each_node_by_type(dn, "cpu") { <nl>  		struct clk_init_data init; <nl>  		struct clk *clk; <nl> -		struct clk *parent_clk; <nl>  		char *clk_name = kzalloc(5, GFP_KERNEL); <nl>  		int cpu, err; <nl>   <nl> @@ -209,9 +208,8 @@ static void __init of_cpu_clk_setup(struct device_node *node) <nl>  			goto bail_out; <nl>   <nl>  		sprintf(clk_name, "cpu%d", cpu); <nl> -		parent_clk = of_clk_get(node, 0); <nl>   <nl> -		cpuclk[cpu].parent_name = __clk_get_name(parent_clk); <nl> +		cpuclk[cpu].parent_name = of_clk_get_parent_name(node, 0); <nl>  		cpuclk[cpu].clk_name = clk_name; <nl>  		cpuclk[cpu].cpu = cpu; <nl>  		cpuclk[cpu].reg_base = clock_complex_base;
@@ -309,7 +309,7 @@ static irqreturn_t mc13xxx_rtc_reset_handler(int irq, void *dev) <nl>  	return IRQ_HANDLED; <nl>  } <nl>   <nl> -static int __devinit mc13xxx_rtc_probe(struct platform_device *pdev) <nl> +static int __init mc13xxx_rtc_probe(struct platform_device *pdev) <nl>  { <nl>  	int ret; <nl>  	struct mc13xxx_rtc *priv; <nl> @@ -378,7 +378,7 @@ err_reset_irq_request: <nl>  	return ret; <nl>  } <nl>   <nl> -static int __devexit mc13xxx_rtc_remove(struct platform_device *pdev) <nl> +static int __exit mc13xxx_rtc_remove(struct platform_device *pdev) <nl>  { <nl>  	struct mc13xxx_rtc *priv = platform_get_drvdata(pdev); <nl>   <nl> @@ -410,7 +410,7 @@ const struct platform_device_id mc13xxx_rtc_idtable[] = { <nl>   <nl>  static struct platform_driver mc13xxx_rtc_driver = { <nl>  	.id_table = mc13xxx_rtc_idtable, <nl> -	.remove = __devexit_p(mc13xxx_rtc_remove), <nl> +	.remove = __exit_p(mc13xxx_rtc_remove), <nl>  	.driver = { <nl>  		.name = DRIVER_NAME, <nl>  		.owner = THIS_MODULE,
@@ -1330,7 +1330,8 @@ int btrfs_commit_transaction(struct btrfs_trans_handle *trans, <nl>  		spin_unlock(&root->fs_info->trans_lock); <nl>  	} <nl>   <nl> -	if (now < cur_trans->start_time || now - cur_trans->start_time < 1) <nl> +	if (!btrfs_test_opt(root, SSD) && <nl> +	    (now < cur_trans->start_time || now - cur_trans->start_time < 1)) <nl>  		should_grow = 1; <nl>   <nl>  	do {
@@ -188,7 +188,7 @@ void rds_ib_cm_connect_complete(struct rds_connection *conn, struct rdma_cm_even <nl>  		 * Since dp_ack_seq is 64-bit extended load operations can be <nl>  		 * used so go through get_unaligned to avoid unaligned errors. <nl>  		 */ <nl> -		u64 dp_ack_seq = get_unaligned(&dp->dp_ack_seq); <nl> +		__be64 dp_ack_seq = get_unaligned(&dp->dp_ack_seq); <nl>   <nl>  		if (dp_ack_seq) <nl>  			rds_send_drop_acked(conn, be64_to_cpu(dp_ack_seq),
@@ -533,6 +533,7 @@ static struct cl_lock *cl_lock_find(const struct lu_env *env, <nl>  			spin_lock(&head->coh_lock_guard); <nl>  			ghost = cl_lock_lookup(env, obj, io, need); <nl>  			if (ghost == NULL) { <nl> +				cl_lock_get_trust(lock); <nl>  				list_add_tail(&lock->cll_linkage, <nl>  						  &head->coh_locks); <nl>  				spin_unlock(&head->coh_lock_guard); <nl> @@ -791,15 +792,22 @@ static void cl_lock_delete0(const struct lu_env *env, struct cl_lock *lock) <nl>  	LINVRNT(cl_lock_invariant(env, lock)); <nl>   <nl>  	if (lock->cll_state < CLS_FREEING) { <nl> +		bool in_cache; <nl> + <nl>  		LASSERT(lock->cll_state != CLS_INTRANSIT); <nl>  		cl_lock_state_set(env, lock, CLS_FREEING); <nl>   <nl>  		head = cl_object_header(lock->cll_descr.cld_obj); <nl>   <nl>  		spin_lock(&head->coh_lock_guard); <nl> -		list_del_init(&lock->cll_linkage); <nl> +		in_cache = !list_empty(&lock->cll_linkage); <nl> +		if (in_cache) <nl> +			list_del_init(&lock->cll_linkage); <nl>  		spin_unlock(&head->coh_lock_guard); <nl>   <nl> +		if (in_cache) /* coh_locks cache holds a refcount. */ <nl> +			cl_lock_put(env, lock); <nl> + <nl>  		/* <nl>  		 * From now on, no new references to this lock can be acquired <nl>  		 * by cl_lock_lookup().
@@ -997,12 +997,16 @@ static bool vlv_c0_above(struct drm_i915_private *dev_priv, <nl>  			 int threshold) <nl>  { <nl>  	u64 time, c0; <nl> +	unsigned int mul = 100; <nl>   <nl>  	if (old->cz_clock == 0) <nl>  		return false; <nl>   <nl> +	if (I915_READ(VLV_COUNTER_CONTROL) & VLV_COUNT_RANGE_HIGH) <nl> +		mul <<= 8; <nl> + <nl>  	time = now->cz_clock - old->cz_clock; <nl> -	time *= threshold * dev_priv->mem_freq; <nl> +	time *= threshold * dev_priv->czclk_freq; <nl>   <nl>  	/* Workload can be split between render + media, e.g. SwapBuffers <nl>  	 * being blitted in X after being rendered in mesa. To account for <nl> @@ -1010,7 +1014,7 @@ static bool vlv_c0_above(struct drm_i915_private *dev_priv, <nl>  	 */ <nl>  	c0 = now->render_c0 - old->render_c0; <nl>  	c0 += now->media_c0 - old->media_c0; <nl> -	c0 *= 100 * VLV_CZ_CLOCK_TO_MILLI_SEC * 4 / 1000; <nl> +	c0 *= mul * VLV_CZ_CLOCK_TO_MILLI_SEC; <nl>   <nl>  	return c0 >= time; <nl>  }
@@ -2302,6 +2302,14 @@ int open_ctree(struct super_block *sb, <nl>  		goto fail_sb_buffer; <nl>  	} <nl>   <nl> +	if ((features & BTRFS_FEATURE_INCOMPAT_MIXED_GROUPS) && <nl> +			(leafsize != nodesize || sectorsize != nodesize)) { <nl> +		printk(KERN_WARNING "btrfs: unequal leaf/node/sector sizes " <nl> +				"are not allowed for mixed block groups on %s\n", <nl> +				sb->s_id); <nl> +		goto fail_sb_buffer; <nl> +	} <nl> + <nl>  	mutex_lock(&fs_info->chunk_mutex); <nl>  	ret = btrfs_read_sys_array(tree_root); <nl>  	mutex_unlock(&fs_info->chunk_mutex);
@@ -522,7 +522,7 @@ EXPORT_SYMBOL(genphy_read_status); <nl>   <nl>  static int genphy_config_init(struct phy_device *phydev) <nl>  { <nl> -	u32 val; <nl> +	int val; <nl>  	u32 features; <nl>   <nl>  	/* For now, I'll claim that the generic driver supports
@@ -693,7 +693,10 @@ bool kvm_irq_delivery_to_apic_fast(struct kvm *kvm, struct kvm_lapic *src, <nl>  	ret = true; <nl>   <nl>  	if (irq->dest_mode == 0) { /* physical mode */ <nl> -		dst = &map->phys_map[irq->dest_id & 0xff]; <nl> +		if (irq->dest_id >= ARRAY_SIZE(map->phys_map)) <nl> +			goto out; <nl> + <nl> +		dst = &map->phys_map[irq->dest_id]; <nl>  	} else { <nl>  		u32 mda = irq->dest_id << (32 - map->ldr_bits); <nl>  
@@ -24,10 +24,12 @@ static char *make_driver_name(struct device_driver *drv) <nl>   <nl>  static void module_create_drivers_dir(struct module_kobject *mk) <nl>  { <nl> -	if (!mk || mk->drivers_dir) <nl> -		return; <nl> +	static DEFINE_MUTEX(drivers_dir_mutex); <nl>   <nl> -	mk->drivers_dir = kobject_create_and_add("drivers", &mk->kobj); <nl> +	mutex_lock(&drivers_dir_mutex); <nl> +	if (mk && !mk->drivers_dir) <nl> +		mk->drivers_dir = kobject_create_and_add("drivers", &mk->kobj); <nl> +	mutex_unlock(&drivers_dir_mutex); <nl>  } <nl>   <nl>  void module_add_driver(struct module *mod, struct device_driver *drv)
@@ -37,8 +37,11 @@ nouveau_sgdma_populate(struct ttm_backend *be, unsigned long num_pages, <nl>  		return -ENOMEM; <nl>   <nl>  	nvbe->ttm_alloced = kmalloc(sizeof(bool) * num_pages, GFP_KERNEL); <nl> -	if (!nvbe->ttm_alloced) <nl> +	if (!nvbe->ttm_alloced) { <nl> +		kfree(nvbe->pages); <nl> +		nvbe->pages = NULL; <nl>  		return -ENOMEM; <nl> +	} <nl>   <nl>  	nvbe->nr_pages = 0; <nl>  	while (num_pages--) {
@@ -2159,7 +2159,7 @@ static void __wa_populate_buf_in_urb_isoc(struct wahc *wa, struct wa_xfer *xfer, <nl>  	wa->buf_in_urb->transfer_dma = xfer->urb->transfer_dma + <nl>  		xfer->urb->iso_frame_desc[curr_iso_frame].offset; <nl>  	wa->buf_in_urb->transfer_buffer_length = <nl> -		xfer->urb->iso_frame_desc[curr_iso_frame].length; <nl> +		xfer->urb->iso_frame_desc[curr_iso_frame].actual_length; <nl>  	wa->buf_in_urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP; <nl>  	wa->buf_in_urb->transfer_buffer = NULL; <nl>  	wa->buf_in_urb->sg = NULL;
@@ -1544,6 +1544,12 @@ struct sock *sk_clone_lock(const struct sock *sk, const gfp_t priority) <nl>  			is_charged = sk_filter_charge(newsk, filter); <nl>   <nl>  		if (unlikely(!is_charged || xfrm_sk_clone_policy(newsk, sk))) { <nl> +			/* We need to make sure that we don't uncharge the new <nl> +			 * socket if we couldn't charge it in the first place <nl> +			 * as otherwise we uncharge the parent's filter. <nl> +			 */ <nl> +			if (!is_charged) <nl> +				RCU_INIT_POINTER(newsk->sk_filter, NULL); <nl>  			sk_free_unlock_clone(newsk); <nl>  			newsk = NULL; <nl>  			goto out;
@@ -1035,6 +1035,8 @@ static struct omap_clk am33xx_clks[] = { <nl>  	CLK(NULL,	"pruss_ocp_gclk",	&pruss_ocp_gclk,	CK_AM33XX), <nl>  	CLK("davinci-mcasp.0",  NULL,           &mcasp0_fck,    CK_AM33XX), <nl>  	CLK("davinci-mcasp.1",  NULL,           &mcasp1_fck,    CK_AM33XX), <nl> +	CLK(NULL,	"mcasp0_fck",		&mcasp0_fck,	CK_AM33XX), <nl> +	CLK(NULL,	"mcasp1_fck",		&mcasp1_fck,	CK_AM33XX), <nl>  	CLK("NULL",	"mmc2_fck",		&mmc2_fck,	CK_AM33XX), <nl>  	CLK(NULL,	"mmu_fck",		&mmu_fck,	CK_AM33XX), <nl>  	CLK(NULL,	"smartreflex0_fck",	&smartreflex0_fck,	CK_AM33XX),
@@ -629,10 +629,13 @@ void <nl>  free_session(struct kref *kref) <nl>  { <nl>  	struct nfsd4_session *ses; <nl> +	int mem; <nl>   <nl>  	ses = container_of(kref, struct nfsd4_session, se_ref); <nl>  	spin_lock(&nfsd_drc_lock); <nl> -	nfsd_drc_mem_used -= ses->se_fchannel.maxreqs * NFSD_SLOT_CACHE_SIZE; <nl> +	mem = ses->se_fchannel.maxreqs <nl> +		* (ses->se_fchannel.maxresp_cached - NFSD_MIN_HDR_SEQ_SZ); <nl> +	nfsd_drc_mem_used -= mem; <nl>  	spin_unlock(&nfsd_drc_lock); <nl>  	free_session_slots(ses); <nl>  	kfree(ses);
@@ -1056,6 +1056,12 @@ static void lguest_load_sp0(struct tss_struct *tss, <nl>  } <nl>   <nl>  /* Let's just say, I wouldn't do debugging under a Guest. */ <nl> +static unsigned long lguest_get_debugreg(int regno) <nl> +{ <nl> +	/* FIXME: Implement */ <nl> +	return 0; <nl> +} <nl> + <nl>  static void lguest_set_debugreg(int regno, unsigned long value) <nl>  { <nl>  	/* FIXME: Implement */ <nl> @@ -1303,6 +1309,7 @@ __init void lguest_init(void) <nl>  	pv_cpu_ops.load_tr_desc = lguest_load_tr_desc; <nl>  	pv_cpu_ops.set_ldt = lguest_set_ldt; <nl>  	pv_cpu_ops.load_tls = lguest_load_tls; <nl> +	pv_cpu_ops.get_debugreg = lguest_get_debugreg; <nl>  	pv_cpu_ops.set_debugreg = lguest_set_debugreg; <nl>  	pv_cpu_ops.clts = lguest_clts; <nl>  	pv_cpu_ops.read_cr0 = lguest_read_cr0;
@@ -884,7 +884,7 @@ static struct platform_driver sport_uart_driver = { <nl>  }; <nl>   <nl>  #ifdef CONFIG_SERIAL_BFIN_SPORT_CONSOLE <nl> -static __initdata struct early_platform_driver early_sport_uart_driver = { <nl> +static struct early_platform_driver early_sport_uart_driver __initdata = { <nl>  	.class_str = CLASS_BFIN_SPORT_CONSOLE, <nl>  	.pdrv = &sport_uart_driver, <nl>  	.requested_id = EARLY_PLATFORM_ID_UNSET,
@@ -330,6 +330,7 @@ static int s3c_fb_check_var(struct fb_var_screeninfo *var, <nl>   <nl>  	default: <nl>  		dev_err(sfb->dev, "invalid bpp\n"); <nl> +		return -EINVAL; <nl>  	} <nl>   <nl>  	dev_dbg(sfb->dev, "%s: verified parameters\n", __func__);
@@ -25,6 +25,9 @@ unsigned int oz_dbg_mask = OZ_DEFAULT_DBG_MASK; <nl>   * netcards. Bindings can be added later using an IOCTL. <nl>   */ <nl>  static char *g_net_dev = ""; <nl> +module_param(g_net_dev, charp, S_IRUGO); <nl> +MODULE_PARM_DESC(g_net_dev, "The device(s) to bind to; " <nl> +	"'*' means all, '' (empty string; default) means none."); <nl>   <nl>  /* <nl>   * Context: process <nl> @@ -48,7 +51,6 @@ static void __exit ozwpan_exit(void) <nl>  	oz_cdev_deregister(); <nl>  } <nl>   <nl> -module_param(g_net_dev, charp, S_IRUGO); <nl>  module_init(ozwpan_init); <nl>  module_exit(ozwpan_exit); <nl>  
@@ -75,6 +75,7 @@ <nl>  #define LSS_PWS_BITS		2	/* power state width */ <nl>   <nl>  /* Supported device IDs */ <nl> +#define PCI_DEVICE_ID_PENWELL	0x0828 <nl>  #define PCI_DEVICE_ID_TANGIER	0x11a1 <nl>   <nl>  struct mid_pwr_dev { <nl> @@ -354,7 +355,7 @@ static int mid_pwr_probe(struct pci_dev *pdev, const struct pci_device_id *id) <nl>  	return 0; <nl>  } <nl>   <nl> -static int tng_set_initial_state(struct mid_pwr *pwr) <nl> +static int mid_set_initial_state(struct mid_pwr *pwr) <nl>  { <nl>  	unsigned int i, j; <nl>  	int ret; <nl> @@ -397,12 +398,13 @@ static int tng_set_initial_state(struct mid_pwr *pwr) <nl>  	return 0; <nl>  } <nl>   <nl> -static const struct mid_pwr_device_info tng_info = { <nl> -	.set_initial_state = tng_set_initial_state, <nl> +static const struct mid_pwr_device_info mid_info = { <nl> +	.set_initial_state = mid_set_initial_state, <nl>  }; <nl>   <nl>  static const struct pci_device_id mid_pwr_pci_ids[] = { <nl> -	{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_TANGIER), (kernel_ulong_t)&tng_info }, <nl> +	{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_PENWELL), (kernel_ulong_t)&mid_info }, <nl> +	{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_TANGIER), (kernel_ulong_t)&mid_info }, <nl>  	{} <nl>  }; <nl>  MODULE_DEVICE_TABLE(pci, mid_pwr_pci_ids);
@@ -237,6 +237,7 @@ struct mei_device { <nl>  	bool mei_host_buffer_is_empty; <nl>   <nl>  	struct mei_cl wd_cl; <nl> +	bool wd_interface_reg; <nl>  	bool wd_pending; <nl>  	bool wd_stopped; <nl>  	bool wd_bypass;	/* if false, don't refresh watchdog ME client */ <nl> @@ -245,7 +246,6 @@ struct mei_device { <nl>  	unsigned char wd_data[MEI_START_WD_DATA_SIZE]; <nl>   <nl>   <nl> - <nl>  	struct file *iamthif_file_object; <nl>  	struct mei_cl iamthif_cl; <nl>  	struct mei_cl_cb *iamthif_current_cb; <nl> @@ -259,8 +259,6 @@ struct mei_device { <nl>  	bool iamthif_flow_control_pending; <nl>  	bool iamthif_ioctl; <nl>  	bool iamthif_canceled; <nl> - <nl> -	bool wd_interface_reg; <nl>  }; <nl>   <nl>  
@@ -734,7 +734,7 @@ static int spi_qup_remove(struct platform_device *pdev) <nl>  	int ret; <nl>   <nl>  	ret = pm_runtime_get_sync(&pdev->dev); <nl> -	if (ret) <nl> +	if (ret < 0) <nl>  		return ret; <nl>   <nl>  	ret = spi_qup_set_state(controller, QUP_STATE_RESET);
@@ -1110,6 +1110,7 @@ static void cfq_dispatch_insert(struct request_queue *q, struct request *rq) <nl>   <nl>  	cfq_log_cfqq(cfqd, cfqq, "dispatch_insert"); <nl>   <nl> +	cfqq->next_rq = cfq_find_next_rq(cfqd, cfqq, rq); <nl>  	cfq_remove_request(rq); <nl>  	cfqq->dispatched++; <nl>  	elv_dispatch_sort(q, rq);
@@ -473,7 +473,14 @@ static int dm9000_nway_reset(struct net_device *dev) <nl>  static u32 dm9000_get_link(struct net_device *dev) <nl>  { <nl>  	board_info_t *dm = to_dm9000_board(dev); <nl> -	return mii_link_ok(&dm->mii); <nl> +	u32 ret; <nl> + <nl> +	if (dm->flags & DM9000_PLATF_EXT_PHY) <nl> +		ret = mii_link_ok(&dm->mii); <nl> +	else <nl> +		ret = dm9000_read_locked(dm, DM9000_NSR) & NSR_LINKST ? 1 : 0; <nl> + <nl> +	return ret; <nl>  } <nl>   <nl>  #define DM_EEPROM_MAGIC		(0x444D394B)
@@ -120,8 +120,10 @@ static unsigned int ipv4_confirm(unsigned int hooknum, <nl>  		typeof(nf_nat_seq_adjust_hook) seq_adjust; <nl>   <nl>  		seq_adjust = rcu_dereference(nf_nat_seq_adjust_hook); <nl> -		if (!seq_adjust || !seq_adjust(skb, ct, ctinfo)) <nl> +		if (!seq_adjust || !seq_adjust(skb, ct, ctinfo)) { <nl> +			NF_CT_STAT_INC_ATOMIC(nf_ct_net(ct), drop); <nl>  			return NF_DROP; <nl> +		} <nl>  	} <nl>  out: <nl>  	/* We've seen it coming out the other side: confirm it */
@@ -507,7 +507,9 @@ static int gfs2_commit_write(struct file *file, struct page *page, <nl>  		gfs2_quota_unlock(ip); <nl>  		gfs2_alloc_put(ip); <nl>  	} <nl> +	unlock_page(page); <nl>  	gfs2_glock_dq_m(1, &ip->i_gh); <nl> +	lock_page(page); <nl>  	gfs2_holder_uninit(&ip->i_gh); <nl>  	return 0; <nl>   <nl> @@ -520,7 +522,9 @@ fail_endtrans: <nl>  		gfs2_quota_unlock(ip); <nl>  		gfs2_alloc_put(ip); <nl>  	} <nl> +	unlock_page(page); <nl>  	gfs2_glock_dq_m(1, &ip->i_gh); <nl> +	lock_page(page); <nl>  	gfs2_holder_uninit(&ip->i_gh); <nl>  fail_nounlock: <nl>  	ClearPageUptodate(page);
@@ -8101,7 +8101,7 @@ static void nl80211_send_remain_on_chan_event( <nl>  	if (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) || <nl>  	    (wdev->netdev && nla_put_u32(msg, NL80211_ATTR_IFINDEX, <nl>  					 wdev->netdev->ifindex)) || <nl> -	    nla_put_u32(msg, NL80211_ATTR_WDEV, wdev_id(wdev)) || <nl> +	    nla_put_u64(msg, NL80211_ATTR_WDEV, wdev_id(wdev)) || <nl>  	    nla_put_u32(msg, NL80211_ATTR_WIPHY_FREQ, chan->center_freq) || <nl>  	    nla_put_u32(msg, NL80211_ATTR_WIPHY_CHANNEL_TYPE, channel_type) || <nl>  	    nla_put_u64(msg, NL80211_ATTR_COOKIE, cookie))
@@ -992,7 +992,7 @@ static int wm8993_set_bias_level(struct snd_soc_codec *codec, <nl>  		break; <nl>   <nl>  	case SND_SOC_BIAS_STANDBY: <nl> -		if (codec->dapm.bias_level == SND_SOC_BIAS_OFF) { <nl> +		if (snd_soc_codec_get_bias_level(codec) == SND_SOC_BIAS_OFF) { <nl>  			ret = regulator_bulk_enable(ARRAY_SIZE(wm8993->supplies), <nl>  						    wm8993->supplies); <nl>  			if (ret != 0) <nl> @@ -1483,7 +1483,7 @@ static struct snd_soc_dai_driver wm8993_dai = { <nl>  static int wm8993_probe(struct snd_soc_codec *codec) <nl>  { <nl>  	struct wm8993_priv *wm8993 = snd_soc_codec_get_drvdata(codec); <nl> -	struct snd_soc_dapm_context *dapm = &codec->dapm; <nl> +	struct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec); <nl>   <nl>  	wm8993->hubs_data.hp_startup_mode = 1; <nl>  	wm8993->hubs_data.dcs_codes_l = -2; <nl> @@ -1537,7 +1537,7 @@ static int wm8993_probe(struct snd_soc_codec *codec) <nl>  	 * VMID as an output and can disable it. <nl>  	 */ <nl>  	if (wm8993->pdata.lineout1_diff && wm8993->pdata.lineout2_diff) <nl> -		codec->dapm.idle_bias_off = 1; <nl> +		dapm->idle_bias_off = 1; <nl>   <nl>  	return 0; <nl>  
@@ -459,7 +459,12 @@ static int logger_release(struct inode *ignored, struct file *file) <nl>  { <nl>  	if (file->f_mode & FMODE_READ) { <nl>  		struct logger_reader *reader = file->private_data; <nl> +		struct logger_log *log = reader->log; <nl> + <nl> +		mutex_lock(&log->mutex); <nl>  		list_del(&reader->list); <nl> +		mutex_unlock(&log->mutex); <nl> + <nl>  		kfree(reader); <nl>  	} <nl>  
@@ -1221,6 +1221,8 @@ static int gb_lights_probe(struct gb_bundle *bundle, <nl>  	if (!glights) <nl>  		return -ENOMEM; <nl>   <nl> +	mutex_init(&glights->lights_lock); <nl> + <nl>  	connection = gb_connection_create(bundle, le16_to_cpu(cport_desc->id), <nl>  					  gb_lights_request_handler); <nl>  	if (IS_ERR(connection)) { <nl> @@ -1231,8 +1233,6 @@ static int gb_lights_probe(struct gb_bundle *bundle, <nl>  	glights->connection = connection; <nl>  	gb_connection_set_data(connection, glights); <nl>   <nl> -	mutex_init(&glights->lights_lock); <nl> - <nl>  	greybus_set_drvdata(bundle, glights); <nl>   <nl>  	/* We aren't ready to receive an incoming request yet */
@@ -67,14 +67,12 @@ static void _rtl88e_fw_block_write(struct adapter *adapt, <nl>   <nl>  	offset = FW_8192C_START_ADDRESS; <nl>   <nl> -	for (i = 0; i < blk_cnt; i++, offset += blk_sz) { <nl> +	for (i = 0; i < blk_cnt; i++, offset += blk_sz) <nl>  		usb_write32(adapt, offset, pu4BytePtr[i]); <nl> -	} <nl>   <nl>  	buf_ptr = buffer + blk_cnt * blk_sz; <nl> -	for (i = 0; i < remain; i++, offset++) { <nl> +	for (i = 0; i < remain; i++, offset++) <nl>  		usb_write8(adapt, offset, buf_ptr[i]); <nl> -	} <nl>  } <nl>   <nl>  static void _rtl88e_fill_dummy(u8 *pfwbuf, u32 *pfwlen)
@@ -1470,7 +1470,7 @@ static int set_dev_class(struct sock *sk, u16 index, void *data, u16 len) <nl>   <nl>  	if (err == 0) <nl>  		err = cmd_complete(sk, index, MGMT_OP_SET_DEV_CLASS, 0, <nl> -								NULL, 0); <nl> +							hdev->dev_class, 3); <nl>   <nl>  unlock: <nl>  	hci_dev_unlock(hdev);
@@ -993,6 +993,8 @@ static void eeh_handle_special_event(void) <nl>   <nl>  				/* Notify all devices to be down */ <nl>  				eeh_pe_state_clear(pe, EEH_PE_PRI_BUS); <nl> +				eeh_pe_dev_traverse(pe, <nl> +					eeh_report_failure, NULL); <nl>  				bus = eeh_pe_bus_get(phb_pe); <nl>  				if (!bus) { <nl>  					pr_err("%s: Cannot find PCI bus for " <nl> @@ -1002,8 +1004,6 @@ static void eeh_handle_special_event(void) <nl>  					       pe->addr); <nl>  					break; <nl>  				} <nl> -				eeh_pe_dev_traverse(pe, <nl> -					eeh_report_failure, NULL); <nl>  				pci_hp_remove_devices(bus); <nl>  			} <nl>  			pci_unlock_rescan_remove();
@@ -69,7 +69,7 @@ const struct imx_imx_ssi_data imx35_imx_ssi_data[] __initconst = { <nl>  #ifdef CONFIG_SOC_IMX51 <nl>  const struct imx_imx_ssi_data imx51_imx_ssi_data[] __initconst = { <nl>  #define imx51_imx_ssi_data_entry(_id, _hwid)				\ <nl> -	imx_imx_ssi_data_entry(MX51, _id, _hwid, SZ_4K) <nl> +	imx_imx_ssi_data_entry(MX51, _id, _hwid, SZ_16K) <nl>  	imx51_imx_ssi_data_entry(0, 1), <nl>  	imx51_imx_ssi_data_entry(1, 2), <nl>  	imx51_imx_ssi_data_entry(2, 3),
@@ -93,6 +93,7 @@ static int btmtk_usb_io_read32(struct btmtk_usb_data *data, u32 reg, u32 *val) <nl>  	u8 request = data->r_request; <nl>  	struct usb_device *udev = data->udev; <nl>  	int ret; <nl> +	__le32 val_le; <nl>   <nl>  	ret = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0), request, <nl>  			DEVICE_VENDOR_REQUEST_IN, 0x0, reg, data->io_buf, <nl> @@ -105,9 +106,9 @@ static int btmtk_usb_io_read32(struct btmtk_usb_data *data, u32 reg, u32 *val) <nl>  		return ret; <nl>  	} <nl>   <nl> -	memmove(val, data->io_buf, 4); <nl> +	memmove(&val_le, data->io_buf, 4); <nl>   <nl> -	*val = le32_to_cpu(*val); <nl> +	*val = le32_to_cpu(val_le); <nl>   <nl>  	if (ret > 0) <nl>  		ret = 0; <nl> @@ -280,6 +281,7 @@ static u16 btmtk_usb_get_crc(struct btmtk_usb_data *data) <nl>  	int ret = 0; <nl>  	struct usb_device *udev = data->udev; <nl>  	u16 crc, count = 0; <nl> +	__le16 crc_le; <nl>   <nl>  	BT_DBG("%s\n", __func__); <nl>   <nl> @@ -294,9 +296,9 @@ static u16 btmtk_usb_get_crc(struct btmtk_usb_data *data) <nl>  			BT_ERR("%s error(%d)\n", __func__, ret); <nl>  		} <nl>   <nl> -		memmove(&crc, data->io_buf, 2); <nl> +		memmove(&crc_le, data->io_buf, 2); <nl>   <nl> -		crc = le16_to_cpu(crc); <nl> +		crc = le16_to_cpu(crc_le); <nl>   <nl>  		if (crc != 0xFFFF) <nl>  			break;
@@ -32,6 +32,7 @@ <nl>  #include <linux/kmod.h> <nl>  #include <linux/slab.h> <nl>  #include <linux/module.h> <nl> +#include <linux/etherdevice.h> <nl>   <nl>  #include "ieee80211.h" <nl>  static const char *ieee80211_modes[] = { <nl> @@ -53,7 +54,7 @@ static inline char *rtl818x_translate_scan(struct ieee80211_device *ieee, <nl>  	/* First entry *MUST* be the AP MAC address */ <nl>  	iwe.cmd = SIOCGIWAP; <nl>  	iwe.u.ap_addr.sa_family = ARPHRD_ETHER; <nl> -	memcpy(iwe.u.ap_addr.sa_data, network->bssid, ETH_ALEN); <nl> +	ether_addr_copy(iwe.u.ap_addr.sa_data, network->bssid); <nl>  	start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_ADDR_LEN); <nl>   <nl>  	/* Remaining entries will be displayed in the order we provide them */
@@ -661,7 +661,7 @@ static struct zonelist *zonelist_policy(unsigned int __nocast gfp, struct mempol <nl>  	case MPOL_BIND: <nl>  		/* Lower zones don't get a policy applied */ <nl>  		/* Careful: current->mems_allowed might have moved */ <nl> -		if (gfp >= policy_zone) <nl> +		if ((gfp & GFP_ZONEMASK) >= policy_zone) <nl>  			if (cpuset_zonelist_valid_mems_allowed(policy->v.zonelist)) <nl>  				return policy->v.zonelist; <nl>  		/*FALL THROUGH*/
@@ -86,10 +86,12 @@ static void tty_audit_buf_push(struct task_struct *tsk, uid_t loginuid, <nl>  	ab = audit_log_start(NULL, GFP_KERNEL, AUDIT_TTY); <nl>  	if (ab) { <nl>  		char name[sizeof(tsk->comm)]; <nl> +		uid_t uid = task_uid(tsk); <nl>   <nl>  		audit_log_format(ab, "tty pid=%u uid=%u auid=%u ses=%u " <nl> -				 "major=%d minor=%d comm=", tsk->pid, tsk->uid, <nl> -				 loginuid, sessionid, buf->major, buf->minor); <nl> +				 "major=%d minor=%d comm=", <nl> +				 tsk->pid, uid, loginuid, sessionid, <nl> +				 buf->major, buf->minor); <nl>  		get_task_comm(name, tsk); <nl>  		audit_log_untrustedstring(ab, name); <nl>  		audit_log_format(ab, " data=");
@@ -734,9 +734,12 @@ static void mxs_auart_reset(struct uart_port *u) <nl>   <nl>  static int mxs_auart_startup(struct uart_port *u) <nl>  { <nl> +	int ret; <nl>  	struct mxs_auart_port *s = to_auart_port(u); <nl>   <nl> -	clk_prepare_enable(s->clk); <nl> +	ret = clk_prepare_enable(s->clk); <nl> +	if (ret) <nl> +		return ret; <nl>   <nl>  	writel(AUART_CTRL0_CLKGATE, u->membase + AUART_CTRL0_CLR); <nl>   <nl> @@ -957,7 +960,9 @@ auart_console_setup(struct console *co, char *options) <nl>  	if (!s) <nl>  		return -ENODEV; <nl>   <nl> -	clk_prepare_enable(s->clk); <nl> +	ret = clk_prepare_enable(s->clk); <nl> +	if (ret) <nl> +		return ret; <nl>   <nl>  	if (options) <nl>  		uart_parse_options(options, &baud, &parity, &bits, &flow);
@@ -2636,8 +2636,11 @@ static int vxlan_dev_configure(struct net *src_net, struct net_device *dev, <nl>  		dst->remote_ip.sa.sa_family = AF_INET; <nl>   <nl>  	if (dst->remote_ip.sa.sa_family == AF_INET6 || <nl> -	    vxlan->cfg.saddr.sa.sa_family == AF_INET6) <nl> +	    vxlan->cfg.saddr.sa.sa_family == AF_INET6) { <nl> +		if (!IS_ENABLED(CONFIG_IPV6)) <nl> +			return -EPFNOSUPPORT; <nl>  		use_ipv6 = true; <nl> +	} <nl>   <nl>  	if (conf->remote_ifindex) { <nl>  		struct net_device *lowerdev
@@ -544,7 +544,8 @@ static int ahash_prepare_alg(struct ahash_alg *alg) <nl>  	struct crypto_alg *base = &alg->halg.base; <nl>   <nl>  	if (alg->halg.digestsize > PAGE_SIZE / 8 || <nl> -	    alg->halg.statesize > PAGE_SIZE / 8) <nl> +	    alg->halg.statesize > PAGE_SIZE / 8 || <nl> +	    alg->halg.statesize == 0) <nl>  		return -EINVAL; <nl>   <nl>  	base->cra_type = &crypto_ahash_type;
@@ -112,13 +112,13 @@ struct ifmcaddr6 <nl>  	struct ip6_sf_list	*mca_sources; <nl>  	struct ip6_sf_list	*mca_tomb; <nl>  	unsigned int		mca_sfmode; <nl> +	unsigned char		mca_crcount; <nl>  	unsigned long		mca_sfcount[2]; <nl>  	struct timer_list	mca_timer; <nl>  	unsigned		mca_flags; <nl>  	int			mca_users; <nl>  	atomic_t		mca_refcnt; <nl>  	spinlock_t		mca_lock; <nl> -	unsigned char		mca_crcount; <nl>  	unsigned long		mca_cstamp; <nl>  	unsigned long		mca_tstamp; <nl>  };
@@ -836,14 +836,16 @@ static void ieee80211_do_stop(struct ieee80211_sub_if_data *sdata, <nl>  		rcu_barrier(); <nl>  		sta_info_flush_cleanup(sdata); <nl>   <nl> -		skb_queue_purge(&sdata->skb_queue); <nl> - <nl>  		/* <nl>  		 * Free all remaining keys, there shouldn't be any, <nl>  		 * except maybe in WDS mode? <nl>  		 */ <nl>  		ieee80211_free_keys(sdata); <nl>   <nl> +		/* fall through */ <nl> +	case NL80211_IFTYPE_AP: <nl> +		skb_queue_purge(&sdata->skb_queue); <nl> + <nl>  		drv_remove_interface_debugfs(local, sdata); <nl>   <nl>  		if (going_down)
@@ -1551,15 +1551,11 @@ void fm10k_down(struct fm10k_intfc *interface) <nl>  static int fm10k_sw_init(struct fm10k_intfc *interface, <nl>  			 const struct pci_device_id *ent) <nl>  { <nl> -	static const u32 seed[FM10K_RSSRK_SIZE] = { 0xda565a6d, 0xc20e5b25, <nl> -						    0x3d256741, 0xb08fa343, <nl> -						    0xcb2bcad0, 0xb4307bae, <nl> -						    0xa32dcb77, 0x0cf23080, <nl> -						    0x3bb7426a, 0xfa01acbe }; <nl>  	const struct fm10k_info *fi = fm10k_info_tbl[ent->driver_data]; <nl>  	struct fm10k_hw *hw = &interface->hw; <nl>  	struct pci_dev *pdev = interface->pdev; <nl>  	struct net_device *netdev = interface->netdev; <nl> +	u32 rss_key[FM10K_RSSRK_SIZE]; <nl>  	unsigned int rss; <nl>  	int err; <nl>   <nl> @@ -1673,8 +1669,8 @@ static int fm10k_sw_init(struct fm10k_intfc *interface, <nl>  	/* initialize vxlan_port list */ <nl>  	INIT_LIST_HEAD(&interface->vxlan_port); <nl>   <nl> -	/* initialize RSS key */ <nl> -	memcpy(interface->rssrk, seed, sizeof(seed)); <nl> +	netdev_rss_key_fill(rss_key, sizeof(rss_key)); <nl> +	memcpy(interface->rssrk, rss_key, sizeof(rss_key)); <nl>   <nl>  	/* Start off interface as being down */ <nl>  	set_bit(__FM10K_DOWN, &interface->state);
@@ -95,7 +95,7 @@ <nl>  * slc_tac register definitions <nl>  **********************************************************************/ <nl>  /* Computation of clock cycles on basis of controller and device clock rates */ <nl> -#define SLCTAC_CLOCKS(c, n, s)	(min_t(u32, 1 + (c / n), 0xF) << s) <nl> +#define SLCTAC_CLOCKS(c, n, s)	(min_t(u32, DIV_ROUND_UP(c, n) - 1, 0xF) << s) <nl>   <nl>  /* Clock setting for RDY write sample wait time in 2*n clocks */ <nl>  #define SLCTAC_WDR(n)		(((n) & 0xF) << 28)
@@ -209,8 +209,10 @@ static __be32 nfsd_set_fh_dentry(struct svc_rqst *rqstp, struct svc_fh *fhp) <nl>  		 * fix that case easily. <nl>  		 */ <nl>  		struct cred *new = prepare_creds(); <nl> -		if (!new) <nl> -			return nfserrno(-ENOMEM); <nl> +		if (!new) { <nl> +			error =  nfserrno(-ENOMEM); <nl> +			goto out; <nl> +		} <nl>  		new->cap_effective = <nl>  			cap_raise_nfsd_set(new->cap_effective, <nl>  					   new->cap_permitted);
@@ -469,8 +469,8 @@ pptp_inbound_pkt(struct sk_buff **pskb, <nl>  			DEBUGP("%s but no session\n", pptp_msg_name[msg]); <nl>  			break; <nl>  		} <nl> -		if (info->sstate != PPTP_CALL_IN_REP <nl> -		    && info->sstate != PPTP_CALL_IN_CONF) { <nl> +		if (info->cstate != PPTP_CALL_IN_REP <nl> +		    && info->cstate != PPTP_CALL_IN_CONF) { <nl>  			DEBUGP("%s but never sent IN_CALL_REPLY\n", <nl>  				pptp_msg_name[msg]); <nl>  			break;
@@ -53,10 +53,10 @@ static struct sg_table *omap_gem_map_dma_buf( <nl>  	/* this should be after _get_paddr() to ensure we have pages attached */ <nl>  	omap_gem_dma_sync(obj, dir); <nl>   <nl> -out: <nl> -	if (ret) <nl> -		return ERR_PTR(ret); <nl>  	return sg; <nl> +out: <nl> +	kfree(sg); <nl> +	return ERR_PTR(ret); <nl>  } <nl>   <nl>  static void omap_gem_unmap_dma_buf(struct dma_buf_attachment *attachment,
@@ -697,6 +697,13 @@ static void au1xmmc_request(struct mmc_host* mmc, struct mmc_request* mrq) <nl>  	host->mrq = mrq; <nl>  	host->status = HOST_S_CMD; <nl>   <nl> +	/* fail request immediately if no card is present */ <nl> +	if (0 == au1xmmc_card_inserted(host)) { <nl> +		mrq->cmd->error = -ENOMEDIUM; <nl> +		au1xmmc_finish_request(host); <nl> +		return; <nl> +	} <nl> + <nl>  	if (mrq->data) { <nl>  		FLUSH_FIFO(host); <nl>  		ret = au1xmmc_prepare_data(host, mrq->data);
@@ -90,7 +90,7 @@ static struct tegra_ictlr_info *lic; <nl>   <nl>  static inline void tegra_ictlr_write_mask(struct irq_data *d, unsigned long reg) <nl>  { <nl> -	void __iomem *base = d->chip_data; <nl> +	void __iomem *base = (void __iomem __force *)d->chip_data; <nl>  	u32 mask; <nl>   <nl>  	mask = BIT(d->hwirq % 32); <nl> @@ -266,7 +266,7 @@ static int tegra_ictlr_domain_alloc(struct irq_domain *domain, <nl>   <nl>  		irq_domain_set_hwirq_and_chip(domain, virq + i, hwirq + i, <nl>  					      &tegra_ictlr_chip, <nl> -					      info->base[ictlr]); <nl> +					      (void __force *)info->base[ictlr]); <nl>  	} <nl>   <nl>  	parent_fwspec = *fwspec;
@@ -53,7 +53,7 @@ static int ir_rc5_decode(struct rc_dev *dev, struct ir_raw_event ev) <nl>  	u32 scancode; <nl>  	enum rc_type protocol; <nl>   <nl> -	if (!(dev->enabled_protocols & (RC_BIT_RC5 | RC_BIT_RC5X))) <nl> +	if (!(dev->enabled_protocols & (RC_BIT_RC5 | RC_BIT_RC5X | RC_BIT_RC5_SZ))) <nl>  		return 0; <nl>   <nl>  	if (!is_timing_event(ev)) {
@@ -100,10 +100,10 @@ static inline void handle_pairwise_key(struct sta_info *psta, <nl>  	memcpy(psta->x_UncstKey.skey, param->u.crypt.key, <nl>  	       (param->u.crypt. key_len > 16 ? 16 : param->u.crypt.key_len)); <nl>  	if (strcmp(param->u.crypt.alg, "TKIP") == 0) { /* set mic key */ <nl> -		memcpy(psta->tkiptxmickey. skey, &(param->u.crypt. <nl> -			key[16]), 8); <nl> -		memcpy(psta->tkiprxmickey. skey, &(param->u.crypt. <nl> -			key[24]), 8); <nl> +		memcpy(psta->tkiptxmickey. skey, <nl> +		       &(param->u.crypt.key[16]), 8); <nl> +		memcpy(psta->tkiprxmickey. skey, <nl> +		       &(param->u.crypt.key[24]), 8); <nl>  		padapter->securitypriv. busetkipkey = false; <nl>  		mod_timer(&padapter->securitypriv.tkip_timer, <nl>  			  jiffies + msecs_to_jiffies(50));
@@ -1644,7 +1644,10 @@ static void reset_terminal(struct vc_data *vc, int do_clear) <nl>  	vc->vc_tab_stop[1]	= <nl>  	vc->vc_tab_stop[2]	= <nl>  	vc->vc_tab_stop[3]	= <nl> -	vc->vc_tab_stop[4]	= 0x01010101; <nl> +	vc->vc_tab_stop[4]	= <nl> +	vc->vc_tab_stop[5]	= <nl> +	vc->vc_tab_stop[6]	= <nl> +	vc->vc_tab_stop[7]	= 0x01010101; <nl>   <nl>  	vc->vc_bell_pitch = DEFAULT_BELL_PITCH; <nl>  	vc->vc_bell_duration = DEFAULT_BELL_DURATION; <nl> @@ -1935,7 +1938,10 @@ static void do_con_trol(struct tty_struct *tty, struct vc_data *vc, int c) <nl>  					vc->vc_tab_stop[1] = <nl>  					vc->vc_tab_stop[2] = <nl>  					vc->vc_tab_stop[3] = <nl> -					vc->vc_tab_stop[4] = 0; <nl> +					vc->vc_tab_stop[4] = <nl> +					vc->vc_tab_stop[5] = <nl> +					vc->vc_tab_stop[6] = <nl> +					vc->vc_tab_stop[7] = 0; <nl>  			} <nl>  			return; <nl>  		case 'm':
@@ -2887,6 +2887,7 @@ static int pl330_dma_device_slave_caps(struct dma_chan *dchan, <nl>  	caps->directions = BIT(DMA_DEV_TO_MEM) | BIT(DMA_MEM_TO_DEV); <nl>  	caps->cmd_pause = false; <nl>  	caps->cmd_terminate = true; <nl> +	caps->residue_granularity = DMA_RESIDUE_GRANULARITY_DESCRIPTOR; <nl>   <nl>  	return 0; <nl>  }
@@ -528,14 +528,14 @@ find_prev_fhdr(struct sk_buff *skb, u8 *prevhdrp, int *prevhoff, int *fhoff) <nl>  		if (!ipv6_ext_hdr(nexthdr)) { <nl>  			return -1; <nl>  		} <nl> -		if (len < (int)sizeof(struct ipv6_opt_hdr)) { <nl> -			pr_debug("too short\n"); <nl> -			return -1; <nl> -		} <nl>  		if (nexthdr == NEXTHDR_NONE) { <nl>  			pr_debug("next header is none\n"); <nl>  			return -1; <nl>  		} <nl> +		if (len < (int)sizeof(struct ipv6_opt_hdr)) { <nl> +			pr_debug("too short\n"); <nl> +			return -1; <nl> +		} <nl>  		if (skb_copy_bits(skb, start, &hdr, sizeof(hdr))) <nl>  			BUG(); <nl>  		if (nexthdr == NEXTHDR_AUTH)
@@ -534,8 +534,10 @@ static int i915_drm_freeze(struct drm_device *dev) <nl>  		 * Disable CRTCs directly since we want to preserve sw state <nl>  		 * for _thaw. <nl>  		 */ <nl> +		mutex_lock(&dev->mode_config.mutex); <nl>  		list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) <nl>  			dev_priv->display.crtc_disable(crtc); <nl> +		mutex_unlock(&dev->mode_config.mutex); <nl>   <nl>  		intel_modeset_suspend_hw(dev); <nl>  	}
@@ -207,6 +207,9 @@ s32 fm10k_disable_queues_generic(struct fm10k_hw *hw, u16 q_cnt) <nl>  	/* clear tx_ready to prevent any false hits for reset */ <nl>  	hw->mac.tx_ready = false; <nl>   <nl> +	if (FM10K_REMOVED(hw->hw_addr)) <nl> +		return 0; <nl> + <nl>  	/* clear the enable bit for all rings */ <nl>  	for (i = 0; i < q_cnt; i++) { <nl>  		reg = fm10k_read_reg(hw, FM10K_TXDCTL(i));
@@ -371,6 +371,8 @@ struct mmc_host *mmc_alloc_host(int extra, struct device *dev) <nl>   <nl>  	if (mmc_gpio_alloc(host)) { <nl>  		put_device(&host->class_dev); <nl> +		ida_simple_remove(&mmc_host_ida, host->index); <nl> +		kfree(host); <nl>  		return NULL; <nl>  	} <nl>  
@@ -693,10 +693,11 @@ i40e_status i40e_nvmupd_command(struct i40e_hw *hw, <nl>  	/* early check for status command and debug msgs */ <nl>  	upd_cmd = i40e_nvmupd_validate_command(hw, cmd, perrno); <nl>   <nl> -	i40e_debug(hw, I40E_DEBUG_NVM, "%s state %d nvm_release_on_hold %d\n", <nl> +	i40e_debug(hw, I40E_DEBUG_NVM, "%s state %d nvm_release_on_hold %d cmd 0x%08x config 0x%08x offset 0x%08x data_size 0x%08x\n", <nl>  		   i40e_nvm_update_state_str[upd_cmd], <nl>  		   hw->nvmupd_state, <nl> -		   hw->aq.nvm_release_on_done); <nl> +		   hw->aq.nvm_release_on_done, <nl> +		   cmd->command, cmd->config, cmd->offset, cmd->data_size); <nl>   <nl>  	if (upd_cmd == I40E_NVMUPD_INVALID) { <nl>  		*perrno = -EFAULT;
@@ -241,7 +241,7 @@ static int sha384_neon_final(struct shash_desc *desc, u8 *hash) <nl>  	sha512_neon_final(desc, D); <nl>   <nl>  	memcpy(hash, D, SHA384_DIGEST_SIZE); <nl> -	memset(D, 0, SHA512_DIGEST_SIZE); <nl> +	memzero_explicit(D, SHA512_DIGEST_SIZE); <nl>   <nl>  	return 0; <nl>  }
@@ -602,6 +602,9 @@ static int usbhsg_ep_disable(struct usb_ep *ep) <nl>  	struct usbhsg_uep *uep = usbhsg_ep_to_uep(ep); <nl>  	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep); <nl>   <nl> +	if (!pipe) <nl> +		return -EINVAL; <nl> + <nl>  	usbhsg_pipe_disable(uep); <nl>  	usbhs_pipe_free(pipe); <nl>  
@@ -1269,7 +1269,9 @@ static int _regulator_enable(struct regulator_dev *rdev) <nl>   <nl>  	/* do we need to enable the supply regulator first */ <nl>  	if (rdev->supply) { <nl> +		mutex_lock(&rdev->supply->mutex); <nl>  		ret = _regulator_enable(rdev->supply); <nl> +		mutex_unlock(&rdev->supply->mutex); <nl>  		if (ret < 0) { <nl>  			printk(KERN_ERR "%s: failed to enable %s: %d\n", <nl>  			       __func__, rdev_get_name(rdev), ret);
@@ -113,6 +113,7 @@ static enum power_supply_property max17042_battery_props[] = { <nl>  	POWER_SUPPLY_PROP_VOLTAGE_OCV, <nl>  	POWER_SUPPLY_PROP_CAPACITY, <nl>  	POWER_SUPPLY_PROP_CHARGE_FULL, <nl> +	POWER_SUPPLY_PROP_CHARGE_COUNTER, <nl>  	POWER_SUPPLY_PROP_TEMP, <nl>  	POWER_SUPPLY_PROP_CURRENT_NOW, <nl>  	POWER_SUPPLY_PROP_CURRENT_AVG, <nl> @@ -199,6 +200,13 @@ static int max17042_get_property(struct power_supply *psy, <nl>  		if (ret < 0) <nl>  			return ret; <nl>   <nl> +		val->intval = ret * 1000 / 2; <nl> +		break; <nl> +	case POWER_SUPPLY_PROP_CHARGE_COUNTER: <nl> +		ret = max17042_read_reg(chip->client, MAX17042_QH); <nl> +		if (ret < 0) <nl> +			return ret; <nl> + <nl>  		val->intval = ret * 1000 / 2; <nl>  		break; <nl>  	case POWER_SUPPLY_PROP_TEMP:
@@ -186,6 +186,7 @@ struct device_node *v4l2_of_get_next_endpoint(const struct device_node *parent, <nl>  		if (!endpoint) <nl>  			pr_err("%s(): no endpoint nodes specified for %s\n", <nl>  			       __func__, parent->full_name); <nl> +		of_node_put(node); <nl>  	} else { <nl>  		port = of_get_parent(prev); <nl>  		if (!port)
@@ -949,7 +949,7 @@ static int loop_clr_fd(struct loop_device *lo, struct block_device *bdev) <nl>  	lo->lo_state = Lo_unbound; <nl>  	/* This is safe: open() is still holding a reference. */ <nl>  	module_put(THIS_MODULE); <nl> -	if (max_part > 0) <nl> +	if (max_part > 0 && bdev) <nl>  		ioctl_by_bdev(bdev, BLKRRPART, 0); <nl>  	mutex_unlock(&lo->lo_ctl_mutex); <nl>  	/*
@@ -67,7 +67,6 @@ EXPORT_SYMBOL(smp_num_siblings); <nl>   <nl>  /* Last level cache ID of each logical CPU */ <nl>  u8 cpu_llc_id[NR_CPUS] __cpuinitdata  = {[0 ... NR_CPUS-1] = BAD_APICID}; <nl> -EXPORT_SYMBOL(cpu_llc_id); <nl>   <nl>  /* Bitmask of currently online CPUs */ <nl>  cpumask_t cpu_online_map __read_mostly;
@@ -1078,8 +1078,11 @@ static void sk_prot_free(struct proto *prot, struct sock *sk) <nl>  #ifdef CONFIG_CGROUPS <nl>  void sock_update_classid(struct sock *sk) <nl>  { <nl> -	u32 classid = task_cls_classid(current); <nl> +	u32 classid; <nl>   <nl> +	rcu_read_lock();  /* doing current task, which cannot vanish. */ <nl> +	classid = task_cls_classid(current); <nl> +	rcu_read_unlock(); <nl>  	if (classid && classid != sk->sk_classid) <nl>  		sk->sk_classid = classid; <nl>  }
@@ -125,7 +125,7 @@ static struct i2c_algorithm osif_algorithm = { <nl>  #define USB_OSIF_VENDOR_ID	0x1964 <nl>  #define USB_OSIF_PRODUCT_ID	0x0001 <nl>   <nl> -static struct usb_device_id osif_table[] = { <nl> +static const struct usb_device_id osif_table[] = { <nl>  	{ USB_DEVICE(USB_OSIF_VENDOR_ID, USB_OSIF_PRODUCT_ID) }, <nl>  	{ } <nl>  };
@@ -30,6 +30,7 @@ struct flow_cache_entry { <nl>  		struct hlist_node	hlist; <nl>  		struct list_head	gc_list; <nl>  	} u; <nl> +	struct net			*net; <nl>  	u16				family; <nl>  	u8				dir; <nl>  	u32				genid; <nl> @@ -232,7 +233,8 @@ flow_cache_lookup(struct net *net, const struct flowi *key, u16 family, u8 dir, <nl>   <nl>  	hash = flow_hash_code(fc, fcp, key); <nl>  	hlist_for_each_entry(tfle, entry, &fcp->hash_table[hash], u.hlist) { <nl> -		if (tfle->family == family && <nl> +		if (tfle->net == net && <nl> +		    tfle->family == family && <nl>  		    tfle->dir == dir && <nl>  		    flow_key_compare(key, &tfle->key) == 0) { <nl>  			fle = tfle; <nl> @@ -246,6 +248,7 @@ flow_cache_lookup(struct net *net, const struct flowi *key, u16 family, u8 dir, <nl>   <nl>  		fle = kmem_cache_alloc(flow_cachep, GFP_ATOMIC); <nl>  		if (fle) { <nl> +			fle->net = net; <nl>  			fle->family = family; <nl>  			fle->dir = dir; <nl>  			memcpy(&fle->key, key, sizeof(*key));
@@ -350,6 +350,8 @@ static int lstats_open(struct inode *inode, struct file *file) <nl>  	struct seq_file *m; <nl>  	struct task_struct *task = get_proc_task(inode); <nl>   <nl> +	if (!task) <nl> +		return -ENOENT; <nl>  	ret = single_open(file, lstats_show_proc, NULL); <nl>  	if (!ret) { <nl>  		m = file->private_data;
@@ -303,12 +303,12 @@ static int __logfs_readdir(struct file *file, void *buf, filldir_t filldir) <nl>  				(filler_t *)logfs_readpage, NULL); <nl>  		if (IS_ERR(page)) <nl>  			return PTR_ERR(page); <nl> -		dd = kmap_atomic(page, KM_USER0); <nl> +		dd = kmap(page); <nl>  		BUG_ON(dd->namelen == 0); <nl>   <nl>  		full = filldir(buf, (char *)dd->name, be16_to_cpu(dd->namelen), <nl>  				pos, be64_to_cpu(dd->ino), dd->type); <nl> -		kunmap_atomic(dd, KM_USER0); <nl> +		kunmap(page); <nl>  		page_cache_release(page); <nl>  		if (full) <nl>  			break;
@@ -4124,18 +4124,21 @@ EXPORT_SYMBOL(skb_try_coalesce); <nl>   */ <nl>  void skb_scrub_packet(struct sk_buff *skb, bool xnet) <nl>  { <nl> -	if (xnet) <nl> -		skb_orphan(skb); <nl>  	skb->tstamp.tv64 = 0; <nl>  	skb->pkt_type = PACKET_HOST; <nl>  	skb->skb_iif = 0; <nl>  	skb->ignore_df = 0; <nl>  	skb_dst_drop(skb); <nl> -	skb->mark = 0; <nl>  	skb_sender_cpu_clear(skb); <nl>  	secpath_reset(skb); <nl>  	nf_reset(skb); <nl>  	nf_reset_trace(skb); <nl> + <nl> +	if (!xnet) <nl> +		return; <nl> + <nl> +	skb_orphan(skb); <nl> +	skb->mark = 0; <nl>  } <nl>  EXPORT_SYMBOL_GPL(skb_scrub_packet); <nl>  
@@ -198,6 +198,11 @@ static long tce_iommu_register_pages(struct tce_container *container, <nl>  		return ret; <nl>   <nl>  	tcemem = kzalloc(sizeof(*tcemem), GFP_KERNEL); <nl> +	if (!tcemem) { <nl> +		mm_iommu_put(container->mm, mem); <nl> +		return -ENOMEM; <nl> +	} <nl> + <nl>  	tcemem->mem = mem; <nl>  	list_add(&tcemem->next, &container->prereg_list); <nl>  
@@ -197,7 +197,7 @@ static ssize_t gpio_mockup_event_write(struct file *file, <nl>  	struct seq_file *sfile; <nl>  	struct gpio_desc *desc; <nl>  	struct gpio_chip *gc; <nl> -	int status, val; <nl> +	int val; <nl>  	char buf; <nl>   <nl>  	sfile = file->private_data; <nl> @@ -206,9 +206,8 @@ static ssize_t gpio_mockup_event_write(struct file *file, <nl>  	chip = priv->chip; <nl>  	gc = &chip->gc; <nl>   <nl> -	status = copy_from_user(&buf, usr_buf, 1); <nl> -	if (status) <nl> -		return status; <nl> +	if (copy_from_user(&buf, usr_buf, 1)) <nl> +		return -EFAULT; <nl>   <nl>  	if (buf == '0') <nl>  		val = 0;
@@ -257,6 +257,8 @@ static int davinci_gpio_probe(struct platform_device *pdev) <nl>  		spin_lock_init(&chips[i].lock); <nl>   <nl>  		regs = gpio2regs(base); <nl> +		if (!regs) <nl> +			return -ENXIO; <nl>  		chips[i].regs = regs; <nl>  		chips[i].set_data = &regs->set_data; <nl>  		chips[i].clr_data = &regs->clr_data;
@@ -474,6 +474,13 @@ static int alua_check_sense(struct scsi_device *sdev, <nl>  			 * LUN Not Ready -- Offline <nl>  			 */ <nl>  			return SUCCESS; <nl> +		if (sdev->allow_restart && <nl> +		    sense_hdr->asc == 0x04 && sense_hdr->ascq == 0x02) <nl> +			/* <nl> +			 * if the device is not started, we need to wake <nl> +			 * the error handler to start the motor <nl> +			 */ <nl> +			return FAILED; <nl>  		break; <nl>  	case UNIT_ATTENTION: <nl>  		if (sense_hdr->asc == 0x29 && sense_hdr->ascq == 0x00)
@@ -2152,6 +2152,7 @@ static int journal_unmap_buffer(journal_t *journal, struct buffer_head *bh, <nl>   <nl>  		if (!buffer_dirty(bh)) { <nl>  			/* bdflush has written it.  We can drop it now */ <nl> +			__jbd2_journal_remove_checkpoint(jh); <nl>  			goto zap_buffer; <nl>  		} <nl>   <nl> @@ -2181,6 +2182,7 @@ static int journal_unmap_buffer(journal_t *journal, struct buffer_head *bh, <nl>  				/* The orphan record's transaction has <nl>  				 * committed.  We can cleanse this buffer */ <nl>  				clear_buffer_jbddirty(bh); <nl> +				__jbd2_journal_remove_checkpoint(jh); <nl>  				goto zap_buffer; <nl>  			} <nl>  		}
@@ -466,7 +466,7 @@ static int get_v4lctrl(struct i2c_client *client, struct v4l2_control *ctrl) <nl>  		ctrl->value = cx25840_read(client, 0x420) >> 1; <nl>  		break; <nl>  	case V4L2_CID_HUE: <nl> -		ctrl->value = cx25840_read(client, 0x422); <nl> +		ctrl->value = (s8)cx25840_read(client, 0x422); <nl>  		break; <nl>  	case V4L2_CID_AUDIO_VOLUME: <nl>  	case V4L2_CID_AUDIO_BASS:
@@ -105,6 +105,13 @@ static int mn88472_rreg(struct mn88472_state *s, u16 reg, u8 *val) <nl>  	return mn88472_rregs(s, reg, val, 1); <nl>  } <nl>   <nl> +static int mn88472_get_tune_settings(struct dvb_frontend *fe, <nl> +	struct dvb_frontend_tune_settings *s) <nl> +{ <nl> +	s->min_delay_ms = 400; <nl> +	return 0; <nl> +} <nl> + <nl>  static int mn88472_set_frontend_c(struct dvb_frontend *fe) <nl>  { <nl>  	struct mn88472_state *s = fe->demodulator_priv; <nl> @@ -398,6 +405,8 @@ static struct dvb_frontend_ops mn88472_ops_c = { <nl>   <nl>  	.release = mn88472_release_c, <nl>   <nl> +	.get_tune_settings = mn88472_get_tune_settings, <nl> + <nl>  	.init = mn88472_init_c, <nl>  	.sleep = mn88472_sleep_c, <nl>  
@@ -716,7 +716,10 @@ static int w1_attach_slave_device(struct w1_master *dev, struct w1_reg_num *rn) <nl>  	atomic_set(&sl->refcnt, 0); <nl>  	init_completion(&sl->released); <nl>   <nl> +	/* slave modules need to be loaded in a context with unlocked mutex */ <nl> +	mutex_unlock(&dev->mutex); <nl>  	request_module("w1-family-0x%0x", rn->family); <nl> +	mutex_lock(&dev->mutex); <nl>   <nl>  	spin_lock(&w1_flock); <nl>  	f = w1_family_registered(rn->family);
@@ -619,6 +619,9 @@ static __devinit struct nvme_queue *nvme_create_queue(struct nvme_dev *dev, <nl>  	int result; <nl>  	struct nvme_queue *nvmeq = nvme_alloc_queue(dev, qid, cq_size, vector); <nl>   <nl> +	if (!nvmeq) <nl> +		return NULL; <nl> + <nl>  	result = adapter_alloc_cq(dev, qid, nvmeq); <nl>  	if (result < 0) <nl>  		goto free_nvmeq; <nl> @@ -655,6 +658,8 @@ static int __devinit nvme_configure_admin_queue(struct nvme_dev *dev) <nl>  	dev->dbs = ((void __iomem *)dev->bar) + 4096; <nl>   <nl>  	nvmeq = nvme_alloc_queue(dev, 0, 64, 0); <nl> +	if (!nvmeq) <nl> +		return -ENOMEM; <nl>   <nl>  	aqa = nvmeq->q_depth - 1; <nl>  	aqa |= aqa << 16;
@@ -1279,3 +1279,4 @@ static struct usb_driver go7007_usb_driver = { <nl>  }; <nl>   <nl>  module_usb_driver(go7007_usb_driver); <nl> +MODULE_LICENSE("GPL v2");
@@ -1190,7 +1190,7 @@ static void k8_map_sysaddr_to_csrow(struct mem_ctl_info *mci, <nl>  	 * different from the node that detected the error. <nl>  	 */ <nl>  	src_mci = find_mc_by_sys_addr(mci, SystemAddress); <nl> -	if (src_mci) { <nl> +	if (!src_mci) { <nl>  		amd64_mc_printk(mci, KERN_ERR, <nl>  			     "failed to map error address 0x%lx to a node\n", <nl>  			     (unsigned long)SystemAddress);
@@ -644,7 +644,7 @@ static void davinci_hw_param(struct davinci_audio_dev *dev, int stream) <nl>  		mcasp_set_reg(dev->base + DAVINCI_MCASP_TXTDM_REG, mask); <nl>  		mcasp_set_bits(dev->base + DAVINCI_MCASP_TXFMT_REG, TXORD); <nl>   <nl> -		if ((dev->tdm_slots >= 2) || (dev->tdm_slots <= 32)) <nl> +		if ((dev->tdm_slots >= 2) && (dev->tdm_slots <= 32)) <nl>  			mcasp_mod_bits(dev->base + DAVINCI_MCASP_TXFMCTL_REG, <nl>  					FSXMOD(dev->tdm_slots), FSXMOD(0x1FF)); <nl>  		else <nl> @@ -660,7 +660,7 @@ static void davinci_hw_param(struct davinci_audio_dev *dev, int stream) <nl>  				AHCLKRE); <nl>  		mcasp_set_reg(dev->base + DAVINCI_MCASP_RXTDM_REG, mask); <nl>   <nl> -		if ((dev->tdm_slots >= 2) || (dev->tdm_slots <= 32)) <nl> +		if ((dev->tdm_slots >= 2) && (dev->tdm_slots <= 32)) <nl>  			mcasp_mod_bits(dev->base + DAVINCI_MCASP_RXFMCTL_REG, <nl>  					FSRMOD(dev->tdm_slots), FSRMOD(0x1FF)); <nl>  		else
@@ -4903,10 +4903,17 @@ static void sort_parity_stripes(struct btrfs_bio *bbio, int num_stripes) <nl>  static struct btrfs_bio *alloc_btrfs_bio(int total_stripes, int real_stripes) <nl>  { <nl>  	struct btrfs_bio *bbio = kzalloc( <nl> +		 /* the size of the btrfs_bio */ <nl>  		sizeof(struct btrfs_bio) + <nl> +		/* plus the variable array for the stripes */ <nl>  		sizeof(struct btrfs_bio_stripe) * (total_stripes) + <nl> +		/* plus the variable array for the tgt dev */ <nl>  		sizeof(int) * (real_stripes) + <nl> -		sizeof(u64) * (real_stripes), <nl> +		/* <nl> +		 * plus the raid_map, which includes both the tgt dev <nl> +		 * and the stripes <nl> +		 */ <nl> +		sizeof(u64) * (total_stripes), <nl>  		GFP_NOFS); <nl>  	if (!bbio) <nl>  		return NULL;
@@ -126,7 +126,7 @@ static void process_one_interrupt(struct rmi_driver_data *data, <nl>  		return; <nl>   <nl>  	fh = to_rmi_function_handler(fn->dev.driver); <nl> -	if (fn->irq_mask && fh->attention) { <nl> +	if (fh->attention) { <nl>  		bitmap_and(data->fn_irq_bits, data->irq_status, fn->irq_mask, <nl>  				data->irq_count); <nl>  		if (!bitmap_empty(data->fn_irq_bits, data->irq_count)) <nl> @@ -172,8 +172,7 @@ int rmi_process_interrupt_requests(struct rmi_device *rmi_dev) <nl>  	 * use irq_chip. <nl>  	 */ <nl>  	list_for_each_entry(entry, &data->function_list, node) <nl> -		if (entry->irq_mask) <nl> -			process_one_interrupt(data, entry); <nl> +		process_one_interrupt(data, entry); <nl>   <nl>  	if (data->input) <nl>  		input_sync(data->input);
@@ -950,7 +950,7 @@ static int mt9p031_probe(struct i2c_client *client, <nl>  	mt9p031->model = did->driver_data; <nl>  	mt9p031->reset = -1; <nl>   <nl> -	v4l2_ctrl_handler_init(&mt9p031->ctrls, ARRAY_SIZE(mt9p031_ctrls) + 4); <nl> +	v4l2_ctrl_handler_init(&mt9p031->ctrls, ARRAY_SIZE(mt9p031_ctrls) + 5); <nl>   <nl>  	v4l2_ctrl_new_std(&mt9p031->ctrls, &mt9p031_ctrl_ops, <nl>  			  V4L2_CID_EXPOSURE, MT9P031_SHUTTER_WIDTH_MIN, <nl> @@ -963,6 +963,9 @@ static int mt9p031_probe(struct i2c_client *client, <nl>  			  V4L2_CID_HFLIP, 0, 1, 1, 0); <nl>  	v4l2_ctrl_new_std(&mt9p031->ctrls, &mt9p031_ctrl_ops, <nl>  			  V4L2_CID_VFLIP, 0, 1, 1, 0); <nl> +	v4l2_ctrl_new_std(&mt9p031->ctrls, &mt9p031_ctrl_ops, <nl> +			  V4L2_CID_PIXEL_RATE, pdata->target_freq, <nl> +			  pdata->target_freq, 1, pdata->target_freq); <nl>   <nl>  	for (i = 0; i < ARRAY_SIZE(mt9p031_ctrls); ++i) <nl>  		v4l2_ctrl_new_custom(&mt9p031->ctrls, &mt9p031_ctrls[i], NULL);
@@ -198,6 +198,7 @@ static struct pci_driver driver = { <nl>  	.name		= "ITE8213_IDE", <nl>  	.id_table	= it8213_pci_tbl, <nl>  	.probe		= it8213_init_one, <nl> +	.remove		= ide_pci_remove, <nl>  }; <nl>   <nl>  static int __init it8213_ide_init(void) <nl> @@ -205,7 +206,13 @@ static int __init it8213_ide_init(void) <nl>  	return ide_pci_register_driver(&driver); <nl>  } <nl>   <nl> +static void __exit it8213_ide_exit(void) <nl> +{ <nl> +	pci_unregister_driver(&driver); <nl> +} <nl> + <nl>  module_init(it8213_ide_init); <nl> +module_exit(it8213_ide_exit); <nl>   <nl>  MODULE_AUTHOR("Jack Lee, Alan Cox"); <nl>  MODULE_DESCRIPTION("PCI driver module for the ITE 8213");
@@ -41,10 +41,11 @@ sys_mmap2(unsigned long addr, unsigned long len, unsigned long prot, <nl>   <nl>  asmlinkage long <nl>  sys_mmap(unsigned long addr, unsigned long len, unsigned long prot, <nl> -	unsigned long flags, unsigned long fd, off_t pgoff) <nl> +	unsigned long flags, unsigned long fd, off_t offset) <nl>  { <nl> -	/* where's the alignment check? */ <nl> -	return sys_mmap_pgoff(addr, len, prot, flags, fd, pgoff >> PAGE_SHIFT); <nl> +	if (unlikely(offset & ~PAGE_MASK)) <nl> +		return -EINVAL; <nl> +	return sys_mmap_pgoff(addr, len, prot, flags, fd, offset >> PAGE_SHIFT); <nl>  } <nl>   <nl>  asmlinkage long
@@ -115,7 +115,7 @@ static int have_root __initdata = 0; <nl>  /* Set in uml_mem_setup and modified in linux_main */ <nl>  long long physmem_size = 32 * 1024 * 1024; <nl>   <nl> -static char *usage_string = <nl> +static const char *usage_string = <nl>  "User Mode Linux v%s\n" <nl>  "	available at http://user-mode-linux.sourceforge.net/\n\n"; <nl>   <nl> @@ -202,7 +202,7 @@ static void __init uml_checksetup(char *line, int *add) <nl>   <nl>  	p = &__uml_setup_start; <nl>  	while (p < &__uml_setup_end) { <nl> -		int n; <nl> +		size_t n; <nl>   <nl>  		n = strlen(p->str); <nl>  		if (!strncmp(line, p->str, n) && p->setup_func(line + n, add)) <nl> @@ -258,7 +258,8 @@ int __init linux_main(int argc, char **argv) <nl>  { <nl>  	unsigned long avail, diff; <nl>  	unsigned long virtmem_size, max_physmem; <nl> -	unsigned int i, add; <nl> +	unsigned int i; <nl> +	int add; <nl>  	char * mode; <nl>   <nl>  	for (i = 1; i < argc; i++) {
@@ -449,7 +449,8 @@ static struct usb_host_endpoint *alt_xfer(struct usb_host_interface *alt, <nl>  	for (i = 0; i < alt->desc.bNumEndpoints; i++) { <nl>  		ep = &alt->endpoint[i]; <nl>  		attr = ep->desc.bmAttributes & USB_ENDPOINT_XFERTYPE_MASK; <nl> -		if (attr == xfer) <nl> +		if (attr == xfer <nl> +		    && ep->desc.wMaxPacketSize != 0) <nl>  			return ep; <nl>  	} <nl>  	return NULL;
@@ -754,7 +754,7 @@ int perf_evlist__parse_mmap_pages(const struct option *opt, const char *str, <nl>  	unsigned long max = UINT_MAX; <nl>  	long pages; <nl>   <nl> -	if (max < SIZE_MAX / page_size) <nl> +	if (max > SIZE_MAX / page_size) <nl>  		max = SIZE_MAX / page_size; <nl>   <nl>  	pages = parse_pages_arg(str, 1, max);
@@ -130,6 +130,8 @@ static int proc_thermal_add(struct device *dev, <nl>  	int ret; <nl>   <nl>  	adev = ACPI_COMPANION(dev); <nl> +	if (!adev) <nl> +		return -ENODEV; <nl>   <nl>  	status = acpi_evaluate_object(adev->handle, "PPCC", NULL, &buf); <nl>  	if (ACPI_FAILURE(status))
@@ -727,6 +727,9 @@ struct winch { <nl>   <nl>  static void free_winch(struct winch *winch, int free_irq_ok) <nl>  { <nl> +	if (free_irq_ok) <nl> +		free_irq(WINCH_IRQ, winch); <nl> + <nl>  	list_del(&winch->list); <nl>   <nl>  	if (winch->pid != -1) <nl> @@ -735,8 +738,6 @@ static void free_winch(struct winch *winch, int free_irq_ok) <nl>  		os_close_file(winch->fd); <nl>  	if (winch->stack != 0) <nl>  		free_stack(winch->stack, 0); <nl> -	if (free_irq_ok) <nl> -		free_irq(WINCH_IRQ, winch); <nl>  	kfree(winch); <nl>  } <nl>  
@@ -159,7 +159,8 @@ static int send_write(struct svcxprt_rdma *xprt, struct svc_rqst *rqstp, <nl>  	BUG_ON(sge_count >= 32); <nl>  	dprintk("svcrdma: RDMA_WRITE rmr=%x, to=%llx, xdr_off=%d, " <nl>  		"write_len=%d, xdr_sge=%p, sge_count=%d\n", <nl> -		rmr, to, xdr_off, write_len, xdr_sge, sge_count); <nl> +		rmr, (unsigned long long)to, xdr_off, <nl> +		write_len, xdr_sge, sge_count); <nl>   <nl>  	ctxt = svc_rdma_get_context(xprt); <nl>  	ctxt->count = 0;
@@ -172,7 +172,8 @@ static ssize_t m25p80_read(struct spi_nor *nor, loff_t from, size_t len, <nl>   <nl>  	t[1].rx_buf = buf; <nl>  	t[1].rx_nbits = m25p80_rx_nbits(nor); <nl> -	t[1].len = min(len, spi_max_transfer_size(spi)); <nl> +	t[1].len = min3(len, spi_max_transfer_size(spi), <nl> +			spi_max_message_size(spi) - t[0].len); <nl>  	spi_message_add_tail(&t[1], &m); <nl>   <nl>  	ret = spi_sync(spi, &m);
@@ -2301,9 +2301,9 @@ new_group_no_lock: <nl>  				up_read(&space_info->groups_sem); <nl>  				ret = do_chunk_alloc(trans, root, num_bytes + <nl>  						     2 * 1024 * 1024, data, 1); <nl> -				if (ret < 0) <nl> -					break; <nl>  				down_read(&space_info->groups_sem); <nl> +				if (ret < 0) <nl> +					goto loop_check; <nl>  				head = &space_info->block_groups; <nl>  				/* <nl>  				 * we've allocated a new chunk, keep <nl> @@ -2314,6 +2314,7 @@ new_group_no_lock: <nl>  			} else if (!allowed_chunk_alloc) { <nl>  				space_info->force_alloc = 1; <nl>  			} <nl> +loop_check: <nl>  			if (keep_going) { <nl>  				cur = head->next; <nl>  				extra_loop = 0;
@@ -419,6 +419,10 @@ static int ll_dir_setdirstripe(struct inode *parent, struct lmv_user_md *lump, <nl>  	       PFID(ll_inode2fid(parent)), parent, dirname, <nl>  	       (int)lump->lum_stripe_offset, lump->lum_stripe_count); <nl>   <nl> +	if (lump->lum_stripe_count > 1 && <nl> +	    !(exp_connect_flags(sbi->ll_md_exp) & OBD_CONNECT_DIR_STRIPE)) <nl> +		return -EINVAL; <nl> + <nl>  	if (lump->lum_magic != cpu_to_le32(LMV_USER_MAGIC)) <nl>  		lustre_swab_lmv_user_md(lump); <nl>  
@@ -34,8 +34,10 @@ __xfs_printk( <nl>  	const struct xfs_mount	*mp, <nl>  	struct va_format	*vaf) <nl>  { <nl> -	if (mp && mp->m_fsname) <nl> +	if (mp && mp->m_fsname) { <nl>  		printk("%sXFS (%s): %pV\n", level, mp->m_fsname, vaf); <nl> +		return; <nl> +	} <nl>  	printk("%sXFS: %pV\n", level, vaf); <nl>  } <nl>  
@@ -3248,6 +3248,8 @@ int ieee80211_mgd_auth(struct ieee80211_sub_if_data *sdata, <nl>  	goto out_unlock; <nl>   <nl>   err_clear: <nl> +	memset(ifmgd->bssid, 0, ETH_ALEN); <nl> +	ieee80211_bss_info_change_notify(sdata, BSS_CHANGED_BSSID); <nl>  	ifmgd->auth_data = NULL; <nl>   err_free: <nl>  	kfree(auth_data); <nl> @@ -3439,6 +3441,8 @@ int ieee80211_mgd_assoc(struct ieee80211_sub_if_data *sdata, <nl>  	err = 0; <nl>  	goto out; <nl>   err_clear: <nl> +	memset(ifmgd->bssid, 0, ETH_ALEN); <nl> +	ieee80211_bss_info_change_notify(sdata, BSS_CHANGED_BSSID); <nl>  	ifmgd->assoc_data = NULL; <nl>   err_free: <nl>  	kfree(assoc_data);
@@ -3668,7 +3668,7 @@ static inline void update_sd_power_savings_stats(struct sched_group *group, <nl>  	 * capacity but still has some space to pick up some load <nl>  	 * from other group and save more power <nl>  	 */ <nl> -	if (sgs->sum_nr_running > sgs->group_capacity - 1) <nl> +	if (sgs->sum_nr_running + 1 > sgs->group_capacity) <nl>  		return; <nl>   <nl>  	if (sgs->sum_nr_running > sds->leader_nr_running ||
@@ -819,7 +819,7 @@ static int __init gc_setup_pad(struct gc *gc, int idx, int pad_type) <nl>  	int i; <nl>  	int err; <nl>   <nl> -	if (pad_type < 1 || pad_type > GC_MAX) { <nl> +	if (pad_type < 1 || pad_type >= GC_MAX) { <nl>  		pr_err("Pad type %d unknown\n", pad_type); <nl>  		return -EINVAL; <nl>  	}
@@ -1829,14 +1829,12 @@ static int sd_sdr_tuning(struct rtsx_chip *chip) <nl>  	int retval; <nl>   <nl>  	retval = sd_tuning_tx(chip); <nl> -	if (retval != STATUS_SUCCESS) { <nl> +	if (retval != STATUS_SUCCESS) <nl>  		TRACE_RET(chip, STATUS_FAIL); <nl> -	} <nl>   <nl>  	retval = sd_tuning_rx(chip); <nl> -	if (retval != STATUS_SUCCESS) { <nl> +	if (retval != STATUS_SUCCESS) <nl>  		TRACE_RET(chip, STATUS_FAIL); <nl> -	} <nl>   <nl>  	return STATUS_SUCCESS; <nl>  }
@@ -3314,9 +3314,8 @@ static int be_get_config(struct be_adapter *adapter) <nl>  	if (status) <nl>  		return status; <nl>   <nl> -	/* primary mac needs 1 pmac entry */ <nl> -	adapter->pmac_id = kcalloc(be_max_uc(adapter) + 1, sizeof(u32), <nl> -				   GFP_KERNEL); <nl> +	adapter->pmac_id = kcalloc(be_max_uc(adapter), <nl> +				   sizeof(*adapter->pmac_id), GFP_KERNEL); <nl>  	if (!adapter->pmac_id) <nl>  		return -ENOMEM; <nl>  
@@ -80,8 +80,10 @@ int __drm_modeset_lock_all(struct drm_device *dev, <nl>  		return -ENOMEM; <nl>   <nl>  	if (trylock) { <nl> -		if (!mutex_trylock(&config->mutex)) <nl> -			return -EBUSY; <nl> +		if (!mutex_trylock(&config->mutex)) { <nl> +			ret = -EBUSY; <nl> +			goto out; <nl> +		} <nl>  	} else { <nl>  		mutex_lock(&config->mutex); <nl>  	} <nl> @@ -114,6 +116,8 @@ fail: <nl>  		goto retry; <nl>  	} <nl>   <nl> +out: <nl> +	kfree(ctx); <nl>  	return ret; <nl>  } <nl>  EXPORT_SYMBOL(__drm_modeset_lock_all);
@@ -932,7 +932,7 @@ static struct drm_driver tegra_drm_driver = { <nl>  	.debugfs_cleanup = tegra_debugfs_cleanup, <nl>  #endif <nl>   <nl> -	.gem_free_object = tegra_bo_free_object, <nl> +	.gem_free_object_unlocked = tegra_bo_free_object, <nl>  	.gem_vm_ops = &tegra_bo_vm_ops, <nl>   <nl>  	.prime_handle_to_fd = drm_gem_prime_handle_to_fd,
@@ -1501,6 +1501,7 @@ int be_cmd_loopback_test(struct be_adapter *adapter, u32 port_num, <nl>   <nl>  	be_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_LOWLEVEL, <nl>  			OPCODE_LOWLEVEL_LOOPBACK_TEST, sizeof(*req)); <nl> +	req->hdr.timeout = 4; <nl>   <nl>  	req->pattern = cpu_to_le64(pattern); <nl>  	req->src_port = cpu_to_le32(port_num);
@@ -33,6 +33,9 @@ static inline void bio_list_add(struct bio_list *bl, struct bio *bio) <nl>   <nl>  static inline void bio_list_merge(struct bio_list *bl, struct bio_list *bl2) <nl>  { <nl> +	if (!bl2->head) <nl> +		return; <nl> + <nl>  	if (bl->tail) <nl>  		bl->tail->bi_next = bl2->head; <nl>  	else
@@ -70,6 +70,7 @@ static inline pte_t huge_ptep_get_and_clear(struct mm_struct *mm, <nl>  static inline void huge_ptep_clear_flush(struct vm_area_struct *vma, <nl>  					 unsigned long addr, pte_t *ptep) <nl>  { <nl> +	flush_tlb_mm(vma->vm_mm); <nl>  } <nl>   <nl>  static inline int huge_pte_none(pte_t pte)
@@ -418,10 +418,6 @@ static int snd_sst_fill_kernel_list(struct stream_info *stream, <nl>  	static int sent_offset; <nl>  	static unsigned long sent_index; <nl>   <nl> -	stream_bufs = kzalloc(sizeof(*stream_bufs), GFP_KERNEL); <nl> -	if (!stream_bufs) <nl> -		return -ENOMEM; <nl> -	stream_bufs->addr = sst_drv_ctx->mmap_mem; <nl>  #ifdef CONFIG_MRST_RAR_HANDLER <nl>  	if (stream->ops == STREAM_OPS_PLAYBACK_DRM) { <nl>  		for (index = stream->sg_index; index < nr_segs; index++) { <nl> @@ -448,6 +444,10 @@ static int snd_sst_fill_kernel_list(struct stream_info *stream, <nl>  		return retval; <nl>  	} <nl>  #endif <nl> +	stream_bufs = kzalloc(sizeof(*stream_bufs), GFP_KERNEL); <nl> +	if (!stream_bufs) <nl> +		return -ENOMEM; <nl> +	stream_bufs->addr = sst_drv_ctx->mmap_mem; <nl>  	mmap_len = sst_drv_ctx->mmap_len; <nl>  	stream_bufs->addr = sst_drv_ctx->mmap_mem; <nl>  	bufp = stream->cur_ptr;
@@ -121,6 +121,8 @@ xfs_allocbt_free_block( <nl>  	xfs_extent_busy_insert(cur->bc_tp, be32_to_cpu(agf->agf_seqno), bno, 1, <nl>  			      XFS_EXTENT_BUSY_SKIP_DISCARD); <nl>  	xfs_trans_agbtree_delta(cur->bc_tp, -1); <nl> + <nl> +	xfs_trans_binval(cur->bc_tp, bp); <nl>  	return 0; <nl>  } <nl>  
@@ -604,7 +604,7 @@ static int inet_rtm_newroute(struct sk_buff *skb, struct nlmsghdr* nlh, void *ar <nl>  	if (err < 0) <nl>  		goto errout; <nl>   <nl> -	tb = fib_new_table(&init_net, cfg.fc_table); <nl> +	tb = fib_new_table(net, cfg.fc_table); <nl>  	if (tb == NULL) { <nl>  		err = -ENOBUFS; <nl>  		goto errout; <nl> @@ -794,7 +794,7 @@ static void fib_del_ifaddr(struct in_ifaddr *ifa) <nl>  		fib_magic(RTM_DELROUTE, RTN_LOCAL, ifa->ifa_local, 32, prim); <nl>   <nl>  		/* Check, that this local address finally disappeared. */ <nl> -		if (inet_addr_type(&init_net, ifa->ifa_local) != RTN_LOCAL) { <nl> +		if (inet_addr_type(dev->nd_net, ifa->ifa_local) != RTN_LOCAL) { <nl>  			/* And the last, but not the least thing. <nl>  			   We must flush stray FIB entries. <nl>   <nl> @@ -802,7 +802,7 @@ static void fib_del_ifaddr(struct in_ifaddr *ifa) <nl>  			   for stray nexthop entries, then ignite fib_flush. <nl>  			*/ <nl>  			if (fib_sync_down(ifa->ifa_local, NULL, 0)) <nl> -				fib_flush(&init_net); <nl> +				fib_flush(dev->nd_net); <nl>  		} <nl>  	} <nl>  #undef LOCAL_OK <nl> @@ -897,7 +897,7 @@ static void nl_fib_lookup_exit(struct net *net) <nl>  static void fib_disable_ip(struct net_device *dev, int force) <nl>  { <nl>  	if (fib_sync_down(0, dev, force)) <nl> -		fib_flush(&init_net); <nl> +		fib_flush(dev->nd_net); <nl>  	rt_cache_flush(0); <nl>  	arp_ifdown(dev); <nl>  }
@@ -1716,6 +1716,7 @@ card_probe_error: <nl>  	if (card->remove) <nl>  		card->remove(card); <nl>   <nl> +	snd_soc_dapm_free(&card->dapm); <nl>  	soc_cleanup_card_debugfs(card); <nl>  	snd_card_free(card->snd_card); <nl>  
@@ -1362,9 +1362,11 @@ share: <nl>  error_just_free: <nl>  	up_write(&nommu_region_sem); <nl>  error: <nl> -	fput(region->vm_file); <nl> +	if (region->vm_file) <nl> +		fput(region->vm_file); <nl>  	kmem_cache_free(vm_region_jar, region); <nl> -	fput(vma->vm_file); <nl> +	if (vma->vm_file) <nl> +		fput(vma->vm_file); <nl>  	if (vma->vm_flags & VM_EXECUTABLE) <nl>  		removed_exe_file_vma(vma->vm_mm); <nl>  	kmem_cache_free(vm_area_cachep, vma);
@@ -775,6 +775,13 @@ get_more_pages: <nl>  					    ci->i_truncate_seq, <nl>  					    ci->i_truncate_size, <nl>  					    &inode->i_mtime, true, 1, 0); <nl> + <nl> +				if (!req) { <nl> +					rc = -ENOMEM; <nl> +					unlock_page(page); <nl> +					break; <nl> +				} <nl> + <nl>  				max_pages = req->r_num_pages; <nl>   <nl>  				alloc_page_vec(fsc, req);
@@ -616,6 +616,7 @@ int mei_cl_connect(struct mei_cl *cl, struct file *file) <nl>  	mutex_lock(&dev->device_lock); <nl>   <nl>  	if (cl->state != MEI_FILE_CONNECTED) { <nl> +		cl->state = MEI_FILE_DISCONNECTED; <nl>  		/* something went really wrong */ <nl>  		if (!cl->status) <nl>  			cl->status = -EFAULT;
@@ -191,7 +191,7 @@ static void __init _set_omap_chip(void) <nl>   <nl>  } <nl>   <nl> -void __init omap2_check_revision(void) <nl> +void __init omap24xx_check_revision(void) <nl>  { <nl>  	int i, j; <nl>  	u32 idcode; <nl> @@ -266,6 +266,11 @@ void __init omap2_check_revision(void) <nl>   <nl>  } <nl>   <nl> +void __init omap2_check_revision(void) <nl> +{ <nl> +	omap24xx_check_revision(); <nl> +} <nl> + <nl>  void __init omap2_set_globals_tap(struct omap_globals *omap2_globals) <nl>  { <nl>  	class = omap2_globals->class;
@@ -259,13 +259,15 @@ static int nct7802_read_fan_min(struct nct7802_data *data, u8 reg_fan_low, <nl>  		ret = 0; <nl>  	else if (ret) <nl>  		ret = DIV_ROUND_CLOSEST(1350000U, ret); <nl> +	else <nl> +		ret = 1350000U; <nl>  abort: <nl>  	mutex_unlock(&data->access_lock); <nl>  	return ret; <nl>  } <nl>   <nl>  static int nct7802_write_fan_min(struct nct7802_data *data, u8 reg_fan_low, <nl> -				 u8 reg_fan_high, unsigned int limit) <nl> +				 u8 reg_fan_high, unsigned long limit) <nl>  { <nl>  	int err; <nl>   <nl> @@ -326,8 +328,8 @@ static int nct7802_write_voltage(struct nct7802_data *data, int nr, int index, <nl>  	int shift = 8 - REG_VOLTAGE_LIMIT_MSB_SHIFT[index - 1][nr]; <nl>  	int err; <nl>   <nl> +	voltage = clamp_val(voltage, 0, 0x3ff * nct7802_vmul[nr]); <nl>  	voltage = DIV_ROUND_CLOSEST(voltage, nct7802_vmul[nr]); <nl> -	voltage = clamp_val(voltage, 0, 0x3ff); <nl>   <nl>  	mutex_lock(&data->access_lock); <nl>  	err = regmap_write(data->regmap, <nl> @@ -402,7 +404,7 @@ static ssize_t store_temp(struct device *dev, struct device_attribute *attr, <nl>  	if (err < 0) <nl>  		return err; <nl>   <nl> -	val = clamp_val(DIV_ROUND_CLOSEST(val, 1000), -128, 127); <nl> +	val = DIV_ROUND_CLOSEST(clamp_val(val, -128000, 127000), 1000); <nl>   <nl>  	err = regmap_write(data->regmap, nr, val & 0xff); <nl>  	return err ? : count;
@@ -675,6 +675,7 @@ static int send_connect(struct c4iw_ep *ep) <nl>  	if (is_t5(ep->com.dev->rdev.lldi.adapter_type)) { <nl>  		opt2 |= T5_OPT_2_VALID; <nl>  		opt2 |= V_CONG_CNTRL(CONG_ALG_TAHOE); <nl> +		opt2 |= CONG_CNTRL_VALID; /* OPT_2_ISS for T5 */ <nl>  	} <nl>  	t4_set_arp_err_handler(skb, ep, act_open_req_arp_failure); <nl>   <nl> @@ -720,8 +721,6 @@ static int send_connect(struct c4iw_ep *ep) <nl>  	} else { <nl>  		u32 isn = (prandom_u32() & ~7UL) - 1; <nl>   <nl> -		opt2 |= T5_OPT_2_VALID; <nl> -		opt2 |= CONG_CNTRL_VALID; /* OPT_2_ISS for T5 */ <nl>  		if (peer2peer) <nl>  			isn += 4; <nl>   <nl> @@ -763,10 +762,10 @@ static int send_connect(struct c4iw_ep *ep) <nl>  			t5_req6->peer_ip_lo = *((__be64 *) <nl>  						(ra6->sin6_addr.s6_addr + 8)); <nl>  			t5_req6->opt0 = cpu_to_be64(opt0); <nl> -			t5_req6->params = (__force __be64)cpu_to_be32( <nl> +			t5_req6->params = cpu_to_be64(V_FILTER_TUPLE( <nl>  							cxgb4_select_ntuple( <nl>  						ep->com.dev->rdev.lldi.ports[0], <nl> -						ep->l2t)); <nl> +						ep->l2t))); <nl>  			t5_req6->rsvd = cpu_to_be32(isn); <nl>  			PDBG("%s snd_isn %u\n", __func__, <nl>  			     be32_to_cpu(t5_req6->rsvd));
@@ -444,6 +444,7 @@ static int mv643xx_eth_receive_queue(struct net_device *dev) <nl>  			netif_rx(skb); <nl>  #endif <nl>  		} <nl> +		dev->last_rx = jiffies; <nl>  	} <nl>   <nl>  	return received_packets;
@@ -4850,7 +4850,7 @@ static irqreturn_t iwl_isr(int irq, void *data) <nl>  	if ((inta == 0xFFFFFFFF) || ((inta & 0xFFFFFFF0) == 0xa5a5a5a0)) { <nl>  		/* Hardware disappeared */ <nl>  		IWL_WARNING("HARDWARE GONE?? INTA == 0x%080x\n", inta); <nl> -		goto none; <nl> +		goto unplugged; <nl>  	} <nl>   <nl>  	IWL_DEBUG_ISR("ISR inta 0x%08x, enabled 0x%08x, fh 0x%08x\n", <nl> @@ -4858,6 +4858,7 @@ static irqreturn_t iwl_isr(int irq, void *data) <nl>   <nl>  	/* iwl_irq_tasklet() will service interrupts and re-enable them */ <nl>  	tasklet_schedule(&priv->irq_tasklet); <nl> +unplugged: <nl>  	spin_unlock(&priv->lock); <nl>   <nl>  	return IRQ_HANDLED;
@@ -372,6 +372,10 @@ static ssize_t set_pwm_mode(struct device *dev, struct device_attribute *attr, <nl>  	if (!(val == 0 || val == 1)) <nl>  		return -EINVAL; <nl>   <nl> +	/* F75373 does not support DC (linear voltage) fan control mode */ <nl> +	if (data->kind == f75373 && val == 0) <nl> +		return -EINVAL; <nl> + <nl>  	mutex_lock(&data->update_lock); <nl>  	conf = f75375_read8(client, F75375_REG_CONFIG1); <nl>  	conf &= ~(1 << FAN_CTRL_LINEAR(nr));
@@ -695,7 +695,7 @@ bool gw_out_of_range(struct bat_priv *bat_priv, <nl>  	} <nl>   <nl>  	neigh_old = find_router(bat_priv, orig_dst_node, NULL); <nl> -	if (!!neigh_old) <nl> +	if (!neigh_old) <nl>  		goto out; <nl>   <nl>  	if (curr_tq_avg - neigh_old->tq_avg > GW_THRESHOLD)
@@ -340,9 +340,10 @@ void __init find_legacy_serial_ports(void) <nl>  	} <nl>   <nl>  	/* First fill our array with opb bus ports */ <nl> -	for (np = NULL; (np = of_find_compatible_node(np, "serial", "ns16750")) != NULL;) { <nl> +	for (np = NULL; (np = of_find_compatible_node(np, "serial", "ns16550")) != NULL;) { <nl>  		struct device_node *opb = of_get_parent(np); <nl> -		if (opb && !strcmp(opb->type, "opb")) { <nl> +		if (opb && (!strcmp(opb->type, "opb") || <nl> +			    of_device_is_compatible(opb, "ibm,opb"))) { <nl>  			index = add_legacy_soc_port(np, np); <nl>  			if (index >= 0 && np == stdout) <nl>  				legacy_serial_console = index;
@@ -540,11 +540,14 @@ struct nes_cqp_request *nes_get_cqp_request(struct nes_device *nesdev) <nl>   <nl>  	if (!list_empty(&nesdev->cqp_avail_reqs)) { <nl>  		spin_lock_irqsave(&nesdev->cqp.lock, flags); <nl> -		cqp_request = list_entry(nesdev->cqp_avail_reqs.next, <nl> +		if (!list_empty(&nesdev->cqp_avail_reqs)) { <nl> +			cqp_request = list_entry(nesdev->cqp_avail_reqs.next, <nl>  				struct nes_cqp_request, list); <nl> -		list_del_init(&cqp_request->list); <nl> +			list_del_init(&cqp_request->list); <nl> +		} <nl>  		spin_unlock_irqrestore(&nesdev->cqp.lock, flags); <nl> -	} else { <nl> +	} <nl> +	if (cqp_request == NULL) { <nl>  		cqp_request = kzalloc(sizeof(struct nes_cqp_request), GFP_KERNEL); <nl>  		if (cqp_request) { <nl>  			cqp_request->dynamic = 1;
@@ -580,7 +580,7 @@ static int hws_cpu_callback(struct notifier_block *nfb, <nl>  { <nl>  	/* We do not have sampler space available for all possible CPUs. <nl>  	   All CPUs should be online when hw sampling is activated. */ <nl> -	return NOTIFY_BAD; <nl> +	return (hws_state <= HWS_DEALLOCATED) ? NOTIFY_OK : NOTIFY_BAD; <nl>  } <nl>   <nl>  static struct notifier_block hws_cpu_notifier = {
@@ -507,9 +507,8 @@ static int em28xx_i2c_xfer(struct i2c_adapter *i2c_adap, <nl>  	if (dev->disconnected) <nl>  		return -ENODEV; <nl>   <nl> -	rc = rt_mutex_trylock(&dev->i2c_bus_lock); <nl> -	if (rc < 0) <nl> -		return rc; <nl> +	if (!rt_mutex_trylock(&dev->i2c_bus_lock)) <nl> +		return -EAGAIN; <nl>   <nl>  	/* Switch I2C bus if needed */ <nl>  	if (bus != dev->cur_i2c_bus &&
@@ -2599,7 +2599,6 @@ static void free_sa_defrag_extent(struct new_sa_defrag_extent *new) <nl>  		return; <nl>   <nl>  	list_for_each_entry_safe(old, tmp, &new->head, list) { <nl> -		list_del(&old->list); <nl>  		kfree(old); <nl>  	} <nl>  	kfree(new);
@@ -2914,6 +2914,9 @@ static int rx_intr_handler(struct ring_info *ring_data, int budget) <nl>  	struct RxD1 *rxdp1; <nl>  	struct RxD3 *rxdp3; <nl>   <nl> +	if (budget <= 0) <nl> +		return napi_pkts; <nl> + <nl>  	get_info = ring_data->rx_curr_get_info; <nl>  	get_block = get_info.block_index; <nl>  	memcpy(&put_info, &ring_data->rx_curr_put_info, sizeof(put_info));
@@ -488,7 +488,7 @@ static int srp_create_ch_ib(struct srp_rdma_ch *ch) <nl>  	struct ib_qp *qp; <nl>  	struct ib_fmr_pool *fmr_pool = NULL; <nl>  	struct srp_fr_pool *fr_pool = NULL; <nl> -	const int m = 1 + dev->use_fast_reg; <nl> +	const int m = dev->use_fast_reg ? 3 : 1; <nl>  	struct ib_cq_init_attr cq_attr = {}; <nl>  	int ret; <nl>  
@@ -329,7 +329,7 @@ static struct platform_driver snvs_rtc_driver = { <nl>  		.name	= "snvs_rtc", <nl>  		.owner	= THIS_MODULE, <nl>  		.pm	= &snvs_rtc_pm_ops, <nl> -		.of_match_table = of_match_ptr(snvs_dt_ids), <nl> +		.of_match_table = snvs_dt_ids, <nl>  	}, <nl>  	.probe		= snvs_rtc_probe, <nl>  };
@@ -681,6 +681,8 @@ struct iwl_cfg iwl6000i_2bg_cfg = { <nl>  	.fw_name_pre = IWL6050_FW_PRE,				\ <nl>  	.ucode_api_max = IWL6050_UCODE_API_MAX,			\ <nl>  	.ucode_api_min = IWL6050_UCODE_API_MIN,			\ <nl> +	.valid_tx_ant = ANT_AB,		/* .cfg overwrite */	\ <nl> +	.valid_rx_ant = ANT_AB,		/* .cfg overwrite */	\ <nl>  	.ops = &iwl6050_ops,					\ <nl>  	.eeprom_ver = EEPROM_6050_EEPROM_VERSION,		\ <nl>  	.eeprom_calib_ver = EEPROM_6050_TX_POWER_VERSION,	\
@@ -298,6 +298,13 @@ static inline bool lowpan_fetch_skb(struct sk_buff *skb, <nl>  	return false; <nl>  } <nl>   <nl> +static inline void lowpan_push_hc_data(u8 **hc_ptr, const void *data, <nl> +				       const size_t len) <nl> +{ <nl> +	memcpy(*hc_ptr, data, len); <nl> +	*hc_ptr += len; <nl> +} <nl> + <nl>  typedef int (*skb_delivery_cb)(struct sk_buff *skb, struct net_device *dev); <nl>   <nl>  int lowpan_process_data(struct sk_buff *skb, struct net_device *dev,
@@ -1482,7 +1482,6 @@ unsigned int ata_sff_qc_issue(struct ata_queued_cmd *qc) <nl>  		break; <nl>   <nl>  	default: <nl> -		WARN_ON_ONCE(1); <nl>  		return AC_ERR_SYSTEM; <nl>  	} <nl>  
@@ -279,7 +279,7 @@ static void cyberjack_read_int_callback(struct urb *urb) <nl>   <nl>  		old_rdtodo = priv->rdtodo; <nl>   <nl> -		if (old_rdtodo + size < old_rdtodo) { <nl> +		if (old_rdtodo > SHRT_MAX - size) { <nl>  			dev_dbg(dev, "To many bulk_in urbs to do.\n"); <nl>  			spin_unlock(&priv->lock); <nl>  			goto resubmit;
@@ -23,7 +23,7 @@ struct wm8994_ldo_pdata { <nl>  	int enable; <nl>   <nl>  	const char *supply; <nl> -	struct regulator_init_data *init_data; <nl> +	const struct regulator_init_data *init_data; <nl>  }; <nl>   <nl>  #define WM8994_CONFIGURE_GPIO 0x10000
@@ -2185,6 +2185,11 @@ static noinline long btrfs_ioctl_clone(struct file *file, unsigned long srcfd, <nl>  	if (!(src_file->f_mode & FMODE_READ)) <nl>  		goto out_fput; <nl>   <nl> +	/* don't make the dst file partly checksummed */ <nl> +	if ((BTRFS_I(src)->flags & BTRFS_INODE_NODATASUM) != <nl> +	    (BTRFS_I(inode)->flags & BTRFS_INODE_NODATASUM)) <nl> +		goto out_fput; <nl> + <nl>  	ret = -EISDIR; <nl>  	if (S_ISDIR(src->i_mode) || S_ISDIR(inode->i_mode)) <nl>  		goto out_fput;
@@ -72,6 +72,8 @@ static int get_kobj_path_length(struct kobject *kobj) <nl>  	 * Add 1 to strlen for leading '/' of each level. <nl>  	 */ <nl>  	do { <nl> +		if (kobject_name(parent) == NULL) <nl> +			return 0; <nl>  		length += strlen(kobject_name(parent)) + 1; <nl>  		parent = parent->parent; <nl>  	} while (parent); <nl> @@ -107,6 +109,8 @@ char *kobject_get_path(struct kobject *kobj, gfp_t gfp_mask) <nl>  	int len; <nl>   <nl>  	len = get_kobj_path_length(kobj); <nl> +	if (len == 0) <nl> +		return NULL; <nl>  	path = kmalloc(len, gfp_mask); <nl>  	if (!path) <nl>  		return NULL;
@@ -512,8 +512,10 @@ static int get_cac_tdp_table( <nl>   <nl>  	hwmgr->dyn_state.cac_dtp_table = kzalloc(table_size, GFP_KERNEL); <nl>   <nl> -	if (NULL == hwmgr->dyn_state.cac_dtp_table) <nl> +	if (NULL == hwmgr->dyn_state.cac_dtp_table) { <nl> +		kfree(tdp_table); <nl>  		return -ENOMEM; <nl> +	} <nl>   <nl>  	memset(hwmgr->dyn_state.cac_dtp_table, 0x00, table_size); <nl>  
@@ -1128,6 +1128,7 @@ static void do_ubd_request(struct request_queue *q) <nl>  					       "errno = %d\n", -n); <nl>  				else if(list_empty(&dev->restart)) <nl>  					list_add(&dev->restart, &restart); <nl> +				kfree(io_req); <nl>  				return; <nl>  			} <nl>  
@@ -489,6 +489,10 @@ static int imx_thermal_probe(struct platform_device *pdev) <nl>  	data->tempmon = map; <nl>   <nl>  	data->socdata = of_device_get_match_data(&pdev->dev); <nl> +	if (!data->socdata) { <nl> +		dev_err(&pdev->dev, "no device match found\n"); <nl> +		return -ENODEV; <nl> +	} <nl>   <nl>  	/* make sure the IRQ flag is clear before enabling irq on i.MX6SX */ <nl>  	if (data->socdata->version == TEMPMON_IMX6SX) {
@@ -434,7 +434,7 @@ int btrfs_is_empty_uuid(u8 *uuid) <nl>   <nl>  static noinline int create_subvol(struct inode *dir, <nl>  				  struct dentry *dentry, <nl> -				  char *name, int namelen, <nl> +				  const char *name, int namelen, <nl>  				  u64 *async_transid, <nl>  				  struct btrfs_qgroup_inherit *inherit) <nl>  { <nl> @@ -832,7 +832,7 @@ static inline int btrfs_may_create(struct inode *dir, struct dentry *child) <nl>   * inside this filesystem so it's quite a bit simpler. <nl>   */ <nl>  static noinline int btrfs_mksubvol(const struct path *parent, <nl> -				   char *name, int namelen, <nl> +				   const char *name, int namelen, <nl>  				   struct btrfs_root *snap_src, <nl>  				   u64 *async_transid, bool readonly, <nl>  				   struct btrfs_qgroup_inherit *inherit) <nl> @@ -1625,7 +1625,7 @@ out: <nl>  } <nl>   <nl>  static noinline int btrfs_ioctl_snap_create_transid(struct file *file, <nl> -				char *name, unsigned long fd, int subvol, <nl> +				const char *name, unsigned long fd, int subvol, <nl>  				u64 *transid, bool readonly, <nl>  				struct btrfs_qgroup_inherit *inherit) <nl>  {
@@ -195,8 +195,8 @@ static void hci_cc_reset(struct hci_dev *hdev, struct sk_buff *skb) <nl>   <nl>  	hci_req_complete(hdev, HCI_OP_RESET, status); <nl>   <nl> -	/* Reset all flags, except persistent ones like HCI_MGMT */ <nl> -	hdev->dev_flags &= BIT(HCI_MGMT); <nl> +	/* Reset all flags, except persistent ones */ <nl> +	hdev->dev_flags &= BIT(HCI_MGMT) | BIT(HCI_SETUP) | BIT(HCI_AUTO_OFF); <nl>  } <nl>   <nl>  static void hci_cc_write_local_name(struct hci_dev *hdev, struct sk_buff *skb)
@@ -299,10 +299,15 @@ static int pcm3168a_set_dai_sysclk(struct snd_soc_dai *dai, <nl>  				  int clk_id, unsigned int freq, int dir) <nl>  { <nl>  	struct pcm3168a_priv *pcm3168a = snd_soc_codec_get_drvdata(dai->codec); <nl> +	int ret; <nl>   <nl>  	if (freq > PCM1368A_MAX_SYSCLK) <nl>  		return -EINVAL; <nl>   <nl> +	ret = clk_set_rate(pcm3168a->scki, freq); <nl> +	if (ret) <nl> +		return ret; <nl> + <nl>  	pcm3168a->sysclk = freq; <nl>   <nl>  	return 0;
@@ -1269,6 +1269,9 @@ tcp_sacktag_write_queue(struct sock *sk, struct sk_buff *ack_skb, u32 prior_snd_ <nl>  	if (before(TCP_SKB_CB(ack_skb)->ack_seq, prior_snd_una - tp->max_window)) <nl>  		return 0; <nl>   <nl> +	if (!tp->packets_out) <nl> +		goto out; <nl> + <nl>  	/* SACK fastpath: <nl>  	 * if the only SACK change is the increase of the end_seq of <nl>  	 * the first block then only apply that SACK block <nl> @@ -1515,6 +1518,8 @@ tcp_sacktag_write_queue(struct sock *sk, struct sk_buff *ack_skb, u32 prior_snd_ <nl>  	    (!tp->frto_highmark || after(tp->snd_una, tp->frto_highmark))) <nl>  		tcp_update_reordering(sk, tp->fackets_out - reord, 0); <nl>   <nl> +out: <nl> + <nl>  #if FASTRETRANS_DEBUG > 0 <nl>  	BUG_TRAP((int)tp->sacked_out >= 0); <nl>  	BUG_TRAP((int)tp->lost_out >= 0);
@@ -214,6 +214,11 @@ static int st33zp24_spi_evaluate_latency(void *phy_id) <nl>  						&data, 1); <nl>  		latency++; <nl>  	} <nl> +	if (status < 0) <nl> +		return status; <nl> +	if (latency == MAX_SPI_LATENCY) <nl> +		return -ENODEV; <nl> + <nl>  	return latency - 1; <nl>  } /* evaluate_latency() */ <nl>  
@@ -644,7 +644,7 @@ static int lx_pipe_wait_for_state(struct lx6464es *chip, u32 pipe, <nl>  		if (err < 0) <nl>  			return err; <nl>   <nl> -		if (current_state == state) <nl> +		if (!err && current_state == state) <nl>  			return 0; <nl>   <nl>  		mdelay(1);
@@ -239,6 +239,8 @@ restore_sigcontext(struct sigcontext __user *sc, struct pt_regs *regs, <nl>  	unsigned long usp; <nl>  	long i, err = __get_user(regs->pc, &sc->sc_pc); <nl>   <nl> +	current_thread_info()->restart_block.fn = do_no_restart_syscall; <nl> + <nl>  	sw->r26 = (unsigned long) ret_from_sys_call; <nl>   <nl>  	err |= __get_user(regs->r0, sc->sc_regs+0); <nl> @@ -591,7 +593,6 @@ syscall_restart(unsigned long r0, unsigned long r19, <nl>  		regs->pc -= 4; <nl>  		break; <nl>  	case ERESTART_RESTARTBLOCK: <nl> -		current_thread_info()->restart_block.fn = do_no_restart_syscall; <nl>  		regs->r0 = EINTR; <nl>  		break; <nl>  	}
@@ -1429,7 +1429,7 @@ static int domain_context_mapping_one(struct dmar_domain *domain, int segment, <nl>  	domain_flush_cache(domain, context, sizeof(*context)); <nl>   <nl>  	/* it's a non-present to present mapping */ <nl> -	if (iommu->flush.flush_context(iommu, domain->id, <nl> +	if (iommu->flush.flush_context(iommu, id, <nl>  		(((u16)bus) << 8) | devfn, DMA_CCMD_MASK_NOBIT, <nl>  		DMA_CCMD_DEVICE_INVL, 1)) <nl>  		iommu_flush_write_buffer(iommu);
@@ -1161,7 +1161,7 @@ static int tsi721_rio_map_inb_mem(struct rio_mport *mport, dma_addr_t lstart, <nl>  		} else if (ibw_start < (ib_win->rstart + ib_win->size) && <nl>  			   (ibw_start + ibw_size) > ib_win->rstart) { <nl>  			/* Return error if address translation involved */ <nl> -			if (direct && ib_win->xlat) { <nl> +			if (!direct || ib_win->xlat) { <nl>  				ret = -EFAULT; <nl>  				break; <nl>  			}
@@ -75,13 +75,13 @@ <nl>  #define AR9300_OTP_BASE \ <nl>  		((AR_SREV_9340(ah) || AR_SREV_9550(ah)) ? 0x30000 : 0x14000) <nl>  #define AR9300_OTP_STATUS \ <nl> -		((AR_SREV_9340(ah) || AR_SREV_9550(ah)) ? 0x30018 : 0x15f18) <nl> +		((AR_SREV_9340(ah) || AR_SREV_9550(ah)) ? 0x31018 : 0x15f18) <nl>  #define AR9300_OTP_STATUS_TYPE		0x7 <nl>  #define AR9300_OTP_STATUS_VALID		0x4 <nl>  #define AR9300_OTP_STATUS_ACCESS_BUSY	0x2 <nl>  #define AR9300_OTP_STATUS_SM_BUSY	0x1 <nl>  #define AR9300_OTP_READ_DATA \ <nl> -		((AR_SREV_9340(ah) || AR_SREV_9550(ah)) ? 0x3001c : 0x15f1c) <nl> +		((AR_SREV_9340(ah) || AR_SREV_9550(ah)) ? 0x3101c : 0x15f1c) <nl>   <nl>  enum targetPowerHTRates { <nl>  	HT_TARGET_RATE_0_8_16,
@@ -144,9 +144,9 @@ again: <nl>  	add_dev (numdevs++, port, -1); <nl>   <nl>  	/* Find out the legacy device's IEEE 1284 device ID. */ <nl> -	deviceid = kmalloc (1000, GFP_KERNEL); <nl> +	deviceid = kmalloc (1024, GFP_KERNEL); <nl>  	if (deviceid) { <nl> -		if (parport_device_id (numdevs - 1, deviceid, 1000) > 2) <nl> +		if (parport_device_id (numdevs - 1, deviceid, 1024) > 2) <nl>  			detected++; <nl>   <nl>  		kfree (deviceid); <nl> @@ -508,11 +508,11 @@ static int assign_addrs (struct parport *port) <nl>  		 detected); <nl>   <nl>  	/* Ask the new devices to introduce themselves. */ <nl> -	deviceid = kmalloc (1000, GFP_KERNEL); <nl> +	deviceid = kmalloc (1024, GFP_KERNEL); <nl>  	if (!deviceid) return 0; <nl>   <nl>  	for (daisy = 0; thisdev < numdevs; thisdev++, daisy++) <nl> -		parport_device_id (thisdev, deviceid, 1000); <nl> +		parport_device_id (thisdev, deviceid, 1024); <nl>   <nl>  	kfree (deviceid); <nl>  	return detected;
@@ -796,10 +796,11 @@ static ssize_t store_ledd(struct device *dev, struct device_attribute *attr, <nl>   <nl>  	rv = parse_arg(buf, count, &value); <nl>  	if (rv > 0) { <nl> -		if (write_acpi_int(asus->handle, METHOD_LEDD, value)) <nl> +		if (write_acpi_int(asus->handle, METHOD_LEDD, value)) { <nl>  			pr_warning("LED display write failed\n"); <nl> -		else <nl> -			asus->ledd_status = (u32) value; <nl> +			return -ENODEV; <nl> +		} <nl> +		asus->ledd_status = (u32) value; <nl>  	} <nl>  	return rv; <nl>  }
@@ -283,6 +283,7 @@ static int __devinit snd_gusextreme_probe(struct device *dev, unsigned int n) <nl>  			"detected at 0x%lx\n", dev->bus_id, gus->gf1.port); <nl>  		goto out; <nl>  	} <nl> +	gus->codec_flag = 1; <nl>   <nl>  	error = snd_es1688_pcm(es1688, 0, NULL); <nl>  	if (error < 0)
@@ -267,9 +267,9 @@ int go7007_snd_init(struct go7007 *go) <nl>  		kfree(gosnd); <nl>  		return ret; <nl>  	} <nl> -	strncpy(gosnd->card->driver, "go7007", sizeof(gosnd->card->driver)); <nl> -	strncpy(gosnd->card->shortname, go->name, sizeof(gosnd->card->driver)); <nl> -	strncpy(gosnd->card->longname, gosnd->card->shortname, <nl> +	strlcpy(gosnd->card->driver, "go7007", sizeof(gosnd->card->driver)); <nl> +	strlcpy(gosnd->card->shortname, go->name, sizeof(gosnd->card->driver)); <nl> +	strlcpy(gosnd->card->longname, gosnd->card->shortname, <nl>  			sizeof(gosnd->card->longname)); <nl>   <nl>  	gosnd->pcm->private_data = go;
@@ -135,7 +135,12 @@ void __init early_fixup_exception(struct pt_regs *regs, int trapnr) <nl>  	if (early_recursion_flag > 2) <nl>  		goto halt_loop; <nl>   <nl> -	if (regs->cs != __KERNEL_CS) <nl> +	/* <nl> +	 * Old CPUs leave the high bits of CS on the stack <nl> +	 * undefined.  I'm not sure which CPUs do this, but at least <nl> +	 * the 486 DX works this way. <nl> +	 */ <nl> +	if ((regs->cs & 0xFFFF) != __KERNEL_CS) <nl>  		goto fail; <nl>   <nl>  	/*
@@ -70,7 +70,7 @@ xfs_find_handle( <nl>  	int			hsize; <nl>  	xfs_handle_t		handle; <nl>  	struct inode		*inode; <nl> -	struct fd		f; <nl> +	struct fd		f = {0}; <nl>  	struct path		path; <nl>  	int			error; <nl>  	struct xfs_inode	*ip;
@@ -465,7 +465,7 @@ static ssize_t devkmsg_read(struct file *file, char __user *buf, <nl>  	for (i = 0; i < msg->text_len; i++) { <nl>  		unsigned char c = log_text(msg)[i]; <nl>   <nl> -		if (c < ' ' || c >= 128) <nl> +		if (c < ' ' || c >= 127 || c == '\\') <nl>  			len += sprintf(user->buf + len, "\\x%02x", c); <nl>  		else <nl>  			user->buf[len++] = c; <nl> @@ -489,7 +489,7 @@ static ssize_t devkmsg_read(struct file *file, char __user *buf, <nl>  				continue; <nl>  			} <nl>   <nl> -			if (c < ' ' || c >= 128) { <nl> +			if (c < ' ' || c >= 127 || c == '\\') { <nl>  				len += sprintf(user->buf + len, "\\x%02x", c); <nl>  				continue; <nl>  			}
@@ -1302,6 +1302,11 @@ static bool shadow_walk_okay(struct kvm_shadow_walk_iterator *iterator) <nl>  { <nl>  	if (iterator->level < PT_PAGE_TABLE_LEVEL) <nl>  		return false; <nl> + <nl> +	if (iterator->level == PT_PAGE_TABLE_LEVEL) <nl> +		if (is_large_pte(*iterator->sptep)) <nl> +			return false; <nl> + <nl>  	iterator->index = SHADOW_PT_INDEX(iterator->addr, iterator->level); <nl>  	iterator->sptep	= ((u64 *)__va(iterator->shadow_addr)) + iterator->index; <nl>  	return true;
@@ -318,9 +318,9 @@ out_attach: <nl>  static void ocfs2_drop_dentry_lock(struct ocfs2_super *osb, <nl>  				   struct ocfs2_dentry_lock *dl) <nl>  { <nl> +	iput(dl->dl_inode); <nl>  	ocfs2_simple_drop_lockres(osb, &dl->dl_lockres); <nl>  	ocfs2_lock_res_free(&dl->dl_lockres); <nl> -	iput(dl->dl_inode); <nl>  	kfree(dl); <nl>  } <nl>  
@@ -2226,8 +2226,11 @@ static int add_new_disk(mddev_t * mddev, mdu_disk_info_t *info) <nl>  			       mdname(mddev)); <nl>  			return -EINVAL; <nl>  		} <nl> -		rdev = md_import_device(dev, mddev->major_version, <nl> -					mddev->minor_version); <nl> +		if (mddev->persistent) <nl> +			rdev = md_import_device(dev, mddev->major_version, <nl> +						mddev->minor_version); <nl> +		else <nl> +			rdev = md_import_device(dev, -1, -1); <nl>  		if (IS_ERR(rdev)) { <nl>  			printk(KERN_WARNING  <nl>  				"md: md_import_device returned %ld\n",
@@ -212,6 +212,9 @@ static void vmw_fb_dirty_flush(struct vmw_fb_par *par) <nl>  		SVGAFifoCmdUpdate body; <nl>  	} *cmd; <nl>   <nl> +	if (vmw_priv->suspended) <nl> +		return; <nl> + <nl>  	spin_lock_irqsave(&par->dirty.lock, flags); <nl>  	if (!par->dirty.active) { <nl>  		spin_unlock_irqrestore(&par->dirty.lock, flags);
@@ -33,6 +33,9 @@ int mmap_min_addr_handler(struct ctl_table *table, int write, <nl>  { <nl>  	int ret; <nl>   <nl> +	if (!capable(CAP_SYS_RAWIO)) <nl> +		return -EPERM; <nl> + <nl>  	ret = proc_doulongvec_minmax(table, write, buffer, lenp, ppos); <nl>   <nl>  	update_mmap_min_addr();
@@ -492,8 +492,9 @@ static ssize_t bonding_show_mii_status(struct device *d, <nl>  				       char *buf) <nl>  { <nl>  	struct bonding *bond = to_bond(d); <nl> +	bool active = !!rcu_access_pointer(bond->curr_active_slave); <nl>   <nl> -	return sprintf(buf, "%s\n", bond->curr_active_slave ? "up" : "down"); <nl> +	return sprintf(buf, "%s\n", active ? "up" : "down"); <nl>  } <nl>  static DEVICE_ATTR(mii_status, S_IRUGO, bonding_show_mii_status, NULL); <nl>  
@@ -260,7 +260,7 @@ dasd_ioctl_information(struct dasd_device *device, <nl>  	if (!device->discipline->fill_info) <nl>  		return -EINVAL; <nl>   <nl> -	dasd_info = kmalloc(sizeof(struct dasd_information2_t), GFP_KERNEL); <nl> +	dasd_info = kzalloc(sizeof(struct dasd_information2_t), GFP_KERNEL); <nl>  	if (dasd_info == NULL) <nl>  		return -ENOMEM; <nl>   <nl> @@ -303,8 +303,7 @@ dasd_ioctl_information(struct dasd_device *device, <nl>  		memcpy(dasd_info->type, device->discipline->name, 4); <nl>  	else <nl>  		memcpy(dasd_info->type, "none", 4); <nl> -	dasd_info->req_queue_len = 0; <nl> -	dasd_info->chanq_len = 0; <nl> + <nl>  	if (device->request_queue->request_fn) { <nl>  		struct list_head *l; <nl>  #ifdef DASD_EXTENDED_PROFILING
@@ -380,14 +380,20 @@ static void mcasp_start_tx(struct davinci_audio_dev *dev) <nl>  static void davinci_mcasp_start(struct davinci_audio_dev *dev, int stream) <nl>  { <nl>  	if (stream == SNDRV_PCM_STREAM_PLAYBACK) { <nl> -		if (dev->txnumevt)	/* enable FIFO */ <nl> +		if (dev->txnumevt) {	/* enable FIFO */ <nl> +			mcasp_clr_bits(dev->base + DAVINCI_MCASP_WFIFOCTL, <nl> +								FIFO_ENABLE); <nl>  			mcasp_set_bits(dev->base + DAVINCI_MCASP_WFIFOCTL, <nl>  								FIFO_ENABLE); <nl> +		} <nl>  		mcasp_start_tx(dev); <nl>  	} else { <nl> -		if (dev->rxnumevt)	/* enable FIFO */ <nl> +		if (dev->rxnumevt) {	/* enable FIFO */ <nl> +			mcasp_clr_bits(dev->base + DAVINCI_MCASP_RFIFOCTL, <nl> +								FIFO_ENABLE); <nl>  			mcasp_set_bits(dev->base + DAVINCI_MCASP_RFIFOCTL, <nl>  								FIFO_ENABLE); <nl> +		} <nl>  		mcasp_start_rx(dev); <nl>  	} <nl>  }
@@ -310,6 +310,15 @@ int blkdev_issue_flush(struct block_device *bdev, gfp_t gfp_mask, <nl>  	if (!q) <nl>  		return -ENXIO; <nl>   <nl> +	/* <nl> +	 * some block devices may not have their queue correctly set up here <nl> +	 * (e.g. loop device without a backing file) and so issuing a flush <nl> +	 * here will panic. Ensure there is a request function before issuing <nl> +	 * the barrier. <nl> +	 */ <nl> +	if (!q->make_request_fn) <nl> +		return -ENXIO; <nl> + <nl>  	bio = bio_alloc(gfp_mask, 0); <nl>  	bio->bi_end_io = bio_end_empty_barrier; <nl>  	bio->bi_bdev = bdev;
@@ -307,7 +307,7 @@ static int ieee80211_tkip_encrypt(struct sk_buff *skb, int hdr_len, void *priv) <nl>  	int len; <nl>  	u8  *pos; <nl>  	struct ieee80211_hdr_4addr *hdr; <nl> -	u8 rc4key[16],*icv; <nl> +	u8 rc4key[16], *icv; <nl>  	u32 crc; <nl>  	struct scatterlist sg; <nl>  	int ret; <nl> @@ -348,7 +348,7 @@ static int ieee80211_tkip_encrypt(struct sk_buff *skb, int hdr_len, void *priv) <nl>  	icv[3] = crc >> 24; <nl>  	crypto_blkcipher_setkey(tkey->tx_tfm_arc4, rc4key, 16); <nl>  	sg_init_one(&sg, pos, len + 4); <nl> -	ret= crypto_blkcipher_encrypt(&desc, &sg, &sg, len + 4); <nl> +	ret = crypto_blkcipher_encrypt(&desc, &sg, &sg, len + 4); <nl>   <nl>  	tkey->tx_iv16++; <nl>  	if (tkey->tx_iv16 == 0) { <nl> @@ -537,7 +537,7 @@ static int ieee80211_michael_mic_add(struct sk_buff *skb, int hdr_len, <nl>   <nl>  	michael_mic_hdr(skb, tkey->tx_hdr); <nl>   <nl> -	if(IEEE80211_QOS_HAS_SEQ(le16_to_cpu(hdr->frame_ctl))) { <nl> +	if (IEEE80211_QOS_HAS_SEQ(le16_to_cpu(hdr->frame_ctl))) { <nl>  		tkey->tx_hdr[12] = *(skb->data + hdr_len - 2) & 0x07; <nl>  	} <nl>  	pos = skb_put(skb, 8); <nl> @@ -583,7 +583,7 @@ static int ieee80211_michael_mic_verify(struct sk_buff *skb, int keyidx, <nl>  		return -1; <nl>   <nl>  	michael_mic_hdr(skb, tkey->rx_hdr); <nl> -	if(IEEE80211_QOS_HAS_SEQ(le16_to_cpu(hdr->frame_ctl))) { <nl> +	if (IEEE80211_QOS_HAS_SEQ(le16_to_cpu(hdr->frame_ctl))) { <nl>  		tkey->rx_hdr[12] = *(skb->data + hdr_len - 2) & 0x07; <nl>  	} <nl>  
@@ -286,7 +286,8 @@ static struct async *alloc_async(unsigned int numisoframes) <nl>  static void free_async(struct async *as) <nl>  { <nl>  	put_pid(as->pid); <nl> -	put_cred(as->cred); <nl> +	if (as->cred) <nl> +		put_cred(as->cred); <nl>  	kfree(as->urb->transfer_buffer); <nl>  	kfree(as->urb->setup_packet); <nl>  	usb_free_urb(as->urb);
@@ -446,6 +446,7 @@ static int usbvision_v4l2_close(struct file *file) <nl>  	if (usbvision->remove_pending) { <nl>  		printk(KERN_INFO "%s: Final disconnect\n", __func__); <nl>  		usbvision_release(usbvision); <nl> +		return 0; <nl>  	} <nl>  	mutex_unlock(&usbvision->v4l2_lock); <nl>   <nl> @@ -1221,6 +1222,7 @@ static int usbvision_radio_close(struct file *file) <nl>  	if (usbvision->remove_pending) { <nl>  		printk(KERN_INFO "%s: Final disconnect\n", __func__); <nl>  		usbvision_release(usbvision); <nl> +		return err_code; <nl>  	} <nl>   <nl>  	mutex_unlock(&usbvision->v4l2_lock);
@@ -396,7 +396,8 @@ static int send_reply(struct svcxprt_rdma *rdma, <nl>  		       "svcrdma: could not post a receive buffer, err=%d." <nl>  		       "Closing transport %p.\n", ret, rdma); <nl>  		set_bit(XPT_CLOSE, &rdma->sc_xprt.xpt_flags); <nl> -		return 0; <nl> +		svc_rdma_put_context(ctxt, 0); <nl> +		return -ENOTCONN; <nl>  	} <nl>   <nl>  	/* Prepare the context */
@@ -1012,6 +1012,7 @@ static struct mlx5_ib_mr *reg_create(struct ib_pd *pd, u64 virt_addr, <nl>  		goto err_2; <nl>  	} <nl>  	mr->umem = umem; <nl> +	mr->dev = dev; <nl>  	mr->live = 1; <nl>  	kvfree(in); <nl>  
@@ -1139,7 +1139,7 @@ static void be_rx_compl_process(struct be_adapter *adapter, <nl>  		skb->rxhash = rxcp->rss_hash; <nl>   <nl>   <nl> -	if (unlikely(rxcp->vlanf)) <nl> +	if (rxcp->vlanf) <nl>  		__vlan_hwaccel_put_tag(skb, rxcp->vlan_tag); <nl>   <nl>  	netif_receive_skb(skb); <nl> @@ -1196,7 +1196,7 @@ static void be_rx_compl_process_gro(struct be_adapter *adapter, <nl>  	if (adapter->netdev->features & NETIF_F_RXHASH) <nl>  		skb->rxhash = rxcp->rss_hash; <nl>   <nl> -	if (unlikely(rxcp->vlanf)) <nl> +	if (rxcp->vlanf) <nl>  		__vlan_hwaccel_put_tag(skb, rxcp->vlan_tag); <nl>   <nl>  	napi_gro_frags(&eq_obj->napi);
@@ -835,6 +835,7 @@ do_kern_mount(const char *fstype, int flags, const char *name, void *data) <nl>  	mnt->mnt_parent = mnt; <nl>  	mnt->mnt_namespace = current->namespace; <nl>  	up_write(&sb->s_umount); <nl> +	free_secdata(secdata); <nl>  	put_filesystem(type); <nl>  	return mnt; <nl>  out_sb:
@@ -1354,6 +1354,12 @@ radeon_user_framebuffer_create(struct drm_device *dev, <nl>  		return ERR_PTR(-ENOENT); <nl>  	} <nl>   <nl> +	/* Handle is imported dma-buf, so cannot be migrated to VRAM for scanout */ <nl> +	if (obj->import_attach) { <nl> +		DRM_DEBUG_KMS("Cannot create framebuffer from imported dma_buf\n"); <nl> +		return ERR_PTR(-EINVAL); <nl> +	} <nl> + <nl>  	radeon_fb = kzalloc(sizeof(*radeon_fb), GFP_KERNEL); <nl>  	if (radeon_fb == NULL) { <nl>  		drm_gem_object_unreference_unlocked(obj);
@@ -1510,6 +1510,8 @@ imsttfb_probe(struct pci_dev *pdev, const struct pci_device_id *ent) <nl>  		default: <nl>  			printk(KERN_INFO "imsttfb: Device 0x%x unknown, " <nl>  					 "contact maintainer.\n", pdev->device); <nl> +			release_mem_region(addr, size); <nl> +			framebuffer_release(info); <nl>  			return -ENODEV; <nl>  	} <nl>  
@@ -134,7 +134,7 @@ static int __init snd_cx18_card_set_names(struct snd_cx18_card *cxsc) <nl>  static int __init snd_cx18_init(struct v4l2_device *v4l2_dev) <nl>  { <nl>  	struct cx18 *cx = to_cx18(v4l2_dev); <nl> -	struct snd_card *sc; <nl> +	struct snd_card *sc = NULL; <nl>  	struct snd_cx18_card *cxsc; <nl>  	int ret; <nl>   <nl> @@ -189,7 +189,8 @@ static int __init snd_cx18_init(struct v4l2_device *v4l2_dev) <nl>  	return 0; <nl>   <nl>  err_exit_free: <nl> -	snd_card_free(sc); <nl> +	if (sc != NULL) <nl> +		snd_card_free(sc); <nl>  err_exit: <nl>  	return ret; <nl>  }
@@ -1033,6 +1033,9 @@ static void ui_browser__hists_seek(struct ui_browser *browser, <nl>  	 * and stop when we printed enough lines to fill the screen. <nl>  	 */ <nl>  do_offset: <nl> +	if (!nd) <nl> +		return; <nl> + <nl>  	if (offset > 0) { <nl>  		do { <nl>  			h = rb_entry(nd, struct hist_entry, rb_node);
@@ -1895,8 +1895,7 @@ static int nes_destroy_cq(struct ib_cq *ib_cq) <nl>  static u32 root_256(struct nes_device *nesdev, <nl>  		    struct nes_root_vpbl *root_vpbl, <nl>  		    struct nes_root_vpbl *new_root, <nl> -		    u16 pbl_count_4k, <nl> -		    u16 pbl_count_256) <nl> +		    u16 pbl_count_4k) <nl>  { <nl>  	u64 leaf_pbl; <nl>  	int i, j, k; <nl> @@ -2012,7 +2011,7 @@ static int nes_reg_mr(struct nes_device *nesdev, struct nes_pd *nespd, <nl>  	} <nl>   <nl>  	if (use_256_pbls && use_two_level) { <nl> -		if (root_256(nesdev, root_vpbl, &new_root, pbl_count_4k, pbl_count_256) == 1) { <nl> +		if (root_256(nesdev, root_vpbl, &new_root, pbl_count_4k) == 1) { <nl>  			if (new_root.pbl_pbase != 0) <nl>  				root_vpbl = &new_root; <nl>  		} else {
@@ -76,7 +76,7 @@ static struct collection collections[] = { <nl>   <nl>  /* Iterate over all benchmarks within a collection: */ <nl>  #define for_each_bench(coll, bench) \ <nl> -	for (bench = coll->benchmarks; bench->name; bench++) <nl> +	for (bench = coll->benchmarks; bench && bench->name; bench++) <nl>   <nl>  static void dump_benchmarks(struct collection *coll) <nl>  {
@@ -51,7 +51,9 @@ static int record_connection(char *host, char *port, char *busid, int rhport) <nl>  	char buff[MAX_BUFF+1]; <nl>  	int ret; <nl>   <nl> -	mkdir(VHCI_STATE_PATH, 0700); <nl> +	ret = mkdir(VHCI_STATE_PATH, 0700); <nl> +	if (ret < 0) <nl> +		return -1; <nl>   <nl>  	snprintf(path, PATH_MAX, VHCI_STATE_PATH"/port%d", rhport); <nl>  
@@ -7716,6 +7716,7 @@ static int si_dpm_init_microcode(struct amdgpu_device *adev) <nl>  		    (adev->pdev->revision == 0x80) || <nl>  		    (adev->pdev->revision == 0x81) || <nl>  		    (adev->pdev->revision == 0x83) || <nl> +		    (adev->pdev->revision == 0x87) || <nl>  		    (adev->pdev->device == 0x6604) || <nl>  		    (adev->pdev->device == 0x6605)) <nl>  			chip_name = "oland_k";
@@ -2161,8 +2161,6 @@ static void e1000_set_rx_mode(struct net_device *netdev) <nl>  			e1000_rar_set(hw, ha->addr, i++); <nl>  		} <nl>   <nl> -	WARN_ON(i == rar_entries); <nl> - <nl>  	netdev_for_each_mc_addr(ha, netdev) { <nl>  		if (i == rar_entries) { <nl>  			/* load any remaining addresses into the hash table */
@@ -353,7 +353,15 @@ static int __init omap_hsmmc_pdata_init(struct omap2_hsmmc_info *c, <nl>  	 * <nl>  	 * temporary HACK: ocr_mask instead of fixed supply <nl>  	 */ <nl> -	mmc->slots[0].ocr_mask = c->ocr_mask; <nl> +	if (cpu_is_omap3505() || cpu_is_omap3517()) <nl> +		mmc->slots[0].ocr_mask = MMC_VDD_165_195 | <nl> +					 MMC_VDD_26_27 | <nl> +					 MMC_VDD_27_28 | <nl> +					 MMC_VDD_29_30 | <nl> +					 MMC_VDD_30_31 | <nl> +					 MMC_VDD_31_32; <nl> +	else <nl> +		mmc->slots[0].ocr_mask = c->ocr_mask; <nl>   <nl>  	if (!cpu_is_omap3517() && !cpu_is_omap3505()) <nl>  		mmc->slots[0].features |= HSMMC_HAS_PBIAS;
@@ -991,6 +991,8 @@ void usb_buffer_unmap_sg (struct usb_device *dev, unsigned pipe, <nl>   <nl>  static int verify_suspended(struct device *dev, void *unused) <nl>  { <nl> +	if (dev->driver == NULL) <nl> +		return 0; <nl>  	return (dev->power.power_state.event == PM_EVENT_ON) ? -EBUSY : 0; <nl>  } <nl>  
@@ -1361,8 +1361,10 @@ static int wacom_probe(struct usb_interface *intf, const struct usb_device_id *i <nl>  	usb_set_intfdata(intf, wacom); <nl>   <nl>  	if (features->quirks & WACOM_QUIRK_MONITOR) { <nl> -		if (usb_submit_urb(wacom->irq, GFP_KERNEL)) <nl> +		if (usb_submit_urb(wacom->irq, GFP_KERNEL)) { <nl> +			error = -EIO; <nl>  			goto fail5; <nl> +		} <nl>  	} <nl>   <nl>  	return 0; <nl> @@ -1417,8 +1419,8 @@ static int wacom_resume(struct usb_interface *intf) <nl>  	wacom_query_tablet_data(intf, features); <nl>  	wacom_led_control(wacom); <nl>   <nl> -	if ((wacom->open || features->quirks & WACOM_QUIRK_MONITOR) <nl> -	     && usb_submit_urb(wacom->irq, GFP_NOIO) < 0) <nl> +	if ((wacom->open || (features->quirks & WACOM_QUIRK_MONITOR)) && <nl> +	    usb_submit_urb(wacom->irq, GFP_NOIO) < 0) <nl>  		rv = -EIO; <nl>   <nl>  	mutex_unlock(&wacom->lock);
@@ -1479,8 +1479,9 @@ static int ath9k_add_interface(struct ieee80211_hw *hw, <nl>  		} <nl>  	} <nl>   <nl> -	if ((vif->type == NL80211_IFTYPE_ADHOC) && <nl> -	    sc->nvifs > 0) { <nl> +	if ((ah->opmode == NL80211_IFTYPE_ADHOC) || <nl> +	    ((vif->type == NL80211_IFTYPE_ADHOC) && <nl> +	     sc->nvifs > 0)) { <nl>  		ath_err(common, "Cannot create ADHOC interface when other" <nl>  			" interfaces already exist.\n"); <nl>  		ret = -EINVAL;
@@ -163,7 +163,7 @@ static void arc_emac_tx_clean(struct net_device *ndev) <nl>  		struct sk_buff *skb = tx_buff->skb; <nl>  		unsigned int info = le32_to_cpu(txbd->info); <nl>   <nl> -		if ((info & FOR_EMAC) || !txbd->data) <nl> +		if ((info & FOR_EMAC) || !txbd->data || !skb) <nl>  			break; <nl>   <nl>  		if (unlikely(info & (DROP | DEFR | LTCL | UFLO))) { <nl> @@ -191,6 +191,7 @@ static void arc_emac_tx_clean(struct net_device *ndev) <nl>   <nl>  		txbd->data = 0; <nl>  		txbd->info = 0; <nl> +		tx_buff->skb = NULL; <nl>   <nl>  		*txbd_dirty = (*txbd_dirty + 1) % TX_BD_NUM; <nl>  	} <nl> @@ -610,7 +611,6 @@ static int arc_emac_tx(struct sk_buff *skb, struct net_device *ndev) <nl>  	dma_unmap_addr_set(&priv->tx_buff[*txbd_curr], addr, addr); <nl>  	dma_unmap_len_set(&priv->tx_buff[*txbd_curr], len, len); <nl>   <nl> -	priv->tx_buff[*txbd_curr].skb = skb; <nl>  	priv->txbd[*txbd_curr].data = cpu_to_le32(addr); <nl>   <nl>  	/* Make sure pointer to data buffer is set */ <nl> @@ -620,6 +620,11 @@ static int arc_emac_tx(struct sk_buff *skb, struct net_device *ndev) <nl>   <nl>  	*info = cpu_to_le32(FOR_EMAC | FIRST_OR_LAST_MASK | len); <nl>   <nl> +	/* Make sure info word is set */ <nl> +	wmb(); <nl> + <nl> +	priv->tx_buff[*txbd_curr].skb = skb; <nl> + <nl>  	/* Increment index to point to the next BD */ <nl>  	*txbd_curr = (*txbd_curr + 1) % TX_BD_NUM; <nl>  
@@ -1087,7 +1087,6 @@ int btrfs_defrag_file(struct inode *inode, struct file *file, <nl>   <nl>  		defrag_count += ret; <nl>  		balance_dirty_pages_ratelimited_nr(inode->i_mapping, ret); <nl> -		i += ret; <nl>   <nl>  		if (newer_than) { <nl>  			if (newer_off == (u64)-1) <nl> @@ -1107,7 +1106,10 @@ int btrfs_defrag_file(struct inode *inode, struct file *file, <nl>  				break; <nl>  			} <nl>  		} else { <nl> -			i++; <nl> +			if (ret > 0) <nl> +				i += ret; <nl> +			else <nl> +				i++; <nl>  		} <nl>  	} <nl>  
@@ -323,12 +323,15 @@ static inline unsigned int ip_dst_mtu_maybe_forward(const struct dst_entry *dst, <nl>   <nl>  static inline unsigned int ip_skb_dst_mtu(const struct sk_buff *skb) <nl>  { <nl> -	if (!skb->sk || ip_sk_use_pmtu(skb->sk)) { <nl> +	struct sock *sk = skb->sk; <nl> + <nl> +	if (!sk || !sk_fullsock(sk) || ip_sk_use_pmtu(sk)) { <nl>  		bool forwarding = IPCB(skb)->flags & IPSKB_FORWARDED; <nl> + <nl>  		return ip_dst_mtu_maybe_forward(skb_dst(skb), forwarding); <nl> -	} else { <nl> -		return min(skb_dst(skb)->dev->mtu, IP_MAX_MTU); <nl>  	} <nl> + <nl> +	return min(skb_dst(skb)->dev->mtu, IP_MAX_MTU); <nl>  } <nl>   <nl>  u32 ip_idents_reserve(u32 hash, int segs);
@@ -1372,6 +1372,8 @@ static int lowpan_newlink(struct net *src_net, struct net_device *dev, <nl>  	real_dev = dev_get_by_index(src_net, nla_get_u32(tb[IFLA_LINK])); <nl>  	if (!real_dev) <nl>  		return -ENODEV; <nl> +	if (real_dev->type != ARPHRD_IEEE802154) <nl> +		return -EINVAL; <nl>   <nl>  	lowpan_dev_info(dev)->real_dev = real_dev; <nl>  	lowpan_dev_info(dev)->fragment_tag = 0;
@@ -976,7 +976,7 @@ static int ltr501_write_event_config(struct iio_dev *indio_dev, <nl>  	int ret; <nl>   <nl>  	/* only 1 and 0 are valid inputs */ <nl> -	if (state != 1  || state != 0) <nl> +	if (state != 1  && state != 0) <nl>  		return -EINVAL; <nl>   <nl>  	switch (chan->type) {
@@ -571,6 +571,10 @@ int call_usermodehelper_exec(struct subprocess_info *sub_info, int wait) <nl>  	DECLARE_COMPLETION_ONSTACK(done); <nl>  	int retval = 0; <nl>   <nl> +	if (!sub_info->path) { <nl> +		call_usermodehelper_freeinfo(sub_info); <nl> +		return -EINVAL; <nl> +	} <nl>  	helper_lock(); <nl>  	if (!khelper_wq || usermodehelper_disabled) { <nl>  		retval = -EBUSY;
@@ -442,6 +442,7 @@ static int spi_imx_setupxfer(struct spi_device *spi, <nl>  	config.bpw = t ? t->bits_per_word : spi->bits_per_word; <nl>  	config.speed_hz  = t ? t->speed_hz : spi->max_speed_hz; <nl>  	config.mode = spi->mode; <nl> +	config.cs = spi_imx->chipselect[spi->chip_select]; <nl>   <nl>  	if (!config.speed_hz) <nl>  		config.speed_hz = spi->max_speed_hz;
@@ -1028,6 +1028,9 @@ void audit_log_hex(struct audit_buffer *ab, const unsigned char *buf, <nl>  	struct sk_buff *skb; <nl>  	static const unsigned char *hex = "0123456789ABCDEF"; <nl>   <nl> +	if (!ab) <nl> +		return; <nl> + <nl>  	BUG_ON(!ab->skb); <nl>  	skb = ab->skb; <nl>  	avail = skb_tailroom(skb); <nl> @@ -1060,6 +1063,9 @@ static void audit_log_n_string(struct audit_buffer *ab, size_t slen, <nl>  	unsigned char *ptr; <nl>  	struct sk_buff *skb; <nl>   <nl> +	if (!ab) <nl> +		return; <nl> + <nl>  	BUG_ON(!ab->skb); <nl>  	skb = ab->skb; <nl>  	avail = skb_tailroom(skb);
@@ -982,7 +982,7 @@ static int __devinit mei_probe(struct pci_dev *pdev, <nl>  		err = request_threaded_irq(pdev->irq, <nl>  			NULL, <nl>  			mei_interrupt_thread_handler, <nl> -			0, mei_driver_name, dev); <nl> +			IRQF_ONESHOT, mei_driver_name, dev); <nl>  	else <nl>  		err = request_threaded_irq(pdev->irq, <nl>  			mei_interrupt_quick_handler,
@@ -612,7 +612,7 @@ static void get_total_mem(struct mv64x60_mc_pdata *pdata) <nl>  	if (!np) <nl>  		return; <nl>   <nl> -	reg = get_property(np, "reg", NULL); <nl> +	reg = of_get_property(np, "reg", NULL); <nl>   <nl>  	pdata->total_mem = reg[1]; <nl>  }
@@ -116,7 +116,8 @@ MODULE_PARM_DESC(write_timeout, "Time (in ms) to try writes (default 25)"); <nl>  /* <nl>   * Both reads and writes fail if the previous write didn't complete yet. This <nl>   * macro loops a few times waiting at least long enough for one entire page <nl> - * write to work. <nl> + * write to work while making sure that at least one iteration is run before <nl> + * checking the break condition. <nl>   * <nl>   * It takes two parameters: a variable in which the future timeout in jiffies <nl>   * will be stored and a temporary variable holding the time of the last <nl> @@ -124,9 +125,8 @@ MODULE_PARM_DESC(write_timeout, "Time (in ms) to try writes (default 25)"); <nl>   * holding at least 32 bits. <nl>   */ <nl>  #define loop_until_timeout(tout, op_time)				\ <nl> -	for (tout = jiffies + msecs_to_jiffies(write_timeout),		\ <nl> -		op_time = jiffies;					\ <nl> -	     time_before(op_time, tout);				\ <nl> +	for (tout = jiffies + msecs_to_jiffies(write_timeout), op_time = 0; \ <nl> +	     op_time ? time_before(op_time, tout) : true;		\ <nl>  	     usleep_range(1000, 1500), op_time = jiffies) <nl>   <nl>  static const struct i2c_device_id at24_ids[] = {
@@ -13,6 +13,9 @@ void print_stack_trace(struct stack_trace *trace, int spaces) <nl>  { <nl>  	int i, j; <nl>   <nl> +	if (WARN_ON(!trace->entries)) <nl> +		return; <nl> + <nl>  	for (i = 0; i < trace->nr_entries; i++) { <nl>  		unsigned long ip = trace->entries[i]; <nl>  
@@ -1182,6 +1182,9 @@ static int threshold_create_bank(unsigned int cpu, unsigned int bank) <nl>  	const char *name = get_name(bank, NULL); <nl>  	int err = 0; <nl>   <nl> +	if (!dev) <nl> +		return -ENODEV; <nl> + <nl>  	if (is_shared_bank(bank)) { <nl>  		nb = node_to_amd_nb(amd_get_nb_id(cpu)); <nl>  
@@ -665,8 +665,9 @@ trace_print_graph_duration(unsigned long long duration, struct trace_seq *s) <nl>   <nl>  	/* Print nsecs (we don't want to exceed 7 numbers) */ <nl>  	if (len < 7) { <nl> -		snprintf(nsecs_str, min(sizeof(nsecs_str), 8UL - len), "%03lu", <nl> -			 nsecs_rem); <nl> +		size_t slen = min_t(size_t, sizeof(nsecs_str), 8UL - len); <nl> + <nl> +		snprintf(nsecs_str, slen, "%03lu", nsecs_rem); <nl>  		ret = trace_seq_printf(s, ".%s", nsecs_str); <nl>  		if (!ret) <nl>  			return TRACE_TYPE_PARTIAL_LINE;
@@ -1317,7 +1317,7 @@ sbni_ioctl( struct net_device  *dev,  struct ifreq  *ifr,  int  cmd ) <nl>  		break; <nl>   <nl>  	case  SIOCDEVRESINSTATS : <nl> -		if( current->euid != 0 )	/* root only */ <nl> +		if (!capable(CAP_NET_ADMIN)) <nl>  			return  -EPERM; <nl>  		memset( &nl->in_stats, 0, sizeof(struct sbni_in_stats) ); <nl>  		break; <nl> @@ -1334,7 +1334,7 @@ sbni_ioctl( struct net_device  *dev,  struct ifreq  *ifr,  int  cmd ) <nl>  		break; <nl>   <nl>  	case  SIOCDEVSHWSTATE : <nl> -		if( current->euid != 0 )	/* root only */ <nl> +		if (!capable(CAP_NET_ADMIN)) <nl>  			return  -EPERM; <nl>   <nl>  		spin_lock( &nl->lock ); <nl> @@ -1355,7 +1355,7 @@ sbni_ioctl( struct net_device  *dev,  struct ifreq  *ifr,  int  cmd ) <nl>  #ifdef CONFIG_SBNI_MULTILINE <nl>   <nl>  	case  SIOCDEVENSLAVE : <nl> -		if( current->euid != 0 )	/* root only */ <nl> +		if (!capable(CAP_NET_ADMIN)) <nl>  			return  -EPERM; <nl>   <nl>  		if (copy_from_user( slave_name, ifr->ifr_data, sizeof slave_name )) <nl> @@ -1370,7 +1370,7 @@ sbni_ioctl( struct net_device  *dev,  struct ifreq  *ifr,  int  cmd ) <nl>  		return  enslave( dev, slave_dev ); <nl>   <nl>  	case  SIOCDEVEMANSIPATE : <nl> -		if( current->euid != 0 )	/* root only */ <nl> +		if (!capable(CAP_NET_ADMIN)) <nl>  			return  -EPERM; <nl>   <nl>  		return  emancipate( dev );
@@ -6499,7 +6499,7 @@ static void igb_reuse_rx_page(struct igb_ring *rx_ring, <nl>  	rx_ring->next_to_alloc = (nta < rx_ring->count) ? nta : 0; <nl>   <nl>  	/* transfer page from old buffer to new buffer */ <nl> -	memcpy(new_buff, old_buff, sizeof(struct igb_rx_buffer)); <nl> +	*new_buff = *old_buff; <nl>   <nl>  	/* sync the buffer for use by the device */ <nl>  	dma_sync_single_range_for_device(rx_ring->dev, old_buff->dma,
@@ -2901,10 +2901,10 @@ static void _rocker_neigh_add(struct rocker *rocker, <nl>  			      enum switchdev_trans trans, <nl>  			      struct rocker_neigh_tbl_entry *entry) <nl>  { <nl> -	entry->index = rocker->neigh_tbl_next_index; <nl> +	if (trans != SWITCHDEV_TRANS_COMMIT) <nl> +		entry->index = rocker->neigh_tbl_next_index++; <nl>  	if (trans == SWITCHDEV_TRANS_PREPARE) <nl>  		return; <nl> -	rocker->neigh_tbl_next_index++; <nl>  	entry->ref_count++; <nl>  	hash_add(rocker->neigh_tbl, &entry->entry, <nl>  		 be32_to_cpu(entry->ip_addr));
@@ -890,7 +890,7 @@ static const struct of_device_id bcm_kona_i2c_of_match[] = { <nl>  	{.compatible = "brcm,kona-i2c",}, <nl>  	{}, <nl>  }; <nl> -MODULE_DEVICE_TABLE(of, kona_i2c_of_match); <nl> +MODULE_DEVICE_TABLE(of, bcm_kona_i2c_of_match); <nl>   <nl>  static struct platform_driver bcm_kona_i2c_driver = { <nl>  	.driver = {
@@ -282,8 +282,15 @@ void kvmppc_init_lpid(unsigned long nr_lpids); <nl>   <nl>  static inline void kvmppc_mmu_flush_icache(pfn_t pfn) <nl>  { <nl> -	/* Clear i-cache for new pages */ <nl>  	struct page *page; <nl> +	/* <nl> +	 * We can only access pages that the kernel maps <nl> +	 * as memory. Bail out for unmapped ones. <nl> +	 */ <nl> +	if (!pfn_valid(pfn)) <nl> +		return; <nl> + <nl> +	/* Clear i-cache for new pages */ <nl>  	page = pfn_to_page(pfn); <nl>  	if (!test_bit(PG_arch_1, &page->flags)) { <nl>  		flush_dcache_icache_page(page);
@@ -1923,6 +1923,9 @@ parse_ipsecrequests(struct xfrm_policy *xp, struct sadb_x_policy *pol) <nl>  	int len = pol->sadb_x_policy_len*8 - sizeof(struct sadb_x_policy); <nl>  	struct sadb_x_ipsecrequest *rq = (void*)(pol+1); <nl>   <nl> +	if (pol->sadb_x_policy_len * 8 < sizeof(struct sadb_x_policy)) <nl> +		return -EINVAL; <nl> + <nl>  	while (len >= sizeof(struct sadb_x_ipsecrequest)) { <nl>  		if ((err = parse_ipsecrequest(xp, rq)) < 0) <nl>  			return err;
@@ -626,6 +626,10 @@ static void xfrm_hash_rebuild(struct work_struct *work) <nl>   <nl>  	/* re-insert all policies by order of creation */ <nl>  	list_for_each_entry_reverse(policy, &net->xfrm.policy_all, walk.all) { <nl> +		if (xfrm_policy_id2dir(policy->index) >= XFRM_POLICY_MAX) { <nl> +			/* skip socket policies */ <nl> +			continue; <nl> +		} <nl>  		newpos = NULL; <nl>  		chain = policy_hash_bysel(net, &policy->selector, <nl>  					  policy->family,
@@ -563,6 +563,9 @@ int truncate_blocks(struct inode *inode, u64 from, bool lock) <nl>   <nl>  	free_from = (pgoff_t)F2FS_BYTES_TO_BLK(from + blocksize - 1); <nl>   <nl> +	if (free_from >= sbi->max_file_blocks) <nl> +		goto free_partial; <nl> + <nl>  	if (lock) <nl>  		f2fs_lock_op(sbi); <nl>   <nl> @@ -604,7 +607,7 @@ free_next: <nl>  out: <nl>  	if (lock) <nl>  		f2fs_unlock_op(sbi); <nl> - <nl> +free_partial: <nl>  	/* lastly zero out the first data page */ <nl>  	if (!err) <nl>  		err = truncate_partial_data_page(inode, from, truncate_page);
@@ -424,6 +424,7 @@ static int esw_create_offloads_fdb_table(struct mlx5_eswitch *esw, int nvports) <nl>  	root_ns = mlx5_get_flow_namespace(dev, MLX5_FLOW_NAMESPACE_FDB); <nl>  	if (!root_ns) { <nl>  		esw_warn(dev, "Failed to get FDB flow namespace\n"); <nl> +		err = -EOPNOTSUPP; <nl>  		goto ns_err; <nl>  	} <nl>   <nl> @@ -655,7 +656,7 @@ static int esw_offloads_start(struct mlx5_eswitch *esw) <nl>  		esw_warn(esw->dev, "Failed setting eswitch to offloads, err %d\n", err); <nl>  		err1 = mlx5_eswitch_enable_sriov(esw, num_vfs, SRIOV_LEGACY); <nl>  		if (err1) <nl> -			esw_warn(esw->dev, "Failed setting eswitch back to legacy, err %d\n", err); <nl> +			esw_warn(esw->dev, "Failed setting eswitch back to legacy, err %d\n", err1); <nl>  	} <nl>  	if (esw->offloads.inline_mode == MLX5_INLINE_MODE_NONE) { <nl>  		if (mlx5_eswitch_inline_mode_get(esw,
@@ -272,6 +272,11 @@ static int __init list_sort_test(void) <nl>  		} <nl>  		count++; <nl>  	} <nl> +	if (head.prev != cur) { <nl> +		printk(KERN_ERR "list_sort_test: error: list is corrupted\n"); <nl> +		goto exit; <nl> +	} <nl> + <nl>   <nl>  	if (count != TEST_LIST_LEN) { <nl>  		printk(KERN_ERR "list_sort_test: error: bad list length %d",
@@ -2596,8 +2596,7 @@ int dev_hard_start_xmit(struct sk_buff *skb, struct net_device *dev, <nl>  			dev_queue_xmit_nit(skb, dev); <nl>   <nl>  		skb_len = skb->len; <nl> -			rc = ops->ndo_start_xmit(skb, dev); <nl> - <nl> +		rc = ops->ndo_start_xmit(skb, dev); <nl>  		trace_net_dev_xmit(skb, rc, dev, skb_len); <nl>  		if (rc == NETDEV_TX_OK) <nl>  			txq_trans_update(txq);
@@ -864,7 +864,7 @@ static void bnx2x_set_one_mac_e1x(struct bnx2x *bp, <nl>  	/* Reset the ramrod data buffer */ <nl>  	memset(config, 0, sizeof(*config)); <nl>   <nl> -	bnx2x_vlan_mac_set_rdata_e1x(bp, o, BNX2X_FILTER_MAC_PENDING, <nl> +	bnx2x_vlan_mac_set_rdata_e1x(bp, o, raw->state, <nl>  				     cam_offset, add, <nl>  				     elem->cmd_data.vlan_mac.u.mac.mac, 0, <nl>  				     ETH_VLAN_FILTER_ANY_VLAN, config);
@@ -2011,9 +2011,11 @@ int soc_new_pcm(struct snd_soc_pcm_runtime *rtd, int num) <nl>  		if (cpu_dai->driver->capture.channels_min) <nl>  			capture = 1; <nl>  	} else { <nl> -		if (codec_dai->driver->playback.channels_min) <nl> +		if (codec_dai->driver->playback.channels_min && <nl> +		    cpu_dai->driver->playback.channels_min) <nl>  			playback = 1; <nl> -		if (codec_dai->driver->capture.channels_min) <nl> +		if (codec_dai->driver->capture.channels_min && <nl> +		    cpu_dai->driver->capture.channels_min) <nl>  			capture = 1; <nl>  	} <nl>  
@@ -199,6 +199,9 @@ int hfsplus_get_block(struct inode *inode, sector_t iblock, <nl>  		goto done; <nl>  	} <nl>   <nl> +	if (inode->i_ino == HFSPLUS_EXT_CNID) <nl> +		return -EIO; <nl> + <nl>  	mutex_lock(&HFSPLUS_I(inode).extents_lock); <nl>  	res = hfsplus_ext_read_extent(inode, ablock); <nl>  	if (!res) {
@@ -62,6 +62,9 @@ struct ichx_desc { <nl>  	/* Max GPIO pins the chipset can have */ <nl>  	uint ngpio; <nl>   <nl> +	/* GPO_BLINK is available on this chipset */ <nl> +	bool have_blink; <nl> + <nl>  	/* Whether the chipset has GPIO in GPE0_STS in the PM IO region */ <nl>  	bool uses_gpe0; <nl>   <nl> @@ -151,7 +154,7 @@ static int ichx_gpio_direction_output(struct gpio_chip *gpio, unsigned nr, <nl>  					int val) <nl>  { <nl>  	/* Disable blink hardware which is available for GPIOs from 0 to 31. */ <nl> -	if (nr < 32) <nl> +	if (nr < 32 && ichx_priv.desc->have_blink) <nl>  		ichx_write_bit(GPO_BLINK, nr, 0, 0); <nl>   <nl>  	/* Set GPIO output value. */ <nl> @@ -266,6 +269,7 @@ static struct ichx_desc ich6_desc = { <nl>  	.uses_gpe0 = true, <nl>   <nl>  	.ngpio = 50, <nl> +	.have_blink = true, <nl>  }; <nl>   <nl>  /* Intel 3100 */ <nl> @@ -290,19 +294,23 @@ static struct ichx_desc i3100_desc = { <nl>  /* ICH7 and ICH8-based */ <nl>  static struct ichx_desc ich7_desc = { <nl>  	.ngpio = 50, <nl> +	.have_blink = true, <nl>  }; <nl>   <nl>  /* ICH9-based */ <nl>  static struct ichx_desc ich9_desc = { <nl>  	.ngpio = 61, <nl> +	.have_blink = true, <nl>  }; <nl>   <nl>  /* ICH10-based - Consumer/corporate versions have different amount of GPIO */ <nl>  static struct ichx_desc ich10_cons_desc = { <nl>  	.ngpio = 61, <nl> +	.have_blink = true, <nl>  }; <nl>  static struct ichx_desc ich10_corp_desc = { <nl>  	.ngpio = 72, <nl> +	.have_blink = true, <nl>  }; <nl>   <nl>  /* Intel 5 series, 6 series, 3400 series, and C200 series */
@@ -412,6 +412,13 @@ static void sd_send_cmd_get_rsp(struct realtek_pci_sdmmc *host, <nl>  	} <nl>   <nl>  	if (rsp_type == SD_RSP_TYPE_R2) { <nl> +		/* <nl> +		 * The controller offloads the last byte {CRC-7, end bit 1'b1} <nl> +		 * of response type R2. Assign dummy CRC, 0, and end bit to the <nl> +		 * byte(ptr[16], goes into the LSB of resp[3] later). <nl> +		 */ <nl> +		ptr[16] = 1; <nl> + <nl>  		for (i = 0; i < 4; i++) { <nl>  			cmd->resp[i] = get_unaligned_be32(ptr + 1 + i * 4); <nl>  			dev_dbg(sdmmc_dev(host), "cmd->resp[%d] = 0x%08x\n",
@@ -904,7 +904,7 @@ void psched_ratecfg_precompute(struct psched_ratecfg *r, u32 rate) <nl>  	u64 mult; <nl>  	int shift; <nl>   <nl> -	r->rate_bps = rate << 3; <nl> +	r->rate_bps = (u64)rate << 3; <nl>  	r->shift = 0; <nl>  	r->mult = 1; <nl>  	/*
@@ -2032,6 +2032,8 @@ static int check_leaf(struct ubifs_info *c, struct ubifs_zbranch *zbr, <nl>  		long long blk_offs; <nl>  		struct ubifs_data_node *dn = node; <nl>   <nl> +		ubifs_assert(zbr->len >= UBIFS_DATA_NODE_SZ); <nl> + <nl>  		/* <nl>  		 * Search the inode node this data node belongs to and insert <nl>  		 * it to the RB-tree of inodes. <nl> @@ -2060,6 +2062,8 @@ static int check_leaf(struct ubifs_info *c, struct ubifs_zbranch *zbr, <nl>  		struct ubifs_dent_node *dent = node; <nl>  		struct fsck_inode *fscki1; <nl>   <nl> +		ubifs_assert(zbr->len >= UBIFS_DENT_NODE_SZ); <nl> + <nl>  		err = ubifs_validate_entry(c, dent); <nl>  		if (err) <nl>  			goto out_dump;
@@ -3655,13 +3655,19 @@ static void hotkey_notify(struct ibm_struct *ibm, u32 event) <nl>  			break; <nl>  		case 3: <nl>  			/* 0x3000-0x3FFF: bay-related wakeups */ <nl> -			if (hkey == TP_HKEY_EV_BAYEJ_ACK) { <nl> +			switch (hkey) { <nl> +			case TP_HKEY_EV_BAYEJ_ACK: <nl>  				hotkey_autosleep_ack = 1; <nl>  				printk(TPACPI_INFO <nl>  				       "bay ejected\n"); <nl>  				hotkey_wakeup_hotunplug_complete_notify_change(); <nl>  				known_ev = true; <nl> -			} else { <nl> +				break; <nl> +			case TP_HKEY_EV_OPTDRV_EJ: <nl> +				/* FIXME: kick libata if SATA link offline */ <nl> +				known_ev = true; <nl> +				break; <nl> +			default: <nl>  				known_ev = false; <nl>  			} <nl>  			break;
@@ -2693,7 +2693,6 @@ static void __init pnv_pci_init_ioda_phb(struct device_node *np, <nl>  		hose->last_busno = 0xff; <nl>  	} <nl>  	hose->private_data = phb; <nl> -	hose->controller_ops = pnv_pci_controller_ops; <nl>  	phb->hub_id = hub_id; <nl>  	phb->opal_id = phb_id; <nl>  	phb->type = ioda_type; <nl> @@ -2812,6 +2811,7 @@ static void __init pnv_pci_init_ioda_phb(struct device_node *np, <nl>  	pnv_pci_controller_ops.enable_device_hook = pnv_pci_enable_device_hook; <nl>  	pnv_pci_controller_ops.window_alignment = pnv_pci_window_alignment; <nl>  	pnv_pci_controller_ops.reset_secondary_bus = pnv_pci_reset_secondary_bus; <nl> +	hose->controller_ops = pnv_pci_controller_ops; <nl>   <nl>  #ifdef CONFIG_PCI_IOV <nl>  	ppc_md.pcibios_fixup_sriov = pnv_pci_ioda_fixup_iov_resources;
@@ -3579,7 +3579,7 @@ int kvm_arch_vcpu_ioctl_get_sregs(struct kvm_vcpu *vcpu, <nl>   <nl>  	memset(sregs->interrupt_bitmap, 0, sizeof sregs->interrupt_bitmap); <nl>   <nl> -	if (vcpu->arch.interrupt.pending) <nl> +	if (vcpu->arch.interrupt.pending && !vcpu->arch.interrupt.soft) <nl>  		set_bit(vcpu->arch.interrupt.nr, <nl>  			(unsigned long *)sregs->interrupt_bitmap); <nl>  
@@ -797,7 +797,8 @@ static void bnx2x_tpa_stop(struct bnx2x *bp, struct bnx2x_fastpath *fp, <nl>   <nl>  		return; <nl>  	} <nl> -	bnx2x_frag_free(fp, new_data); <nl> +	if (new_data) <nl> +		bnx2x_frag_free(fp, new_data); <nl>  drop: <nl>  	/* drop the packet and keep the buffer in the bin */ <nl>  	DP(NETIF_MSG_RX_STATUS,
@@ -179,14 +179,16 @@ static mode_t power_supply_attr_is_visible(struct kobject *kobj, <nl>  { <nl>  	struct device *dev = container_of(kobj, struct device, kobj); <nl>  	struct power_supply *psy = dev_get_drvdata(dev); <nl> +	mode_t mode = S_IRUSR | S_IRGRP | S_IROTH; <nl>  	int i; <nl>   <nl> +	if (attrno == POWER_SUPPLY_PROP_TYPE) <nl> +		return mode; <nl> + <nl>  	for (i = 0; i < psy->num_properties; i++) { <nl>  		int property = psy->properties[i]; <nl>   <nl>  		if (property == attrno) { <nl> -			mode_t mode = S_IRUSR | S_IRGRP | S_IROTH; <nl> - <nl>  			if (psy->property_is_writeable && <nl>  			    psy->property_is_writeable(psy, property) > 0) <nl>  				mode |= S_IWUSR;
@@ -1633,6 +1633,11 @@ static long comedi_unlocked_ioctl(struct file *file, unsigned int cmd, <nl>  	/* Device config is special, because it must work on <nl>  	 * an unconfigured device. */ <nl>  	if (cmd == COMEDI_DEVCONFIG) { <nl> +		if (minor >= COMEDI_NUM_BOARD_MINORS) { <nl> +			/* Device config not appropriate on non-board minors. */ <nl> +			rc = -ENOTTY; <nl> +			goto done; <nl> +		} <nl>  		rc = do_devconfig_ioctl(dev, <nl>  					(struct comedi_devconfig __user *)arg); <nl>  		if (rc == 0)
@@ -540,7 +540,8 @@ static int ina2xx_buffer_enable(struct iio_dev *indio_dev) <nl>  	chip->prev_ns = iio_get_time_ns(); <nl>   <nl>  	chip->task = kthread_run(ina2xx_capture_thread, (void *)indio_dev, <nl> -				 "ina2xx-%uus", sampling_us); <nl> +				 "%s:%d-%uus", indio_dev->name, indio_dev->id, <nl> +				 sampling_us); <nl>   <nl>  	return PTR_ERR_OR_ZERO(chip->task); <nl>  }
@@ -93,6 +93,9 @@ static unsigned long output_ptr = 0; <nl>  static void *malloc(int size); <nl>  static void free(void *where); <nl>    <nl> +void* memset(void* s, int c, unsigned n); <nl> +void* memcpy(void* dest, const void* src, unsigned n); <nl> + <nl>  static void putstr(const char *); <nl>     <nl>  extern int end;
@@ -97,6 +97,7 @@ int sc_ioctl(int card, scs_ioctl *data) <nl>   <nl>  	case SCIOCSTART: <nl>  	{ <nl> +		kfree(rcvmsg); <nl>  		pr_debug("%s: SCIOSTART: ioctl received\n", <nl>  				sc_adapter[card]->devicename); <nl>  		if(sc_adapter[card]->EngineUp) {
@@ -1079,10 +1079,8 @@ int blkcg_init_queue(struct request_queue *q) <nl>  	if (preloaded) <nl>  		radix_tree_preload_end(); <nl>   <nl> -	if (IS_ERR(blkg)) { <nl> -		blkg_free(new_blkg); <nl> +	if (IS_ERR(blkg)) <nl>  		return PTR_ERR(blkg); <nl> -	} <nl>   <nl>  	q->root_blkg = blkg; <nl>  	q->root_rl.blkg = blkg;
@@ -1176,11 +1176,12 @@ intel_dp_source_rates(struct drm_device *dev, const int **source_rates) <nl>   <nl>  	*source_rates = default_rates; <nl>   <nl> +	/* WaDisableHBR2:skl */ <nl>  	if (IS_SKYLAKE(dev) && INTEL_REVID(dev) <= SKL_REVID_B0) <nl> -		/* WaDisableHBR2:skl */ <nl>  		return (DP_LINK_BW_2_7 >> 3) + 1; <nl> -	else if (INTEL_INFO(dev)->gen >= 8 || <nl> -	    (IS_HASWELL(dev) && !IS_HSW_ULX(dev))) <nl> + <nl> +	if ((IS_HASWELL(dev) && !IS_HSW_ULX(dev)) || IS_BROADWELL(dev) || <nl> +	    (INTEL_INFO(dev)->gen >= 9)) <nl>  		return (DP_LINK_BW_5_4 >> 3) + 1; <nl>  	else <nl>  		return (DP_LINK_BW_2_7 >> 3) + 1;
@@ -6184,8 +6184,9 @@ match1: <nl>  		; <nl>  	} <nl>   <nl> +	n = ndoms_cur; <nl>  	if (doms_new == NULL) { <nl> -		ndoms_cur = 0; <nl> +		n = 0; <nl>  		doms_new = &fallback_doms; <nl>  		cpumask_andnot(doms_new[0], cpu_active_mask, cpu_isolated_map); <nl>  		WARN_ON_ONCE(dattr_new); <nl> @@ -6193,7 +6194,7 @@ match1: <nl>   <nl>  	/* Build new domains */ <nl>  	for (i = 0; i < ndoms_new; i++) { <nl> -		for (j = 0; j < ndoms_cur && !new_topology; j++) { <nl> +		for (j = 0; j < n && !new_topology; j++) { <nl>  			if (cpumask_equal(doms_new[i], doms_cur[j]) <nl>  			    && dattrs_equal(dattr_new, i, dattr_cur, j)) <nl>  				goto match2;
@@ -693,7 +693,8 @@ static void __init sanity_check_meminfo(void) <nl>  		 * Check whether this memory bank would entirely overlap <nl>  		 * the vmalloc area. <nl>  		 */ <nl> -		if (__va(bank->start) >= VMALLOC_MIN) { <nl> +		if (__va(bank->start) >= VMALLOC_MIN || <nl> +		    __va(bank->start) < PAGE_OFFSET) { <nl>  			printk(KERN_NOTICE "Ignoring RAM at %.8lx-%.8lx " <nl>  			       "(vmalloc region overlap).\n", <nl>  			       bank->start, bank->start + bank->size - 1);
@@ -2126,7 +2126,7 @@ static int __devinit ipmi_pnp_probe(struct pnp_dev *dev, <nl>  { <nl>  	struct acpi_device *acpi_dev; <nl>  	struct smi_info *info; <nl> -	struct resource *res; <nl> +	struct resource *res, *res_second; <nl>  	acpi_handle handle; <nl>  	acpi_status status; <nl>  	unsigned long long tmp; <nl> @@ -2182,13 +2182,13 @@ static int __devinit ipmi_pnp_probe(struct pnp_dev *dev, <nl>  	info->io.addr_data = res->start; <nl>   <nl>  	info->io.regspacing = DEFAULT_REGSPACING; <nl> -	res = pnp_get_resource(dev, <nl> +	res_second = pnp_get_resource(dev, <nl>  			       (info->io.addr_type == IPMI_IO_ADDR_SPACE) ? <nl>  					IORESOURCE_IO : IORESOURCE_MEM, <nl>  			       1); <nl> -	if (res) { <nl> -		if (res->start > info->io.addr_data) <nl> -			info->io.regspacing = res->start - info->io.addr_data; <nl> +	if (res_second) { <nl> +		if (res_second->start > info->io.addr_data) <nl> +			info->io.regspacing = res_second->start - info->io.addr_data; <nl>  	} <nl>  	info->io.regsize = DEFAULT_REGSPACING; <nl>  	info->io.regshift = 0;
@@ -68,7 +68,12 @@ EXPORT_SYMBOL(writeback_in_progress); <nl>   <nl>  struct backing_dev_info *inode_to_bdi(struct inode *inode) <nl>  { <nl> -	struct super_block *sb = inode->i_sb; <nl> +	struct super_block *sb; <nl> + <nl> +	if (!inode) <nl> +		return &noop_backing_dev_info; <nl> + <nl> +	sb = inode->i_sb; <nl>  #ifdef CONFIG_BLOCK <nl>  	if (sb_is_blkdev_sb(sb)) <nl>  		return blk_get_backing_dev_info(I_BDEV(inode));
@@ -295,7 +295,7 @@ int iwl_mvm_mac_setup_register(struct iwl_mvm *mvm) <nl>  	    !iwlwifi_mod_params.sw_crypto) <nl>  		hw->flags |= IEEE80211_HW_MFP_CAPABLE; <nl>   <nl> -	if (mvm->fw->ucode_capa.flags & IWL_UCODE_TLV_FLAGS_UAPSD_SUPPORT) { <nl> +	if (0 && mvm->fw->ucode_capa.flags & IWL_UCODE_TLV_FLAGS_UAPSD_SUPPORT) { <nl>  		hw->flags |= IEEE80211_HW_SUPPORTS_UAPSD; <nl>  		hw->uapsd_queues = IWL_UAPSD_AC_INFO; <nl>  		hw->uapsd_max_sp_len = IWL_UAPSD_MAX_SP;
@@ -118,6 +118,10 @@ static const struct mfd_cell cros_devs[] = { <nl>  		.id = 2, <nl>  		.of_compatible = "google,cros-ec-i2c-tunnel", <nl>  	}, <nl> +	{ <nl> +		.name = "cros-ec-ctl", <nl> +		.id = 3, <nl> +	}, <nl>  }; <nl>   <nl>  int cros_ec_register(struct cros_ec_device *ec_dev)
@@ -1245,7 +1245,7 @@ static struct sctp_transport *sctp_trans_elect_best(struct sctp_transport *curr, <nl>  { <nl>  	u8 score_curr, score_best; <nl>   <nl> -	if (best == NULL) <nl> +	if (best == NULL || curr == best) <nl>  		return curr; <nl>   <nl>  	score_curr = sctp_trans_score(curr);
@@ -162,6 +162,9 @@ void ieee80211_offchannel_return(struct ieee80211_local *local, <nl>   <nl>  	mutex_lock(&local->iflist_mtx); <nl>  	list_for_each_entry(sdata, &local->interfaces, list) { <nl> +		if (sdata->vif.type != NL80211_IFTYPE_MONITOR) <nl> +			clear_bit(SDATA_STATE_OFFCHANNEL, &sdata->state); <nl> + <nl>  		if (!ieee80211_sdata_running(sdata)) <nl>  			continue; <nl>   <nl> @@ -173,7 +176,6 @@ void ieee80211_offchannel_return(struct ieee80211_local *local, <nl>  		} <nl>   <nl>  		if (sdata->vif.type != NL80211_IFTYPE_MONITOR) { <nl> -			clear_bit(SDATA_STATE_OFFCHANNEL, &sdata->state); <nl>  			/* <nl>  			 * This may wake up queues even though the driver <nl>  			 * currently has them stopped. This is not very
@@ -175,6 +175,7 @@ static void dm_stat_free(struct rcu_head *head) <nl>  	int cpu; <nl>  	struct dm_stat *s = container_of(head, struct dm_stat, rcu_head); <nl>   <nl> +	kfree(s->histogram_boundaries); <nl>  	kfree(s->program_id); <nl>  	kfree(s->aux_data); <nl>  	for_each_possible_cpu(cpu) {
@@ -1129,11 +1129,7 @@ drm_atomic_helper_wait_for_vblanks(struct drm_device *dev, <nl>  	for_each_crtc_in_state(old_state, crtc, old_crtc_state, i) { <nl>  		struct drm_crtc_state *new_crtc_state = crtc->state; <nl>   <nl> -		if (!new_crtc_state->active) <nl> -			continue; <nl> - <nl> -		if (!drm_atomic_helper_framebuffer_changed(dev, <nl> -				old_state, crtc)) <nl> +		if (!new_crtc_state->active || !new_crtc_state->planes_changed) <nl>  			continue; <nl>   <nl>  		ret = drm_crtc_vblank_get(crtc);
@@ -995,6 +995,7 @@ long vhost_dev_ioctl(struct vhost_dev *d, unsigned int ioctl, void __user *argp) <nl>  		} <nl>  		if (eventfp != d->log_file) { <nl>  			filep = d->log_file; <nl> +			d->log_file = eventfp; <nl>  			ctx = d->log_ctx; <nl>  			d->log_ctx = eventfp ? <nl>  				eventfd_ctx_fileget(eventfp) : NULL;
@@ -178,6 +178,7 @@ int mlx4_buf_alloc(struct mlx4_dev *dev, int size, int max_direct, <nl>  	} else { <nl>  		int i; <nl>   <nl> +		buf->direct.buf  = NULL; <nl>  		buf->nbufs       = (size + PAGE_SIZE - 1) / PAGE_SIZE; <nl>  		buf->npages      = buf->nbufs; <nl>  		buf->page_shift  = PAGE_SHIFT; <nl> @@ -229,7 +230,7 @@ void mlx4_buf_free(struct mlx4_dev *dev, int size, struct mlx4_buf *buf) <nl>  		dma_free_coherent(&dev->pdev->dev, size, buf->direct.buf, <nl>  				  buf->direct.map); <nl>  	else { <nl> -		if (BITS_PER_LONG == 64) <nl> +		if (BITS_PER_LONG == 64 && buf->direct.buf) <nl>  			vunmap(buf->direct.buf); <nl>   <nl>  		for (i = 0; i < buf->nbufs; ++i)
@@ -642,9 +642,13 @@ static void map_cpu_to_logical_apicid(void) <nl>  { <nl>  	int cpu = smp_processor_id(); <nl>  	int apicid = logical_smp_processor_id(); <nl> +	int node = apicid_to_node(apicid); <nl> + <nl> +	if (!node_online(node)) <nl> +		node = first_online_node; <nl>   <nl>  	cpu_2_logical_apicid[cpu] = apicid; <nl> -	map_cpu_to_node(cpu, apicid_to_node(apicid)); <nl> +	map_cpu_to_node(cpu, node); <nl>  } <nl>   <nl>  static void unmap_cpu_to_logical_apicid(int cpu)
@@ -1236,6 +1236,9 @@ static inline struct sk_buff *sk_stream_alloc_pskb(struct sock *sk, <nl>  { <nl>  	struct sk_buff *skb; <nl>   <nl> +	/* The TCP header must be at least 32-bit aligned.  */ <nl> +	size = ALIGN(size, 4); <nl> + <nl>  	skb = alloc_skb_fclone(size + sk->sk_prot->max_header, gfp); <nl>  	if (skb) { <nl>  		skb->truesize += mem;
@@ -147,21 +147,21 @@ static ssize_t boottotool_store(struct device *dev, <nl>  				struct device_attribute *attr, <nl>  				const char *buf, size_t count) <nl>  { <nl> -	int val, ret; <nl> +	int val, err; <nl>  	struct efi_spar_indication efi_spar_indication; <nl>   <nl>  	if (kstrtoint(buf, 10, &val)) <nl>  		return -EINVAL; <nl>   <nl>  	efi_spar_indication.boot_to_tool = val; <nl> -	ret = visorchannel_write <nl> +	err = visorchannel_write <nl>  		(chipset_dev->controlvm_channel, <nl>  		 offsetof(struct spar_controlvm_channel_protocol, <nl>  			  efi_spar_ind), &(efi_spar_indication), <nl>  		 sizeof(struct efi_spar_indication)); <nl>   <nl> -	if (ret) <nl> -		return ret; <nl> +	if (err) <nl> +		return err; <nl>  	return count; <nl>  } <nl>  static DEVICE_ATTR_RW(boottotool);
@@ -46,8 +46,14 @@ read_clk(struct drm_device *dev, int clk, bool ignore_en) <nl>  	u32 sctl, sdiv, sclk; <nl>   <nl>  	/* refclk for the 0xe8xx plls is a fixed frequency */ <nl> -	if (clk >= 0x40) <nl> +	if (clk >= 0x40) { <nl> +		if (dev_priv->chipset == 0xaf) { <nl> +			/* no joke.. seriously.. sigh.. */ <nl> +			return nv_rd32(dev, 0x00471c) * 1000; <nl> +		} <nl> + <nl>  		return dev_priv->crystal; <nl> +	} <nl>   <nl>  	sctl = nv_rd32(dev, 0x4120 + (clk * 4)); <nl>  	if (!ignore_en && !(sctl & 0x00000100))
@@ -38,7 +38,7 @@ static const struct cifs_sid sid_everyone = { <nl>  	1, 1, {0, 0, 0, 0, 0, 1}, {0} }; <nl>  /* security id for Authenticated Users system group */ <nl>  static const struct cifs_sid sid_authusers = { <nl> -	1, 1, {0, 0, 0, 0, 0, 5}, {11} }; <nl> +	1, 1, {0, 0, 0, 0, 0, 5}, {cpu_to_le32(11)} }; <nl>  /* group users */ <nl>  static const struct cifs_sid sid_user = {1, 2 , {0, 0, 0, 0, 0, 5}, {} }; <nl>   <nl> @@ -458,7 +458,8 @@ int compare_sids(const struct cifs_sid *ctsid, const struct cifs_sid *cwsid) <nl>  	if (num_subauth) { <nl>  		for (i = 0; i < num_subauth; ++i) { <nl>  			if (ctsid->sub_auth[i] != cwsid->sub_auth[i]) { <nl> -				if (ctsid->sub_auth[i] > cwsid->sub_auth[i]) <nl> +				if (le32_to_cpu(ctsid->sub_auth[i]) > <nl> +					le32_to_cpu(cwsid->sub_auth[i])) <nl>  					return 1; <nl>  				else <nl>  					return -1;
@@ -1269,7 +1269,7 @@ bool i40e_is_vsi_in_vlan(struct i40e_vsi *vsi) <nl>  	 * so we have to go through all the list in order to make sure <nl>  	 */ <nl>  	list_for_each_entry(f, &vsi->mac_filter_list, list) { <nl> -		if (f->vlan >= 0) <nl> +		if (f->vlan >= 0 || vsi->info.pvid) <nl>  			return true; <nl>  	} <nl>  
@@ -282,7 +282,7 @@ static int parse_scriptname(const struct option *opt __used, <nl>  		script++; <nl>  	} else { <nl>  		script = str; <nl> -		ext = strchr(script, '.'); <nl> +		ext = strrchr(script, '.'); <nl>  		if (!ext) { <nl>  			fprintf(stderr, "invalid script extension"); <nl>  			return -1;
@@ -140,7 +140,7 @@ int __init oprofile_arch_init(struct oprofile_operations *ops) <nl>  		if (ret < 0) <nl>  			return ret; <nl>   <nl> -		counter_config = kmalloc(sizeof(struct op_counter_config) * spec->num_counters, <nl> +		counter_config = kcalloc(spec->num_counters, sizeof(struct op_counter_config), <nl>  					 GFP_KERNEL); <nl>  		if (!counter_config) <nl>  			return -ENOMEM;
@@ -762,6 +762,12 @@ static int acpi_cpufreq_cpu_init(struct cpufreq_policy *policy) <nl>   <nl>  	switch (perf->control_register.space_id) { <nl>  	case ACPI_ADR_SPACE_SYSTEM_IO: <nl> +		if (boot_cpu_data.x86_vendor == X86_VENDOR_AMD && <nl> +		    boot_cpu_data.x86 == 0xf) { <nl> +			pr_debug("AMD K8 systems must use native drivers.\n"); <nl> +			result = -ENODEV; <nl> +			goto err_unreg; <nl> +		} <nl>  		pr_debug("SYSTEM IO addr space\n"); <nl>  		data->cpu_feature = SYSTEM_IO_CAPABLE; <nl>  		break;
@@ -385,7 +385,7 @@ static ssize_t spufs_mbox_read(struct file *file, char __user *buf, <nl>  	udata = (void __user *)buf; <nl>   <nl>  	spu_acquire(ctx); <nl> -	for (count = 0; count <= len; count += 4, udata++) { <nl> +	for (count = 0; (count + 4) <= len; count += 4, udata++) { <nl>  		int ret; <nl>  		ret = ctx->ops->mbox_read(ctx, &mbox_data); <nl>  		if (ret == 0)
@@ -601,6 +601,10 @@ static inline void mlx5e_build_rx_skb(struct mlx5_cqe64 *cqe, <nl>  	if (lro_num_seg > 1) { <nl>  		mlx5e_lro_update_hdr(skb, cqe, cqe_bcnt); <nl>  		skb_shinfo(skb)->gso_size = DIV_ROUND_UP(cqe_bcnt, lro_num_seg); <nl> +		/* Subtract one since we already counted this as one <nl> +		 * "regular" packet in mlx5e_complete_rx_cqe() <nl> +		 */ <nl> +		rq->stats.packets += lro_num_seg - 1; <nl>  		rq->stats.lro_packets++; <nl>  		rq->stats.lro_bytes += cqe_bcnt; <nl>  	}
@@ -742,6 +742,7 @@ int map_groups__clone(struct map_groups *mg, <nl>  		if (new == NULL) <nl>  			goto out_unlock; <nl>  		map_groups__insert(mg, new); <nl> +		map__put(new); <nl>  	} <nl>   <nl>  	err = 0;
@@ -249,8 +249,8 @@ int mxc_initialize_usb_hw(int port, unsigned int flags) <nl>  #ifdef CONFIG_ARCH_MX51 <nl>  	if (cpu_is_mx51()) { <nl>  		void __iomem *usb_base; <nl> -		u32 usbotg_base; <nl> -		u32 usbother_base; <nl> +		void __iomem *usbotg_base; <nl> +		void __iomem *usbother_base; <nl>  		int ret = 0; <nl>   <nl>  		usb_base = ioremap(MX51_OTG_BASE_ADDR, SZ_4K);
@@ -114,7 +114,8 @@ unsigned int <nl>  nft_do_chain(struct nft_pktinfo *pkt, const struct nf_hook_ops *ops) <nl>  { <nl>  	const struct nft_chain *chain = ops->priv, *basechain = chain; <nl> -	const struct net *net = read_pnet(&nft_base_chain(basechain)->pnet); <nl> +	const struct net *chain_net = read_pnet(&nft_base_chain(basechain)->pnet); <nl> +	const struct net *net = dev_net(pkt->in ? pkt->in : pkt->out); <nl>  	const struct nft_rule *rule; <nl>  	const struct nft_expr *expr, *last; <nl>  	struct nft_regs regs; <nl> @@ -124,6 +125,10 @@ nft_do_chain(struct nft_pktinfo *pkt, const struct nf_hook_ops *ops) <nl>  	int rulenum; <nl>  	unsigned int gencursor = nft_genmask_cur(net); <nl>   <nl> +	/* Ignore chains that are not for the current network namespace */ <nl> +	if (!net_eq(net, chain_net)) <nl> +		return NF_ACCEPT; <nl> + <nl>  do_chain: <nl>  	rulenum = 0; <nl>  	rule = list_entry(&chain->rules, struct nft_rule, list);
@@ -275,7 +275,7 @@ static int ibmvfc_get_err_result(struct ibmvfc_cmd *vfc_cmd) <nl>  	int fc_rsp_len = rsp->fcp_rsp_len; <nl>   <nl>  	if ((rsp->flags & FCP_RSP_LEN_VALID) && <nl> -	    ((!fc_rsp_len && fc_rsp_len != 4 && fc_rsp_len != 8) || <nl> +	    ((fc_rsp_len && fc_rsp_len != 4 && fc_rsp_len != 8) || <nl>  	     rsp->data.info.rsp_code)) <nl>  		return DID_ERROR << 16; <nl>  
@@ -187,9 +187,9 @@ ds1685_rtc_end_data_access(struct ds1685_priv *rtc) <nl>   * Only use this where you are certain another lock will not be held. <nl>   */ <nl>  static inline void <nl> -ds1685_rtc_begin_ctrl_access(struct ds1685_priv *rtc, unsigned long flags) <nl> +ds1685_rtc_begin_ctrl_access(struct ds1685_priv *rtc, unsigned long *flags) <nl>  { <nl> -	spin_lock_irqsave(&rtc->lock, flags); <nl> +	spin_lock_irqsave(&rtc->lock, *flags); <nl>  	ds1685_rtc_switch_to_bank1(rtc); <nl>  } <nl>   <nl> @@ -1300,7 +1300,7 @@ ds1685_rtc_sysfs_ctrl_regs_store(struct device *dev, <nl>  { <nl>  	struct ds1685_priv *rtc = dev_get_drvdata(dev); <nl>  	u8 reg = 0, bit = 0, tmp; <nl> -	unsigned long flags = 0; <nl> +	unsigned long flags; <nl>  	long int val = 0; <nl>  	const struct ds1685_rtc_ctrl_regs *reg_info = <nl>  		ds1685_rtc_sysfs_ctrl_regs_lookup(attr->attr.name); <nl> @@ -1321,7 +1321,7 @@ ds1685_rtc_sysfs_ctrl_regs_store(struct device *dev, <nl>  	bit = reg_info->bit; <nl>   <nl>  	/* Safe to spinlock during a write. */ <nl> -	ds1685_rtc_begin_ctrl_access(rtc, flags); <nl> +	ds1685_rtc_begin_ctrl_access(rtc, &flags); <nl>  	tmp = rtc->read(rtc, reg); <nl>  	rtc->write(rtc, reg, (val ? (tmp | bit) : (tmp & ~(bit)))); <nl>  	ds1685_rtc_end_ctrl_access(rtc, flags);
@@ -600,7 +600,11 @@ pte_t *__page_check_address(struct page *page, struct mm_struct *mm, <nl>  	spinlock_t *ptl; <nl>   <nl>  	if (unlikely(PageHuge(page))) { <nl> +		/* when pud is not present, pte will be NULL */ <nl>  		pte = huge_pte_offset(mm, address); <nl> +		if (!pte) <nl> +			return NULL; <nl> + <nl>  		ptl = huge_pte_lockptr(page_hstate(page), mm, pte); <nl>  		goto check; <nl>  	}
@@ -2831,7 +2831,7 @@ try_mount_again: <nl>   <nl>  remote_path_check: <nl>  	/* check if a whole path (including prepath) is not remote */ <nl> -	if (!rc && cifs_sb->prepathlen && tcon) { <nl> +	if (!rc && tcon) { <nl>  		/* build_path_to_root works only when we have a valid tcon */ <nl>  		full_path = cifs_build_path_to_root(cifs_sb, tcon); <nl>  		if (full_path == NULL) {
@@ -2629,7 +2629,7 @@ static int btrfs_finish_ordered_io(struct btrfs_ordered_extent *ordered_extent) <nl>  			EXTENT_DEFRAG, 1, cached_state); <nl>  	if (ret) { <nl>  		u64 last_snapshot = btrfs_root_last_snapshot(&root->root_item); <nl> -		if (last_snapshot >= BTRFS_I(inode)->generation) <nl> +		if (0 && last_snapshot >= BTRFS_I(inode)->generation) <nl>  			/* the inode is shared */ <nl>  			new = record_old_file_extents(inode, ordered_extent); <nl>  
@@ -907,7 +907,7 @@ static int uas_find_endpoints(struct usb_host_interface *alt, <nl>  	for (i = 0; i < n_endpoints; i++) { <nl>  		unsigned char *extra = endpoint[i].extra; <nl>  		int len = endpoint[i].extralen; <nl> -		while (len > 1) { <nl> +		while (len >= 3) { <nl>  			if (extra[1] == USB_DT_PIPE_USAGE) { <nl>  				unsigned pipe_id = extra[2]; <nl>  				if (pipe_id > 0 && pipe_id < 5)
@@ -2125,6 +2125,7 @@ static void intel_find_plane_obj(struct intel_crtc *intel_crtc, <nl>  		return; <nl>   <nl>  	kfree(intel_crtc->base.fb); <nl> +	intel_crtc->base.fb = NULL; <nl>   <nl>  	/* <nl>  	 * Failed to alloc the obj, check to see if we should share
@@ -740,6 +740,9 @@ static void __init setup_hwcaps(void) <nl>  void __init <nl>  setup_arch(char **cmdline_p) <nl>  { <nl> +	/* set up preferred console */ <nl> +	add_preferred_console("ttyS", 0, NULL); <nl> + <nl>          /* <nl>           * print what head.S has found out about the machine <nl>           */
@@ -131,6 +131,7 @@ static const struct ar9300_eeprom ar9300_default = { <nl>  		.thresh62 = 28, <nl>  		.papdRateMaskHt20 = LE32(0x0cf0e0e0), <nl>  		.papdRateMaskHt40 = LE32(0x6cf0e0e0), <nl> +		.switchcomspdt = 0, <nl>  		.xlna_bias_strength = 0, <nl>  		.futureModal = { <nl>  			0, 0, 0, 0, 0, 0, 0, <nl> @@ -333,6 +334,7 @@ static const struct ar9300_eeprom ar9300_default = { <nl>  		.thresh62 = 28, <nl>  		.papdRateMaskHt20 = LE32(0x0c80c080), <nl>  		.papdRateMaskHt40 = LE32(0x0080c080), <nl> +		.switchcomspdt = 0, <nl>  		.xlna_bias_strength = 0, <nl>  		.futureModal = { <nl>  			0, 0, 0, 0, 0, 0, 0, <nl> @@ -707,6 +709,7 @@ static const struct ar9300_eeprom ar9300_x113 = { <nl>  		.thresh62 = 28, <nl>  		.papdRateMaskHt20 = LE32(0x0c80c080), <nl>  		.papdRateMaskHt40 = LE32(0x0080c080), <nl> +		.switchcomspdt = 0, <nl>  		.xlna_bias_strength = 0, <nl>  		.futureModal = { <nl>  			0, 0, 0, 0, 0, 0, 0, <nl> @@ -909,6 +912,7 @@ static const struct ar9300_eeprom ar9300_x113 = { <nl>  		.thresh62 = 28, <nl>  		.papdRateMaskHt20 = LE32(0x0cf0e0e0), <nl>  		.papdRateMaskHt40 = LE32(0x6cf0e0e0), <nl> +		.switchcomspdt = 0, <nl>  		.xlna_bias_strength = 0, <nl>  		.futureModal = { <nl>  			0, 0, 0, 0, 0, 0, 0, <nl> @@ -1284,6 +1288,7 @@ static const struct ar9300_eeprom ar9300_h112 = { <nl>  		.thresh62 = 28, <nl>  		.papdRateMaskHt20 = LE32(0x0c80c080), <nl>  		.papdRateMaskHt40 = LE32(0x0080c080), <nl> +		.switchcomspdt = 0, <nl>  		.xlna_bias_strength = 0, <nl>  		.futureModal = { <nl>  			0, 0, 0, 0, 0, 0, 0, <nl> @@ -1486,6 +1491,7 @@ static const struct ar9300_eeprom ar9300_h112 = { <nl>  		.thresh62 = 28, <nl>  		.papdRateMaskHt20 = LE32(0x0cf0e0e0), <nl>  		.papdRateMaskHt40 = LE32(0x6cf0e0e0), <nl> +		.switchcomspdt = 0, <nl>  		.xlna_bias_strength = 0, <nl>  		.futureModal = { <nl>  			0, 0, 0, 0, 0, 0, 0, <nl> @@ -1861,6 +1867,7 @@ static const struct ar9300_eeprom ar9300_x112 = { <nl>  		.thresh62 = 28, <nl>  		.papdRateMaskHt20 = LE32(0x0c80c080), <nl>  		.papdRateMaskHt40 = LE32(0x0080c080), <nl> +		.switchcomspdt = 0, <nl>  		.xlna_bias_strength = 0, <nl>  		.futureModal = { <nl>  			0, 0, 0, 0, 0, 0, 0, <nl> @@ -2063,6 +2070,7 @@ static const struct ar9300_eeprom ar9300_x112 = { <nl>  		.thresh62 = 28, <nl>  		.papdRateMaskHt20 = LE32(0x0cf0e0e0), <nl>  		.papdRateMaskHt40 = LE32(0x6cf0e0e0), <nl> +		.switchcomspdt = 0, <nl>  		.xlna_bias_strength = 0, <nl>  		.futureModal = { <nl>  			0, 0, 0, 0, 0, 0, 0, <nl> @@ -2437,6 +2445,7 @@ static const struct ar9300_eeprom ar9300_h116 = { <nl>  		.thresh62 = 28, <nl>  		.papdRateMaskHt20 = LE32(0x0c80C080), <nl>  		.papdRateMaskHt40 = LE32(0x0080C080), <nl> +		.switchcomspdt = 0, <nl>  		.xlna_bias_strength = 0, <nl>  		.futureModal = { <nl>  			0, 0, 0, 0, 0, 0, 0, <nl> @@ -2639,6 +2648,7 @@ static const struct ar9300_eeprom ar9300_h116 = { <nl>  		.thresh62 = 28, <nl>  		.papdRateMaskHt20 = LE32(0x0cf0e0e0), <nl>  		.papdRateMaskHt40 = LE32(0x6cf0e0e0), <nl> +		.switchcomspdt = 0, <nl>  		.xlna_bias_strength = 0, <nl>  		.futureModal = { <nl>  			0, 0, 0, 0, 0, 0, 0,
@@ -29,6 +29,7 @@ <nl>  #include <linux/module.h> <nl>  #include <linux/if_vlan.h> <nl>  #include <linux/inet_lro.h> <nl> +#include <net/checksum.h> <nl>   <nl>  MODULE_LICENSE("GPL"); <nl>  MODULE_AUTHOR("Jan-Bernd Themann <themann@de.ibm.com>"); <nl> @@ -114,11 +115,9 @@ static void lro_update_tcp_ip_header(struct net_lro_desc *lro_desc) <nl>  		*(p+2) = lro_desc->tcp_rcv_tsecr; <nl>  	} <nl>   <nl> +	csum_replace2(&iph->check, iph->tot_len, htons(lro_desc->ip_tot_len)); <nl>  	iph->tot_len = htons(lro_desc->ip_tot_len); <nl>   <nl> -	iph->check = 0; <nl> -	iph->check = ip_fast_csum((u8 *)lro_desc->iph, iph->ihl); <nl> - <nl>  	tcph->check = 0; <nl>  	tcp_hdr_csum = csum_partial(tcph, TCP_HDR_LEN(tcph), 0); <nl>  	lro_desc->data_csum = csum_add(lro_desc->data_csum, tcp_hdr_csum);
@@ -748,6 +748,9 @@ asmlinkage long sys_linkat(int olddfd, const char __user *oldname, <nl>  			   int newdfd, const char __user *newname, int flags); <nl>  asmlinkage long sys_renameat(int olddfd, const char __user * oldname, <nl>  			     int newdfd, const char __user * newname); <nl> +asmlinkage long sys_renameat2(int olddfd, const char __user *oldname, <nl> +			      int newdfd, const char __user *newname, <nl> +			      unsigned int flags); <nl>  asmlinkage long sys_futimesat(int dfd, const char __user *filename, <nl>  			      struct timeval __user *utimes); <nl>  asmlinkage long sys_faccessat(int dfd, const char __user *filename, int mode);
@@ -1126,7 +1126,6 @@ static int ucc_hdlc_probe(struct platform_device *pdev) <nl>   <nl>  err_hdlc_init: <nl>  err_miss_tsa_property: <nl> -	kfree(uhdlc_priv); <nl>  	if (uhdlc_priv->tsa) <nl>  		kfree(utdm); <nl>  err_alloc_utdm:
@@ -3327,7 +3327,10 @@ static inline int set_geometry(unsigned int cmd, struct floppy_struct *g, <nl>  		if (!capable(CAP_SYS_ADMIN)) <nl>  			return -EPERM; <nl>  		mutex_lock(&open_lock); <nl> -		LOCK_FDC(drive, 1); <nl> +		if (lock_fdc(drive, 1)) { <nl> +			mutex_unlock(&open_lock); <nl> +			return -EINTR; <nl> +		} <nl>  		floppy_type[type] = *g; <nl>  		floppy_type[type].name = "user format"; <nl>  		for (cnt = type << 2; cnt < (type << 2) + 4; cnt++)
@@ -190,6 +190,9 @@ fill_write_buffer(struct sysfs_buffer * buffer, const char __user * buf, size_t <nl>  		count = PAGE_SIZE - 1; <nl>  	error = copy_from_user(buffer->page,buf,count); <nl>  	buffer->needs_read_fill = 1; <nl> +	/* if buf is assumed to contain a string, terminate it by \0, <nl> +	   so e.g. sscanf() can scan the string easily */ <nl> +	buffer->page[count] = 0; <nl>  	return error ? -EFAULT : count; <nl>  } <nl>  
@@ -880,7 +880,16 @@ static int ceph_rename(struct inode *old_dir, struct dentry *old_dentry, <nl>  		 * do_request, above).  If there is no trace, we need <nl>  		 * to do it here. <nl>  		 */ <nl> + <nl> +		/* d_move screws up d_subdirs order */ <nl> +		ceph_i_clear(new_dir, CEPH_I_COMPLETE); <nl> + <nl>  		d_move(old_dentry, new_dentry); <nl> + <nl> +		/* ensure target dentry is invalidated, despite <nl> +		   rehashing bug in vfs_rename_dir */ <nl> +		new_dentry->d_time = jiffies; <nl> +		ceph_dentry(new_dentry)->lease_shared_gen = 0; <nl>  	} <nl>  	ceph_mdsc_put_request(req); <nl>  	return err;
@@ -460,6 +460,7 @@ int opp_add(struct device *dev, unsigned long freq, unsigned long u_volt) <nl>  	srcu_notifier_call_chain(&dev_opp->head, OPP_EVENT_ADD, new_opp); <nl>  	return 0; <nl>  } <nl> +EXPORT_SYMBOL_GPL(opp_add); <nl>   <nl>  /** <nl>   * opp_set_availability() - helper to set the availability of an opp
@@ -275,4 +275,9 @@ enum mtd_file_modes { <nl>  	MTD_FILE_MODE_RAW, <nl>  }; <nl>   <nl> +static inline int mtd_type_is_nand_user(const struct mtd_info_user *mtd) <nl> +{ <nl> +	return mtd->type == MTD_NANDFLASH || mtd->type == MTD_MLCNANDFLASH; <nl> +} <nl> + <nl>  #endif /* __MTD_ABI_H__ */
@@ -930,7 +930,7 @@ int ieee80211_register_hw(struct ieee80211_hw *hw) <nl>   fail_workqueue: <nl>  	wiphy_unregister(local->hw.wiphy); <nl>   fail_wiphy_register: <nl> -	kfree(local->int_scan_req->channels); <nl> +	kfree(local->int_scan_req); <nl>  	return result; <nl>  } <nl>  EXPORT_SYMBOL(ieee80211_register_hw);
@@ -3407,7 +3407,7 @@ u16 hpi_entity_alloc_and_pack(const enum e_entity_type type, <nl>  	if (hE) <nl>  		return hE; <nl>   <nl> -	HPI_DEBUG_ASSERT(role > entity_role_null && type < LAST_ENTITY_ROLE); <nl> +	HPI_DEBUG_ASSERT(role > entity_role_null && type < LAST_ENTITY_TYPE); <nl>   <nl>  	bytes_to_copy = entity_type_to_size[type] * item_count; <nl>  	total_size = hpi_entity_header_size(*entity) + bytes_to_copy;
@@ -234,7 +234,7 @@ void cfg80211_conn_work(struct work_struct *work) <nl>  			wdev_unlock(wdev); <nl>  			continue; <nl>  		} <nl> -		if (wdev->sme_state != CFG80211_SME_CONNECTING) { <nl> +		if (wdev->sme_state != CFG80211_SME_CONNECTING || !wdev->conn) { <nl>  			wdev_unlock(wdev); <nl>  			continue; <nl>  		}
@@ -148,8 +148,15 @@ static void vblank_disable_and_save(struct drm_device *dev, int crtc) <nl>  	 * has been ticking all along until this time. This makes the <nl>  	 * count account for the entire time between drm_vblank_on() and <nl>  	 * drm_vblank_off(). <nl> +	 * <nl> +	 * But only do this if precise vblank timestamps are available. <nl> +	 * Otherwise we might read a totally bogus timestamp since drivers <nl> +	 * lacking precise timestamp support rely upon sampling the system clock <nl> +	 * at vblank interrupt time. Which obviously won't work out well if the <nl> +	 * vblank interrupt is disabled. <nl>  	 */ <nl> -	if (!vblank->enabled) { <nl> +	if (!vblank->enabled && <nl> +	    drm_get_last_vbltimestamp(dev, crtc, &tvblank, 0) > 0) { <nl>  		drm_update_vblank_count(dev, crtc); <nl>  		spin_unlock_irqrestore(&dev->vblank_time_lock, irqflags); <nl>  		return;
@@ -1011,7 +1011,8 @@ static irqreturn_t sci_er_interrupt(int irq, void *ptr) <nl>  	sci_clear_SCxSR(port, SCxSR_ERROR_CLEAR(port)); <nl>   <nl>  	/* Kick the transmission */ <nl> -	sci_tx_interrupt(irq, ptr); <nl> +	if (!s->chan_tx) <nl> +		sci_tx_interrupt(irq, ptr); <nl>   <nl>  	return IRQ_HANDLED; <nl>  }
@@ -541,11 +541,12 @@ void symbol__annotate_decay_histogram(struct symbol *sym, int evidx) <nl>  	struct annotation *notes = symbol__annotation(sym); <nl>  	struct sym_hist *h = annotation__histogram(notes, evidx); <nl>  	struct objdump_line *pos; <nl> +	int len = sym->end - sym->start; <nl>   <nl>  	h->sum = 0; <nl>   <nl>  	list_for_each_entry(pos, &notes->src->source, node) { <nl> -		if (pos->offset != -1) { <nl> +		if (pos->offset != -1 && pos->offset < len) { <nl>  			h->addr[pos->offset] = h->addr[pos->offset] * 7 / 8; <nl>  			h->sum += h->addr[pos->offset]; <nl>  		}
@@ -1656,6 +1656,9 @@ next_file: <nl>  		mnt_drop_write_file(dst_file); <nl>  next_loop: <nl>  		fdput(dst_fd); <nl> + <nl> +		if (fatal_signal_pending(current)) <nl> +			goto out; <nl>  	} <nl>   <nl>  out:
@@ -380,6 +380,7 @@ static int rbd_get_client(struct rbd_device *rbd_dev, const char *mon_addr, <nl>  	rbdc = __rbd_client_find(opt); <nl>  	if (rbdc) { <nl>  		ceph_destroy_options(opt); <nl> +		kfree(rbd_opts); <nl>   <nl>  		/* using an existing client */ <nl>  		kref_get(&rbdc->kref);
@@ -27,6 +27,9 @@ <nl>  #include <linux/module.h> <nl>  #include <linux/platform_device.h> <nl>  #include <linux/spinlock.h> <nl> + <nl> +#include <asm/mach/irq.h> <nl> + <nl>  #include <mach/msm_iomap.h> <nl>  #include "gpiomux.h" <nl>   <nl> @@ -309,8 +312,10 @@ static int msm_gpio_irq_set_type(struct irq_data *d, unsigned int flow_type) <nl>   */ <nl>  static void msm_summary_irq_handler(unsigned int irq, struct irq_desc *desc) <nl>  { <nl> -	struct irq_data *data = irq_desc_get_irq_data(desc); <nl>  	unsigned long i; <nl> +	struct irq_chip *chip = irq_desc_get_chip(desc); <nl> + <nl> +	chained_irq_enter(chip, desc); <nl>   <nl>  	for (i = find_first_bit(msm_gpio.enabled_irqs, NR_GPIO_IRQS); <nl>  	     i < NR_GPIO_IRQS; <nl> @@ -319,7 +324,8 @@ static void msm_summary_irq_handler(unsigned int irq, struct irq_desc *desc) <nl>  			generic_handle_irq(msm_gpio_to_irq(&msm_gpio.gpio_chip, <nl>  							   i)); <nl>  	} <nl> -	data->chip->irq_ack(data); <nl> + <nl> +	chained_irq_exit(chip, desc); <nl>  } <nl>   <nl>  static int msm_gpio_irq_set_wake(struct irq_data *d, unsigned int on)
@@ -187,7 +187,7 @@ static inline void print_ipv6_addr(struct audit_buffer *ab, <nl>  				   char *name1, char *name2) <nl>  { <nl>  	if (!ipv6_addr_any(addr)) <nl> -		audit_log_format(ab, " %s=%pI6", name1, addr); <nl> +		audit_log_format(ab, " %s=%pI6c", name1, addr); <nl>  	if (port) <nl>  		audit_log_format(ab, " %s=%d", name2, ntohs(port)); <nl>  }
@@ -845,6 +845,9 @@ static int __init ubi_mtd_param_parse(const char *val, struct kernel_param *kp) <nl>  	char *pbuf = &buf[0]; <nl>  	char *tokens[3] = {NULL, NULL, NULL}; <nl>   <nl> +	if (!val) <nl> +		return -EINVAL; <nl> + <nl>  	if (mtd_devs == UBI_MAX_DEVICES) { <nl>  		printk("UBI error: too many parameters, max. is %d\n", <nl>  		       UBI_MAX_DEVICES);
@@ -450,11 +450,11 @@ serial_pnp_probe(struct pnp_dev *dev, const struct pnp_device_id *dev_id) <nl>  	port.dev = &dev->dev; <nl>   <nl>  	line = serial8250_register_port(&port); <nl> +	if (line < 0) <nl> +		return -ENODEV; <nl>   <nl> -	if (line >= 0) <nl> -		pnp_set_drvdata(dev, (void *)((long)line + 1)); <nl> -	return line >= 0 ? 0 : -ENODEV; <nl> - <nl> +	pnp_set_drvdata(dev, (void *)((long)line + 1)); <nl> +	return 0; <nl>  } <nl>   <nl>  static void __devexit serial_pnp_remove(struct pnp_dev *dev)
@@ -516,6 +516,13 @@ static void do_fault(struct work_struct *work) <nl>  		goto out; <nl>  	} <nl>   <nl> +	if (!(vma->vm_flags & (VM_READ | VM_EXEC | VM_WRITE))) { <nl> +		/* handle_mm_fault would BUG_ON() */ <nl> +		up_read(&mm->mmap_sem); <nl> +		handle_fault_error(fault); <nl> +		goto out; <nl> +	} <nl> + <nl>  	ret = handle_mm_fault(mm, vma, address, write); <nl>  	if (ret & VM_FAULT_ERROR) { <nl>  		/* failed to service fault */
@@ -1125,6 +1125,7 @@ static void iwlagn_tx_status(struct iwl_priv *priv, struct sk_buff *skb) <nl>  	struct ieee80211_sta *sta; <nl>  	struct iwl_station_priv *sta_priv; <nl>   <nl> +	rcu_read_lock(); <nl>  	sta = ieee80211_find_sta(priv->vif, hdr->addr1); <nl>  	if (sta) { <nl>  		sta_priv = (void *)sta->drv_priv; <nl> @@ -1133,6 +1134,7 @@ static void iwlagn_tx_status(struct iwl_priv *priv, struct sk_buff *skb) <nl>  		    atomic_dec_return(&sta_priv->pending_frames) == 0) <nl>  			ieee80211_sta_block_awake(priv->hw, sta, false); <nl>  	} <nl> +	rcu_read_unlock(); <nl>   <nl>  	ieee80211_tx_status_irqsafe(priv->hw, skb); <nl>  }
@@ -1497,7 +1497,6 @@ static int sky2_up(struct net_device *dev) <nl>  	if (ramsize > 0) { <nl>  		u32 rxspace; <nl>   <nl> -		hw->flags |= SKY2_HW_RAM_BUFFER; <nl>  		pr_debug(PFX "%s: ram buffer %dK\n", dev->name, ramsize); <nl>  		if (ramsize < 16) <nl>  			rxspace = ramsize / 2; <nl> @@ -2926,6 +2925,9 @@ static int __devinit sky2_init(struct sky2_hw *hw) <nl>  			++hw->ports; <nl>  	} <nl>   <nl> +	if (sky2_read8(hw, B2_E_0)) <nl> +		hw->flags |= SKY2_HW_RAM_BUFFER; <nl> + <nl>  	return 0; <nl>  } <nl>  
@@ -679,7 +679,8 @@ static int rfcomm_sock_setsockopt(struct socket *sock, int level, int optname, c <nl>  { <nl>  	struct sock *sk = sock->sk; <nl>  	struct bt_security sec; <nl> -	int len, err = 0; <nl> +	int err = 0; <nl> +	size_t len; <nl>  	u32 opt; <nl>   <nl>  	BT_DBG("sk %p", sk);
@@ -1837,6 +1837,11 @@ void __cpuinit generic_processor_info(int apicid, int version) <nl>  	num_processors++; <nl>  	cpu = cpumask_next_zero(-1, cpu_present_mask); <nl>   <nl> +	if (version != apic_version[boot_cpu_physical_apicid]) <nl> +		WARN_ONCE(1, <nl> +			"ACPI: apic version mismatch, bootcpu: %x cpu %d: %x\n", <nl> +			apic_version[boot_cpu_physical_apicid], cpu, version); <nl> + <nl>  	physid_set(apicid, phys_cpu_present_map); <nl>  	if (apicid == boot_cpu_physical_apicid) { <nl>  		/*
@@ -543,7 +543,6 @@ err_regulator_enable: <nl>  err_regulator_get: <nl>  	regulator_bulk_free(ARRAY_SIZE(wm8731->supplies), wm8731->supplies); <nl>   <nl> -	kfree(wm8731); <nl>  	return ret; <nl>  } <nl>  
@@ -1504,9 +1504,7 @@ enum stb0899_status stb0899_dvbs2_algo(struct stb0899_state *state) <nl>  		else <nl>  			internal->inversion = IQ_SWAP_OFF; <nl>   <nl> -		offsetfreq *= internal->inversion; <nl> - <nl> -		internal->freq = internal->freq - offsetfreq; <nl> +		internal->freq = internal->freq + offsetfreq; <nl>  		internal->srate = stb0899_dvbs2_get_srate(state); <nl>   <nl>  		reg = STB0899_READ_S2REG(STB0899_S2DEMOD, UWP_STAT2);
@@ -695,6 +695,11 @@ static int create_trace_kprobe(int argc, char **argv) <nl>  			pr_info("Failed to parse symbol.\n"); <nl>  			return ret; <nl>  		} <nl> +		if (offset && is_return && <nl> +		    !arch_function_offset_within_entry(offset)) { <nl> +			pr_info("Given offset is not valid for return probe.\n"); <nl> +			return -EINVAL; <nl> +		} <nl>  	} <nl>  	argc -= 2; argv += 2; <nl>  
@@ -168,6 +168,9 @@ int main(int argc, char **argv) <nl>  		} <nl>  	} <nl>   <nl> +	if (device_name == NULL) <nl> +		return -1; <nl> + <nl>  	/* Find the device requested */ <nl>  	dev_num = find_type_by_name(device_name, "device"); <nl>  	if (dev_num < 0) {
@@ -355,7 +355,7 @@ static struct inet_frag_queue *inet_frag_alloc(struct netns_frags *nf, <nl>  { <nl>  	struct inet_frag_queue *q; <nl>   <nl> -	if (frag_mem_limit(nf) > nf->high_thresh) { <nl> +	if (!nf->high_thresh || frag_mem_limit(nf) > nf->high_thresh) { <nl>  		inet_frag_schedule_worker(f); <nl>  		return NULL; <nl>  	}
@@ -29,6 +29,8 @@ <nl>  #include "include/policy.h" <nl>  #include "include/policy_unpack.h" <nl>   <nl> +#define FORCE_COMPLAIN_FLAG 0x800 <nl> + <nl>  /* <nl>   * The AppArmor interface treats data as a type byte followed by the <nl>   * actual data.  The interface has the notion of a a named entry <nl> @@ -514,7 +516,7 @@ static struct aa_profile *unpack_profile(struct aa_ext *e) <nl>  		profile->flags |= PFLAG_HAT; <nl>  	if (!unpack_u32(e, &tmp, NULL)) <nl>  		goto fail; <nl> -	if (tmp == PACKED_MODE_COMPLAIN) <nl> +	if (tmp == PACKED_MODE_COMPLAIN || (e->version & FORCE_COMPLAIN_FLAG)) <nl>  		profile->mode = APPARMOR_COMPLAIN; <nl>  	else if (tmp == PACKED_MODE_KILL) <nl>  		profile->mode = APPARMOR_KILL;
@@ -58,6 +58,7 @@ static void nvmet_execute_rw(struct nvmet_req *req) <nl>   <nl>  	if (req->cmd->rw.opcode == nvme_cmd_write) { <nl>  		op = REQ_OP_WRITE; <nl> +		op_flags = WRITE_ODIRECT; <nl>  		if (req->cmd->rw.control & cpu_to_le16(NVME_RW_FUA)) <nl>  			op_flags |= REQ_FUA; <nl>  	} else {
@@ -473,7 +473,7 @@ static int s3c2440_nand_calculate_ecc(struct mtd_info *mtd, const u_char *dat, u <nl>  	ecc_code[1] = ecc >> 8; <nl>  	ecc_code[2] = ecc >> 16; <nl>   <nl> -	pr_debug("%s: returning ecc %06x\n", __func__, ecc); <nl> +	pr_debug("%s: returning ecc %06lx\n", __func__, ecc); <nl>   <nl>  	return 0; <nl>  }
@@ -726,7 +726,7 @@ static int sis5513_config_xfer_rate (ide_drive_t *drive) <nl>  */ <nl>   <nl>  /* Chip detection and general config */ <nl> -static unsigned int __init init_chipset_sis5513 (struct pci_dev *dev, const char *name) <nl> +static unsigned int __devinit init_chipset_sis5513 (struct pci_dev *dev, const char *name) <nl>  { <nl>  	struct pci_dev *host; <nl>  	int i = 0; <nl> @@ -879,7 +879,7 @@ static unsigned int __init init_chipset_sis5513 (struct pci_dev *dev, const char <nl>  	return 0; <nl>  } <nl>   <nl> -static unsigned int __init ata66_sis5513 (ide_hwif_t *hwif) <nl> +static unsigned int __devinit ata66_sis5513 (ide_hwif_t *hwif) <nl>  { <nl>  	u8 ata66 = 0; <nl>   <nl> @@ -897,7 +897,7 @@ static unsigned int __init ata66_sis5513 (ide_hwif_t *hwif) <nl>          return ata66; <nl>  } <nl>   <nl> -static void __init init_hwif_sis5513 (ide_hwif_t *hwif) <nl> +static void __devinit init_hwif_sis5513 (ide_hwif_t *hwif) <nl>  { <nl>  	hwif->autodma = 0; <nl>  
@@ -617,5 +617,5 @@ static void __exit parport_default_proc_unregister (void) <nl>  } <nl>  #endif <nl>   <nl> -module_init(parport_default_proc_register) <nl> +subsys_initcall(parport_default_proc_register) <nl>  module_exit(parport_default_proc_unregister)
@@ -490,7 +490,7 @@ void bfin_serial_rx_dma_timeout(struct bfin_serial_port *uart) <nl>  	uart->rx_dma_nrows = get_dma_curr_ycount(uart->rx_dma_channel); <nl>  	x_pos = get_dma_curr_xcount(uart->rx_dma_channel); <nl>  	uart->rx_dma_nrows = DMA_RX_YCOUNT - uart->rx_dma_nrows; <nl> -	if (uart->rx_dma_nrows == DMA_RX_YCOUNT) <nl> +	if (uart->rx_dma_nrows == DMA_RX_YCOUNT || x_pos == 0) <nl>  		uart->rx_dma_nrows = 0; <nl>  	x_pos = DMA_RX_XCOUNT - x_pos; <nl>  	if (x_pos == DMA_RX_XCOUNT) <nl> @@ -546,15 +546,16 @@ static irqreturn_t bfin_serial_dma_rx_int(int irq, void *dev_id) <nl>  { <nl>  	struct bfin_serial_port *uart = dev_id; <nl>  	unsigned short irqstat; <nl> -	int pos; <nl> +	int x_pos, pos; <nl>   <nl>  	spin_lock(&uart->port.lock); <nl>  	irqstat = get_dma_curr_irqstat(uart->rx_dma_channel); <nl>  	clear_dma_irqstat(uart->rx_dma_channel); <nl>   <nl>  	uart->rx_dma_nrows = get_dma_curr_ycount(uart->rx_dma_channel); <nl> +	x_pos = get_dma_curr_xcount(uart->rx_dma_channel); <nl>  	uart->rx_dma_nrows = DMA_RX_YCOUNT - uart->rx_dma_nrows; <nl> -	if (uart->rx_dma_nrows == DMA_RX_YCOUNT) <nl> +	if (uart->rx_dma_nrows == DMA_RX_YCOUNT || x_pos == 0) <nl>  		uart->rx_dma_nrows = 0; <nl>   <nl>  	pos = uart->rx_dma_nrows * DMA_RX_XCOUNT;
@@ -1334,7 +1334,7 @@ static int tegra_dma_probe(struct platform_device *pdev) <nl>  		if (ret) { <nl>  			dev_err(&pdev->dev, <nl>  				"request_irq failed with err %d channel %d\n", <nl> -				i, ret); <nl> +				ret, i); <nl>  			goto err_irq; <nl>  		} <nl>  
@@ -809,6 +809,14 @@ static inline void cpu_probe_mips(struct cpuinfo_mips *c, unsigned int cpu) <nl>  		c->cputype = CPU_74K; <nl>  		__cpu_name[cpu] = "MIPS 1074Kc"; <nl>  		break; <nl> +	case PRID_IMP_INTERAPTIV_UP: <nl> +		c->cputype = CPU_INTERAPTIV; <nl> +		__cpu_name[cpu] = "MIPS interAptiv"; <nl> +		break; <nl> +	case PRID_IMP_INTERAPTIV_MP: <nl> +		c->cputype = CPU_INTERAPTIV; <nl> +		__cpu_name[cpu] = "MIPS interAptiv (multi)"; <nl> +		break; <nl>  	case PRID_IMP_PROAPTIV_UP: <nl>  		c->cputype = CPU_PROAPTIV; <nl>  		__cpu_name[cpu] = "MIPS proAptiv";
@@ -104,7 +104,8 @@ static int s3c64xx_cpufreq_set_target(struct cpufreq_policy *policy, <nl>  		if (ret != 0) { <nl>  			pr_err("Failed to set VDDARM for %dkHz: %d\n", <nl>  			       freqs.new, ret); <nl> -			goto err; <nl> +			freqs.new = freqs.old; <nl> +			goto post_notify; <nl>  		} <nl>  	} <nl>  #endif <nl> @@ -113,10 +114,13 @@ static int s3c64xx_cpufreq_set_target(struct cpufreq_policy *policy, <nl>  	if (ret < 0) { <nl>  		pr_err("Failed to set rate %dkHz: %d\n", <nl>  		       freqs.new, ret); <nl> -		goto err; <nl> +		freqs.new = freqs.old; <nl>  	} <nl>   <nl> +post_notify: <nl>  	cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE); <nl> +	if (ret) <nl> +		goto err; <nl>   <nl>  #ifdef CONFIG_REGULATOR <nl>  	if (vddarm && freqs.new < freqs.old) {
@@ -751,6 +751,9 @@ int ivtv_stop_v4l2_encode_stream(struct ivtv_stream *s, int gop_end) <nl>  		stopmode = 1; <nl>  	} <nl>   <nl> +	/* ensure these actions are done only once */ <nl> +	mutex_lock(&itv->serialize_lock); <nl> + <nl>  	/* end_capture */ <nl>  	/* when: 0 =  end of GOP  1 = NOW!, type: 0 = mpeg, subtype: 3 = video+audio */ <nl>  	ivtv_vapi(itv, CX2341X_ENC_STOP_CAPTURE, 3, stopmode, cap_type, s->subtype); <nl> @@ -803,9 +806,6 @@ int ivtv_stop_v4l2_encode_stream(struct ivtv_stream *s, int gop_end) <nl>  	/* Clear capture and no-read bits */ <nl>  	clear_bit(IVTV_F_S_STREAMING, &s->s_flags); <nl>   <nl> -	/* ensure these global cleanup actions are done only once */ <nl> -	mutex_lock(&itv->serialize_lock); <nl> - <nl>  	if (s->type == IVTV_ENC_STREAM_TYPE_VBI) <nl>  		ivtv_set_irq_mask(itv, IVTV_IRQ_ENC_VBI_CAP); <nl>  
@@ -219,6 +219,8 @@ static int hal2_gain_get(struct snd_kcontrol *kcontrol, <nl>  		l = (tmp >> H2I_C2_L_GAIN_SHIFT) & 15; <nl>  		r = (tmp >> H2I_C2_R_GAIN_SHIFT) & 15; <nl>  		break; <nl> +	default: <nl> +		return -EINVAL; <nl>  	} <nl>  	ucontrol->value.integer.value[0] = l; <nl>  	ucontrol->value.integer.value[1] = r; <nl> @@ -256,6 +258,8 @@ static int hal2_gain_put(struct snd_kcontrol *kcontrol, <nl>  		new |= (r << H2I_C2_R_GAIN_SHIFT); <nl>  		hal2_i_write32(hal2, H2I_ADC_C2, new); <nl>  		break; <nl> +	default: <nl> +		return -EINVAL; <nl>  	} <nl>  	return old != new; <nl>  }
@@ -722,6 +722,8 @@ static int mlx5e_create_main_flow_table(struct mlx5e_priv *priv) <nl>  	u8 *dmac; <nl>   <nl>  	g = kcalloc(9, sizeof(*g), GFP_KERNEL); <nl> +	if (!g) <nl> +		return -ENOMEM; <nl>   <nl>  	g[0].log_sz = 2; <nl>  	g[0].match_criteria_enable = MLX5_MATCH_OUTER_HEADERS;
@@ -284,11 +284,8 @@ void fsnotify_duplicate_mark(struct fsnotify_mark *new, struct fsnotify_mark *ol <nl>  void fsnotify_init_mark(struct fsnotify_mark *mark, <nl>  			void (*free_mark)(struct fsnotify_mark *mark)) <nl>  { <nl> +	memset(mark, 0, sizeof(*mark)); <nl>  	spin_lock_init(&mark->lock); <nl>  	atomic_set(&mark->refcnt, 1); <nl> -	INIT_HLIST_NODE(&mark->i.i_list); <nl> -	mark->group = NULL; <nl> -	mark->mask = 0; <nl> -	mark->i.inode = NULL; <nl>  	mark->free_mark = free_mark; <nl>  }
@@ -192,3 +192,7 @@ EXPORT_SYMBOL(hwsw_unmap_sg); <nl>  EXPORT_SYMBOL(hwsw_dma_supported); <nl>  EXPORT_SYMBOL(hwsw_alloc_coherent); <nl>  EXPORT_SYMBOL(hwsw_free_coherent); <nl> +EXPORT_SYMBOL(hwsw_sync_single_for_cpu); <nl> +EXPORT_SYMBOL(hwsw_sync_single_for_device); <nl> +EXPORT_SYMBOL(hwsw_sync_sg_for_cpu); <nl> +EXPORT_SYMBOL(hwsw_sync_sg_for_device);
@@ -557,6 +557,9 @@ static int __init __fdt_scan_reserved_mem(unsigned long node, const char *uname, <nl>   */ <nl>  void __init early_init_fdt_scan_reserved_mem(void) <nl>  { <nl> +	if (!initial_boot_params) <nl> +		return; <nl> + <nl>  	of_scan_flat_dt(__fdt_scan_reserved_mem, NULL); <nl>  	fdt_init_reserved_mem(); <nl>  }
@@ -37,6 +37,7 @@ <nl>  #define OP_31_XOP_SLBIA		498 <nl>  #define OP_31_XOP_MFSR		595 <nl>  #define OP_31_XOP_MFSRIN	659 <nl> +#define OP_31_XOP_DCBA		758 <nl>  #define OP_31_XOP_SLBMFEV	851 <nl>  #define OP_31_XOP_EIOIO		854 <nl>  #define OP_31_XOP_SLBMFEE	915 <nl> @@ -183,6 +184,9 @@ int kvmppc_core_emulate_op(struct kvm_run *run, struct kvm_vcpu *vcpu, <nl>  				kvmppc_set_gpr(vcpu, get_rt(inst), t); <nl>  			} <nl>  			break; <nl> +		case OP_31_XOP_DCBA: <nl> +			/* Gets treated as NOP */ <nl> +			break; <nl>  		case OP_31_XOP_DCBZ: <nl>  		{ <nl>  			ulong rb = kvmppc_get_gpr(vcpu, get_rb(inst));
@@ -249,6 +249,8 @@ static int tcf_act_police(struct sk_buff *skb, const struct tc_action *a, <nl>  			police->tcfp_t_c = now; <nl>  			police->tcfp_toks = toks; <nl>  			police->tcfp_ptoks = ptoks; <nl> +			if (police->tcfp_result == TC_ACT_SHOT) <nl> +				police->tcf_qstats.drops++; <nl>  			spin_unlock(&police->tcf_lock); <nl>  			return police->tcfp_result; <nl>  		}
@@ -3186,12 +3186,12 @@ sch_handle_egress(struct sk_buff *skb, int *ret, struct net_device *dev) <nl>  	case TC_ACT_SHOT: <nl>  		qdisc_qstats_cpu_drop(cl->q); <nl>  		*ret = NET_XMIT_DROP; <nl> -		goto drop; <nl> +		kfree_skb(skb); <nl> +		return NULL; <nl>  	case TC_ACT_STOLEN: <nl>  	case TC_ACT_QUEUED: <nl>  		*ret = NET_XMIT_SUCCESS; <nl> -drop: <nl> -		kfree_skb(skb); <nl> +		consume_skb(skb); <nl>  		return NULL; <nl>  	case TC_ACT_REDIRECT: <nl>  		/* No need to push/pop skb's mac_header here on egress! */
@@ -3336,7 +3336,7 @@ static int probe_one_instance(unsigned int nid) <nl>  	ecc_stngs[nid] = s; <nl>   <nl>  	if (!ecc_enabled(F3, nid)) { <nl> -		ret = -ENODEV; <nl> +		ret = 0; <nl>   <nl>  		if (!ecc_enable_override) <nl>  			goto err_enable; <nl> @@ -3465,6 +3465,11 @@ static int __init amd64_edac_init(void) <nl>  		} <nl>  	} <nl>   <nl> +	if (!edac_has_mcs()) { <nl> +		err = -ENODEV; <nl> +		goto err_pci; <nl> +	} <nl> + <nl>  	/* register stuff with EDAC MCE */ <nl>  	if (report_gart_errors) <nl>  		amd_report_gart_errors(true);
@@ -297,6 +297,7 @@ static ssize_t chars_in_buffer(struct tty_struct *tty) <nl>   <nl>  static ssize_t n_tty_chars_in_buffer(struct tty_struct *tty) <nl>  { <nl> +	WARN_ONCE(1, "%s is deprecated and scheduled for removal.", __func__); <nl>  	return chars_in_buffer(tty); <nl>  } <nl>  
@@ -114,12 +114,18 @@ static struct neighbour *fake_neigh_lookup(const struct dst_entry *dst, const vo <nl>  	return NULL; <nl>  } <nl>   <nl> +static unsigned int fake_mtu(const struct dst_entry *dst) <nl> +{ <nl> +	return dst->dev->mtu; <nl> +} <nl> + <nl>  static struct dst_ops fake_dst_ops = { <nl>  	.family =		AF_INET, <nl>  	.protocol =		cpu_to_be16(ETH_P_IP), <nl>  	.update_pmtu =		fake_update_pmtu, <nl>  	.cow_metrics =		fake_cow_metrics, <nl>  	.neigh_lookup =		fake_neigh_lookup, <nl> +	.mtu =			fake_mtu, <nl>  }; <nl>   <nl>  /*
@@ -129,14 +129,15 @@ int mlx4_en_activate_cq(struct mlx4_en_priv *priv, struct mlx4_en_cq *cq, <nl>  						  name); <nl>  				} <nl>   <nl> -				cq->irq_desc = <nl> -					irq_to_desc(mlx4_eq_get_irq(mdev->dev, <nl> -								    cq->vector)); <nl>  			} <nl>  		} else { <nl>  			cq->vector = (cq->ring + 1 + priv->port) % <nl>  				mdev->dev->caps.num_comp_vectors; <nl>  		} <nl> + <nl> +		cq->irq_desc = <nl> +			irq_to_desc(mlx4_eq_get_irq(mdev->dev, <nl> +						    cq->vector)); <nl>  	} else { <nl>  		/* For TX we use the same irq per <nl>  		ring we assigned for the RX    */
@@ -486,12 +486,14 @@ static unsigned int tun_chr_poll(struct file *file, poll_table * wait) <nl>  { <nl>  	struct tun_file *tfile = file->private_data; <nl>  	struct tun_struct *tun = __tun_get(tfile); <nl> -	struct sock *sk = tun->sk; <nl> +	struct sock *sk; <nl>  	unsigned int mask = 0; <nl>   <nl>  	if (!tun) <nl>  		return POLLERR; <nl>   <nl> +	sk = tun->sk; <nl> + <nl>  	DBG(KERN_INFO "%s: tun_chr_poll\n", tun->dev->name); <nl>   <nl>  	poll_wait(file, &tun->socket.wait, wait);
@@ -1450,7 +1450,7 @@ err: <nl>  	return ret; <nl>  } <nl>   <nl> -static enum fb_op_origin <nl> +static inline enum fb_op_origin <nl>  write_origin(struct drm_i915_gem_object *obj, unsigned domain) <nl>  { <nl>  	return domain == I915_GEM_DOMAIN_GTT && !obj->has_wc_mmap ? <nl> @@ -3155,7 +3155,7 @@ i915_gem_object_flush_gtt_write_domain(struct drm_i915_gem_object *obj) <nl>  	old_write_domain = obj->base.write_domain; <nl>  	obj->base.write_domain = 0; <nl>   <nl> -	intel_fb_obj_flush(obj, false, ORIGIN_GTT); <nl> +	intel_fb_obj_flush(obj, false, write_origin(obj, I915_GEM_DOMAIN_GTT)); <nl>   <nl>  	trace_i915_gem_object_change_domain(obj, <nl>  					    obj->base.read_domains,
@@ -305,6 +305,7 @@ static struct dma_async_tx_descriptor *edma_prep_slave_sg( <nl>  				edma_alloc_slot(EDMA_CTLR(echan->ch_num), <nl>  						EDMA_SLOT_ANY); <nl>  			if (echan->slot[i] < 0) { <nl> +				kfree(edesc); <nl>  				dev_err(dev, "Failed to allocate slot\n"); <nl>  				kfree(edesc); <nl>  				return NULL;
@@ -187,10 +187,10 @@ bool __weak is_trap_insn(uprobe_opcode_t *insn) <nl>  	return is_swbp_insn(insn); <nl>  } <nl>   <nl> -static void copy_opcode(struct page *page, unsigned long vaddr, uprobe_opcode_t *opcode) <nl> +static void copy_from_page(struct page *page, unsigned long vaddr, void *dst, int len) <nl>  { <nl>  	void *kaddr = kmap_atomic(page); <nl> -	memcpy(opcode, kaddr + (vaddr & ~PAGE_MASK), UPROBE_SWBP_INSN_SIZE); <nl> +	memcpy(dst, kaddr + (vaddr & ~PAGE_MASK), len); <nl>  	kunmap_atomic(kaddr); <nl>  } <nl>   <nl> @@ -208,7 +208,7 @@ static int verify_opcode(struct page *page, unsigned long vaddr, uprobe_opcode_t <nl>  	 * is a trap variant; uprobes always wins over any other (gdb) <nl>  	 * breakpoint. <nl>  	 */ <nl> -	copy_opcode(page, vaddr, &old_opcode); <nl> +	copy_from_page(page, vaddr, &old_opcode, UPROBE_SWBP_INSN_SIZE); <nl>  	is_swbp = is_swbp_insn(&old_opcode); <nl>   <nl>  	if (is_swbp_insn(new_opcode)) { <nl> @@ -1472,7 +1472,7 @@ static int is_trap_at_addr(struct mm_struct *mm, unsigned long vaddr) <nl>  	if (result < 0) <nl>  		return result; <nl>   <nl> -	copy_opcode(page, vaddr, &opcode); <nl> +	copy_from_page(page, vaddr, &opcode, UPROBE_SWBP_INSN_SIZE); <nl>  	put_page(page); <nl>   out: <nl>  	/* This needs to return true for any variant of the trap insn */
@@ -20,16 +20,11 @@ <nl>  int mesh_allocated; <nl>  static struct kmem_cache *rm_cache; <nl>   <nl> -#ifdef CONFIG_MAC80211_MESH <nl>  bool mesh_action_is_path_sel(struct ieee80211_mgmt *mgmt) <nl>  { <nl>  	return (mgmt->u.action.u.mesh_action.action_code == <nl>  			WLAN_MESH_ACTION_HWMP_PATH_SELECTION); <nl>  } <nl> -#else <nl> -bool mesh_action_is_path_sel(struct ieee80211_mgmt *mgmt) <nl> -{ return false; } <nl> -#endif <nl>   <nl>  void ieee80211s_init(void) <nl>  {
@@ -38,12 +38,12 @@ static int jffs2_acl_count(size_t size) <nl>  	size_t s; <nl>   <nl>  	size -= sizeof(struct jffs2_acl_header); <nl> -	s = size - 4 * sizeof(struct jffs2_acl_entry_short); <nl> -	if (s < 0) { <nl> +	if (size < 4 * sizeof(struct jffs2_acl_entry_short)) { <nl>  		if (size % sizeof(struct jffs2_acl_entry_short)) <nl>  			return -1; <nl>  		return size / sizeof(struct jffs2_acl_entry_short); <nl>  	} else { <nl> +		s = size - 4 * sizeof(struct jffs2_acl_entry_short); <nl>  		if (s % sizeof(struct jffs2_acl_entry)) <nl>  			return -1; <nl>  		return s / sizeof(struct jffs2_acl_entry) + 4;
@@ -249,6 +249,7 @@ static const struct of_device_id regulator_haptic_dt_match[] = { <nl>  	{ .compatible = "regulator-haptic" }, <nl>  	{ /* sentinel */ }, <nl>  }; <nl> +MODULE_DEVICE_TABLE(of, regulator_haptic_dt_match); <nl>   <nl>  static struct platform_driver regulator_haptic_driver = { <nl>  	.probe		= regulator_haptic_probe,
@@ -39,8 +39,8 @@ <nl>  /* <nl>   * Literals <nl>   */ <nl> -#define IPR_DRIVER_VERSION "2.6.1" <nl> -#define IPR_DRIVER_DATE "(March 12, 2015)" <nl> +#define IPR_DRIVER_VERSION "2.6.2" <nl> +#define IPR_DRIVER_DATE "(June 11, 2015)" <nl>   <nl>  /* <nl>   * IPR_MAX_CMD_PER_LUN: This defines the maximum number of outstanding
@@ -585,7 +585,8 @@ static int __devinit sta2x11_mfd_probe(struct pci_dev *pdev, <nl>  	sta2x11_mfd_setup(pdev, setup_data); <nl>   <nl>  	/* Record this pdev before mfd_add_devices: their probe looks for it */ <nl> -	sta2x11_mfd_add(pdev, GFP_ATOMIC); <nl> +	if (!sta2x11_mfd_find(pdev)) <nl> +		sta2x11_mfd_add(pdev, GFP_ATOMIC); <nl>   <nl>  	/* Just 2 bars for all mfd's at present */ <nl>  	for (i = 0; i < 2; i++) {
@@ -3852,9 +3852,13 @@ i915_gem_object_pin(struct drm_i915_gem_object *obj, <nl>  		    uint32_t alignment, <nl>  		    unsigned flags) <nl>  { <nl> +	struct drm_i915_private *dev_priv = obj->base.dev->dev_private; <nl>  	struct i915_vma *vma; <nl>  	int ret; <nl>   <nl> +	if (WARN_ON(vm == &dev_priv->mm.aliasing_ppgtt->base)) <nl> +		return -ENODEV; <nl> + <nl>  	if (WARN_ON(flags & (PIN_GLOBAL | PIN_MAPPABLE) && !i915_is_ggtt(vm))) <nl>  		return -EINVAL; <nl>  
@@ -1165,6 +1165,8 @@ static int snd_fm801_free(struct fm801 *chip) <nl>  	cmdw |= 0x00c3; <nl>  	fm801_writew(chip, IRQ_MASK, cmdw); <nl>   <nl> +	devm_free_irq(&chip->pci->dev, chip->irq, chip); <nl> + <nl>        __end_hw: <nl>  #ifdef CONFIG_SND_FM801_TEA575X_BOOL <nl>  	if (!(chip->tea575x_tuner & TUNER_DISABLED)) {
@@ -1058,6 +1058,7 @@ process_filter(struct event_format *event, struct filter_arg **parg, <nl>  					*parg = current_op; <nl>  				else <nl>  					*parg = current_exp; <nl> +				free(token); <nl>  				return PEVENT_ERRNO__UNBALANCED_PAREN; <nl>  			} <nl>  			break; <nl> @@ -1168,6 +1169,7 @@ process_filter(struct event_format *event, struct filter_arg **parg, <nl>   <nl>  	*parg = current_op; <nl>   <nl> +	free(token); <nl>  	return 0; <nl>   <nl>   fail_alloc:
@@ -297,7 +297,9 @@ static ssize_t qeth_l3_dev_hsuid_store(struct device *dev, <nl>  		addr->u.a6.pfxlen = 0; <nl>  		addr->type = QETH_IP_TYPE_NORMAL; <nl>   <nl> +		spin_lock_bh(&card->ip_lock); <nl>  		qeth_l3_delete_ip(card, addr); <nl> +		spin_unlock_bh(&card->ip_lock); <nl>  		kfree(addr); <nl>  	} <nl>   <nl> @@ -329,7 +331,10 @@ static ssize_t qeth_l3_dev_hsuid_store(struct device *dev, <nl>  		addr->type = QETH_IP_TYPE_NORMAL; <nl>  	} else <nl>  		return -ENOMEM; <nl> + <nl> +	spin_lock_bh(&card->ip_lock); <nl>  	qeth_l3_add_ip(card, addr); <nl> +	spin_unlock_bh(&card->ip_lock); <nl>  	kfree(addr); <nl>   <nl>  	return count;
@@ -965,7 +965,7 @@ static int osc_extent_wait(const struct lu_env *env, struct osc_extent *ext, <nl>  			"%s: wait ext to %d timedout, recovery in progress?\n", <nl>  			osc_export(obj)->exp_obd->obd_name, state); <nl>   <nl> -		lwi = LWI_INTR(LWI_ON_SIGNAL_NOOP, NULL); <nl> +		lwi = LWI_INTR(NULL, NULL); <nl>  		rc = l_wait_event(ext->oe_waitq, extent_wait_cb(ext, state), <nl>  				  &lwi); <nl>  	}
@@ -448,6 +448,7 @@ static int btrfs_parse_early_options(const char *options, fmode_t flags, <nl>  		token = match_token(p, tokens, args); <nl>  		switch (token) { <nl>  		case Opt_subvol: <nl> +			kfree(*subvol_name); <nl>  			*subvol_name = match_strdup(&args[0]); <nl>  			break; <nl>  		case Opt_subvolid:
@@ -590,6 +590,12 @@ int dm_split_args(int *argc, char ***argvp, char *input) <nl>  	unsigned array_size = 0; <nl>   <nl>  	*argc = 0; <nl> + <nl> +	if (!input) { <nl> +		*argvp = NULL; <nl> +		return 0; <nl> +	} <nl> + <nl>  	argv = realloc_argv(&array_size, argv); <nl>  	if (!argv) <nl>  		return -ENOMEM;
@@ -324,7 +324,7 @@ static void __pci_restore_msix_state(struct pci_dev *dev) <nl>  	if (!dev->msix_enabled) <nl>  		return; <nl>  	BUG_ON(list_empty(&dev->msi_list)); <nl> -	entry = list_entry(dev->msi_list.next, struct msi_desc, list); <nl> +	entry = list_first_entry(&dev->msi_list, struct msi_desc, list); <nl>  	pos = entry->msi_attrib.pos; <nl>  	pci_read_config_word(dev, pos + PCI_MSIX_FLAGS, &control); <nl>  
@@ -109,7 +109,7 @@ static int gp8psk_fe_read_signal_strength(struct dvb_frontend* fe, u16 *strength <nl>   <nl>  static int gp8psk_fe_get_tune_settings(struct dvb_frontend* fe, struct dvb_frontend_tune_settings *tune) <nl>  { <nl> -	tune->min_delay_ms = 200; <nl> +	tune->min_delay_ms = 800; <nl>  	return 0; <nl>  } <nl>  
@@ -27,6 +27,8 @@ <nl>  void lbs_mac_event_disconnected(struct lbs_private *priv, <nl>  				bool locally_generated) <nl>  { <nl> +	unsigned long flags; <nl> + <nl>  	if (priv->connect_status != LBS_CONNECTED) <nl>  		return; <nl>   <nl> @@ -46,9 +48,11 @@ void lbs_mac_event_disconnected(struct lbs_private *priv, <nl>  	netif_carrier_off(priv->dev); <nl>   <nl>  	/* Free Tx and Rx packets */ <nl> +	spin_lock_irqsave(&priv->driver_lock, flags); <nl>  	kfree_skb(priv->currenttxskb); <nl>  	priv->currenttxskb = NULL; <nl>  	priv->tx_pending_len = 0; <nl> +	spin_unlock_irqrestore(&priv->driver_lock, flags); <nl>   <nl>  	priv->connect_status = LBS_DISCONNECTED; <nl>  
@@ -250,6 +250,9 @@ int max8998_irq_init(struct max8998_dev *max8998) <nl>   <nl>  void max8998_irq_exit(struct max8998_dev *max8998) <nl>  { <nl> +	if (max8998->ono) <nl> +		free_irq(max8998->ono, max8998); <nl> + <nl>  	if (max8998->irq) <nl>  		free_irq(max8998->irq, max8998); <nl>  }
@@ -946,6 +946,8 @@ jme_alloc_and_feed_skb(struct jme_adapter *jme, int idx) <nl>  				jme->jme_vlan_rx(skb, jme->vlgrp, <nl>  					le16_to_cpu(rxdesc->descwb.vlan)); <nl>  				NET_STAT(jme).rx_bytes += 4; <nl> +			} else { <nl> +				dev_kfree_skb(skb); <nl>  			} <nl>  		} else { <nl>  			jme->jme_rx(skb);
@@ -1266,6 +1266,9 @@ static struct tx_agg *r8152_get_tx_agg(struct r8152 *tp) <nl>  	struct tx_agg *agg = NULL; <nl>  	unsigned long flags; <nl>   <nl> +	if (list_empty(&tp->tx_free)) <nl> +		return NULL; <nl> + <nl>  	spin_lock_irqsave(&tp->tx_lock, flags); <nl>  	if (!list_empty(&tp->tx_free)) { <nl>  		struct list_head *cursor;
@@ -969,6 +969,8 @@ static int macvtap_ioctl_set_queue(struct file *file, unsigned int flags) <nl>  		ret = macvtap_enable_queue(vlan->dev, file, q); <nl>  	else if (flags & IFF_DETACH_QUEUE) <nl>  		ret = macvtap_disable_queue(q); <nl> +	else <nl> +		ret = -EINVAL; <nl>   <nl>  	macvtap_put_vlan(vlan); <nl>  	return ret;
@@ -608,6 +608,7 @@ ssize_t tcp_splice_read(struct socket *sock, loff_t *ppos, <nl>  	ssize_t spliced; <nl>  	int ret; <nl>   <nl> +	sock_rps_record_flow(sk); <nl>  	/* <nl>  	 * We can't seek on a socket input <nl>  	 */
@@ -667,7 +667,13 @@ target_emulate_readcapacity(struct se_cmd *cmd) <nl>  { <nl>  	struct se_device *dev = SE_DEV(cmd); <nl>  	unsigned char *buf = cmd->t_task->t_task_buf; <nl> -	u32 blocks = dev->transport->get_blocks(dev); <nl> +	unsigned long long blocks_long = dev->transport->get_blocks(dev); <nl> +	u32 blocks; <nl> + <nl> +	if (blocks_long >= 0x00000000ffffffff) <nl> +		blocks = 0xffffffff; <nl> +	else <nl> +		blocks = (u32)blocks_long; <nl>   <nl>  	buf[0] = (blocks >> 24) & 0xff; <nl>  	buf[1] = (blocks >> 16) & 0xff;
@@ -60,7 +60,7 @@ static ssize_t w1_smem_read_val(struct device *dev, char *buf) <nl>  	int i; <nl>  	ssize_t count = 0; <nl>  	 <nl> -	for (i = 0; i < 9; ++i) <nl> +	for (i = 0; i < 8; ++i) <nl>  		count += sprintf(buf + count, "%02x ", ((u8 *)&sl->reg_num)[i]); <nl>  	count += sprintf(buf + count, "\n"); <nl>   <nl> @@ -87,7 +87,7 @@ static ssize_t w1_smem_read_bin(struct kobject *kobj, char *buf, loff_t off, siz <nl>  		count = 0; <nl>  		goto out; <nl>  	} <nl> -	for (i = 0; i < 9; ++i) <nl> +	for (i = 0; i < 8; ++i) <nl>  		count += sprintf(buf + count, "%02x ", ((u8 *)&sl->reg_num)[i]); <nl>  	count += sprintf(buf + count, "\n"); <nl>  	
@@ -588,7 +588,7 @@ int serial8250_em485_init(struct uart_8250_port *p) <nl>  	if (p->em485 != NULL) <nl>  		return 0; <nl>   <nl> -	p->em485 = kmalloc(sizeof(struct uart_8250_em485), GFP_KERNEL); <nl> +	p->em485 = kmalloc(sizeof(struct uart_8250_em485), GFP_ATOMIC); <nl>  	if (p->em485 == NULL) <nl>  		return -ENOMEM; <nl>  
@@ -487,9 +487,12 @@ static void __init emergency_stack_init(void) <nl>  	 */ <nl>  	limit = min(0x10000000UL, lmb.rmo_size); <nl>   <nl> -	for_each_possible_cpu(i) <nl> -		paca[i].emergency_sp = <nl> -		__va(lmb_alloc_base(HW_PAGE_SIZE, 128, limit)) + HW_PAGE_SIZE; <nl> +	for_each_possible_cpu(i) { <nl> +		unsigned long sp; <nl> +		sp  = lmb_alloc_base(THREAD_SIZE, THREAD_SIZE, limit); <nl> +		sp += THREAD_SIZE; <nl> +		paca[i].emergency_sp = __va(sp); <nl> +	} <nl>  } <nl>   <nl>  /*
@@ -43,7 +43,7 @@ void host1x_set_drm_data(struct device *dev, void *data) <nl>  void *host1x_get_drm_data(struct device *dev) <nl>  { <nl>  	struct host1x *host1x = dev_get_drvdata(dev); <nl> -	return host1x->drm_data; <nl> +	return host1x ? host1x->drm_data : NULL; <nl>  } <nl>   <nl>  void host1x_sync_writel(struct host1x *host1x, u32 v, u32 r)
@@ -140,6 +140,9 @@ bool drm_i2c_encoder_mode_fixup(struct drm_encoder *encoder, <nl>  		const struct drm_display_mode *mode, <nl>  		struct drm_display_mode *adjusted_mode) <nl>  { <nl> +	if (!get_slave_funcs(encoder)->mode_fixup) <nl> +		return true; <nl> + <nl>  	return get_slave_funcs(encoder)->mode_fixup(encoder, mode, adjusted_mode); <nl>  } <nl>  EXPORT_SYMBOL(drm_i2c_encoder_mode_fixup);
@@ -326,6 +326,7 @@ static int ocfs2_truncate_file(struct inode *inode, <nl>  		   (unsigned long long)OCFS2_I(inode)->ip_blkno, <nl>  		   (unsigned long long)new_i_size); <nl>   <nl> +	unmap_mapping_range(inode->i_mapping, new_i_size + PAGE_SIZE - 1, 0, 1); <nl>  	truncate_inode_pages(inode->i_mapping, new_i_size); <nl>   <nl>  	fe = (struct ocfs2_dinode *) di_bh->b_data;
@@ -33,10 +33,13 @@ static u32 crc32c_vpmsum(u32 crc, unsigned char const *p, size_t len) <nl>  	} <nl>   <nl>  	if (len & ~VMX_ALIGN_MASK) { <nl> +		preempt_disable(); <nl>  		pagefault_disable(); <nl>  		enable_kernel_altivec(); <nl>  		crc = __crc32c_vpmsum(crc, p, len & ~VMX_ALIGN_MASK); <nl> +		disable_kernel_altivec(); <nl>  		pagefault_enable(); <nl> +		preempt_enable(); <nl>  	} <nl>   <nl>  	tail = len & VMX_ALIGN_MASK;
@@ -592,7 +592,7 @@ static struct p9_trans_module p9_virtio_trans = { <nl>  	.close = p9_virtio_close, <nl>  	.request = p9_virtio_request, <nl>  	.cancel = p9_virtio_cancel, <nl> -	.maxsize = PAGE_SIZE*16, <nl> +	.maxsize = PAGE_SIZE*VIRTQUEUE_NUM, <nl>  	.pref = P9_TRANS_PREF_PAYLOAD_SEP, <nl>  	.def = 0, <nl>  	.owner = THIS_MODULE,
@@ -478,6 +478,11 @@ static void iwl_mvm_stat_iterator(void *_data, u8 *mac, <nl>  	if (vif->type != NL80211_IFTYPE_STATION) <nl>  		return; <nl>   <nl> +	if (sig == 0) { <nl> +		IWL_DEBUG_RX(mvm, "RSSI is 0 - skip signal based decision\n"); <nl> +		return; <nl> +	} <nl> + <nl>  	mvmvif->bf_data.ave_beacon_signal = sig; <nl>   <nl>  	/* BT Coex */
@@ -709,6 +709,10 @@ static void __cpuinit put_core_offline(unsigned int cpu) <nl>   <nl>  	indx = TO_ATTR_NO(cpu); <nl>   <nl> +	/* The core id is too big, just return */ <nl> +	if (indx > MAX_CORE_DATA - 1) <nl> +		return; <nl> + <nl>  	if (pdata->core_data[indx] && pdata->core_data[indx]->cpu == cpu) <nl>  		coretemp_remove_core(pdata, &pdev->dev, indx); <nl>  
@@ -42,14 +42,17 @@ static int udf_pc_to_char(struct super_block *sb, unsigned char *from, <nl>  	tolen--; <nl>  	while (elen < fromlen) { <nl>  		pc = (struct pathComponent *)(from + elen); <nl> +		elen += sizeof(struct pathComponent); <nl>  		switch (pc->componentType) { <nl>  		case 1: <nl>  			/* <nl>  			 * Symlink points to some place which should be agreed <nl>   			 * upon between originator and receiver of the media. Ignore. <nl>  			 */ <nl> -			if (pc->lengthComponentIdent > 0) <nl> +			if (pc->lengthComponentIdent > 0) { <nl> +				elen += pc->lengthComponentIdent; <nl>  				break; <nl> +			} <nl>  			/* Fall through */ <nl>  		case 2: <nl>  			if (tolen == 0) <nl> @@ -74,6 +77,9 @@ static int udf_pc_to_char(struct super_block *sb, unsigned char *from, <nl>  			/* that would be . - just ignore */ <nl>  			break; <nl>  		case 5: <nl> +			elen += pc->lengthComponentIdent; <nl> +			if (elen > fromlen) <nl> +				return -EIO; <nl>  			comp_len = udf_get_filename(sb, pc->componentIdent, <nl>  						    pc->lengthComponentIdent, <nl>  						    p, tolen); <nl> @@ -85,7 +91,6 @@ static int udf_pc_to_char(struct super_block *sb, unsigned char *from, <nl>  			tolen--; <nl>  			break; <nl>  		} <nl> -		elen += sizeof(struct pathComponent) + pc->lengthComponentIdent; <nl>  	} <nl>  	if (p > to + 1) <nl>  		p[-1] = '\0';
@@ -111,7 +111,8 @@ static struct sctp_endpoint *sctp_endpoint_init(struct sctp_endpoint *ep, <nl>  		if (sctp_addip_enable) { <nl>  			auth_chunks->chunks[0] = SCTP_CID_ASCONF; <nl>  			auth_chunks->chunks[1] = SCTP_CID_ASCONF_ACK; <nl> -			auth_chunks->param_hdr.length += htons(2); <nl> +			auth_chunks->param_hdr.length = <nl> +					htons(sizeof(sctp_paramhdr_t) + 2); <nl>  		} <nl>  	} <nl>  
@@ -488,8 +488,7 @@ out: <nl>  	return err; <nl>  } <nl>   <nl> -static int recover_data(struct f2fs_sb_info *sbi, <nl> -				struct list_head *head, int type) <nl> +static int recover_data(struct f2fs_sb_info *sbi, struct list_head *head) <nl>  { <nl>  	unsigned long long cp_ver = cur_cp_version(F2FS_CKPT(sbi)); <nl>  	struct curseg_info *curseg; <nl> @@ -498,7 +497,7 @@ static int recover_data(struct f2fs_sb_info *sbi, <nl>  	block_t blkaddr; <nl>   <nl>  	/* get node pages in the current segment */ <nl> -	curseg = CURSEG_I(sbi, type); <nl> +	curseg = CURSEG_I(sbi, CURSEG_WARM_NODE); <nl>  	blkaddr = NEXT_FREE_BLKADDR(sbi, curseg); <nl>   <nl>  	while (1) { <nl> @@ -585,7 +584,7 @@ int recover_fsync_data(struct f2fs_sb_info *sbi) <nl>  	need_writecp = true; <nl>   <nl>  	/* step #2: recover data */ <nl> -	err = recover_data(sbi, &inode_list, CURSEG_WARM_NODE); <nl> +	err = recover_data(sbi, &inode_list); <nl>  	if (!err) <nl>  		f2fs_bug_on(sbi, !list_empty(&inode_list)); <nl>  out:
@@ -36,7 +36,7 @@ static struct usbip_imported_device *imported_device_init(struct usbip_imported_ <nl>  				goto err; <nl>   <nl>  			memcpy(new_cdev, cdev, sizeof(*new_cdev)); <nl> -			dlist_unshift(idev->cdev_list, (void*) new_cdev); <nl> +			dlist_unshift(idev->cdev_list, (void *) new_cdev); <nl>  		} <nl>  	} <nl>  
@@ -2550,6 +2550,9 @@ static void intel_enable_dp(struct intel_encoder *encoder) <nl>   <nl>  	pps_unlock(intel_dp); <nl>   <nl> +	if (IS_VALLEYVIEW(dev)) <nl> +		vlv_wait_port_ready(dev_priv, dp_to_dig_port(intel_dp)); <nl> + <nl>  	intel_dp_sink_dpms(intel_dp, DRM_MODE_DPMS_ON); <nl>  	intel_dp_start_link_train(intel_dp); <nl>  	intel_dp_complete_link_train(intel_dp); <nl> @@ -2685,8 +2688,6 @@ static void vlv_pre_enable_dp(struct intel_encoder *encoder) <nl>  	mutex_unlock(&dev_priv->dpio_lock); <nl>   <nl>  	intel_enable_dp(encoder); <nl> - <nl> -	vlv_wait_port_ready(dev_priv, dport); <nl>  } <nl>   <nl>  static void vlv_dp_pre_pll_enable(struct intel_encoder *encoder) <nl> @@ -2779,8 +2780,6 @@ static void chv_pre_enable_dp(struct intel_encoder *encoder) <nl>  	mutex_unlock(&dev_priv->dpio_lock); <nl>   <nl>  	intel_enable_dp(encoder); <nl> - <nl> -	vlv_wait_port_ready(dev_priv, dport); <nl>  } <nl>   <nl>  static void chv_dp_pre_pll_enable(struct intel_encoder *encoder)
@@ -2164,7 +2164,9 @@ int vfs_quota_on_mount(struct super_block *sb, char *qf_name, <nl>  	struct dentry *dentry; <nl>  	int error; <nl>   <nl> +	mutex_lock(&sb->s_root->d_inode->i_mutex); <nl>  	dentry = lookup_one_len(qf_name, sb->s_root, strlen(qf_name)); <nl> +	mutex_unlock(&sb->s_root->d_inode->i_mutex); <nl>  	if (IS_ERR(dentry)) <nl>  		return PTR_ERR(dentry); <nl>  
@@ -1282,8 +1282,10 @@ static void qeth_free_qdio_buffers(struct qeth_card *card) <nl>   <nl>  	qeth_free_cq(card); <nl>  	cancel_delayed_work_sync(&card->buffer_reclaim_work); <nl> -	for (j = 0; j < QDIO_MAX_BUFFERS_PER_Q; ++j) <nl> -		dev_kfree_skb_any(card->qdio.in_q->bufs[j].rx_skb); <nl> +	for (j = 0; j < QDIO_MAX_BUFFERS_PER_Q; ++j) { <nl> +		if (card->qdio.in_q->bufs[j].rx_skb) <nl> +			dev_kfree_skb_any(card->qdio.in_q->bufs[j].rx_skb); <nl> +	} <nl>  	kfree(card->qdio.in_q); <nl>  	card->qdio.in_q = NULL; <nl>  	/* inbound buffer pool */
@@ -854,9 +854,8 @@ static int setup_blkring(struct xenbus_device *dev, <nl>  	if (err) <nl>  		goto fail; <nl>   <nl> -	err = bind_evtchn_to_irqhandler(info->evtchn, <nl> -					blkif_interrupt, <nl> -					IRQF_SAMPLE_RANDOM, "blkif", info); <nl> +	err = bind_evtchn_to_irqhandler(info->evtchn, blkif_interrupt, 0, <nl> +					"blkif", info); <nl>  	if (err <= 0) { <nl>  		xenbus_dev_fatal(dev, err, <nl>  				 "bind_evtchn_to_irqhandler failed");
@@ -200,8 +200,10 @@ static void tcp_reinit_congestion_control(struct sock *sk, <nl>  	icsk->icsk_ca_ops = ca; <nl>  	icsk->icsk_ca_setsockopt = 1; <nl>   <nl> -	if (sk->sk_state != TCP_CLOSE) <nl> +	if (sk->sk_state != TCP_CLOSE) { <nl> +		memset(icsk->icsk_ca_priv, 0, sizeof(icsk->icsk_ca_priv)); <nl>  		tcp_init_congestion_control(sk); <nl> +	} <nl>  } <nl>   <nl>  /* Manage refcounts on socket close. */
@@ -514,13 +514,13 @@ static void __kprobes resume_execution(struct kprobe *p, <nl>  		*tos = orig_rip + (*tos - copy_rip); <nl>  		break; <nl>  	case 0xff: <nl> -		if ((*insn & 0x30) == 0x10) { <nl> +		if ((insn[1] & 0x30) == 0x10) { <nl>  			/* call absolute, indirect */ <nl>  			/* Fix return addr; rip is correct. */ <nl>  			next_rip = regs->rip; <nl>  			*tos = orig_rip + (*tos - copy_rip); <nl> -		} else if (((*insn & 0x31) == 0x20) ||	/* jmp near, absolute indirect */ <nl> -			   ((*insn & 0x31) == 0x21)) {	/* jmp far, absolute indirect */ <nl> +		} else if (((insn[1] & 0x31) == 0x20) ||	/* jmp near, absolute indirect */ <nl> +			   ((insn[1] & 0x31) == 0x21)) {	/* jmp far, absolute indirect */ <nl>  			/* rip is correct. */ <nl>  			next_rip = regs->rip; <nl>  		}
@@ -3907,6 +3907,11 @@ static inline bool netif_is_lag_master(struct net_device *dev) <nl>  	return netif_is_bond_master(dev) || netif_is_team_master(dev); <nl>  } <nl>   <nl> +static inline bool netif_is_lag_port(struct net_device *dev) <nl> +{ <nl> +	return netif_is_bond_slave(dev) || netif_is_team_port(dev); <nl> +} <nl> + <nl>  /* This device needs to keep skb dst for qdisc enqueue or ndo_start_xmit() */ <nl>  static inline void netif_keep_dst(struct net_device *dev) <nl>  {
@@ -5227,10 +5227,14 @@ static int alc882_mux_enum_put(struct snd_kcontrol *kcontrol, <nl>  	const struct hda_input_mux *imux = spec->input_mux; <nl>  	unsigned int adc_idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id); <nl>  	static hda_nid_t capture_mixers[3] = { 0x24, 0x23, 0x22 }; <nl> -	hda_nid_t nid = capture_mixers[adc_idx]; <nl> +	hda_nid_t nid; <nl>  	unsigned int *cur_val = &spec->cur_mux[adc_idx]; <nl>  	unsigned int i, idx; <nl>   <nl> +	if (spec->num_adc_nids < 3) <nl> +		nid = capture_mixers[adc_idx + 1]; <nl> +	else <nl> +		nid = capture_mixers[adc_idx]; <nl>  	idx = ucontrol->value.enumerated.item[0]; <nl>  	if (idx >= imux->num_items) <nl>  		idx = imux->num_items - 1;
@@ -553,8 +553,8 @@ static int cx24123_pll_calculate(struct dvb_frontend* fe, struct dvb_frontend_pa <nl>  	ndiv = ( ((p->frequency * vco_div * 10) / (2 * XTAL / 1000)) / 32) & 0x1ff; <nl>  	adiv = ( ((p->frequency * vco_div * 10) / (2 * XTAL / 1000)) % 32) & 0x1f; <nl>   <nl> -	if (adiv == 0) <nl> -		ndiv++; <nl> +	if (adiv == 0 && ndiv > 0) <nl> +		ndiv--; <nl>   <nl>  	/* control bits 11, refdiv 11, charge pump polarity 1, charge pump current, ndiv, adiv */ <nl>  	state->pllarg = (3 << 19) | (3 << 17) | (1 << 16) | (pump << 14) | (ndiv << 5) | adiv;
@@ -478,6 +478,10 @@ static int __ext4_ext_check(const char *function, unsigned int line, <nl>  		error_msg = "invalid extent entries"; <nl>  		goto corrupted; <nl>  	} <nl> +	if (unlikely(depth > 32)) { <nl> +		error_msg = "too large eh_depth"; <nl> +		goto corrupted; <nl> +	} <nl>  	/* Verify checksum on non-root extent tree nodes */ <nl>  	if (ext_depth(inode) != depth && <nl>  	    !ext4_extent_block_csum_verify(inode, eh)) {
@@ -572,9 +572,10 @@ static void source_sink_complete (struct usb_ep *ep, struct usb_request *req) <nl>  	switch (status) { <nl>   <nl>  	case 0: 			/* normal completion? */ <nl> -		if (ep == dev->out_ep) <nl> +		if (ep == dev->out_ep) { <nl>  			check_read_data (dev, ep, req); <nl> -		else <nl> +			memset (req->buf, 0x55, req->length); <nl> +		} else <nl>  			reinit_write_data (dev, ep, req); <nl>  		break; <nl>   <nl> @@ -626,6 +627,8 @@ source_sink_start_ep (struct usb_ep *ep, gfp_t gfp_flags) <nl>   <nl>  	if (strcmp (ep->name, EP_IN_NAME) == 0) <nl>  		reinit_write_data (ep->driver_data, ep, req); <nl> +	else <nl> +		memset (req->buf, 0x55, req->length); <nl>   <nl>  	status = usb_ep_queue (ep, req, gfp_flags); <nl>  	if (status) {
@@ -1141,6 +1141,11 @@ static int __devinit r6040_init_one(struct pci_dev *pdev, <nl>  	adrp[1] = ioread16(ioaddr + MID_0M); <nl>  	adrp[2] = ioread16(ioaddr + MID_0H); <nl>   <nl> +	/* Some bootloader/BIOSes do not initialize <nl> +	 * MAC address, warn about that */ <nl> +	if (!(adrp[0] || adrp[1] || adrp[2])) <nl> +		printk(KERN_WARNING DRV_NAME ": MAC address not initialized\n"); <nl> + <nl>  	/* Link new device into r6040_root_dev */ <nl>  	lp->pdev = pdev; <nl>  	lp->dev = dev;
@@ -1503,7 +1503,7 @@ static int vidioc_reqbufs(struct file *file, void *priv, <nl>  			  struct v4l2_requestbuffers *rb) <nl>  { <nl>  	struct gspca_dev *gspca_dev = priv; <nl> -	int i, ret = 0; <nl> +	int i, ret = 0, streaming; <nl>   <nl>  	switch (rb->memory) { <nl>  	case GSPCA_MEMORY_READ:			/* (internal call) */ <nl> @@ -1538,7 +1538,8 @@ static int vidioc_reqbufs(struct file *file, void *priv, <nl>  	} <nl>   <nl>  	/* stop streaming */ <nl> -	if (gspca_dev->streaming) { <nl> +	streaming = gspca_dev->streaming; <nl> +	if (streaming) { <nl>  		mutex_lock(&gspca_dev->usb_lock); <nl>  		gspca_dev->usb_err = 0; <nl>  		gspca_stream_off(gspca_dev); <nl> @@ -1557,6 +1558,8 @@ static int vidioc_reqbufs(struct file *file, void *priv, <nl>  	if (ret == 0) { <nl>  		rb->count = gspca_dev->nframes; <nl>  		gspca_dev->capt_file = file; <nl> +		if (streaming) <nl> +			ret = gspca_init_transfer(gspca_dev); <nl>  	} <nl>  out: <nl>  	mutex_unlock(&gspca_dev->queue_lock);
@@ -729,7 +729,7 @@ static int hid_scan_report(struct hid_device *hid) <nl>  			item.type == HID_ITEM_TYPE_MAIN && <nl>  			item.tag == HID_MAIN_ITEM_TAG_BEGIN_COLLECTION && <nl>  			(item_udata(&item) & 0xff) == HID_COLLECTION_PHYSICAL && <nl> -			hid->bus == BUS_USB) <nl> +			(hid->bus == BUS_USB || hid->bus == BUS_I2C)) <nl>  			hid->group = HID_GROUP_SENSOR_HUB; <nl>  	} <nl>  
@@ -669,6 +669,15 @@ int blk_queue_enter(struct request_queue *q, bool nowait) <nl>  		if (nowait) <nl>  			return -EBUSY; <nl>   <nl> +		/* <nl> +		 * read pair of barrier in blk_mq_freeze_queue_start(), <nl> +		 * we need to order reading __PERCPU_REF_DEAD flag of <nl> +		 * .q_usage_counter and reading .mq_freeze_depth, <nl> +		 * otherwise the following wait may never return if the <nl> +		 * two reads are reordered. <nl> +		 */ <nl> +		smp_rmb(); <nl> + <nl>  		ret = wait_event_interruptible(q->mq_freeze_wq, <nl>  				!atomic_read(&q->mq_freeze_depth) || <nl>  				blk_queue_dying(q));
@@ -1353,8 +1353,9 @@ static inline struct xfrm_dst *xfrm_alloc_dst(struct net *net, int family) <nl>  	xdst = dst_alloc(dst_ops, NULL, 0, 0, 0); <nl>   <nl>  	if (likely(xdst)) { <nl> -		memset(&xdst->u.rt6.rt6i_table, 0, <nl> -			sizeof(*xdst) - sizeof(struct dst_entry)); <nl> +		struct dst_entry *dst = &xdst->u.dst; <nl> + <nl> +		memset(dst + 1, 0, sizeof(*xdst) - sizeof(*dst)); <nl>  		xdst->flo.ops = &xfrm_bundle_fc_ops; <nl>  	} else <nl>  		xdst = ERR_PTR(-ENOBUFS);
@@ -1193,6 +1193,7 @@ static struct xfrm_state * pfkey_msg2xfrm_state(struct net *net, <nl>  			x->aalg->alg_key_len = key->sadb_key_bits; <nl>  			memcpy(x->aalg->alg_key, key+1, keysize); <nl>  		} <nl> +		x->aalg->alg_trunc_len = a->uinfo.auth.icv_truncbits; <nl>  		x->props.aalgo = sa->sadb_sa_auth; <nl>  		/* x->algo.flags = sa->sadb_sa_flags; */ <nl>  	}
@@ -750,8 +750,6 @@ static int davinci_spi_bufs_dma(struct spi_device *spi, struct spi_transfer *t) <nl>   <nl>  	data1_reg_val = ioread32(davinci_spi->base + SPIDAT1); <nl>   <nl> -	INIT_COMPLETION(davinci_spi->done); <nl> - <nl>  	init_completion(&davinci_spi_dma->dma_rx_completion); <nl>  	init_completion(&davinci_spi_dma->dma_tx_completion); <nl>  
@@ -66,7 +66,7 @@ static int cache_block_group(struct btrfs_root *root, <nl>  			     struct btrfs_block_group_cache *block_group) <nl>  { <nl>  	struct btrfs_path *path; <nl> -	int ret; <nl> +	int ret = 0; <nl>  	struct btrfs_key key; <nl>  	struct extent_buffer *leaf; <nl>  	struct extent_io_tree *free_space_cache; <nl> @@ -102,10 +102,10 @@ static int cache_block_group(struct btrfs_root *root, <nl>  	btrfs_set_key_type(&key, BTRFS_EXTENT_ITEM_KEY); <nl>  	ret = btrfs_search_slot(NULL, root, &key, path, 0, 0); <nl>  	if (ret < 0) <nl> -		return ret; <nl> +		goto err; <nl>  	ret = btrfs_previous_item(root, path, 0, BTRFS_EXTENT_ITEM_KEY); <nl>  	if (ret < 0) <nl> -		return ret; <nl> +		goto err; <nl>  	if (ret == 0) { <nl>  		leaf = path->nodes[0]; <nl>  		btrfs_item_key_to_cpu(leaf, &key, path->slots[0]); <nl> @@ -161,9 +161,10 @@ next: <nl>  				 last + hole_size - 1, GFP_NOFS); <nl>  	} <nl>  	block_group->cached = 1; <nl> +	ret = 0; <nl>  err: <nl>  	btrfs_free_path(path); <nl> -	return 0; <nl> +	return ret; <nl>  } <nl>   <nl>  struct btrfs_block_group_cache *btrfs_lookup_first_block_group(struct
@@ -400,6 +400,9 @@ static int mwl8k_request_firmware(struct mwl8k_priv *priv) <nl>  	return 0; <nl>  } <nl>   <nl> +MODULE_FIRMWARE("mwl8k/helper_8687.fw"); <nl> +MODULE_FIRMWARE("mwl8k/fmimage_8687.fw"); <nl> + <nl>  struct mwl8k_cmd_pkt { <nl>  	__le16	code; <nl>  	__le16	length;
@@ -2084,7 +2084,7 @@ static long snd_seq_ioctl(struct file *file, unsigned int cmd, <nl>  { <nl>  	struct snd_seq_client *client = file->private_data; <nl>  	/* To use kernel stack for ioctl data. */ <nl> -	union ioctl_arg { <nl> +	union { <nl>  		int pversion; <nl>  		int client_id; <nl>  		struct snd_seq_system_info	system_info; <nl> @@ -2100,7 +2100,7 @@ static long snd_seq_ioctl(struct file *file, unsigned int cmd, <nl>  		struct snd_seq_client_pool	client_pool; <nl>  		struct snd_seq_remove_events	remove_events; <nl>  		struct snd_seq_query_subs	query_subs; <nl> -	} buf = {0}; <nl> +	} buf; <nl>  	const struct ioctl_handler *handler; <nl>  	unsigned long size; <nl>  	int err; <nl> @@ -2114,6 +2114,9 @@ static long snd_seq_ioctl(struct file *file, unsigned int cmd, <nl>  	} <nl>  	if (handler->cmd == 0) <nl>  		return -ENOTTY; <nl> + <nl> +	memset(&buf, 0, sizeof(buf)); <nl> + <nl>  	/* <nl>  	 * All of ioctl commands for ALSA sequencer get an argument of size <nl>  	 * within 13 bits. We can safely pick up the size from the command.
@@ -100,6 +100,7 @@ int __init irttp_init(void) <nl>  	if (!irttp->tsaps) { <nl>  		IRDA_ERROR("%s: can't allocate IrTTP hashbin!\n", <nl>  			   __FUNCTION__); <nl> +		kfree(irttp); <nl>  		return -ENOMEM; <nl>  	} <nl>  
@@ -4022,7 +4022,7 @@ out: <nl>  	return ret; <nl>  } <nl>   <nl> -static void ocfs2_split_record(struct inode *inode, <nl> +static void ocfs2_split_record(struct ocfs2_extent_tree *et, <nl>  			       struct ocfs2_path *left_path, <nl>  			       struct ocfs2_path *right_path, <nl>  			       struct ocfs2_extent_rec *split_rec, <nl> @@ -4095,7 +4095,8 @@ static void ocfs2_split_record(struct inode *inode, <nl>  	} <nl>   <nl>  	rec = &el->l_recs[index]; <nl> -	ocfs2_subtract_from_rec(inode->i_sb, split, rec, split_rec); <nl> +	ocfs2_subtract_from_rec(ocfs2_metadata_cache_get_super(et->et_ci), <nl> +				split, rec, split_rec); <nl>  	ocfs2_rotate_leaf(insert_el, split_rec); <nl>  } <nl>   <nl> @@ -4158,7 +4159,7 @@ static int ocfs2_insert_path(struct inode *inode, <nl>  		 * of splits, but it's easier to just let one separate <nl>  		 * function sort it all out. <nl>  		 */ <nl> -		ocfs2_split_record(inode, left_path, right_path, <nl> +		ocfs2_split_record(et, left_path, right_path, <nl>  				   insert_rec, insert->ins_split); <nl>   <nl>  		/*
@@ -714,7 +714,7 @@ static int audit_set_feature(struct sk_buff *skb) <nl>  		old_lock = af.lock & feature; <nl>   <nl>  		/* are we changing a locked feature? */ <nl> -		if ((af.lock & feature) && (new_feature != old_feature)) { <nl> +		if (old_lock && (new_feature != old_feature)) { <nl>  			audit_log_feature_change(i, old_feature, new_feature, <nl>  						 old_lock, new_lock, 0); <nl>  			return -EPERM;
@@ -62,6 +62,9 @@ visorchannel_create_guts(u64 physaddr, unsigned long channel_bytes, <nl>  	int err; <nl>  	size_t size = sizeof(struct channel_header); <nl>   <nl> +	if (physaddr == 0) <nl> +		return NULL; <nl> + <nl>  	channel = kzalloc(sizeof(*channel), gfp); <nl>  	if (!channel) <nl>  		goto cleanup;
@@ -55,7 +55,7 @@ nf_nat_redirect_ipv4(struct sk_buff *skb, <nl>   <nl>  		rcu_read_lock(); <nl>  		indev = __in_dev_get_rcu(skb->dev); <nl> -		if (indev != NULL) { <nl> +		if (indev && indev->ifa_list) { <nl>  			ifa = indev->ifa_list; <nl>  			newdst = ifa->ifa_local; <nl>  		}
@@ -42,6 +42,9 @@ struct intel_uncore_box *uncore_pmu_to_box(struct intel_uncore_pmu *pmu, int cpu <nl>  		return box; <nl>   <nl>  	raw_spin_lock(&uncore_box_lock); <nl> +	/* Recheck in lock to handle races. */ <nl> +	if (*per_cpu_ptr(pmu->box, cpu)) <nl> +		goto out; <nl>  	list_for_each_entry(box, &pmu->box_list, list) { <nl>  		if (box->phys_id == topology_physical_package_id(cpu)) { <nl>  			atomic_inc(&box->refcnt); <nl> @@ -49,6 +52,7 @@ struct intel_uncore_box *uncore_pmu_to_box(struct intel_uncore_pmu *pmu, int cpu <nl>  			break; <nl>  		} <nl>  	} <nl> +out: <nl>  	raw_spin_unlock(&uncore_box_lock); <nl>   <nl>  	return *per_cpu_ptr(pmu->box, cpu);
@@ -40,7 +40,11 @@ enum { <nl>   * Security-relevant compatibility flags that must be <nl>   * cleared upon setuid or setgid exec: <nl>   */ <nl> -#define PER_CLEAR_ON_SETID (READ_IMPLIES_EXEC|ADDR_NO_RANDOMIZE) <nl> +#define PER_CLEAR_ON_SETID \ <nl> +	(READ_IMPLIES_EXEC | \ <nl> +	 ADDR_NO_RANDOMIZE | \ <nl> +	 ADDR_COMPAT_LAYOUT | \ <nl> +	 MMAP_PAGE_ZERO) <nl>   <nl>  /* <nl>   * Personality types.
@@ -2174,6 +2174,10 @@ static int sh_eth_start_xmit(struct sk_buff *skb, struct net_device *ndev) <nl>  				 skb->len + 2); <nl>  	txdesc->addr = dma_map_single(&ndev->dev, skb->data, skb->len, <nl>  				      DMA_TO_DEVICE); <nl> +	if (dma_mapping_error(&ndev->dev, txdesc->addr)) { <nl> +		kfree_skb(skb); <nl> +		return NETDEV_TX_OK; <nl> +	} <nl>  	txdesc->buffer_length = skb->len; <nl>   <nl>  	if (entry >= mdp->num_tx_ring - 1)
@@ -289,6 +289,8 @@ static struct ip6_tnl *ip6_tnl_create(struct net *net, struct ip6_tnl_parm *p) <nl>  	if ((err = register_netdevice(dev)) < 0) <nl>  		goto failed_free; <nl>   <nl> +	strcpy(t->parms.name, dev->name); <nl> + <nl>  	dev_hold(dev); <nl>  	ip6_tnl_link(ip6n, t); <nl>  	return t; <nl> @@ -1407,7 +1409,6 @@ ip6_tnl_dev_init_gen(struct net_device *dev) <nl>  	struct ip6_tnl *t = netdev_priv(dev); <nl>   <nl>  	t->dev = dev; <nl> -	strcpy(t->parms.name, dev->name); <nl>  	dev->tstats = alloc_percpu(struct pcpu_tstats); <nl>  	if (!dev->tstats) <nl>  		return -ENOMEM; <nl> @@ -1487,6 +1488,7 @@ static void __net_exit ip6_tnl_destroy_tunnels(struct ip6_tnl_net *ip6n) <nl>  static int __net_init ip6_tnl_init_net(struct net *net) <nl>  { <nl>  	struct ip6_tnl_net *ip6n = net_generic(net, ip6_tnl_net_id); <nl> +	struct ip6_tnl *t = NULL; <nl>  	int err; <nl>   <nl>  	ip6n->tnls[0] = ip6n->tnls_wc; <nl> @@ -1507,6 +1509,10 @@ static int __net_init ip6_tnl_init_net(struct net *net) <nl>  	err = register_netdev(ip6n->fb_tnl_dev); <nl>  	if (err < 0) <nl>  		goto err_register; <nl> + <nl> +	t = netdev_priv(ip6n->fb_tnl_dev); <nl> + <nl> +	strcpy(t->parms.name, ip6n->fb_tnl_dev->name); <nl>  	return 0; <nl>   <nl>  err_register:
@@ -491,16 +491,16 @@ static int wm8580_paif_hw_params(struct snd_pcm_substream *substream, <nl>  		paifa |= 0x8; <nl>  		break; <nl>  	case SNDRV_PCM_FORMAT_S20_3LE: <nl> -		paifa |= 0x10; <nl> +		paifa |= 0x0; <nl>  		paifb |= WM8580_AIF_LENGTH_20; <nl>  		break; <nl>  	case SNDRV_PCM_FORMAT_S24_LE: <nl> -		paifa |= 0x10; <nl> +		paifa |= 0x0; <nl>  		paifb |= WM8580_AIF_LENGTH_24; <nl>  		break; <nl>  	case SNDRV_PCM_FORMAT_S32_LE: <nl> -		paifa |= 0x10; <nl> -		paifb |= WM8580_AIF_LENGTH_24; <nl> +		paifa |= 0x0; <nl> +		paifb |= WM8580_AIF_LENGTH_32; <nl>  		break; <nl>  	default: <nl>  		return -EINVAL;
@@ -2232,6 +2232,12 @@ static int stmmac_rx(struct stmmac_priv *priv, int limit) <nl>   <nl>  			frame_len = priv->hw->desc->get_rx_frame_len(p, coe); <nl>   <nl> +			/*  check if frame_len fits the preallocated memory */ <nl> +			if (frame_len > priv->dma_buf_sz) { <nl> +				priv->dev->stats.rx_length_errors++; <nl> +				break; <nl> +			} <nl> + <nl>  			/* ACS is set; GMAC core strips PAD/FCS for IEEE 802.3 <nl>  			 * Type frames (LLC/LLC-SNAP) <nl>  			 */
@@ -687,13 +687,14 @@ void __init smp_prepare_cpus(unsigned int max_cpus) <nl>  #ifndef CONFIG_64BIT <nl>  	if (MACHINE_HAS_IEEE) <nl>  		lowcore->extended_save_area_addr = (u32) save_area; <nl> -#else <nl> -	if (vdso_alloc_per_cpu(smp_processor_id(), lowcore)) <nl> -		BUG(); <nl>  #endif <nl>  	set_prefix((u32)(unsigned long) lowcore); <nl>  	local_mcck_enable(); <nl>  	local_irq_enable(); <nl> +#ifdef CONFIG_64BIT <nl> +	if (vdso_alloc_per_cpu(smp_processor_id(), &S390_lowcore)) <nl> +		BUG(); <nl> +#endif <nl>  	for_each_possible_cpu(cpu) <nl>  		if (cpu != smp_processor_id()) <nl>  			smp_create_idle(cpu);
@@ -1121,10 +1121,10 @@ static int bcm_char_ioctl_buffer_download_stop(void __user *argp, <nl>  static int bcm_char_ioctl_chip_reset(struct bcm_mini_adapter *ad) <nl>  { <nl>  	INT status; <nl> -	INT NVMAccess; <nl> +	INT nvm_access; <nl>   <nl> -	NVMAccess = down_trylock(&ad->NVMRdmWrmLock); <nl> -	if (NVMAccess) { <nl> +	nvm_access = down_trylock(&ad->NVMRdmWrmLock); <nl> +	if (nvm_access) { <nl>  		BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0, <nl>  			" IOCTL_BCM_CHIP_RESET not allowed as EEPROM Read/Write is in progress\n"); <nl>  		return -EACCES;
@@ -407,6 +407,9 @@ static int nf_tables_updtable(struct nft_ctx *ctx) <nl>  	if (flags & ~NFT_TABLE_F_DORMANT) <nl>  		return -EINVAL; <nl>   <nl> +	if (flags == ctx->table->flags) <nl> +		return 0; <nl> + <nl>  	trans = nft_trans_alloc(ctx, NFT_MSG_NEWTABLE, <nl>  				sizeof(struct nft_trans_table)); <nl>  	if (trans == NULL)
@@ -827,11 +827,11 @@ static void usb_alphatrack_disconnect(struct usb_interface *intf) <nl>  		mutex_unlock(&dev->mtx); <nl>  		usb_alphatrack_delete(dev); <nl>  	} else { <nl> +		atomic_set(&dev->writes_pending, 0); <nl>  		dev->intf = NULL; <nl>  		mutex_unlock(&dev->mtx); <nl>  	} <nl>   <nl> -	atomic_set(&dev->writes_pending, 0); <nl>  	mutex_unlock(&disconnect_mutex); <nl>   <nl>  	dev_info(&intf->dev, "Alphatrack Surface #%d now disconnected\n",
@@ -338,6 +338,7 @@ static int super_written(struct bio *bio, unsigned int bytes_done, int error) <nl>   <nl>  	if (atomic_dec_and_test(&rdev->mddev->pending_writes)) <nl>  		wake_up(&rdev->mddev->sb_wait); <nl> +	bio_put(bio); <nl>  	return 0; <nl>  } <nl>  
@@ -416,14 +416,6 @@ static struct pci_device_id agp_sis_pci_table[] = { <nl>  		.subvendor	= PCI_ANY_ID, <nl>  		.subdevice	= PCI_ANY_ID, <nl>  	}, <nl> -	{ <nl> -		.class		= (PCI_CLASS_BRIDGE_HOST << 8), <nl> -		.class_mask	= ~0, <nl> -		.vendor		= PCI_VENDOR_ID_SI, <nl> -		.device		= PCI_DEVICE_ID_SI_760, <nl> -		.subvendor	= PCI_ANY_ID, <nl> -		.subdevice	= PCI_ANY_ID, <nl> -	}, <nl>  	{ } <nl>  }; <nl>  
@@ -1358,12 +1358,15 @@ ctnetlink_create_conntrack(struct net *net, u16 zone, <nl>  						    nf_ct_protonum(ct)); <nl>  		if (helper == NULL) { <nl>  			rcu_read_unlock(); <nl> +			spin_unlock_bh(&nf_conntrack_lock); <nl>  #ifdef CONFIG_MODULES <nl>  			if (request_module("nfct-helper-%s", helpname) < 0) { <nl> +				spin_lock_bh(&nf_conntrack_lock); <nl>  				err = -EOPNOTSUPP; <nl>  				goto err1; <nl>  			} <nl>   <nl> +			spin_lock_bh(&nf_conntrack_lock); <nl>  			rcu_read_lock(); <nl>  			helper = __nf_conntrack_helper_find(helpname, <nl>  							    nf_ct_l3num(ct),
@@ -2029,13 +2029,12 @@ static int __devinit xgifb_probe(struct pci_dev *pdev, <nl>  		xgifb_info->hasVB = HASVB_NONE; <nl>  	} else if (xgifb_info->chip == XG21) { <nl>  		CR38 = xgifb_reg_get(XGICR, 0x38); <nl> -		if ((CR38&0xE0) == 0xC0) { <nl> +		if ((CR38&0xE0) == 0xC0) <nl>  			xgifb_info->display2 = XGIFB_DISP_LCD; <nl> -		} else if ((CR38&0xE0) == 0x60) { <nl> +		else if ((CR38&0xE0) == 0x60) <nl>  			xgifb_info->hasVB = HASVB_CHRONTEL; <nl> -		} else { <nl> +		else <nl>  			xgifb_info->hasVB = HASVB_NONE; <nl> -		} <nl>  	} else { <nl>  		XGIfb_get_VB_type(xgifb_info); <nl>  	} <nl> @@ -2139,9 +2138,6 @@ static int __devinit xgifb_probe(struct pci_dev *pdev, <nl>  					if (tmp & 0x20) { <nl>  						tmp = xgifb_reg_get( <nl>  							XGIPART1, 0x13); <nl> -						if (tmp & 0x04) { <nl> -							/* XGI_Pr.XGI_UseLCDA = 1; */ <nl> -						} <nl>  					} <nl>  				} <nl>  			}
@@ -514,6 +514,7 @@ static int read_bus_info_block(struct fw_device *device, int generation) <nl>  		return -ENOMEM; <nl>   <nl>  	stack = &rom[READ_BIB_ROM_SIZE]; <nl> +	memset(rom, 0, sizeof(*rom) * READ_BIB_ROM_SIZE); <nl>   <nl>  	device->max_speed = SCODE_100; <nl>  
@@ -452,10 +452,10 @@ one_member: <nl>  			if (finddsp->features.pcm_id == dsp->features.pcm_id) { <nl>  				if (finddsp->pcm_slot_rx >= 0 && <nl>  				    finddsp->pcm_slot_rx < sizeof(freeslots)) <nl> -					freeslots[finddsp->pcm_slot_tx] = 0; <nl> +					freeslots[finddsp->pcm_slot_rx] = 0; <nl>  				if (finddsp->pcm_slot_tx >= 0 && <nl>  				    finddsp->pcm_slot_tx < sizeof(freeslots)) <nl> -					freeslots[finddsp->pcm_slot_rx] = 0; <nl> +					freeslots[finddsp->pcm_slot_tx] = 0; <nl>  			} <nl>  		} <nl>  		i = 0;
@@ -1268,7 +1268,6 @@ out_disable_phy: <nl>  out_unregister_bus: <nl>  	phy_exit(host->generic_phy); <nl>  out_host_free: <nl> -	devm_kfree(dev, host); <nl>  	ufshcd_set_variant(hba, NULL); <nl>  out: <nl>  	return err;
@@ -674,6 +674,7 @@ int p9dirent_read(char *buf, int len, struct p9_dirent *dirent, <nl>  	} <nl>   <nl>  	strcpy(dirent->d_name, nameptr); <nl> +	kfree(nameptr); <nl>   <nl>  out: <nl>  	return fake_pdu.offset;
@@ -211,7 +211,6 @@ static int socrates_nand_probe(struct platform_device *ofdev) <nl>  	nand_release(mtd); <nl>   <nl>  out: <nl> -	dev_set_drvdata(&ofdev->dev, NULL); <nl>  	iounmap(host->io_base); <nl>  	kfree(host); <nl>  	return res; <nl> @@ -227,7 +226,6 @@ static int socrates_nand_remove(struct platform_device *ofdev) <nl>   <nl>  	nand_release(mtd); <nl>   <nl> -	dev_set_drvdata(&ofdev->dev, NULL); <nl>  	iounmap(host->io_base); <nl>  	kfree(host); <nl>  
@@ -253,6 +253,8 @@ static int ch7006_encoder_create_resources(struct drm_encoder *encoder, <nl>  	drm_mode_create_tv_properties(dev, NUM_TV_NORMS, ch7006_tv_norm_names); <nl>   <nl>  	priv->scale_property = drm_property_create_range(dev, 0, "scale", 0, 2); <nl> +	if (!priv->scale_property) <nl> +		return -ENOMEM; <nl>   <nl>  	drm_object_attach_property(&connector->base, conf->tv_select_subconnector_property, <nl>  				      priv->select_subconnector);
@@ -1585,6 +1585,7 @@ xlog_recover_add_to_trans( <nl>  		"bad number of regions (%d) in inode log format", <nl>  				  in_f->ilf_size); <nl>  			ASSERT(0); <nl> +			free(ptr); <nl>  			return XFS_ERROR(EIO); <nl>  		} <nl>  
@@ -3537,10 +3537,13 @@ EXPORT_SYMBOL_GPL(snd_soc_dapm_free); <nl>   <nl>  static void soc_dapm_shutdown_codec(struct snd_soc_dapm_context *dapm) <nl>  { <nl> +	struct snd_soc_card *card = dapm->card; <nl>  	struct snd_soc_dapm_widget *w; <nl>  	LIST_HEAD(down_list); <nl>  	int powerdown = 0; <nl>   <nl> +	mutex_lock(&card->dapm_mutex); <nl> + <nl>  	list_for_each_entry(w, &dapm->card->widgets, list) { <nl>  		if (w->dapm != dapm) <nl>  			continue; <nl> @@ -3563,6 +3566,8 @@ static void soc_dapm_shutdown_codec(struct snd_soc_dapm_context *dapm) <nl>  			snd_soc_dapm_set_bias_level(dapm, <nl>  						    SND_SOC_BIAS_STANDBY); <nl>  	} <nl> + <nl> +	mutex_unlock(&card->dapm_mutex); <nl>  } <nl>   <nl>  /*
@@ -280,9 +280,14 @@ struct rxrpc_call *rxrpc_kernel_begin_call(struct socket *sock, <nl>  	struct rxrpc_transport *trans; <nl>  	struct rxrpc_call *call; <nl>  	struct rxrpc_sock *rx = rxrpc_sk(sock->sk); <nl> +	int ret; <nl>   <nl>  	_enter(",,%x,%lx", key_serial(key), user_call_ID); <nl>   <nl> +	ret = rxrpc_validate_address(rx, srx, sizeof(*srx)); <nl> +	if (ret < 0) <nl> +		return ERR_PTR(ret); <nl> + <nl>  	lock_sock(&rx->sk); <nl>   <nl>  	if (!key)
@@ -7971,13 +7971,14 @@ static int set_block_group_ro(struct btrfs_block_group_cache *cache) <nl>   <nl>  	if (sinfo->bytes_used + sinfo->bytes_reserved + sinfo->bytes_pinned + <nl>  	    sinfo->bytes_may_use + sinfo->bytes_readonly + <nl> -	    cache->reserved_pinned + num_bytes < sinfo->total_bytes) { <nl> +	    cache->reserved_pinned + num_bytes <= sinfo->total_bytes) { <nl>  		sinfo->bytes_readonly += num_bytes; <nl>  		sinfo->bytes_reserved += cache->reserved_pinned; <nl>  		cache->reserved_pinned = 0; <nl>  		cache->ro = 1; <nl>  		ret = 0; <nl>  	} <nl> + <nl>  	spin_unlock(&cache->lock); <nl>  	spin_unlock(&sinfo->lock); <nl>  	return ret;
@@ -963,6 +963,16 @@ int cfg80211_mlme_mgmt_tx(struct cfg80211_registered_device *rdev, <nl>  			if (memcmp(mgmt->bssid, dev->dev_addr, ETH_ALEN)) <nl>  				err = -EINVAL; <nl>  			break; <nl> +		case NL80211_IFTYPE_MESH_POINT: <nl> +			if (memcmp(mgmt->sa, mgmt->bssid, ETH_ALEN)) { <nl> +				err = -EINVAL; <nl> +				break; <nl> +			} <nl> +			/* <nl> +			 * check for mesh DA must be done by driver as <nl> +			 * cfg80211 doesn't track the stations <nl> +			 */ <nl> +			break; <nl>  		default: <nl>  			err = -EOPNOTSUPP; <nl>  			break;
@@ -220,6 +220,8 @@ static int hgcm_call_preprocess_linaddr( <nl>  	if (!bounce_buf) <nl>  		return -ENOMEM; <nl>   <nl> +	*bounce_buf_ret = bounce_buf; <nl> + <nl>  	if (copy_in) { <nl>  		ret = copy_from_user(bounce_buf, (void __user *)buf, len); <nl>  		if (ret) <nl> @@ -228,7 +230,6 @@ static int hgcm_call_preprocess_linaddr( <nl>  		memset(bounce_buf, 0, len); <nl>  	} <nl>   <nl> -	*bounce_buf_ret = bounce_buf; <nl>  	hgcm_call_add_pagelist_size(bounce_buf, len, extra); <nl>  	return 0; <nl>  }
@@ -585,6 +585,7 @@ static int drm_queue_vblank_event(struct drm_device *dev, int pipe, <nl>  	if ((vblwait->request.type & _DRM_VBLANK_NEXTONMISS) && <nl>  	    (seq - vblwait->request.sequence) <= (1 << 23)) { <nl>  		vblwait->request.sequence = seq + 1; <nl> +		vblwait->reply.sequence = vblwait->request.sequence; <nl>  	} <nl>   <nl>  	DRM_DEBUG("event on vblank count %d, current %d, crtc %d\n",
@@ -4000,7 +4000,8 @@ struct net_device *alloc_netdev_mq(int sizeof_priv, const char *name, <nl>  	alloc_size = (sizeof(*dev) + NETDEV_ALIGN_CONST + <nl>  		     (sizeof(struct net_device_subqueue) * (queue_count - 1))) & <nl>  		     ~NETDEV_ALIGN_CONST; <nl> -	alloc_size += sizeof_priv + NETDEV_ALIGN_CONST; <nl> +	if (sizeof_priv) <nl> +		alloc_size += sizeof_priv + NETDEV_ALIGN_CONST; <nl>   <nl>  	p = kzalloc(alloc_size, GFP_KERNEL); <nl>  	if (!p) {
@@ -417,6 +417,11 @@ static int skl_unload_module(struct sst_dsp *ctx, u16 mod_id) <nl>  		dev_err(ctx->dev, "Module bad usage cnt!:%d\n", usage_cnt); <nl>  		return -EIO; <nl>  	} <nl> + <nl> +	/* if module is used by others return, no need to unload */ <nl> +	if (usage_cnt > 0) <nl> +		return 0; <nl> + <nl>  	ret = skl_ipc_unload_modules(&skl->ipc, <nl>  			SKL_NUM_MODULES, &mod_id); <nl>  	if (ret < 0) {
@@ -191,7 +191,7 @@ static char *res_strings[] = { <nl>  	"reserved 37", <nl>  	"reserved 38", <nl>  	"reserved 39", <nl> -	"reseverd 40", <nl> +	"reserved 40", <nl>  	"reserved 41",  <nl>  	"reserved 42",  <nl>  	"reserved 43", 
@@ -77,6 +77,7 @@ static void ax25_kill_by_device(struct net_device *dev) <nl>  { <nl>  	ax25_dev *ax25_dev; <nl>  	ax25_cb *s; <nl> +	struct sock *sk; <nl>   <nl>  	if ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL) <nl>  		return; <nl> @@ -85,13 +86,15 @@ static void ax25_kill_by_device(struct net_device *dev) <nl>  again: <nl>  	ax25_for_each(s, &ax25_list) { <nl>  		if (s->ax25_dev == ax25_dev) { <nl> +			sk = s->sk; <nl> +			sock_hold(sk); <nl>  			spin_unlock_bh(&ax25_list_lock); <nl> -			lock_sock(s->sk); <nl> +			lock_sock(sk); <nl>  			s->ax25_dev = NULL; <nl> -			release_sock(s->sk); <nl> +			release_sock(sk); <nl>  			ax25_disconnect(s, ENETUNREACH); <nl>  			spin_lock_bh(&ax25_list_lock); <nl> - <nl> +			sock_put(sk); <nl>  			/* The entry could have been deleted from the <nl>  			 * list meanwhile and thus the next pointer is <nl>  			 * no longer valid.  Play it safe and restart
@@ -614,6 +614,10 @@ static void free_pcppages_bulk(struct zone *zone, int count, <nl>  			list = &pcp->lists[migratetype]; <nl>  		} while (list_empty(list)); <nl>   <nl> +		/* This is the only non-empty list. Free them all. */ <nl> +		if (batch_free == MIGRATE_PCPTYPES) <nl> +			batch_free = to_free; <nl> + <nl>  		do { <nl>  			page = list_entry(list->prev, struct page, lru); <nl>  			/* must delete as __free_one_page list manipulates */
@@ -610,7 +610,6 @@ static struct kioctx *ioctx_alloc(unsigned nr_events) <nl>  err_cleanup: <nl>  	aio_nr_sub(ctx->max_reqs); <nl>  err: <nl> -	aio_free_ring(ctx); <nl>  	free_percpu(ctx->cpu); <nl>  	free_percpu(ctx->reqs.pcpu_count); <nl>  	free_percpu(ctx->users.pcpu_count);
@@ -55,7 +55,7 @@ static struct cpuidle_state s3c64xx_cpuidle_set[] = { <nl>  	[0] = { <nl>  		.enter			= s3c64xx_enter_idle, <nl>  		.exit_latency		= 1, <nl> -		.target_residency	= 100000, <nl> +		.target_residency	= 1, <nl>  		.flags			= CPUIDLE_FLAG_TIME_VALID, <nl>  		.name			= "IDLE", <nl>  		.desc			= "System active, ARM gated",
@@ -248,6 +248,12 @@ static int mfd_emmc_probe_slot(struct sdhci_pci_slot *slot) <nl>  	return 0; <nl>  } <nl>   <nl> +static int mfd_sdio_probe_slot(struct sdhci_pci_slot *slot) <nl> +{ <nl> +	slot->host->mmc->caps |= MMC_CAP_POWER_OFF_CARD; <nl> +	return 0; <nl> +} <nl> + <nl>  static const struct sdhci_pci_fixes sdhci_intel_mrst_hc0 = { <nl>  	.quirks		= SDHCI_QUIRK_BROKEN_ADMA | SDHCI_QUIRK_NO_HISPD_BIT, <nl>  	.probe_slot	= mrst_hc_probe_slot, <nl> @@ -266,6 +272,7 @@ static const struct sdhci_pci_fixes sdhci_intel_mfd_sd = { <nl>  static const struct sdhci_pci_fixes sdhci_intel_mfd_sdio = { <nl>  	.quirks		= SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC, <nl>  	.allow_runtime_pm = true, <nl> +	.probe_slot	= mfd_sdio_probe_slot, <nl>  }; <nl>   <nl>  static const struct sdhci_pci_fixes sdhci_intel_mfd_emmc = {
@@ -2810,6 +2810,7 @@ int BcmGetSectionValEndOffset(struct bcm_mini_adapter *Adapter, enum bcm_flash2x <nl>  	case CONTROL_SECTION: <nl>  		/* Not Clear So Putting failure. confirm and fix it. */ <nl>  		SectEndOffset = STATUS_FAILURE; <nl> +		break; <nl>  	case ISO_IMAGE1_PART2: <nl>  		if (Adapter->psFlash2xCSInfo->OffsetISOImage1Part2End != UNINIT_PTR_IN_CS) <nl>  			SectEndOffset = (Adapter->psFlash2xCSInfo->OffsetISOImage1Part2End);
@@ -572,8 +572,10 @@ static int sof_set_get_large_ctrl_data(struct snd_sof_dev *sdev, <nl>  	else <nl>  		err = sof_get_ctrl_copy_params(cdata->type, partdata, cdata, <nl>  					       sparams); <nl> -	if (err < 0) <nl> +	if (err < 0) { <nl> +		kfree(partdata); <nl>  		return err; <nl> +	} <nl>   <nl>  	msg_bytes = sparams->msg_bytes; <nl>  	pl_size = sparams->pl_size;
@@ -4828,11 +4828,20 @@ static int bond_validate(struct nlattr *tb[], struct nlattr *data[]) <nl>  	return 0; <nl>  } <nl>   <nl> +static int bond_get_tx_queues(struct net *net, struct nlattr *tb[], <nl> +			      unsigned int *num_queues, <nl> +			      unsigned int *real_num_queues) <nl> +{ <nl> +	*num_queues = tx_queues; <nl> +	return 0; <nl> +} <nl> + <nl>  static struct rtnl_link_ops bond_link_ops __read_mostly = { <nl>  	.kind		= "bond", <nl>  	.priv_size	= sizeof(struct bonding), <nl>  	.setup		= bond_setup, <nl>  	.validate	= bond_validate, <nl> +	.get_tx_queues	= bond_get_tx_queues, <nl>  }; <nl>   <nl>  /* Create a new bond based on the specified name and bonding parameters.
@@ -640,6 +640,9 @@ static struct platform_device_id armpmu_plat_device_ids[] = { <nl>   <nl>  static int __devinit armpmu_device_probe(struct platform_device *pdev) <nl>  { <nl> +	if (!cpu_pmu) <nl> +		return -ENODEV; <nl> + <nl>  	cpu_pmu->plat_device = pdev; <nl>  	return 0; <nl>  }
@@ -904,6 +904,8 @@ static int pn533_target_found(struct pn533 *dev, <nl>  	if (resp->tg != 1) <nl>  		return -EPROTO; <nl>   <nl> +	memset(&nfc_tgt, 0, sizeof(struct nfc_target)); <nl> + <nl>  	target_data_len = resp_len - sizeof(struct pn533_poll_response); <nl>   <nl>  	switch (dev->poll_mod_curr) {
@@ -381,6 +381,11 @@ static int ecryptfs_write_begin(struct file *file, <nl>  	    && (pos != 0)) <nl>  		zero_user(page, 0, PAGE_CACHE_SIZE); <nl>  out: <nl> +	if (unlikely(rc)) { <nl> +		unlock_page(page); <nl> +		page_cache_release(page); <nl> +		*pagep = NULL; <nl> +	} <nl>  	return rc; <nl>  } <nl>  
@@ -1470,12 +1470,12 @@ static int scsi_report_lun_scan(struct scsi_target *starget, int bflags, <nl>   out_err: <nl>  	kfree(lun_data); <nl>   out: <nl> -	scsi_device_put(sdev); <nl>  	if (scsi_device_created(sdev)) <nl>  		/* <nl>  		 * the sdev we used didn't appear in the report luns scan <nl>  		 */ <nl>  		__scsi_remove_device(sdev); <nl> +	scsi_device_put(sdev); <nl>  	return ret; <nl>  } <nl>  
@@ -2496,7 +2496,7 @@ ath5k_intr(int irq, void *dev_id) <nl>  			tasklet_schedule(&sc->restq); <nl>  		} else { <nl>  			if (status & AR5K_INT_SWBA) { <nl> -				tasklet_schedule(&sc->beacontq); <nl> +				tasklet_hi_schedule(&sc->beacontq); <nl>  			} <nl>  			if (status & AR5K_INT_RXEOL) { <nl>  				/*
@@ -776,7 +776,7 @@ static int init_section_ref_ok(const char *name) <nl>  		if (strncmp(*s, name, strlen(*s)) == 0) <nl>  			return 1; <nl>  	for (s = namelist3; *s; s++) <nl> -		if (strstr(*s, name) != NULL) <nl> +		if (strstr(name, *s) != NULL) <nl>  			return 1; <nl>  	return 0; <nl>  } <nl> @@ -842,7 +842,7 @@ static int exit_section_ref_ok(const char *name) <nl>  		if (strncmp(*s, name, strlen(*s)) == 0) <nl>  			return 1; <nl>  	for (s = namelist3; *s; s++) <nl> -		if (strstr(*s, name) != NULL) <nl> +		if (strstr(name, *s) != NULL) <nl>  			return 1; <nl>  	return 0; <nl>  }
@@ -163,6 +163,7 @@ static int alloc_small_queue_page(struct ipz_queue *queue, struct ehca_pd *pd) <nl>   <nl>  out: <nl>  	ehca_err(pd->ib_pd.device, "failed to allocate small queue page"); <nl> +	mutex_unlock(&pd->lock); <nl>  	return 0; <nl>  } <nl>  
@@ -646,6 +646,8 @@ static int llcp_sock_recvmsg(struct kiocb *iocb, struct socket *sock, <nl>   <nl>  	pr_debug("%p %zu\n", sk, len); <nl>   <nl> +	msg->msg_namelen = 0; <nl> + <nl>  	lock_sock(sk); <nl>   <nl>  	if (sk->sk_state == LLCP_CLOSED && <nl> @@ -691,6 +693,7 @@ static int llcp_sock_recvmsg(struct kiocb *iocb, struct socket *sock, <nl>   <nl>  		pr_debug("Datagram socket %d %d\n", ui_cb->dsap, ui_cb->ssap); <nl>   <nl> +		memset(sockaddr, 0, sizeof(*sockaddr)); <nl>  		sockaddr->sa_family = AF_NFC; <nl>  		sockaddr->nfc_protocol = NFC_PROTO_NFC_DEP; <nl>  		sockaddr->dsap = ui_cb->dsap;
@@ -1206,6 +1206,9 @@ struct ib_mr *mlx5_ib_reg_user_mr(struct ib_pd *pd, u64 start, u64 length, <nl>  	int err; <nl>  	bool use_umr = true; <nl>   <nl> +	if (!IS_ENABLED(CONFIG_INFINIBAND_USER_MEM)) <nl> +		return ERR_PTR(-EINVAL); <nl> + <nl>  	mlx5_ib_dbg(dev, "start 0x%llx, virt_addr 0x%llx, length 0x%llx, access_flags 0x%x\n", <nl>  		    start, virt_addr, length, access_flags); <nl>  
@@ -2178,6 +2178,12 @@ static int cdrom_read_cdda_bpc(struct cdrom_device_info *cdi, __u8 __user *ubuf, <nl>  	if (!q) <nl>  		return -ENXIO; <nl>   <nl> +	if (!blk_queue_scsi_passthrough(q)) { <nl> +		WARN_ONCE(true, <nl> +			  "Attempt read CDDA info through a non-SCSI queue\n"); <nl> +		return -EINVAL; <nl> +	} <nl> + <nl>  	cdi->last_sense = 0; <nl>   <nl>  	while (nframes) {
@@ -309,11 +309,14 @@ static int soc_camera_try_fmt_vid_cap(struct file *file, void *priv, <nl>  static int soc_camera_enum_input(struct file *file, void *priv, <nl>  				 struct v4l2_input *inp) <nl>  { <nl> +	struct soc_camera_device *icd = file->private_data; <nl> + <nl>  	if (inp->index != 0) <nl>  		return -EINVAL; <nl>   <nl>  	/* default is camera */ <nl>  	inp->type = V4L2_INPUT_TYPE_CAMERA; <nl> +	inp->std = icd->vdev->tvnorms; <nl>  	strcpy(inp->name, "Camera"); <nl>   <nl>  	return 0;
@@ -1668,9 +1668,8 @@ int __init pcpu_setup_first_chunk(const struct pcpu_alloc_info *ai, <nl>  	schunk->map[1] = ai->static_size; <nl>  	schunk->map_used = 1; <nl>  	if (schunk->free_size) <nl> -		schunk->map[++schunk->map_used] = 1 | (ai->static_size + schunk->free_size); <nl> -	else <nl> -		schunk->map[1] |= 1; <nl> +		schunk->map[++schunk->map_used] = ai->static_size + schunk->free_size; <nl> +	schunk->map[schunk->map_used] |= 1; <nl>   <nl>  	/* init dynamic chunk if necessary */ <nl>  	if (dyn_size) {
@@ -111,7 +111,7 @@ smb2_unlock_range(struct cifsFileInfo *cfile, struct file_lock *flock, <nl>  		return -EINVAL; <nl>   <nl>  	max_num = max_buf / sizeof(struct smb2_lock_element); <nl> -	buf = kzalloc(max_num * sizeof(struct smb2_lock_element), GFP_KERNEL); <nl> +	buf = kcalloc(max_num, sizeof(struct smb2_lock_element), GFP_KERNEL); <nl>  	if (!buf) <nl>  		return -ENOMEM; <nl>   <nl> @@ -247,7 +247,7 @@ smb2_push_mandatory_locks(struct cifsFileInfo *cfile) <nl>  	} <nl>   <nl>  	max_num = max_buf / sizeof(struct smb2_lock_element); <nl> -	buf = kzalloc(max_num * sizeof(struct smb2_lock_element), GFP_KERNEL); <nl> +	buf = kcalloc(max_num, sizeof(struct smb2_lock_element), GFP_KERNEL); <nl>  	if (!buf) { <nl>  		free_xid(xid); <nl>  		return -ENOMEM;
@@ -1158,6 +1158,7 @@ static int sh_veu_probe(struct platform_device *pdev) <nl>  	} <nl>   <nl>  	*vdev = sh_veu_videodev; <nl> +	vdev->v4l2_dev = &veu->v4l2_dev; <nl>  	spin_lock_init(&veu->lock); <nl>  	mutex_init(&veu->fop_lock); <nl>  	vdev->lock = &veu->fop_lock;
@@ -284,7 +284,7 @@ static void __munlock_pagevec(struct pagevec *pvec, struct zone *zone) <nl>  { <nl>  	int i; <nl>  	int nr = pagevec_count(pvec); <nl> -	int delta_munlocked; <nl> +	int delta_munlocked = -nr; <nl>  	struct pagevec pvec_putback; <nl>  	int pgrescued = 0; <nl>   <nl> @@ -304,6 +304,8 @@ static void __munlock_pagevec(struct pagevec *pvec, struct zone *zone) <nl>  				continue; <nl>  			else <nl>  				__munlock_isolation_failed(page); <nl> +		} else { <nl> +			delta_munlocked++; <nl>  		} <nl>   <nl>  		/* <nl> @@ -315,7 +317,6 @@ static void __munlock_pagevec(struct pagevec *pvec, struct zone *zone) <nl>  		pagevec_add(&pvec_putback, pvec->pages[i]); <nl>  		pvec->pages[i] = NULL; <nl>  	} <nl> -	delta_munlocked = -nr + pagevec_count(&pvec_putback); <nl>  	__mod_zone_page_state(zone, NR_MLOCK, delta_munlocked); <nl>  	spin_unlock_irq(zone_lru_lock(zone)); <nl>  
@@ -165,7 +165,7 @@ static ssize_t sta_ht_capa_read(struct file *file, char __user *userbuf, <nl>  	if (_cond) \ <nl>  			p += scnprintf(p, sizeof(buf)+buf-p, "\t" _str "\n"); \ <nl>  	} while (0) <nl> -	char buf[1024], *p = buf; <nl> +	char buf[512], *p = buf; <nl>  	int i; <nl>  	struct sta_info *sta = file->private_data; <nl>  	struct ieee80211_sta_ht_cap *htc = &sta->sta.ht_cap;
@@ -378,8 +378,12 @@ static int radeon_crtc_page_flip(struct drm_crtc *crtc, <nl>  	work->old_rbo = rbo; <nl>  	obj = new_radeon_fb->obj; <nl>  	rbo = gem_to_radeon_bo(obj); <nl> + <nl> +	spin_lock(&rbo->tbo.bdev->fence_lock); <nl>  	if (rbo->tbo.sync_obj) <nl>  		work->fence = radeon_fence_ref(rbo->tbo.sync_obj); <nl> +	spin_unlock(&rbo->tbo.bdev->fence_lock); <nl> + <nl>  	INIT_WORK(&work->work, radeon_unpin_work_func); <nl>   <nl>  	/* We borrow the event spin lock for protecting unpin_work */
@@ -733,7 +733,7 @@ int __init mon_text_init(void) <nl>  { <nl>  	struct dentry *mondir; <nl>   <nl> -	mondir = debugfs_create_dir("usbmon", NULL); <nl> +	mondir = debugfs_create_dir("usbmon", usb_debug_root); <nl>  	if (IS_ERR(mondir)) { <nl>  		printk(KERN_NOTICE TAG ": debugfs is not available\n"); <nl>  		return -ENODEV;
@@ -451,7 +451,11 @@ struct qmp *qmp_get(struct device *dev) <nl>   <nl>  	qmp = platform_get_drvdata(pdev); <nl>   <nl> -	return qmp ? qmp : ERR_PTR(-EPROBE_DEFER); <nl> +	if (!qmp) { <nl> +		put_device(&pdev->dev); <nl> +		return ERR_PTR(-EPROBE_DEFER); <nl> +	} <nl> +	return qmp; <nl>  } <nl>  EXPORT_SYMBOL(qmp_get); <nl>  
@@ -75,6 +75,8 @@ struct ath6kl_sdio { <nl>  #define CMD53_ARG_FIXED_ADDRESS 0 <nl>  #define CMD53_ARG_INCR_ADDRESS  1 <nl>   <nl> +static int ath6kl_sdio_config(struct ath6kl *ar); <nl> + <nl>  static inline struct ath6kl_sdio *ath6kl_sdio_priv(struct ath6kl *ar) <nl>  { <nl>  	return ar->hif_priv; <nl> @@ -526,8 +528,15 @@ static int ath6kl_sdio_power_on(struct ath6kl *ar) <nl>  	 */ <nl>  	msleep(10); <nl>   <nl> +	ret = ath6kl_sdio_config(ar); <nl> +	if (ret) { <nl> +		ath6kl_err("Failed to config sdio: %d\n", ret); <nl> +		goto out; <nl> +	} <nl> + <nl>  	ar_sdio->is_disabled = false; <nl>   <nl> +out: <nl>  	return ret; <nl>  } <nl>  
@@ -4520,6 +4520,8 @@ static const struct hda_fixup alc269_fixups[] = { <nl>  	[ALC269_FIXUP_HEADSET_MODE] = { <nl>  		.type = HDA_FIXUP_FUNC, <nl>  		.v.func = alc_fixup_headset_mode, <nl> +		.chained = true, <nl> +		.chain_id = ALC255_FIXUP_DELL_WMI_MIC_MUTE_LED <nl>  	}, <nl>  	[ALC269_FIXUP_HEADSET_MODE_NO_HP_MIC] = { <nl>  		.type = HDA_FIXUP_FUNC,
@@ -34,6 +34,13 @@ bool b43legacy_is_hw_radio_enabled(struct b43legacy_wldev *dev) <nl>  		      & B43legacy_MMIO_RADIO_HWENABLED_HI_MASK)) <nl>  			return 1; <nl>  	} else { <nl> +		/* To prevent CPU fault on PPC, do not read a register <nl> +		 * unless the interface is started; however, on resume <nl> +		 * for hibernation, this routine is entered early. When <nl> +		 * that happens, unconditionally return TRUE. <nl> +		 */ <nl> +		if (b43legacy_status(dev) < B43legacy_STAT_STARTED) <nl> +			return 1; <nl>  		if (b43legacy_read16(dev, B43legacy_MMIO_RADIO_HWENABLED_LO) <nl>  		    & B43legacy_MMIO_RADIO_HWENABLED_LO_MASK) <nl>  			return 1;
@@ -2611,7 +2611,7 @@ static int strip_open(struct tty_struct *tty) <nl>  	 * We need a write method. <nl>  	 */ <nl>   <nl> -	if (tty->ops->write == NULL) <nl> +	if (tty->ops->write == NULL || tty->ops->set_termios == NULL) <nl>  		return -EOPNOTSUPP; <nl>   <nl>  	/*
@@ -1266,6 +1266,7 @@ static void snd_timer_user_tinterrupt(struct snd_timer_instance *timeri, <nl>  	} <nl>  	if ((tu->filter & (1 << SNDRV_TIMER_EVENT_RESOLUTION)) && <nl>  	    tu->last_resolution != resolution) { <nl> +		memset(&r1, 0, sizeof(r1)); <nl>  		r1.event = SNDRV_TIMER_EVENT_RESOLUTION; <nl>  		r1.tstamp = tstamp; <nl>  		r1.val = resolution;
@@ -980,7 +980,7 @@ int tpm_open(struct inode *inode, struct file *file) <nl>  		return -EBUSY; <nl>  	} <nl>   <nl> -	chip->data_buffer = kmalloc(TPM_BUFSIZE * sizeof(u8), GFP_KERNEL); <nl> +	chip->data_buffer = kzalloc(TPM_BUFSIZE, GFP_KERNEL); <nl>  	if (chip->data_buffer == NULL) { <nl>  		clear_bit(0, &chip->is_open); <nl>  		put_device(chip->dev);
@@ -17,6 +17,7 @@ <nl>   * GNU General Public License for more details. <nl>   */ <nl>  #include <linux/module.h> <nl> +#include <linux/of.h> <nl>  #include <linux/opp.h> <nl>  #include <linux/cpu.h> <nl>   <nl> @@ -40,6 +41,9 @@ int __init omap_init_opp_table(struct omap_opp_def *opp_def, <nl>  { <nl>  	int i, r; <nl>   <nl> +	if (of_have_populated_dt()) <nl> +		return -EINVAL; <nl> + <nl>  	if (!opp_def || !opp_def_size) { <nl>  		pr_err("%s: invalid params!\n", __func__); <nl>  		return -EINVAL;
@@ -3194,6 +3194,11 @@ static int hwsim_new_radio_nl(struct sk_buff *msg, struct genl_info *info) <nl>  	if (info->attrs[HWSIM_ATTR_CHANNELS]) <nl>  		param.channels = nla_get_u32(info->attrs[HWSIM_ATTR_CHANNELS]); <nl>   <nl> +	if (param.channels < 1) { <nl> +		GENL_SET_ERR_MSG(info, "must have at least one channel"); <nl> +		return -EINVAL; <nl> +	} <nl> + <nl>  	if (param.channels > CFG80211_MAX_NUM_DIFFERENT_CHANNELS) { <nl>  		GENL_SET_ERR_MSG(info, "too many channels specified"); <nl>  		return -EINVAL;
@@ -443,6 +443,7 @@ int nfs42_proc_layoutstats_generic(struct nfs_server *server, <nl>  	task = rpc_run_task(&task_setup); <nl>  	if (IS_ERR(task)) <nl>  		return PTR_ERR(task); <nl> +	rpc_put_task(task); <nl>  	return 0; <nl>  } <nl>  
@@ -371,6 +371,7 @@ int brcmf_fweh_activate_events(struct brcmf_if *ifp) <nl>  	int i, err; <nl>  	s8 eventmask[BRCMF_EVENTING_MASK_LEN]; <nl>   <nl> +	memset(eventmask, 0, sizeof(eventmask)); <nl>  	for (i = 0; i < BRCMF_E_LAST; i++) { <nl>  		if (ifp->drvr->fweh.evt_handler[i]) { <nl>  			brcmf_dbg(EVENT, "enable event %s\n",
@@ -2049,7 +2049,7 @@ static int musb_urb_enqueue( <nl>  	 * we only have work to do in the former case. <nl>  	 */ <nl>  	spin_lock_irqsave(&musb->lock, flags); <nl> -	if (hep->hcpriv) { <nl> +	if (hep->hcpriv || !next_urb(qh)) { <nl>  		/* some concurrent activity submitted another urb to hep... <nl>  		 * odd, rare, error prone, but legal. <nl>  		 */
@@ -1857,11 +1857,10 @@ static int serial_imx_probe_dt(struct imx_port *sport, <nl>  		struct platform_device *pdev) <nl>  { <nl>  	struct device_node *np = pdev->dev.of_node; <nl> -	const struct of_device_id *of_id = <nl> -			of_match_device(imx_uart_dt_ids, &pdev->dev); <nl>  	int ret; <nl>   <nl> -	if (!np) <nl> +	sport->devdata = of_device_get_match_data(&pdev->dev); <nl> +	if (!sport->devdata) <nl>  		/* no device tree device */ <nl>  		return 1; <nl>   <nl> @@ -1878,8 +1877,6 @@ static int serial_imx_probe_dt(struct imx_port *sport, <nl>  	if (of_get_property(np, "fsl,dte-mode", NULL)) <nl>  		sport->dte_mode = 1; <nl>   <nl> -	sport->devdata = of_id->data; <nl> - <nl>  	return 0; <nl>  } <nl>  #else
@@ -1364,6 +1364,8 @@ static int ioat_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id) <nl>   <nl>  	device->version = readb(device->reg_base + IOAT_VER_OFFSET); <nl>  	if (device->version >= IOAT_VER_3_0) { <nl> +		if (is_skx_ioat(pdev)) <nl> +			device->version = IOAT_VER_3_2; <nl>  		err = ioat3_dma_probe(device, ioat_dca_enabled); <nl>   <nl>  		if (device->version >= IOAT_VER_3_3)
@@ -1723,11 +1723,13 @@ int assoc_array_gc(struct assoc_array *array, <nl>  		shortcut = assoc_array_ptr_to_shortcut(ptr); <nl>  		slot = shortcut->parent_slot; <nl>  		cursor = shortcut->back_pointer; <nl> +		if (!cursor) <nl> +			goto gc_complete; <nl>  	} else { <nl>  		slot = node->parent_slot; <nl>  		cursor = ptr; <nl>  	} <nl> -	BUG_ON(!ptr); <nl> +	BUG_ON(!cursor); <nl>  	node = assoc_array_ptr_to_node(cursor); <nl>  	slot++; <nl>  	goto continue_node;
@@ -1807,6 +1807,8 @@ static int mwifiex_pcie_event_complete(struct mwifiex_adapter *adapter, <nl>   <nl>  	if (!card->evt_buf_list[rdptr]) { <nl>  		skb_push(skb, INTF_HEADER_LEN); <nl> +		skb_put(skb, MAX_EVENT_SIZE - skb->len); <nl> +		memset(skb->data, 0, MAX_EVENT_SIZE); <nl>  		if (mwifiex_map_pci_memory(adapter, skb, <nl>  					   MAX_EVENT_SIZE, <nl>  					   PCI_DMA_FROMDEVICE))
@@ -1397,6 +1397,7 @@ static struct eg20t_port *pch_uart_init_port(struct pci_dev *pdev, <nl>  	int fifosize, base_baud; <nl>  	int port_type; <nl>  	struct pch_uart_driver_data *board; <nl> +	const char *board_name; <nl>   <nl>  	board = &drv_dat[id->driver_data]; <nl>  	port_type = board->port_type; <nl> @@ -1412,7 +1413,8 @@ static struct eg20t_port *pch_uart_init_port(struct pci_dev *pdev, <nl>  	base_baud = 1843200; /* 1.8432MHz */ <nl>   <nl>  	/* quirk for CM-iTC board */ <nl> -	if (strstr(dmi_get_system_info(DMI_BOARD_NAME), "CM-iTC")) <nl> +	board_name = dmi_get_system_info(DMI_BOARD_NAME); <nl> +	if (board_name && strstr(board_name, "CM-iTC")) <nl>  		base_baud = 192000000; /* 192.0MHz */ <nl>   <nl>  	switch (port_type) {
@@ -1402,6 +1402,10 @@ static int kill_something_info(int sig, struct siginfo *info, pid_t pid) <nl>  		return ret; <nl>  	} <nl>   <nl> +	/* -INT_MIN is undefined.  Exclude this case to avoid a UBSAN warning */ <nl> +	if (pid == INT_MIN) <nl> +		return -ESRCH; <nl> + <nl>  	read_lock(&tasklist_lock); <nl>  	if (pid != -1) { <nl>  		ret = __kill_pgrp_info(sig, info,
@@ -3150,7 +3150,7 @@ radeon_atom_is_voltage_gpio(struct radeon_device *rdev, <nl>  				break; <nl>  			case 2: <nl>  				num_indices = (size - sizeof(ATOM_COMMON_TABLE_HEADER)) / <nl> -					sizeof(ATOM_VOLTAGE_OBJECT_INFO_V2); <nl> +					sizeof(ATOM_VOLTAGE_OBJECT_V2); <nl>   <nl>  				for (i = 0; i < num_indices; i++) { <nl>  					if ((voltage_info->v2.asVoltageObj[i].ucVoltageType == voltage_type) && <nl> @@ -3231,7 +3231,7 @@ int radeon_atom_get_max_voltage(struct radeon_device *rdev, <nl>  			break; <nl>  		case 2: <nl>  			num_indices = (size - sizeof(ATOM_COMMON_TABLE_HEADER)) / <nl> -				sizeof(ATOM_VOLTAGE_OBJECT_INFO_V2); <nl> +				sizeof(ATOM_VOLTAGE_OBJECT_V2); <nl>   <nl>  			for (i = 0; i < num_indices; i++) { <nl>  				if (voltage_info->v2.asVoltageObj[i].ucVoltageType == voltage_type) { <nl> @@ -3287,7 +3287,7 @@ int radeon_atom_get_min_voltage(struct radeon_device *rdev, <nl>  			break; <nl>  		case 2: <nl>  			num_indices = (size - sizeof(ATOM_COMMON_TABLE_HEADER)) / <nl> -				sizeof(ATOM_VOLTAGE_OBJECT_INFO_V2); <nl> +				sizeof(ATOM_VOLTAGE_OBJECT_V2); <nl>   <nl>  			for (i = 0; i < num_indices; i++) { <nl>  				if (voltage_info->v2.asVoltageObj[i].ucVoltageType == voltage_type) { <nl> @@ -3406,7 +3406,7 @@ int radeon_atom_get_voltage_table(struct radeon_device *rdev, <nl>  				return -EINVAL; <nl>  			case 2: <nl>  				num_indices = (size - sizeof(ATOM_COMMON_TABLE_HEADER)) / <nl> -					sizeof(ATOM_VOLTAGE_OBJECT_INFO_V2); <nl> +					sizeof(ATOM_VOLTAGE_OBJECT_V2); <nl>   <nl>  				for (i = 0; i < num_indices; i++) { <nl>  					if (voltage_info->v2.asVoltageObj[i].ucVoltageType == voltage_type) {
@@ -7736,7 +7736,8 @@ static int remove_and_add_spares(struct mddev *mddev, <nl>  		       !test_bit(Bitmap_sync, &rdev->flags))) <nl>  			continue; <nl>   <nl> -		rdev->recovery_offset = 0; <nl> +		if (rdev->saved_raid_disk < 0) <nl> +			rdev->recovery_offset = 0; <nl>  		if (mddev->pers-> <nl>  		    hot_add_disk(mddev, rdev) == 0) { <nl>  			if (sysfs_link_rdev(mddev, rdev))
@@ -993,6 +993,7 @@ static int soc_bind_dai_link(struct snd_soc_card *card, <nl>  	struct snd_soc_dai_link_component cpu_dai_component; <nl>  	struct snd_soc_dai **codec_dais; <nl>  	struct snd_soc_platform *platform; <nl> +	struct device_node *platform_of_node; <nl>  	const char *platform_name; <nl>  	int i; <nl>   <nl> @@ -1042,9 +1043,12 @@ static int soc_bind_dai_link(struct snd_soc_card *card, <nl>   <nl>  	/* find one from the set of registered platforms */ <nl>  	list_for_each_entry(platform, &platform_list, list) { <nl> +		platform_of_node = platform->dev->of_node; <nl> +		if (!platform_of_node && platform->dev->parent->of_node) <nl> +			platform_of_node = platform->dev->parent->of_node; <nl> + <nl>  		if (dai_link->platform_of_node) { <nl> -			if (platform->dev->of_node != <nl> -			    dai_link->platform_of_node) <nl> +			if (platform_of_node != dai_link->platform_of_node) <nl>  				continue; <nl>  		} else { <nl>  			if (strcmp(platform->component.name, platform_name))
@@ -21,6 +21,7 @@ <nl>  #include <linux/blkdev.h> <nl>  #include <linux/pagemap.h> <nl>  #include <linux/export.h> <nl> +#include <linux/hid.h> <nl>  #include <asm/unaligned.h> <nl>   <nl>  #include <linux/usb/composite.h> <nl> @@ -1671,6 +1672,12 @@ static int __must_check ffs_do_desc(char *data, unsigned len, <nl>  	} <nl>  		break; <nl>   <nl> +	case HID_DT_HID: <nl> +		pr_vdebug("hid descriptor\n"); <nl> +		if (length != sizeof(struct hid_descriptor)) <nl> +			goto inv_length; <nl> +		break; <nl> + <nl>  	case USB_DT_OTG: <nl>  		if (length != sizeof(struct usb_otg_descriptor)) <nl>  			goto inv_length;
@@ -604,8 +604,13 @@ static void ath10k_hw_qca988x_set_coverage_class(struct ath10k *ar, <nl>   <nl>  	/* Only modify registers if the core is started. */ <nl>  	if ((ar->state != ATH10K_STATE_ON) && <nl> -	    (ar->state != ATH10K_STATE_RESTARTED)) <nl> +	    (ar->state != ATH10K_STATE_RESTARTED)) { <nl> +		spin_lock_bh(&ar->data_lock); <nl> +		/* Store config value for when radio boots up */ <nl> +		ar->fw_coverage.coverage_class = value; <nl> +		spin_unlock_bh(&ar->data_lock); <nl>  		goto unlock; <nl> +	} <nl>   <nl>  	/* Retrieve the current values of the two registers that need to be <nl>  	 * adjusted. <nl> @@ -637,7 +642,7 @@ static void ath10k_hw_qca988x_set_coverage_class(struct ath10k *ar, <nl>  		ar->fw_coverage.reg_ack_cts_timeout_orig = timeout_reg; <nl>  	ar->fw_coverage.reg_phyclk = phyclk_reg; <nl>   <nl> -	/* Calculat new value based on the (original) firmware calculation. */ <nl> +	/* Calculate new value based on the (original) firmware calculation. */ <nl>  	slottime_reg = ar->fw_coverage.reg_slottime_orig; <nl>  	timeout_reg = ar->fw_coverage.reg_ack_cts_timeout_orig; <nl>  
@@ -3657,8 +3657,11 @@ static u32 slic_card_locate(struct adapter *adapter) <nl>  	if (!physcard) { <nl>  		/* no structure allocated for this physical card yet */ <nl>  		physcard = kzalloc(sizeof(struct physcard), GFP_ATOMIC); <nl> -		if (!physcard) <nl> +		if (!physcard) { <nl> +			if (card_hostid == SLIC_HOSTID_DEFAULT) <nl> +				kfree(card); <nl>  			return -ENOMEM; <nl> +		} <nl>   <nl>  		physcard->next = slic_global.phys_card; <nl>  		slic_global.phys_card = physcard;
@@ -396,7 +396,6 @@ static int ipath_post_one_send(struct ipath_qp *qp, struct ib_send_wr *wr) <nl>   <nl>  	wqe = get_swqe_ptr(qp, qp->s_head); <nl>  	wqe->wr = *wr; <nl> -	wqe->ssn = qp->s_ssn++; <nl>  	wqe->length = 0; <nl>  	if (wr->num_sge) { <nl>  		acc = wr->opcode >= IB_WR_RDMA_READ ? <nl> @@ -422,6 +421,7 @@ static int ipath_post_one_send(struct ipath_qp *qp, struct ib_send_wr *wr) <nl>  			goto bail_inval; <nl>  	} else if (wqe->length > to_idev(qp->ibqp.device)->dd->ipath_ibmtu) <nl>  		goto bail_inval; <nl> +	wqe->ssn = qp->s_ssn++; <nl>  	qp->s_head = next; <nl>   <nl>  	ret = 0;
@@ -1149,6 +1149,10 @@ struct extent_buffer *read_tree_block(struct btrfs_root *root, u64 bytenr, <nl>  		return NULL; <nl>   <nl>  	ret = btree_read_extent_buffer_pages(root, buf, 0, parent_transid); <nl> +	if (ret) { <nl> +		free_extent_buffer(buf); <nl> +		return NULL; <nl> +	} <nl>  	return buf; <nl>   <nl>  }
@@ -785,6 +785,7 @@ extern struct debug_obj_descr rcuhead_debug_descr; <nl>   <nl>  static inline void debug_rcu_head_queue(struct rcu_head *head) <nl>  { <nl> +	WARN_ON_ONCE((unsigned long)head & 0x3); <nl>  	debug_object_activate(head, &rcuhead_debug_descr); <nl>  	debug_object_active_state(head, &rcuhead_debug_descr, <nl>  				  STATE_RCU_HEAD_READY,
@@ -2445,7 +2445,6 @@ static int __init omapfb_probe(struct platform_device *pdev) <nl>  	fbdev->dev = &pdev->dev; <nl>  	platform_set_drvdata(pdev, fbdev); <nl>   <nl> -	r = 0; <nl>  	fbdev->num_displays = 0; <nl>  	dssdev = NULL; <nl>  	for_each_dss_dev(dssdev) { <nl> @@ -2468,9 +2467,6 @@ static int __init omapfb_probe(struct platform_device *pdev) <nl>  			d->update_mode = OMAPFB_AUTO_UPDATE; <nl>  	} <nl>   <nl> -	if (r) <nl> -		goto cleanup; <nl> - <nl>  	if (fbdev->num_displays == 0) { <nl>  		dev_err(&pdev->dev, "no displays\n"); <nl>  		r = -EINVAL;
@@ -3407,7 +3407,7 @@ qla2x00_configure_fabric(scsi_qla_host_t *vha) <nl>  					    fcport->d_id.b.domain, <nl>  					    fcport->d_id.b.area, <nl>  					    fcport->d_id.b.al_pa); <nl> -					fcport->loop_id = FC_NO_LOOP_ID; <nl> +					qla2x00_clear_loop_id(fcport); <nl>  				} <nl>  			} <nl>  		}
@@ -690,6 +690,11 @@ int firmware_fallback_sysfs(struct firmware *fw, const char *name, <nl>  	if (!fw_run_sysfs_fallback(opt_flags)) <nl>  		return ret; <nl>   <nl> -	dev_warn(device, "Falling back to user helper\n"); <nl> +	if (!(opt_flags & FW_OPT_NO_WARN)) <nl> +		dev_warn(device, "Falling back to syfs fallback for: %s\n", <nl> +				 name); <nl> +	else <nl> +		dev_dbg(device, "Falling back to sysfs fallback for: %s\n", <nl> +				name); <nl>  	return fw_load_from_user_helper(fw, name, device, opt_flags); <nl>  }
@@ -718,7 +718,7 @@ static int gic_shared_irq_domain_map(struct irq_domain *d, unsigned int virq, <nl>   <nl>  	spin_lock_irqsave(&gic_lock, flags); <nl>  	gic_map_to_pin(intr, gic_cpu_pin); <nl> -	gic_map_to_vpe(intr, vpe); <nl> +	gic_map_to_vpe(intr, mips_cm_vp_id(vpe)); <nl>  	for (i = 0; i < min(gic_vpes, NR_CPUS); i++) <nl>  		clear_bit(intr, pcpu_masks[i].pcpu_mask); <nl>  	set_bit(intr, pcpu_masks[vpe].pcpu_mask);
@@ -207,19 +207,23 @@ static inline int __must_check wlcore_write_reg(struct wl1271 *wl, int reg, <nl>   <nl>  static inline void wl1271_power_off(struct wl1271 *wl) <nl>  { <nl> -	int ret; <nl> +	int ret = 0; <nl>   <nl>  	if (!test_bit(WL1271_FLAG_GPIO_POWER, &wl->flags)) <nl>  		return; <nl>   <nl> -	ret = wl->if_ops->power(wl->dev, false); <nl> +	if (wl->if_ops->power) <nl> +		ret = wl->if_ops->power(wl->dev, false); <nl>  	if (!ret) <nl>  		clear_bit(WL1271_FLAG_GPIO_POWER, &wl->flags); <nl>  } <nl>   <nl>  static inline int wl1271_power_on(struct wl1271 *wl) <nl>  { <nl> -	int ret = wl->if_ops->power(wl->dev, true); <nl> +	int ret = 0; <nl> + <nl> +	if (wl->if_ops->power) <nl> +		ret = wl->if_ops->power(wl->dev, true); <nl>  	if (ret == 0) <nl>  		set_bit(WL1271_FLAG_GPIO_POWER, &wl->flags); <nl>  
@@ -3428,6 +3428,10 @@ static int rndis_wlan_bind(struct usbnet *usbdev, struct usb_interface *intf) <nl>   <nl>  	/* because rndis_command() sleeps we need to use workqueue */ <nl>  	priv->workqueue = create_singlethread_workqueue("rndis_wlan"); <nl> +	if (!priv->workqueue) { <nl> +		wiphy_free(wiphy); <nl> +		return -ENOMEM; <nl> +	} <nl>  	INIT_WORK(&priv->work, rndis_wlan_worker); <nl>  	INIT_DELAYED_WORK(&priv->dev_poller_work, rndis_device_poller); <nl>  	INIT_DELAYED_WORK(&priv->scan_work, rndis_get_scan_results);
@@ -1818,6 +1818,11 @@ static int nvm_get_dir_info(struct net_device *dev, u32 *entries, u32 *length) <nl>   <nl>  static int bnxt_get_eeprom_len(struct net_device *dev) <nl>  { <nl> +	struct bnxt *bp = netdev_priv(dev); <nl> + <nl> +	if (BNXT_VF(bp)) <nl> +		return 0; <nl> + <nl>  	/* The -1 return value allows the entire 32-bit range of offsets to be <nl>  	 * passed via the ethtool command-line utility. <nl>  	 */
@@ -5000,6 +5000,8 @@ int x86_decode_insn(struct x86_emulate_ctxt *ctxt, void *insn, int insn_len) <nl>  	bool op_prefix = false; <nl>  	bool has_seg_override = false; <nl>  	struct opcode opcode; <nl> +	u16 dummy; <nl> +	struct desc_struct desc; <nl>   <nl>  	ctxt->memop.type = OP_NONE; <nl>  	ctxt->memopp = NULL; <nl> @@ -5018,6 +5020,11 @@ int x86_decode_insn(struct x86_emulate_ctxt *ctxt, void *insn, int insn_len) <nl>  	switch (mode) { <nl>  	case X86EMUL_MODE_REAL: <nl>  	case X86EMUL_MODE_VM86: <nl> +		def_op_bytes = def_ad_bytes = 2; <nl> +		ctxt->ops->get_segment(ctxt, &dummy, &desc, NULL, VCPU_SREG_CS); <nl> +		if (desc.d) <nl> +			def_op_bytes = def_ad_bytes = 4; <nl> +		break; <nl>  	case X86EMUL_MODE_PROT16: <nl>  		def_op_bytes = def_ad_bytes = 2; <nl>  		break;
@@ -2791,6 +2791,7 @@ int hugetlb_fault(struct mm_struct *mm, struct vm_area_struct *vma, <nl>  	 * so no worry about deadlock. <nl>  	 */ <nl>  	page = pte_page(entry); <nl> +	get_page(page); <nl>  	if (page != pagecache_page) <nl>  		lock_page(page); <nl>   <nl> @@ -2822,6 +2823,7 @@ int hugetlb_fault(struct mm_struct *mm, struct vm_area_struct *vma, <nl>  	} <nl>  	if (page != pagecache_page) <nl>  		unlock_page(page); <nl> +	put_page(page); <nl>   <nl>  out_mutex: <nl>  	mutex_unlock(&hugetlb_instantiation_mutex);
@@ -3399,7 +3399,7 @@ static inline void __cache_free(struct kmem_cache *cachep, void *objp, <nl>  	if (nr_online_nodes > 1 && cache_free_alien(cachep, objp)) <nl>  		return; <nl>   <nl> -	if (likely(ac->avail < ac->limit)) { <nl> +	if (ac->avail < ac->limit) { <nl>  		STATS_INC_FREEHIT(cachep); <nl>  	} else { <nl>  		STATS_INC_FREEMISS(cachep);
@@ -492,6 +492,9 @@ static struct proc_dir_entry *proc_sn2_ptc; <nl>   <nl>  static int __init sn2_ptc_init(void) <nl>  { <nl> +	if (!ia64_platform_is("sn2")) <nl> +		return -ENOSYS; <nl> + <nl>  	if (!(proc_sn2_ptc = create_proc_entry(PTC_BASENAME, 0444, NULL))) { <nl>  		printk(KERN_ERR "unable to create %s proc entry", PTC_BASENAME); <nl>  		return -EINVAL;
@@ -3037,7 +3037,9 @@ static void t3_io_resume(struct pci_dev *pdev) <nl>  	CH_ALERT(adapter, "adapter recovering, PEX ERR 0x%x\n", <nl>  		 t3_read_reg(adapter, A_PCIE_PEX_ERR)); <nl>   <nl> +	rtnl_lock(); <nl>  	t3_resume_ports(adapter); <nl> +	rtnl_unlock(); <nl>  } <nl>   <nl>  static const struct pci_error_handlers t3_err_handler = {
@@ -328,10 +328,7 @@ static unsigned long axi_clkgen_recalc_rate(struct clk_hw *clk_hw, <nl>  	tmp = (unsigned long long)(parent_rate / d) * m; <nl>  	do_div(tmp, dout); <nl>   <nl> -	if (tmp > ULONG_MAX) <nl> -		return ULONG_MAX; <nl> - <nl> -	return tmp; <nl> +	return min_t(unsigned long long, tmp, ULONG_MAX); <nl>  } <nl>   <nl>  static int axi_clkgen_enable(struct clk_hw *clk_hw)
@@ -132,7 +132,7 @@ static int ascot2e_write_regs(struct ascot2e_priv *priv, <nl>  		} <nl>  	}; <nl>   <nl> -	if (len + 1 >= sizeof(buf)) { <nl> +	if (len + 1 > sizeof(buf)) { <nl>  		dev_warn(&priv->i2c->dev,"wr reg=%04x: len=%d is too big!\n", <nl>  			 reg, len + 1); <nl>  		return -E2BIG;
@@ -2157,7 +2157,7 @@ static void process_checks(struct r1bio *r1_bio) <nl>  		struct page **ppages = get_resync_pages(pbio)->pages; <nl>  		struct page **spages = get_resync_pages(sbio)->pages; <nl>  		struct bio_vec *bi; <nl> -		int page_len[RESYNC_PAGES]; <nl> +		int page_len[RESYNC_PAGES] = { 0 }; <nl>   <nl>  		if (sbio->bi_end_io != end_sync_read) <nl>  			continue;
@@ -889,7 +889,8 @@ static int fill_inode(struct inode *inode, struct page *locked_page, <nl>  	} <nl>   <nl>  	/* finally update i_version */ <nl> -	ci->i_version = le64_to_cpu(info->version); <nl> +	if (le64_to_cpu(info->version) > ci->i_version) <nl> +		ci->i_version = le64_to_cpu(info->version); <nl>   <nl>  	inode->i_mapping->a_ops = &ceph_aops; <nl>  
@@ -1246,13 +1246,13 @@ xfs_dialloc_ag_inobt( <nl>   <nl>  			/* free inodes to the left? */ <nl>  			if (useleft && trec.ir_freecount) { <nl> -				rec = trec; <nl>  				xfs_btree_del_cursor(cur, XFS_BTREE_NOERROR); <nl>  				cur = tcur; <nl>   <nl>  				pag->pagl_leftrec = trec.ir_startino; <nl>  				pag->pagl_rightrec = rec.ir_startino; <nl>  				pag->pagl_pagino = pagino; <nl> +				rec = trec; <nl>  				goto alloc_inode; <nl>  			} <nl>  
@@ -280,7 +280,7 @@ static inline void __fsnotify_update_dcache_flags(struct dentry *dentry) <nl>  	assert_spin_locked(&dentry->d_lock); <nl>   <nl>  	parent = dentry->d_parent; <nl> -	if (fsnotify_inode_watches_children(parent->d_inode)) <nl> +	if (parent->d_inode && fsnotify_inode_watches_children(parent->d_inode)) <nl>  		dentry->d_flags |= DCACHE_FSNOTIFY_PARENT_WATCHED; <nl>  	else <nl>  		dentry->d_flags &= ~DCACHE_FSNOTIFY_PARENT_WATCHED;
@@ -896,8 +896,12 @@ bool intel_crtc_active(struct drm_crtc *crtc) <nl>  	 * <nl>  	 * We can ditch the crtc->primary->fb check as soon as we can <nl>  	 * properly reconstruct framebuffers. <nl> +	 * <nl> +	 * FIXME: The intel_crtc->active here should be switched to <nl> +	 * crtc->state->active once we have proper CRTC states wired up <nl> +	 * for atomic. <nl>  	 */ <nl> -	return intel_crtc->active && crtc->primary->fb && <nl> +	return intel_crtc->active && crtc->primary->state->fb && <nl>  		intel_crtc->config->base.adjusted_mode.crtc_clock; <nl>  } <nl>  
@@ -165,7 +165,8 @@ int io_msg_ring(struct io_kiocb *req, unsigned int issue_flags) <nl>  		req_set_fail(req); <nl>  	io_req_set_res(req, ret, 0); <nl>  	/* put file to avoid an attempt to IOPOLL the req */ <nl> -	io_put_file(req->file); <nl> +	if (!(req->flags & REQ_F_FIXED_FILE)) <nl> +		io_put_file(req->file); <nl>  	req->file = NULL; <nl>  	return IOU_OK; <nl>  }
@@ -325,6 +325,7 @@ static int lmp91000_probe(struct i2c_client *client, <nl>  	indio_dev->channels = lmp91000_channels; <nl>  	indio_dev->num_channels = ARRAY_SIZE(lmp91000_channels); <nl>  	indio_dev->name = LMP91000_DRV_NAME; <nl> +	indio_dev->dev.parent = &client->dev; <nl>  	indio_dev->modes = INDIO_DIRECT_MODE; <nl>  	i2c_set_clientdata(client, indio_dev); <nl>  
@@ -1348,6 +1348,7 @@ static inline void namespace_lock(void) <nl>  enum umount_tree_flags { <nl>  	UMOUNT_SYNC = 1, <nl>  	UMOUNT_PROPAGATE = 2, <nl> +	UMOUNT_CONNECTED = 4, <nl>  }; <nl>  /* <nl>   * mount_lock must be held <nl> @@ -1386,7 +1387,10 @@ static void umount_tree(struct mount *mnt, enum umount_tree_flags how) <nl>  		if (how & UMOUNT_SYNC) <nl>  			p->mnt.mnt_flags |= MNT_SYNC_UMOUNT; <nl>   <nl> -		disconnect = !IS_MNT_LOCKED_AND_LAZY(p); <nl> +		disconnect = !(((how & UMOUNT_CONNECTED) && <nl> +				mnt_has_parent(p) && <nl> +				(p->mnt_parent->mnt.mnt_flags & MNT_UMOUNT)) || <nl> +			       IS_MNT_LOCKED_AND_LAZY(p)); <nl>   <nl>  		pin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt, <nl>  				 disconnect ? &unmounted : NULL); <nl> @@ -1529,7 +1533,7 @@ void __detach_mounts(struct dentry *dentry) <nl>  				umount_mnt(p); <nl>  			} <nl>  		} <nl> -		else umount_tree(mnt, 0); <nl> +		else umount_tree(mnt, UMOUNT_CONNECTED); <nl>  	} <nl>  	unlock_mount_hash(); <nl>  	put_mountpoint(mp);
@@ -151,7 +151,7 @@ void kvm_check_async_pf_completion(struct kvm_vcpu *vcpu) <nl>  		spin_unlock(&vcpu->async_pf.lock); <nl>   <nl>  		kvm_arch_async_page_ready(vcpu, work); <nl> -		kvm_arch_async_page_present(vcpu, work); <nl> +		kvm_async_page_present_async(vcpu, work); <nl>   <nl>  		list_del(&work->queue); <nl>  		vcpu->async_pf.queued--;
@@ -6186,7 +6186,7 @@ static int complete_emulated_mmio(struct kvm_vcpu *vcpu) <nl>  		frag->len -= len; <nl>  	} <nl>   <nl> -	if (vcpu->mmio_cur_fragment == vcpu->mmio_nr_fragments) { <nl> +	if (vcpu->mmio_cur_fragment >= vcpu->mmio_nr_fragments) { <nl>  		vcpu->mmio_needed = 0; <nl>   <nl>  		/* FIXME: return into emulator if single-stepping.  */
@@ -659,6 +659,9 @@ struct xt_table_info *xt_alloc_table_info(unsigned int size) <nl>  	struct xt_table_info *info = NULL; <nl>  	size_t sz = sizeof(*info) + size; <nl>   <nl> +	if (sz < sizeof(*info)) <nl> +		return NULL; <nl> + <nl>  	/* Pedantry: prevent them from hitting BUG() in vmalloc.c --RR */ <nl>  	if ((SMP_ALIGN(size) >> PAGE_SHIFT) + 2 > totalram_pages) <nl>  		return NULL;
@@ -691,7 +691,8 @@ int sock_setsockopt(struct socket *sock, int level, int optname, <nl>   <nl>  	case SO_KEEPALIVE: <nl>  #ifdef CONFIG_INET <nl> -		if (sk->sk_protocol == IPPROTO_TCP) <nl> +		if (sk->sk_protocol == IPPROTO_TCP && <nl> +		    sk->sk_type == SOCK_STREAM) <nl>  			tcp_set_keepalive(sk, valbool); <nl>  #endif <nl>  		sock_valbool_flag(sk, SOCK_KEEPOPEN, valbool);
@@ -1559,6 +1559,16 @@ static struct dmi_system_id __initdata samsung_dmi_table[] = { <nl>  		}, <nl>  	 .driver_data = &samsung_broken_acpi_video, <nl>  	}, <nl> +	{ <nl> +	 .callback = samsung_dmi_matched, <nl> +	 .ident = "NC210", <nl> +	 .matches = { <nl> +		DMI_MATCH(DMI_SYS_VENDOR, "SAMSUNG ELECTRONICS CO., LTD."), <nl> +		DMI_MATCH(DMI_PRODUCT_NAME, "NC210/NC110"), <nl> +		DMI_MATCH(DMI_BOARD_NAME, "NC210/NC110"), <nl> +		}, <nl> +	 .driver_data = &samsung_broken_acpi_video, <nl> +	}, <nl>  	{ <nl>  	 .callback = samsung_dmi_matched, <nl>  	 .ident = "730U3E/740U3E",
@@ -5577,6 +5577,8 @@ void intel_display_power_get(struct drm_i915_private *dev_priv, <nl>  	struct i915_power_well *power_well; <nl>  	int i; <nl>   <nl> +	intel_runtime_pm_get(dev_priv); <nl> + <nl>  	power_domains = &dev_priv->power_domains; <nl>   <nl>  	mutex_lock(&power_domains->lock); <nl> @@ -5621,6 +5623,8 @@ void intel_display_power_put(struct drm_i915_private *dev_priv, <nl>  	} <nl>   <nl>  	mutex_unlock(&power_domains->lock); <nl> + <nl> +	intel_runtime_pm_put(dev_priv); <nl>  } <nl>   <nl>  static struct i915_power_domains *hsw_pwr;
@@ -254,7 +254,7 @@ static void rate_control_pid_tx_status(void *priv, struct net_device *dev, <nl>  	/* Ignore all frames that were sent with a different rate than the rate <nl>  	 * we currently advise mac80211 to use. */ <nl>  	if (status->control.rate != &local->oper_hw_mode->rates[sta->txrate]) <nl> -		return; <nl> +		goto ignore; <nl>   <nl>  	spinfo = sta->rate_ctrl_priv; <nl>  	spinfo->tx_num_xmit++; <nl> @@ -295,6 +295,7 @@ static void rate_control_pid_tx_status(void *priv, struct net_device *dev, <nl>  	if (time_after(jiffies, spinfo->last_sample + period)) <nl>  		rate_control_pid_sample(pinfo, local, sta); <nl>   <nl> +ignore: <nl>  	sta_info_put(sta); <nl>  } <nl>  
@@ -1358,6 +1358,10 @@ static int fuse_notify_inval_entry(struct fuse_conn *fc, unsigned int size, <nl>  	if (outarg.namelen > FUSE_NAME_MAX) <nl>  		goto err; <nl>   <nl> +	err = -EINVAL; <nl> +	if (size != sizeof(outarg) + outarg.namelen + 1) <nl> +		goto err; <nl> + <nl>  	name.name = buf; <nl>  	name.len = outarg.namelen; <nl>  	err = fuse_copy_one(cs, buf, outarg.namelen + 1);
@@ -364,8 +364,12 @@ static struct ip6_tnl *ip6_tnl_locate(struct net *net, <nl>  	     (t = rtnl_dereference(*tp)) != NULL; <nl>  	     tp = &t->next) { <nl>  		if (ipv6_addr_equal(local, &t->parms.laddr) && <nl> -		    ipv6_addr_equal(remote, &t->parms.raddr)) <nl> +		    ipv6_addr_equal(remote, &t->parms.raddr)) { <nl> +			if (create) <nl> +				return NULL; <nl> + <nl>  			return t; <nl> +		} <nl>  	} <nl>  	if (!create) <nl>  		return NULL;
@@ -230,7 +230,7 @@ int usbnet_generic_cdc_bind(struct usbnet *dev, struct usb_interface *intf) <nl>  			goto bad_desc; <nl>  	} <nl>   <nl> -	if (header.usb_cdc_ether_desc) { <nl> +	if (header.usb_cdc_ether_desc && info->ether->wMaxSegmentSize) { <nl>  		dev->hard_mtu = le16_to_cpu(info->ether->wMaxSegmentSize); <nl>  		/* because of Zaurus, we may be ignoring the host <nl>  		 * side link address we were given.
@@ -250,18 +250,18 @@ static int __devexit twl4030_audio_remove(struct platform_device *pdev) <nl>  	return 0; <nl>  } <nl>   <nl> -MODULE_ALIAS("platform:twl4030-audio"); <nl> - <nl>  static struct platform_driver twl4030_audio_driver = { <nl> -	.probe		= twl4030_audio_probe, <nl> -	.remove		= __devexit_p(twl4030_audio_remove), <nl>  	.driver		= { <nl>  		.owner	= THIS_MODULE, <nl>  		.name	= "twl4030-audio", <nl>  	}, <nl> +	.probe		= twl4030_audio_probe, <nl> +	.remove		= __devexit_p(twl4030_audio_remove), <nl>  }; <nl>   <nl>  module_platform_driver(twl4030_audio_driver); <nl>   <nl>  MODULE_AUTHOR("Peter Ujfalusi <peter.ujfalusi@ti.com>"); <nl> +MODULE_DESCRIPTION("TWL4030 audio block MFD driver"); <nl>  MODULE_LICENSE("GPL"); <nl> +MODULE_ALIAS("platform:twl4030-audio");
@@ -336,6 +336,9 @@ static void spear_smi_hw_init(struct spear_smi *dev) <nl>  	val = HOLD1 | BANK_EN | DSEL_TIME | (prescale << 8); <nl>   <nl>  	mutex_lock(&dev->lock); <nl> +	/* clear all interrupt conditions */ <nl> +	writel(0, dev->io_base + SMI_SR); <nl> + <nl>  	writel(val, dev->io_base + SMI_CR1); <nl>  	mutex_unlock(&dev->lock); <nl>  }
@@ -1321,8 +1321,9 @@ static int omap_system_dma_probe(struct platform_device *pdev) <nl>  		return -ENOMEM; <nl>   <nl>  	if (dma_omap2plus()) { <nl> -		dma_linked_lch = kzalloc(sizeof(struct dma_link_info) * <nl> -						dma_lch_count, GFP_KERNEL); <nl> +		dma_linked_lch = kcalloc(dma_lch_count, <nl> +					 sizeof(*dma_linked_lch), <nl> +					 GFP_KERNEL); <nl>  		if (!dma_linked_lch) { <nl>  			ret = -ENOMEM; <nl>  			goto exit_dma_lch_fail;
@@ -593,6 +593,7 @@ static void mcba_usb_read_bulk_callback(struct urb *urb) <nl>   <nl>  	case -ENOENT: <nl>  	case -EPIPE: <nl> +	case -EPROTO: <nl>  	case -ESHUTDOWN: <nl>  		return; <nl>  
@@ -10876,6 +10876,11 @@ static int check_vmentry_postreqs(struct kvm_vcpu *vcpu, struct vmcs12 *vmcs12, <nl>  			return 1; <nl>  	} <nl>   <nl> +	if ((vmcs12->vm_entry_controls & VM_ENTRY_LOAD_BNDCFGS) && <nl> +		(is_noncanonical_address(vmcs12->guest_bndcfgs & PAGE_MASK, vcpu) || <nl> +		(vmcs12->guest_bndcfgs & MSR_IA32_BNDCFGS_RSVD))) <nl> +			return 1; <nl> + <nl>  	return 0; <nl>  } <nl>  
@@ -490,9 +490,12 @@ wl12xx_scan_sched_scan_ssid_list(struct wl1271 *wl, <nl>  		return -ENOMEM; <nl>   <nl>  	while ((cmd->n_ssids < req->n_ssids) && ssid) { <nl> -		if (ssid->ssid_len == 0) <nl> +		if (ssid->ssid_len == 0) { <nl>  			wildcard = 1; <nl> -		cmd->ssids[cmd->n_ssids].type = SCAN_SSID_TYPE_HIDDEN; <nl> +			cmd->ssids[cmd->n_ssids].type = SCAN_SSID_TYPE_PUBLIC; <nl> +		} else { <nl> +			cmd->ssids[cmd->n_ssids].type = SCAN_SSID_TYPE_HIDDEN; <nl> +		} <nl>  		cmd->ssids[cmd->n_ssids].len = ssid->ssid_len; <nl>  		memcpy(cmd->ssids[cmd->n_ssids].ssid, ssid->ssid, <nl>  		       ssid->ssid_len);
@@ -1083,7 +1083,7 @@ static int iterate_dir_item(struct btrfs_root *root, struct btrfs_path *path, <nl>  				buf = tmp; <nl>  			} <nl>  			if (!buf) { <nl> -				buf = vmalloc(buf_len); <nl> +				buf = kvmalloc(buf_len, GFP_KERNEL); <nl>  				if (!buf) { <nl>  					ret = -ENOMEM; <nl>  					goto out;
@@ -766,6 +766,11 @@ long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen) <nl>   <nl>  	key = key_ref_to_ptr(key_ref); <nl>   <nl> +	if (test_bit(KEY_FLAG_NEGATIVE, &key->flags)) { <nl> +		ret = -ENOKEY; <nl> +		goto error2; <nl> +	} <nl> + <nl>  	/* see if we can read it directly */ <nl>  	ret = key_permission(key_ref, KEY_NEED_READ); <nl>  	if (ret == 0)
@@ -1182,6 +1182,9 @@ static int threshold_create_bank(unsigned int cpu, unsigned int bank) <nl>  	const char *name = get_name(bank, NULL); <nl>  	int err = 0; <nl>   <nl> +	if (!dev) <nl> +		return -ENODEV; <nl> + <nl>  	if (is_shared_bank(bank)) { <nl>  		nb = node_to_amd_nb(amd_get_nb_id(cpu)); <nl>  
@@ -455,7 +455,7 @@ tegra_xusb_find_port_node(struct tegra_xusb_padctl *padctl, const char *type, <nl>  	name = kasprintf(GFP_KERNEL, "%s-%u", type, index); <nl>  	if (!name) { <nl>  		of_node_put(ports); <nl> -		return ERR_PTR(-ENOMEM); <nl> +		return NULL; <nl>  	} <nl>  	np = of_get_child_by_name(ports, name); <nl>  	kfree(name);
@@ -47,7 +47,7 @@ static int sched_domain_debug_one(struct sched_domain *sd, int cpu, int level, <nl>  	if (!cpumask_test_cpu(cpu, sched_domain_span(sd))) { <nl>  		printk(KERN_ERR "ERROR: domain->span does not contain CPU%d\n", cpu); <nl>  	} <nl> -	if (!cpumask_test_cpu(cpu, sched_group_span(group))) { <nl> +	if (group && !cpumask_test_cpu(cpu, sched_group_span(group))) { <nl>  		printk(KERN_ERR "ERROR: domain->groups does not contain CPU%d\n", cpu); <nl>  	} <nl>  
@@ -430,8 +430,10 @@ static int snd_sst_fill_kernel_list(struct stream_info *stream, <nl>  				return -ENOMEM; <nl>  			if (copy_from_user((void *) &rar_handle, <nl>  					iovec[index].iov_base, <nl> -					sizeof(__u32))) <nl> +					sizeof(__u32))) { <nl> +				kfree(stream_bufs); <nl>  				return -EFAULT; <nl> +			} <nl>  			stream_bufs->addr = (char *)rar_handle; <nl>  			stream_bufs->in_use = false; <nl>  			stream_bufs->size = iovec[0].iov_len;
@@ -1502,6 +1502,12 @@ void i40e_fcoe_config_netdev(struct net_device *netdev, struct i40e_vsi *vsi) <nl>  	strlcpy(netdev->name, "fcoe%d", IFNAMSIZ-1); <nl>  	netdev->mtu = FCOE_MTU; <nl>  	SET_NETDEV_DEV(netdev, &pf->pdev->dev); <nl> +	/* set different dev_port value 1 for FCoE netdev than the default <nl> +	 * zero dev_port value for PF netdev, this helps biosdevname user <nl> +	 * tool to differentiate them correctly while both attached to the <nl> +	 * same PCI function. <nl> +	 */ <nl> +	netdev->dev_port = 1; <nl>  	i40e_add_filter(vsi, hw->mac.san_addr, 0, false, false); <nl>  	i40e_add_filter(vsi, (u8[6]) FC_FCOE_FLOGI_MAC, 0, false, false); <nl>  	i40e_add_filter(vsi, FIP_ALL_FCOE_MACS, 0, false, false);
@@ -1374,7 +1374,7 @@ struct task_struct { <nl>  	int exit_state; <nl>  	int exit_code, exit_signal; <nl>  	int pdeath_signal;  /*  The signal sent when the parent dies  */ <nl> -	unsigned int jobctl;	/* JOBCTL_*, siglock protected */ <nl> +	unsigned long jobctl;	/* JOBCTL_*, siglock protected */ <nl>   <nl>  	/* Used for emulating ABI behavior of previous Linux versions */ <nl>  	unsigned int personality;
@@ -1149,7 +1149,7 @@ static int davinci_mcasp_startup(struct snd_pcm_substream *substream, <nl>  		if (mcasp->serial_dir[i] == dir) <nl>  			max_channels++; <nl>  	} <nl> -	mcasp->ruledata[dir].serializers = max_channels; <nl> +	mcasp->ruledata[substream->stream].serializers = max_channels; <nl>  	max_channels *= mcasp->tdm_slots; <nl>  	/* <nl>  	 * If the already active stream has less channels than the calculated <nl> @@ -1172,7 +1172,7 @@ static int davinci_mcasp_startup(struct snd_pcm_substream *substream, <nl>  	if (mcasp->bclk_master && mcasp->bclk_div == 0 && mcasp->sysclk_freq) { <nl>  		int ret; <nl>   <nl> -		mcasp->ruledata[dir].mcasp = mcasp; <nl> +		mcasp->ruledata[substream->stream].mcasp = mcasp; <nl>   <nl>  		ret = snd_pcm_hw_rule_add(substream->runtime, 0, <nl>  					  SNDRV_PCM_HW_PARAM_RATE,
@@ -1364,18 +1364,18 @@ unsigned int vb2_poll(struct vb2_queue *q, struct file *file, poll_table *wait) <nl>  	struct vb2_buffer *vb = NULL; <nl>   <nl>  	/* <nl> -	 * Start file io emulator if streaming api has not been used yet. <nl> +	 * Start file I/O emulator only if streaming API has not been used yet. <nl>  	 */ <nl>  	if (q->num_buffers == 0 && q->fileio == NULL) { <nl>  		if (!V4L2_TYPE_IS_OUTPUT(q->type) && (q->io_modes & VB2_READ)) { <nl>  			ret = __vb2_init_fileio(q, 1); <nl>  			if (ret) <nl> -				return ret; <nl> +				return POLLERR; <nl>  		} <nl>  		if (V4L2_TYPE_IS_OUTPUT(q->type) && (q->io_modes & VB2_WRITE)) { <nl>  			ret = __vb2_init_fileio(q, 0); <nl>  			if (ret) <nl> -				return ret; <nl> +				return POLLERR; <nl>  			/* <nl>  			 * Write to OUTPUT queue can be done immediately. <nl>  			 */
@@ -1298,6 +1298,10 @@ int iwl_mvm_sched_scan_start(struct iwl_mvm *mvm, <nl>  		return -EBUSY; <nl>  	} <nl>   <nl> +	/* we don't support "match all" in the firmware */ <nl> +	if (!req->n_match_sets) <nl> +		return -EOPNOTSUPP; <nl> + <nl>  	ret = iwl_mvm_check_running_scans(mvm, type); <nl>  	if (ret) <nl>  		return ret;
@@ -308,7 +308,7 @@ static int __cmd_record(struct record *rec, int argc, const char **argv) <nl>  	struct record_opts *opts = &rec->opts; <nl>  	struct perf_data_file *file = &rec->file; <nl>  	struct perf_session *session; <nl> -	bool disabled = false; <nl> +	bool disabled = false, draining = false; <nl>   <nl>  	rec->progname = argv[0]; <nl>   <nl> @@ -457,7 +457,7 @@ static int __cmd_record(struct record *rec, int argc, const char **argv) <nl>  		} <nl>   <nl>  		if (hits == rec->samples) { <nl> -			if (done) <nl> +			if (done || draining) <nl>  				break; <nl>  			err = perf_evlist__poll(rec->evlist, -1); <nl>  			/* <nl> @@ -467,6 +467,9 @@ static int __cmd_record(struct record *rec, int argc, const char **argv) <nl>  			if (err > 0 || (err < 0 && errno == EINTR)) <nl>  				err = 0; <nl>  			waking++; <nl> + <nl> +			if (perf_evlist__filter_pollfd(rec->evlist, POLLERR | POLLHUP) == 0) <nl> +				draining = true; <nl>  		} <nl>   <nl>  		/*
@@ -514,6 +514,10 @@ static void command_port_read_callback(struct urb *urb) <nl>  		dev_dbg(&urb->dev->dev, "%s - command_info is NULL, exiting.\n", __func__); <nl>  		return; <nl>  	} <nl> +	if (!urb->actual_length) { <nl> +		dev_dbg(&urb->dev->dev, "%s - empty response, exiting.\n", __func__); <nl> +		return; <nl> +	} <nl>  	if (status) { <nl>  		dev_dbg(&urb->dev->dev, "%s - nonzero urb status: %d\n", __func__, status); <nl>  		if (status != -ENOENT) <nl> @@ -534,7 +538,8 @@ static void command_port_read_callback(struct urb *urb) <nl>  		/* These are unsolicited reports from the firmware, hence no <nl>  		   waiting command to wakeup */ <nl>  		dev_dbg(&urb->dev->dev, "%s - event received\n", __func__); <nl> -	} else if (data[0] == WHITEHEAT_GET_DTR_RTS) { <nl> +	} else if ((data[0] == WHITEHEAT_GET_DTR_RTS) && <nl> +		(urb->actual_length - 1 <= sizeof(command_info->result_buffer))) { <nl>  		memcpy(command_info->result_buffer, &data[1], <nl>  						urb->actual_length - 1); <nl>  		command_info->command_finished = WHITEHEAT_CMD_COMPLETE;
@@ -911,7 +911,7 @@ static netdev_tx_t ip6erspan_tunnel_xmit(struct sk_buff *skb, <nl>  		truncate = true; <nl>  	} <nl>   <nl> -	if (skb_cow_head(skb, dev->needed_headroom)) <nl> +	if (skb_cow_head(skb, dev->needed_headroom ?: t->hlen)) <nl>  		goto tx_err; <nl>   <nl>  	t->parms.o_flags &= ~TUNNEL_KEY;
@@ -142,12 +142,6 @@ static int omninet_port_remove(struct usb_serial_port *port) <nl>   <nl>  static int omninet_open(struct tty_struct *tty, struct usb_serial_port *port) <nl>  { <nl> -	struct usb_serial	*serial = port->serial; <nl> -	struct usb_serial_port	*wport; <nl> - <nl> -	wport = serial->port[1]; <nl> -	tty_port_tty_set(&wport->port, tty); <nl> - <nl>  	return usb_serial_generic_open(tty, port); <nl>  } <nl>  
@@ -140,7 +140,8 @@ struct xc4000_priv { <nl>   <nl>  /* Product id */ <nl>  #define XC_PRODUCT_ID_FW_NOT_LOADED	0x2000 <nl> -#define XC_PRODUCT_ID_FW_LOADED	0x0FA0 <nl> +#define XC_PRODUCT_ID_XC4000		0x0FA0 <nl> +#define XC_PRODUCT_ID_XC4100		0x1004 <nl>   <nl>  /* Registers (Write-only) */ <nl>  #define XREG_INIT         0x00 <nl> @@ -1071,7 +1072,9 @@ static int check_firmware(struct dvb_frontend *fe, unsigned int type, <nl>  #endif <nl>   <nl>  	/* Check that the tuner hardware model remains consistent over time. */ <nl> -	if (priv->hwmodel == 0 && hwmodel == 4000) { <nl> +	if (priv->hwmodel == 0 && <nl> +	    (hwmodel == XC_PRODUCT_ID_XC4000 || <nl> +	     hwmodel == XC_PRODUCT_ID_XC4100)) { <nl>  		priv->hwmodel = hwmodel; <nl>  		priv->hwvers  = version & 0xff00; <nl>  	} else if (priv->hwmodel == 0 || priv->hwmodel != hwmodel || <nl> @@ -1678,7 +1681,8 @@ struct dvb_frontend *xc4000_attach(struct dvb_frontend *fe, <nl>  	} <nl>   <nl>  	switch (id) { <nl> -	case XC_PRODUCT_ID_FW_LOADED: <nl> +	case XC_PRODUCT_ID_XC4000: <nl> +	case XC_PRODUCT_ID_XC4100: <nl>  		printk(KERN_INFO <nl>  			"xc4000: Successfully identified at address 0x%02x\n", <nl>  			cfg->i2c_address);
@@ -1365,11 +1365,6 @@ static int init_fb_chan(struct mx3fb_data *mx3fb, struct idmac_channel *ichan) <nl>  	init_completion(&mx3fbi->flip_cmpl); <nl>  	disable_irq(ichan->eof_irq); <nl>  	dev_dbg(mx3fb->dev, "disabling irq %d\n", ichan->eof_irq); <nl> -	ret = mx3fb_set_par(fbi); <nl> -	if (ret < 0) <nl> -		goto esetpar; <nl> - <nl> -	mx3fb_blank(FB_BLANK_UNBLANK, fbi); <nl>   <nl>  	dev_info(dev, "registered, using mode %s\n", fb_mode); <nl>  
@@ -683,7 +683,7 @@ static int ath10k_sdio_mbox_rxmsg_pending_handler(struct ath10k *ar, <nl>  	lookaheads[0] = msg_lookahead; <nl>   <nl>  	timeout = jiffies + SDIO_MBOX_PROCESSING_TIMEOUT_HZ; <nl> -	while (time_before(jiffies, timeout)) { <nl> +	do { <nl>  		/* Try to allocate as many HTC RX packets indicated by <nl>  		 * n_lookaheads. <nl>  		 */ <nl> @@ -719,7 +719,7 @@ static int ath10k_sdio_mbox_rxmsg_pending_handler(struct ath10k *ar, <nl>  		 * performance in high throughput situations. <nl>  		 */ <nl>  		*done = false; <nl> -	} <nl> +	} while (time_before(jiffies, timeout)); <nl>   <nl>  	if (ret && (ret != -ECANCELED)) <nl>  		ath10k_warn(ar, "failed to get pending recv messages: %d\n", <nl> @@ -1336,11 +1336,11 @@ static void ath10k_sdio_irq_handler(struct sdio_func *func) <nl>  	sdio_release_host(ar_sdio->func); <nl>   <nl>  	timeout = jiffies + ATH10K_SDIO_HIF_COMMUNICATION_TIMEOUT_HZ; <nl> -	while (time_before(jiffies, timeout) && !done) { <nl> +	do { <nl>  		ret = ath10k_sdio_mbox_proc_pending_irqs(ar, &done); <nl>  		if (ret) <nl>  			break; <nl> -	} <nl> +	} while (time_before(jiffies, timeout) && !done); <nl>   <nl>  	sdio_claim_host(ar_sdio->func); <nl>  
@@ -1655,6 +1655,7 @@ static int dump_holder(struct seq_file *seq, const struct gfs2_holder *gh) <nl>  	struct task_struct *gh_owner = NULL; <nl>  	char flags_buf[32]; <nl>   <nl> +	rcu_read_lock(); <nl>  	if (gh->gh_owner_pid) <nl>  		gh_owner = pid_task(gh->gh_owner_pid, PIDTYPE_PID); <nl>  	gfs2_print_dbg(seq, " H: s:%s f:%s e:%d p:%ld [%s] %pS\n", <nl> @@ -1664,6 +1665,7 @@ static int dump_holder(struct seq_file *seq, const struct gfs2_holder *gh) <nl>  		       gh->gh_owner_pid ? (long)pid_nr(gh->gh_owner_pid) : -1, <nl>  		       gh_owner ? gh_owner->comm : "(ended)", <nl>  		       (void *)gh->gh_ip); <nl> +	rcu_read_unlock(); <nl>  	return 0; <nl>  } <nl>  
@@ -829,7 +829,6 @@ static int fsl_elbc_chip_remove(struct fsl_elbc_mtd *priv) <nl>   <nl>  	elbc_fcm_ctrl->chips[priv->bank] = NULL; <nl>  	kfree(priv); <nl> -	kfree(elbc_fcm_ctrl); <nl>  	return 0; <nl>  } <nl>  
@@ -210,9 +210,8 @@ int asn1_ber_decoder(const struct asn1_decoder *decoder, <nl>  		unsigned char tmp; <nl>   <nl>  		/* Skip conditional matches if possible */ <nl> -		if ((op & ASN1_OP_MATCH__COND && <nl> -		     flags & FLAG_MATCHED) || <nl> -		    dp == datalen) { <nl> +		if ((op & ASN1_OP_MATCH__COND && flags & FLAG_MATCHED) || <nl> +		    (op & ASN1_OP_MATCH__SKIP && dp == datalen)) { <nl>  			flags &= ~FLAG_LAST_MATCHED; <nl>  			pc += asn1_op_lengths[op]; <nl>  			goto next_op;
@@ -780,9 +780,11 @@ static bool tg_may_dispatch(struct throtl_grp *tg, struct bio *bio, <nl>  	/* <nl>  	 * If previous slice expired, start a new one otherwise renew/extend <nl>  	 * existing slice to make sure it is at least throtl_slice interval <nl> -	 * long since now. <nl> +	 * long since now. New slice is started only for empty throttle group. <nl> +	 * If there is queued bio, that means there should be an active <nl> +	 * slice and it should be extended instead. <nl>  	 */ <nl> -	if (throtl_slice_used(tg, rw)) <nl> +	if (throtl_slice_used(tg, rw) && !(tg->service_queue.nr_queued[rw])) <nl>  		throtl_start_new_slice(tg, rw); <nl>  	else { <nl>  		if (time_before(tg->slice_end[rw], jiffies + throtl_slice))
@@ -210,6 +210,7 @@ static ssize_t wait_for_direct_io(enum ORANGEFS_io_type type, struct inode *inod <nl>  	 */ <nl>  	if (ret == -EAGAIN && op_state_purged(new_op)) { <nl>  		orangefs_bufmap_put(bufmap, buffer_index); <nl> +		buffer_index = -1; <nl>  		gossip_debug(GOSSIP_FILE_DEBUG, <nl>  			     "%s:going to repopulate_shared_memory.\n", <nl>  			     __func__);
@@ -30,7 +30,7 @@ void *ion_heap_map_kernel(struct ion_heap *heap, <nl>  	struct page **tmp = pages; <nl>   <nl>  	if (!pages) <nl> -		return NULL; <nl> +		return ERR_PTR(-ENOMEM); <nl>   <nl>  	if (buffer->flags & ION_FLAG_CACHED) <nl>  		pgprot = PAGE_KERNEL;
@@ -402,9 +402,9 @@ MODULE_FIRMWARE("digiface_firmware_rev11.bin"); <nl>  #define HDSP_DMA_AREA_BYTES ((HDSP_MAX_CHANNELS+1) * HDSP_CHANNEL_BUFFER_BYTES) <nl>  #define HDSP_DMA_AREA_KILOBYTES (HDSP_DMA_AREA_BYTES/1024) <nl>   <nl> -/* use hotplug firmeare loader? */ <nl> +/* use hotplug firmware loader? */ <nl>  #if defined(CONFIG_FW_LOADER) || defined(CONFIG_FW_LOADER_MODULE) <nl> -#if !defined(HDSP_USE_HWDEP_LOADER) && !defined(CONFIG_SND_HDSP) <nl> +#if !defined(HDSP_USE_HWDEP_LOADER) <nl>  #define HDSP_FW_LOADER <nl>  #endif <nl>  #endif
@@ -789,8 +789,9 @@ static int create_queue_cpsch(struct device_queue_manager *dqm, struct queue *q, <nl>  	return retval; <nl>  } <nl>   <nl> -int fence_wait_timeout(unsigned int *fence_addr, unsigned int fence_value, <nl> -			unsigned long timeout) <nl> +static int fence_wait_timeout(unsigned int *fence_addr, <nl> +				unsigned int fence_value, <nl> +				unsigned long timeout) <nl>  { <nl>  	BUG_ON(!fence_addr); <nl>  	timeout += jiffies;
@@ -1131,6 +1131,9 @@ void compact_pgdat(pg_data_t *pgdat, int order) <nl>  		.sync = false, <nl>  	}; <nl>   <nl> +	if (!order) <nl> +		return; <nl> + <nl>  	__compact_pgdat(pgdat, &cc); <nl>  } <nl>  
@@ -247,6 +247,7 @@ get_futex_key(u32 __user *uaddr, int fshared, union futex_key *key, int rw) <nl>  	if (err < 0) <nl>  		return err; <nl>   <nl> +	page = compound_head(page); <nl>  	lock_page(page); <nl>  	if (!page->mapping) { <nl>  		unlock_page(page);
@@ -1678,7 +1678,8 @@ static void imon_incoming_packet(struct imon_context *ictx, <nl>  		if (press_type == 0) <nl>  			rc_keyup(ictx->rdev); <nl>  		else { <nl> -			if (ictx->rc_type == RC_BIT_RC6_MCE) <nl> +			if (ictx->rc_type == RC_BIT_RC6_MCE || <nl> +			    ictx->rc_type == RC_BIT_OTHER) <nl>  				rc_keydown(ictx->rdev, <nl>  					   ictx->rc_type == RC_BIT_RC6_MCE ? RC_TYPE_RC6_MCE : RC_TYPE_OTHER, <nl>  					   ictx->rc_scancode, ictx->rc_toggle);
@@ -381,7 +381,7 @@ static void wl3501_free_tx_buffer(struct wl3501_card *this, u16 ptr) <nl>   <nl>  static int wl3501_esbq_req_test(struct wl3501_card *this) <nl>  { <nl> -	u8 tmp; <nl> +	u8 tmp = 0; <nl>   <nl>  	wl3501_get_from_wla(this, this->esbq_req_head + 3, &tmp, sizeof(tmp)); <nl>  	return tmp & 0x80;
@@ -158,14 +158,20 @@ static struct console udbg_console = { <nl>  	.index	= -1, <nl>  }; <nl>   <nl> +static int early_console_initialized; <nl> + <nl>  void __init disable_early_printk(void) <nl>  { <nl> +	if (!early_console_initialized) <nl> +		return; <nl>  	unregister_console(&udbg_console); <nl> +	early_console_initialized = 0; <nl>  } <nl>   <nl>  /* called by setup_system */ <nl>  void register_early_udbg_console(void) <nl>  { <nl> +	early_console_initialized = 1; <nl>  	register_console(&udbg_console); <nl>  } <nl>  
@@ -1819,7 +1819,8 @@ int __init ap_module_init(void) <nl>  	if (ap_domain_index < -1 || ap_domain_index > max_domain_id) { <nl>  		pr_warn("%d is not a valid cryptographic domain\n", <nl>  			ap_domain_index); <nl> -		return -EINVAL; <nl> +		rc = -EINVAL; <nl> +		goto out_free; <nl>  	} <nl>  	/* In resume callback we need to know if the user had set the domain. <nl>  	 * If so, we can not just reset it. <nl> @@ -1892,6 +1893,7 @@ int __init ap_module_init(void) <nl>  	unregister_reset_call(&ap_reset_call); <nl>  	if (ap_using_interrupts()) <nl>  		unregister_adapter_interrupt(&ap_airq); <nl> +out_free: <nl>  	kfree(ap_configuration); <nl>  	return rc; <nl>  }
@@ -854,7 +854,7 @@ void tsl2x7x_prox_calculate(int *data, int length, <nl>  		tmp = data[i] - statP->mean; <nl>  		sample_sum += tmp * tmp; <nl>  	} <nl> -	statP->stddev = int_sqrt((long)sample_sum)/length; <nl> +	statP->stddev = int_sqrt((long)sample_sum) / length; <nl>  } <nl>   <nl>  /** <nl> @@ -1192,7 +1192,7 @@ static ssize_t tsl2x7x_luxtable_store(struct device *dev, <nl>  { <nl>  	struct iio_dev *indio_dev = dev_to_iio_dev(dev); <nl>  	struct tsl2X7X_chip *chip = iio_priv(indio_dev); <nl> -	int value[ARRAY_SIZE(chip->tsl2x7x_device_lux)*3 + 1]; <nl> +	int value[ARRAY_SIZE(chip->tsl2x7x_device_lux) * 3 + 1]; <nl>  	int n; <nl>   <nl>  	get_options(buf, ARRAY_SIZE(value), value);
@@ -681,8 +681,8 @@ static int gfar_of_init(struct of_device *ofdev, struct net_device **pdev) <nl>  		priv->rx_queue[i] = NULL; <nl>   <nl>  	for (i = 0; i < priv->num_tx_queues; i++) { <nl> -		priv->tx_queue[i] =  (struct gfar_priv_tx_q *)kzalloc( <nl> -				sizeof (struct gfar_priv_tx_q), GFP_KERNEL); <nl> +		priv->tx_queue[i] = kzalloc(sizeof(struct gfar_priv_tx_q), <nl> +					    GFP_KERNEL); <nl>  		if (!priv->tx_queue[i]) { <nl>  			err = -ENOMEM; <nl>  			goto tx_alloc_failed; <nl> @@ -694,8 +694,8 @@ static int gfar_of_init(struct of_device *ofdev, struct net_device **pdev) <nl>  	} <nl>   <nl>  	for (i = 0; i < priv->num_rx_queues; i++) { <nl> -		priv->rx_queue[i] = (struct gfar_priv_rx_q *)kzalloc( <nl> -					sizeof (struct gfar_priv_rx_q), GFP_KERNEL); <nl> +		priv->rx_queue[i] = kzalloc(sizeof(struct gfar_priv_rx_q), <nl> +					    GFP_KERNEL); <nl>  		if (!priv->rx_queue[i]) { <nl>  			err = -ENOMEM; <nl>  			goto rx_alloc_failed;
@@ -435,8 +435,14 @@ xfs_attr_inactive( <nl>  	 */ <nl>  	xfs_trans_ijoin(trans, dp, 0); <nl>   <nl> -	/* invalidate and truncate the attribute fork extents */ <nl> -	if (dp->i_d.di_aformat != XFS_DINODE_FMT_LOCAL) { <nl> +	/* <nl> +	 * Invalidate and truncate the attribute fork extents. Make sure the <nl> +	 * fork actually has attributes as otherwise the invalidation has no <nl> +	 * blocks to read and returns an error. In this case, just do the fork <nl> +	 * removal below. <nl> +	 */ <nl> +	if (xfs_inode_hasattr(dp) && <nl> +	    dp->i_d.di_aformat != XFS_DINODE_FMT_LOCAL) { <nl>  		error = xfs_attr3_root_inactive(&trans, dp); <nl>  		if (error) <nl>  			goto out_cancel;
@@ -1702,6 +1702,8 @@ SYSCALL_DEFINE6(sendto, int, fd, void __user *, buff, size_t, len, <nl>   <nl>  	if (len > INT_MAX) <nl>  		len = INT_MAX; <nl> +	if (unlikely(!access_ok(VERIFY_READ, buff, len))) <nl> +		return -EFAULT; <nl>  	sock = sockfd_lookup_light(fd, &err, &fput_needed); <nl>  	if (!sock) <nl>  		goto out; <nl> @@ -1760,6 +1762,8 @@ SYSCALL_DEFINE6(recvfrom, int, fd, void __user *, ubuf, size_t, size, <nl>   <nl>  	if (size > INT_MAX) <nl>  		size = INT_MAX; <nl> +	if (unlikely(!access_ok(VERIFY_WRITE, ubuf, size))) <nl> +		return -EFAULT; <nl>  	sock = sockfd_lookup_light(fd, &err, &fput_needed); <nl>  	if (!sock) <nl>  		goto out;
@@ -341,7 +341,7 @@ int fix_alignment(struct pt_regs *regs) <nl>   <nl>  	type = op.type & INSTR_TYPE_MASK; <nl>  	if (!OP_IS_LOAD_STORE(type)) { <nl> -		if (type != CACHEOP + DCBZ) <nl> +		if (op.type != CACHEOP + DCBZ) <nl>  			return -EINVAL; <nl>  		PPC_WARN_ALIGNMENT(dcbz, regs); <nl>  		r = emulate_dcbz(op.ea, regs);
@@ -878,7 +878,7 @@ static int ieee80211_fragment(struct ieee80211_tx_data *tx, <nl>  	} <nl>   <nl>  	/* adjust first fragment's length */ <nl> -	skb->len = hdrlen + per_fragm; <nl> +	skb_trim(skb, hdrlen + per_fragm); <nl>  	return 0; <nl>  } <nl>  
@@ -1208,7 +1208,7 @@ static int meson_mmc_probe(struct platform_device *pdev) <nl>  	} <nl>   <nl>  	irq = platform_get_irq(pdev, 0); <nl> -	if (!irq) { <nl> +	if (irq <= 0) { <nl>  		dev_err(&pdev->dev, "failed to get interrupt resource.\n"); <nl>  		ret = -EINVAL; <nl>  		goto free_host;
@@ -63,7 +63,7 @@ static int moxart_gpio_probe(struct platform_device *pdev) <nl>  	gc->parent = dev; <nl>  	gc->owner = THIS_MODULE; <nl>   <nl> -	ret = gpiochip_add_data(gc, NULL); <nl> +	ret = devm_gpiochip_add_data(dev, gc, NULL); <nl>  	if (ret) { <nl>  		dev_err(dev, "%s: gpiochip_add failed\n", <nl>  			dev->of_node->full_name);
@@ -309,8 +309,7 @@ struct io_reg CX700_ModeXregs[] = { {VIASR, SR10, 0xFF, 0x01}, <nl>  {VIACR, CR96, 0xFF, 0x00}, <nl>  {VIACR, CR97, 0xFF, 0x00}, <nl>  {VIACR, CR99, 0xFF, 0x00}, <nl> -{VIACR, CR9B, 0xFF, 0x00}, <nl> -{VIACR, CRD2, 0xFF, 0xFF}	/* TMDS/LVDS control register.         */ <nl> +{VIACR, CR9B, 0xFF, 0x00} <nl>  }; <nl>   <nl>  /* Video Mode Table */
@@ -213,11 +213,15 @@ int kvm_set_irq_routing(struct kvm *kvm, <nl>  			goto out; <nl>   <nl>  		r = -EINVAL; <nl> -		if (ue->flags) <nl> +		if (ue->flags) { <nl> +			kfree(e); <nl>  			goto out; <nl> +		} <nl>  		r = setup_routing_entry(new, e, ue); <nl> -		if (r) <nl> +		if (r) { <nl> +			kfree(e); <nl>  			goto out; <nl> +		} <nl>  		++ue; <nl>  	} <nl>  
@@ -1681,18 +1681,18 @@ static bool link_dump_filtered(struct net_device *dev, <nl>  	return false; <nl>  } <nl>   <nl> -static struct net *get_target_net(struct sk_buff *skb, int netnsid) <nl> +static struct net *get_target_net(struct sock *sk, int netnsid) <nl>  { <nl>  	struct net *net; <nl>   <nl> -	net = get_net_ns_by_id(sock_net(skb->sk), netnsid); <nl> +	net = get_net_ns_by_id(sock_net(sk), netnsid); <nl>  	if (!net) <nl>  		return ERR_PTR(-EINVAL); <nl>   <nl>  	/* For now, the caller is required to have CAP_NET_ADMIN in <nl>  	 * the user namespace owning the target net ns. <nl>  	 */ <nl> -	if (!netlink_ns_capable(skb, net->user_ns, CAP_NET_ADMIN)) { <nl> +	if (!sk_ns_capable(sk, net->user_ns, CAP_NET_ADMIN)) { <nl>  		put_net(net); <nl>  		return ERR_PTR(-EACCES); <nl>  	} <nl> @@ -1733,7 +1733,7 @@ static int rtnl_dump_ifinfo(struct sk_buff *skb, struct netlink_callback *cb) <nl>  			ifla_policy, NULL) >= 0) { <nl>  		if (tb[IFLA_IF_NETNSID]) { <nl>  			netnsid = nla_get_s32(tb[IFLA_IF_NETNSID]); <nl> -			tgt_net = get_target_net(skb, netnsid); <nl> +			tgt_net = get_target_net(skb->sk, netnsid); <nl>  			if (IS_ERR(tgt_net)) { <nl>  				tgt_net = net; <nl>  				netnsid = -1; <nl> @@ -2883,7 +2883,7 @@ static int rtnl_getlink(struct sk_buff *skb, struct nlmsghdr *nlh, <nl>   <nl>  	if (tb[IFLA_IF_NETNSID]) { <nl>  		netnsid = nla_get_s32(tb[IFLA_IF_NETNSID]); <nl> -		tgt_net = get_target_net(skb, netnsid); <nl> +		tgt_net = get_target_net(NETLINK_CB(skb).sk, netnsid); <nl>  		if (IS_ERR(tgt_net)) <nl>  			return PTR_ERR(tgt_net); <nl>  	}
@@ -173,8 +173,15 @@ static struct page *get_arg_page(struct linux_binprm *bprm, unsigned long pos, <nl>  		return NULL; <nl>   <nl>  	if (write) { <nl> -		struct rlimit *rlim = current->signal->rlim; <nl>  		unsigned long size = bprm->vma->vm_end - bprm->vma->vm_start; <nl> +		struct rlimit *rlim; <nl> + <nl> +		/* <nl> +		 * We've historically supported up to 32 pages (ARG_MAX) <nl> +		 * of argument strings even with small stacks <nl> +		 */ <nl> +		if (size <= ARG_MAX) <nl> +			return page; <nl>   <nl>  		/* <nl>  		 * Limit to 1/4-th the stack size for the argv+env strings. <nl> @@ -183,6 +190,7 @@ static struct page *get_arg_page(struct linux_binprm *bprm, unsigned long pos, <nl>  		 *  - the program will have a reasonable amount of stack left <nl>  		 *    to work from. <nl>  		 */ <nl> +		rlim = current->signal->rlim; <nl>  		if (size > rlim[RLIMIT_STACK].rlim_cur / 4) { <nl>  			put_page(page); <nl>  			return NULL;
@@ -412,8 +412,9 @@ static int nfs4_do_handle_exception(struct nfs_server *server, <nl>  				ret = -EBUSY; <nl>  				break; <nl>  			} <nl> -		case -NFS4ERR_GRACE: <nl>  		case -NFS4ERR_DELAY: <nl> +			nfs_inc_server_stats(server, NFSIOS_DELAY); <nl> +		case -NFS4ERR_GRACE: <nl>  			exception->delay = 1; <nl>  			return 0; <nl>  
@@ -357,7 +357,7 @@ static void iwl_mvm_power_build_cmd(struct iwl_mvm *mvm, <nl>  	cmd->flags |= cpu_to_le16(POWER_FLAGS_POWER_SAVE_ENA_MSK); <nl>   <nl>  	if (!vif->bss_conf.ps || iwl_mvm_vif_low_latency(mvmvif) || <nl> -	    !mvmvif->pm_enabled || iwl_mvm_tdls_sta_count(mvm, vif)) <nl> +	    !mvmvif->pm_enabled) <nl>  		return; <nl>   <nl>  	cmd->flags |= cpu_to_le16(POWER_FLAGS_POWER_MANAGEMENT_ENA_MSK); <nl> @@ -638,6 +638,10 @@ static void iwl_mvm_power_set_pm(struct iwl_mvm *mvm, <nl>  	if (vifs->ap_vif) <nl>  		ap_mvmvif = iwl_mvm_vif_from_mac80211(vifs->ap_vif); <nl>   <nl> +	/* don't allow PM if any TDLS stations exist */ <nl> +	if (iwl_mvm_tdls_sta_count(mvm, NULL)) <nl> +		return; <nl> + <nl>  	/* enable PM on bss if bss stand alone */ <nl>  	if (vifs->bss_active && !vifs->p2p_active && !vifs->ap_active) { <nl>  		bss_mvmvif->pm_enabled = true;
@@ -1603,6 +1603,7 @@ device_create_groups_vargs(struct class *class, struct device *parent, <nl>  		goto error; <nl>  	} <nl>   <nl> +	device_initialize(dev); <nl>  	dev->devt = devt; <nl>  	dev->class = class; <nl>  	dev->parent = parent; <nl> @@ -1614,7 +1615,7 @@ device_create_groups_vargs(struct class *class, struct device *parent, <nl>  	if (retval) <nl>  		goto error; <nl>   <nl> -	retval = device_register(dev); <nl> +	retval = device_add(dev); <nl>  	if (retval) <nl>  		goto error; <nl>  
@@ -29,7 +29,7 @@ <nl>  /* to align the pointer to the (next) page boundary */ <nl>  #define PAGE_ALIGN(addr)	(((addr)+PAGE_SIZE-1)&PAGE_MASK) <nl>   <nl> -#define __PHYSICAL_MASK		((((phys_addr_t)1) << __PHYSICAL_MASK_SHIFT) - 1) <nl> +#define __PHYSICAL_MASK		((phys_addr_t)(1ULL << __PHYSICAL_MASK_SHIFT) - 1) <nl>  #define __VIRTUAL_MASK		((1UL << __VIRTUAL_MASK_SHIFT) - 1) <nl>   <nl>  #ifndef __ASSEMBLY__
@@ -786,7 +786,8 @@ static struct task_struct *create_comp_task(struct ehca_comp_pool *pool, <nl>  	spin_lock_init(&cct->task_lock); <nl>  	INIT_LIST_HEAD(&cct->cq_list); <nl>  	init_waitqueue_head(&cct->wait_queue); <nl> -	cct->task = kthread_create(comp_task, cct, "ehca_comp/%d", cpu); <nl> +	cct->task = kthread_create_on_node(comp_task, cct, cpu_to_node(cpu), <nl> +					   "ehca_comp/%d", cpu); <nl>   <nl>  	return cct->task; <nl>  }
@@ -479,6 +479,8 @@ int exynos_eint_wkup_init(struct samsung_pinctrl_drv_data *d) <nl>  		if (match) { <nl>  			irq_chip = kmemdup(match->data, <nl>  				sizeof(*irq_chip), GFP_KERNEL); <nl> +			if (!irq_chip) <nl> +				return -ENOMEM; <nl>  			wkup_np = np; <nl>  			break; <nl>  		}
@@ -4357,7 +4357,8 @@ static void set_bredr_scan(struct hci_request *req) <nl>  	 */ <nl>  	write_fast_connectable(req, false); <nl>   <nl> -	if (test_bit(HCI_CONNECTABLE, &hdev->dev_flags)) <nl> +	if (test_bit(HCI_CONNECTABLE, &hdev->dev_flags) || <nl> +	    !list_empty(&hdev->whitelist)) <nl>  		scan |= SCAN_PAGE; <nl>  	if (test_bit(HCI_DISCOVERABLE, &hdev->dev_flags)) <nl>  		scan |= SCAN_INQUIRY; <nl> @@ -4471,7 +4472,8 @@ static int set_bredr(struct sock *sk, struct hci_dev *hdev, void *data, u16 len) <nl>   <nl>  	hci_req_init(&req, hdev); <nl>   <nl> -	if (test_bit(HCI_CONNECTABLE, &hdev->dev_flags)) <nl> +	if (test_bit(HCI_CONNECTABLE, &hdev->dev_flags) || <nl> +	    !list_empty(&hdev->whitelist)) <nl>  		set_bredr_scan(&req); <nl>   <nl>  	/* Since only the advertising data flags will change, there
@@ -948,7 +948,6 @@ static int __dwc3_gadget_kick_transfer(struct dwc3_ep *dep, u16 cmd_param, <nl>  		dwc3_trace(trace_dwc3_gadget, "%s: endpoint busy", dep->name); <nl>  		return -EBUSY; <nl>  	} <nl> -	dep->flags &= ~DWC3_EP_PENDING_REQUEST; <nl>   <nl>  	/* <nl>  	 * If we are getting here after a short-out-packet we don't enqueue any <nl> @@ -1117,6 +1116,10 @@ static int __dwc3_gadget_ep_queue(struct dwc3_ep *dep, struct dwc3_request *req) <nl>  		if (ret && ret != -EBUSY) <nl>  			dev_dbg(dwc->dev, "%s: failed to kick transfers\n", <nl>  					dep->name); <nl> + <nl> +		if (!ret) <nl> +			dep->flags &= ~DWC3_EP_PENDING_REQUEST; <nl> + <nl>  		return ret; <nl>  	} <nl>  
@@ -3783,6 +3783,7 @@ static int io_rw_init_file(struct io_kiocb *req, fmode_t mode) <nl>  		if (!(kiocb->ki_flags & IOCB_DIRECT) || !file->f_op->iopoll) <nl>  			return -EOPNOTSUPP; <nl>   <nl> +		kiocb->private = NULL; <nl>  		kiocb->ki_flags |= IOCB_HIPRI | IOCB_ALLOC_CACHE; <nl>  		kiocb->ki_complete = io_complete_rw_iopoll; <nl>  		req->iopoll_completed = 0;
@@ -1894,7 +1894,7 @@ sg_build_indirect(Sg_scatter_hold * schp, Sg_fd * sfp, int buff_size) <nl>  		num = (rem_sz > scatter_elem_sz_prev) ? <nl>  			scatter_elem_sz_prev : rem_sz; <nl>   <nl> -		schp->pages[k] = alloc_pages(gfp_mask, order); <nl> +		schp->pages[k] = alloc_pages(gfp_mask | __GFP_ZERO, order); <nl>  		if (!schp->pages[k]) <nl>  			goto out; <nl>  
@@ -5811,6 +5811,8 @@ int tcp_rcv_state_process(struct sock *sk, struct sk_buff *skb, <nl>  			goto discard; <nl>   <nl>  		if (th->syn) { <nl> +			if (th->fin) <nl> +				goto discard; <nl>  			if (icsk->icsk_af_ops->conn_request(sk, skb) < 0) <nl>  				return 1; <nl>  
@@ -290,6 +290,7 @@ static inline int cipso_v4_validate(const struct sk_buff *skb, <nl>  	unsigned char err_offset = 0; <nl>  	u8 opt_len = opt[1]; <nl>  	u8 opt_iter; <nl> +	u8 tag_len; <nl>   <nl>  	if (opt_len < 8) { <nl>  		err_offset = 1; <nl> @@ -302,11 +303,12 @@ static inline int cipso_v4_validate(const struct sk_buff *skb, <nl>  	} <nl>   <nl>  	for (opt_iter = 6; opt_iter < opt_len;) { <nl> -		if (opt[opt_iter + 1] > (opt_len - opt_iter)) { <nl> +		tag_len = opt[opt_iter + 1]; <nl> +		if ((tag_len == 0) || (opt[opt_iter + 1] > (opt_len - opt_iter))) { <nl>  			err_offset = opt_iter + 1; <nl>  			goto out; <nl>  		} <nl> -		opt_iter += opt[opt_iter + 1]; <nl> +		opt_iter += tag_len; <nl>  	} <nl>   <nl>  out:
@@ -2660,8 +2660,6 @@ void target_wait_for_sess_cmds(struct se_session *se_sess) <nl>   <nl>  	list_for_each_entry_safe(se_cmd, tmp_cmd, <nl>  				&se_sess->sess_wait_list, se_cmd_list) { <nl> -		list_del_init(&se_cmd->se_cmd_list); <nl> - <nl>  		pr_debug("Waiting for se_cmd: %p t_state: %d, fabric state:" <nl>  			" %d\n", se_cmd, se_cmd->t_state, <nl>  			se_cmd->se_tfo->get_cmd_state(se_cmd));
@@ -222,9 +222,10 @@ getname_kernel(const char * filename) <nl>  	if (len <= EMBEDDED_NAME_MAX) { <nl>  		result->name = (char *)result->iname; <nl>  	} else if (len <= PATH_MAX) { <nl> +		const size_t size = offsetof(struct filename, iname[1]); <nl>  		struct filename *tmp; <nl>   <nl> -		tmp = kmalloc(sizeof(*tmp), GFP_KERNEL); <nl> +		tmp = kmalloc(size, GFP_KERNEL); <nl>  		if (unlikely(!tmp)) { <nl>  			__putname(result); <nl>  			return ERR_PTR(-ENOMEM);
@@ -1675,13 +1675,13 @@ static void kick_requests(struct ceph_osd_client *osdc, int force_resend) <nl>  		__register_request(osdc, req); <nl>  		__unregister_linger_request(osdc, req); <nl>  	} <nl> +	reset_changed_osds(osdc); <nl>  	mutex_unlock(&osdc->request_mutex); <nl>   <nl>  	if (needmap) { <nl>  		dout("%d requests for down osds, need new map\n", needmap); <nl>  		ceph_monc_request_next_osdmap(&osdc->client->monc); <nl>  	} <nl> -	reset_changed_osds(osdc); <nl>  } <nl>   <nl>  
@@ -637,7 +637,7 @@ static int tipc_l2_device_event(struct notifier_block *nb, unsigned long evt, <nl>  		break; <nl>  	case NETDEV_UNREGISTER: <nl>  	case NETDEV_CHANGENAME: <nl> -		bearer_disable(dev_net(dev), b); <nl> +		bearer_disable(net, b); <nl>  		break; <nl>  	} <nl>  	return NOTIFY_OK;
@@ -150,12 +150,6 @@ static bool r5l_has_free_space(struct r5l_log *log, sector_t size) <nl>  	return log->device_size > used_size + size; <nl>  } <nl>   <nl> -static void r5l_free_io_unit(struct r5l_log *log, struct r5l_io_unit *io) <nl> -{ <nl> -	__free_page(io->meta_page); <nl> -	kmem_cache_free(log->io_kc, io); <nl> -} <nl> - <nl>  static void __r5l_set_io_unit_state(struct r5l_io_unit *io, <nl>  				    enum r5l_io_unit_state state) <nl>  { <nl> @@ -215,6 +209,7 @@ static void r5l_log_endio(struct bio *bio) <nl>  		md_error(log->rdev->mddev, log->rdev); <nl>   <nl>  	bio_put(bio); <nl> +	__free_page(io->meta_page); <nl>   <nl>  	spin_lock_irqsave(&log->io_list_lock, flags); <nl>  	__r5l_set_io_unit_state(io, IO_UNIT_IO_END); <nl> @@ -552,7 +547,7 @@ static bool r5l_complete_finished_ios(struct r5l_log *log) <nl>  		log->next_cp_seq = io->seq; <nl>   <nl>  		list_del(&io->log_sibling); <nl> -		r5l_free_io_unit(log, io); <nl> +		kmem_cache_free(log->io_kc, io); <nl>   <nl>  		found = true; <nl>  	}
@@ -321,7 +321,7 @@ get_matching_model_microcode(int cpu, unsigned long start, <nl>  	unsigned int mc_saved_count = mc_saved_data->mc_saved_count; <nl>  	int i; <nl>   <nl> -	while (leftover) { <nl> +	while (leftover && mc_saved_count < ARRAY_SIZE(mc_saved_tmp)) { <nl>  		mc_header = (struct microcode_header_intel *)ucode_ptr; <nl>   <nl>  		mc_size = get_totalsize(mc_header);
@@ -283,7 +283,7 @@ static struct dm_region *__rh_alloc(struct dm_region_hash *rh, region_t region) <nl>   <nl>  	nreg = mempool_alloc(rh->region_pool, GFP_ATOMIC); <nl>  	if (unlikely(!nreg)) <nl> -		nreg = kmalloc(sizeof(*nreg), GFP_NOIO); <nl> +		nreg = kmalloc(sizeof(*nreg), GFP_NOIO | __GFP_NOFAIL); <nl>   <nl>  	nreg->state = rh->log->type->in_sync(rh->log, region, 1) ? <nl>  		      DM_RH_CLEAN : DM_RH_NOSYNC;
@@ -405,6 +405,11 @@ static int adis16400_read_raw(struct iio_dev *indio_dev, <nl>  			*val = st->variant->temp_scale_nano / 1000000; <nl>  			*val2 = (st->variant->temp_scale_nano % 1000000); <nl>  			return IIO_VAL_INT_PLUS_MICRO; <nl> +		case IIO_PRESSURE: <nl> +			/* 20 uBar = 0.002kPascal */ <nl> +			*val = 0; <nl> +			*val2 = 2000; <nl> +			return IIO_VAL_INT_PLUS_MICRO; <nl>  		default: <nl>  			return -EINVAL; <nl>  		}
@@ -3374,7 +3374,6 @@ static void ixgbe_configure_dcb(struct ixgbe_adapter *adapter) <nl>  	if (hw->mac.type == ixgbe_mac_82598EB) <nl>  		netif_set_gso_max_size(adapter->netdev, 32768); <nl>   <nl> -	ixgbe_dcb_check_config(&adapter->dcb_cfg); <nl>  	ixgbe_dcb_calculate_tc_credits(&adapter->dcb_cfg, DCB_TX_CONFIG); <nl>  	ixgbe_dcb_calculate_tc_credits(&adapter->dcb_cfg, DCB_RX_CONFIG); <nl>  
@@ -466,6 +466,9 @@ static bool snd_soc_set_cache_val(void *base, unsigned int idx, <nl>  static unsigned int snd_soc_get_cache_val(const void *base, unsigned int idx, <nl>  		unsigned int word_size) <nl>  { <nl> +	if (!base) <nl> +		return -1; <nl> + <nl>  	switch (word_size) { <nl>  	case 1: { <nl>  		const u8 *cache = base;
@@ -418,7 +418,7 @@ unsigned long slice_get_unmapped_area(unsigned long addr, unsigned long len, <nl>  	unsigned long high_limit; <nl>   <nl>  	high_limit = DEFAULT_MAP_WINDOW; <nl> -	if (addr >= high_limit) <nl> +	if (addr >= high_limit || (fixed && (addr + len > high_limit))) <nl>  		high_limit = TASK_SIZE; <nl>   <nl>  	if (len > high_limit)
@@ -149,9 +149,14 @@ int mdio_mux_init(struct device *dev, <nl>  		} <nl>  		cb->bus_number = v; <nl>  		cb->parent = pb; <nl> + <nl>  		cb->mii_bus = mdiobus_alloc(); <nl> +		if (!cb->mii_bus) { <nl> +			ret_val = -ENOMEM; <nl> +			of_node_put(child_bus_node); <nl> +			break; <nl> +		} <nl>  		cb->mii_bus->priv = cb; <nl> - <nl>  		cb->mii_bus->irq = cb->phy_irq; <nl>  		cb->mii_bus->name = "mdio_mux"; <nl>  		snprintf(cb->mii_bus->id, MII_BUS_ID_SIZE, "%x.%x",
@@ -114,8 +114,8 @@ static ssize_t module_gzip_decompress(struct load_info *info, <nl>  	do { <nl>  		struct page *page = module_get_next_page(info); <nl>   <nl> -		if (!page) { <nl> -			retval = -ENOMEM; <nl> +		if (IS_ERR(page)) { <nl> +			retval = PTR_ERR(page); <nl>  			goto out_inflate_end; <nl>  		} <nl>   <nl> @@ -173,8 +173,8 @@ static ssize_t module_xz_decompress(struct load_info *info, <nl>  	do { <nl>  		struct page *page = module_get_next_page(info); <nl>   <nl> -		if (!page) { <nl> -			retval = -ENOMEM; <nl> +		if (IS_ERR(page)) { <nl> +			retval = PTR_ERR(page); <nl>  			goto out; <nl>  		} <nl>  
@@ -2136,7 +2136,7 @@ static int r8a66597_hub_status_data(struct usb_hcd *hcd, char *buf) <nl>  static void r8a66597_hub_descriptor(struct r8a66597 *r8a66597, <nl>  				    struct usb_hub_descriptor *desc) <nl>  { <nl> -	desc->bDescriptorType = 0x29; <nl> +	desc->bDescriptorType = USB_DT_HUB; <nl>  	desc->bHubContrCurrent = 0; <nl>  	desc->bNbrPorts = r8a66597->max_root_hub; <nl>  	desc->bDescLength = 9;
@@ -33,7 +33,7 @@ EXPORT_SYMBOL_GPL(cb710_pci_update_config_reg); <nl>  static int __devinit cb710_pci_configure(struct pci_dev *pdev) <nl>  { <nl>  	unsigned int devfn = PCI_DEVFN(PCI_SLOT(pdev->devfn), 0); <nl> -	struct pci_dev *pdev0 = pci_get_slot(pdev->bus, devfn); <nl> +	struct pci_dev *pdev0; <nl>  	u32 val; <nl>   <nl>  	cb710_pci_update_config_reg(pdev, 0x48, <nl> @@ -43,6 +43,7 @@ static int __devinit cb710_pci_configure(struct pci_dev *pdev) <nl>  	if (val & 0x80000000) <nl>  		return 0; <nl>   <nl> +	pdev0 = pci_get_slot(pdev->bus, devfn); <nl>  	if (!pdev0) <nl>  		return -ENODEV; <nl>  
@@ -2365,16 +2365,16 @@ static int i915_ppgtt_info(struct seq_file *m, void *data) <nl>  		task = get_pid_task(file->pid, PIDTYPE_PID); <nl>  		if (!task) { <nl>  			ret = -ESRCH; <nl> -			goto out_put; <nl> +			goto out_unlock; <nl>  		} <nl>  		seq_printf(m, "\nproc: %s\n", task->comm); <nl>  		put_task_struct(task); <nl>  		idr_for_each(&file_priv->context_idr, per_file_ctx, <nl>  			     (void *)(unsigned long)m); <nl>  	} <nl> +out_unlock: <nl>  	mutex_unlock(&dev->filelist_mutex); <nl>   <nl> -out_put: <nl>  	intel_runtime_pm_put(dev_priv); <nl>  	mutex_unlock(&dev->struct_mutex); <nl>  
@@ -485,6 +485,9 @@ flush_signal_handlers(struct task_struct *t, int force_default) <nl>  		if (force_default || ka->sa.sa_handler != SIG_IGN) <nl>  			ka->sa.sa_handler = SIG_DFL; <nl>  		ka->sa.sa_flags = 0; <nl> +#ifdef SA_RESTORER <nl> +		ka->sa.sa_restorer = NULL; <nl> +#endif <nl>  		sigemptyset(&ka->sa.sa_mask); <nl>  		ka++; <nl>  	}
@@ -1601,6 +1601,9 @@ static void hdspm_set_dds_value(struct hdspm *hdspm, int rate) <nl>  { <nl>  	u64 n; <nl>   <nl> +	if (snd_BUG_ON(rate <= 0)) <nl> +		return; <nl> + <nl>  	if (rate >= 112000) <nl>  		rate /= 4; <nl>  	else if (rate >= 56000) <nl> @@ -2215,6 +2218,8 @@ static int hdspm_get_system_sample_rate(struct hdspm *hdspm) <nl>  		} else { <nl>  			/* slave mode, return external sample rate */ <nl>  			rate = hdspm_external_sample_rate(hdspm); <nl> +			if (!rate) <nl> +				rate = hdspm->system_sample_rate; <nl>  		} <nl>  	} <nl>   <nl> @@ -2260,7 +2265,10 @@ static int snd_hdspm_put_system_sample_rate(struct snd_kcontrol *kcontrol, <nl>  					    ucontrol) <nl>  { <nl>  	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol); <nl> +	int rate = ucontrol->value.integer.value[0]; <nl>   <nl> +	if (rate < 27000 || rate > 207000) <nl> +		return -EINVAL; <nl>  	hdspm_set_dds_value(hdspm, ucontrol->value.integer.value[0]); <nl>  	return 0; <nl>  }
@@ -146,7 +146,8 @@ aoedev_freedev(struct aoedev *d) <nl>  		put_disk(d->gd); <nl>  	} <nl>  	kfree(d->frames); <nl> -	mempool_destroy(d->bufpool); <nl> +	if (d->bufpool) <nl> +		mempool_destroy(d->bufpool); <nl>  	kfree(d); <nl>  } <nl>  
@@ -46,7 +46,7 @@ void rtsx_add_cmd(struct rtsx_chip *chip, <nl>  void rtsx_send_cmd_no_wait(struct rtsx_chip *chip); <nl>  int rtsx_send_cmd(struct rtsx_chip *chip, u8 card, int timeout); <nl>   <nl> -extern inline u8 *rtsx_get_cmd_data(struct rtsx_chip *chip) <nl> +static inline u8 *rtsx_get_cmd_data(struct rtsx_chip *chip) <nl>  { <nl>  #ifdef CMD_USING_SG <nl>  	return (u8 *)(chip->host_sg_tbl_ptr);
@@ -671,8 +671,10 @@ int orangefs_prepare_debugfs_help_string(int at_boot) <nl>  		 */ <nl>  		cdm_element_count = <nl>  			orangefs_prepare_cdm_array(client_debug_array_string); <nl> -		if (cdm_element_count <= 0) <nl> +		if (cdm_element_count <= 0) { <nl> +			kfree(new); <nl>  			goto out; <nl> +		} <nl>   <nl>  		for (i = 0; i < cdm_element_count; i++) { <nl>  			strlcat(new, "\t", string_size);
@@ -67,7 +67,10 @@ static int radio_si4713_querycap(struct file *file, void *priv, <nl>  	strlcpy(capability->driver, "radio-si4713", sizeof(capability->driver)); <nl>  	strlcpy(capability->card, "Silicon Labs Si4713 Modulator", <nl>  		sizeof(capability->card)); <nl> -	capability->capabilities = V4L2_CAP_MODULATOR | V4L2_CAP_RDS_OUTPUT; <nl> +	strlcpy(capability->bus_info, "platform:radio-si4713", <nl> +		sizeof(capability->bus_info)); <nl> +	capability->device_caps = V4L2_CAP_MODULATOR | V4L2_CAP_RDS_OUTPUT; <nl> +	capability->capabilities = capability->device_caps | V4L2_CAP_DEVICE_CAPS; <nl>   <nl>  	return 0; <nl>  }
@@ -1668,10 +1668,10 @@ static void print_request(struct drm_printer *m, <nl>  			  struct i915_request *rq, <nl>  			  const char *prefix) <nl>  { <nl> -	drm_printf(m, "%s%x%s [%x:%x] prio=%d @ %dms: %s\n", prefix, <nl> +	drm_printf(m, "%s%x%s [%llx:%x] prio=%d @ %dms: %s\n", prefix, <nl>  		   rq->global_seqno, <nl>  		   i915_request_completed(rq) ? "!" : "", <nl> -		   rq->ctx->hw_id, rq->fence.seqno, <nl> +		   rq->fence.context, rq->fence.seqno, <nl>  		   rq->priotree.priority, <nl>  		   jiffies_to_msecs(jiffies - rq->emitted_jiffies), <nl>  		   rq->timeline->common->name);
@@ -849,11 +849,13 @@ int ext4_da_write_inline_data_begin(struct address_space *mapping, <nl>  	handle_t *handle; <nl>  	struct page *page; <nl>  	struct ext4_iloc iloc; <nl> +	int retries; <nl>   <nl>  	ret = ext4_get_inode_loc(inode, &iloc); <nl>  	if (ret) <nl>  		return ret; <nl>   <nl> +retry_journal: <nl>  	handle = ext4_journal_start(inode, EXT4_HT_INODE, 1); <nl>  	if (IS_ERR(handle)) { <nl>  		ret = PTR_ERR(handle); <nl> @@ -875,6 +877,11 @@ int ext4_da_write_inline_data_begin(struct address_space *mapping, <nl>  							    inode, <nl>  							    flags, <nl>  							    fsdata); <nl> +		ext4_journal_stop(handle); <nl> +		handle = NULL; <nl> +		if (ret == -ENOSPC && <nl> +		    ext4_should_retry_alloc(inode->i_sb, &retries)) <nl> +			goto retry_journal; <nl>  		goto out; <nl>  	} <nl>  
@@ -352,6 +352,9 @@ void gen8_fbc_sw_flush(struct drm_device *dev, u32 value) <nl>  	if (!IS_GEN8(dev)) <nl>  		return; <nl>   <nl> +	if (!intel_fbc_enabled(dev)) <nl> +		return; <nl> + <nl>  	I915_WRITE(MSG_FBC_REND_STATE, value); <nl>  } <nl>  
@@ -73,6 +73,9 @@ static ssize_t acpi_ec_write_io(struct file *f, const char __user *buf, <nl>  	loff_t init_off = *off; <nl>  	int err = 0; <nl>   <nl> +	if (!write_support) <nl> +		return -EINVAL; <nl> + <nl>  	if (*off >= EC_SPACE_SIZE) <nl>  		return 0; <nl>  	if (*off + count >= EC_SPACE_SIZE) {
@@ -560,7 +560,7 @@ void __init init_cpu_features(struct cpuinfo_arm64 *info) <nl>  	 * Run the errata work around checks on the boot CPU, once we have <nl>  	 * initialised the cpu feature infrastructure. <nl>  	 */ <nl> -	update_cpu_capabilities(arm64_errata, SCOPE_ALL, <nl> +	update_cpu_capabilities(arm64_errata, SCOPE_LOCAL_CPU, <nl>  				"enabling workaround for"); <nl>  } <nl>   <nl> @@ -1452,7 +1452,7 @@ void check_local_cpu_capabilities(void) <nl>  	 * advertised capabilities. <nl>  	 */ <nl>  	if (!sys_caps_initialised) <nl> -		update_cpu_capabilities(arm64_errata, SCOPE_ALL, <nl> +		update_cpu_capabilities(arm64_errata, SCOPE_LOCAL_CPU, <nl>  					"enabling workaround for"); <nl>  	else <nl>  		verify_local_cpu_capabilities(); <nl> @@ -1480,6 +1480,8 @@ void __init setup_cpu_features(void) <nl>   <nl>  	/* Set the CPU feature capabilies */ <nl>  	update_cpu_capabilities(arm64_features, SCOPE_ALL, "detected:"); <nl> +	update_cpu_capabilities(arm64_errata, SCOPE_SYSTEM, <nl> +				"enabling workaround for"); <nl>  	enable_cpu_capabilities(arm64_features, SCOPE_ALL); <nl>  	enable_cpu_capabilities(arm64_errata, SCOPE_ALL); <nl>  	mark_const_caps_ready();
@@ -661,7 +661,8 @@ int oxygen_pcm_init(struct oxygen *chip) <nl>  	ins = !!(chip->model.device_config & (CAPTURE_0_FROM_I2S_1 | <nl>  					      CAPTURE_0_FROM_I2S_2)); <nl>  	if (outs | ins) { <nl> -		err = snd_pcm_new(chip->card, "Analog", 0, outs, ins, &pcm); <nl> +		err = snd_pcm_new(chip->card, "Multichannel", <nl> +				  0, outs, ins, &pcm); <nl>  		if (err < 0) <nl>  			return err; <nl>  		if (outs) <nl> @@ -675,7 +676,7 @@ int oxygen_pcm_init(struct oxygen *chip) <nl>  					&oxygen_rec_b_ops); <nl>  		pcm->private_data = chip; <nl>  		pcm->private_free = oxygen_pcm_free; <nl> -		strcpy(pcm->name, "Analog"); <nl> +		strcpy(pcm->name, "Multichannel"); <nl>  		if (outs) <nl>  			snd_pcm_lib_preallocate_pages(pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream, <nl>  						      SNDRV_DMA_TYPE_DEV,
@@ -7054,6 +7054,7 @@ static long DAC960_gam_ioctl(struct file *file, unsigned int Request, <nl>  	else <nl>  		ErrorCode =  0; <nl>        } <nl> +      break; <nl>        default: <nl>  	ErrorCode = -ENOTTY; <nl>      }
@@ -1985,6 +1985,10 @@ static int copy_msghdr_from_user(struct msghdr *kmsg, <nl>  { <nl>  	if (copy_from_user(kmsg, umsg, sizeof(struct msghdr))) <nl>  		return -EFAULT; <nl> + <nl> +	if (kmsg->msg_namelen < 0) <nl> +		return -EINVAL; <nl> + <nl>  	if (kmsg->msg_namelen > sizeof(struct sockaddr_storage)) <nl>  		kmsg->msg_namelen = sizeof(struct sockaddr_storage); <nl>  	return 0;
@@ -309,7 +309,9 @@ int dccp_disconnect(struct sock *sk, int flags) <nl>  		sk->sk_err = ECONNRESET; <nl>   <nl>  	dccp_clear_xmit_timers(sk); <nl> + <nl>  	__skb_queue_purge(&sk->sk_receive_queue); <nl> +	__skb_queue_purge(&sk->sk_write_queue); <nl>  	if (sk->sk_send_head != NULL) { <nl>  		__kfree_skb(sk->sk_send_head); <nl>  		sk->sk_send_head = NULL;
@@ -2604,7 +2604,7 @@ static void *skd_alloc_dma(struct skd_device *skdev, struct kmem_cache *s, <nl>  		return NULL; <nl>  	*dma_handle = dma_map_single(dev, buf, s->size, dir); <nl>  	if (dma_mapping_error(dev, *dma_handle)) { <nl> -		kfree(buf); <nl> +		kmem_cache_free(s, buf); <nl>  		buf = NULL; <nl>  	} <nl>  	return buf;
@@ -1365,7 +1365,7 @@ static int pppol2tp_setsockopt(struct socket *sock, int level, int optname, <nl>  	int err; <nl>   <nl>  	if (level != SOL_PPPOL2TP) <nl> -		return udp_prot.setsockopt(sk, level, optname, optval, optlen); <nl> +		return -EINVAL; <nl>   <nl>  	if (optlen < sizeof(int)) <nl>  		return -EINVAL; <nl> @@ -1491,7 +1491,7 @@ static int pppol2tp_getsockopt(struct socket *sock, int level, int optname, <nl>  	struct pppol2tp_session *ps; <nl>   <nl>  	if (level != SOL_PPPOL2TP) <nl> -		return udp_prot.getsockopt(sk, level, optname, optval, optlen); <nl> +		return -EINVAL; <nl>   <nl>  	if (get_user(len, optlen)) <nl>  		return -EFAULT;
@@ -1574,11 +1574,12 @@ static inline int zap_threads(struct task_struct *tsk, struct mm_struct *mm, <nl>  	for_each_process(g) { <nl>  		if (g == tsk->group_leader) <nl>  			continue; <nl> - <nl> +		if (g->flags & PF_KTHREAD) <nl> +			continue; <nl>  		p = g; <nl>  		do { <nl>  			if (p->mm) { <nl> -				if (p->mm == mm) { <nl> +				if (unlikely(p->mm == mm)) { <nl>  					lock_task_sighand(p, &flags); <nl>  					zap_process(p); <nl>  					unlock_task_sighand(p, &flags);
@@ -5734,6 +5734,8 @@ int x86_emulate_instruction(struct kvm_vcpu *vcpu, <nl>  			if (reexecute_instruction(vcpu, cr2, write_fault_to_spt, <nl>  						emulation_type)) <nl>  				return EMULATE_DONE; <nl> +			if (ctxt->have_exception && inject_emulated_exception(vcpu)) <nl> +				return EMULATE_DONE; <nl>  			if (emulation_type & EMULTYPE_SKIP) <nl>  				return EMULATE_FAIL; <nl>  			return handle_emulation_failure(vcpu);
@@ -339,6 +339,7 @@ static struct platform_device wl1271_device = { <nl>  	}, <nl>  }; <nl>   <nl> +static DEFINE_MUTEX(wl_list_mutex); <nl>  static LIST_HEAD(wl_list); <nl>   <nl>  static int wl1271_dev_notify(struct notifier_block *me, unsigned long what, <nl> @@ -369,10 +370,12 @@ static int wl1271_dev_notify(struct notifier_block *me, unsigned long what, <nl>  		return NOTIFY_DONE; <nl>   <nl>  	wl_temp = hw->priv; <nl> +	mutex_lock(&wl_list_mutex); <nl>  	list_for_each_entry(wl, &wl_list, list) { <nl>  		if (wl == wl_temp) <nl>  			break; <nl>  	} <nl> +	mutex_unlock(&wl_list_mutex); <nl>  	if (wl != wl_temp) <nl>  		return NOTIFY_DONE; <nl>   <nl> @@ -1390,8 +1393,10 @@ static int wl1271_op_add_interface(struct ieee80211_hw *hw, <nl>  out: <nl>  	mutex_unlock(&wl->mutex); <nl>   <nl> +	mutex_lock(&wl_list_mutex); <nl>  	if (!ret) <nl>  		list_add(&wl->list, &wl_list); <nl> +	mutex_unlock(&wl_list_mutex); <nl>   <nl>  	return ret; <nl>  } <nl> @@ -1404,7 +1409,9 @@ static void __wl1271_op_remove_interface(struct wl1271 *wl) <nl>   <nl>  	wl1271_info("down"); <nl>   <nl> +	mutex_lock(&wl_list_mutex); <nl>  	list_del(&wl->list); <nl> +	mutex_unlock(&wl_list_mutex); <nl>   <nl>  	WARN_ON(wl->state != WL1271_STATE_ON); <nl>  
@@ -1517,6 +1517,8 @@ xfs_rtfree_range( <nl>  	 */ <nl>  	error = xfs_rtfind_forw(mp, tp, end, mp->m_sb.sb_rextents - 1, <nl>  		&postblock); <nl> +	if (error) <nl> +		return error; <nl>  	/* <nl>  	 * If there are blocks not being freed at the front of the <nl>  	 * old extent, add summary data for them to be allocated.
@@ -605,6 +605,8 @@ static int spc_emulate_inquiry(struct se_cmd *cmd) <nl>  	unsigned char buf[SE_INQUIRY_BUF]; <nl>  	int p, ret; <nl>   <nl> +	memset(buf, 0, SE_INQUIRY_BUF); <nl> + <nl>  	if (dev == tpg->tpg_virt_lun0.lun_se_dev) <nl>  		buf[0] = 0x3f; /* Not connected */ <nl>  	else
@@ -495,7 +495,7 @@ static int exofs_read_lookup_dev_table(struct exofs_sb_info **psbi, <nl>  		} <nl>   <nl>  		od = osduld_info_lookup(&odi); <nl> -		if (unlikely(IS_ERR(od))) { <nl> +		if (IS_ERR(od)) { <nl>  			ret = PTR_ERR(od); <nl>  			EXOFS_ERR("ERROR: device requested is not found " <nl>  				  "osd_name-%s =>%d\n", odi.osdname, ret);
@@ -35,7 +35,7 @@ static void pwmled_brightness(struct led_classdev *cdev, enum led_brightness b) <nl>   * NOTE:  we reuse the platform_data structure of GPIO leds, <nl>   * but repurpose its "gpio" number as a PWM channel number. <nl>   */ <nl> -static int __init pwmled_probe(struct platform_device *pdev) <nl> +static int __devinit pwmled_probe(struct platform_device *pdev) <nl>  { <nl>  	const struct gpio_led_platform_data	*pdata; <nl>  	struct pwmled				*leds;
@@ -276,6 +276,7 @@ asmlinkage void math_emulate(long arg) <nl>  	entry_sel_off.offset = FPU_ORIG_EIP; <nl>  	entry_sel_off.selector = FPU_CS; <nl>  	entry_sel_off.opcode = (byte1 << 8) | FPU_modrm; <nl> +	entry_sel_off.empty = 0; <nl>   <nl>  	FPU_rm = FPU_modrm & 7; <nl>  
@@ -1150,6 +1150,7 @@ void kvm_mmu_pte_write(struct kvm_vcpu *vcpu, gpa_t gpa, <nl>  	unsigned pte_size; <nl>  	unsigned page_offset; <nl>  	unsigned misaligned; <nl> +	unsigned quadrant; <nl>  	int level; <nl>  	int flooded = 0; <nl>  	int npte; <nl> @@ -1202,7 +1203,10 @@ void kvm_mmu_pte_write(struct kvm_vcpu *vcpu, gpa_t gpa, <nl>  				page_offset <<= 1; <nl>  				npte = 2; <nl>  			} <nl> +			quadrant = page_offset >> PAGE_SHIFT; <nl>  			page_offset &= ~PAGE_MASK; <nl> +			if (quadrant != page->role.quadrant) <nl> +				continue; <nl>  		} <nl>  		spte = __va(page->page_hpa); <nl>  		spte += page_offset / sizeof(*spte);
@@ -678,7 +678,7 @@ static void apc_agent_timeout(unsigned long data) <nl>  	configure_phy_mask = ~port_agent->phy_configured_mask & port_agent->phy_ready_mask; <nl>   <nl>  	if (!configure_phy_mask) <nl> -		return; <nl> +		goto done; <nl>   <nl>  	for (index = 0; index < SCI_MAX_PHYS; index++) { <nl>  		if ((configure_phy_mask & (1 << index)) == 0)
@@ -872,11 +872,11 @@ static int smsdvb_hotplug(struct smscore_device_t *coredev, <nl>  	switch (smscore_get_device_mode(coredev)) { <nl>  	case DEVICE_MODE_DVBT: <nl>  	case DEVICE_MODE_DVBT_BDA: <nl> -		smsdvb_fe_ops.delsys[0] = SYS_DVBT; <nl> +		client->frontend.ops.delsys[0] = SYS_DVBT; <nl>  		break; <nl>  	case DEVICE_MODE_ISDBT: <nl>  	case DEVICE_MODE_ISDBT_BDA: <nl> -		smsdvb_fe_ops.delsys[0] = SYS_ISDBT; <nl> +		client->frontend.ops.delsys[0] = SYS_ISDBT; <nl>  		break; <nl>  	} <nl>  
@@ -733,8 +733,7 @@ xfs_iext_remove_node( <nl>  	node->ptrs[nr_entries] = NULL; <nl>   <nl>  	if (pos == 0 && nr_entries > 0) { <nl> -		xfs_iext_update_node(ifp, offset, node->keys[0], level, <nl> -				node); <nl> +		xfs_iext_update_node(ifp, offset, node->keys[0], level, node); <nl>  		offset = node->keys[0]; <nl>  	} <nl>  
@@ -64,8 +64,13 @@ int mpi_powm(MPI res, MPI base, MPI exp, MPI mod) <nl>  	if (!esize) { <nl>  		/* Exponent is zero, result is 1 mod MOD, i.e., 1 or 0 <nl>  		 * depending on if MOD equals 1.  */ <nl> -		rp[0] = 1; <nl>  		res->nlimbs = (msize == 1 && mod->d[0] == 1) ? 0 : 1; <nl> +		if (res->nlimbs) { <nl> +			if (mpi_resize(res, 1) < 0) <nl> +				goto enomem; <nl> +			rp = res->d; <nl> +			rp[0] = 1; <nl> +		} <nl>  		res->sign = 0; <nl>  		goto leave; <nl>  	}
@@ -490,9 +490,6 @@ static void balance_dirty_pages(struct address_space *mapping, <nl>  	bool dirty_exceeded = false; <nl>  	struct backing_dev_info *bdi = mapping->backing_dev_info; <nl>   <nl> -	if (!bdi_cap_account_dirty(bdi)) <nl> -		return; <nl> - <nl>  	for (;;) { <nl>  		struct writeback_control wbc = { <nl>  			.sync_mode	= WB_SYNC_NONE, <nl> @@ -631,9 +628,13 @@ static DEFINE_PER_CPU(unsigned long, bdp_ratelimits) = 0; <nl>  void balance_dirty_pages_ratelimited_nr(struct address_space *mapping, <nl>  					unsigned long nr_pages_dirtied) <nl>  { <nl> +	struct backing_dev_info *bdi = mapping->backing_dev_info; <nl>  	unsigned long ratelimit; <nl>  	unsigned long *p; <nl>   <nl> +	if (!bdi_cap_account_dirty(bdi)) <nl> +		return; <nl> + <nl>  	ratelimit = ratelimit_pages; <nl>  	if (mapping->backing_dev_info->dirty_exceeded) <nl>  		ratelimit = 8;
@@ -456,6 +456,9 @@ static int qat_hal_init_esram(struct icp_qat_fw_loader_handle *handle) <nl>  	unsigned int csr_val; <nl>  	int times = 30; <nl>   <nl> +	if (handle->pci_dev->device == ADF_C3XXX_PCI_DEVICE_ID) <nl> +		return 0; <nl> + <nl>  	csr_val = ADF_CSR_RD(csr_addr, 0); <nl>  	if ((csr_val & ESRAM_AUTO_TINIT) && (csr_val & ESRAM_AUTO_TINIT_DONE)) <nl>  		return 0;
@@ -839,9 +839,10 @@ static int safexcel_probe(struct platform_device *pdev) <nl>  		snprintf(irq_name, 6, "ring%d", i); <nl>  		irq = safexcel_request_ring_irq(pdev, irq_name, safexcel_irq_ring, <nl>  						ring_irq); <nl> - <nl> -		if (irq < 0) <nl> +		if (irq < 0) { <nl> +			ret = irq; <nl>  			goto err_clk; <nl> +		} <nl>   <nl>  		priv->ring[i].work_data.priv = priv; <nl>  		priv->ring[i].work_data.ring = i;
@@ -1537,7 +1537,8 @@ int blk_mq_alloc_tag_set(struct blk_mq_tag_set *set) <nl>  		return -EINVAL; <nl>   <nl>   <nl> -	set->tags = kmalloc_node(set->nr_hw_queues * sizeof(struct blk_mq_tags), <nl> +	set->tags = kmalloc_node(set->nr_hw_queues * <nl> +				 sizeof(struct blk_mq_tags *), <nl>  				 GFP_KERNEL, set->numa_node); <nl>  	if (!set->tags) <nl>  		goto out;
@@ -1428,6 +1428,7 @@ static long ppc_set_hwdebug(struct task_struct *child, <nl>   <nl>  	brk.address = bp_info->addr & ~7UL; <nl>  	brk.type = HW_BRK_TYPE_TRANSLATE; <nl> +	brk.len = 8; <nl>  	if (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_READ) <nl>  		brk.type |= HW_BRK_TYPE_READ; <nl>  	if (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_WRITE)
@@ -244,6 +244,11 @@ static int davinci_pcm_open(struct snd_pcm_substream *substream) <nl>  	int ret = 0; <nl>   <nl>  	snd_soc_set_runtime_hwparams(substream, &davinci_pcm_hardware); <nl> +	/* ensure that buffer size is a multiple of period size */ <nl> +	ret = snd_pcm_hw_constraint_integer(runtime, <nl> +						SNDRV_PCM_HW_PARAM_PERIODS); <nl> +	if (ret < 0) <nl> +		return ret; <nl>   <nl>  	prtd = kzalloc(sizeof(struct davinci_runtime_data), GFP_KERNEL); <nl>  	if (prtd == NULL)
@@ -577,10 +577,11 @@ static void pmic_mpp_config_dbg_show(struct pinctrl_dev *pctldev, <nl>   <nl>  		if (pad->input_enabled) { <nl>  			ret = pmic_mpp_read(state, pad, PMIC_MPP_REG_RT_STS); <nl> -			if (!ret) { <nl> -				ret &= PMIC_MPP_REG_RT_STS_VAL_MASK; <nl> -				pad->out_value = ret; <nl> -			} <nl> +			if (ret < 0) <nl> +				return; <nl> + <nl> +			ret &= PMIC_MPP_REG_RT_STS_VAL_MASK; <nl> +			pad->out_value = ret; <nl>  		} <nl>   <nl>  		seq_printf(s, " %-4s", pad->output_enabled ? "out" : "in");
@@ -57,7 +57,6 @@ static int nft_hash_init(const struct nft_ctx *ctx, <nl>  	if (!tb[NFTA_HASH_SREG] || <nl>  	    !tb[NFTA_HASH_DREG] || <nl>  	    !tb[NFTA_HASH_LEN]  || <nl> -	    !tb[NFTA_HASH_SEED] || <nl>  	    !tb[NFTA_HASH_MODULUS]) <nl>  		return -EINVAL; <nl>   <nl> @@ -80,7 +79,10 @@ static int nft_hash_init(const struct nft_ctx *ctx, <nl>  	if (priv->offset + priv->modulus - 1 < priv->offset) <nl>  		return -EOVERFLOW; <nl>   <nl> -	priv->seed = ntohl(nla_get_be32(tb[NFTA_HASH_SEED])); <nl> +	if (tb[NFTA_HASH_SEED]) <nl> +		priv->seed = ntohl(nla_get_be32(tb[NFTA_HASH_SEED])); <nl> +	else <nl> +		get_random_bytes(&priv->seed, sizeof(priv->seed)); <nl>   <nl>  	return nft_validate_register_load(priv->sreg, len) && <nl>  	       nft_validate_register_store(ctx, priv->dreg, NULL,
@@ -350,6 +350,12 @@ static int picolcd_raw_event(struct hid_device *hdev, <nl>  	if (!data) <nl>  		return 1; <nl>   <nl> +	if (size > 64) { <nl> +		hid_warn(hdev, "invalid size value (%d) for picolcd raw event\n", <nl> +				size); <nl> +		return 0; <nl> +	} <nl> + <nl>  	if (report->id == REPORT_KEY_STATE) { <nl>  		if (data->input_keys) <nl>  			ret = picolcd_raw_keypad(data, report, raw_data+1, size-1);
@@ -233,7 +233,7 @@ static int omap_pcm_open(struct snd_pcm_substream *substream) <nl>  	if (ret < 0) <nl>  		goto out; <nl>   <nl> -	prtd = kzalloc(sizeof(prtd), GFP_KERNEL); <nl> +	prtd = kzalloc(sizeof(*prtd), GFP_KERNEL); <nl>  	if (prtd == NULL) { <nl>  		ret = -ENOMEM; <nl>  		goto out;
@@ -596,9 +596,8 @@ static void bm_memset(struct drbd_bitmap *b, size_t offset, int c, size_t len) <nl>  		if (bm+do_now > p_addr + LWPP) { <nl>  			printk(KERN_ALERT "drbd: BUG BUG BUG! p_addr:%p bm:%p do_now:%d\n", <nl>  			       p_addr, bm, (int)do_now); <nl> -			break; /* breaks to after catch_oob_access_end() only! */ <nl> -		} <nl> -		memset(bm, c, do_now * sizeof(long)); <nl> +		} else <nl> +			memset(bm, c, do_now * sizeof(long)); <nl>  		bm_unmap(p_addr); <nl>  		bm_set_page_need_writeout(b->bm_pages[idx]); <nl>  		offset += do_now;
@@ -108,6 +108,10 @@ static struct page_info *alloc_largest_available(struct ion_system_heap *heap, <nl>  	struct page_info *info; <nl>  	int i; <nl>   <nl> +	info = kmalloc(sizeof(struct page_info), GFP_KERNEL); <nl> +	if (!info) <nl> +		return NULL; <nl> + <nl>  	for (i = 0; i < num_orders; i++) { <nl>  		if (size < order_to_size(orders[i])) <nl>  			continue; <nl> @@ -118,11 +122,12 @@ static struct page_info *alloc_largest_available(struct ion_system_heap *heap, <nl>  		if (!page) <nl>  			continue; <nl>   <nl> -		info = kmalloc(sizeof(struct page_info), GFP_KERNEL); <nl>  		info->page = page; <nl>  		info->order = orders[i]; <nl>  		return info; <nl>  	} <nl> +	kfree(info); <nl> + <nl>  	return NULL; <nl>  } <nl>  
@@ -1184,6 +1184,7 @@ int blk_init_allocated_queue(struct request_queue *q) <nl>  		q->exit_rq_fn(q, q->fq->flush_rq); <nl>  out_free_flush_queue: <nl>  	blk_free_flush_queue(q->fq); <nl> +	q->fq = NULL; <nl>  	return -ENOMEM; <nl>  } <nl>  EXPORT_SYMBOL(blk_init_allocated_queue);
@@ -21,6 +21,7 @@ <nl>  #include <linux/err.h> <nl>  #include <linux/init.h> <nl>  #include <linux/module.h> <nl> +#include <linux/of.h> <nl>  #include <linux/types.h> <nl>   <nl>  static struct cpufreq_frequency_table freq_table[] = { <nl> @@ -158,6 +159,9 @@ static int __init tegra_cpufreq_init(void) <nl>  { <nl>  	int err; <nl>   <nl> +	if (!of_machine_is_compatible("nvidia,tegra20")) <nl> +		return -ENODEV; <nl> + <nl>  	cpu_clk = clk_get_sys(NULL, "cclk"); <nl>  	if (IS_ERR(cpu_clk)) <nl>  		return PTR_ERR(cpu_clk);
@@ -1892,7 +1892,7 @@ static int pm_genpd_summary_one(struct seq_file *s, <nl>  	if (WARN_ON(genpd->status >= ARRAY_SIZE(status_lookup))) <nl>  		goto exit; <nl>  	if (genpd->status == GPD_STATE_POWER_OFF) <nl> -		snprintf(state, sizeof(state), "%s %u", <nl> +		snprintf(state, sizeof(state), "%s-%u", <nl>  			 status_lookup[genpd->status], genpd->state_idx); <nl>  	else <nl>  		snprintf(state, sizeof(state), "%s",
@@ -634,6 +634,9 @@ xfs_error_get_cfg( <nl>  { <nl>  	struct xfs_error_cfg	*cfg; <nl>   <nl> +	if (error < 0) <nl> +		error = -error; <nl> + <nl>  	switch (error) { <nl>  	case EIO: <nl>  		cfg = &mp->m_error_cfg[error_class][XFS_ERR_EIO];
@@ -1197,6 +1197,11 @@ int bond_enslave(struct net_device *bond_dev, struct net_device *slave_dev) <nl>  		return -EBUSY; <nl>  	} <nl>   <nl> +	if (bond_dev == slave_dev) { <nl> +		pr_err("%s: cannot enslave bond to itself.\n", bond_dev->name); <nl> +		return -EPERM; <nl> +	} <nl> + <nl>  	/* vlan challenged mutual exclusion */ <nl>  	/* no need to lock since we're protected by rtnl_lock */ <nl>  	if (slave_dev->features & NETIF_F_VLAN_CHALLENGED) {
@@ -148,8 +148,6 @@ static int power_saving_thread(void *data) <nl>  	while (!kthread_should_stop()) { <nl>  		unsigned long expire_time; <nl>   <nl> -		try_to_freeze(); <nl> - <nl>  		/* round robin to cpus */ <nl>  		expire_time = last_jiffies + round_robin_time * HZ; <nl>  		if (time_before(expire_time, jiffies)) {
@@ -1540,8 +1540,8 @@ static int pxa168_eth_probe(struct platform_device *pdev) <nl>  	if (err) <nl>  		goto err_free_mdio; <nl>   <nl> -	pxa168_init_hw(pep); <nl>  	SET_NETDEV_DEV(dev, &pdev->dev); <nl> +	pxa168_init_hw(pep); <nl>  	err = register_netdev(dev); <nl>  	if (err) <nl>  		goto err_mdiobus;
@@ -411,7 +411,7 @@ static int spi_ppc4xx_of_probe(struct platform_device *op) <nl>  	if (num_gpios > 0) { <nl>  		int i; <nl>   <nl> -		hw->gpios = kzalloc(sizeof(int) * num_gpios, GFP_KERNEL); <nl> +		hw->gpios = kcalloc(num_gpios, sizeof(*hw->gpios), GFP_KERNEL); <nl>  		if (!hw->gpios) { <nl>  			ret = -ENOMEM; <nl>  			goto free_master;
@@ -185,8 +185,8 @@ static int pcf8583_rtc_read_time(struct device *dev, struct rtc_time *tm) <nl>  	if (ctrl & (CTRL_STOP | CTRL_HOLD)) { <nl>  		unsigned char new_ctrl = ctrl & ~(CTRL_STOP | CTRL_HOLD); <nl>   <nl> -		printk(KERN_WARNING "RTC: resetting control %02x -> %02x\n", <nl> -		       ctrl, new_ctrl); <nl> +		dev_warn(dev, "resetting control %02x -> %02x\n", <nl> +			ctrl, new_ctrl); <nl>   <nl>  		if ((err = pcf8583_set_ctrl(client, &new_ctrl)) < 0) <nl>  			return err;
@@ -66,6 +66,12 @@ struct nvram_parser { <nl>  	bool multi_dev_v2; <nl>  }; <nl>   <nl> +/** <nl> + * is_nvram_char() - check if char is a valid one for NVRAM entry <nl> + * <nl> + * It accepts all printable ASCII chars except for '#' which opens a comment. <nl> + * Please note that ' ' (space) while accepted is not a valid key name char. <nl> + */ <nl>  static bool is_nvram_char(char c) <nl>  { <nl>  	/* comment marker excluded */ <nl> @@ -73,7 +79,7 @@ static bool is_nvram_char(char c) <nl>  		return false; <nl>   <nl>  	/* key and value may have any other readable character */ <nl> -	return (c > 0x20 && c < 0x7f); <nl> +	return (c >= 0x20 && c < 0x7f); <nl>  } <nl>   <nl>  static bool is_whitespace(char c) <nl> @@ -120,7 +126,7 @@ static enum nvram_parser_state brcmf_nvram_handle_key(struct nvram_parser *nvp) <nl>  			nvp->multi_dev_v1 = true; <nl>  		if (strncmp(&nvp->fwnv->data[nvp->entry], "pcie/", 5) == 0) <nl>  			nvp->multi_dev_v2 = true; <nl> -	} else if (!is_nvram_char(c)) { <nl> +	} else if (!is_nvram_char(c) || c == ' ') { <nl>  		brcmf_dbg(INFO, "warning: ln=%d:col=%d: '=' expected, skip invalid key entry\n", <nl>  			  nvp->line, nvp->column); <nl>  		return COMMENT;
@@ -733,7 +733,7 @@ static void ttm_put_pages(struct page **pages, unsigned npages, int flags, <nl>  			if (!(flags & TTM_PAGE_FLAG_DMA32) && <nl>  			    (npages - i) >= HPAGE_PMD_NR) { <nl>  				for (j = 1; j < HPAGE_PMD_NR; ++j) <nl> -					if (p++ != pages[i + j]) <nl> +					if (++p != pages[i + j]) <nl>  					    break; <nl>   <nl>  				if (j == HPAGE_PMD_NR) <nl> @@ -768,7 +768,7 @@ static void ttm_put_pages(struct page **pages, unsigned npages, int flags, <nl>  				break; <nl>   <nl>  			for (j = 1; j < HPAGE_PMD_NR; ++j) <nl> -				if (p++ != pages[i + j]) <nl> +				if (++p != pages[i + j]) <nl>  				    break; <nl>   <nl>  			if (j != HPAGE_PMD_NR)
@@ -4460,7 +4460,7 @@ static int dm_update_crtcs_state(struct dc *dc, <nl>  			} <nl>  		} <nl>   <nl> -		if (dc_is_stream_unchanged(new_stream, dm_old_crtc_state->stream) && <nl> +		if (enable && dc_is_stream_unchanged(new_stream, dm_old_crtc_state->stream) && <nl>  				dc_is_stream_scaling_unchanged(new_stream, dm_old_crtc_state->stream)) { <nl>   <nl>  			new_crtc_state->mode_changed = false;
@@ -36,7 +36,7 @@ static int mfd_add_device(struct platform_device *parent, <nl>  	if (ret) <nl>  		goto fail_device; <nl>   <nl> -	memzero(res, sizeof(res)); <nl> +	memset(res, 0, sizeof(res)); <nl>  	for (r = 0; r < cell->num_resources; r++) { <nl>  		res[r].name = cell->resources[r].name; <nl>  		res[r].flags = cell->resources[r].flags;
@@ -3921,7 +3921,8 @@ static int btrfs_add_system_chunk(struct btrfs_root *root, <nl>  	u8 *ptr; <nl>   <nl>  	array_size = btrfs_super_sys_array_size(super_copy); <nl> -	if (array_size + item_size > BTRFS_SYSTEM_CHUNK_ARRAY_SIZE) <nl> +	if (array_size + item_size + sizeof(disk_key) <nl> +			> BTRFS_SYSTEM_CHUNK_ARRAY_SIZE) <nl>  		return -EFBIG; <nl>   <nl>  	ptr = super_copy->sys_chunk_array + array_size;
@@ -138,7 +138,7 @@ static int tomoyo_mount_acl(struct tomoyo_request_info *r, char *dev_name, <nl>  	} <nl>  	if (need_dev) { <nl>  		/* Get mount point or device file. */ <nl> -		if (kern_path(dev_name, LOOKUP_FOLLOW, &path)) { <nl> +		if (!dev_name || kern_path(dev_name, LOOKUP_FOLLOW, &path)) { <nl>  			error = -ENOENT; <nl>  			goto out; <nl>  		}
@@ -607,9 +607,11 @@ static int osc_ldlm_glimpse_ast(struct ldlm_lock *dlmlock, void *data) <nl>  			lvb = req_capsule_server_get(cap, &RMF_DLM_LVB); <nl>  			result = cl_object_glimpse(env, obj, lvb); <nl>  		} <nl> -		if (!exp_connect_lvb_type(req->rq_export)) <nl> -		req_capsule_shrink(&req->rq_pill, &RMF_DLM_LVB, <nl> -				   sizeof(struct ost_lvb_v1), RCL_SERVER); <nl> +		if (!exp_connect_lvb_type(req->rq_export)) { <nl> +			req_capsule_shrink(&req->rq_pill, &RMF_DLM_LVB, <nl> +					   sizeof(struct ost_lvb_v1), <nl> +					   RCL_SERVER); <nl> +		} <nl>  		cl_object_put(env, obj); <nl>  	} else { <nl>  		/*
@@ -92,7 +92,7 @@ enum { none, prepare, done, } __init_state; <nl>  static void init_preload(void); <nl>  static void try_init_preload(void) <nl>  { <nl> -	if (!__init_state != done) <nl> +	if (__init_state != done) <nl>  		init_preload(); <nl>  } <nl>  
@@ -121,6 +121,13 @@ static int acpi_cpu_soft_notify(struct notifier_block *nfb, <nl>  	struct acpi_processor *pr = per_cpu(processors, cpu); <nl>  	struct acpi_device *device; <nl>   <nl> +	/* <nl> +	 * CPU_STARTING and CPU_DYING must not sleep. Return here since <nl> +	 * acpi_bus_get_device() may sleep. <nl> +	 */ <nl> +	if (action == CPU_STARTING || action == CPU_DYING) <nl> +		return NOTIFY_DONE; <nl> + <nl>  	if (!pr || acpi_bus_get_device(pr->handle, &device)) <nl>  		return NOTIFY_DONE; <nl>  
@@ -908,6 +908,7 @@ static int fuse_fill_super(struct super_block *sb, void *data, int silent) <nl>   err_put_root: <nl>  	dput(root_dentry); <nl>   err_put_conn: <nl> +	bdi_destroy(&fc->bdi); <nl>  	fuse_conn_put(fc); <nl>   err_fput: <nl>  	fput(file);
@@ -1719,6 +1719,9 @@ int ll_fid2path(struct inode *inode, void __user *arg) <nl>  	if (get_user(pathlen, &gfin->gf_pathlen)) <nl>  		return -EFAULT; <nl>   <nl> +	if (pathlen > PATH_MAX) <nl> +		return -EINVAL; <nl> + <nl>  	outsize = sizeof(*gfout) + pathlen; <nl>   <nl>  	OBD_ALLOC(gfout, outsize);
@@ -903,6 +903,8 @@ static void can_pernet_exit(struct net *net) <nl>  		} <nl>  	} <nl>  	rcu_read_unlock(); <nl> + <nl> +	kfree(net->can.can_rx_alldev_list); <nl>  } <nl>   <nl>  /*
@@ -191,7 +191,7 @@ static struct platform_driver mxc_w1_driver = { <nl>  		   .name = "mxc_w1", <nl>  	}, <nl>  	.probe = mxc_w1_probe, <nl> -	.remove = __devexit_p(mxc_w1_remove), <nl> +	.remove = mxc_w1_remove, <nl>  }; <nl>  module_platform_driver(mxc_w1_driver); <nl>  
@@ -402,7 +402,7 @@ static void clear_huge_page(struct page *page, <nl>  { <nl>  	int i; <nl>   <nl> -	if (unlikely(sz > MAX_ORDER_NR_PAGES)) { <nl> +	if (unlikely(sz/PAGE_SIZE > MAX_ORDER_NR_PAGES)) { <nl>  		clear_gigantic_page(page, addr, sz); <nl>  		return; <nl>  	}
@@ -258,7 +258,8 @@ int ip_cmsg_send(struct sock *sk, struct msghdr *msg, struct ipcm_cookie *ipc, <nl>  			src_info = (struct in6_pktinfo *)CMSG_DATA(cmsg); <nl>  			if (!ipv6_addr_v4mapped(&src_info->ipi6_addr)) <nl>  				return -EINVAL; <nl> -			ipc->oif = src_info->ipi6_ifindex; <nl> +			if (src_info->ipi6_ifindex) <nl> +				ipc->oif = src_info->ipi6_ifindex; <nl>  			ipc->addr = src_info->ipi6_addr.s6_addr32[3]; <nl>  			continue; <nl>  		} <nl> @@ -288,7 +289,8 @@ int ip_cmsg_send(struct sock *sk, struct msghdr *msg, struct ipcm_cookie *ipc, <nl>  			if (cmsg->cmsg_len != CMSG_LEN(sizeof(struct in_pktinfo))) <nl>  				return -EINVAL; <nl>  			info = (struct in_pktinfo *)CMSG_DATA(cmsg); <nl> -			ipc->oif = info->ipi_ifindex; <nl> +			if (info->ipi_ifindex) <nl> +				ipc->oif = info->ipi_ifindex; <nl>  			ipc->addr = info->ipi_spec_dst.s_addr; <nl>  			break; <nl>  		}
@@ -184,9 +184,9 @@ static long __init sclp_hsa_size_init(struct sdias_sccb *sccb) <nl>  	sccb_init_eq_size(sccb); <nl>  	if (sclp_cmd_early(SCLP_CMDW_WRITE_EVENT_DATA, sccb)) <nl>  		return -EIO; <nl> -	if (sccb->evbuf.blk_cnt != 0) <nl> -		return (sccb->evbuf.blk_cnt - 1) * PAGE_SIZE; <nl> -	return 0; <nl> +	if (sccb->evbuf.blk_cnt == 0) <nl> +		return 0; <nl> +	return (sccb->evbuf.blk_cnt - 1) * PAGE_SIZE; <nl>  } <nl>   <nl>  static long __init sclp_hsa_copy_wait(struct sccb_header *sccb) <nl> @@ -195,6 +195,8 @@ static long __init sclp_hsa_copy_wait(struct sccb_header *sccb) <nl>  	sccb->length = PAGE_SIZE; <nl>  	if (sclp_cmd_early(SCLP_CMDW_READ_EVENT_DATA, sccb)) <nl>  		return -EIO; <nl> +	if (((struct sdias_sccb *) sccb)->evbuf.blk_cnt == 0) <nl> +		return 0; <nl>  	return (((struct sdias_sccb *) sccb)->evbuf.blk_cnt - 1) * PAGE_SIZE; <nl>  } <nl>  
@@ -2288,7 +2288,7 @@ unsigned int skb_seq_read(unsigned int consumed, const u8 **data, <nl>  next_skb: <nl>  	block_limit = skb_headlen(st->cur_skb) + st->stepped_offset; <nl>   <nl> -	if (abs_offset < block_limit) { <nl> +	if (abs_offset < block_limit && !st->frag_data) { <nl>  		*data = st->cur_skb->data + (abs_offset - st->stepped_offset); <nl>  		return block_limit - abs_offset; <nl>  	}
@@ -694,7 +694,7 @@ void snd_timer_interrupt(struct snd_timer * timer, unsigned long ticks_left) <nl>  		} else { <nl>  			ti->flags &= ~SNDRV_TIMER_IFLG_RUNNING; <nl>  			if (--timer->running) <nl> -				list_del(&ti->active_list); <nl> +				list_del_init(&ti->active_list); <nl>  		} <nl>  		if ((timer->hw.flags & SNDRV_TIMER_HW_TASKLET) || <nl>  		    (ti->flags & SNDRV_TIMER_IFLG_FAST))
@@ -1182,7 +1182,6 @@ void sctp_assoc_update(struct sctp_association *asoc, <nl>  	asoc->peer.peer_hmacs = new->peer.peer_hmacs; <nl>  	new->peer.peer_hmacs = NULL; <nl>   <nl> -	sctp_auth_key_put(asoc->asoc_shared_key); <nl>  	sctp_auth_asoc_init_active_key(asoc, GFP_ATOMIC); <nl>  } <nl>  
@@ -2269,8 +2269,9 @@ struct md_op_data *ll_prep_md_op_data(struct md_op_data *op_data, <nl>  	op_data->op_default_stripe_offset = -1; <nl>  	if (S_ISDIR(i1->i_mode)) { <nl>  		op_data->op_mea1 = ll_i2info(i1)->lli_lsm_md; <nl> -		op_data->op_default_stripe_offset = <nl> -			ll_i2info(i1)->lli_def_stripe_offset; <nl> +		if (opc == LUSTRE_OPC_MKDIR) <nl> +			op_data->op_default_stripe_offset = <nl> +				ll_i2info(i1)->lli_def_stripe_offset; <nl>  	} <nl>   <nl>  	if (i2) {
@@ -2898,7 +2898,9 @@ int mpol_parse_str(char *str, struct mempolicy **mpol) <nl>  	switch (mode) { <nl>  	case MPOL_PREFERRED: <nl>  		/* <nl> -		 * Insist on a nodelist of one node only <nl> +		 * Insist on a nodelist of one node only, although later <nl> +		 * we use first_node(nodes) to grab a single node, so here <nl> +		 * nodelist (or nodes) cannot be empty. <nl>  		 */ <nl>  		if (nodelist) { <nl>  			char *rest = nodelist; <nl> @@ -2906,6 +2908,8 @@ int mpol_parse_str(char *str, struct mempolicy **mpol) <nl>  				rest++; <nl>  			if (*rest) <nl>  				goto out; <nl> +			if (nodes_empty(nodes)) <nl> +				goto out; <nl>  		} <nl>  		break; <nl>  	case MPOL_INTERLEAVE:
@@ -4133,9 +4133,10 @@ static int sctp_getsockopt_disable_fragments(struct sock *sk, int len, <nl>  static int sctp_getsockopt_events(struct sock *sk, int len, char __user *optval, <nl>  				  int __user *optlen) <nl>  { <nl> -	if (len < sizeof(struct sctp_event_subscribe)) <nl> +	if (len <= 0) <nl>  		return -EINVAL; <nl> -	len = sizeof(struct sctp_event_subscribe); <nl> +	if (len > sizeof(struct sctp_event_subscribe)) <nl> +		len = sizeof(struct sctp_event_subscribe); <nl>  	if (put_user(len, optlen)) <nl>  		return -EFAULT; <nl>  	if (copy_to_user(optval, &sctp_sk(sk)->subscribe, len))
@@ -121,7 +121,9 @@ static long vbg_misc_device_ioctl(struct file *filp, unsigned int req, <nl>  	if (!buf) <nl>  		return -ENOMEM; <nl>   <nl> -	if (copy_from_user(buf, (void *)arg, hdr.size_in)) { <nl> +	*((struct vbg_ioctl_hdr *)buf) = hdr; <nl> +	if (copy_from_user(buf + sizeof(hdr), (void *)arg + sizeof(hdr), <nl> +			   hdr.size_in - sizeof(hdr))) { <nl>  		ret = -EFAULT; <nl>  		goto out; <nl>  	}
@@ -188,7 +188,7 @@ static void dpp1_cm_set_regamma_pwl( <nl>  	struct dpp *dpp_base, const struct pwl_params *params, enum opp_regamma mode) <nl>  { <nl>  	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base); <nl> -	uint32_t re_mode; <nl> +	uint32_t re_mode = 0; <nl>   <nl>  	switch (mode) { <nl>  	case OPP_REGAMMA_BYPASS:
@@ -655,7 +655,7 @@ static struct pnp_driver tpm_inf_pnp_driver = { <nl>  	.probe = tpm_inf_pnp_probe, <nl>  	.suspend = tpm_inf_pnp_suspend, <nl>  	.resume = tpm_inf_pnp_resume, <nl> -	.remove = __devexit_p(tpm_inf_pnp_remove) <nl> +	.remove = tpm_inf_pnp_remove <nl>  }; <nl>   <nl>  static int __init init_inf(void)
@@ -184,7 +184,6 @@ static int ext4_init_block_bitmap(struct super_block *sb, <nl>  	unsigned int bit, bit_max; <nl>  	struct ext4_sb_info *sbi = EXT4_SB(sb); <nl>  	ext4_fsblk_t start, tmp; <nl> -	int flex_bg = 0; <nl>   <nl>  	J_ASSERT_BH(bh, buffer_locked(bh)); <nl>   <nl> @@ -207,22 +206,19 @@ static int ext4_init_block_bitmap(struct super_block *sb, <nl>   <nl>  	start = ext4_group_first_block_no(sb, block_group); <nl>   <nl> -	if (ext4_has_feature_flex_bg(sb)) <nl> -		flex_bg = 1; <nl> - <nl>  	/* Set bits for block and inode bitmaps, and inode table */ <nl>  	tmp = ext4_block_bitmap(sb, gdp); <nl> -	if (!flex_bg || ext4_block_in_group(sb, tmp, block_group)) <nl> +	if (ext4_block_in_group(sb, tmp, block_group)) <nl>  		ext4_set_bit(EXT4_B2C(sbi, tmp - start), bh->b_data); <nl>   <nl>  	tmp = ext4_inode_bitmap(sb, gdp); <nl> -	if (!flex_bg || ext4_block_in_group(sb, tmp, block_group)) <nl> +	if (ext4_block_in_group(sb, tmp, block_group)) <nl>  		ext4_set_bit(EXT4_B2C(sbi, tmp - start), bh->b_data); <nl>   <nl>  	tmp = ext4_inode_table(sb, gdp); <nl>  	for (; tmp < ext4_inode_table(sb, gdp) + <nl>  		     sbi->s_itb_per_group; tmp++) { <nl> -		if (!flex_bg || ext4_block_in_group(sb, tmp, block_group)) <nl> +		if (ext4_block_in_group(sb, tmp, block_group)) <nl>  			ext4_set_bit(EXT4_B2C(sbi, tmp - start), bh->b_data); <nl>  	} <nl>  
@@ -139,14 +139,18 @@ static void parse_lfp_panel_data(struct drm_psb_private *dev_priv, <nl>  	if (!lvds_lfp_data) <nl>  		return; <nl>   <nl> -	dev_priv->lvds_vbt = 1; <nl>   <nl>  	entry = &lvds_lfp_data->data[lvds_options->panel_type]; <nl>  	dvo_timing = &entry->dvo_timing; <nl>   <nl>  	panel_fixed_mode = kzalloc(sizeof(*panel_fixed_mode), <nl>  				      GFP_KERNEL); <nl> +	if (panel_fixed_mode == NULL) { <nl> +		dev_err(dev_priv->dev->dev, "out of memory for fixed panel mode\n"); <nl> +		return; <nl> +	} <nl>   <nl> +	dev_priv->lvds_vbt = 1; <nl>  	fill_detail_timing_data(panel_fixed_mode, dvo_timing); <nl>   <nl>  	if (panel_fixed_mode->htotal > 0 && panel_fixed_mode->vtotal > 0) {
@@ -3342,6 +3342,8 @@ static int kvm_vcpu_ioctl_enable_cap(struct kvm_vcpu *vcpu, <nl>   <nl>  	switch (cap->cap) { <nl>  	case KVM_CAP_HYPERV_SYNIC: <nl> +		if (!irqchip_in_kernel(vcpu->kvm)) <nl> +			return -EINVAL; <nl>  		return kvm_hv_activate_synic(vcpu); <nl>  	default: <nl>  		return -EINVAL;
@@ -620,7 +620,6 @@ static int queue_init(void *priv, struct vb2_queue *src_vq, <nl>  	struct fimc_ctx *ctx = priv; <nl>  	int ret; <nl>   <nl> -	memset(src_vq, 0, sizeof(*src_vq)); <nl>  	src_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE; <nl>  	src_vq->io_modes = VB2_MMAP | VB2_USERPTR; <nl>  	src_vq->drv_priv = ctx; <nl> @@ -632,7 +631,6 @@ static int queue_init(void *priv, struct vb2_queue *src_vq, <nl>  	if (ret) <nl>  		return ret; <nl>   <nl> -	memset(dst_vq, 0, sizeof(*dst_vq)); <nl>  	dst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE; <nl>  	dst_vq->io_modes = VB2_MMAP | VB2_USERPTR; <nl>  	dst_vq->drv_priv = ctx;
@@ -418,10 +418,17 @@ int pem_task_create_user_performance_state(struct pp_eventmgr *eventmgr, struct <nl>  int pem_task_initialize_thermal_controller(struct pp_eventmgr *eventmgr, struct pem_event_data *event_data) <nl>  { <nl>  	struct PP_TemperatureRange range; <nl> + <nl>  	range.max = TEMP_RANGE_MAX; <nl>  	range.min = TEMP_RANGE_MIN; <nl>   <nl> -	return phm_start_thermal_controller(eventmgr->hwmgr, &range); <nl> +	if (eventmgr == NULL || eventmgr->platform_descriptor == NULL) <nl> +		return -EINVAL; <nl> + <nl> +	if (phm_cap_enabled(eventmgr->platform_descriptor->platformCaps, PHM_PlatformCaps_ThermalController)) <nl> +		return phm_start_thermal_controller(eventmgr->hwmgr, &range); <nl> + <nl> +	return 0; <nl>  } <nl>   <nl>  int pem_task_uninitialize_thermal_controller(struct pp_eventmgr *eventmgr, struct pem_event_data *event_data)
@@ -302,7 +302,7 @@ static void __init relocate_initrd(void) <nl>  		if (clen > MAX_MAP_CHUNK-slop) <nl>  			clen = MAX_MAP_CHUNK-slop; <nl>  		mapaddr = ramdisk_image & PAGE_MASK; <nl> -		p = early_ioremap(mapaddr, clen+slop); <nl> +		p = early_memremap(mapaddr, clen+slop); <nl>  		memcpy(q, p+slop, clen); <nl>  		early_iounmap(p, clen+slop); <nl>  		q += clen; <nl> @@ -379,7 +379,7 @@ static void __init parse_setup_data(void) <nl>  		return; <nl>  	pa_data = boot_params.hdr.setup_data; <nl>  	while (pa_data) { <nl> -		data = early_ioremap(pa_data, PAGE_SIZE); <nl> +		data = early_memremap(pa_data, PAGE_SIZE); <nl>  		switch (data->type) { <nl>  		case SETUP_E820_EXT: <nl>  			parse_e820_ext(data, pa_data); <nl> @@ -402,7 +402,7 @@ static void __init e820_reserve_setup_data(void) <nl>  		return; <nl>  	pa_data = boot_params.hdr.setup_data; <nl>  	while (pa_data) { <nl> -		data = early_ioremap(pa_data, sizeof(*data)); <nl> +		data = early_memremap(pa_data, sizeof(*data)); <nl>  		e820_update_range(pa_data, sizeof(*data)+data->len, <nl>  			 E820_RAM, E820_RESERVED_KERN); <nl>  		found = 1; <nl> @@ -428,7 +428,7 @@ static void __init reserve_early_setup_data(void) <nl>  		return; <nl>  	pa_data = boot_params.hdr.setup_data; <nl>  	while (pa_data) { <nl> -		data = early_ioremap(pa_data, sizeof(*data)); <nl> +		data = early_memremap(pa_data, sizeof(*data)); <nl>  		sprintf(buf, "setup data %x", data->type); <nl>  		reserve_early(pa_data, pa_data+sizeof(*data)+data->len, buf); <nl>  		pa_data = data->next;
@@ -1615,6 +1615,8 @@ static void xudc_getstatus(struct xusb_udc *udc) <nl>  		break; <nl>  	case USB_RECIP_ENDPOINT: <nl>  		epnum = udc->setup.wIndex & USB_ENDPOINT_NUMBER_MASK; <nl> +		if (epnum >= XUSB_MAX_ENDPOINTS) <nl> +			goto stall; <nl>  		target_ep = &udc->ep[epnum]; <nl>  		epcfgreg = udc->read_fn(udc->addr + target_ep->offset); <nl>  		halt = epcfgreg & XUSB_EP_CFG_STALL_MASK; <nl> @@ -1682,6 +1684,10 @@ static void xudc_set_clear_feature(struct xusb_udc *udc) <nl>  	case USB_RECIP_ENDPOINT: <nl>  		if (!udc->setup.wValue) { <nl>  			endpoint = udc->setup.wIndex & USB_ENDPOINT_NUMBER_MASK; <nl> +			if (endpoint >= XUSB_MAX_ENDPOINTS) { <nl> +				xudc_ep0_stall(udc); <nl> +				return; <nl> +			} <nl>  			target_ep = &udc->ep[endpoint]; <nl>  			outinbit = udc->setup.wIndex & USB_ENDPOINT_DIR_MASK; <nl>  			outinbit = outinbit >> 7;
@@ -55,6 +55,7 @@ static void __init reset_tod_clock(void) <nl>  		disabled_wait(0); <nl>   <nl>  	sched_clock_base_cc = TOD_UNIX_EPOCH; <nl> +	S390_lowcore.last_update_clock = sched_clock_base_cc; <nl>  } <nl>   <nl>  #ifdef CONFIG_SHARED_KERNEL <nl> @@ -167,6 +168,14 @@ static noinline __init void create_kernel_nss(void) <nl>  		return; <nl>  	} <nl>   <nl> +	/* re-initialize cputime accounting. */ <nl> +	sched_clock_base_cc = get_clock(); <nl> +	S390_lowcore.last_update_clock = sched_clock_base_cc; <nl> +	S390_lowcore.last_update_timer = 0x7fffffffffffffffULL; <nl> +	S390_lowcore.user_timer = 0; <nl> +	S390_lowcore.system_timer = 0; <nl> +	asm volatile("SPT 0(%0)" : : "a" (&S390_lowcore.last_update_timer)); <nl> + <nl>  	/* re-setup boot command line with new ipl vm parms */ <nl>  	ipl_update_parameters(); <nl>  	setup_boot_command_line();
@@ -2845,14 +2845,14 @@ context_switch(struct rq *rq, struct task_struct *prev, <nl>  	 */ <nl>  	arch_start_context_switch(prev); <nl>   <nl> -	if (likely(!mm)) { <nl> +	if (!mm) { <nl>  		next->active_mm = oldmm; <nl>  		atomic_inc(&oldmm->mm_count); <nl>  		enter_lazy_tlb(oldmm, next); <nl>  	} else <nl>  		switch_mm(oldmm, mm, next); <nl>   <nl> -	if (likely(!prev->mm)) { <nl> +	if (!prev->mm) { <nl>  		prev->active_mm = NULL; <nl>  		rq->prev_mm = oldmm; <nl>  	}
@@ -4451,7 +4451,7 @@ int qeth_snmp_command(struct qeth_card *card, char __user *udata) <nl>  	struct qeth_cmd_buffer *iob; <nl>  	struct qeth_ipa_cmd *cmd; <nl>  	struct qeth_snmp_ureq *ureq; <nl> -	int req_len; <nl> +	unsigned int req_len; <nl>  	struct qeth_arp_query_info qinfo = {0, }; <nl>  	int rc = 0; <nl>   <nl> @@ -4467,6 +4467,10 @@ int qeth_snmp_command(struct qeth_card *card, char __user *udata) <nl>  	/* skip 4 bytes (data_len struct member) to get req_len */ <nl>  	if (copy_from_user(&req_len, udata + sizeof(int), sizeof(int))) <nl>  		return -EFAULT; <nl> +	if (req_len > (QETH_BUFSIZE - IPA_PDU_HEADER_SIZE - <nl> +		       sizeof(struct qeth_ipacmd_hdr) - <nl> +		       sizeof(struct qeth_ipacmd_setadpparms_hdr))) <nl> +		return -EINVAL; <nl>  	ureq = memdup_user(udata, req_len + sizeof(struct qeth_snmp_ureq_hdr)); <nl>  	if (IS_ERR(ureq)) { <nl>  		QETH_CARD_TEXT(card, 2, "snmpnome");
@@ -332,7 +332,7 @@ static void pl011_dma_probe_initcall(struct device *dev, struct uart_amba_port * <nl>  		dmaengine_slave_config(chan, &rx_conf); <nl>  		uap->dmarx.chan = chan; <nl>   <nl> -		if (plat->dma_rx_poll_enable) { <nl> +		if (plat && plat->dma_rx_poll_enable) { <nl>  			/* Set poll rate if specified. */ <nl>  			if (plat->dma_rx_poll_rate) { <nl>  				uap->dmarx.auto_poll_rate = false;
@@ -1437,6 +1437,8 @@ void dlm_lowcomms_stop(void) <nl>  		con = __nodeid2con(i, 0); <nl>  		if (con) { <nl>  			close_connection(con, true); <nl> +			if (con->othercon) <nl> +				kmem_cache_free(con_cache, con->othercon); <nl>  			kmem_cache_free(con_cache, con); <nl>  		} <nl>  	}
@@ -787,12 +787,6 @@ static int init_hardware(void) <nl>  	spin_lock_irqsave(&hardware_lock, flags); <nl>  	/* reset UART */ <nl>  #ifdef LIRC_ON_SA1100 <nl> -#ifdef CONFIG_SA1100_BITSY <nl> -	if (machine_is_bitsy()) { <nl> -		pr_info("Power on IR module\n"); <nl> -		set_bitsy_egpio(EGPIO_BITSY_IR_ON); <nl> -	} <nl> -#endif <nl>  #ifdef CONFIG_SA1100_COLLIE <nl>  	sa1100_irda_set_power_collie(3);	/* power on */ <nl>  #endif <nl> @@ -942,10 +936,6 @@ static void drop_hardware(void) <nl>  	Ser2UTCR3 = sr.utcr3; <nl>   <nl>  	Ser2HSCR0 = sr.hscr0; <nl> -#ifdef CONFIG_SA1100_BITSY <nl> -	if (machine_is_bitsy()) <nl> -		clr_bitsy_egpio(EGPIO_BITSY_IR_ON); <nl> -#endif <nl>  #ifdef CONFIG_SA1100_COLLIE <nl>  	sa1100_irda_set_power_collie(0);	/* power off */ <nl>  #endif
@@ -1315,9 +1315,6 @@ static int srp_map_finish_fr(struct srp_map_state *state, <nl>   <nl>  	WARN_ON_ONCE(!dev->use_fast_reg); <nl>   <nl> -	if (sg_nents == 0) <nl> -		return 0; <nl> - <nl>  	if (sg_nents == 1 && target->global_mr) { <nl>  		srp_map_desc(state, sg_dma_address(state->sg), <nl>  			     sg_dma_len(state->sg), <nl> @@ -1439,6 +1436,9 @@ static int srp_map_sg_fr(struct srp_map_state *state, struct srp_rdma_ch *ch, <nl>  	state->fr.end = req->fr_list + ch->target->cmd_sg_cnt; <nl>  	state->sg = scat; <nl>   <nl> +	if (count == 0) <nl> +		return 0; <nl> + <nl>  	while (count) { <nl>  		int i, n; <nl>  
@@ -124,7 +124,7 @@ int sclp_pci_report(struct zpci_report_error_header *report, u32 fh, u32 fid) <nl>  { <nl>  	DECLARE_COMPLETION_ONSTACK(completion); <nl>  	struct err_notify_sccb *sccb; <nl> -	struct sclp_req req = {0}; <nl> +	struct sclp_req req; <nl>  	int ret; <nl>   <nl>  	ret = sclp_pci_check_report(report); <nl> @@ -147,6 +147,7 @@ int sclp_pci_report(struct zpci_report_error_header *report, u32 fh, u32 fid) <nl>  		goto out_unregister; <nl>  	} <nl>   <nl> +	memset(&req, 0, sizeof(req)); <nl>  	req.callback_data = &completion; <nl>  	req.callback = sclp_pci_callback; <nl>  	req.command = SCLP_CMDW_WRITE_EVENT_DATA;
@@ -557,13 +557,16 @@ v3d_submit_cl_ioctl(struct drm_device *dev, void *data, <nl>   <nl>  	if (args->bcl_start != args->bcl_end) { <nl>  		bin = kcalloc(1, sizeof(*bin), GFP_KERNEL); <nl> -		if (!bin) <nl> +		if (!bin) { <nl> +			v3d_job_put(&render->base); <nl>  			return -ENOMEM; <nl> +		} <nl>   <nl>  		ret = v3d_job_init(v3d, file_priv, &bin->base, <nl>  				   v3d_job_free, args->in_sync_bcl); <nl>  		if (ret) { <nl>  			v3d_job_put(&render->base); <nl> +			kfree(bin); <nl>  			return ret; <nl>  		} <nl>  
@@ -7198,7 +7198,8 @@ void init_tg_cfs_entry(struct task_group *tg, struct cfs_rq *cfs_rq, <nl>  		se->cfs_rq = parent->my_q; <nl>   <nl>  	se->my_q = cfs_rq; <nl> -	update_load_set(&se->load, 0); <nl> +	/* guarantee group entities always have weight */ <nl> +	update_load_set(&se->load, NICE_0_LOAD); <nl>  	se->parent = parent; <nl>  } <nl>  
@@ -2403,7 +2403,8 @@ static int tpacket_snd(struct packet_sock *po, struct msghdr *msg) <nl>  		} <nl>  		tp_len = tpacket_fill_skb(po, skb, ph, dev, size_max, proto, <nl>  					  addr, hlen); <nl> -		if (tp_len > dev->mtu + dev->hard_header_len) { <nl> +		if (likely(tp_len >= 0) && <nl> +		    tp_len > dev->mtu + dev->hard_header_len) { <nl>  			struct ethhdr *ehdr; <nl>  			/* Earlier code assumed this would be a VLAN pkt, <nl>  			 * double-check this now that we have the actual
@@ -316,11 +316,9 @@ static int pwm_regulator_probe(struct platform_device *pdev) <nl>  		return ret; <nl>  	} <nl>   <nl> -	/* <nl> -	 * FIXME: pwm_apply_args() should be removed when switching to the <nl> -	 * atomic PWM API. <nl> -	 */ <nl> -	pwm_apply_args(drvdata->pwm); <nl> +	ret = pwm_adjust_config(drvdata->pwm); <nl> +	if (ret) <nl> +		return ret; <nl>   <nl>  	regulator = devm_regulator_register(&pdev->dev, <nl>  					    &drvdata->desc, &config);
@@ -245,6 +245,7 @@ static void acpi_ac_notify(struct acpi_device *device, u32 event) <nl>  		acpi_bus_generate_netlink_event(device->pnp.device_class, <nl>  						  dev_name(&device->dev), event, <nl>  						  (u32) ac->state); <nl> +		acpi_notifier_call_chain(device, event, (u32) ac->state); <nl>  #ifdef CONFIG_ACPI_SYSFS_POWER <nl>  		kobject_uevent(&ac->charger.dev->kobj, KOBJ_CHANGE); <nl>  #endif
@@ -607,10 +607,8 @@ static const struct amdgpu_irq_src_funcs dm_hpd_irq_funcs = { <nl>   <nl>  void amdgpu_dm_set_irq_funcs(struct amdgpu_device *adev) <nl>  { <nl> -	if (adev->mode_info.num_crtc > 0) <nl> -		adev->crtc_irq.num_types = AMDGPU_CRTC_IRQ_VLINE1 + adev->mode_info.num_crtc; <nl> -	else <nl> -		adev->crtc_irq.num_types = 0; <nl> + <nl> +	adev->crtc_irq.num_types = adev->mode_info.num_crtc; <nl>  	adev->crtc_irq.funcs = &dm_crtc_irq_funcs; <nl>   <nl>  	adev->pageflip_irq.num_types = adev->mode_info.num_crtc;
@@ -838,7 +838,7 @@ static int __devinit at91_pinctrl_probe_dt(struct platform_device *pdev, <nl>  		return -ENODEV; <nl>   <nl>  	info->dev = &pdev->dev; <nl> -	info->ops = <nl> +	info->ops = (struct at91_pinctrl_mux_ops*) <nl>  		of_match_device(at91_pinctrl_of_match, &pdev->dev)->data; <nl>  	at91_pinctrl_child_count(info, np); <nl>   <nl> @@ -1403,7 +1403,7 @@ static int __devinit at91_gpio_probe(struct platform_device *pdev) <nl>  		goto err; <nl>  	} <nl>   <nl> -	at91_chip->ops = <nl> +	at91_chip->ops = (struct at91_pinctrl_mux_ops*) <nl>  		of_match_device(at91_gpio_of_match, &pdev->dev)->data; <nl>  	at91_chip->pioc_virq = irq; <nl>  	at91_chip->pioc_idx = alias_idx;
@@ -997,6 +997,13 @@ int dma_async_device_register(struct dma_device *device) <nl>  		} <nl>  		chan->client_count = 0; <nl>  	} <nl> + <nl> +	if (!chancnt) { <nl> +		dev_err(device->dev, "%s: device has no channels!\n", __func__); <nl> +		rc = -ENODEV; <nl> +		goto err_out; <nl> +	} <nl> + <nl>  	device->chancnt = chancnt; <nl>   <nl>  	mutex_lock(&dma_list_mutex);
@@ -160,11 +160,11 @@ nouveau_bo_new(struct drm_device *dev, struct nouveau_channel *chan, <nl>  	ret = ttm_bo_init(&dev_priv->ttm.bdev, &nvbo->bo, size, <nl>  			  ttm_bo_type_device, &nvbo->placement, align, 0, <nl>  			  false, NULL, size, nouveau_bo_del_ttm); <nl> -	nvbo->channel = NULL; <nl>  	if (ret) { <nl>  		/* ttm will call nouveau_bo_del_ttm if it fails.. */ <nl>  		return ret; <nl>  	} <nl> +	nvbo->channel = NULL; <nl>   <nl>  	spin_lock(&dev_priv->ttm.bo_list_lock); <nl>  	list_add_tail(&nvbo->head, &dev_priv->ttm.bo_list);
@@ -1161,6 +1161,13 @@ static int dso__load_sym(struct dso *self, struct map *map, const char *name, <nl>   <nl>  		section_name = elf_sec__name(&shdr, secstrs); <nl>   <nl> +		/* On ARM, symbols for thumb functions have 1 added to <nl> +		 * the symbol address as a flag - remove it */ <nl> +		if ((ehdr.e_machine == EM_ARM) && <nl> +		    (map->type == MAP__FUNCTION) && <nl> +		    (sym.st_value & 1)) <nl> +			--sym.st_value; <nl> + <nl>  		if (self->kernel != DSO_TYPE_USER || kmodule) { <nl>  			char dso_name[PATH_MAX]; <nl>  
@@ -783,6 +783,9 @@ nvmet_fc_find_target_queue(struct nvmet_fc_tgtport *tgtport, <nl>  	u16 qid = nvmet_fc_getqueueid(connection_id); <nl>  	unsigned long flags; <nl>   <nl> +	if (qid > NVMET_NR_QUEUES) <nl> +		return NULL; <nl> + <nl>  	spin_lock_irqsave(&tgtport->lock, flags); <nl>  	list_for_each_entry(assoc, &tgtport->assoc_list, a_list) { <nl>  		if (association_id == assoc->association_id) {
@@ -8709,7 +8709,7 @@ static void atomic_switch_perf_msrs(struct vcpu_vmx *vmx) <nl>  					msrs[i].host); <nl>  } <nl>   <nl> -void vmx_arm_hv_timer(struct kvm_vcpu *vcpu) <nl> +static void vmx_arm_hv_timer(struct kvm_vcpu *vcpu) <nl>  { <nl>  	struct vcpu_vmx *vmx = to_vmx(vcpu); <nl>  	u64 tscl;
@@ -351,7 +351,9 @@ static __init void parse_cmdline_early (char ** cmdline_p) <nl>  		if (!memcmp(from, "noapic", 6))  <nl>  			skip_ioapic_setup = 1; <nl>   <nl> -		if (!memcmp(from, "apic", 4)) {  <nl> +		/* Make sure to not confuse with apic= */ <nl> +		if (!memcmp(from, "apic", 4) && <nl> +			(from[4] == ' ' || from[4] == 0)) { <nl>  			skip_ioapic_setup = 0; <nl>  			ioapic_force = 1; <nl>  		}
@@ -218,7 +218,7 @@ void uncore_perf_event_update(struct intel_uncore_box *box, struct perf_event *e <nl>  	u64 prev_count, new_count, delta; <nl>  	int shift; <nl>   <nl> -	if (event->hw.idx >= UNCORE_PMC_IDX_FIXED) <nl> +	if (event->hw.idx == UNCORE_PMC_IDX_FIXED) <nl>  		shift = 64 - uncore_fixed_ctr_bits(box); <nl>  	else <nl>  		shift = 64 - uncore_perf_ctr_bits(box);
@@ -865,7 +865,7 @@ static enum dma_status sun6i_dma_tx_status(struct dma_chan *chan, <nl>  	size_t bytes = 0; <nl>   <nl>  	ret = dma_cookie_status(chan, cookie, state); <nl> -	if (ret == DMA_COMPLETE) <nl> +	if (ret == DMA_COMPLETE || !state) <nl>  		return ret; <nl>   <nl>  	spin_lock_irqsave(&vchan->vc.lock, flags);
@@ -2970,20 +2970,20 @@ void __devinit bttv_idcard(struct bttv *btv) <nl>   <nl>  	if (UNSET != audiomux[0]) { <nl>  		gpiobits = 0; <nl> -		for (i = 0; i < 4; i++) { <nl> +		for (i = 0; i < ARRAY_SIZE(bttv_tvcards->gpiomux); i++) { <nl>  			bttv_tvcards[btv->c.type].gpiomux[i] = audiomux[i]; <nl>  			gpiobits |= audiomux[i]; <nl>  		} <nl>  	} else { <nl>  		gpiobits = audioall; <nl> -		for (i = 0; i < 4; i++) { <nl> +		for (i = 0; i < ARRAY_SIZE(bttv_tvcards->gpiomux); i++) { <nl>  			bttv_tvcards[btv->c.type].gpiomux[i] = audioall; <nl>  		} <nl>  	} <nl>  	bttv_tvcards[btv->c.type].gpiomask = (UNSET != gpiomask) ? gpiomask : gpiobits; <nl>  	printk(KERN_INFO "bttv%d: gpio config override: mask=0x%x, mux=", <nl>  	       btv->c.nr,bttv_tvcards[btv->c.type].gpiomask); <nl> -	for (i = 0; i < 5; i++) { <nl> +	for (i = 0; i < ARRAY_SIZE(bttv_tvcards->gpiomux); i++) { <nl>  		printk("%s0x%x", i ? "," : "", bttv_tvcards[btv->c.type].gpiomux[i]); <nl>  	} <nl>  	printk("\n");
@@ -600,8 +600,6 @@ static int nvme_nvm_submit_user_cmd(struct request_queue *q, <nl>   <nl>  	rq->timeout = timeout ? timeout : ADMIN_TIMEOUT; <nl>   <nl> -	rq->cmd_flags &= ~REQ_FAILFAST_DRIVER; <nl> - <nl>  	if (ppa_buf && ppa_len) { <nl>  		ppa_list = dma_pool_alloc(dev->dma_pool, GFP_KERNEL, &ppa_dma); <nl>  		if (!ppa_list) {
@@ -75,14 +75,14 @@ static struct timer_list watchdog_timer; <nl>  static DEFINE_SPINLOCK(watchdog_lock); <nl>  static cycle_t watchdog_last; <nl>  /* <nl> - * Interval: 0.5sec Treshold: 0.0625s <nl> + * Interval: 0.5sec Threshold: 0.0625s <nl>   */ <nl>  #define WATCHDOG_INTERVAL (HZ >> 1) <nl> -#define WATCHDOG_TRESHOLD (NSEC_PER_SEC >> 4) <nl> +#define WATCHDOG_THRESHOLD (NSEC_PER_SEC >> 4) <nl>   <nl>  static void clocksource_ratewd(struct clocksource *cs, int64_t delta) <nl>  { <nl> -	if (delta > -WATCHDOG_TRESHOLD && delta < WATCHDOG_TRESHOLD) <nl> +	if (delta > -WATCHDOG_THRESHOLD && delta < WATCHDOG_THRESHOLD) <nl>  		return; <nl>   <nl>  	printk(KERN_WARNING "Clocksource %s unstable (delta = %Ld ns)\n",
@@ -4104,7 +4104,7 @@ static void amdgpu_dm_commit_planes(struct drm_atomic_state *state, <nl>  		} <nl>  		spin_unlock_irqrestore(&crtc->dev->event_lock, flags); <nl>   <nl> -		if (!pflip_needed) { <nl> +		if (!pflip_needed || plane->type == DRM_PLANE_TYPE_OVERLAY) { <nl>  			WARN_ON(!dm_new_plane_state->dc_state); <nl>   <nl>  			plane_states_constructed[planes_count] = dm_new_plane_state->dc_state; <nl> @@ -4827,7 +4827,8 @@ static int dm_update_planes_state(struct dc *dc, <nl>   <nl>  		/* Remove any changed/removed planes */ <nl>  		if (!enable) { <nl> -			if (pflip_needed) <nl> +			if (pflip_needed && <nl> +			    plane->type != DRM_PLANE_TYPE_OVERLAY) <nl>  				continue; <nl>   <nl>  			if (!old_plane_crtc) <nl> @@ -4874,7 +4875,8 @@ static int dm_update_planes_state(struct dc *dc, <nl>  			if (!dm_new_crtc_state->stream) <nl>  				continue; <nl>   <nl> -			if (pflip_needed) <nl> +			if (pflip_needed && <nl> +			    plane->type != DRM_PLANE_TYPE_OVERLAY) <nl>  				continue; <nl>   <nl>  			WARN_ON(dm_new_plane_state->dc_state);
@@ -136,6 +136,7 @@ static int hpfs_statfs(struct dentry *dentry, struct kstatfs *buf) <nl>  { <nl>  	struct super_block *s = dentry->d_sb; <nl>  	struct hpfs_sb_info *sbi = hpfs_sb(s); <nl> +	u64 id = huge_encode_dev(s->s_bdev->bd_dev); <nl>  	lock_kernel(); <nl>   <nl>  	/*if (sbi->sb_n_free == -1) {*/ <nl> @@ -149,6 +150,8 @@ static int hpfs_statfs(struct dentry *dentry, struct kstatfs *buf) <nl>  	buf->f_bavail = sbi->sb_n_free; <nl>  	buf->f_files = sbi->sb_dirband_size / 4; <nl>  	buf->f_ffree = sbi->sb_n_free_dnodes; <nl> +	buf->f_fsid.val[0] = (u32)id; <nl> +	buf->f_fsid.val[1] = (u32)(id >> 32); <nl>  	buf->f_namelen = 254; <nl>   <nl>  	unlock_kernel();
@@ -154,8 +154,8 @@ bool skb_flow_dissect(const struct sk_buff *skb, struct flow_keys *flow) <nl>  	if (poff >= 0) { <nl>  		__be32 *ports, _ports; <nl>   <nl> -		nhoff += poff; <nl> -		ports = skb_header_pointer(skb, nhoff, sizeof(_ports), &_ports); <nl> +		ports = skb_header_pointer(skb, nhoff + poff, <nl> +					   sizeof(_ports), &_ports); <nl>  		if (ports) <nl>  			flow->ports = *ports; <nl>  	}
@@ -1142,8 +1142,11 @@ static int ata_bus_probe(struct ata_port *ap) <nl>   <nl>  		rc = ap->ops->probe_reset(ap, classes); <nl>  		if (rc == 0) { <nl> -			for (i = 0; i < ATA_MAX_DEVICES; i++) <nl> +			for (i = 0; i < ATA_MAX_DEVICES; i++) { <nl> +				if (classes[i] == ATA_DEV_UNKNOWN) <nl> +					classes[i] = ATA_DEV_NONE; <nl>  				ap->device[i].class = classes[i]; <nl> +			} <nl>  		} else { <nl>  			printk(KERN_ERR "ata%u: probe reset failed, " <nl>  			       "disabling port\n", ap->id);
@@ -311,7 +311,7 @@ asmlinkage long sys_oabi_semtimedop(int semid, <nl>  	long err; <nl>  	int i; <nl>   <nl> -	if (nsops < 1) <nl> +	if (nsops < 1 || nsops > SEMOPM) <nl>  		return -EINVAL; <nl>  	sops = kmalloc(sizeof(*sops) * nsops, GFP_KERNEL); <nl>  	if (!sops)
@@ -3320,6 +3320,10 @@ static int rt6_fill_node(struct net *net, <nl>  int rt6_dump_route(struct rt6_info *rt, void *p_arg) <nl>  { <nl>  	struct rt6_rtnl_dump_arg *arg = (struct rt6_rtnl_dump_arg *) p_arg; <nl> +	struct net *net = arg->net; <nl> + <nl> +	if (rt == net->ipv6.ip6_null_entry) <nl> +		return 0; <nl>   <nl>  	if (nlmsg_len(arg->cb->nlh) >= sizeof(struct rtmsg)) { <nl>  		struct rtmsg *rtm = nlmsg_data(arg->cb->nlh); <nl> @@ -3332,7 +3336,7 @@ int rt6_dump_route(struct rt6_info *rt, void *p_arg) <nl>  		} <nl>  	} <nl>   <nl> -	return rt6_fill_node(arg->net, <nl> +	return rt6_fill_node(net, <nl>  		     arg->skb, rt, NULL, NULL, 0, RTM_NEWROUTE, <nl>  		     NETLINK_CB(arg->cb->skb).portid, arg->cb->nlh->nlmsg_seq, <nl>  		     NLM_F_MULTI);
@@ -47,7 +47,10 @@ DECLARE_EVENT_CLASS(writeback_work_class, <nl>  		__field(int, reason) <nl>  	), <nl>  	TP_fast_assign( <nl> -		strncpy(__entry->name, dev_name(bdi->dev), 32); <nl> +		struct device *dev = bdi->dev; <nl> +		if (!dev) <nl> +			dev = default_backing_dev_info.dev; <nl> +		strncpy(__entry->name, dev_name(dev), 32); <nl>  		__entry->nr_pages = work->nr_pages; <nl>  		__entry->sb_dev = work->sb ? work->sb->s_dev : 0; <nl>  		__entry->sync_mode = work->sync_mode;
@@ -188,8 +188,7 @@ static int pmc_core_check_read_lock_bit(void) <nl>  	u32 value; <nl>   <nl>  	value = pmc_core_reg_read(pmcdev, SPT_PMC_PM_CFG_OFFSET); <nl> -	return test_bit(SPT_PMC_READ_DISABLE_BIT, <nl> -			(unsigned long *)&value); <nl> +	return value & BIT(SPT_PMC_READ_DISABLE_BIT); <nl>  } <nl>   <nl>  #if IS_ENABLED(CONFIG_DEBUG_FS) <nl> @@ -238,8 +237,7 @@ static int pmc_core_mtpmc_link_status(void) <nl>  	u32 value; <nl>   <nl>  	value = pmc_core_reg_read(pmcdev, SPT_PMC_PM_STS_OFFSET); <nl> -	return test_bit(SPT_PMC_MSG_FULL_STS_BIT, <nl> -			(unsigned long *)&value); <nl> +	return value & BIT(SPT_PMC_MSG_FULL_STS_BIT); <nl>  } <nl>   <nl>  static int pmc_core_send_msg(u32 *addr_xram)
@@ -541,9 +541,11 @@ void kvm_timer_vcpu_put(struct kvm_vcpu *vcpu) <nl>  	 * The kernel may decide to run userspace after calling vcpu_put, so <nl>  	 * we reset cntvoff to 0 to ensure a consistent read between user <nl>  	 * accesses to the virtual counter and kernel access to the physical <nl> -	 * counter. <nl> +	 * counter of non-VHE case. For VHE, the virtual counter uses a fixed <nl> +	 * virtual offset of zero, so no need to zero CNTVOFF_EL2 register. <nl>  	 */ <nl> -	set_cntvoff(0); <nl> +	if (!has_vhe()) <nl> +		set_cntvoff(0); <nl>  } <nl>   <nl>  /*
@@ -572,6 +572,9 @@ static int dgap_init_one(struct pci_dev *pdev, const struct pci_device_id *ent) <nl>  { <nl>  	int rc; <nl>   <nl> +	if (dgap_NumBoards >= MAXBOARDS) <nl> +		return -EPERM; <nl> + <nl>  	/* wake up and enable device */ <nl>  	rc = pci_enable_device(pdev); <nl>  
@@ -383,7 +383,7 @@ static int alps_input_configured(struct hid_device *hdev, struct hid_input *hi) <nl>   <nl>  		input2 = input_allocate_device(); <nl>  		if (!input2) { <nl> -			input_free_device(input2); <nl> +			ret = -ENOMEM; <nl>  			goto exit; <nl>  		} <nl>   <nl> @@ -425,7 +425,8 @@ static int alps_input_configured(struct hid_device *hdev, struct hid_input *hi) <nl>  		__set_bit(INPUT_PROP_POINTER, input2->propbit); <nl>  		__set_bit(INPUT_PROP_POINTING_STICK, input2->propbit); <nl>   <nl> -		if (input_register_device(data->input2)) { <nl> +		ret = input_register_device(data->input2); <nl> +		if (ret) { <nl>  			input_free_device(input2); <nl>  			goto exit; <nl>  		}
@@ -2401,6 +2401,10 @@ static int skl_manifest_load(struct snd_soc_component *cmpnt, <nl>  	struct skl *skl = ebus_to_skl(ebus); <nl>  	int ret = 0; <nl>   <nl> +	/* proceed only if we have private data defined */ <nl> +	if (manifest->priv.size == 0) <nl> +		return 0; <nl> + <nl>  	minfo = &skl->skl_sst->manifest; <nl>   <nl>  	skl_tplg_get_manifest_data(manifest, bus->dev, minfo);
@@ -507,7 +507,7 @@ void rt2x00lib_txdone(struct queue_entry *entry, <nl>  	 * Update TX statistics. <nl>  	 */ <nl>  	rt2x00dev->link.qual.tx_success += success; <nl> -	rt2x00dev->link.qual.tx_failed += txdesc->retry + fail; <nl> +	rt2x00dev->link.qual.tx_failed += fail; <nl>   <nl>  	/* <nl>  	 * Initialize TX status
@@ -818,7 +818,7 @@ static int qlcnic_82xx_setup_intr(struct qlcnic_adapter *adapter) <nl>  			qlcnic_disable_multi_tx(adapter); <nl>   <nl>  			err = qlcnic_enable_msi_legacy(adapter); <nl> -			if (!err) <nl> +			if (err) <nl>  				return err; <nl>  		} <nl>  	}
@@ -3069,13 +3069,15 @@ static int packet_do_bind(struct sock *sk, const char *name, int ifindex, <nl>  	int ret = 0; <nl>  	bool unlisted = false; <nl>   <nl> -	if (po->fanout) <nl> -		return -EINVAL; <nl> - <nl>  	lock_sock(sk); <nl>  	spin_lock(&po->bind_lock); <nl>  	rcu_read_lock(); <nl>   <nl> +	if (po->fanout) { <nl> +		ret = -EINVAL; <nl> +		goto out_unlock; <nl> +	} <nl> + <nl>  	if (name) { <nl>  		dev = dev_get_by_name_rcu(sock_net(sk), name); <nl>  		if (!dev) {
@@ -95,6 +95,7 @@ static int pvc_getname(struct socket *sock, struct sockaddr *sockaddr, <nl>  		return -ENOTCONN; <nl>  	*sockaddr_len = sizeof(struct sockaddr_atmpvc); <nl>  	addr = (struct sockaddr_atmpvc *)sockaddr; <nl> +	memset(addr, 0, sizeof(*addr)); <nl>  	addr->sap_family = AF_ATMPVC; <nl>  	addr->sap_addr.itf = vcc->dev->number; <nl>  	addr->sap_addr.vpi = vcc->vpi;
@@ -375,6 +375,8 @@ static void ntb_netdev_remove(struct pci_dev *pdev) <nl>  	if (dev == NULL) <nl>  		return; <nl>   <nl> +	list_del(&dev->list); <nl> + <nl>  	ndev = dev->ndev; <nl>   <nl>  	unregister_netdev(ndev);
@@ -701,7 +701,7 @@ static void vnt_bss_info_changed(struct ieee80211_hw *hw, <nl>   <nl>  	priv->current_aid = conf->aid; <nl>   <nl> -	if (changed & BSS_CHANGED_BSSID) <nl> +	if (changed & BSS_CHANGED_BSSID && conf->bssid) <nl>  		vnt_mac_set_bssid_addr(priv, (u8 *)conf->bssid); <nl>   <nl>  
@@ -148,7 +148,7 @@ static void slc_bump(struct slcan *sl) <nl>  	u32 tmpid; <nl>  	char *cmd = sl->rbuff; <nl>   <nl> -	cf.can_id = 0; <nl> +	memset(&cf, 0, sizeof(cf)); <nl>   <nl>  	switch (*cmd) { <nl>  	case 'r': <nl> @@ -187,8 +187,6 @@ static void slc_bump(struct slcan *sl) <nl>  	else <nl>  		return; <nl>   <nl> -	*(u64 *) (&cf.data) = 0; /* clear payload */ <nl> - <nl>  	/* RTR frames may have a dlc > 0 but they never have any data bytes */ <nl>  	if (!(cf.can_id & CAN_RTR_FLAG)) { <nl>  		for (i = 0; i < cf.can_dlc; i++) {
@@ -958,6 +958,14 @@ static int vidioc_streamoff(struct file *file, void *priv, enum v4l2_buf_type i) <nl>  	return vb2_streamoff(&dev->vb_vidq, i); <nl>  } <nl>   <nl> +static int vidioc_log_status(struct file *file, void *priv) <nl> +{ <nl> +	struct vivi_dev *dev = video_drvdata(file); <nl> + <nl> +	v4l2_ctrl_handler_log_status(&dev->ctrl_handler, dev->v4l2_dev.name); <nl> +	return 0; <nl> +} <nl> + <nl>  static int vidioc_s_std(struct file *file, void *priv, v4l2_std_id *i) <nl>  { <nl>  	return 0; <nl> @@ -1201,6 +1209,7 @@ static const struct v4l2_ioctl_ops vivi_ioctl_ops = { <nl>  	.vidioc_s_input       = vidioc_s_input, <nl>  	.vidioc_streamon      = vidioc_streamon, <nl>  	.vidioc_streamoff     = vidioc_streamoff, <nl> +	.vidioc_log_status    = vidioc_log_status, <nl>  	.vidioc_subscribe_event = vidioc_subscribe_event, <nl>  	.vidioc_unsubscribe_event = v4l2_event_unsubscribe, <nl>  };
@@ -2378,7 +2378,7 @@ int vb2_mmap(struct vb2_queue *q, struct vm_area_struct *vma) <nl>  { <nl>  	unsigned long off = vma->vm_pgoff << PAGE_SHIFT; <nl>  	struct vb2_buffer *vb; <nl> -	unsigned int buffer, plane; <nl> +	unsigned int buffer = 0, plane = 0; <nl>  	int ret; <nl>  	unsigned long length; <nl>  
@@ -5942,13 +5942,12 @@ xfs_bmse_merge( <nl>  	xfs_iext_update_extent(ifp, current_ext - 1, &new); <nl>  	xfs_iext_remove(ip, current_ext, 1, 0); <nl>   <nl> -	/* update reverse mapping */ <nl> +	/* update reverse mapping. rmap functions merge the rmaps for us */ <nl>  	error = xfs_rmap_unmap_extent(mp, dfops, ip, whichfork, got); <nl>  	if (error) <nl>  		return error; <nl> -	error = xfs_rmap_unmap_extent(mp, dfops, ip, whichfork, left); <nl> -	if (error) <nl> -		return error; <nl> +	memcpy(&new, got, sizeof(new)); <nl> +	new.br_startoff = left->br_startoff + left->br_blockcount; <nl>  	return xfs_rmap_map_extent(mp, dfops, ip, whichfork, &new); <nl>  } <nl>  
@@ -769,8 +769,8 @@ static void log_refund(struct gfs2_sbd *sdp, struct gfs2_trans *tr) <nl>  	sdp->sd_log_commited_revoke += tr->tr_num_revoke - tr->tr_num_revoke_rm; <nl>  	gfs2_assert_withdraw(sdp, ((int)sdp->sd_log_commited_revoke) >= 0); <nl>  	reserved = calc_reserved(sdp); <nl> +	gfs2_assert_withdraw(sdp, sdp->sd_log_blks_reserved + tr->tr_reserved >= reserved); <nl>  	unused = sdp->sd_log_blks_reserved - reserved + tr->tr_reserved; <nl> -	gfs2_assert_withdraw(sdp, unused >= 0); <nl>  	atomic_add(unused, &sdp->sd_log_blks_free); <nl>  	gfs2_assert_withdraw(sdp, atomic_read(&sdp->sd_log_blks_free) <= <nl>  			     sdp->sd_jdesc->jd_blocks);
@@ -1564,6 +1564,10 @@ int test_range_bit(struct extent_io_tree *tree, u64 start, u64 end, <nl>  			bitset = 0; <nl>  			break; <nl>  		} <nl> + <nl> +		if (state->end == (u64)-1) <nl> +			break; <nl> + <nl>  		start = state->end + 1; <nl>  		if (start > end) <nl>  			break;
@@ -2635,6 +2635,7 @@ process_hex(struct event_format *event, struct print_arg *arg, char **tok) <nl>   <nl>  free_field: <nl>  	free_arg(arg->hex.field); <nl> +	arg->hex.field = NULL; <nl>  out: <nl>  	*tok = NULL; <nl>  	return EVENT_ERROR; <nl> @@ -2659,8 +2660,10 @@ process_int_array(struct event_format *event, struct print_arg *arg, char **tok) <nl>   <nl>  free_size: <nl>  	free_arg(arg->int_array.count); <nl> +	arg->int_array.count = NULL; <nl>  free_field: <nl>  	free_arg(arg->int_array.field); <nl> +	arg->int_array.field = NULL; <nl>  out: <nl>  	*tok = NULL; <nl>  	return EVENT_ERROR;
@@ -205,9 +205,9 @@ int evm_update_evmxattr(struct dentry *dentry, const char *xattr_name, <nl>  		rc = __vfs_setxattr_noperm(dentry, XATTR_NAME_EVM, <nl>  					   &xattr_data, <nl>  					   sizeof(xattr_data), 0); <nl> -	} <nl> -	else if (rc == -ENODATA) <nl> +	} else if (rc == -ENODATA && inode->i_op->removexattr) { <nl>  		rc = inode->i_op->removexattr(dentry, XATTR_NAME_EVM); <nl> +	} <nl>  	return rc; <nl>  } <nl>  
@@ -110,6 +110,10 @@ int hns_roce_uar_alloc(struct hns_roce_dev *hr_dev, struct hns_roce_uar *uar) <nl>  			     (hr_dev->caps.phy_num_uars - 1) + 1; <nl>   <nl>  	res = platform_get_resource(hr_dev->pdev, IORESOURCE_MEM, 0); <nl> +	if (!res) { <nl> +		dev_err(&hr_dev->pdev->dev, "memory resource not found!\n"); <nl> +		return -EINVAL; <nl> +	} <nl>  	uar->pfn = ((res->start) >> PAGE_SHIFT) + uar->index; <nl>   <nl>  	return 0;
@@ -150,7 +150,7 @@ static inline bool kvm_apic_vid_enabled(struct kvm *kvm) <nl>   <nl>  static inline bool kvm_apic_has_events(struct kvm_vcpu *vcpu) <nl>  { <nl> -	return vcpu->arch.apic->pending_events; <nl> +	return kvm_vcpu_has_lapic(vcpu) && vcpu->arch.apic->pending_events; <nl>  } <nl>   <nl>  static inline bool kvm_lowest_prio_delivery(struct kvm_lapic_irq *irq)
@@ -317,6 +317,7 @@ static ssize_t hiddev_read(struct file * file, char __user * buffer, size_t coun <nl>  				} <nl>   <nl>  				schedule(); <nl> +				set_current_state(TASK_INTERRUPTIBLE); <nl>  			} <nl>   <nl>  			set_current_state(TASK_RUNNING);
@@ -92,8 +92,8 @@ static int min_bytes_needed(unsigned long val) <nl>  static int format_register_str(struct snd_soc_codec *codec, <nl>  			       unsigned int reg, char *buf, size_t len) <nl>  { <nl> -	int wordsize = codec->driver->reg_word_size * 2; <nl> -	int regsize = min_bytes_needed(codec->driver->reg_cache_size) * 2; <nl> +	int wordsize = min_bytes_needed(codec->driver->reg_cache_size) * 2; <nl> +	int regsize = codec->driver->reg_word_size * 2; <nl>  	int ret; <nl>  	char tmpbuf[len + 1]; <nl>  	char regbuf[regsize + 1]; <nl> @@ -132,8 +132,8 @@ static ssize_t soc_codec_reg_show(struct snd_soc_codec *codec, char *buf, <nl>  	size_t total = 0; <nl>  	loff_t p = 0; <nl>   <nl> -	wordsize = codec->driver->reg_word_size * 2; <nl> -	regsize = min_bytes_needed(codec->driver->reg_cache_size) * 2; <nl> +	wordsize = min_bytes_needed(codec->driver->reg_cache_size) * 2; <nl> +	regsize = codec->driver->reg_word_size * 2; <nl>   <nl>  	len = wordsize + regsize + 2 + 1; <nl>  
@@ -1376,13 +1376,13 @@ static void orinoco_process_scan_results(struct work_struct *work) <nl>   <nl>  	spin_lock_irqsave(&priv->scan_lock, flags); <nl>  	list_for_each_entry_safe(sd, temp, &priv->scan_list, list) { <nl> -		spin_unlock_irqrestore(&priv->scan_lock, flags); <nl>   <nl>  		buf = sd->buf; <nl>  		len = sd->len; <nl>  		type = sd->type; <nl>   <nl>  		list_del(&sd->list); <nl> +		spin_unlock_irqrestore(&priv->scan_lock, flags); <nl>  		kfree(sd); <nl>   <nl>  		if (len > 0) {
@@ -238,7 +238,7 @@ static int overlay_set_addr(struct mmp_overlay *overlay, struct mmp_addr *addr) <nl>  	struct lcd_regs *regs = path_regs(overlay->path); <nl>   <nl>  	/* FIXME: assert addr supported */ <nl> -	memcpy(&overlay->addr, addr, sizeof(struct mmp_win)); <nl> +	memcpy(&overlay->addr, addr, sizeof(struct mmp_addr)); <nl>  	writel(addr->phys[0], &regs->g_0); <nl>   <nl>  	return overlay->addr.phys[0];
@@ -295,11 +295,14 @@ static void sas_discover_domain(struct work_struct *work) <nl>  	case FANOUT_DEV: <nl>  		error = sas_discover_root_expander(dev); <nl>  		break; <nl> -#ifdef CONFIG_SCSI_SAS_ATA <nl>  	case SATA_DEV: <nl>  	case SATA_PM: <nl> +#ifdef CONFIG_SCSI_SAS_ATA <nl>  		error = sas_discover_sata(dev); <nl>  		break; <nl> +#else <nl> +		SAS_DPRINTK("ATA device seen but CONFIG_SCSI_SAS_ATA=N so cannot attach\n"); <nl> +		/* Fall through */ <nl>  #endif <nl>  	default: <nl>  		error = -ENXIO;
@@ -121,6 +121,9 @@ static int __sock_diag_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh) <nl>  	if (nlmsg_len(nlh) < sizeof(*req)) <nl>  		return -EINVAL; <nl>   <nl> +	if (req->sdiag_family >= AF_MAX) <nl> +		return -EINVAL; <nl> + <nl>  	hndl = sock_diag_lock_handler(req->sdiag_family); <nl>  	if (hndl == NULL) <nl>  		err = -ENOENT;
@@ -258,7 +258,7 @@ void __init init_extra_mapping_uc(unsigned long phys, unsigned long size) <nl>  void __init cleanup_highmap(void) <nl>  { <nl>  	unsigned long vaddr = __START_KERNEL_map; <nl> -	unsigned long end = round_up((unsigned long)_end, PMD_SIZE) - 1; <nl> +	unsigned long end = roundup((unsigned long)_end, PMD_SIZE) - 1; <nl>  	pmd_t *pmd = level2_kernel_pgt; <nl>  	pmd_t *last_pmd = pmd + PTRS_PER_PMD; <nl>   <nl> @@ -474,14 +474,14 @@ static void __init find_early_table_space(unsigned long end) <nl>  	unsigned long puds, pmds, ptes, tables, start; <nl>   <nl>  	puds = (end + PUD_SIZE - 1) >> PUD_SHIFT; <nl> -	tables = round_up(puds * sizeof(pud_t), PAGE_SIZE); <nl> +	tables = roundup(puds * sizeof(pud_t), PAGE_SIZE); <nl>  	if (direct_gbpages) { <nl>  		unsigned long extra; <nl>  		extra = end - ((end>>PUD_SHIFT) << PUD_SHIFT); <nl>  		pmds = (extra + PMD_SIZE - 1) >> PMD_SHIFT; <nl>  	} else <nl>  		pmds = (end + PMD_SIZE - 1) >> PMD_SHIFT; <nl> -	tables += round_up(pmds * sizeof(pmd_t), PAGE_SIZE); <nl> +	tables += roundup(pmds * sizeof(pmd_t), PAGE_SIZE); <nl>   <nl>  	if (cpu_has_pse) { <nl>  		unsigned long extra; <nl> @@ -489,7 +489,7 @@ static void __init find_early_table_space(unsigned long end) <nl>  		ptes = (extra + PAGE_SIZE - 1) >> PAGE_SHIFT; <nl>  	} else <nl>  		ptes = (end + PAGE_SIZE - 1) >> PAGE_SHIFT; <nl> -	tables += round_up(ptes * sizeof(pte_t), PAGE_SIZE); <nl> +	tables += roundup(ptes * sizeof(pte_t), PAGE_SIZE); <nl>   <nl>  	/* <nl>  	 * RED-PEN putting page tables only on node 0 could
@@ -1552,8 +1552,8 @@ cifs_setlk(struct file *file, struct file_lock *flock, __u32 type, <nl>  		rc = server->ops->mand_unlock_range(cfile, flock, xid); <nl>   <nl>  out: <nl> -	if (flock->fl_flags & FL_POSIX) <nl> -		posix_lock_file_wait(file, flock); <nl> +	if (flock->fl_flags & FL_POSIX && !rc) <nl> +		rc = posix_lock_file_wait(file, flock); <nl>  	return rc; <nl>  } <nl>  
@@ -454,7 +454,7 @@ static int crypto_authenc_verify(struct aead_request *req, <nl>  	unsigned int authsize; <nl>   <nl>  	areq_ctx->complete = authenc_verify_ahash_done; <nl> -	areq_ctx->complete = authenc_verify_ahash_update_done; <nl> +	areq_ctx->update_complete = authenc_verify_ahash_update_done; <nl>   <nl>  	ohash = authenc_ahash_fn(req, CRYPTO_TFM_REQ_MAY_SLEEP); <nl>  	if (IS_ERR(ohash))
@@ -102,6 +102,7 @@ static void __init clk_sp810_of_setup(struct device_node *node) <nl>   <nl>  	if (of_clk_parent_fill(node, parent_names, num) != num) { <nl>  		pr_warn("Failed to obtain parent clocks for SP810!\n"); <nl> +		kfree(sp810); <nl>  		return; <nl>  	} <nl>  
@@ -3689,7 +3689,7 @@ iscsi_if_rx(struct sk_buff *skb) <nl>  		uint32_t group; <nl>   <nl>  		nlh = nlmsg_hdr(skb); <nl> -		if (nlh->nlmsg_len < sizeof(*nlh) || <nl> +		if (nlh->nlmsg_len < sizeof(*nlh) + sizeof(*ev) || <nl>  		    skb->len < nlh->nlmsg_len) { <nl>  			break; <nl>  		}
@@ -1275,6 +1275,10 @@ static int f2fs_write_data_pages(struct address_space *mapping, <nl>  	if (!mapping->a_ops->writepage) <nl>  		return 0; <nl>   <nl> +	/* skip writing if there is no dirty page in this inode */ <nl> +	if (!get_dirty_pages(inode) && wbc->sync_mode == WB_SYNC_NONE) <nl> +		return 0; <nl> + <nl>  	if (S_ISDIR(inode->i_mode) && wbc->sync_mode == WB_SYNC_NONE && <nl>  			get_dirty_pages(inode) < nr_pages_to_skip(sbi, DATA) && <nl>  			available_free_memory(sbi, DIRTY_DENTS))
@@ -374,6 +374,8 @@ static int nvme_submit_io(struct nvme_ns *ns, struct nvme_user_io __user *uio) <nl>   <nl>  	if (copy_from_user(&io, uio, sizeof(io))) <nl>  		return -EFAULT; <nl> +	if (io.flags) <nl> +		return -EINVAL; <nl>   <nl>  	switch (io.opcode) { <nl>  	case nvme_cmd_write: <nl> @@ -425,6 +427,8 @@ static int nvme_user_cmd(struct nvme_ctrl *ctrl, struct nvme_ns *ns, <nl>  		return -EACCES; <nl>  	if (copy_from_user(&cmd, ucmd, sizeof(cmd))) <nl>  		return -EFAULT; <nl> +	if (cmd.flags) <nl> +		return -EINVAL; <nl>   <nl>  	memset(&c, 0, sizeof(c)); <nl>  	c.common.opcode = cmd.opcode;
@@ -473,7 +473,7 @@ static int radeon_uvd_cs_reloc(struct radeon_cs_parser *p, <nl>  		return -EINVAL; <nl>  	} <nl>   <nl> -	if ((start >> 28) != (end >> 28)) { <nl> +	if ((start >> 28) != ((end - 1) >> 28)) { <nl>  		DRM_ERROR("reloc %LX-%LX crossing 256MB boundary!\n", <nl>  			  start, end); <nl>  		return -EINVAL;
@@ -133,7 +133,12 @@ void __init omap_detect_sram(void) <nl>  			if (cpu_is_omap34xx()) { <nl>  				omap_sram_base = OMAP3_SRAM_PUB_VA; <nl>  				omap_sram_start = OMAP3_SRAM_PUB_PA; <nl> -				omap_sram_size = 0x8000; /* 32K */ <nl> +				if ((omap_type() == OMAP2_DEVICE_TYPE_EMU) || <nl> +				    (omap_type() == OMAP2_DEVICE_TYPE_SEC)) { <nl> +					omap_sram_size = 0x7000; /* 28K */ <nl> +				} else { <nl> +					omap_sram_size = 0x8000; /* 32K */ <nl> +				} <nl>  			} else { <nl>  				omap_sram_base = OMAP2_SRAM_PUB_VA; <nl>  				omap_sram_start = OMAP2_SRAM_PUB_PA;
@@ -3995,7 +3995,11 @@ static int btrfs_real_readdir(struct file *filp, void *dirent, <nl>   <nl>  	/* Reached end of directory/root. Bump pos past the last item. */ <nl>  	if (key_type == BTRFS_DIR_INDEX_KEY) <nl> -		filp->f_pos = INT_LIMIT(off_t); <nl> +		/* <nl> +		 * 32-bit glibc will use getdents64, but then strtol - <nl> +		 * so the last number we can serve is this. <nl> +		 */ <nl> +		filp->f_pos = 0x7fffffff; <nl>  	else <nl>  		filp->f_pos++; <nl>  nopos:
@@ -4317,6 +4317,8 @@ static void __init cgroup_init_subsys(struct cgroup_subsys *ss) <nl>   <nl>  	printk(KERN_INFO "Initializing cgroup subsys %s\n", ss->name); <nl>   <nl> +	mutex_lock(&cgroup_mutex); <nl> + <nl>  	/* init base cftset */ <nl>  	cgroup_init_cftsets(ss); <nl>   <nl> @@ -4346,6 +4348,8 @@ static void __init cgroup_init_subsys(struct cgroup_subsys *ss) <nl>  	if (ss->post_create) <nl>  		ss->post_create(dummytop); <nl>   <nl> +	mutex_unlock(&cgroup_mutex); <nl> + <nl>  	/* this function shouldn't be used with modular subsystems, since they <nl>  	 * need to register a subsys_id, among other things */ <nl>  	BUG_ON(ss->module);
@@ -436,7 +436,7 @@ static int __devinit tegra_gpio_probe(struct platform_device *pdev) <nl>  		return -ENODEV; <nl>  	} <nl>   <nl> -	for (i = 0; i < 7; i++) { <nl> +	for (i = 0; i < tegra_gpio_bank_count; i++) { <nl>  		for (j = 0; j < 4; j++) { <nl>  			int gpio = tegra_gpio_compose(i, j, 0); <nl>  			tegra_gpio_writel(0x00, GPIO_INT_ENB(gpio)); <nl> @@ -514,7 +514,7 @@ static int dbg_gpio_show(struct seq_file *s, void *unused) <nl>  	int i; <nl>  	int j; <nl>   <nl> -	for (i = 0; i < 7; i++) { <nl> +	for (i = 0; i < tegra_gpio_bank_count; i++) { <nl>  		for (j = 0; j < 4; j++) { <nl>  			int gpio = tegra_gpio_compose(i, j, 0); <nl>  			seq_printf(s,
@@ -1050,6 +1050,7 @@ static int sc16is7xx_probe(struct device *dev, <nl>  		else <nl>  			return PTR_ERR(s->clk); <nl>  	} else { <nl> +		clk_prepare_enable(s->clk); <nl>  		freq = clk_get_rate(s->clk); <nl>  	} <nl>  
@@ -307,7 +307,8 @@ static void udf_sb_free_partitions(struct super_block *sb) <nl>  { <nl>  	struct udf_sb_info *sbi = UDF_SB(sb); <nl>  	int i; <nl> - <nl> +	if (sbi->s_partmaps == NULL) <nl> +		return; <nl>  	for (i = 0; i < sbi->s_partitions; i++) <nl>  		udf_free_partition(&sbi->s_partmaps[i]); <nl>  	kfree(sbi->s_partmaps);
@@ -1328,6 +1328,8 @@ static int iucv_sock_recvmsg(struct kiocb *iocb, struct socket *sock, <nl>  	struct sk_buff *skb, *rskb, *cskb; <nl>  	int err = 0; <nl>   <nl> +	msg->msg_namelen = 0; <nl> + <nl>  	if ((sk->sk_state == IUCV_DISCONN) && <nl>  	    skb_queue_empty(&iucv->backlog_skb_q) && <nl>  	    skb_queue_empty(&sk->sk_receive_queue) &&
@@ -408,7 +408,7 @@ static void efifb_fixup_resources(struct pci_dev *dev) <nl>  	if (!base) <nl>  		return; <nl>   <nl> -	for (i = 0; i < PCI_STD_RESOURCE_END; i++) { <nl> +	for (i = 0; i <= PCI_STD_RESOURCE_END; i++) { <nl>  		struct resource *res = &dev->resource[i]; <nl>   <nl>  		if (!(res->flags & IORESOURCE_MEM))
@@ -168,6 +168,11 @@ int hfsplus_find_cat(struct super_block *sb, u32 cnid, <nl>  		return -EIO; <nl>  	} <nl>   <nl> +	if (be16_to_cpu(tmp.thread.nodeName.length) > 255) { <nl> +		printk(KERN_ERR "hfs: catalog name length corrupted\n"); <nl> +		return -EIO; <nl> +	} <nl> + <nl>  	hfsplus_cat_build_key_uni(fd->search_key, be32_to_cpu(tmp.thread.parentID), <nl>  				 &tmp.thread.nodeName); <nl>  	return hfs_brec_find(fd);
@@ -218,7 +218,7 @@ int cfg80211_validate_key_settings(struct cfg80211_registered_device *rdev, <nl>  				   struct key_params *params, int key_idx, <nl>  				   bool pairwise, const u8 *mac_addr) <nl>  { <nl> -	if (key_idx > 5) <nl> +	if (key_idx < 0 || key_idx > 5) <nl>  		return -EINVAL; <nl>   <nl>  	if (!pairwise && mac_addr && !(rdev->wiphy.flags & WIPHY_FLAG_IBSS_RSN)) <nl> @@ -249,7 +249,13 @@ int cfg80211_validate_key_settings(struct cfg80211_registered_device *rdev, <nl>  		/* Disallow BIP (group-only) cipher as pairwise cipher */ <nl>  		if (pairwise) <nl>  			return -EINVAL; <nl> +		if (key_idx < 4) <nl> +			return -EINVAL; <nl>  		break; <nl> +	case WLAN_CIPHER_SUITE_WEP40: <nl> +	case WLAN_CIPHER_SUITE_WEP104: <nl> +		if (key_idx > 3) <nl> +			return -EINVAL; <nl>  	default: <nl>  		break; <nl>  	}
@@ -2529,7 +2529,8 @@ static int parse_tc_fdb_actions(struct mlx5e_priv *priv, struct tcf_exts *exts, <nl>  			if (tcf_vlan_action(a) == TCA_VLAN_ACT_POP) { <nl>  				attr->action |= MLX5_FLOW_CONTEXT_ACTION_VLAN_POP; <nl>  			} else if (tcf_vlan_action(a) == TCA_VLAN_ACT_PUSH) { <nl> -				if (tcf_vlan_push_proto(a) != htons(ETH_P_8021Q)) <nl> +				if (tcf_vlan_push_proto(a) != htons(ETH_P_8021Q) || <nl> +				    tcf_vlan_push_prio(a)) <nl>  					return -EOPNOTSUPP; <nl>   <nl>  				attr->action |= MLX5_FLOW_CONTEXT_ACTION_VLAN_PUSH;
@@ -875,7 +875,7 @@ static int atmel_hlcdc_plane_init_properties(struct atmel_hlcdc_plane *plane, <nl>  		drm_object_attach_property(&plane->base.base, <nl>  					   props->alpha, 255); <nl>   <nl> -	if (desc->layout.xstride && desc->layout.pstride) { <nl> +	if (desc->layout.xstride[0] && desc->layout.pstride[0]) { <nl>  		int ret; <nl>   <nl>  		ret = drm_plane_create_rotation_property(&plane->base,
@@ -999,8 +999,8 @@ static int cs53l30_i2c_probe(struct i2c_client *client, <nl>  	/* Check if MCLK provided */ <nl>  	cs53l30->mclk = devm_clk_get(dev, "mclk"); <nl>  	if (IS_ERR(cs53l30->mclk)) { <nl> -		if (PTR_ERR(cs53l30->mclk) == -EPROBE_DEFER) { <nl> -			ret = -EPROBE_DEFER; <nl> +		if (PTR_ERR(cs53l30->mclk) != -ENOENT) { <nl> +			ret = PTR_ERR(cs53l30->mclk); <nl>  			goto error; <nl>  		} <nl>  		/* Otherwise mark the mclk pointer to NULL */
@@ -166,6 +166,10 @@ static int si2157_init(struct dvb_frontend *fe) <nl>   <nl>  	for (remaining = fw->size; remaining > 0; remaining -= 17) { <nl>  		len = fw->data[fw->size - remaining]; <nl> +		if (len > SI2157_ARGLEN) { <nl> +			dev_err(&client->dev, "Bad firmware length\n"); <nl> +			goto err_release_firmware; <nl> +		} <nl>  		memcpy(cmd.args, &fw->data[(fw->size - remaining) + 1], len); <nl>  		cmd.wlen = len; <nl>  		cmd.rlen = 1;
@@ -531,6 +531,8 @@ static void _rtl_usb_rx_process_noagg(struct ieee80211_hw *hw, <nl>  			ieee80211_rx(hw, skb); <nl>  		else <nl>  			dev_kfree_skb_any(skb); <nl> +	} else { <nl> +		dev_kfree_skb_any(skb); <nl>  	} <nl>  } <nl>  
@@ -1173,7 +1173,7 @@ static int nr_recvmsg(struct kiocb *iocb, struct socket *sock, <nl>  	} <nl>   <nl>  	if (sax != NULL) { <nl> -		memset(sax, 0, sizeof(sax)); <nl> +		memset(sax, 0, sizeof(*sax)); <nl>  		sax->sax25_family = AF_NETROM; <nl>  		skb_copy_from_linear_data_offset(skb, 7, sax->sax25_call.ax25_call, <nl>  			      AX25_ADDR_LEN);
@@ -2030,7 +2030,6 @@ static int replace_map_fd_with_map_ptr(struct verifier_env *env) <nl>  			if (IS_ERR(map)) { <nl>  				verbose("fd %d is not pointing to valid bpf_map\n", <nl>  					insn->imm); <nl> -				fdput(f); <nl>  				return PTR_ERR(map); <nl>  			} <nl>  
@@ -50,7 +50,7 @@ static bool acpi_video_caps_checked; <nl>   <nl>  static acpi_status <nl>  acpi_backlight_cap_match(acpi_handle handle, u32 level, void *context, <nl> -			  void **retyurn_value) <nl> +			  void **return_value) <nl>  { <nl>  	long *cap = context; <nl>  
@@ -3615,6 +3615,7 @@ static int decode_attr_fs_locations(struct xdr_stream *xdr, uint32_t *bitmap, st <nl>  	status = 0; <nl>  	if (unlikely(!(bitmap[0] & FATTR4_WORD0_FS_LOCATIONS))) <nl>  		goto out; <nl> +	bitmap[0] &= ~FATTR4_WORD0_FS_LOCATIONS; <nl>  	status = -EIO; <nl>  	/* Ignore borken servers that return unrequested attrs */ <nl>  	if (unlikely(res == NULL))
@@ -3389,6 +3389,8 @@ int btrfs_read_chunk_tree(struct btrfs_root *root) <nl>  	key.type = 0; <nl>  again: <nl>  	ret = btrfs_search_slot(NULL, root, &key, path, 0, 0); <nl> +	if (ret < 0) <nl> +		goto error; <nl>  	while (1) { <nl>  		leaf = path->nodes[0]; <nl>  		slot = path->slots[0];
@@ -1819,8 +1819,8 @@ uart_get_console(struct uart_port *ports, int nr, struct console *co) <nl>   *	@options: ptr for <options> field; NULL if not present (out) <nl>   * <nl>   *	Decodes earlycon kernel command line parameters of the form <nl> - *	   earlycon=<name>,io|mmio|mmio32|mmio32be,<addr>,<options> <nl> - *	   console=<name>,io|mmio|mmio32|mmio32be,<addr>,<options> <nl> + *	   earlycon=<name>,io|mmio|mmio32|mmio32be|mmio32native,<addr>,<options> <nl> + *	   console=<name>,io|mmio|mmio32|mmio32be|mmio32native,<addr>,<options> <nl>   * <nl>   *	The optional form <nl>   *	   earlycon=<name>,0x<addr>,<options> <nl> @@ -1841,6 +1841,10 @@ int uart_parse_earlycon(char *p, unsigned char *iotype, unsigned long *addr, <nl>  	} else if (strncmp(p, "mmio32be,", 9) == 0) { <nl>  		*iotype = UPIO_MEM32BE; <nl>  		p += 9; <nl> +	} else if (strncmp(p, "mmio32native,", 13) == 0) { <nl> +		*iotype = IS_ENABLED(CONFIG_CPU_BIG_ENDIAN) ? <nl> +			UPIO_MEM32BE : UPIO_MEM32; <nl> +		p += 13; <nl>  	} else if (strncmp(p, "io,", 3) == 0) { <nl>  		*iotype = UPIO_PORT; <nl>  		p += 3;
@@ -806,6 +806,7 @@ static struct mm_struct *mm_init(struct mm_struct *mm, struct task_struct *p, <nl>  	mm_init_cpumask(mm); <nl>  	mm_init_aio(mm); <nl>  	mm_init_owner(mm, p); <nl> +	RCU_INIT_POINTER(mm->exe_file, NULL); <nl>  	mmu_notifier_mm_init(mm); <nl>  	init_tlb_flush_pending(mm); <nl>  #if defined(CONFIG_TRANSPARENT_HUGEPAGE) && !USE_SPLIT_PMD_PTLOCKS
@@ -1041,6 +1041,7 @@ static int trunc_start(struct gfs2_inode *ip, u64 size) <nl>   <nl>  	if (gfs2_is_stuffed(ip)) { <nl>  		u64 dsize = size + sizeof(struct gfs2_inode); <nl> +		ip->i_disksize = size; <nl>  		ip->i_inode.i_mtime = ip->i_inode.i_ctime = CURRENT_TIME; <nl>  		gfs2_trans_add_bh(ip->i_gl, dibh, 1); <nl>  		gfs2_dinode_out(ip, dibh->b_data);
@@ -4681,11 +4681,13 @@ void igb_update_stats(struct igb_adapter *adapter, <nl>  	bytes = 0; <nl>  	packets = 0; <nl>  	for (i = 0; i < adapter->num_rx_queues; i++) { <nl> -		u32 rqdpc_tmp = rd32(E1000_RQDPC(i)) & 0x0FFF; <nl> +		u32 rqdpc = rd32(E1000_RQDPC(i)); <nl>  		struct igb_ring *ring = adapter->rx_ring[i]; <nl>   <nl> -		ring->rx_stats.drops += rqdpc_tmp; <nl> -		net_stats->rx_fifo_errors += rqdpc_tmp; <nl> +		if (rqdpc) { <nl> +			ring->rx_stats.drops += rqdpc; <nl> +			net_stats->rx_fifo_errors += rqdpc; <nl> +		} <nl>   <nl>  		do { <nl>  			start = u64_stats_fetch_begin_bh(&ring->rx_syncp);
@@ -234,6 +234,7 @@ static struct shash_alg alg = { <nl>  	.export		=	md5_export, <nl>  	.import		=	md5_import, <nl>  	.descsize	=	sizeof(struct md5_state), <nl> +	.statesize	=	sizeof(struct md5_state), <nl>  	.base		=	{ <nl>  		.cra_name	=	"md5", <nl>  		.cra_flags	=	CRYPTO_ALG_TYPE_SHASH,
@@ -245,6 +245,7 @@ static int l2cap_sock_getname(struct socket *sock, struct sockaddr *addr, int *l <nl>   <nl>  	BT_DBG("sock %p, sk %p", sock, sk); <nl>   <nl> +	memset(la, 0, sizeof(struct sockaddr_l2)); <nl>  	addr->sa_family = AF_BLUETOOTH; <nl>  	*len = sizeof(struct sockaddr_l2); <nl>  
@@ -336,11 +336,12 @@ static int nfs_sockaddr_match_ipaddr6(const struct sockaddr *sa1, <nl>  	const struct sockaddr_in6 *sin1 = (const struct sockaddr_in6 *)sa1; <nl>  	const struct sockaddr_in6 *sin2 = (const struct sockaddr_in6 *)sa2; <nl>   <nl> -	if (ipv6_addr_scope(&sin1->sin6_addr) == IPV6_ADDR_SCOPE_LINKLOCAL && <nl> -	    sin1->sin6_scope_id != sin2->sin6_scope_id) <nl> +	if (!ipv6_addr_equal(&sin1->sin6_addr, &sin2->sin6_addr)) <nl>  		return 0; <nl> +	else if (ipv6_addr_type(&sin1->sin6_addr) & IPV6_ADDR_LINKLOCAL) <nl> +		return sin1->sin6_scope_id == sin2->sin6_scope_id; <nl>   <nl> -	return ipv6_addr_equal(&sin1->sin6_addr, &sin2->sin6_addr); <nl> +	return 1; <nl>  } <nl>  #else	/* !defined(CONFIG_IPV6) && !defined(CONFIG_IPV6_MODULE) */ <nl>  static int nfs_sockaddr_match_ipaddr6(const struct sockaddr *sa1,
@@ -416,7 +416,7 @@ static int bq24735_charger_probe(struct i2c_client *client, <nl>  		return ret; <nl>  	} <nl>   <nl> -	if (!charger->status_gpio || bq24735_charger_is_present(charger)) { <nl> +	if (bq24735_charger_is_present(charger)) { <nl>  		ret = bq24735_read_word(client, BQ24735_MANUFACTURER_ID); <nl>  		if (ret < 0) { <nl>  			dev_err(&client->dev, "Failed to read manufacturer id : %d\n", <nl> @@ -437,10 +437,7 @@ static int bq24735_charger_probe(struct i2c_client *client, <nl>  				"device id mismatch. 0x000b != 0x%04x\n", ret); <nl>  			return -ENODEV; <nl>  		} <nl> -	} <nl>   <nl> -	/* check for AC adapter presence */ <nl> -	if (bq24735_charger_is_present(charger)) { <nl>  		ret = bq24735_enable_charging(charger); <nl>  		if (ret < 0) { <nl>  			dev_err(&client->dev, "Failed to enable charging\n");
@@ -306,6 +306,8 @@ static int poll_select_copy_remaining(struct timespec *end_time, void __user *p, <nl>  		rts.tv_sec = rts.tv_nsec = 0; <nl>   <nl>  	if (timeval) { <nl> +		if (sizeof(rtv) > sizeof(rtv.tv_sec) + sizeof(rtv.tv_usec)) <nl> +			memset(&rtv, 0, sizeof(rtv)); <nl>  		rtv.tv_sec = rts.tv_sec; <nl>  		rtv.tv_usec = rts.tv_nsec / NSEC_PER_USEC; <nl>  
@@ -96,6 +96,9 @@ struct reg_beacon { <nl>  	struct ieee80211_channel chan; <nl>  }; <nl>   <nl> +static void reg_todo(struct work_struct *work); <nl> +static DECLARE_WORK(reg_work, reg_todo); <nl> + <nl>  /* We keep a static world regulatory domain in case of the absence of CRDA */ <nl>  static const struct ieee80211_regdomain world_regdom = { <nl>  	.n_reg_rules = 5, <nl> @@ -1494,8 +1497,6 @@ static void reg_todo(struct work_struct *work) <nl>  	reg_process_pending_beacon_hints(); <nl>  } <nl>   <nl> -static DECLARE_WORK(reg_work, reg_todo); <nl> - <nl>  static void queue_regulatory_request(struct regulatory_request *request) <nl>  { <nl>  	if (isalpha(request->alpha2[0]))
@@ -104,6 +104,7 @@ static void wl1271_spi_reset(struct wl1271 *wl) <nl>  	spi_message_add_tail(&t, &m); <nl>   <nl>  	spi_sync(wl_to_spi(wl), &m); <nl> +	kfree(cmd); <nl>   <nl>  	wl1271_dump(DEBUG_SPI, "spi reset -> ", cmd, WSPI_INIT_CMD_LEN); <nl>  } <nl> @@ -158,6 +159,7 @@ static void wl1271_spi_init(struct wl1271 *wl) <nl>  	spi_message_add_tail(&t, &m); <nl>   <nl>  	spi_sync(wl_to_spi(wl), &m); <nl> +	kfree(cmd); <nl>   <nl>  	wl1271_dump(DEBUG_SPI, "spi init -> ", cmd, WSPI_INIT_CMD_LEN); <nl>  }
@@ -184,8 +184,8 @@ mpc85xx_setup_pci1(struct pci_controller *hose) <nl>  	pci->powar1 = 0x80044000 | <nl>  	   (__ilog2(MPC85XX_PCI1_UPPER_MEM - MPC85XX_PCI1_LOWER_MEM + 1) - 1); <nl>   <nl> -	/* Setup outboud IO windows @ MPC85XX_PCI1_IO_BASE */ <nl> -	pci->potar2 = 0x00000000; <nl> +	/* Setup outbound IO windows @ MPC85XX_PCI1_IO_BASE */ <nl> +	pci->potar2 = (MPC85XX_PCI1_LOWER_IO >> 12) & 0x000fffff; <nl>  	pci->potear2 = 0x00000000; <nl>  	pci->powbar2 = (MPC85XX_PCI1_IO_BASE >> 12) & 0x000fffff; <nl>  	/* Enable, IO R/W */ <nl> @@ -235,8 +235,8 @@ mpc85xx_setup_pci2(struct pci_controller *hose) <nl>  	pci->powar1 = 0x80044000 | <nl>  	   (__ilog2(MPC85XX_PCI2_UPPER_MEM - MPC85XX_PCI2_LOWER_MEM + 1) - 1); <nl>   <nl> -	/* Setup outboud IO windows @ MPC85XX_PCI2_IO_BASE */ <nl> -	pci->potar2 = 0x00000000; <nl> +	/* Setup outbound IO windows @ MPC85XX_PCI2_IO_BASE */ <nl> +	pci->potar2 = (MPC85XX_PCI2_LOWER_IO >> 12) & 0x000fffff;; <nl>  	pci->potear2 = 0x00000000; <nl>  	pci->powbar2 = (MPC85XX_PCI2_IO_BASE >> 12) & 0x000fffff; <nl>  	/* Enable, IO R/W */
@@ -2523,8 +2523,8 @@ static noinline struct module *load_module(void __user *umod, <nl>   free_unload: <nl>  	module_unload_free(mod); <nl>  #if defined(CONFIG_MODULE_UNLOAD) && defined(CONFIG_SMP) <nl> - free_init: <nl>  	percpu_modfree(mod->refptr); <nl> + free_init: <nl>  #endif <nl>  	module_free(mod, mod->module_init); <nl>   free_core:
@@ -7415,10 +7415,11 @@ static inline void nested_release_vmcs12(struct vcpu_vmx *vmx) <nl>   */ <nl>  static void free_nested(struct vcpu_vmx *vmx) <nl>  { <nl> -	if (!vmx->nested.vmxon) <nl> +	if (!vmx->nested.vmxon && !vmx->nested.smm.vmxon) <nl>  		return; <nl>   <nl>  	vmx->nested.vmxon = false; <nl> +	vmx->nested.smm.vmxon = false; <nl>  	free_vpid(vmx->nested.vpid02); <nl>  	vmx->nested.posted_intr_nv = -1; <nl>  	vmx->nested.current_vmptr = -1ull;
@@ -4558,6 +4558,13 @@ xfs_btree_simple_query_range( <nl>  	if (error) <nl>  		goto out; <nl>   <nl> +	/* Nothing?  See if there's anything to the right. */ <nl> +	if (!stat) { <nl> +		error = xfs_btree_increment(cur, 0, &stat); <nl> +		if (error) <nl> +			goto out; <nl> +	} <nl> + <nl>  	while (stat) { <nl>  		/* Find the record. */ <nl>  		error = xfs_btree_get_rec(cur, &recp, &stat);
@@ -734,7 +734,7 @@ static int spi_qup_remove(struct platform_device *pdev) <nl>  	int ret; <nl>   <nl>  	ret = pm_runtime_get_sync(&pdev->dev); <nl> -	if (ret) <nl> +	if (ret < 0) <nl>  		return ret; <nl>   <nl>  	ret = spi_qup_set_state(controller, QUP_STATE_RESET);
@@ -788,7 +788,7 @@ static void do_pata_set_dmamode (struct ata_port *ap, struct ata_device *adev, i <nl>  	u16 master_data; <nl>  	u8 speed		= adev->dma_mode; <nl>  	int devid		= adev->devno + 2 * ap->port_no; <nl> -	u8 udma_enable; <nl> +	u8 udma_enable		= 0; <nl>   <nl>  	static const	 /* ISP  RTC */ <nl>  	u8 timings[][2]	= { { 0, 0 },
@@ -124,7 +124,7 @@ static ssize_t shm_read_file(struct b43legacy_wldev *dev, char *buf, size_t bufs <nl>  	__le16 *le16buf = (__le16 *)buf; <nl>   <nl>  	for (i = 0; i < 0x1000; i++) { <nl> -		if (bufsize <= 0) <nl> +		if (bufsize < sizeof(tmp)) <nl>  			break; <nl>  		tmp = b43legacy_shm_read16(dev, B43legacy_SHM_SHARED, 2 * i); <nl>  		le16buf[i] = cpu_to_le16(tmp);
@@ -421,8 +421,8 @@ static int __devinit i2o_pci_probe(struct pci_dev *pdev, <nl>  	i2o_pci_free(c); <nl>   <nl>        free_controller: <nl> -	i2o_iop_free(c); <nl>  	put_device(c->device.parent); <nl> +	i2o_iop_free(c); <nl>   <nl>        disable: <nl>  	pci_disable_device(pdev);
@@ -1177,6 +1177,11 @@ static void mceusb_process_ir_data(struct mceusb_dev *ir, int buf_len) <nl>  			init_ir_raw_event(&rawir); <nl>  			rawir.pulse = ((ir->buf_in[i] & MCE_PULSE_BIT) != 0); <nl>  			rawir.duration = (ir->buf_in[i] & MCE_PULSE_MASK); <nl> +			if (unlikely(!rawir.duration)) { <nl> +				dev_warn(ir->dev, "nonsensical irdata %02x with duration 0", <nl> +					 ir->buf_in[i]); <nl> +				break; <nl> +			} <nl>  			if (rawir.pulse) { <nl>  				ir->pulse_tunit += rawir.duration; <nl>  				ir->pulse_count++;
@@ -4717,7 +4717,8 @@ static int amdgpu_dm_atomic_check(struct drm_device *dev, <nl>  		} <nl>  	} else { <nl>  		for_each_oldnew_crtc_in_state(state, crtc, old_crtc_state, new_crtc_state, i) { <nl> -			if (!drm_atomic_crtc_needs_modeset(new_crtc_state)) <nl> +			if (!drm_atomic_crtc_needs_modeset(new_crtc_state) && <nl> +					!new_crtc_state->color_mgmt_changed) <nl>  				continue; <nl>   <nl>  			if (!new_crtc_state->enable)
@@ -304,6 +304,9 @@ void exit_shm(struct task_struct *task) <nl>  { <nl>  	struct ipc_namespace *ns = task->nsproxy->ipc_ns; <nl>   <nl> +	if (shm_ids(ns).in_use == 0) <nl> +		return; <nl> + <nl>  	/* Destroy all already created segments, but not mapped yet */ <nl>  	down_write(&shm_ids(ns).rw_mutex); <nl>  	if (shm_ids(ns).in_use)
@@ -1328,6 +1328,7 @@ void intel_engines_mark_idle(struct drm_i915_private *i915) <nl>  	for_each_engine(engine, i915, id) { <nl>  		intel_engine_disarm_breadcrumbs(engine); <nl>  		i915_gem_batch_pool_fini(&engine->batch_pool); <nl> +		tasklet_kill(&engine->irq_tasklet); <nl>  		engine->no_priolist = false; <nl>  	} <nl>  }
@@ -379,7 +379,7 @@ int usb_sg_init(struct usb_sg_request *io, struct usb_device *dev, <nl>  	} <nl>   <nl>  	/* initialize all the urbs we'll use */ <nl> -	io->urbs = kmalloc(io->entries * sizeof *io->urbs, mem_flags); <nl> +	io->urbs = kmalloc(io->entries * sizeof(*io->urbs), mem_flags); <nl>  	if (!io->urbs) <nl>  		goto nomem; <nl>  
@@ -2678,8 +2678,10 @@ static int xfrm_expand_policies(const struct flowi *fl, u16 family, <nl>  		*num_xfrms = 0; <nl>  		return 0; <nl>  	} <nl> -	if (IS_ERR(pols[0])) <nl> +	if (IS_ERR(pols[0])) { <nl> +		*num_pols = 0; <nl>  		return PTR_ERR(pols[0]); <nl> +	} <nl>   <nl>  	*num_xfrms = pols[0]->xfrm_nr; <nl>   <nl> @@ -2694,6 +2696,7 @@ static int xfrm_expand_policies(const struct flowi *fl, u16 family, <nl>  		if (pols[1]) { <nl>  			if (IS_ERR(pols[1])) { <nl>  				xfrm_pols_put(pols, *num_pols); <nl> +				*num_pols = 0; <nl>  				return PTR_ERR(pols[1]); <nl>  			} <nl>  			(*num_pols)++;
@@ -24,13 +24,13 @@ static void pcspkr_do_sound(unsigned int count) <nl>  	spin_lock_irqsave(&i8253_lock, flags); <nl>   <nl>  	if (count) { <nl> -		/* enable counter 2 */ <nl> -		outb_p(inb_p(0x61) | 3, 0x61); <nl>  		/* set command for counter 2, 2 byte write */ <nl>  		outb_p(0xB6, 0x43); <nl>  		/* select desired HZ */ <nl>  		outb_p(count & 0xff, 0x42); <nl>  		outb((count >> 8) & 0xff, 0x42); <nl> +		/* enable counter 2 */ <nl> +		outb_p(inb_p(0x61) | 3, 0x61); <nl>  	} else { <nl>  		/* disable counter 2 */ <nl>  		outb(inb_p(0x61) & 0xFC, 0x61);
@@ -248,7 +248,7 @@ static ssize_t channel_dimm_label_store(struct device *dev, <nl>  	if (data[count - 1] == '\0' || data[count - 1] == '\n') <nl>  		copy_count -= 1; <nl>   <nl> -	if (copy_count >= sizeof(rank->dimm->label)) <nl> +	if (copy_count == 0 || copy_count >= sizeof(rank->dimm->label)) <nl>  		return -EINVAL; <nl>   <nl>  	strncpy(rank->dimm->label, data, copy_count); <nl> @@ -509,7 +509,7 @@ static ssize_t dimmdev_label_store(struct device *dev, <nl>  	if (data[count - 1] == '\0' || data[count - 1] == '\n') <nl>  		copy_count -= 1; <nl>   <nl> -	if (copy_count >= sizeof(dimm->label)) <nl> +	if (copy_count == 0 || copy_count >= sizeof(dimm->label)) <nl>  		return -EINVAL; <nl>   <nl>  	strncpy(dimm->label, data, copy_count);
@@ -561,5 +561,7 @@ void rds_inc_info_copy(struct rds_incoming *inc, <nl>  		minfo.fport = inc->i_hdr.h_dport; <nl>  	} <nl>   <nl> +	minfo.flags = 0; <nl> + <nl>  	rds_info_copy(iter, &minfo, sizeof(minfo)); <nl>  }
@@ -1605,6 +1605,15 @@ void smscore_onresponse(struct smscore_device_t *coredev, <nl>  				- sizeof(struct SmsMsgHdr_ST)); <nl>  			break; <nl>   <nl> +		case MSG_SMS_DVBT_BDA_DATA: <nl> +			/* <nl> +			 * It can be received here, if the frontend is <nl> +			 * tuned into a valid channel and the proper firmware <nl> +			 * is loaded. That happens when the module got removed <nl> +			 * and re-inserted, without powering the device off <nl> +			 */ <nl> +			break; <nl> + <nl>  		default: <nl>  			sms_debug("message %s(%d) not handled.", <nl>  				  smscore_translate_msg(phdr->msgType),
@@ -236,6 +236,9 @@ static int si21_writeregs(struct si21xx_state *state, u8 reg1, <nl>  				.len = len + 1 <nl>  	}; <nl>   <nl> +	if (len > sizeof(buf) - 1) <nl> +		return -EINVAL; <nl> + <nl>  	msg.buf[0] =  reg1; <nl>  	memcpy(msg.buf + 1, data, len); <nl>  
@@ -922,11 +922,10 @@ int simple_set_acl(struct inode *inode, struct posix_acl *acl, int type) <nl>  	int error; <nl>   <nl>  	if (type == ACL_TYPE_ACCESS) { <nl> -		error = posix_acl_equiv_mode(acl, &inode->i_mode); <nl> -		if (error < 0) <nl> -			return 0; <nl> -		if (error == 0) <nl> -			acl = NULL; <nl> +		error = posix_acl_update_mode(inode, <nl> +				&inode->i_mode, &acl); <nl> +		if (error) <nl> +			return error; <nl>  	} <nl>   <nl>  	inode->i_ctime = current_time(inode);
@@ -190,6 +190,12 @@ static struct rds_connection *__rds_conn_create(struct net *net, <nl>  		} <nl>  	} <nl>   <nl> +	if (trans == NULL) { <nl> +		kmem_cache_free(rds_conn_slab, conn); <nl> +		conn = ERR_PTR(-ENODEV); <nl> +		goto out; <nl> +	} <nl> + <nl>  	conn->c_trans = trans; <nl>   <nl>  	ret = trans->conn_alloc(conn, gfp);
@@ -2756,6 +2756,9 @@ isdn_net_setcfg(isdn_net_ioctl_cfg * cfg) <nl>  			char *c, <nl>  			*e; <nl>   <nl> +			if (strnlen(cfg->drvid, sizeof(cfg->drvid)) == <nl> +					sizeof(cfg->drvid)) <nl> +				return -EINVAL; <nl>  			drvidx = -1; <nl>  			chidx = -1; <nl>  			strcpy(drvid, cfg->drvid);
@@ -1021,8 +1021,10 @@ int rtl_usb_probe(struct usb_interface *intf, <nl>  	rtlpriv->hw = hw; <nl>  	rtlpriv->usb_data = kcalloc(RTL_USB_MAX_RX_COUNT, sizeof(u32), <nl>  				    GFP_KERNEL); <nl> -	if (!rtlpriv->usb_data) <nl> +	if (!rtlpriv->usb_data) { <nl> +		ieee80211_free_hw(hw); <nl>  		return -ENOMEM; <nl> +	} <nl>   <nl>  	/* this spin lock must be initialized early */ <nl>  	spin_lock_init(&rtlpriv->locks.usb_lock); <nl> @@ -1083,6 +1085,7 @@ int rtl_usb_probe(struct usb_interface *intf, <nl>  	_rtl_usb_io_handler_release(hw); <nl>  	usb_put_dev(udev); <nl>  	complete(&rtlpriv->firmware_loading_complete); <nl> +	kfree(rtlpriv->usb_data); <nl>  	return -ENODEV; <nl>  } <nl>  EXPORT_SYMBOL(rtl_usb_probe);
@@ -231,7 +231,7 @@ static int proc_bus_pci_mmap(struct file *file, struct vm_area_struct *vma) <nl>  { <nl>  	struct pci_dev *dev = PDE_DATA(file_inode(file)); <nl>  	struct pci_filp_private *fpriv = file->private_data; <nl> -	int i, ret; <nl> +	int i, ret, write_combine; <nl>   <nl>  	if (!capable(CAP_SYS_RAWIO)) <nl>  		return -EPERM; <nl> @@ -245,9 +245,12 @@ static int proc_bus_pci_mmap(struct file *file, struct vm_area_struct *vma) <nl>  	if (i >= PCI_ROM_RESOURCE) <nl>  		return -ENODEV; <nl>   <nl> +	if (fpriv->mmap_state == pci_mmap_mem) <nl> +		write_combine = fpriv->write_combine; <nl> +	else <nl> +		write_combine = 0; <nl>  	ret = pci_mmap_page_range(dev, vma, <nl> -				  fpriv->mmap_state, <nl> -				  fpriv->write_combine); <nl> +				  fpriv->mmap_state, write_combine); <nl>  	if (ret < 0) <nl>  		return ret; <nl>  
@@ -150,6 +150,8 @@ int btrfs_add_inode_defrag(struct btrfs_trans_handle *trans, <nl>  	spin_lock(&root->fs_info->defrag_inodes_lock); <nl>  	if (!BTRFS_I(inode)->in_defrag) <nl>  		__btrfs_add_inode_defrag(inode, defrag); <nl> +	else <nl> +		kfree(defrag); <nl>  	spin_unlock(&root->fs_info->defrag_inodes_lock); <nl>  	return 0; <nl>  }
@@ -66,16 +66,16 @@ struct regmap { <nl>  	unsigned int num_reg_defaults_raw; <nl>   <nl>  	/* if set, only the cache is modified not the HW */ <nl> -	unsigned int cache_only:1; <nl> +	u32 cache_only; <nl>  	/* if set, only the HW is modified not the cache */ <nl> -	unsigned int cache_bypass:1; <nl> +	u32 cache_bypass; <nl>  	/* if set, remember to free reg_defaults_raw */ <nl> -	unsigned int cache_free:1; <nl> +	bool cache_free; <nl>   <nl>  	struct reg_default *reg_defaults; <nl>  	const void *reg_defaults_raw; <nl>  	void *cache; <nl> -	bool cache_dirty; <nl> +	u32 cache_dirty; <nl>  }; <nl>   <nl>  struct regcache_ops {
@@ -2536,6 +2536,11 @@ static struct sk_buff *isdn_ppp_decompress(struct sk_buff *skb,struct ippp_struc <nl>    		rsparm.maxdlen = IPPP_RESET_MAXDATABYTES; <nl>     <nl>    		skb_out = dev_alloc_skb(is->mru + PPP_HDRLEN); <nl> +  		if (!skb_out) { <nl> +  			kfree_skb(skb); <nl> +  			printk(KERN_ERR "ippp: decomp memory allocation failure\n"); <nl> +			return NULL; <nl> +  		} <nl>  		len = ipc->decompress(stat, skb, skb_out, &rsparm); <nl>  		kfree_skb(skb); <nl>  		if (len <= 0) {
@@ -866,7 +866,8 @@ static void pcie_disable_notification(struct controller *ctrl) <nl>  	u16 mask; <nl>  	mask = (PCI_EXP_SLTCTL_PDCE | PCI_EXP_SLTCTL_ABPE | <nl>  		PCI_EXP_SLTCTL_MRLSCE | PCI_EXP_SLTCTL_PFDE | <nl> -		PCI_EXP_SLTCTL_HPIE | PCI_EXP_SLTCTL_CCIE); <nl> +		PCI_EXP_SLTCTL_HPIE | PCI_EXP_SLTCTL_CCIE | <nl> +		PCI_EXP_SLTCTL_DLLSCE); <nl>  	if (pcie_write_cmd(ctrl, 0, mask)) <nl>  		ctrl_warn(ctrl, "Cannot disable software notification\n"); <nl>  }
@@ -1478,8 +1478,10 @@ EXPORT_SYMBOL(__getblk); <nl>  void __breadahead(struct block_device *bdev, sector_t block, int size) <nl>  { <nl>  	struct buffer_head *bh = __getblk(bdev, block, size); <nl> -	ll_rw_block(READA, 1, &bh); <nl> -	brelse(bh); <nl> +	if (likely(bh)) { <nl> +		ll_rw_block(READA, 1, &bh); <nl> +		brelse(bh); <nl> +	} <nl>  } <nl>  EXPORT_SYMBOL(__breadahead); <nl>   <nl> @@ -1497,7 +1499,7 @@ __bread(struct block_device *bdev, sector_t block, int size) <nl>  { <nl>  	struct buffer_head *bh = __getblk(bdev, block, size); <nl>   <nl> -	if (!buffer_uptodate(bh)) <nl> +	if (likely(bh) && !buffer_uptodate(bh)) <nl>  		bh = __bread_slow(bh); <nl>  	return bh; <nl>  }
@@ -289,7 +289,6 @@ static void clip_neigh_error(struct neighbour *neigh,struct sk_buff *skb) <nl>   <nl>  static struct neigh_ops clip_neigh_ops = { <nl>  	.family =		AF_INET, <nl> -	.destructor =		clip_neigh_destroy, <nl>  	.solicit =		clip_neigh_solicit, <nl>  	.error_report =		clip_neigh_error, <nl>  	.output =		dev_queue_xmit, <nl> @@ -347,6 +346,7 @@ static struct neigh_table clip_tbl = { <nl>  	/* parameters are copied from ARP ... */ <nl>  	.parms = { <nl>  		.tbl 			= &clip_tbl, <nl> +		.neigh_destructor	= clip_neigh_destroy, <nl>  		.base_reachable_time 	= 30 * HZ, <nl>  		.retrans_time 		= 1 * HZ, <nl>  		.gc_staletime 		= 60 * HZ,
@@ -81,6 +81,11 @@ static int xgmiitorgmii_probe(struct mdio_device *mdiodev) <nl>  		return -EPROBE_DEFER; <nl>  	} <nl>   <nl> +	if (!priv->phy_dev->drv) { <nl> +		dev_info(dev, "Attached phy not ready\n"); <nl> +		return -EPROBE_DEFER; <nl> +	} <nl> + <nl>  	priv->addr = mdiodev->addr; <nl>  	priv->phy_drv = priv->phy_dev->drv; <nl>  	memcpy(&priv->conv_phy_drv, priv->phy_dev->drv,
@@ -2759,9 +2759,12 @@ int rtnl_configure_link(struct net_device *dev, const struct ifinfomsg *ifm) <nl>  			return err; <nl>  	} <nl>   <nl> -	dev->rtnl_link_state = RTNL_LINK_INITIALIZED; <nl> - <nl> -	__dev_notify_flags(dev, old_flags, ~0U); <nl> +	if (dev->rtnl_link_state == RTNL_LINK_INITIALIZED) { <nl> +		__dev_notify_flags(dev, old_flags, 0U); <nl> +	} else { <nl> +		dev->rtnl_link_state = RTNL_LINK_INITIALIZED; <nl> +		__dev_notify_flags(dev, old_flags, ~0U); <nl> +	} <nl>  	return 0; <nl>  } <nl>  EXPORT_SYMBOL(rtnl_configure_link);
@@ -1497,9 +1497,11 @@ struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key) <nl>   <nl>  	args.objectid = key->on_disk_key.k_objectid; <nl>  	args.dirid = key->on_disk_key.k_dir_id; <nl> +	reiserfs_write_unlock(s); <nl>  	inode = iget5_locked(s, key->on_disk_key.k_objectid, <nl>  			     reiserfs_find_actor, reiserfs_init_locked_inode, <nl>  			     (void *)(&args)); <nl> +	reiserfs_write_lock(s); <nl>  	if (!inode) <nl>  		return ERR_PTR(-ENOMEM); <nl>  
@@ -69,7 +69,7 @@ static LIST_HEAD(dev_map_list); <nl>   <nl>  static u64 dev_map_bitmap_size(const union bpf_attr *attr) <nl>  { <nl> -	return BITS_TO_LONGS(attr->max_entries) * sizeof(unsigned long); <nl> +	return BITS_TO_LONGS((u64) attr->max_entries) * sizeof(unsigned long); <nl>  } <nl>   <nl>  static struct bpf_map *dev_map_alloc(union bpf_attr *attr)
@@ -1441,15 +1441,13 @@ static struct zonelist *policy_zonelist(gfp_t gfp, struct mempolicy *policy) <nl>  		/* <nl>  		 * Normally, MPOL_BIND allocations are node-local within the <nl>  		 * allowed nodemask.  However, if __GFP_THISNODE is set and the <nl> -		 * current node is part of the mask, we use the zonelist for <nl> +		 * current node isn't part of the mask, we use the zonelist for <nl>  		 * the first node in the mask instead. <nl>  		 */ <nl>  		if (unlikely(gfp & __GFP_THISNODE) && <nl>  				unlikely(!node_isset(nd, policy->v.nodes))) <nl>  			nd = first_node(policy->v.nodes); <nl>  		break; <nl> -	case MPOL_INTERLEAVE: /* should not happen */ <nl> -		break; <nl>  	default: <nl>  		BUG(); <nl>  	}
@@ -377,6 +377,9 @@ static ssize_t btrfs_label_store(struct kobject *kobj, <nl>  	struct btrfs_fs_info *fs_info = to_fs_info(kobj); <nl>  	size_t p_len; <nl>   <nl> +	if (!fs_info) <nl> +		return -EPERM; <nl> + <nl>  	if (fs_info->sb->s_flags & MS_RDONLY) <nl>  		return -EROFS; <nl>  
@@ -35,8 +35,6 @@ void cfg80211_scan_done(struct cfg80211_scan_request *request, bool aborted) <nl>  	else <nl>  		nl80211_send_scan_done(wiphy_to_dev(request->wiphy), dev); <nl>   <nl> -	wiphy_to_dev(request->wiphy)->scan_req = NULL; <nl> - <nl>  #ifdef CONFIG_WIRELESS_EXT <nl>  	if (!aborted) { <nl>  		memset(&wrqu, 0, sizeof(wrqu)); <nl> @@ -48,6 +46,7 @@ void cfg80211_scan_done(struct cfg80211_scan_request *request, bool aborted) <nl>  	dev_put(dev); <nl>   <nl>   out: <nl> +	wiphy_to_dev(request->wiphy)->scan_req = NULL; <nl>  	kfree(request); <nl>  } <nl>  EXPORT_SYMBOL(cfg80211_scan_done);
@@ -3771,8 +3771,11 @@ static bool g4x_compute_wm0(struct drm_device *dev, <nl>  	int entries, tlb_miss; <nl>   <nl>  	crtc = intel_get_crtc_for_plane(dev, plane); <nl> -	if (crtc->fb == NULL || !crtc->enabled) <nl> +	if (crtc->fb == NULL || !crtc->enabled) { <nl> +		*cursor_wm = cursor->guard_size; <nl> +		*plane_wm = display->guard_size; <nl>  		return false; <nl> +	} <nl>   <nl>  	htotal = crtc->mode.htotal; <nl>  	hdisplay = crtc->mode.hdisplay;
@@ -283,8 +283,12 @@ static int ipddp_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd) <nl>                  case SIOCFINDIPDDPRT: <nl>  			spin_lock_bh(&ipddp_route_lock); <nl>  			rp = __ipddp_find_route(&rcp); <nl> -			if (rp) <nl> -				memcpy(&rcp2, rp, sizeof(rcp2)); <nl> +			if (rp) { <nl> +				memset(&rcp2, 0, sizeof(rcp2)); <nl> +				rcp2.ip    = rp->ip; <nl> +				rcp2.at    = rp->at; <nl> +				rcp2.flags = rp->flags; <nl> +			} <nl>  			spin_unlock_bh(&ipddp_route_lock); <nl>   <nl>  			if (rp) {
@@ -586,7 +586,7 @@ static ssize_t cxlflash_show_port_status(struct device *dev, <nl>  	u64 *fc_regs; <nl>   <nl>  	rc = kstrtouint((attr->attr.name + 4), 10, &port); <nl> -	if (rc || (port > NUM_FC_PORTS)) <nl> +	if (rc || (port >= NUM_FC_PORTS)) <nl>  		return 0; <nl>   <nl>  	fc_regs = &afu->afu_map->global.fc_regs[port][0];
@@ -265,8 +265,15 @@ int walk_page_range(unsigned long start, unsigned long end, <nl>  			vma = vma->vm_next; <nl>   <nl>  			err = walk_page_test(start, next, walk); <nl> -			if (err > 0) <nl> +			if (err > 0) { <nl> +				/* <nl> +				 * positive return values are purely for <nl> +				 * controlling the pagewalk, so should never <nl> +				 * be passed to the callers. <nl> +				 */ <nl> +				err = 0; <nl>  				continue; <nl> +			} <nl>  			if (err < 0) <nl>  				break; <nl>  		}
@@ -5281,6 +5281,7 @@ int ext4_setattr(struct dentry *dentry, struct iattr *attr) <nl>  { <nl>  	struct inode *inode = dentry->d_inode; <nl>  	int error, rc = 0; <nl> +	int orphan = 0; <nl>  	const unsigned int ia_valid = attr->ia_valid; <nl>   <nl>  	error = inode_change_ok(inode, attr); <nl> @@ -5336,8 +5337,10 @@ int ext4_setattr(struct dentry *dentry, struct iattr *attr) <nl>  			error = PTR_ERR(handle); <nl>  			goto err_out; <nl>  		} <nl> - <nl> -		error = ext4_orphan_add(handle, inode); <nl> +		if (ext4_handle_valid(handle)) { <nl> +			error = ext4_orphan_add(handle, inode); <nl> +			orphan = 1; <nl> +		} <nl>  		EXT4_I(inode)->i_disksize = attr->ia_size; <nl>  		rc = ext4_mark_inode_dirty(handle, inode); <nl>  		if (!error) <nl> @@ -5355,6 +5358,7 @@ int ext4_setattr(struct dentry *dentry, struct iattr *attr) <nl>  					goto err_out; <nl>  				} <nl>  				ext4_orphan_del(handle, inode); <nl> +				orphan = 0; <nl>  				ext4_journal_stop(handle); <nl>  				goto err_out; <nl>  			} <nl> @@ -5377,7 +5381,7 @@ int ext4_setattr(struct dentry *dentry, struct iattr *attr) <nl>  	 * If the call to ext4_truncate failed to get a transaction handle at <nl>  	 * all, we need to clean up the in-core orphan list manually. <nl>  	 */ <nl> -	if (inode->i_nlink) <nl> +	if (orphan && inode->i_nlink) <nl>  		ext4_orphan_del(NULL, inode); <nl>   <nl>  	if (!rc && (ia_valid & ATTR_MODE))
@@ -365,6 +365,9 @@ static ssize_t comp_algorithm_store(struct device *dev, <nl>  	struct zram *zram = dev_to_zram(dev); <nl>  	size_t sz; <nl>   <nl> +	if (!zcomp_available_algorithm(buf)) <nl> +		return -EINVAL; <nl> + <nl>  	down_write(&zram->init_lock); <nl>  	if (init_done(zram)) { <nl>  		up_write(&zram->init_lock); <nl> @@ -378,9 +381,6 @@ static ssize_t comp_algorithm_store(struct device *dev, <nl>  	if (sz > 0 && zram->compressor[sz - 1] == '\n') <nl>  		zram->compressor[sz - 1] = 0x00; <nl>   <nl> -	if (!zcomp_available_algorithm(zram->compressor)) <nl> -		len = -EINVAL; <nl> - <nl>  	up_write(&zram->init_lock); <nl>  	return len; <nl>  }
@@ -825,6 +825,8 @@ static void release_resources(struct ibmvnic_adapter *adapter) <nl>  			} <nl>  		} <nl>  	} <nl> +	kfree(adapter->napi); <nl> +	adapter->napi = NULL; <nl>   <nl>  	release_login_rsp_buffer(adapter); <nl>  }
@@ -780,21 +780,16 @@ asmlinkage long compat_sys_recvmmsg(int fd, struct compat_mmsghdr __user *mmsg, <nl>  	if (flags & MSG_CMSG_COMPAT) <nl>  		return -EINVAL; <nl>   <nl> -	if (COMPAT_USE_64BIT_TIME) <nl> -		return __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen, <nl> -				      flags | MSG_CMSG_COMPAT, <nl> -				      (struct timespec *) timeout); <nl> - <nl>  	if (timeout == NULL) <nl>  		return __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen, <nl>  				      flags | MSG_CMSG_COMPAT, NULL); <nl>   <nl> -	if (get_compat_timespec(&ktspec, timeout)) <nl> +	if (compat_get_timespec(&ktspec, timeout)) <nl>  		return -EFAULT; <nl>   <nl>  	datagrams = __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen, <nl>  				   flags | MSG_CMSG_COMPAT, &ktspec); <nl> -	if (datagrams > 0 && put_compat_timespec(&ktspec, timeout)) <nl> +	if (datagrams > 0 && compat_put_timespec(&ktspec, timeout)) <nl>  		datagrams = -EFAULT; <nl>   <nl>  	return datagrams;
@@ -1972,6 +1972,7 @@ fst_get_iface(struct fst_card_info *card, struct fst_port_info *port, <nl>  	} <nl>   <nl>  	i = port->index; <nl> +	memset(&sync, 0, sizeof(sync)); <nl>  	sync.clock_rate = FST_RDL(card, portConfig[i].lineSpeed); <nl>  	/* Lucky card and linux use same encoding here */ <nl>  	sync.clock_type = FST_RDB(card, portConfig[i].internalClock) ==
@@ -1253,7 +1253,6 @@ static void uart_close(struct tty_struct *tty, struct file *filp) <nl>   <nl>  	pr_debug("uart_close(%d) called\n", uport->line); <nl>   <nl> -	mutex_lock(&port->mutex); <nl>  	spin_lock_irqsave(&port->lock, flags); <nl>   <nl>  	if (tty_hung_up_p(filp)) { <nl> @@ -1312,6 +1311,7 @@ static void uart_close(struct tty_struct *tty, struct file *filp) <nl>  		uart_wait_until_sent(tty, uport->timeout); <nl>  	} <nl>   <nl> +	mutex_lock(&port->mutex); <nl>  	uart_shutdown(tty, state); <nl>  	uart_flush_buffer(tty); <nl>  
@@ -1284,7 +1284,7 @@ int ocfs2_xattr_get_nolock(struct inode *inode, <nl>  		return -EOPNOTSUPP; <nl>   <nl>  	if (!(oi->ip_dyn_features & OCFS2_HAS_XATTR_FL)) <nl> -		ret = -ENODATA; <nl> +		return -ENODATA; <nl>   <nl>  	xis.inode_bh = xbs.inode_bh = di_bh; <nl>  	di = (struct ocfs2_dinode *)di_bh->b_data;
@@ -138,11 +138,6 @@ static int pxa3xx_pmx_enable(struct pinctrl_dev *pctrldev, unsigned func, <nl>  	return 0; <nl>  } <nl>   <nl> -static void pxa3xx_pmx_disable(struct pinctrl_dev *pctrldev, unsigned func, <nl> -			       unsigned group) <nl> -{ <nl> -} <nl> - <nl>  static int pxa3xx_pmx_request_gpio(struct pinctrl_dev *pctrldev, <nl>  				   struct pinctrl_gpio_range *range, <nl>  				   unsigned pin) <nl> @@ -170,7 +165,6 @@ static struct pinmux_ops pxa3xx_pmx_ops = { <nl>  	.get_function_name	= pxa3xx_pmx_get_func_name, <nl>  	.get_function_groups	= pxa3xx_pmx_get_groups, <nl>  	.enable			= pxa3xx_pmx_enable, <nl> -	.disable		= pxa3xx_pmx_disable, <nl>  	.gpio_request_enable	= pxa3xx_pmx_request_gpio, <nl>  }; <nl>  
@@ -2030,11 +2030,9 @@ int drm_mode_getconnector(struct drm_device *dev, void *data, <nl>   <nl>  	props_count = connector->properties.count; <nl>   <nl> -	for (i = 0; i < DRM_CONNECTOR_MAX_ENCODER; i++) { <nl> -		if (connector->encoder_ids[i] != 0) { <nl> +	for (i = 0; i < DRM_CONNECTOR_MAX_ENCODER; i++) <nl> +		if (connector->encoder_ids[i] != 0) <nl>  			encoders_count++; <nl> -		} <nl> -	} <nl>   <nl>  	if (out_resp->count_modes == 0) { <nl>  		connector->funcs->fill_modes(connector,
@@ -800,6 +800,10 @@ static int is_valid_state_transition(struct drbd_conf *mdev, <nl>  	    os.conn < C_CONNECTED) <nl>  		rv = SS_NEED_CONNECTION; <nl>   <nl> +	if ((ns.conn == C_SYNC_TARGET || ns.conn == C_SYNC_SOURCE) <nl> +	    && os.conn < C_WF_REPORT_PARAMS) <nl> +		rv = SS_NEED_CONNECTION; /* No NetworkFailure -> SyncTarget etc... */ <nl> + <nl>  	return rv; <nl>  } <nl>  
@@ -1368,6 +1368,7 @@ int tcp_read_sock(struct sock *sk, read_descriptor_t *desc, <nl>  		sk_eat_skb(sk, skb, 0); <nl>  		if (!desc->count) <nl>  			break; <nl> +		tp->copied_seq = seq; <nl>  	} <nl>  	tp->copied_seq = seq; <nl>  
@@ -1230,6 +1230,8 @@ static int acm_probe(struct usb_interface *intf, <nl>  		i = device_create_file(&intf->dev, &dev_attr_wCountryCodes); <nl>  		if (i < 0) { <nl>  			kfree(acm->country_codes); <nl> +			acm->country_codes = NULL; <nl> +			acm->country_code_size = 0; <nl>  			goto skip_countries; <nl>  		} <nl>   <nl> @@ -1238,6 +1240,8 @@ static int acm_probe(struct usb_interface *intf, <nl>  		if (i < 0) { <nl>  			device_remove_file(&intf->dev, &dev_attr_wCountryCodes); <nl>  			kfree(acm->country_codes); <nl> +			acm->country_codes = NULL; <nl> +			acm->country_code_size = 0; <nl>  			goto skip_countries; <nl>  		} <nl>  	}
@@ -142,6 +142,9 @@ int pvr2_debugifc_print_info(struct pvr2_hdw *hdw,char *buf,unsigned int acnt) <nl>  { <nl>  	int bcnt = 0; <nl>  	int ccnt; <nl> +	ccnt = scnprintf(buf, acnt, "Driver hardware description: %s\n", <nl> +			 pvr2_hdw_get_desc(hdw)); <nl> +	bcnt += ccnt; acnt -= ccnt; buf += ccnt; <nl>  	ccnt = scnprintf(buf,acnt,"Driver state info:\n"); <nl>  	bcnt += ccnt; acnt -= ccnt; buf += ccnt; <nl>  	ccnt = pvr2_hdw_state_report(hdw,buf,acnt);
@@ -477,6 +477,8 @@ static int sample(struct datapath *dp, struct sk_buff *skb, <nl>  		skb_get(skb); <nl>  	} else { <nl>  		sample_skb = skb_clone(skb, GFP_ATOMIC); <nl> +		if (!sample_skb) /* Skip sample action when out of memory. */ <nl> +			return 0; <nl>  	} <nl>   <nl>  	/* Note that do_execute_actions() never consumes skb.
@@ -696,6 +696,7 @@ static const struct pinmux_ops sunxi_pmx_ops = { <nl>  	.get_function_groups	= sunxi_pmx_get_func_groups, <nl>  	.set_mux		= sunxi_pmx_set_mux, <nl>  	.gpio_set_direction	= sunxi_pmx_gpio_set_direction, <nl> +	.strict			= true, <nl>  }; <nl>   <nl>  static int sunxi_pinctrl_gpio_direction_input(struct gpio_chip *chip,
@@ -206,7 +206,7 @@ static void __init cps_prepare_cpus(unsigned int max_cpus) <nl>  	} <nl>  } <nl>   <nl> -static void boot_core(unsigned core) <nl> +static void boot_core(unsigned int core, unsigned int vpe_id) <nl>  { <nl>  	u32 access, stat, seq_state; <nl>  	unsigned timeout; <nl> @@ -233,8 +233,9 @@ static void boot_core(unsigned core) <nl>  		mips_cpc_lock_other(core); <nl>   <nl>  		if (mips_cm_revision() >= CM_REV_CM3) { <nl> -			/* Run VP0 following the reset */ <nl> -			write_cpc_co_vp_run(0x1); <nl> +			/* Run only the requested VP following the reset */ <nl> +			write_cpc_co_vp_stop(0xf); <nl> +			write_cpc_co_vp_run(1 << vpe_id); <nl>   <nl>  			/* <nl>  			 * Ensure that the VP_RUN register is written before the <nl> @@ -306,7 +307,7 @@ static void cps_boot_secondary(int cpu, struct task_struct *idle) <nl>   <nl>  	if (!test_bit(core, core_power)) { <nl>  		/* Boot a VPE on a powered down core */ <nl> -		boot_core(core); <nl> +		boot_core(core, vpe_id); <nl>  		goto out; <nl>  	} <nl>  
@@ -904,6 +904,7 @@ static size_t exynos_iommu_unmap(struct iommu_domain *domain, <nl>  	if (lv2ent_small(ent)) { <nl>  		*ent = 0; <nl>  		size = SPAGE_SIZE; <nl> +		pgtable_flush(ent, ent + 1); <nl>  		priv->lv2entcnt[lv1ent_offset(iova)] += 1; <nl>  		goto done; <nl>  	} <nl> @@ -915,6 +916,7 @@ static size_t exynos_iommu_unmap(struct iommu_domain *domain, <nl>  	} <nl>   <nl>  	memset(ent, 0, sizeof(*ent) * SPAGES_PER_LPAGE); <nl> +	pgtable_flush(ent, ent + SPAGES_PER_LPAGE); <nl>   <nl>  	size = LPAGE_SIZE; <nl>  	priv->lv2entcnt[lv1ent_offset(iova)] += SPAGES_PER_LPAGE;
@@ -933,7 +933,13 @@ static int upgrade_fw(struct adapter *adap) <nl>  		if (!ret) <nl>  			dev_info(dev, "firmware upgraded to version %pI4 from " <nl>  				 FW_FNAME "\n", &hdr->fw_ver); <nl> +	} else { <nl> +		/* <nl> +		 * Tell our caller that we didn't upgrade the firmware. <nl> +		 */ <nl> +		ret = -EINVAL; <nl>  	} <nl> + <nl>  out:	release_firmware(fw); <nl>  	return ret; <nl>  }
@@ -1835,6 +1835,7 @@ static void __ccw_device_pm_restore(struct ccw_device *cdev) <nl>  	 * available again. Kick re-detection. <nl>  	 */ <nl>  	cdev->private->flags.resuming = 1; <nl> +	cdev->private->path_new_mask = LPM_ANYPATH; <nl>  	css_schedule_eval(sch->schid); <nl>  	spin_unlock_irq(sch->lock); <nl>  	css_complete_work();
@@ -328,11 +328,12 @@ e1000_up(struct e1000_adapter *adapter) <nl>  		return err; <nl>   <nl>  	mod_timer(&adapter->watchdog_timer, jiffies); <nl> -	e1000_irq_enable(adapter); <nl>   <nl>  #ifdef CONFIG_E1000_NAPI <nl>  	netif_poll_enable(netdev); <nl>  #endif <nl> +	e1000_irq_enable(adapter); <nl> + <nl>  	return 0; <nl>  } <nl>  
@@ -1634,7 +1634,8 @@ void rtw_alloc_hwxmits(struct adapter *padapter) <nl>   <nl>  	pxmitpriv->hwxmit_entry = HWXMIT_ENTRY; <nl>   <nl> -	pxmitpriv->hwxmits = kzalloc(sizeof(struct hw_xmit) * pxmitpriv->hwxmit_entry, GFP_KERNEL); <nl> +	pxmitpriv->hwxmits = kcalloc(pxmitpriv->hwxmit_entry, <nl> +				     sizeof(struct hw_xmit), GFP_KERNEL); <nl>   <nl>  	hwxmits = pxmitpriv->hwxmits; <nl>  
@@ -960,10 +960,12 @@ int usb_get_bos_descriptor(struct usb_device *dev) <nl>  	for (i = 0; i < num; i++) { <nl>  		buffer += length; <nl>  		cap = (struct usb_dev_cap_header *)buffer; <nl> -		length = cap->bLength; <nl>   <nl> -		if (total_len < length) <nl> +		if (total_len < sizeof(*cap) || total_len < cap->bLength) { <nl> +			dev->bos->desc->bNumDeviceCaps = i; <nl>  			break; <nl> +		} <nl> +		length = cap->bLength; <nl>  		total_len -= length; <nl>   <nl>  		if (cap->bDescriptorType != USB_DT_DEVICE_CAPABILITY) {
@@ -852,7 +852,7 @@ static int tg3_bmcr_reset(struct tg3 *tp) <nl>  		} <nl>  		udelay(10); <nl>  	} <nl> -	if (limit <= 0) <nl> +	if (limit < 0) <nl>  		return -EBUSY; <nl>   <nl>  	return 0; <nl> @@ -1603,7 +1603,7 @@ static int tg3_wait_macro_done(struct tg3 *tp) <nl>  				break; <nl>  		} <nl>  	} <nl> -	if (limit <= 0) <nl> +	if (limit < 0) <nl>  		return -EBUSY; <nl>   <nl>  	return 0;
@@ -84,7 +84,7 @@ static int tlv320aic23_write(struct snd_soc_codec *codec, unsigned int reg, <nl>  			     unsigned int value) <nl>  { <nl>   <nl> -	u8 data; <nl> +	u8 data[2]; <nl>   <nl>  	/* TLV320AIC23 has 7 bit address and 9 bits of data <nl>  	 * so we need to switch one data bit into reg and rest <nl> @@ -96,12 +96,12 @@ static int tlv320aic23_write(struct snd_soc_codec *codec, unsigned int reg, <nl>  		return -1; <nl>  	} <nl>   <nl> -	data = (reg << 1) | (value >> 8 & 0x01); <nl> +	data[0] = (reg << 1) | (value >> 8 & 0x01); <nl> +	data[1] = value & 0xff; <nl>   <nl>  	tlv320aic23_write_reg_cache(codec, reg, value); <nl>   <nl> -	if (codec->hw_write(codec->control_data, data, <nl> -			    (value & 0xff)) == 0) <nl> +	if (codec->hw_write(codec->control_data, data, 2) == 2) <nl>  		return 0; <nl>   <nl>  	printk(KERN_ERR "%s cannot write %03x to register R%d\n", __func__, <nl> @@ -674,7 +674,7 @@ static int tlv320aic23_probe(struct platform_device *pdev) <nl>   <nl>  	tlv320aic23_socdev = socdev; <nl>  #if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE) <nl> -	codec->hw_write = (hw_write_t) i2c_smbus_write_byte_data; <nl> +	codec->hw_write = (hw_write_t) i2c_master_send; <nl>  	codec->hw_read = NULL; <nl>  	ret = i2c_add_driver(&tlv320aic23_i2c_driver); <nl>  	if (ret != 0)
@@ -3825,6 +3825,7 @@ static int easycap_usb_probe(struct usb_interface *intf, <nl>  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */ <nl>  			pdata_urb = kzalloc(sizeof(struct data_urb), GFP_KERNEL); <nl>  			if (!pdata_urb) { <nl> +				usb_free_urb(purb); <nl>  				SAM("ERROR: Could not allocate struct data_urb.\n"); <nl>  				return -ENOMEM; <nl>  			}
@@ -146,6 +146,10 @@ static int create_pnp_modalias(struct acpi_device *acpi_dev, char *modalias, <nl>  	int count; <nl>  	struct acpi_hardware_id *id; <nl>   <nl> +	/* Avoid unnecessarily loading modules for non present devices. */ <nl> +	if (!acpi_device_is_present(acpi_dev)) <nl> +		return 0; <nl> + <nl>  	/* <nl>  	 * Since we skip ACPI_DT_NAMESPACE_HID from the modalias below, 0 should <nl>  	 * be returned if ACPI_DT_NAMESPACE_HID is the only ACPI/PNP ID in the
@@ -3183,6 +3183,16 @@ static int cgroup_enable_threaded(struct cgroup *cgrp) <nl>  	if (cgroup_is_threaded(cgrp)) <nl>  		return 0; <nl>   <nl> +	/* <nl> +	 * If @cgroup is populated or has domain controllers enabled, it <nl> +	 * can't be switched.  While the below cgroup_can_be_thread_root() <nl> +	 * test can catch the same conditions, that's only when @parent is <nl> +	 * not mixable, so let's check it explicitly. <nl> +	 */ <nl> +	if (cgroup_is_populated(cgrp) || <nl> +	    cgrp->subtree_control & ~cgrp_dfl_threaded_ss_mask) <nl> +		return -EOPNOTSUPP; <nl> + <nl>  	/* we're joining the parent's domain, ensure its validity */ <nl>  	if (!cgroup_is_valid_domain(dom_cgrp) || <nl>  	    !cgroup_can_be_thread_root(dom_cgrp))
@@ -1197,7 +1197,6 @@ void ide_do_drive_cmd(ide_drive_t *drive, struct request *rq) <nl>   <nl>  	spin_lock_irqsave(q->queue_lock, flags); <nl>  	__elv_add_request(q, rq, ELEVATOR_INSERT_FRONT, 0); <nl> -	blk_start_queueing(q); <nl>  	spin_unlock_irqrestore(q->queue_lock, flags); <nl>  } <nl>  EXPORT_SYMBOL(ide_do_drive_cmd);
@@ -71,7 +71,7 @@ static struct nvmem_config imx_ocotp_nvmem_config = { <nl>   <nl>  static const struct of_device_id imx_ocotp_dt_ids[] = { <nl>  	{ .compatible = "fsl,imx6q-ocotp",  (void *)128 }, <nl> -	{ .compatible = "fsl,imx6sl-ocotp", (void *)32 }, <nl> +	{ .compatible = "fsl,imx6sl-ocotp", (void *)64 }, <nl>  	{ .compatible = "fsl,imx6sx-ocotp", (void *)128 }, <nl>  	{ }, <nl>  };
@@ -121,6 +121,13 @@ static struct dentry *proc_mount(struct file_system_type *fs_type, <nl>  	if (IS_ERR(sb)) <nl>  		return ERR_CAST(sb); <nl>   <nl> +	/* <nl> +	 * procfs isn't actually a stacking filesystem; however, there is <nl> +	 * too much magic going on inside it to permit stacking things on <nl> +	 * top of it <nl> +	 */ <nl> +	sb->s_stack_depth = FILESYSTEM_MAX_STACK_DEPTH; <nl> + <nl>  	if (!proc_parse_options(options, ns)) { <nl>  		deactivate_locked_super(sb); <nl>  		return ERR_PTR(-EINVAL);
@@ -2209,8 +2209,10 @@ int btrfs_del_dir_entries_in_log(struct btrfs_trans_handle *trans, <nl>   <nl>  	log = root->log_root; <nl>  	path = btrfs_alloc_path(); <nl> -	if (!path) <nl> -		return -ENOMEM; <nl> +	if (!path) { <nl> +		err = -ENOMEM; <nl> +		goto out_unlock; <nl> +	} <nl>   <nl>  	di = btrfs_lookup_dir_item(trans, log, path, dir->i_ino, <nl>  				   name, name_len, -1); <nl> @@ -2271,6 +2273,7 @@ int btrfs_del_dir_entries_in_log(struct btrfs_trans_handle *trans, <nl>  	} <nl>  fail: <nl>  	btrfs_free_path(path); <nl> +out_unlock: <nl>  	mutex_unlock(&BTRFS_I(dir)->log_mutex); <nl>  	if (ret == -ENOSPC) { <nl>  		root->fs_info->last_trans_log_full_commit = trans->transid;
@@ -157,7 +157,7 @@ vbuschannel_devinfo_to_string(struct ultra_vbus_deviceinfo *devinfo, <nl>  	int nsrc, x, i, pad; <nl>  	int chars = 0; <nl>   <nl> -	psrc = &(devinfo->devtype[0]); <nl> +	psrc = &devinfo->devtype[0]; <nl>  	nsrc = sizeof(devinfo->devtype); <nl>  	if (vbuschannel_sanitize_buffer(NULL, 0, psrc, nsrc) <= 0) <nl>  		return 0; <nl> @@ -187,7 +187,7 @@ vbuschannel_devinfo_to_string(struct ultra_vbus_deviceinfo *devinfo, <nl>  	VBUSCHANNEL_ADDACHAR(' ', p, remain, chars); <nl>   <nl>  	/* emit driver name */ <nl> -	psrc = &(devinfo->drvname[0]); <nl> +	psrc = &devinfo->drvname[0]; <nl>  	nsrc = sizeof(devinfo->drvname); <nl>  	x = vbuschannel_sanitize_buffer(p, remain, psrc, nsrc); <nl>  	p += x; <nl> @@ -199,7 +199,7 @@ vbuschannel_devinfo_to_string(struct ultra_vbus_deviceinfo *devinfo, <nl>  	VBUSCHANNEL_ADDACHAR(' ', p, remain, chars); <nl>   <nl>  	/* emit strings */ <nl> -	psrc = &(devinfo->infostrs[0]); <nl> +	psrc = &devinfo->infostrs[0]; <nl>  	nsrc = sizeof(devinfo->infostrs); <nl>  	x = vbuschannel_sanitize_buffer(p, remain, psrc, nsrc); <nl>  	p += x;
@@ -2074,7 +2074,7 @@ static int pm_genpd_summary_one(struct seq_file *s, <nl>   <nl>  	if (WARN_ON(genpd->status >= ARRAY_SIZE(status_lookup))) <nl>  		goto exit; <nl> -	seq_printf(s, "%-30s  %-15s  ", genpd->name, status_lookup[genpd->status]); <nl> +	seq_printf(s, "%-30s  %-15s ", genpd->name, status_lookup[genpd->status]); <nl>   <nl>  	/* <nl>  	 * Modifications on the list require holding locks on both <nl> @@ -2109,8 +2109,8 @@ static int pm_genpd_summary_show(struct seq_file *s, void *data) <nl>  	struct generic_pm_domain *genpd; <nl>  	int ret = 0; <nl>   <nl> -	seq_puts(s, "    domain                      status         slaves\n"); <nl> -	seq_puts(s, "           /device                                      runtime status\n"); <nl> +	seq_puts(s, "domain                          status          slaves\n"); <nl> +	seq_puts(s, "    /device                                             runtime status\n"); <nl>  	seq_puts(s, "----------------------------------------------------------------------\n"); <nl>   <nl>  	ret = mutex_lock_interruptible(&gpd_list_lock);
@@ -347,8 +347,9 @@ static noinline int compress_file_range(struct inode *inode, <nl>  	int will_compress; <nl>  	int compress_type = root->fs_info->compress_type; <nl>   <nl> -	/* if this is a small write inside eof, kick off a defragbot */ <nl> -	if (end <= BTRFS_I(inode)->disk_i_size && (end - start + 1) < 16 * 1024) <nl> +	/* if this is a small write inside eof, kick off a defrag */ <nl> +	if ((end - start + 1) < 16 * 1024 && <nl> +	    (start > 0 || end + 1 < BTRFS_I(inode)->disk_i_size)) <nl>  		btrfs_add_inode_defrag(NULL, inode); <nl>   <nl>  	actual_end = min_t(u64, isize, end + 1); <nl> @@ -843,7 +844,8 @@ static noinline int cow_file_range(struct inode *inode, <nl>  	ret = 0; <nl>   <nl>  	/* if this is a small write inside eof, kick off defrag */ <nl> -	if (end <= BTRFS_I(inode)->disk_i_size && num_bytes < 64 * 1024) <nl> +	if (num_bytes < 64 * 1024 && <nl> +	    (start > 0 || end + 1 < BTRFS_I(inode)->disk_i_size)) <nl>  		btrfs_add_inode_defrag(trans, inode); <nl>   <nl>  	if (start == 0) {
@@ -1576,6 +1576,7 @@ struct qcom_glink *qcom_glink_native_probe(struct device *dev, <nl>  	idr_init(&glink->rcids); <nl>   <nl>  	glink->mbox_client.dev = dev; <nl> +	glink->mbox_client.knows_txdone = true; <nl>  	glink->mbox_chan = mbox_request_channel(&glink->mbox_client, 0); <nl>  	if (IS_ERR(glink->mbox_chan)) { <nl>  		if (PTR_ERR(glink->mbox_chan) != -EPROBE_DEFER)
@@ -222,6 +222,7 @@ efx_mcdi_mon_add_attr(struct efx_nic *efx, const char *name, <nl>  	attr->index = index; <nl>  	attr->type = type; <nl>  	attr->limit_value = limit_value; <nl> +	sysfs_attr_init(&attr->dev_attr.attr); <nl>  	attr->dev_attr.attr.name = attr->name; <nl>  	attr->dev_attr.attr.mode = S_IRUGO; <nl>  	attr->dev_attr.show = reader;
@@ -240,13 +240,9 @@ static struct fdtable *alloc_fdtable(int nr) <nl>  	if (!fdt) <nl>    		goto out; <nl>   <nl> -	nfds = 8 * L1_CACHE_BYTES; <nl> -  	/* Expand to the max in easy steps */ <nl> -  	while (nfds <= nr) { <nl> -		nfds = nfds * 2; <nl> -		if (nfds > NR_OPEN) <nl> -			nfds = NR_OPEN; <nl> -	} <nl> +	nfds = max_t(int, 8 * L1_CACHE_BYTES, roundup_pow_of_two(nfds)); <nl> +	if (nfds > NR_OPEN) <nl> +		nfds = NR_OPEN; <nl>   <nl>    	new_openset = alloc_fdset(nfds); <nl>    	new_execset = alloc_fdset(nfds);
@@ -630,6 +630,7 @@ static int rdma_cma_handler(struct rdma_cm_id *cma_id, <nl>  		if (xprt) { <nl>  			set_bit(XPT_CLOSE, &xprt->xpt_flags); <nl>  			svc_xprt_enqueue(xprt); <nl> +			svc_xprt_put(xprt); <nl>  		} <nl>  		break; <nl>  	case RDMA_CM_EVENT_DEVICE_REMOVAL:
@@ -531,7 +531,7 @@ static int alloc_mad(struct ib_sa_query *query, gfp_t gfp_mask) <nl>  					    query->sm_ah->pkey_index, <nl>  					    0, IB_MGMT_SA_HDR, IB_MGMT_SA_DATA, <nl>  					    gfp_mask); <nl> -	if (!query->mad_buf) { <nl> +	if (IS_ERR(query->mad_buf)) { <nl>  		kref_put(&query->sm_ah->ref, free_sm_ah); <nl>  		return -ENOMEM; <nl>  	}
@@ -56,8 +56,10 @@ static int dlm_add_member(struct dlm_ls *ls, int nodeid) <nl>  		return -ENOMEM; <nl>   <nl>  	w = dlm_node_weight(ls->ls_name, nodeid); <nl> -	if (w < 0) <nl> +	if (w < 0) { <nl> +		kfree(memb); <nl>  		return w; <nl> +	} <nl>   <nl>  	memb->nodeid = nodeid; <nl>  	memb->weight = w;
@@ -155,11 +155,11 @@ static int sxgbe_platform_probe(struct platform_device *pdev) <nl>  	return 0; <nl>   <nl>  err_rx_irq_unmap: <nl> -	while (--i) <nl> +	while (i--) <nl>  		irq_dispose_mapping(priv->rxq[i]->irq_no); <nl>  	i = SXGBE_TX_QUEUES; <nl>  err_tx_irq_unmap: <nl> -	while (--i) <nl> +	while (i--) <nl>  		irq_dispose_mapping(priv->txq[i]->irq_no); <nl>  	irq_dispose_mapping(priv->irq); <nl>  err_drv_remove:
@@ -1048,7 +1048,7 @@ static int bpf_tcp_sendmsg(struct sock *sk, struct msghdr *msg, size_t size) <nl>  	timeo = sock_sndtimeo(sk, msg->msg_flags & MSG_DONTWAIT); <nl>   <nl>  	while (msg_data_left(msg)) { <nl> -		struct sk_msg_buff *m; <nl> +		struct sk_msg_buff *m = NULL; <nl>  		bool enospc = false; <nl>  		int copy; <nl>   <nl> @@ -1116,8 +1116,11 @@ static int bpf_tcp_sendmsg(struct sock *sk, struct msghdr *msg, size_t size) <nl>  		set_bit(SOCK_NOSPACE, &sk->sk_socket->flags); <nl>  wait_for_memory: <nl>  		err = sk_stream_wait_memory(sk, &timeo); <nl> -		if (err) <nl> +		if (err) { <nl> +			if (m && m != psock->cork) <nl> +				free_start_sg(sk, m); <nl>  			goto out_err; <nl> +		} <nl>  	} <nl>  out_err: <nl>  	if (err < 0)
@@ -4580,10 +4580,10 @@ int x86_decode_insn(struct x86_emulate_ctxt *ctxt, void *insn, int insn_len) <nl>  	/* Decode and fetch the destination operand: register or memory. */ <nl>  	rc = decode_operand(ctxt, &ctxt->dst, (ctxt->d >> DstShift) & OpMask); <nl>   <nl> -done: <nl>  	if (ctxt->rip_relative) <nl>  		ctxt->memopp->addr.mem.ea += ctxt->_eip; <nl>   <nl> +done: <nl>  	return (rc != X86EMUL_CONTINUE) ? EMULATION_FAILED : EMULATION_OK; <nl>  } <nl>  
@@ -2078,7 +2078,7 @@ void rtl8188eu_set_hal_ops(struct adapter *adapt) <nl>   <nl>   <nl>  	adapt->HalData = kzalloc(sizeof(struct hal_data_8188e), GFP_KERNEL); <nl> -	if (adapt->HalData == NULL) <nl> +	if (!adapt->HalData) <nl>  		DBG_88E("cant not alloc memory for HAL DATA\n"); <nl>   <nl>  	halfunc->hal_power_on = rtl8188eu_InitPowerOn;
@@ -300,6 +300,8 @@ static int ext4_valid_extent(struct inode *inode, struct ext4_extent *ext) <nl>  	ext4_fsblk_t block = ext4_ext_pblock(ext); <nl>  	int len = ext4_ext_get_actual_len(ext); <nl>   <nl> +	if (len == 0) <nl> +		return 0; <nl>  	return ext4_data_block_valid(EXT4_SB(inode->i_sb), block, len); <nl>  } <nl>  
@@ -1236,6 +1236,9 @@ static inline struct sk_buff *sk_stream_alloc_pskb(struct sock *sk, <nl>  { <nl>  	struct sk_buff *skb; <nl>   <nl> +	/* The TCP header must be at least 32-bit aligned.  */ <nl> +	size = ALIGN(size, 4); <nl> + <nl>  	skb = alloc_skb_fclone(size + sk->sk_prot->max_header, gfp); <nl>  	if (skb) { <nl>  		skb->truesize += mem;
@@ -1426,7 +1426,7 @@ static int perf_sched__process_tracepoint_sample(struct perf_tool *tool __maybe_ <nl>  						 struct perf_evsel *evsel, <nl>  						 struct machine *machine) <nl>  { <nl> -	struct thread *thread = machine__findnew_thread(machine, sample->pid); <nl> +	struct thread *thread = machine__findnew_thread(machine, sample->tid); <nl>  	int err = 0; <nl>   <nl>  	if (thread == NULL) {
@@ -327,6 +327,7 @@ static void __init setup_lowcore(void) <nl>  		+ PAGE_SIZE - STACK_FRAME_OVERHEAD - sizeof(struct pt_regs); <nl>  	lc->current_task = (unsigned long) init_thread_union.thread_info.task; <nl>  	lc->thread_info = (unsigned long) &init_thread_union; <nl> +	lc->lpp = LPP_MAGIC; <nl>  	lc->machine_flags = S390_lowcore.machine_flags; <nl>  	lc->stfl_fac_list = S390_lowcore.stfl_fac_list; <nl>  	memcpy(lc->stfle_fac_list, S390_lowcore.stfle_fac_list,
@@ -328,8 +328,10 @@ rcu_perf_reader(void *arg) <nl>  { <nl>  	unsigned long flags; <nl>  	int idx; <nl> +	long me = (long)arg; <nl>   <nl>  	VERBOSE_PERFOUT_STRING("rcu_perf_reader task started"); <nl> +	set_cpus_allowed_ptr(current, cpumask_of(me % nr_cpu_ids)); <nl>  	set_user_nice(current, MAX_NICE); <nl>  	atomic_inc(&n_rcu_perf_reader_started); <nl>   <nl> @@ -362,6 +364,7 @@ rcu_perf_writer(void *arg) <nl>  	WARN_ON(rcu_gp_is_expedited() && !rcu_gp_is_normal() && !gp_exp); <nl>  	WARN_ON(rcu_gp_is_normal() && gp_exp); <nl>  	WARN_ON(!wdpp); <nl> +	set_cpus_allowed_ptr(current, cpumask_of(me % nr_cpu_ids)); <nl>  	t = ktime_get_mono_fast_ns(); <nl>  	if (atomic_inc_return(&n_rcu_perf_writer_started) >= nrealwriters) { <nl>  		t_rcu_perf_writer_started = t; <nl> @@ -594,7 +597,7 @@ rcu_perf_init(void) <nl>  		goto unwind; <nl>  	} <nl>  	for (i = 0; i < nrealreaders; i++) { <nl> -		firsterr = torture_create_kthread(rcu_perf_reader, NULL, <nl> +		firsterr = torture_create_kthread(rcu_perf_reader, (void *)i, <nl>  						  reader_tasks[i]); <nl>  		if (firsterr) <nl>  			goto unwind;
@@ -1346,6 +1346,7 @@ static int option_probe(struct usb_serial *serial, <nl>  		serial->interface->cur_altsetting->desc.bInterfaceNumber, <nl>  		OPTION_BLACKLIST_RESERVED_IF, <nl>  		(const struct option_blacklist_info *) id->driver_info)) <nl> +		return -ENODEV; <nl>   <nl>  	/* Don't bind network interface on Samsung GT-B3730, it is handled by a separate module */ <nl>  	if (serial->dev->descriptor.idVendor == SAMSUNG_VENDOR_ID &&
@@ -324,7 +324,10 @@ static int __devinit tps_65023_probe(struct i2c_client *client, <nl>   <nl>  		tps->desc[i].name = info->name; <nl>  		tps->desc[i].id = i; <nl> -		tps->desc[i].n_voltages = info->table_len; <nl> +		if (info->fixed) <nl> +			tps->desc[i].n_voltages = 1; <nl> +		else <nl> +			tps->desc[i].n_voltages = info->table_len; <nl>  		tps->desc[i].ops = (i > TPS65023_DCDC_3 ? <nl>  					&tps65023_ldo_ops : &tps65023_dcdc_ops); <nl>  		tps->desc[i].type = REGULATOR_VOLTAGE;
@@ -774,11 +774,10 @@ static int thunderx_lmc_probe(struct pci_dev *pdev, <nl>   <nl>  	lmc->xor_bank = lmc_control & LMC_CONTROL_XOR_BANK; <nl>   <nl> -	l2c_ioaddr = ioremap(L2C_CTL | FIELD_PREP(THUNDERX_NODE, lmc->node), <nl> -			     PAGE_SIZE); <nl> - <nl> +	l2c_ioaddr = ioremap(L2C_CTL | FIELD_PREP(THUNDERX_NODE, lmc->node), PAGE_SIZE); <nl>  	if (!l2c_ioaddr) { <nl>  		dev_err(&pdev->dev, "Cannot map L2C_CTL\n"); <nl> +		ret = -ENOMEM; <nl>  		goto err_free; <nl>  	} <nl>  
@@ -266,6 +266,7 @@ static int fcoe_interface_setup(struct fcoe_interface *fcoe, <nl>  	if ((netdev->priv_flags & IFF_MASTER_ALB) || <nl>  	    (netdev->priv_flags & IFF_SLAVE_INACTIVE) || <nl>  	    (netdev->priv_flags & IFF_MASTER_8023AD)) { <nl> +		FCOE_NETDEV_DBG(netdev, "Bonded interfaces not supported\n"); <nl>  		return -EOPNOTSUPP; <nl>  	} <nl>   <nl> @@ -323,6 +324,7 @@ static int fcoe_interface_setup(struct fcoe_interface *fcoe, <nl>  static struct fcoe_interface *fcoe_interface_create(struct net_device *netdev) <nl>  { <nl>  	struct fcoe_interface *fcoe; <nl> +	int err; <nl>   <nl>  	fcoe = kzalloc(sizeof(*fcoe), GFP_KERNEL); <nl>  	if (!fcoe) { <nl> @@ -341,7 +343,13 @@ static struct fcoe_interface *fcoe_interface_create(struct net_device *netdev) <nl>  	fcoe->ctlr.update_mac = fcoe_update_src_mac; <nl>  	fcoe->ctlr.get_src_addr = fcoe_get_src_mac; <nl>   <nl> -	fcoe_interface_setup(fcoe, netdev); <nl> +	err = fcoe_interface_setup(fcoe, netdev); <nl> +	if (err) { <nl> +		fcoe_ctlr_destroy(&fcoe->ctlr); <nl> +		kfree(fcoe); <nl> +		dev_put(netdev); <nl> +		return NULL; <nl> +	} <nl>   <nl>  	return fcoe; <nl>  }
@@ -1352,7 +1352,7 @@ static struct input_dev *gb_svc_input_create(struct gb_svc *svc) <nl>  	return input_dev; <nl>   <nl>  err_free_input: <nl> -	input_free_device(svc->input); <nl> +	input_free_device(input_dev); <nl>  	return ERR_PTR(-ENOMEM); <nl>  } <nl>  
@@ -156,6 +156,9 @@ static int ttusbdecfe_dvbs_diseqc_send_master_cmd(struct dvb_frontend* fe, struc <nl>  		   0x00, 0x00, 0x00, 0x00, <nl>  		   0x00, 0x00 }; <nl>   <nl> +	if (cmd->msg_len > sizeof(b) - 4) <nl> +		return -EINVAL; <nl> + <nl>  	memcpy(&b[4], cmd->msg, cmd->msg_len); <nl>   <nl>  	state->config->send_command(fe, 0x72,
@@ -195,7 +195,7 @@ int iwlagn_mac_setup_register(struct iwl_priv *priv, <nl>  			ARRAY_SIZE(iwlagn_iface_combinations_dualmode); <nl>  	} <nl>   <nl> -	hw->wiphy->max_remain_on_channel_duration = 1000; <nl> +	hw->wiphy->max_remain_on_channel_duration = 500; <nl>   <nl>  	hw->wiphy->flags |= WIPHY_FLAG_CUSTOM_REGULATORY | <nl>  			    WIPHY_FLAG_DISABLE_BEACON_HINTS |
@@ -543,7 +543,6 @@ static int wm8731_probe(struct snd_soc_codec *codec) <nl>  err_regulator_get: <nl>  	regulator_bulk_free(ARRAY_SIZE(wm8731->supplies), wm8731->supplies); <nl>   <nl> -	kfree(wm8731); <nl>  	return ret; <nl>  } <nl>  
@@ -1273,6 +1273,7 @@ static void v4l_fill_fmtdesc(struct v4l2_fmtdesc *fmt) <nl>  		case V4L2_PIX_FMT_VC1_ANNEX_L:	descr = "VC-1 (SMPTE 412M Annex L)"; break; <nl>  		case V4L2_PIX_FMT_VP8:		descr = "VP8"; break; <nl>  		case V4L2_PIX_FMT_VP9:		descr = "VP9"; break; <nl> +		case V4L2_PIX_FMT_HEVC:		descr = "HEVC"; break; /* aka H.265 */ <nl>  		case V4L2_PIX_FMT_CPIA1:	descr = "GSPCA CPiA YUV"; break; <nl>  		case V4L2_PIX_FMT_WNVA:		descr = "WNVA"; break; <nl>  		case V4L2_PIX_FMT_SN9C10X:	descr = "GSPCA SN9C10X"; break;
@@ -253,6 +253,9 @@ static long ir_lirc_ioctl(struct file *filep, unsigned int cmd, <nl>  					       val); <nl>   <nl>  	case LIRC_SET_REC_CARRIER_RANGE: <nl> +		if (!dev->s_rx_carrier_range) <nl> +			return -ENOTTY; <nl> + <nl>  		if (val <= 0) <nl>  			return -EINVAL; <nl>   <nl> @@ -305,6 +308,9 @@ static long ir_lirc_ioctl(struct file *filep, unsigned int cmd, <nl>  		break; <nl>   <nl>  	case LIRC_SET_REC_TIMEOUT_REPORTS: <nl> +		if (!dev->timeout) <nl> +			return -ENOTTY; <nl> + <nl>  		lirc->send_timeout_reports = !!val; <nl>  		break; <nl>  
@@ -245,10 +245,12 @@ tcf_pedit_dump(struct sk_buff *skb, struct tc_action *a,int bind, int ref) <nl>  	t.lastuse = jiffies_to_clock_t(jiffies - p->tm.lastuse); <nl>  	t.expires = jiffies_to_clock_t(p->tm.expires); <nl>  	RTA_PUT(skb, TCA_PEDIT_TM, sizeof(t), &t); <nl> +	kfree(opt); <nl>  	return skb->len; <nl>   <nl>  rtattr_failure: <nl>  	skb_trim(skb, b - skb->data); <nl> +	kfree(opt); <nl>  	return -1; <nl>  } <nl>  
@@ -425,7 +425,7 @@ static void ks_wlan_hw_rx(struct ks_wlan_private *priv, uint16_t size) <nl>  	int ret; <nl>  	struct rx_device_buffer *rx_buffer; <nl>  	struct hostif_hdr *hdr; <nl> -	unsigned short event = 0; <nl> +	u16 event = 0; <nl>   <nl>  	/* receive data */ <nl>  	if (rxq_count(priv) >= (RX_DEVICE_BUFF_SIZE - 1)) {
@@ -1024,6 +1024,10 @@ bool kvm_irq_delivery_to_apic_fast(struct kvm *kvm, struct kvm_lapic *src, <nl>  	*r = -1; <nl>   <nl>  	if (irq->shorthand == APIC_DEST_SELF) { <nl> +		if (KVM_BUG_ON(!src, kvm)) { <nl> +			*r = 0; <nl> +			return true; <nl> +		} <nl>  		*r = kvm_apic_set_irq(src->vcpu, irq, dest_map); <nl>  		return true; <nl>  	}
@@ -600,6 +600,9 @@ static u64 __skb_get_nlattr(u64 ctx, u64 A, u64 X, u64 r4, u64 r5) <nl>  	if (skb_is_nonlinear(skb)) <nl>  		return 0; <nl>   <nl> +	if (skb->len < sizeof(struct nlattr)) <nl> +		return 0; <nl> + <nl>  	if (A > skb->len - sizeof(struct nlattr)) <nl>  		return 0; <nl>   <nl> @@ -618,11 +621,14 @@ static u64 __skb_get_nlattr_nest(u64 ctx, u64 A, u64 X, u64 r4, u64 r5) <nl>  	if (skb_is_nonlinear(skb)) <nl>  		return 0; <nl>   <nl> +	if (skb->len < sizeof(struct nlattr)) <nl> +		return 0; <nl> + <nl>  	if (A > skb->len - sizeof(struct nlattr)) <nl>  		return 0; <nl>   <nl>  	nla = (struct nlattr *) &skb->data[A]; <nl> -	if (nla->nla_len > A - skb->len) <nl> +	if (nla->nla_len > skb->len - A) <nl>  		return 0; <nl>   <nl>  	nla = nla_find_nested(nla, X);
@@ -67,6 +67,9 @@ static int ghash_update(struct shash_desc *desc, <nl>  	struct ghash_ctx *ctx = crypto_shash_ctx(desc->tfm); <nl>  	u8 *dst = dctx->buffer; <nl>   <nl> +	if (!ctx->gf128) <nl> +		return -ENOKEY; <nl> + <nl>  	if (dctx->bytes) { <nl>  		int n = min(srclen, dctx->bytes); <nl>  		u8 *pos = dst + (GHASH_BLOCK_SIZE - dctx->bytes); <nl> @@ -119,6 +122,9 @@ static int ghash_final(struct shash_desc *desc, u8 *dst) <nl>  	struct ghash_ctx *ctx = crypto_shash_ctx(desc->tfm); <nl>  	u8 *buf = dctx->buffer; <nl>   <nl> +	if (!ctx->gf128) <nl> +		return -ENOKEY; <nl> + <nl>  	ghash_flush(ctx, dctx); <nl>  	memcpy(dst, buf, GHASH_BLOCK_SIZE); <nl>  
@@ -742,7 +742,7 @@ static int copy_to_user_auth(struct xfrm_algo_auth *auth, struct sk_buff *skb) <nl>  		return -EMSGSIZE; <nl>   <nl>  	algo = nla_data(nla); <nl> -	strcpy(algo->alg_name, auth->alg_name); <nl> +	strncpy(algo->alg_name, auth->alg_name, sizeof(algo->alg_name)); <nl>  	memcpy(algo->alg_key, auth->alg_key, (auth->alg_key_len + 7) / 8); <nl>  	algo->alg_key_len = auth->alg_key_len; <nl>  
@@ -977,7 +977,12 @@ int register_netdevice_notifier(struct notifier_block *nb) <nl>   <nl>  int unregister_netdevice_notifier(struct notifier_block *nb) <nl>  { <nl> -	return notifier_chain_unregister(&netdev_chain, nb); <nl> +	int err; <nl> + <nl> +	rtnl_lock(); <nl> +	err = notifier_chain_unregister(&netdev_chain, nb); <nl> +	rtnl_unlock(); <nl> +	return err; <nl>  } <nl>   <nl>  /**
@@ -1376,6 +1376,7 @@ qeth_l3_add_mc_to_hash(struct qeth_card *card, struct in_device *in4_dev) <nl>   <nl>  		tmp->u.a4.addr = be32_to_cpu(im4->multiaddr); <nl>  		memcpy(tmp->mac, buf, sizeof(tmp->mac)); <nl> +		tmp->is_multicast = 1; <nl>   <nl>  		ipm = qeth_l3_ip_from_hash(card, tmp); <nl>  		if (ipm) {
@@ -342,6 +342,9 @@ int snd_ctl_add(struct snd_card *card, struct snd_kcontrol *kcontrol) <nl>  	if (snd_BUG_ON(!card || !kcontrol->info)) <nl>  		goto error; <nl>  	id = kcontrol->id; <nl> +	if (id.index > UINT_MAX - kcontrol->count) <nl> +		goto error; <nl> + <nl>  	down_write(&card->controls_rwsem); <nl>  	if (snd_ctl_find_id(card, &id)) { <nl>  		up_write(&card->controls_rwsem);
@@ -1313,6 +1313,7 @@ static void __ibmvnic_reset(struct work_struct *work) <nl>   <nl>  	if (rc) { <nl>  		free_all_rwi(adapter); <nl> +		mutex_unlock(&adapter->reset_lock); <nl>  		return; <nl>  	} <nl>  
@@ -104,6 +104,7 @@ static void lut_close(struct i915_gem_context *ctx) <nl>  		kmem_cache_free(ctx->i915->luts, lut); <nl>  	} <nl>   <nl> +	rcu_read_lock(); <nl>  	radix_tree_for_each_slot(slot, &ctx->handles_vma, &iter, 0) { <nl>  		struct i915_vma *vma = rcu_dereference_raw(*slot); <nl>  		struct drm_i915_gem_object *obj = vma->obj; <nl> @@ -115,6 +116,7 @@ static void lut_close(struct i915_gem_context *ctx) <nl>   <nl>  		__i915_gem_object_release_unless_active(obj); <nl>  	} <nl> +	rcu_read_unlock(); <nl>  } <nl>   <nl>  static void i915_gem_context_free(struct i915_gem_context *ctx)
@@ -1473,7 +1473,8 @@ static void tg3_phy_toggle_apd(struct tg3 *tp, bool enable) <nl>  { <nl>  	u32 reg; <nl>   <nl> -	if (!(tp->tg3_flags2 & TG3_FLG2_5705_PLUS)) <nl> +	if (!(tp->tg3_flags2 & TG3_FLG2_5705_PLUS) || <nl> +	    GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5906) <nl>  		return; <nl>   <nl>  	reg = MII_TG3_MISC_SHDW_WREN |
@@ -1638,7 +1638,7 @@ struct request_queue *__scsi_alloc_queue(struct Scsi_Host *shost, <nl>  					 request_fn_proc *request_fn) <nl>  { <nl>  	struct request_queue *q; <nl> -	struct device *dev = shost->shost_gendev.parent; <nl> +	struct device *dev = shost->dma_dev; <nl>   <nl>  	q = blk_init_queue(request_fn, NULL); <nl>  	if (!q)
@@ -501,6 +501,15 @@ int imx_drm_add_crtc(struct drm_crtc *crtc, <nl>   <nl>  	mutex_lock(&imxdrm->mutex); <nl>   <nl> +	/* <nl> +	 * The vblank arrays are dimensioned by MAX_CRTC - we can't <nl> +	 * pass IDs greater than this to those functions. <nl> +	 */ <nl> +	if (imxdrm->pipes >= MAX_CRTC) { <nl> +		ret = -EINVAL; <nl> +		goto err_busy; <nl> +	} <nl> + <nl>  	if (imxdrm->drm->open_count) { <nl>  		ret = -EBUSY; <nl>  		goto err_busy;
@@ -608,6 +608,7 @@ static int rfcomm_sock_recvmsg(struct kiocb *iocb, struct socket *sock, <nl>   <nl>  	if (test_and_clear_bit(RFCOMM_DEFER_SETUP, &d->flags)) { <nl>  		rfcomm_dlc_accept(d); <nl> +		msg->msg_namelen = 0; <nl>  		return 0; <nl>  	} <nl>  
@@ -84,11 +84,14 @@ static ssize_t qrtr_tun_write_iter(struct kiocb *iocb, struct iov_iter *from) <nl>  	if (!kbuf) <nl>  		return -ENOMEM; <nl>   <nl> -	if (!copy_from_iter_full(kbuf, len, from)) <nl> +	if (!copy_from_iter_full(kbuf, len, from)) { <nl> +		kfree(kbuf); <nl>  		return -EFAULT; <nl> +	} <nl>   <nl>  	ret = qrtr_endpoint_post(&tun->ep, kbuf, len); <nl>   <nl> +	kfree(kbuf); <nl>  	return ret < 0 ? ret : len; <nl>  } <nl>  
@@ -1444,14 +1444,16 @@ void ath_tx_aggr_sleep(struct ieee80211_sta *sta, struct ath_softc *sc, <nl>  	for (tidno = 0, tid = &an->tid[tidno]; <nl>  	     tidno < IEEE80211_NUM_TIDS; tidno++, tid++) { <nl>   <nl> -		if (!tid->sched) <nl> -			continue; <nl> - <nl>  		ac = tid->ac; <nl>  		txq = ac->txq; <nl>   <nl>  		ath_txq_lock(sc, txq); <nl>   <nl> +		if (!tid->sched) { <nl> +			ath_txq_unlock(sc, txq); <nl> +			continue; <nl> +		} <nl> + <nl>  		buffered = ath_tid_has_buffered(tid); <nl>   <nl>  		tid->sched = false;
@@ -1526,8 +1526,11 @@ int sdma_init(struct hfi1_devdata *dd, u8 port) <nl>  	} <nl>   <nl>  	ret = rhashtable_init(tmp_sdma_rht, &sdma_rht_params); <nl> -	if (ret < 0) <nl> +	if (ret < 0) { <nl> +		kfree(tmp_sdma_rht); <nl>  		goto bail; <nl> +	} <nl> + <nl>  	dd->sdma_rht = tmp_sdma_rht; <nl>   <nl>  	dd_dev_info(dd, "SDMA num_sdma: %u\n", dd->num_sdma);
@@ -503,7 +503,8 @@ int st_sensors_check_device_support(struct iio_dev *indio_dev, <nl>  			break; <nl>  	} <nl>  	if (n == ARRAY_SIZE(sensor_settings[i].sensors_supported)) { <nl> -		dev_err(&indio_dev->dev, "device name and WhoAmI mismatch.\n"); <nl> +		dev_err(&indio_dev->dev, "device name \"%s\" and WhoAmI (0x%02x) mismatch", <nl> +			indio_dev->name, wai); <nl>  		goto sensor_name_mismatch; <nl>  	} <nl>  
@@ -528,6 +528,9 @@ int ath_cmn_process_fft(struct ath_spec_scan_priv *spec_priv, struct ieee80211_h <nl>  	if (!(radar_info->pulse_bw_info & SPECTRAL_SCAN_BITMASK)) <nl>  		return 0; <nl>   <nl> +	if (!spec_priv->rfs_chan_spec_scan) <nl> +		return 1; <nl> + <nl>  	/* Output buffers are full, no need to process anything <nl>  	 * since there is no space to put the result anyway <nl>  	 */ <nl> @@ -1072,7 +1075,7 @@ static struct rchan_callbacks rfs_spec_scan_cb = { <nl>   <nl>  void ath9k_cmn_spectral_deinit_debug(struct ath_spec_scan_priv *spec_priv) <nl>  { <nl> -	if (IS_ENABLED(CONFIG_ATH9K_DEBUGFS)) { <nl> +	if (IS_ENABLED(CONFIG_ATH9K_DEBUGFS) && spec_priv->rfs_chan_spec_scan) { <nl>  		relay_close(spec_priv->rfs_chan_spec_scan); <nl>  		spec_priv->rfs_chan_spec_scan = NULL; <nl>  	} <nl> @@ -1086,6 +1089,9 @@ void ath9k_cmn_spectral_init_debug(struct ath_spec_scan_priv *spec_priv, <nl>  					    debugfs_phy, <nl>  					    1024, 256, &rfs_spec_scan_cb, <nl>  					    NULL); <nl> +	if (!spec_priv->rfs_chan_spec_scan) <nl> +		return; <nl> + <nl>  	debugfs_create_file("spectral_scan_ctl", <nl>  			    S_IRUSR | S_IWUSR, <nl>  			    debugfs_phy, spec_priv,
@@ -821,11 +821,17 @@ static struct dst_entry *ip6_sk_dst_check(struct sock *sk, <nl>  					  const struct flowi6 *fl6) <nl>  { <nl>  	struct ipv6_pinfo *np = inet6_sk(sk); <nl> -	struct rt6_info *rt = (struct rt6_info *)dst; <nl> +	struct rt6_info *rt; <nl>   <nl>  	if (!dst) <nl>  		goto out; <nl>   <nl> +	if (dst->ops->family != AF_INET6) { <nl> +		dst_release(dst); <nl> +		return NULL; <nl> +	} <nl> + <nl> +	rt = (struct rt6_info *)dst; <nl>  	/* Yes, checking route validity in not connected <nl>  	 * case is not very simple. Take into account, <nl>  	 * that we do not support routing by source, TOS,
@@ -3063,6 +3063,9 @@ static int btrfs_extent_same(struct inode *src, u64 loff, u64 olen, <nl>  		inode_lock(src); <nl>   <nl>  		ret = extent_same_check_offsets(src, loff, &len, olen); <nl> +		if (ret) <nl> +			goto out_unlock; <nl> +		ret = extent_same_check_offsets(src, dst_loff, &len, olen); <nl>  		if (ret) <nl>  			goto out_unlock; <nl>  
@@ -59,9 +59,10 @@ struct pt_regs; <nl>  extern int __build_bug_on_failed; <nl>  #define BUILD_BUG_ON(condition)					\ <nl>  	do {							\ <nl> -		((void)sizeof(char[1 - 2*!!(condition)]));	\ <nl> -		if (condition) __build_bug_on_failed = 1;	\ <nl> -	} while(0) <nl> +		bool __cond = !!(condition);			\ <nl> +		((void)sizeof(char[1 - 2 * __cond]));		\ <nl> +		if (__cond) __build_bug_on_failed = 1;		\ <nl> +	} while (0) <nl>  #endif <nl>   <nl>  /**
@@ -6,6 +6,7 @@ <nl>  #include <linux/smp.h> <nl>  #include <linux/threads.h> <nl>  #include <linux/percpu.h> <nl> +#include <linux/cpumask.h> <nl>  #include <asm/cputime.h> <nl>   <nl>  /* <nl> @@ -43,11 +44,10 @@ extern unsigned long long nr_context_switches(void); <nl>   */ <nl>  static inline int kstat_irqs(int irq) <nl>  { <nl> -	int i, sum=0; <nl> +	int cpu, sum = 0; <nl>   <nl> -	for (i = 0; i < NR_CPUS; i++) <nl> -		if (cpu_possible(i)) <nl> -			sum += kstat_cpu(i).irqs[irq]; <nl> +	for_each_cpu(cpu) <nl> +		sum += kstat_cpu(cpu).irqs[irq]; <nl>   <nl>  	return sum; <nl>  }
@@ -442,7 +442,7 @@ static int rpmsg_dev_probe(struct device *dev) <nl>  		goto out; <nl>  	} <nl>   <nl> -	if (rpdev->ops->announce_create) <nl> +	if (ept && rpdev->ops->announce_create) <nl>  		err = rpdev->ops->announce_create(rpdev); <nl>  out: <nl>  	return err;
@@ -9991,6 +9991,7 @@ int intel_framebuffer_init(struct drm_device *dev, <nl>  			   struct drm_mode_fb_cmd2 *mode_cmd, <nl>  			   struct drm_i915_gem_object *obj) <nl>  { <nl> +	int aligned_height, tile_height; <nl>  	int pitch_limit; <nl>  	int ret; <nl>   <nl> @@ -10084,6 +10085,13 @@ int intel_framebuffer_init(struct drm_device *dev, <nl>  	if (mode_cmd->offsets[0] != 0) <nl>  		return -EINVAL; <nl>   <nl> +	tile_height = IS_GEN2(dev) ? 16 : 8; <nl> +	aligned_height = ALIGN(mode_cmd->height, <nl> +			       obj->tiling_mode ? tile_height : 1); <nl> +	/* FIXME drm helper for size checks (especially planar formats)? */ <nl> +	if (obj->base.size < aligned_height * mode_cmd->pitches[0]) <nl> +		return -EINVAL; <nl> + <nl>  	drm_helper_mode_fill_fb_struct(&intel_fb->base, mode_cmd); <nl>  	intel_fb->obj = obj; <nl>  	intel_fb->obj->framebuffer_references++;
@@ -471,6 +471,9 @@ int mm_isBranchInstr(struct pt_regs *regs, struct mm_decoded_insn dec_insn, <nl>  	unsigned int fcr31; <nl>  	unsigned int bit; <nl>   <nl> +	if (!cpu_has_mmips) <nl> +		return 0; <nl> + <nl>  	switch (insn.mm_i_format.opcode) { <nl>  	case mm_pool32a_op: <nl>  		if ((insn.mm_i_format.simmediate & MM_POOL32A_MINOR_MASK) ==
@@ -41,6 +41,9 @@ void ath_init_leds(struct ath_softc *sc) <nl>  { <nl>  	int ret; <nl>   <nl> +	if (AR_SREV_9100(sc->sc_ah)) <nl> +		return; <nl> + <nl>  	if (sc->sc_ah->led_pin < 0) { <nl>  		if (AR_SREV_9287(sc->sc_ah)) <nl>  			sc->sc_ah->led_pin = ATH_LED_PIN_9287;
@@ -549,6 +549,13 @@ struct ieee80211_hw *ieee80211_alloc_hw(size_t priv_data_len, <nl>  	if (WARN_ON(ops->sta_state && (ops->sta_add || ops->sta_remove))) <nl>  		return NULL; <nl>   <nl> +	/* check all or no channel context operations exist */ <nl> +	i = !!ops->add_chanctx + !!ops->remove_chanctx + <nl> +	    !!ops->change_chanctx + !!ops->assign_vif_chanctx + <nl> +	    !!ops->unassign_vif_chanctx; <nl> +	if (WARN_ON(i != 0 && i != 5)) <nl> +		return NULL; <nl> + <nl>  	/* Ensure 32-byte alignment of our private data and hw private data. <nl>  	 * We use the wiphy priv data for both our ieee80211_local and for <nl>  	 * the driver's private data
@@ -2311,7 +2311,7 @@ netxen_md_rdqueue(struct netxen_adapter *adapter, <nl>  				 loop_cnt++) { <nl>  		NX_WR_DUMP_REG(select_addr, adapter->ahw.pci_base0, queue_id); <nl>  		read_addr = queueEntry->read_addr; <nl> -		for (k = 0; k < read_cnt; k--) { <nl> +		for (k = 0; k < read_cnt; k++) { <nl>  			NX_RD_DUMP_REG(read_addr, adapter->ahw.pci_base0, <nl>  							&read_value); <nl>  			*data_buff++ = read_value;
@@ -701,14 +701,18 @@ int main(void) <nl>  	pfd.fd = fd; <nl>   <nl>  	while (1) { <nl> +		struct sockaddr *addr_p = (struct sockaddr *) &addr; <nl> +		socklen_t addr_l = sizeof(addr); <nl>  		pfd.events = POLLIN; <nl>  		pfd.revents = 0; <nl>  		poll(&pfd, 1, -1); <nl>   <nl> -		len = recv(fd, kvp_recv_buffer, sizeof(kvp_recv_buffer), 0); <nl> +		len = recvfrom(fd, kvp_recv_buffer, sizeof(kvp_recv_buffer), 0, <nl> +				addr_p, &addr_l); <nl>   <nl> -		if (len < 0) { <nl> -			syslog(LOG_ERR, "recv failed; error:%d", len); <nl> +		if (len < 0 || addr.nl_pid) { <nl> +			syslog(LOG_ERR, "recvfrom failed; pid:%u error:%d %s", <nl> +					addr.nl_pid, errno, strerror(errno)); <nl>  			close(fd); <nl>  			return -1; <nl>  		}
@@ -4344,8 +4344,10 @@ static long cgroup_create(struct cgroup *parent, struct dentry *dentry, <nl>  		} <nl>   <nl>  		err = percpu_ref_init(&css->refcnt, css_release); <nl> -		if (err) <nl> +		if (err) { <nl> +			ss->css_free(cgrp); <nl>  			goto err_free_all; <nl> +		} <nl>   <nl>  		init_cgroup_css(css, ss, cgrp); <nl>  
@@ -1879,6 +1879,9 @@ static int tun_set_iff(struct net *net, struct file *file, struct ifreq *ifr) <nl>   <nl>  err_detach: <nl>  	tun_detach_all(dev); <nl> +	/* register_netdevice() already called tun_free_netdev() */ <nl> +	goto err_free_dev; <nl> + <nl>  err_free_flow: <nl>  	tun_flow_uninit(tun); <nl>  	security_tun_dev_free_security(tun->security);
@@ -211,11 +211,16 @@ static long ti_clk_divider_round_rate(struct clk_hw *hw, unsigned long rate, <nl>  static int ti_clk_divider_set_rate(struct clk_hw *hw, unsigned long rate, <nl>  				   unsigned long parent_rate) <nl>  { <nl> -	struct clk_divider *divider = to_clk_divider(hw); <nl> +	struct clk_divider *divider; <nl>  	unsigned int div, value; <nl>  	unsigned long flags = 0; <nl>  	u32 val; <nl>   <nl> +	if (!hw || !rate) <nl> +		return -EINVAL; <nl> + <nl> +	divider = to_clk_divider(hw); <nl> + <nl>  	div = DIV_ROUND_UP(parent_rate, rate); <nl>  	value = _get_val(divider, div); <nl>  
@@ -153,7 +153,7 @@ static int __devinit gen_74x164_probe(struct spi_device *spi) <nl>  	} <nl>   <nl>  	chip->gpio_chip.ngpio = GEN_74X164_NUMBER_GPIOS * chip->registers; <nl> -	chip->buffer = devm_kzalloc(&spi->dev, chip->gpio_chip.ngpio, GFP_KERNEL); <nl> +	chip->buffer = devm_kzalloc(&spi->dev, chip->registers, GFP_KERNEL); <nl>  	if (!chip->buffer) { <nl>  		ret = -ENOMEM; <nl>  		goto exit_destroy;
@@ -1525,7 +1525,7 @@ static int __devinit ks8851_probe(struct spi_device *spi) <nl>   <nl>   <nl>  err_netdev: <nl> -	free_irq(ndev->irq, ndev); <nl> +	free_irq(ndev->irq, ks); <nl>   <nl>  err_id: <nl>  err_irq:
@@ -1937,10 +1937,15 @@ static int hci_dev_do_open(struct hci_dev *hdev) <nl>  		 * be able to determine if there is a public address <nl>  		 * or not. <nl>  		 * <nl> +		 * In case of user channel usage, it is not important <nl> +		 * if a public address or static random address is <nl> +		 * available. <nl> +		 * <nl>  		 * This check is only valid for BR/EDR controllers <nl>  		 * since AMP controllers do not have an address. <nl>  		 */ <nl> -		if (hdev->dev_type == HCI_BREDR && <nl> +		if (!test_bit(HCI_USER_CHANNEL, &hdev->dev_flags) && <nl> +		    hdev->dev_type == HCI_BREDR && <nl>  		    !bacmp(&hdev->bdaddr, BDADDR_ANY) && <nl>  		    !bacmp(&hdev->static_addr, BDADDR_ANY)) { <nl>  			ret = -EADDRNOTAVAIL;
@@ -1752,7 +1752,7 @@ static int reset_one_sub_crq_queue(struct ibmvnic_adapter *adapter, <nl>  		scrq->irq = 0; <nl>  	} <nl>   <nl> -	memset(scrq->msgs, 0, 2 * PAGE_SIZE); <nl> +	memset(scrq->msgs, 0, 4 * PAGE_SIZE); <nl>  	scrq->cur = 0; <nl>   <nl>  	rc = h_reg_sub_crq(adapter->vdev->unit_address, scrq->msg_token,
@@ -524,7 +524,9 @@ static bool assoc_array_insert_into_terminal_node(struct assoc_array_edit *edit, <nl>  			free_slot = i; <nl>  			continue; <nl>  		} <nl> -		if (ops->compare_object(assoc_array_ptr_to_leaf(ptr), index_key)) { <nl> +		if (assoc_array_ptr_is_leaf(ptr) && <nl> +		    ops->compare_object(assoc_array_ptr_to_leaf(ptr), <nl> +					index_key)) { <nl>  			pr_devel("replace in slot %d\n", i); <nl>  			edit->leaf_p = &node->slots[i]; <nl>  			edit->dead_leaf = node->slots[i];
@@ -1790,6 +1790,7 @@ void rtl88e_dm_watchdog(struct ieee80211_hw *hw) <nl>  	if (ppsc->p2p_ps_info.p2p_ps_mode) <nl>  		fw_ps_awake = false; <nl>   <nl> +	spin_lock(&rtlpriv->locks.rf_ps_lock); <nl>  	if ((ppsc->rfpwr_state == ERFON) && <nl>  	    ((!fw_current_inpsmode) && fw_ps_awake) && <nl>  	    (!ppsc->rfchange_inprogress)) { <nl> @@ -1802,4 +1803,5 @@ void rtl88e_dm_watchdog(struct ieee80211_hw *hw) <nl>  		rtl88e_dm_check_edca_turbo(hw); <nl>  		rtl88e_dm_antenna_diversity(hw); <nl>  	} <nl> +	spin_unlock(&rtlpriv->locks.rf_ps_lock); <nl>  }
@@ -368,6 +368,15 @@ static void ehci_shutdown(struct usb_hcd *hcd) <nl>  { <nl>  	struct ehci_hcd	*ehci = hcd_to_ehci(hcd); <nl>   <nl> +	/** <nl> +	 * Protect the system from crashing at system shutdown in cases where <nl> +	 * usb host is not added yet from OTG controller driver. <nl> +	 * As ehci_setup() not done yet, so stop accessing registers or <nl> +	 * variables initialized in ehci_setup() <nl> +	 */ <nl> +	if (!ehci->sbrn) <nl> +		return; <nl> + <nl>  	spin_lock_irq(&ehci->lock); <nl>  	ehci->shutdown = true; <nl>  	ehci->rh_state = EHCI_RH_STOPPING;
@@ -24,26 +24,31 @@ int trace_define_field(struct ftrace_event_call *call, char *type, <nl>  { <nl>  	struct ftrace_event_field *field; <nl>   <nl> -	field = kmalloc(sizeof(*field), GFP_KERNEL); <nl> +	field = kzalloc(sizeof(*field), GFP_KERNEL); <nl>  	if (!field) <nl>  		goto err; <nl> + <nl>  	field->name = kstrdup(name, GFP_KERNEL); <nl>  	if (!field->name) <nl>  		goto err; <nl> + <nl>  	field->type = kstrdup(type, GFP_KERNEL); <nl>  	if (!field->type) <nl>  		goto err; <nl> + <nl>  	field->offset = offset; <nl>  	field->size = size; <nl>  	list_add(&field->link, &call->fields); <nl>   <nl>  	return 0; <nl> + <nl>  err: <nl>  	if (field) { <nl>  		kfree(field->name); <nl>  		kfree(field->type); <nl>  	} <nl>  	kfree(field); <nl> + <nl>  	return -ENOMEM; <nl>  } <nl>  
@@ -820,6 +820,9 @@ store_vrm_reg(struct device *dev, struct device_attribute *attr, const char *buf <nl>  	err = kstrtoul(buf, 10, &val); <nl>  	if (err) <nl>  		return err; <nl> + <nl> +	if (val > 255) <nl> +		return -EINVAL; <nl>  	data->vrm = val; <nl>   <nl>  	return count;
@@ -483,14 +483,11 @@ int Efuse_PgPacketRead(struct adapter *pAdapter, u8 offset, u8 *data) <nl>  	u8 hoffset = 0, hworden = 0; <nl>  	u8 tmpidx = 0; <nl>  	u8 tmpdata[8]; <nl> -	u8 max_section = 0; <nl>  	u8 tmp_header = 0; <nl>   <nl> -	EFUSE_GetEfuseDefinition(pAdapter, EFUSE_WIFI, TYPE_EFUSE_MAX_SECTION, (void *)&max_section); <nl> - <nl>  	if (!data) <nl>  		return false; <nl> -	if (offset > max_section) <nl> +	if (offset > EFUSE_MAX_SECTION_88E) <nl>  		return false; <nl>   <nl>  	memset(data, 0xff, sizeof(u8) * PGPKT_DATA_SIZE);
@@ -746,7 +746,14 @@ int cx231xx_set_mode(struct cx231xx *dev, enum cx231xx_mode set_mode) <nl>  		} <nl>  	} <nl>   <nl> -	return errCode ? -EINVAL : 0; <nl> +	if (errCode < 0) { <nl> +		dev_err(dev->dev, "Failed to set devmode to %s: error: %i", <nl> +			dev->mode == CX231XX_DIGITAL_MODE ? "digital" : "analog", <nl> +			errCode); <nl> +		return errCode; <nl> +	} <nl> + <nl> +	return 0; <nl>  } <nl>  EXPORT_SYMBOL_GPL(cx231xx_set_mode); <nl>  
@@ -771,10 +771,14 @@ static const struct snd_soc_component_driver ux500_msp_component = { <nl>  static int ux500_msp_drv_probe(struct platform_device *pdev) <nl>  { <nl>  	struct ux500_msp_i2s_drvdata *drvdata; <nl> +	struct msp_i2s_platform_data *pdata = pdev->dev.platform_data; <nl> +	struct device_node *np = pdev->dev.of_node; <nl>  	int ret = 0; <nl>   <nl> -	dev_dbg(&pdev->dev, "%s: Enter (pdev->name = %s).\n", __func__, <nl> -		pdev->name); <nl> +	if (!pdata && !np) { <nl> +		dev_err(&pdev->dev, "No platform data or Device Tree found\n"); <nl> +		return -ENODEV; <nl> +	} <nl>   <nl>  	drvdata = devm_kzalloc(&pdev->dev, <nl>  				sizeof(struct ux500_msp_i2s_drvdata),
@@ -583,16 +583,15 @@ cfg80211_bss_update(struct cfg80211_registered_device *dev, <nl>  				kfree_rcu((struct cfg80211_bss_ies *)old, <nl>  					  rcu_head); <nl>  		} else if (rcu_access_pointer(tmp->pub.beacon_ies)) { <nl> -			const struct cfg80211_bss_ies *old, *ies; <nl> +			const struct cfg80211_bss_ies *old; <nl>   <nl>  			old = rcu_access_pointer(found->pub.beacon_ies); <nl> -			ies = rcu_access_pointer(found->pub.ies); <nl>   <nl>  			rcu_assign_pointer(found->pub.beacon_ies, <nl>  					   tmp->pub.beacon_ies); <nl>   <nl>  			/* Override IEs if they were from a beacon before */ <nl> -			if (old == ies) <nl> +			if (old == rcu_access_pointer(found->pub.ies)) <nl>  				rcu_assign_pointer(found->pub.ies, <nl>  						   tmp->pub.beacon_ies); <nl>  
@@ -38,6 +38,7 @@ init_iova_domain(struct iova_domain *iovad, unsigned long granule, <nl>  	iovad->start_pfn = start_pfn; <nl>  	iovad->dma_32bit_pfn = pfn_32bit; <nl>  } <nl> +EXPORT_SYMBOL_GPL(init_iova_domain); <nl>   <nl>  static struct rb_node * <nl>  __get_cached_rbnode(struct iova_domain *iovad, unsigned long *limit_pfn) <nl> @@ -243,6 +244,7 @@ int iova_cache_get(void) <nl>   <nl>  	return 0; <nl>  } <nl> +EXPORT_SYMBOL_GPL(iova_cache_get); <nl>   <nl>  void iova_cache_put(void) <nl>  { <nl> @@ -256,6 +258,7 @@ void iova_cache_put(void) <nl>  		kmem_cache_destroy(iova_cache); <nl>  	mutex_unlock(&iova_cache_mutex); <nl>  } <nl> +EXPORT_SYMBOL_GPL(iova_cache_put); <nl>   <nl>  /** <nl>   * alloc_iova - allocates an iova <nl> @@ -296,6 +299,7 @@ alloc_iova(struct iova_domain *iovad, unsigned long size, <nl>   <nl>  	return new_iova; <nl>  } <nl> +EXPORT_SYMBOL_GPL(alloc_iova); <nl>   <nl>  /** <nl>   * find_iova - find's an iova for a given pfn <nl> @@ -336,6 +340,7 @@ struct iova *find_iova(struct iova_domain *iovad, unsigned long pfn) <nl>  	spin_unlock_irqrestore(&iovad->iova_rbtree_lock, flags); <nl>  	return NULL; <nl>  } <nl> +EXPORT_SYMBOL_GPL(find_iova); <nl>   <nl>  /** <nl>   * __free_iova - frees the given iova <nl> @@ -354,6 +359,7 @@ __free_iova(struct iova_domain *iovad, struct iova *iova) <nl>  	spin_unlock_irqrestore(&iovad->iova_rbtree_lock, flags); <nl>  	free_iova_mem(iova); <nl>  } <nl> +EXPORT_SYMBOL_GPL(__free_iova); <nl>   <nl>  /** <nl>   * free_iova - finds and frees the iova for a given pfn <nl> @@ -371,6 +377,7 @@ free_iova(struct iova_domain *iovad, unsigned long pfn) <nl>  		__free_iova(iovad, iova); <nl>   <nl>  } <nl> +EXPORT_SYMBOL_GPL(free_iova); <nl>   <nl>  /** <nl>   * put_iova_domain - destroys the iova doamin <nl> @@ -393,6 +400,7 @@ void put_iova_domain(struct iova_domain *iovad) <nl>  	} <nl>  	spin_unlock_irqrestore(&iovad->iova_rbtree_lock, flags); <nl>  } <nl> +EXPORT_SYMBOL_GPL(put_iova_domain); <nl>   <nl>  static int <nl>  __is_range_overlap(struct rb_node *node, <nl> @@ -482,6 +490,7 @@ reserve_iova(struct iova_domain *iovad, <nl>  	spin_unlock_irqrestore(&iovad->iova_rbtree_lock, flags); <nl>  	return iova; <nl>  } <nl> +EXPORT_SYMBOL_GPL(reserve_iova); <nl>   <nl>  /** <nl>   * copy_reserved_iova - copies the reserved between domains <nl> @@ -508,6 +517,7 @@ copy_reserved_iova(struct iova_domain *from, struct iova_domain *to) <nl>  	} <nl>  	spin_unlock_irqrestore(&from->iova_rbtree_lock, flags); <nl>  } <nl> +EXPORT_SYMBOL_GPL(copy_reserved_iova); <nl>   <nl>  struct iova * <nl>  split_and_remove_iova(struct iova_domain *iovad, struct iova *iova,
@@ -431,7 +431,11 @@ static int xive_spapr_get_ipi(unsigned int cpu, struct xive_cpu *xc) <nl>   <nl>  static void xive_spapr_put_ipi(unsigned int cpu, struct xive_cpu *xc) <nl>  { <nl> +	if (!xc->hw_ipi) <nl> +		return; <nl> + <nl>  	xive_irq_bitmap_free(xc->hw_ipi); <nl> +	xc->hw_ipi = 0; <nl>  } <nl>  #endif /* CONFIG_SMP */ <nl>  
@@ -304,15 +304,16 @@ static ssize_t set_temp_crit_hyst(struct device *dev, <nl>  				  const char *buf, size_t count) <nl>  { <nl>  	struct jc42_data *data = dev_get_drvdata(dev); <nl> -	unsigned long val; <nl> +	long val; <nl>  	int diff, hyst; <nl>  	int err; <nl>  	int ret = count; <nl>   <nl> -	if (kstrtoul(buf, 10, &val) < 0) <nl> +	if (kstrtol(buf, 10, &val) < 0) <nl>  		return -EINVAL; <nl>   <nl> -	val = clamp_val(val, 0, JC42_TEMP_MAX); <nl> +	val = clamp_val(val, (data->extended ? JC42_TEMP_MIN_EXTENDED : <nl> +			      JC42_TEMP_MIN) - 6000, JC42_TEMP_MAX); <nl>  	diff = jc42_temp_from_reg(data->temp[t_crit]) - val; <nl>   <nl>  	hyst = 0;
@@ -318,6 +318,8 @@ static int bcma_get_next_core(struct bcma_bus *bus, u32 __iomem **eromptr, <nl>  		switch (core->id.id) { <nl>  		case BCMA_CORE_4706_MAC_GBIT_COMMON: <nl>  		case BCMA_CORE_NS_CHIPCOMMON_B: <nl> +		case BCMA_CORE_PMU: <nl> +		case BCMA_CORE_GCI: <nl>  		/* Not used yet: case BCMA_CORE_OOB_ROUTER: */ <nl>  			break; <nl>  		default:
@@ -664,7 +664,7 @@ static void start_apic_timer(struct kvm_lapic *apic) <nl>  { <nl>  	ktime_t now = apic->lapic_timer.timer.base->get_time(); <nl>   <nl> -	apic->lapic_timer.period = apic_get_reg(apic, APIC_TMICT) * <nl> +	apic->lapic_timer.period = (u64)apic_get_reg(apic, APIC_TMICT) * <nl>  		    APIC_BUS_CYCLE_NS * apic->divide_count; <nl>  	atomic_set(&apic->lapic_timer.pending, 0); <nl>  
@@ -1829,6 +1829,10 @@ static int ll_ioctl_fiemap(struct inode *inode, unsigned long arg) <nl>  	if (get_user(extent_count, <nl>  	    &((struct ll_user_fiemap __user *)arg)->fm_extent_count)) <nl>  		return -EFAULT; <nl> + <nl> +	if (extent_count >= <nl> +	    (SIZE_MAX - sizeof(*fiemap_s)) / sizeof(struct ll_fiemap_extent)) <nl> +		return -EINVAL; <nl>  	num_bytes = sizeof(*fiemap_s) + (extent_count * <nl>  					 sizeof(struct ll_fiemap_extent)); <nl>  
@@ -1218,7 +1218,14 @@ static void ndisc_router_discovery(struct sk_buff *skb) <nl>  	if (rt) <nl>  		rt6_set_expires(rt, jiffies + (HZ * lifetime)); <nl>  	if (ra_msg->icmph.icmp6_hop_limit) { <nl> -		in6_dev->cnf.hop_limit = ra_msg->icmph.icmp6_hop_limit; <nl> +		/* Only set hop_limit on the interface if it is higher than <nl> +		 * the current hop_limit. <nl> +		 */ <nl> +		if (in6_dev->cnf.hop_limit < ra_msg->icmph.icmp6_hop_limit) { <nl> +			in6_dev->cnf.hop_limit = ra_msg->icmph.icmp6_hop_limit; <nl> +		} else { <nl> +			ND_PRINTK(2, warn, "RA: Got route advertisement with lower hop_limit than current\n"); <nl> +		} <nl>  		if (rt) <nl>  			dst_metric_set(&rt->dst, RTAX_HOPLIMIT, <nl>  				       ra_msg->icmph.icmp6_hop_limit);
@@ -882,13 +882,15 @@ int snd_soc_dapm_connect_input(struct snd_soc_codec *codec, const char *sink, <nl>  	if (wsink->id == snd_soc_dapm_input) { <nl>  		if (wsource->id == snd_soc_dapm_micbias || <nl>  			wsource->id == snd_soc_dapm_mic || <nl> -			wsink->id == snd_soc_dapm_line) <nl> +			wsink->id == snd_soc_dapm_line || <nl> +			wsink->id == snd_soc_dapm_output) <nl>  			wsink->ext = 1; <nl>  	} <nl>  	if (wsource->id == snd_soc_dapm_output) { <nl>  		if (wsink->id == snd_soc_dapm_spk || <nl>  			wsink->id == snd_soc_dapm_hp || <nl> -			wsink->id == snd_soc_dapm_line) <nl> +			wsink->id == snd_soc_dapm_line || <nl> +			wsink->id == snd_soc_dapm_input) <nl>  			wsource->ext = 1; <nl>  	} <nl>  
@@ -569,8 +569,8 @@ static int as3722_pinctrl_probe(struct platform_device *pdev) <nl>  	as3722_pinctrl_desc.name = dev_name(&pdev->dev); <nl>  	as3722_pinctrl_desc.pins = as3722_pins_desc; <nl>  	as3722_pinctrl_desc.npins = ARRAY_SIZE(as3722_pins_desc); <nl> -	as_pci->pctl = pinctrl_register(&as3722_pinctrl_desc, <nl> -					&pdev->dev, as_pci); <nl> +	as_pci->pctl = devm_pinctrl_register(&pdev->dev, &as3722_pinctrl_desc, <nl> +					     as_pci); <nl>  	if (IS_ERR(as_pci->pctl)) { <nl>  		dev_err(&pdev->dev, "Couldn't register pinctrl driver\n"); <nl>  		return PTR_ERR(as_pci->pctl); <nl> @@ -582,7 +582,7 @@ static int as3722_pinctrl_probe(struct platform_device *pdev) <nl>  	ret = gpiochip_add_data(&as_pci->gpio_chip, as_pci); <nl>  	if (ret < 0) { <nl>  		dev_err(&pdev->dev, "Couldn't register gpiochip, %d\n", ret); <nl> -		goto fail_chip_add; <nl> +		return ret; <nl>  	} <nl>   <nl>  	ret = gpiochip_add_pin_range(&as_pci->gpio_chip, dev_name(&pdev->dev), <nl> @@ -596,8 +596,6 @@ static int as3722_pinctrl_probe(struct platform_device *pdev) <nl>   <nl>  fail_range_add: <nl>  	gpiochip_remove(&as_pci->gpio_chip); <nl> -fail_chip_add: <nl> -	pinctrl_unregister(as_pci->pctl); <nl>  	return ret; <nl>  } <nl>   <nl> @@ -606,7 +604,6 @@ static int as3722_pinctrl_remove(struct platform_device *pdev) <nl>  	struct as3722_pctrl_info *as_pci = platform_get_drvdata(pdev); <nl>   <nl>  	gpiochip_remove(&as_pci->gpio_chip); <nl> -	pinctrl_unregister(as_pci->pctl); <nl>  	return 0; <nl>  } <nl>  
@@ -7,7 +7,7 @@ <nl>   * <nl>   * For licensing information, see the file 'LICENCE' in this directory. <nl>   * <nl> - * $Id: nodemgmt.c,v 1.115 2004/11/22 11:07:21 dwmw2 Exp $ <nl> + * $Id: nodemgmt.c,v 1.116 2005/01/24 21:30:22 hammache Exp $ <nl>   * <nl>   */ <nl>   <nl> @@ -308,7 +308,10 @@ int jffs2_add_physical_node_ref(struct jffs2_sb_info *c, struct jffs2_raw_node_r <nl>   <nl>  	D1(printk(KERN_DEBUG "jffs2_add_physical_node_ref(): Node at 0x%x(%d), size 0x%x\n", ref_offset(new), ref_flags(new), len)); <nl>  #if 1 <nl> -	if (jeb != c->nextblock || (ref_offset(new)) != jeb->offset + (c->sector_size - jeb->free_size)) { <nl> +	/* we could get some obsolete nodes after nextblock was refiled <nl> +	   in wbuf.c */ <nl> +	if (  (c->nextblock || !ref_obsolete(new)) <nl> +	    &&(jeb != c->nextblock || (ref_offset(new)) != jeb->offset + (c->sector_size - jeb->free_size))) { <nl>  		printk(KERN_WARNING "argh. node added in wrong place\n"); <nl>  		jffs2_free_raw_node_ref(new); <nl>  		return -EINVAL; <nl> @@ -332,7 +335,7 @@ int jffs2_add_physical_node_ref(struct jffs2_sb_info *c, struct jffs2_raw_node_r <nl>  		c->used_size += len; <nl>  	} <nl>   <nl> -	if (!jeb->free_size && !jeb->dirty_size) { <nl> +	if (!jeb->free_size && !jeb->dirty_size && !jeb->wasted_size) { <nl>  		/* If it lives on the dirty_list, jffs2_reserve_space will put it there */ <nl>  		D1(printk(KERN_DEBUG "Adding full erase block at 0x%08x to clean_list (free 0x%08x, dirty 0x%08x, used 0x%08x\n", <nl>  			  jeb->offset, jeb->free_size, jeb->dirty_size, jeb->used_size));
@@ -991,6 +991,8 @@ static int uas_probe(struct usb_interface *intf, const struct usb_device_id *id) <nl>   <nl>  	shost->max_cmd_len = 16 + 252; <nl>  	shost->max_id = 1; <nl> +	shost->max_lun = 256; <nl> +	shost->max_channel = 0; <nl>  	shost->sg_tablesize = udev->bus->sg_tablesize; <nl>   <nl>  	devinfo->intf = intf;
@@ -680,6 +680,10 @@ static int sdhci_acpi_probe(struct platform_device *pdev) <nl>  	host->hw_name	= "ACPI"; <nl>  	host->ops	= &sdhci_acpi_ops_dflt; <nl>  	host->irq	= platform_get_irq(pdev, 0); <nl> +	if (host->irq <= 0) { <nl> +		err = -EINVAL; <nl> +		goto err_free; <nl> +	} <nl>   <nl>  	host->ioaddr = devm_ioremap_nocache(dev, iomem->start, <nl>  					    resource_size(iomem));
@@ -35,7 +35,7 @@ <nl>  #include <linux/device.h> <nl>  #include <linux/platform_device.h> <nl>  #include <linux/proc_fs.h> <nl> - <nl> +#include <linux/serial_core.h> <nl>   <nl>  #include <asm/mach/arch.h> <nl>  #include <asm/mach/map.h> <nl> @@ -113,12 +113,6 @@ static struct platform_device amlm5900_device_nor = { <nl>  #endif <nl>   <nl>  static struct map_desc amlm5900_iodesc[] __initdata = { <nl> -	{ <nl> -		.virtual	= (u32)S3C24XX_VA_SPI, <nl> -		.pfn		= __phys_to_pfn(S3C2410_PA_SPI), <nl> -		.length		= SZ_1M, <nl> -		.type		= MT_DEVICE <nl> -	} <nl>  }; <nl>   <nl>  #define UCON S3C2410_UCON_DEFAULT
@@ -110,7 +110,7 @@ xfs_attr3_rmt_verify( <nl>  	if (be32_to_cpu(rmt->rm_bytes) > fsbsize - sizeof(*rmt)) <nl>  		return false; <nl>  	if (be32_to_cpu(rmt->rm_offset) + <nl> -				be32_to_cpu(rmt->rm_bytes) >= XATTR_SIZE_MAX) <nl> +				be32_to_cpu(rmt->rm_bytes) > XATTR_SIZE_MAX) <nl>  		return false; <nl>  	if (rmt->rm_owner == 0) <nl>  		return false;
@@ -2526,6 +2526,9 @@ static s32 ixgbe_setup_kr_x550em(struct ixgbe_hw *hw) <nl>  	if (hw->phy.autoneg_advertised & IXGBE_LINK_SPEED_2_5GB_FULL) <nl>  		return 0; <nl>   <nl> +	if (ixgbe_check_reset_blocked(hw)) <nl> +		return 0; <nl> + <nl>  	return ixgbe_setup_kr_speed_x550em(hw, hw->phy.autoneg_advertised); <nl>  } <nl>  
@@ -922,7 +922,8 @@ static int mt_input_mapping(struct hid_device *hdev, struct hid_input *hi, <nl>  	    field->application != HID_DG_PEN && <nl>  	    field->application != HID_DG_TOUCHPAD && <nl>  	    field->application != HID_GD_KEYBOARD && <nl> -	    field->application != HID_CP_CONSUMER_CONTROL) <nl> +	    field->application != HID_CP_CONSUMER_CONTROL && <nl> +	    field->application != HID_GD_WIRELESS_RADIO_CTLS) <nl>  		return -1; <nl>   <nl>  	/* <nl> @@ -1133,6 +1134,9 @@ static int mt_input_configured(struct hid_device *hdev, struct hid_input *hi) <nl>  		case HID_CP_CONSUMER_CONTROL: <nl>  			suffix = "Consumer Control"; <nl>  			break; <nl> +		case HID_GD_WIRELESS_RADIO_CTLS: <nl> +			suffix = "Wireless Radio Control"; <nl> +			break; <nl>  		default: <nl>  			suffix = "UNKNOWN"; <nl>  			break;
@@ -689,6 +689,7 @@ static int xfrm_del_sa(struct sk_buff *skb, struct nlmsghdr *nlh, <nl>   <nl>  static void copy_to_user_state(struct xfrm_state *x, struct xfrm_usersa_info *p) <nl>  { <nl> +	memset(p, 0, sizeof(*p)); <nl>  	memcpy(&p->id, &x->id, sizeof(p->id)); <nl>  	memcpy(&p->sel, &x->sel, sizeof(p->sel)); <nl>  	memcpy(&p->lft, &x->lft, sizeof(p->lft));
@@ -1004,7 +1004,9 @@ static int bcap_probe(struct platform_device *pdev) <nl>  	q->mem_ops = &vb2_dma_contig_memops; <nl>  	q->timestamp_type = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC; <nl>   <nl> -	vb2_queue_init(q); <nl> +	ret = vb2_queue_init(q); <nl> +	if (ret) <nl> +		goto err_free_handler; <nl>   <nl>  	mutex_init(&bcap_dev->mutex); <nl>  	init_completion(&bcap_dev->comp);
@@ -896,6 +896,7 @@ static int blkcg_print_stat(struct seq_file *sf, void *v) <nl>  struct cftype blkcg_files[] = { <nl>  	{ <nl>  		.name = "stat", <nl> +		.flags = CFTYPE_NOT_ON_ROOT, <nl>  		.seq_show = blkcg_print_stat, <nl>  	}, <nl>  	{ }	/* terminate */
@@ -313,7 +313,8 @@ static int __devinit davinci_mdio_probe(struct platform_device *pdev) <nl>  	data->bus->reset	= davinci_mdio_reset, <nl>  	data->bus->parent	= dev; <nl>  	data->bus->priv		= data; <nl> -	snprintf(data->bus->id, MII_BUS_ID_SIZE, "%x", pdev->id); <nl> +	snprintf(data->bus->id, MII_BUS_ID_SIZE, "%s-%x", <nl> +		pdev->name, pdev->id); <nl>   <nl>  	data->clk = clk_get(dev, NULL); <nl>  	if (IS_ERR(data->clk)) {
@@ -475,12 +475,18 @@ EXPORT_SYMBOL_GPL(btbcm_setup_patchram); <nl>  int btbcm_setup_apple(struct hci_dev *hdev) <nl>  { <nl>  	struct sk_buff *skb; <nl> +	int err; <nl> + <nl> +	/* Reset */ <nl> +	err = btbcm_reset(hdev); <nl> +	if (err) <nl> +		return err; <nl>   <nl>  	/* Read Verbose Config Version Info */ <nl>  	skb = btbcm_read_verbose_config(hdev); <nl>  	if (!IS_ERR(skb)) { <nl> -		BT_INFO("%s: BCM: chip id %u build %4.4u", hdev->name, skb->data[1], <nl> -			get_unaligned_le16(skb->data + 5)); <nl> +		BT_INFO("%s: BCM: chip id %u build %4.4u", hdev->name, <nl> +			skb->data[1], get_unaligned_le16(skb->data + 5)); <nl>  		kfree_skb(skb); <nl>  	} <nl>  
@@ -98,10 +98,11 @@ static int sdio_init_func(struct mmc_card *card, unsigned int fn) <nl>  	return ret; <nl>  } <nl>   <nl> -static int sdio_read_cccr(struct mmc_card *card) <nl> +static int sdio_read_cccr(struct mmc_card *card, u32 ocr) <nl>  { <nl>  	int ret; <nl>  	int cccr_vsn; <nl> +	int uhs = ocr & R4_18V_PRESENT; <nl>  	unsigned char data; <nl>  	unsigned char speed; <nl>   <nl> @@ -149,7 +150,7 @@ static int sdio_read_cccr(struct mmc_card *card) <nl>  		card->scr.sda_spec3 = 0; <nl>  		card->sw_caps.sd3_bus_mode = 0; <nl>  		card->sw_caps.sd3_drv_type = 0; <nl> -		if (cccr_vsn >= SDIO_CCCR_REV_3_00) { <nl> +		if (cccr_vsn >= SDIO_CCCR_REV_3_00 && uhs) { <nl>  			card->scr.sda_spec3 = 1; <nl>  			ret = mmc_io_rw_direct(card, 0, 0, <nl>  				SDIO_CCCR_UHS, 0, &data); <nl> @@ -712,7 +713,7 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr, <nl>  	/* <nl>  	 * Read the common registers. <nl>  	 */ <nl> -	err = sdio_read_cccr(card); <nl> +	err = sdio_read_cccr(card, ocr); <nl>  	if (err) <nl>  		goto remove; <nl>  
@@ -1155,7 +1155,7 @@ static int __driver_rfc4106_decrypt(struct aead_request *req) <nl>  		src = kmalloc(req->cryptlen + req->assoclen, GFP_ATOMIC); <nl>  		if (!src) <nl>  			return -ENOMEM; <nl> -		assoc = (src + req->cryptlen + auth_tag_len); <nl> +		assoc = (src + req->cryptlen); <nl>  		scatterwalk_map_and_copy(src, req->src, 0, req->cryptlen, 0); <nl>  		scatterwalk_map_and_copy(assoc, req->assoc, 0, <nl>  			req->assoclen, 0); <nl> @@ -1180,7 +1180,7 @@ static int __driver_rfc4106_decrypt(struct aead_request *req) <nl>  		scatterwalk_done(&src_sg_walk, 0, 0); <nl>  		scatterwalk_done(&assoc_sg_walk, 0, 0); <nl>  	} else { <nl> -		scatterwalk_map_and_copy(dst, req->dst, 0, req->cryptlen, 1); <nl> +		scatterwalk_map_and_copy(dst, req->dst, 0, tempCipherLen, 1); <nl>  		kfree(src); <nl>  	} <nl>  	return retval;
@@ -2446,6 +2446,8 @@ int regulator_map_voltage_linear_range(struct regulator_dev *rdev, <nl>  				return ret; <nl>  		} <nl>   <nl> +		ret += range->min_sel; <nl> + <nl>  		break; <nl>  	} <nl>  
@@ -373,6 +373,7 @@ static int edac_create_csrow_object(struct mem_ctl_info *mci, <nl>  	csrow->dev.bus = &mci->bus; <nl>  	device_initialize(&csrow->dev); <nl>  	csrow->dev.parent = &mci->dev; <nl> +	csrow->mci = mci; <nl>  	dev_set_name(&csrow->dev, "csrow%d", index); <nl>  	dev_set_drvdata(&csrow->dev, csrow); <nl>  
@@ -160,7 +160,6 @@ static inline void chcr_handle_ahash_resp(struct ahash_request *req, <nl>   <nl>  	if (input == NULL) <nl>  		goto out; <nl> -	reqctx = ahash_request_ctx(req); <nl>  	digestsize = crypto_ahash_digestsize(crypto_ahash_reqtfm(req)); <nl>  	if (reqctx->is_sg_map) <nl>  		chcr_hash_dma_unmap(&u_ctx->lldi.pdev->dev, req); <nl> @@ -2014,11 +2013,8 @@ static int chcr_aead_common_init(struct aead_request *req, <nl>  	struct chcr_aead_ctx *aeadctx = AEAD_CTX(a_ctx(tfm)); <nl>  	struct chcr_aead_reqctx  *reqctx = aead_request_ctx(req); <nl>  	int error = -EINVAL; <nl> -	unsigned int dst_size; <nl>  	unsigned int authsize = crypto_aead_authsize(tfm); <nl>   <nl> -	dst_size = req->assoclen + req->cryptlen + (op_type ? <nl> -					-authsize : authsize); <nl>  	/* validate key size */ <nl>  	if (aeadctx->enckey_len == 0) <nl>  		goto err;
@@ -624,7 +624,7 @@ int md_raid1_congested(struct mddev *mddev, int bits) <nl>  		return 1; <nl>   <nl>  	rcu_read_lock(); <nl> -	for (i = 0; i < conf->raid_disks; i++) { <nl> +	for (i = 0; i < conf->raid_disks * 2; i++) { <nl>  		struct md_rdev *rdev = rcu_dereference(conf->mirrors[i].rdev); <nl>  		if (rdev && !test_bit(Faulty, &rdev->flags)) { <nl>  			struct request_queue *q = bdev_get_queue(rdev->bdev);
@@ -3180,13 +3180,8 @@ struct sk_buff *tcp_make_synack(const struct sock *sk, struct dst_entry *dst, <nl>  	th->source = htons(ireq->ir_num); <nl>  	th->dest = ireq->ir_rmt_port; <nl>  	skb->mark = ireq->ir_mark; <nl> -	/* Setting of flags are superfluous here for callers (and ECE is <nl> -	 * not even correctly set) <nl> -	 */ <nl> -	tcp_init_nondata_skb(skb, tcp_rsk(req)->snt_isn, <nl> -			     TCPHDR_SYN | TCPHDR_ACK); <nl> - <nl> -	th->seq = htonl(TCP_SKB_CB(skb)->seq); <nl> +	skb->ip_summed = CHECKSUM_PARTIAL; <nl> +	th->seq = htonl(tcp_rsk(req)->snt_isn); <nl>  	/* XXX data is queued and acked as is. No buffer/window check */ <nl>  	th->ack_seq = htonl(tcp_rsk(req)->rcv_nxt); <nl>  
@@ -584,7 +584,7 @@ static int wm5102_sysclk_ev(struct snd_soc_dapm_widget *w, <nl>  			    struct snd_kcontrol *kcontrol, int event) <nl>  { <nl>  	struct snd_soc_codec *codec = w->codec; <nl> -	struct arizona *arizona = dev_get_drvdata(codec->dev); <nl> +	struct arizona *arizona = dev_get_drvdata(codec->dev->parent); <nl>  	struct regmap *regmap = codec->control_data; <nl>  	const struct reg_default *patch = NULL; <nl>  	int i, patch_size;
@@ -1126,7 +1126,7 @@ ext4_mb_load_buddy(struct super_block *sb, ext4_group_t group, <nl>  	grp = ext4_get_group_info(sb, group); <nl>   <nl>  	e4b->bd_blkbits = sb->s_blocksize_bits; <nl> -	e4b->bd_info = ext4_get_group_info(sb, group); <nl> +	e4b->bd_info = grp; <nl>  	e4b->bd_sb = sb; <nl>  	e4b->bd_group = group; <nl>  	e4b->bd_buddy_page = NULL;
@@ -1000,11 +1000,8 @@ static void __init m32r_sio_register_ports(struct uart_driver *drv) <nl>  		init_timer(&up->timer); <nl>  		up->timer.function = m32r_sio_timeout; <nl>   <nl> -		/* <nl> -		 * ALPHA_KLUDGE_MCR needs to be killed. <nl> -		 */ <nl> -		up->mcr_mask = ~ALPHA_KLUDGE_MCR; <nl> -		up->mcr_force = ALPHA_KLUDGE_MCR; <nl> +		up->mcr_mask = ~0; <nl> +		up->mcr_force = 0; <nl>   <nl>  		uart_add_one_port(drv, &up->port); <nl>  	}
@@ -1134,6 +1134,12 @@ static int ieee80211_change_bss(struct wiphy *wiphy, <nl>  			sdata->flags &= ~IEEE80211_SDATA_DONT_BRIDGE_PACKETS; <nl>  	} <nl>   <nl> +	if (params->ht_opmode >= 0) { <nl> +		sdata->vif.bss_conf.ht_operation_mode = <nl> +			(u16) params->ht_opmode; <nl> +		changed |= BSS_CHANGED_HT; <nl> +	} <nl> + <nl>  	ieee80211_bss_info_change_notify(sdata, changed); <nl>   <nl>  	return 0;
@@ -911,7 +911,8 @@ static int nfc_genl_deactivate_target(struct sk_buff *skb, <nl>  	u32 device_idx, target_idx; <nl>  	int rc; <nl>   <nl> -	if (!info->attrs[NFC_ATTR_DEVICE_INDEX]) <nl> +	if (!info->attrs[NFC_ATTR_DEVICE_INDEX] || <nl> +	    !info->attrs[NFC_ATTR_TARGET_INDEX]) <nl>  		return -EINVAL; <nl>   <nl>  	device_idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);
@@ -1015,8 +1015,15 @@ static struct platform_driver rk_iommu_driver = { <nl>   <nl>  static int __init rk_iommu_init(void) <nl>  { <nl> +	struct device_node *np; <nl>  	int ret; <nl>   <nl> +	np = of_find_matching_node(NULL, rk_iommu_dt_ids); <nl> +	if (!np) <nl> +		return 0; <nl> + <nl> +	of_node_put(np); <nl> + <nl>  	ret = bus_set_iommu(&platform_bus_type, &rk_iommu_ops); <nl>  	if (ret) <nl>  		return ret;
@@ -1225,6 +1225,12 @@ static const struct kernel_symbol *resolve_symbol(struct module *mod, <nl>  	const unsigned long *crc; <nl>  	int err; <nl>   <nl> +	/* <nl> +	 * The module_mutex should not be a heavily contended lock; <nl> +	 * if we get the occasional sleep here, we'll go an extra iteration <nl> +	 * in the wait_event_interruptible(), which is harmless. <nl> +	 */ <nl> +	sched_annotate_sleep(); <nl>  	mutex_lock(&module_mutex); <nl>  	sym = find_symbol(name, &owner, &crc, <nl>  			  !(mod->taints & (1 << TAINT_PROPRIETARY_MODULE)), true);
@@ -3000,6 +3000,7 @@ int i40e_ndo_get_vf_config(struct net_device *netdev, <nl>  	else <nl>  		ivi->linkstate = IFLA_VF_LINK_STATE_DISABLE; <nl>  	ivi->spoofchk = vf->spoofchk; <nl> +	ivi->trusted = vf->trusted; <nl>  	ret = 0; <nl>   <nl>  error_param:
@@ -1757,11 +1757,10 @@ static noinline int btrfs_search_path_in_tree(struct btrfs_fs_info *info, <nl>  		key.objectid = key.offset; <nl>  		key.offset = (u64)-1; <nl>  		dirid = key.objectid; <nl> - <nl>  	} <nl>  	if (ptr < name) <nl>  		goto out; <nl> -	memcpy(name, ptr, total_len); <nl> +	memmove(name, ptr, total_len); <nl>  	name[total_len]='\0'; <nl>  	ret = 0; <nl>  out:
@@ -3572,9 +3572,11 @@ static int kvm_vm_ioctl_get_pit(struct kvm *kvm, struct kvm_pit_state *ps) <nl>   <nl>  static int kvm_vm_ioctl_set_pit(struct kvm *kvm, struct kvm_pit_state *ps) <nl>  { <nl> +	int i; <nl>  	mutex_lock(&kvm->arch.vpit->pit_state.lock); <nl>  	memcpy(&kvm->arch.vpit->pit_state, ps, sizeof(struct kvm_pit_state)); <nl> -	kvm_pit_load_count(kvm, 0, ps->channels[0].count, 0); <nl> +	for (i = 0; i < 3; i++) <nl> +		kvm_pit_load_count(kvm, i, ps->channels[i].count, 0); <nl>  	mutex_unlock(&kvm->arch.vpit->pit_state.lock); <nl>  	return 0; <nl>  } <nl> @@ -3593,6 +3595,7 @@ static int kvm_vm_ioctl_get_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps) <nl>  static int kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps) <nl>  { <nl>  	int start = 0; <nl> +	int i; <nl>  	u32 prev_legacy, cur_legacy; <nl>  	mutex_lock(&kvm->arch.vpit->pit_state.lock); <nl>  	prev_legacy = kvm->arch.vpit->pit_state.flags & KVM_PIT_FLAGS_HPET_LEGACY; <nl> @@ -3602,7 +3605,8 @@ static int kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps) <nl>  	memcpy(&kvm->arch.vpit->pit_state.channels, &ps->channels, <nl>  	       sizeof(kvm->arch.vpit->pit_state.channels)); <nl>  	kvm->arch.vpit->pit_state.flags = ps->flags; <nl> -	kvm_pit_load_count(kvm, 0, kvm->arch.vpit->pit_state.channels[0].count, start); <nl> +	for (i = 0; i < 3; i++) <nl> +		kvm_pit_load_count(kvm, i, kvm->arch.vpit->pit_state.channels[i].count, start); <nl>  	mutex_unlock(&kvm->arch.vpit->pit_state.lock); <nl>  	return 0; <nl>  }
@@ -1011,7 +1011,7 @@ static int __init dw_probe(struct platform_device *pdev) <nl>  	dma_writel(dw, CFG, DW_CFG_DMA_EN); <nl>   <nl>  	printk(KERN_INFO "%s: DesignWare DMA Controller, %d channels\n", <nl> -			pdev->dev.bus_id, dw->dma.chancnt); <nl> +			dev_name(&pdev->dev), dw->dma.chancnt); <nl>   <nl>  	dma_async_device_register(&dw->dma); <nl>  
@@ -318,7 +318,7 @@ struct dst_entry *fib6_rule_lookup(struct net *net, struct flowi6 *fl6, <nl>  	if (rt->dst.error == -EAGAIN) { <nl>  		ip6_rt_put_flags(rt, flags); <nl>  		rt = net->ipv6.ip6_null_entry; <nl> -		if (!(flags | RT6_LOOKUP_F_DST_NOREF)) <nl> +		if (!(flags & RT6_LOOKUP_F_DST_NOREF)) <nl>  			dst_hold(&rt->dst); <nl>  	} <nl>  
@@ -528,14 +528,14 @@ find_prev_fhdr(struct sk_buff *skb, u8 *prevhdrp, int *prevhoff, int *fhoff) <nl>  		if (!ipv6_ext_hdr(nexthdr)) { <nl>  			return -1; <nl>  		} <nl> -		if (len < (int)sizeof(struct ipv6_opt_hdr)) { <nl> -			pr_debug("too short\n"); <nl> -			return -1; <nl> -		} <nl>  		if (nexthdr == NEXTHDR_NONE) { <nl>  			pr_debug("next header is none\n"); <nl>  			return -1; <nl>  		} <nl> +		if (len < (int)sizeof(struct ipv6_opt_hdr)) { <nl> +			pr_debug("too short\n"); <nl> +			return -1; <nl> +		} <nl>  		if (skb_copy_bits(skb, start, &hdr, sizeof(hdr))) <nl>  			BUG(); <nl>  		if (nexthdr == NEXTHDR_AUTH)
@@ -786,6 +786,10 @@ static void mcam_ctlr_image(struct mcam_camera *cam) <nl>  		mcam_reg_write_mask(cam, REG_CTRL0, <nl>  			C0_DF_RGB | C0_RGBF_565 | C0_RGB5_BGGR, C0_DF_MASK); <nl>  		break; <nl> +	case V4L2_PIX_FMT_SBGGR8: <nl> +		mcam_reg_write_mask(cam, REG_CTRL0, <nl> +			C0_DF_RGB | C0_RGB5_GRBG, C0_DF_MASK); <nl> +		break; <nl>  	default: <nl>  		cam_err(cam, "camera: unknown format: %#x\n", fmt->pixelformat); <nl>  		break;
@@ -42,9 +42,9 @@ static void __init imx6sl_init_late(void) <nl>  	if (IS_ENABLED(CONFIG_ARM_IMX6Q_CPUFREQ)) <nl>  		platform_device_register_simple("imx6q-cpufreq", -1, NULL, 0); <nl>   <nl> -	if (cpu_is_imx6sl()) <nl> +	if (IS_ENABLED(CONFIG_SOC_IMX6SL) && cpu_is_imx6sl()) <nl>  		imx6sl_cpuidle_init(); <nl> -	else <nl> +	else if (IS_ENABLED(CONFIG_SOC_IMX6SLL)) <nl>  		imx6sx_cpuidle_init(); <nl>  } <nl>  
@@ -1750,7 +1750,11 @@ static void __iov_iter_advance_iov(struct iov_iter *i, size_t bytes) <nl>  		const struct iovec *iov = i->iov; <nl>  		size_t base = i->iov_offset; <nl>   <nl> -		while (bytes) { <nl> +		/* <nl> +		 * The !iov->iov_len check ensures we skip over unlikely <nl> +		 * zero-length segments. <nl> +		 */ <nl> +		while (bytes || !iov->iov_len) { <nl>  			int copy = min(bytes, iov->iov_len - base); <nl>   <nl>  			bytes -= copy; <nl> @@ -2268,6 +2272,7 @@ static ssize_t generic_perform_write(struct file *file, <nl>   <nl>  		cond_resched(); <nl>   <nl> +		iov_iter_advance(i, copied); <nl>  		if (unlikely(copied == 0)) { <nl>  			/* <nl>  			 * If we were unable to copy any data at all, we must <nl> @@ -2281,7 +2286,6 @@ static ssize_t generic_perform_write(struct file *file, <nl>  						iov_iter_single_seg_count(i)); <nl>  			goto again; <nl>  		} <nl> -		iov_iter_advance(i, copied); <nl>  		pos += copied; <nl>  		written += copied; <nl>  
@@ -247,6 +247,13 @@ void mesh_mgmt_ies_add(struct sk_buff *skb, struct ieee80211_sub_if_data *sdata) <nl>  		} <nl>  	} <nl>   <nl> +	if (sband->band == IEEE80211_BAND_2GHZ) { <nl> +		pos = skb_put(skb, 2 + 1); <nl> +		*pos++ = WLAN_EID_DS_PARAMS; <nl> +		*pos++ = 1; <nl> +		*pos++ = ieee80211_frequency_to_channel(local->hw.conf.channel->center_freq); <nl> +	} <nl> + <nl>  	pos = skb_put(skb, 2 + sdata->u.mesh.mesh_id_len); <nl>  	*pos++ = WLAN_EID_MESH_ID; <nl>  	*pos++ = sdata->u.mesh.mesh_id_len;
@@ -599,7 +599,7 @@ int sctp_packet_transmit(struct sctp_packet *packet) <nl>  	return err; <nl>  no_route: <nl>  	kfree_skb(nskb); <nl> -	IP_INC_STATS_BH(sock_net(asoc->base.sk), IPSTATS_MIB_OUTNOROUTES); <nl> +	IP_INC_STATS(sock_net(asoc->base.sk), IPSTATS_MIB_OUTNOROUTES); <nl>   <nl>  	/* FIXME: Returning the 'err' will effect all the associations <nl>  	 * associated with a socket, although only one of the paths of the
@@ -1020,6 +1020,11 @@ static int __devinit vortex_init_one(struct pci_dev *pdev, <nl>  	ioaddr = pci_iomap(pdev, pci_bar, 0); <nl>  	if (!ioaddr) /* If mapping fails, fall-back to BAR 0... */ <nl>  		ioaddr = pci_iomap(pdev, 0, 0); <nl> +	if (!ioaddr) { <nl> +		pci_disable_device(pdev); <nl> +		rc = -ENOMEM; <nl> +		goto out; <nl> +	} <nl>   <nl>  	rc = vortex_probe1(&pdev->dev, ioaddr, pdev->irq, <nl>  			   ent->driver_data, unit);
@@ -1555,7 +1555,14 @@ int rtl_pci_reset_trx_ring(struct ieee80211_hw *hw) <nl>  				dev_kfree_skb_irq(skb); <nl>  				ring->idx = (ring->idx + 1) % ring->entries; <nl>  			} <nl> + <nl> +			if (rtlpriv->use_new_trx_flow) { <nl> +				rtlpci->tx_ring[i].cur_tx_rp = 0; <nl> +				rtlpci->tx_ring[i].cur_tx_wp = 0; <nl> +			} <nl> + <nl>  			ring->idx = 0; <nl> +			ring->entries = rtlpci->txringcount[i]; <nl>  		} <nl>  	} <nl>  	spin_unlock_irqrestore(&rtlpriv->locks.irq_th_lock, flags);
@@ -2049,6 +2049,10 @@ void pnfs_error_mark_layout_for_return(struct inode *inode, <nl>  	bool return_now = false; <nl>   <nl>  	spin_lock(&inode->i_lock); <nl> +	if (!pnfs_layout_is_valid(lo)) { <nl> +		spin_unlock(&inode->i_lock); <nl> +		return; <nl> +	} <nl>  	pnfs_set_plh_return_info(lo, range.iomode, 0); <nl>  	/* Block LAYOUTGET */ <nl>  	set_bit(NFS_LAYOUT_RETURN, &lo->plh_flags);
@@ -177,6 +177,14 @@ static struct dmi_system_id __initdata acpisleep_dmi_table[] = { <nl>  	}, <nl>  	{ <nl>  	.callback = init_nvs_nosave, <nl> +	.ident = "Sony Vaio VGN-FW41E_H", <nl> +	.matches = { <nl> +		DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"), <nl> +		DMI_MATCH(DMI_PRODUCT_NAME, "VGN-FW41E_H"), <nl> +		}, <nl> +	}, <nl> +	{ <nl> +	.callback = init_nvs_nosave, <nl>  	.ident = "Sony Vaio VGN-FW21E", <nl>  	.matches = { <nl>  		DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
@@ -553,14 +553,13 @@ static int linux_wlan_firmware_download(struct net_device *dev) <nl>   <nl>  	if (!wilc->firmware) { <nl>  		PRINT_ER("Firmware buffer is NULL\n"); <nl> -		ret = -ENOBUFS; <nl> -		goto _FAIL_; <nl> +		return -ENOBUFS; <nl>  	} <nl>  	PRINT_D(INIT_DBG, "Downloading Firmware ...\n"); <nl>  	ret = wilc_wlan_firmware_download(wilc->firmware->data, <nl>  					  wilc->firmware->size); <nl>  	if (ret < 0) <nl> -		goto _FAIL_; <nl> +		return ret; <nl>   <nl>  	PRINT_D(INIT_DBG, "Freeing FW buffer ...\n"); <nl>  	PRINT_D(INIT_DBG, "Releasing firmware\n"); <nl> @@ -568,8 +567,7 @@ static int linux_wlan_firmware_download(struct net_device *dev) <nl>   <nl>  	PRINT_D(INIT_DBG, "Download Succeeded\n"); <nl>   <nl> -_FAIL_: <nl> -	return ret; <nl> +	return 0; <nl>  } <nl>   <nl>  static int linux_wlan_init_test_config(struct net_device *dev, struct wilc *p_nic)
@@ -761,6 +761,10 @@ static int sunxi_mmc_clk_set_rate(struct sunxi_mmc_host *host, <nl>  	u32 rval, clock = ios->clock; <nl>  	int ret; <nl>   <nl> +	ret = sunxi_mmc_oclk_onoff(host, 0); <nl> +	if (ret) <nl> +		return ret; <nl> + <nl>  	/* 8 bit DDR requires a higher module clock */ <nl>  	if (ios->timing == MMC_TIMING_MMC_DDR52 && <nl>  	    ios->bus_width == MMC_BUS_WIDTH_8) <nl> @@ -783,10 +787,6 @@ static int sunxi_mmc_clk_set_rate(struct sunxi_mmc_host *host, <nl>  		return ret; <nl>  	} <nl>   <nl> -	ret = sunxi_mmc_oclk_onoff(host, 0); <nl> -	if (ret) <nl> -		return ret; <nl> - <nl>  	/* clear internal divider */ <nl>  	rval = mmc_readl(host, REG_CLKCR); <nl>  	rval &= ~0xff;
@@ -100,6 +100,9 @@ static ssize_t ci_port_test_write(struct file *file, const char __user *ubuf, <nl>  	if (sscanf(buf, "%u", &mode) != 1) <nl>  		return -EINVAL; <nl>   <nl> +	if (mode > 255) <nl> +		return -EBADRQC; <nl> + <nl>  	pm_runtime_get_sync(ci->dev); <nl>  	spin_lock_irqsave(&ci->lock, flags); <nl>  	ret = hw_port_test_set(ci, mode);
@@ -723,6 +723,7 @@ static int ioctl_send_response(struct client *client, void *buffer) <nl>  		if (copy_from_user(r->data, u64_to_uptr(request->data), <nl>  				   r->length)) { <nl>  			ret = -EFAULT; <nl> +			kfree(r->request); <nl>  			goto out; <nl>  		} <nl>  		fw_send_response(client->device->card, r->request,
@@ -1730,6 +1730,8 @@ static void remap_cell_to_origin_clear_discard(struct cache *cache, <nl>  		remap_to_origin(cache, bio); <nl>  		issue(cache, bio); <nl>  	} <nl> + <nl> +	free_prison_cell(cache, cell); <nl>  } <nl>   <nl>  static void remap_cell_to_cache_dirty(struct cache *cache, struct dm_bio_prison_cell *cell, <nl> @@ -1764,6 +1766,8 @@ static void remap_cell_to_cache_dirty(struct cache *cache, struct dm_bio_prison_ <nl>  		remap_to_cache(cache, bio, cblock); <nl>  		issue(cache, bio); <nl>  	} <nl> + <nl> +	free_prison_cell(cache, cell); <nl>  } <nl>   <nl>  /*----------------------------------------------------------------*/
@@ -819,7 +819,6 @@ static netdev_tx_t ems_usb_start_xmit(struct sk_buff *skb, struct net_device *ne <nl>   <nl>  		usb_unanchor_urb(urb); <nl>  		usb_free_coherent(dev->udev, size, buf, urb->transfer_dma); <nl> -		dev_kfree_skb(skb); <nl>   <nl>  		atomic_dec(&dev->active_tx_urbs); <nl>  
@@ -2055,11 +2055,14 @@ static int domain_context_mapping_one(struct dmar_domain *domain, <nl>  	if (context_copied(context)) { <nl>  		u16 did_old = context_domain_id(context); <nl>   <nl> -		if (did_old >= 0 && did_old < cap_ndoms(iommu->cap)) <nl> +		if (did_old >= 0 && did_old < cap_ndoms(iommu->cap)) { <nl>  			iommu->flush.flush_context(iommu, did_old, <nl>  						   (((u16)bus) << 8) | devfn, <nl>  						   DMA_CCMD_MASK_NOBIT, <nl>  						   DMA_CCMD_DEVICE_INVL); <nl> +			iommu->flush.flush_iotlb(iommu, did_old, 0, 0, <nl> +						 DMA_TLB_DSI_FLUSH); <nl> +		} <nl>  	} <nl>   <nl>  	pgd = domain->pgd;
@@ -2092,6 +2092,13 @@ static int f2fs_move_file_range(struct file *file_in, loff_t pos_in, <nl>  	if (f2fs_encrypted_inode(src) || f2fs_encrypted_inode(dst)) <nl>  		return -EOPNOTSUPP; <nl>   <nl> +	if (src == dst) { <nl> +		if (pos_in == pos_out) <nl> +			return 0; <nl> +		if (pos_out > pos_in && pos_out < pos_in + len) <nl> +			return -EINVAL; <nl> +	} <nl> + <nl>  	inode_lock(src); <nl>  	if (src != dst) { <nl>  		if (!inode_trylock(dst)) {
@@ -877,6 +877,7 @@ int rds_cmsg_atomic(struct rds_sock *rs, struct rds_message *rm, <nl>  err: <nl>  	if (page) <nl>  		put_page(page); <nl> +	rm->atomic.op_active = 0; <nl>  	kfree(rm->atomic.op_notifier); <nl>   <nl>  	return ret;
@@ -449,7 +449,7 @@ static int sh_cmt_register_clocksource(struct sh_cmt_priv *p, <nl>  	clk_disable(p->clk); <nl>   <nl>  	/* TODO: calculate good shift from rate and counter bit width */ <nl> -	cs->shift = 10; <nl> +	cs->shift = 0; <nl>  	cs->mult = clocksource_hz2mult(p->rate, cs->shift); <nl>   <nl>  	dev_info(&p->pdev->dev, "used as clock source\n");
@@ -888,7 +888,7 @@ struct fb_info { <nl>  #define fb_writeq sbus_writeq <nl>  #define fb_memset sbus_memset_io <nl>   <nl> -#elif defined(__i386__) || defined(__alpha__) || defined(__x86_64__) || defined(__hppa__) || (defined(__sh__) && !defined(__SH5__)) || defined(__powerpc__) || defined(__avr32__) <nl> +#elif defined(__i386__) || defined(__alpha__) || defined(__x86_64__) || defined(__hppa__) || defined(__sh__) || defined(__powerpc__) || defined(__avr32__) <nl>   <nl>  #define fb_readb __raw_readb <nl>  #define fb_readw __raw_readw
@@ -152,6 +152,7 @@ static int __ocfs2_move_extent(handle_t *handle, <nl>  	} <nl>   <nl>  out: <nl> +	ocfs2_free_path(path); <nl>  	return ret; <nl>  } <nl>  
@@ -864,7 +864,7 @@ int skl_init_module(struct skl_sst *ctx, <nl>  		return ret; <nl>  	} <nl>  	mconfig->m_state = SKL_MODULE_INIT_DONE; <nl> - <nl> +	kfree(param_data); <nl>  	return ret; <nl>  } <nl>  
@@ -451,6 +451,8 @@ static void sdhci_intel_set_power(struct sdhci_host *host, unsigned char mode, <nl>  	if (mode == MMC_POWER_OFF) <nl>  		return; <nl>   <nl> +	spin_unlock_irq(&host->lock); <nl> + <nl>  	/* <nl>  	 * Bus power might not enable after D3 -> D0 transition due to the <nl>  	 * present state not yet having propagated. Retry for up to 2ms. <nl> @@ -463,6 +465,8 @@ static void sdhci_intel_set_power(struct sdhci_host *host, unsigned char mode, <nl>  		reg |= SDHCI_POWER_ON; <nl>  		sdhci_writeb(host, reg, SDHCI_POWER_CONTROL); <nl>  	} <nl> + <nl> +	spin_lock_irq(&host->lock); <nl>  } <nl>   <nl>  static const struct sdhci_ops sdhci_intel_byt_ops = {
@@ -103,7 +103,8 @@ static inline struct sk_buff *udp_tunnel_handle_offloads(struct sk_buff *skb, <nl>  { <nl>  	int type = udp_csum ? SKB_GSO_UDP_TUNNEL_CSUM : SKB_GSO_UDP_TUNNEL; <nl>   <nl> -	return iptunnel_handle_offloads(skb, udp_csum, type); <nl> +	/* As we're a UDP tunnel, we support LCO, so don't need csum_help */ <nl> +	return iptunnel_handle_offloads(skb, false, type); <nl>  } <nl>   <nl>  static inline void udp_tunnel_gro_complete(struct sk_buff *skb, int nhoff)
@@ -1692,6 +1692,7 @@ static bool intel_sdvo_detect_hdmi_audio(struct drm_connector *connector) <nl>  	edid = intel_sdvo_get_edid(connector); <nl>  	if (edid != NULL && edid->input & DRM_EDID_INPUT_DIGITAL) <nl>  		has_audio = drm_detect_monitor_audio(edid); <nl> +	kfree(edid); <nl>   <nl>  	return has_audio; <nl>  }
@@ -6226,7 +6226,8 @@ static void __devinit bnx2x_link_settings_supported(struct bnx2x *bp, <nl>  			break; <nl>   <nl>  		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8481: <nl> -			BNX2X_DEV_INFO("ext_phy_type 0x%x (BCM8481)\n", <nl> +		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84823: <nl> +			BNX2X_DEV_INFO("ext_phy_type 0x%x (BCM848xx)\n", <nl>  				       ext_phy_type); <nl>   <nl>  			bp->port.supported |= (SUPPORTED_10baseT_Half |
@@ -215,7 +215,7 @@ static int blktrans_open(struct block_device *bdev, fmode_t mode) <nl>   <nl>  	mutex_lock(&dev->lock); <nl>   <nl> -	if (dev->open++) <nl> +	if (dev->open) <nl>  		goto unlock; <nl>   <nl>  	kref_get(&dev->ref); <nl> @@ -235,6 +235,7 @@ static int blktrans_open(struct block_device *bdev, fmode_t mode) <nl>  		goto error_release; <nl>   <nl>  unlock: <nl> +	dev->open++; <nl>  	mutex_unlock(&dev->lock); <nl>  	blktrans_dev_put(dev); <nl>  	return ret;
@@ -1088,7 +1088,7 @@ static void mmu_pte_write_zap_pte(struct kvm_vcpu *vcpu, <nl>  			mmu_page_remove_parent_pte(child, spte); <nl>  		} <nl>  	} <nl> -	*spte = 0; <nl> +	set_shadow_pte(spte, 0); <nl>  	kvm_flush_remote_tlbs(vcpu->kvm); <nl>  } <nl>  
@@ -1085,6 +1085,8 @@ ecryptfs_setxattr(struct dentry *dentry, const char *name, const void *value, <nl>  	} <nl>   <nl>  	rc = vfs_setxattr(lower_dentry, name, value, size, flags); <nl> +	if (!rc) <nl> +		fsstack_copy_attr_all(dentry->d_inode, lower_dentry->d_inode); <nl>  out: <nl>  	return rc; <nl>  }
@@ -606,6 +606,7 @@ static int dvb_fini(struct em28xx *dev) <nl>   <nl>  	if (dev->dvb) { <nl>  		unregister_dvb(dev->dvb); <nl> +		kfree(dev->dvb); <nl>  		dev->dvb = NULL; <nl>  	} <nl>  
@@ -648,7 +648,7 @@ static int cppi41_tear_down_chan(struct cppi41_channel *c) <nl>  		if (!c->is_tx) { <nl>  			reg |= GCR_STARV_RETRY; <nl>  			reg |= GCR_DESC_TYPE_HOST; <nl> -			reg |= c->q_comp_num; <nl> +			reg |= cdd->td_queue.complete; <nl>  		} <nl>  		reg |= GCR_TEARDOWN; <nl>  		cppi_writel(reg, c->gcr_reg); <nl> @@ -659,7 +659,7 @@ static int cppi41_tear_down_chan(struct cppi41_channel *c) <nl>  	if (!c->td_seen || !c->td_desc_seen) { <nl>   <nl>  		desc_phys = cppi41_pop_desc(cdd, cdd->td_queue.complete); <nl> -		if (!desc_phys) <nl> +		if (!desc_phys && c->is_tx) <nl>  			desc_phys = cppi41_pop_desc(cdd, c->q_comp_num); <nl>   <nl>  		if (desc_phys == c->desc_phys) {
@@ -3423,6 +3423,8 @@ static int rt6_fill_node(struct net *net, <nl>  	} <nl>  	else if (rt->rt6i_flags & RTF_LOCAL) <nl>  		rtm->rtm_type = RTN_LOCAL; <nl> +	else if (rt->rt6i_flags & RTF_ANYCAST) <nl> +		rtm->rtm_type = RTN_ANYCAST; <nl>  	else if (rt->dst.dev && (rt->dst.dev->flags & IFF_LOOPBACK)) <nl>  		rtm->rtm_type = RTN_LOCAL; <nl>  	else
@@ -449,6 +449,9 @@ static int synic_set_irq(struct kvm_vcpu_hv_synic *synic, u32 sint) <nl>  	struct kvm_lapic_irq irq; <nl>  	int ret, vector; <nl>   <nl> +	if (KVM_BUG_ON(!lapic_in_kernel(vcpu), vcpu->kvm)) <nl> +		return -EINVAL; <nl> + <nl>  	if (sint >= ARRAY_SIZE(synic->sint)) <nl>  		return -EINVAL; <nl>  
@@ -66,7 +66,7 @@ static void cdc_ncm_tx_timeout_start(struct cdc_ncm_ctx *ctx); <nl>  static enum hrtimer_restart cdc_ncm_tx_timer_cb(struct hrtimer *hr_timer); <nl>  static struct usb_driver cdc_ncm_driver; <nl>   <nl> -static u8 cdc_ncm_setup(struct usbnet *dev) <nl> +static int cdc_ncm_setup(struct usbnet *dev) <nl>  { <nl>  	struct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0]; <nl>  	struct usb_cdc_ncm_ntb_parameters ncm_parm;
@@ -2227,6 +2227,11 @@ static ssize_t target_core_alua_tg_pt_gp_store_attr_alua_access_state( <nl>  			" tg_pt_gp ID: %hu\n", tg_pt_gp->tg_pt_gp_valid_id); <nl>  		return -EINVAL; <nl>  	} <nl> +	if (!(dev->dev_flags & DF_CONFIGURED)) { <nl> +		pr_err("Unable to set alua_access_state while device is" <nl> +		       " not configured\n"); <nl> +		return -ENODEV; <nl> +	} <nl>   <nl>  	ret = kstrtoul(page, 0, &tmp); <nl>  	if (ret < 0) {
@@ -2147,12 +2147,14 @@ static void ext3_mark_recovery_complete(struct super_block * sb, <nl>   <nl>  	journal_lock_updates(journal); <nl>  	journal_flush(journal); <nl> +	lock_super(sb); <nl>  	if (EXT3_HAS_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER) && <nl>  	    sb->s_flags & MS_RDONLY) { <nl>  		EXT3_CLEAR_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER); <nl>  		sb->s_dirt = 0; <nl>  		ext3_commit_super(sb, es, 1); <nl>  	} <nl> +	unlock_super(sb); <nl>  	journal_unlock_updates(journal); <nl>  } <nl>   <nl> @@ -2341,7 +2343,13 @@ static int ext3_remount (struct super_block * sb, int * flags, char * data) <nl>  			    (sbi->s_mount_state & EXT3_VALID_FS)) <nl>  				es->s_state = cpu_to_le16(sbi->s_mount_state); <nl>   <nl> +			/* <nl> +			 * We have to unlock super so that we can wait for <nl> +			 * transactions. <nl> +			 */ <nl> +			unlock_super(sb); <nl>  			ext3_mark_recovery_complete(sb, es); <nl> +			lock_super(sb); <nl>  		} else { <nl>  			__le32 ret; <nl>  			if ((ret = EXT3_HAS_RO_COMPAT_FEATURE(sb,
@@ -390,7 +390,7 @@ static int wusb_oob_mic_verify(void) <nl>  				    0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, <nl>  				    0x2c, 0x2d, 0x2e, 0x2f }, <nl>  		.MIC	 	= { 0x75, 0x6a, 0x97, 0x51, 0x0c, 0x8c, <nl> -				    0x14, 0x7b } , <nl> +				    0x14, 0x7b }, <nl>  	}; <nl>  	size_t hs_size; <nl>   <nl> @@ -480,7 +480,7 @@ static int wusb_key_derive_verify(void) <nl>  		printk(KERN_ERR "E: keydvt in: key\n"); <nl>  		wusb_key_dump(stv_key_a1, sizeof(stv_key_a1)); <nl>  		printk(KERN_ERR "E: keydvt in: nonce\n"); <nl> -		wusb_key_dump( &stv_keydvt_n_a1, sizeof(stv_keydvt_n_a1)); <nl> +		wusb_key_dump(&stv_keydvt_n_a1, sizeof(stv_keydvt_n_a1)); <nl>  		printk(KERN_ERR "E: keydvt in: hnonce & dnonce\n"); <nl>  		wusb_key_dump(&stv_keydvt_in_a1, sizeof(stv_keydvt_in_a1)); <nl>  		printk(KERN_ERR "E: keydvt out: KCK\n");
@@ -163,7 +163,7 @@ static void arc_emac_tx_clean(struct net_device *ndev) <nl>  		struct sk_buff *skb = tx_buff->skb; <nl>  		unsigned int info = le32_to_cpu(txbd->info); <nl>   <nl> -		if ((info & FOR_EMAC) || !txbd->data) <nl> +		if ((info & FOR_EMAC) || !txbd->data || !skb) <nl>  			break; <nl>   <nl>  		if (unlikely(info & (DROP | DEFR | LTCL | UFLO))) { <nl> @@ -191,6 +191,7 @@ static void arc_emac_tx_clean(struct net_device *ndev) <nl>   <nl>  		txbd->data = 0; <nl>  		txbd->info = 0; <nl> +		tx_buff->skb = NULL; <nl>   <nl>  		*txbd_dirty = (*txbd_dirty + 1) % TX_BD_NUM; <nl>  	} <nl> @@ -610,7 +611,6 @@ static int arc_emac_tx(struct sk_buff *skb, struct net_device *ndev) <nl>  	dma_unmap_addr_set(&priv->tx_buff[*txbd_curr], addr, addr); <nl>  	dma_unmap_len_set(&priv->tx_buff[*txbd_curr], len, len); <nl>   <nl> -	priv->tx_buff[*txbd_curr].skb = skb; <nl>  	priv->txbd[*txbd_curr].data = cpu_to_le32(addr); <nl>   <nl>  	/* Make sure pointer to data buffer is set */ <nl> @@ -620,6 +620,11 @@ static int arc_emac_tx(struct sk_buff *skb, struct net_device *ndev) <nl>   <nl>  	*info = cpu_to_le32(FOR_EMAC | FIRST_OR_LAST_MASK | len); <nl>   <nl> +	/* Make sure info word is set */ <nl> +	wmb(); <nl> + <nl> +	priv->tx_buff[*txbd_curr].skb = skb; <nl> + <nl>  	/* Increment index to point to the next BD */ <nl>  	*txbd_curr = (*txbd_curr + 1) % TX_BD_NUM; <nl>  
@@ -410,6 +410,8 @@ int rds_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg, <nl>   <nl>  	rdsdebug("size %zu flags 0x%x timeo %ld\n", size, msg_flags, timeo); <nl>   <nl> +	msg->msg_namelen = 0; <nl> + <nl>  	if (msg_flags & MSG_OOB) <nl>  		goto out; <nl>   <nl> @@ -485,6 +487,7 @@ int rds_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg, <nl>  			sin->sin_port = inc->i_hdr.h_sport; <nl>  			sin->sin_addr.s_addr = inc->i_saddr; <nl>  			memset(sin->sin_zero, 0, sizeof(sin->sin_zero)); <nl> +			msg->msg_namelen = sizeof(*sin); <nl>  		} <nl>  		break; <nl>  	}
@@ -1141,11 +1141,10 @@ static void ipr_handle_log_data(struct ipr_ioa_cfg *ioa_cfg, <nl>   <nl>  	if (ioa_cfg->log_level < IPR_DEFAULT_LOG_LEVEL) <nl>  		return; <nl> +	if (be32_to_cpu(hostrcb->hcam.length) > sizeof(hostrcb->hcam.u.raw)) <nl> +		hostrcb->hcam.length = cpu_to_be32(sizeof(hostrcb->hcam.u.raw)); <nl>   <nl>  	switch (hostrcb->hcam.overlay_id) { <nl> -	case IPR_HOST_RCB_OVERLAY_ID_1: <nl> -		ipr_log_generic_error(ioa_cfg, hostrcb); <nl> -		break; <nl>  	case IPR_HOST_RCB_OVERLAY_ID_2: <nl>  		ipr_log_cache_error(ioa_cfg, hostrcb); <nl>  		break; <nl> @@ -1156,6 +1155,7 @@ static void ipr_handle_log_data(struct ipr_ioa_cfg *ioa_cfg, <nl>  	case IPR_HOST_RCB_OVERLAY_ID_6: <nl>  		ipr_log_array_error(ioa_cfg, hostrcb); <nl>  		break; <nl> +	case IPR_HOST_RCB_OVERLAY_ID_1: <nl>  	case IPR_HOST_RCB_OVERLAY_ID_DEFAULT: <nl>  	default: <nl>  		ipr_log_generic_error(ioa_cfg, hostrcb);
@@ -127,6 +127,13 @@ void vgic_v3_populate_lr(struct kvm_vcpu *vcpu, struct vgic_irq *irq, int lr) <nl>  	if (irq->hw) { <nl>  		val |= ICH_LR_HW; <nl>  		val |= ((u64)irq->hwintid) << ICH_LR_PHYS_ID_SHIFT; <nl> +		/* <nl> +		 * Never set pending+active on a HW interrupt, as the <nl> +		 * pending state is kept at the physical distributor <nl> +		 * level. <nl> +		 */ <nl> +		if (irq->active && irq_is_pending(irq)) <nl> +			val &= ~ICH_LR_PENDING_BIT; <nl>  	} else { <nl>  		if (irq->config == VGIC_CONFIG_LEVEL) <nl>  			val |= ICH_LR_EOI;
@@ -56,6 +56,7 @@ <nl>  #include <net/neighbour.h> <nl>  #include <net/route.h> <nl>  #include <net/ip_fib.h> <nl> +#include <net/tcp.h> <nl>   <nl>  #include "nes.h" <nl>   <nl> @@ -1514,7 +1515,7 @@ static int check_seq(struct nes_cm_node *cm_node, struct tcphdr *tcph, <nl>  	rcv_wnd = cm_node->tcp_cntxt.rcv_wnd; <nl>  	if (ack_seq != loc_seq_num) <nl>  		err = 1; <nl> -	else if ((seq + rcv_wnd) < rcv_nxt) <nl> +	else if (!between(seq, rcv_nxt, (rcv_nxt+rcv_wnd))) <nl>  		err = 1; <nl>  	if (err) { <nl>  		nes_debug(NES_DBG_CM, "%s[%u] create abort for cm_node=%p "
@@ -1285,6 +1285,7 @@ static struct xfrm_state * pfkey_msg2xfrm_state(struct net *net, <nl>  				ext_hdrs[SADB_X_EXT_NAT_T_DPORT-1]; <nl>  			natt->encap_dport = n_port->sadb_x_nat_t_port_port; <nl>  		} <nl> +		memset(&natt->encap_oa, 0, sizeof(natt->encap_oa)); <nl>  	} <nl>   <nl>  	err = xfrm_init_state(x);
@@ -304,7 +304,7 @@ static void __ieee80211_scan_completed(struct ieee80211_hw *hw, bool aborted, <nl>  	if (local->scan_req != local->int_scan_req) <nl>  		cfg80211_scan_done(local->scan_req, aborted); <nl>  	local->scan_req = NULL; <nl> -	local->scan_sdata = NULL; <nl> +	rcu_assign_pointer(local->scan_sdata, NULL); <nl>   <nl>  	local->scanning = 0; <nl>  	local->scan_channel = NULL;
@@ -93,6 +93,13 @@ static int ata_ering_map(struct ata_ering *ering, <nl>  	return rc; <nl>  } <nl>   <nl> +static unsigned int ata_eh_dev_action(struct ata_device *dev) <nl> +{ <nl> +	struct ata_eh_context *ehc = &dev->ap->eh_context; <nl> + <nl> +	return ehc->i.action | ehc->i.dev_action[dev->devno]; <nl> +} <nl> + <nl>  static void ata_eh_clear_action(struct ata_device *dev, <nl>  				struct ata_eh_info *ehi, unsigned int action) <nl>  { <nl> @@ -1592,7 +1599,7 @@ static int ata_eh_revalidate_and_attach(struct ata_port *ap, <nl>  		unsigned int action; <nl>   <nl>  		dev = &ap->device[i]; <nl> -		action = ehc->i.action | ehc->i.dev_action[dev->devno]; <nl> +		action = ata_eh_dev_action(dev); <nl>   <nl>  		if (action & ATA_EH_REVALIDATE && ata_dev_enabled(dev)) { <nl>  			if (ata_port_offline(ap)) {
@@ -296,6 +296,7 @@ static void oz_add_farewell(struct oz_pd *pd, u8 ep_num, u8 index, <nl>  		return; <nl>  	f->ep_num = ep_num; <nl>  	f->index = index; <nl> +	f->len = len; <nl>  	memcpy(f->report, report, len); <nl>  	oz_dbg(ON, "RX: Adding farewell report\n"); <nl>  	spin_lock(&g_polling_lock);
@@ -826,12 +826,14 @@ static int i40iw_query_qp(struct ib_qp *ibqp, <nl>  	attr->cap.max_inline_data = I40IW_MAX_INLINE_DATA_SIZE; <nl>  	attr->cap.max_send_sge = I40IW_MAX_WQ_FRAGMENT_COUNT; <nl>  	attr->cap.max_recv_sge = I40IW_MAX_WQ_FRAGMENT_COUNT; <nl> +	attr->port_num = 1; <nl>  	init_attr->event_handler = iwqp->ibqp.event_handler; <nl>  	init_attr->qp_context = iwqp->ibqp.qp_context; <nl>  	init_attr->send_cq = iwqp->ibqp.send_cq; <nl>  	init_attr->recv_cq = iwqp->ibqp.recv_cq; <nl>  	init_attr->srq = iwqp->ibqp.srq; <nl>  	init_attr->cap = attr->cap; <nl> +	init_attr->port_num = 1; <nl>  	return 0; <nl>  } <nl>  
@@ -986,7 +986,8 @@ static int intel_backlight_device_update_status(struct backlight_device *bd) <nl>  	 */ <nl>  	if (panel->backlight.enabled) { <nl>  		if (panel->backlight_power) { <nl> -			bool enable = bd->props.power == FB_BLANK_UNBLANK; <nl> +			bool enable = bd->props.power == FB_BLANK_UNBLANK && <nl> +				bd->props.brightness != 0; <nl>  			panel->backlight_power(connector, enable); <nl>  		} <nl>  	} else {
@@ -2455,7 +2455,7 @@ ieee80211_rx_h_action_return(struct ieee80211_rx_data *rx) <nl>  	 * frames that we didn't handle, including returning unknown <nl>  	 * ones. For all other modes we will return them to the sender, <nl>  	 * setting the 0x80 bit in the action category, as required by <nl> -	 * 802.11-2007 7.3.1.11. <nl> +	 * 802.11-2012 9.24.4. <nl>  	 * Newer versions of hostapd shall also use the management frame <nl>  	 * registration mechanisms, but older ones still use cooked <nl>  	 * monitor interfaces so push all frames there. <nl> @@ -2465,6 +2465,9 @@ ieee80211_rx_h_action_return(struct ieee80211_rx_data *rx) <nl>  	     sdata->vif.type == NL80211_IFTYPE_AP_VLAN)) <nl>  		return RX_DROP_MONITOR; <nl>   <nl> +	if (is_multicast_ether_addr(mgmt->da)) <nl> +		return RX_DROP_MONITOR; <nl> + <nl>  	/* do not return rejected action frames */ <nl>  	if (mgmt->u.action.category & 0x80) <nl>  		return RX_DROP_UNUSABLE;
@@ -2319,15 +2319,15 @@ void intel_power_domains_init_hw(struct drm_i915_private *dev_priv, bool resume) <nl>   */ <nl>  void intel_power_domains_suspend(struct drm_i915_private *dev_priv) <nl>  { <nl> -	if (IS_SKYLAKE(dev_priv) || IS_KABYLAKE(dev_priv)) <nl> -		skl_display_core_uninit(dev_priv); <nl> - <nl>  	/* <nl>  	 * Even if power well support was disabled we still want to disable <nl>  	 * power wells while we are system suspended. <nl>  	 */ <nl>  	if (!i915.disable_power_well) <nl>  		intel_display_power_put(dev_priv, POWER_DOMAIN_INIT); <nl> + <nl> +	if (IS_SKYLAKE(dev_priv) || IS_KABYLAKE(dev_priv)) <nl> +		skl_display_core_uninit(dev_priv); <nl>  } <nl>   <nl>  /**
@@ -365,7 +365,7 @@ static int ep93xx_ac97_probe(struct platform_device *pdev) <nl>  { <nl>  	struct ep93xx_ac97_info *info; <nl>  	struct resource *res; <nl> -	unsigned int irq; <nl> +	int irq; <nl>  	int ret; <nl>   <nl>  	info = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL); <nl> @@ -378,8 +378,8 @@ static int ep93xx_ac97_probe(struct platform_device *pdev) <nl>  		return PTR_ERR(info->regs); <nl>   <nl>  	irq = platform_get_irq(pdev, 0); <nl> -	if (!irq) <nl> -		return -ENODEV; <nl> +	if (irq <= 0) <nl> +		return irq < 0 ? irq : -ENODEV; <nl>   <nl>  	ret = devm_request_irq(&pdev->dev, irq, ep93xx_ac97_interrupt, <nl>  			       IRQF_TRIGGER_HIGH, pdev->name, info);
@@ -391,19 +391,19 @@ kvm_irqfd_assign(struct kvm *kvm, struct kvm_irqfd *args) <nl>  					   lockdep_is_held(&kvm->irqfds.lock)); <nl>  	irqfd_update(kvm, irqfd, irq_rt); <nl>   <nl> -	events = f.file->f_op->poll(f.file, &irqfd->pt); <nl> - <nl>  	list_add_tail(&irqfd->list, &kvm->irqfds.items); <nl>   <nl> +	spin_unlock_irq(&kvm->irqfds.lock); <nl> + <nl>  	/* <nl>  	 * Check if there was an event already pending on the eventfd <nl>  	 * before we registered, and trigger it as if we didn't miss it. <nl>  	 */ <nl> +	events = f.file->f_op->poll(f.file, &irqfd->pt); <nl> + <nl>  	if (events & POLLIN) <nl>  		schedule_work(&irqfd->inject); <nl>   <nl> -	spin_unlock_irq(&kvm->irqfds.lock); <nl> - <nl>  	/* <nl>  	 * do not drop the file until the irqfd is fully initialized, otherwise <nl>  	 * we might race against the POLLHUP
@@ -1144,16 +1144,17 @@ static irqreturn_t mmci_irq(int irq, void *dev_id) <nl>   <nl>  		dev_dbg(mmc_dev(host->mmc), "irq0 (data+cmd) %08x\n", status); <nl>   <nl> +		cmd = host->cmd; <nl> +		if (status & (MCI_CMDCRCFAIL|MCI_CMDTIMEOUT|MCI_CMDSENT| <nl> +			      MCI_CMDRESPEND) && cmd) <nl> +			mmci_cmd_irq(host, cmd, status); <nl> + <nl>  		data = host->data; <nl>  		if (status & (MCI_DATACRCFAIL|MCI_DATATIMEOUT|MCI_STARTBITERR| <nl>  			      MCI_TXUNDERRUN|MCI_RXOVERRUN|MCI_DATAEND| <nl>  			      MCI_DATABLOCKEND) && data) <nl>  			mmci_data_irq(host, data, status); <nl>   <nl> -		cmd = host->cmd; <nl> -		if (status & (MCI_CMDCRCFAIL|MCI_CMDTIMEOUT|MCI_CMDSENT|MCI_CMDRESPEND) && cmd) <nl> -			mmci_cmd_irq(host, cmd, status); <nl> - <nl>  		ret = 1; <nl>  	} while (status); <nl>  
@@ -212,8 +212,8 @@ static struct watchdog_info at32_wdt_info = { <nl>  /* <nl>   * Handle commands from user-space. <nl>   */ <nl> -static int at32_wdt_ioctl(struct inode *inode, struct file *file, <nl> -		unsigned int cmd, unsigned long arg) <nl> +static long at32_wdt_ioctl(struct file *file, <nl> +				unsigned int cmd, unsigned long arg) <nl>  { <nl>  	int ret = -ENOTTY; <nl>  	int time; <nl> @@ -298,7 +298,7 @@ static ssize_t at32_wdt_write(struct file *file, const char __user *data, <nl>  static const struct file_operations at32_wdt_fops = { <nl>  	.owner		= THIS_MODULE, <nl>  	.llseek		= no_llseek, <nl> -	.ioctl		= at32_wdt_ioctl, <nl> +	.unlocked_ioctl	= at32_wdt_ioctl, <nl>  	.open		= at32_wdt_open, <nl>  	.release	= at32_wdt_close, <nl>  	.write		= at32_wdt_write, <nl> @@ -391,7 +391,6 @@ static int __exit at32_wdt_remove(struct platform_device *pdev) <nl>  		wdt = NULL; <nl>  		platform_set_drvdata(pdev, NULL); <nl>  	} <nl> - <nl>  	return 0; <nl>  } <nl>  
@@ -1013,13 +1013,13 @@ static int destroy_queue_cpsch(struct device_queue_manager *dqm, <nl>   <nl>  	list_del(&q->list); <nl>  	qpd->queue_count--; <nl> -	if (q->properties.is_active) <nl> +	if (q->properties.is_active) { <nl>  		dqm->queue_count--; <nl> - <nl> -	retval = execute_queues_cpsch(dqm, <nl> +		retval = execute_queues_cpsch(dqm, <nl>  				KFD_UNMAP_QUEUES_FILTER_DYNAMIC_QUEUES, 0); <nl> -	if (retval == -ETIME) <nl> -		qpd->reset_wavefronts = true; <nl> +		if (retval == -ETIME) <nl> +			qpd->reset_wavefronts = true; <nl> +	} <nl>   <nl>  	mqd->uninit_mqd(mqd, q->mqd, q->mqd_mem_obj); <nl>  
@@ -1293,6 +1293,7 @@ static void hid_input_field(struct hid_device *hid, struct hid_field *field, <nl>  		/* Ignore report if ErrorRollOver */ <nl>  		if (!(field->flags & HID_MAIN_ITEM_VARIABLE) && <nl>  		    value[n] >= min && value[n] <= max && <nl> +		    value[n] - min < field->maxusage && <nl>  		    field->usage[value[n] - min].hid == HID_UP_KEYBOARD + 1) <nl>  			goto exit; <nl>  	} <nl> @@ -1305,11 +1306,13 @@ static void hid_input_field(struct hid_device *hid, struct hid_field *field, <nl>  		} <nl>   <nl>  		if (field->value[n] >= min && field->value[n] <= max <nl> +			&& field->value[n] - min < field->maxusage <nl>  			&& field->usage[field->value[n] - min].hid <nl>  			&& search(value, field->value[n], count)) <nl>  				hid_process_event(hid, field, &field->usage[field->value[n] - min], 0, interrupt); <nl>   <nl>  		if (value[n] >= min && value[n] <= max <nl> +			&& value[n] - min < field->maxusage <nl>  			&& field->usage[value[n] - min].hid <nl>  			&& search(field->value, value[n], count)) <nl>  				hid_process_event(hid, field, &field->usage[value[n] - min], 1, interrupt);
@@ -111,6 +111,7 @@ static int nf_flow_dnat_ip(const struct flow_offload *flow, struct sk_buff *skb, <nl>  	default: <nl>  		return -1; <nl>  	} <nl> +	csum_replace4(&iph->check, addr, new_addr); <nl>   <nl>  	return nf_flow_nat_ip_l4proto(skb, iph, thoff, addr, new_addr); <nl>  }
@@ -1281,7 +1281,7 @@ static int __devinit nmk_gpio_probe(struct platform_device *dev) <nl>  	struct clk *clk; <nl>  	int secondary_irq; <nl>  	void __iomem *base; <nl> -	int irq_start = -1; <nl> +	int irq_start = 0; <nl>  	int irq; <nl>  	int ret; <nl>  
@@ -1511,6 +1511,9 @@ struct powerdomain *omap_hwmod_get_pwrdm(struct omap_hwmod *oh) <nl>  		c = oh->slaves[oh->_mpu_port_index]->_clk; <nl>  	} <nl>   <nl> +	if (!c->clkdm) <nl> +		return NULL; <nl> + <nl>  	return c->clkdm->pwrdm.ptr; <nl>   <nl>  }
@@ -2794,6 +2794,12 @@ static int ctnetlink_dump_exp_ct(struct net *net, struct sock *ctnl, <nl>  		return -ENOENT; <nl>   <nl>  	ct = nf_ct_tuplehash_to_ctrack(h); <nl> +	/* No expectation linked to this connection tracking. */ <nl> +	if (!nfct_help(ct)) { <nl> +		nf_ct_put(ct); <nl> +		return 0; <nl> +	} <nl> + <nl>  	c.data = ct; <nl>   <nl>  	err = netlink_dump_start(ctnl, skb, nlh, &c);
@@ -1420,9 +1420,10 @@ int esas2r_ioctl_handler(void *hostdata, int cmd, void __user *arg) <nl>   <nl>  		rq = esas2r_alloc_request(a); <nl>  		if (rq == NULL) { <nl> -			up(&a->nvram_semaphore); <nl> -			ioctl->data.prw.code = 0; <nl> -			break; <nl> +			kfree(ioctl); <nl> +			esas2r_log(ESAS2R_LOG_WARN, <nl> +			   "could not allocate an internal request"); <nl> +			return -ENOMEM; <nl>  		} <nl>   <nl>  		code = esas2r_write_params(a, rq,
@@ -2831,7 +2831,7 @@ cifs_mount(struct super_block *sb, struct cifs_sb_info *cifs_sb, <nl>   <nl>  remote_path_check: <nl>  	/* check if a whole path (including prepath) is not remote */ <nl> -	if (!rc && cifs_sb->prepathlen && tcon) { <nl> +	if (!rc && tcon) { <nl>  		/* build_path_to_root works only when we have a valid tcon */ <nl>  		full_path = cifs_build_path_to_root(cifs_sb, tcon); <nl>  		if (full_path == NULL) {
@@ -142,8 +142,10 @@ static struct snd_seq_queue *queue_new(int owner, int locked) <nl>  static void queue_delete(struct snd_seq_queue *q) <nl>  { <nl>  	/* stop and release the timer */ <nl> +	mutex_lock(&q->timer_mutex); <nl>  	snd_seq_timer_stop(q->timer); <nl>  	snd_seq_timer_close(q); <nl> +	mutex_unlock(&q->timer_mutex); <nl>  	/* wait until access free */ <nl>  	snd_use_lock_sync(&q->use_lock); <nl>  	/* release resources... */
@@ -35,8 +35,11 @@ static int adis_update_scan_mode_burst(struct iio_dev *indio_dev, <nl>  		return -ENOMEM; <nl>   <nl>  	adis->buffer = kzalloc(burst_length + sizeof(u16), GFP_KERNEL); <nl> -	if (!adis->buffer) <nl> +	if (!adis->buffer) { <nl> +		kfree(adis->xfer); <nl> +		adis->xfer = NULL; <nl>  		return -ENOMEM; <nl> +	} <nl>   <nl>  	tx = adis->buffer + burst_length; <nl>  	tx[0] = ADIS_READ_REG(adis->burst->reg_cmd);
@@ -490,6 +490,9 @@ int bnx2i_send_iscsi_nopout(struct bnx2i_conn *bnx2i_conn, <nl>  	bnx2i_cmd = (struct bnx2i_cmd *)task->dd_data; <nl>  	nopout_hdr = (struct iscsi_nopout *)task->hdr; <nl>  	nopout_wqe = (struct bnx2i_nop_out_request *)ep->qp.sq_prod_qe; <nl> + <nl> +	memset(nopout_wqe, 0x00, sizeof(struct bnx2i_nop_out_request)); <nl> + <nl>  	nopout_wqe->op_code = nopout_hdr->opcode; <nl>  	nopout_wqe->op_attr = ISCSI_FLAG_CMD_FINAL; <nl>  	memcpy(nopout_wqe->lun, nopout_hdr->lun, 8);
@@ -5143,6 +5143,7 @@ static int brcmf_enable_bw40_2g(struct brcmf_cfg80211_info *cfg) <nl>   <nl>  		ch.band = BRCMU_CHAN_BAND_2G; <nl>  		ch.bw = BRCMU_CHAN_BW_40; <nl> +		ch.sb = BRCMU_CHAN_SB_NONE; <nl>  		ch.chnum = 0; <nl>  		cfg->d11inf.encchspec(&ch); <nl>   <nl> @@ -5176,6 +5177,7 @@ static int brcmf_enable_bw40_2g(struct brcmf_cfg80211_info *cfg) <nl>   <nl>  			brcmf_update_bw40_channel_flag(&band->channels[j], &ch); <nl>  		} <nl> +		kfree(pbuf); <nl>  	} <nl>  	return err; <nl>  }
@@ -639,6 +639,8 @@ static int dell_wmi_events_set_enabled(bool enable) <nl>  	int ret; <nl>   <nl>  	buffer = kzalloc(sizeof(struct calling_interface_buffer), GFP_KERNEL); <nl> +	if (!buffer) <nl> +		return -ENOMEM; <nl>  	buffer->cmd_class = CLASS_INFO; <nl>  	buffer->cmd_select = SELECT_APP_REGISTRATION; <nl>  	buffer->input[0] = 0x10000;
@@ -1340,7 +1340,7 @@ static int udf_load_logicalvol(struct super_block *sb, sector_t block, <nl>  	BUG_ON(ident != TAG_IDENT_LVD); <nl>  	lvd = (struct logicalVolDesc *)bh->b_data; <nl>  	table_len = le32_to_cpu(lvd->mapTableLength); <nl> -	if (sizeof(*lvd) + table_len > sb->s_blocksize) { <nl> +	if (table_len > sb->s_blocksize - sizeof(*lvd)) { <nl>  		udf_err(sb, "error loading logical volume descriptor: " <nl>  			"Partition table too long (%u > %lu)\n", table_len, <nl>  			sb->s_blocksize - sizeof(*lvd));
@@ -1940,11 +1940,17 @@ static inline unsigned long sock_wspace(struct sock *sk) <nl>   */ <nl>  static inline void sk_set_bit(int nr, struct sock *sk) <nl>  { <nl> +	if (nr == SOCKWQ_ASYNC_NOSPACE && !sock_flag(sk, SOCK_FASYNC)) <nl> +		return; <nl> + <nl>  	set_bit(nr, &sk->sk_wq_raw->flags); <nl>  } <nl>   <nl>  static inline void sk_clear_bit(int nr, struct sock *sk) <nl>  { <nl> +	if (nr == SOCKWQ_ASYNC_NOSPACE && !sock_flag(sk, SOCK_FASYNC)) <nl> +		return; <nl> + <nl>  	clear_bit(nr, &sk->sk_wq_raw->flags); <nl>  } <nl>  
@@ -345,7 +345,8 @@ mlxsw_sp_lpm_tree_get(struct mlxsw_sp *mlxsw_sp, <nl>   <nl>  	for (i = 0; i < MLXSW_SP_LPM_TREE_COUNT; i++) { <nl>  		lpm_tree = &mlxsw_sp->router.lpm_trees[i]; <nl> -		if (lpm_tree->proto == proto && <nl> +		if (lpm_tree->ref_count != 0 && <nl> +		    lpm_tree->proto == proto && <nl>  		    mlxsw_sp_prefix_usage_eq(&lpm_tree->prefix_usage, <nl>  					     prefix_usage)) <nl>  			goto inc_ref_count;
@@ -434,8 +434,8 @@ static void kvm_vcpu_init(struct kvm_vcpu *vcpu, struct kvm *kvm, unsigned id) <nl>   <nl>  static void kvm_vcpu_destroy(struct kvm_vcpu *vcpu) <nl>  { <nl> -	kvm_dirty_ring_free(&vcpu->dirty_ring); <nl>  	kvm_arch_vcpu_destroy(vcpu); <nl> +	kvm_dirty_ring_free(&vcpu->dirty_ring); <nl>   <nl>  	/* <nl>  	 * No need for rcu_read_lock as VCPU_RUN is the only place that changes
@@ -1827,7 +1827,12 @@ ieee80211_deliver_skb(struct ieee80211_rx_data *rx) <nl>  	} <nl>   <nl>  	if (xmit_skb) { <nl> -		/* send to wireless media */ <nl> +		/* <nl> +		 * Send to wireless media and increase priority by 256 to <nl> +		 * keep the received priority instead of reclassifying <nl> +		 * the frame (see cfg80211_classify8021d). <nl> +		 */ <nl> +		xmit_skb->priority += 256; <nl>  		xmit_skb->protocol = htons(ETH_P_802_3); <nl>  		skb_reset_network_header(xmit_skb); <nl>  		skb_reset_mac_header(xmit_skb);
@@ -30,7 +30,7 @@ MODULE_LICENSE("GPL v2"); <nl>   <nl>  static int debug; <nl>  module_param(debug, int, 0644); <nl> -MODULE_PARM_DESC(debug, "debug level 0=off(default) 1=on\n"); <nl> +MODULE_PARM_DESC(debug, "debug level 0=off(default) 1=on"); <nl>   <nl>  /* #define MPX_DEBUG */ <nl>  
@@ -1960,6 +1960,7 @@ static long bcm_char_ioctl(struct file *filp, UINT cmd, ULONG arg) <nl>   <nl>  		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, "Called IOCTL_BCM_GET_DEVICE_DRIVER_INFO\n"); <nl>   <nl> +		memset(&DevInfo, 0, sizeof(DevInfo)); <nl>  		DevInfo.MaxRDMBufferSize = BUFFER_4K; <nl>  		DevInfo.u32DSDStartOffset = EEPROM_CALPARAM_START; <nl>  		DevInfo.u32RxAlignmentCorrection = 0;
@@ -851,6 +851,9 @@ void cec_received_msg(struct cec_adapter *adap, struct cec_msg *msg) <nl>  	if (!valid_la || msg->len <= 1) <nl>  		return; <nl>   <nl> +	if (adap->log_addrs.log_addr_mask == 0) <nl> +		return; <nl> + <nl>  	/* <nl>  	 * Process the message on the protocol level. If is_reply is true, <nl>  	 * then cec_receive_notify() won't pass on the reply to the listener(s)
@@ -1232,9 +1232,10 @@ efi_initialize_iomem_resources(struct resource *code_resource, <nl>  				if (md->attribute & EFI_MEMORY_WP) { <nl>  					name = "System ROM"; <nl>  					flags |= IORESOURCE_READONLY; <nl> -				} else { <nl> +				} else if (md->attribute == EFI_MEMORY_UC) <nl> +					name = "Uncached RAM"; <nl> +				else <nl>  					name = "System RAM"; <nl> -				} <nl>  				break; <nl>   <nl>  			case EFI_ACPI_MEMORY_NVS:
@@ -150,8 +150,10 @@ static int get_task_ioprio(struct task_struct *p) <nl>  	if (ret) <nl>  		goto out; <nl>  	ret = IOPRIO_PRIO_VALUE(IOPRIO_CLASS_NONE, IOPRIO_NORM); <nl> +	task_lock(p); <nl>  	if (p->io_context) <nl>  		ret = p->io_context->ioprio; <nl> +	task_unlock(p); <nl>  out: <nl>  	return ret; <nl>  }
@@ -654,10 +654,6 @@ static int pcmciamtd_config(struct pcmcia_device *link) <nl>  	} <nl>  	dev_info(&dev->p_dev->dev, "mtd%d: %s\n", mtd->index, mtd->name); <nl>  	return 0; <nl> - <nl> -	dev_err(&dev->p_dev->dev, "CS Error, exiting\n"); <nl> -	pcmciamtd_release(link); <nl> -	return -ENODEV; <nl>  } <nl>   <nl>  
@@ -1166,6 +1166,14 @@ static struct task_struct *copy_process(unsigned long clone_flags, <nl>  				current->signal->flags & SIGNAL_UNKILLABLE) <nl>  		return ERR_PTR(-EINVAL); <nl>   <nl> +	/* <nl> +	 * If the new process will be in a different pid namespace <nl> +	 * don't allow the creation of threads. <nl> +	 */ <nl> +	if ((clone_flags & (CLONE_VM|CLONE_NEWPID)) && <nl> +	    (task_active_pid_ns(current) != current->nsproxy->pid_ns)) <nl> +		return ERR_PTR(-EINVAL); <nl> + <nl>  	retval = security_task_create(clone_flags); <nl>  	if (retval) <nl>  		goto fork_out;
@@ -3292,7 +3292,7 @@ static int gfx_v6_0_sw_init(void *handle) <nl>  		ring->me = 1; <nl>  		ring->pipe = i; <nl>  		ring->queue = i; <nl> -		sprintf(ring->name, "comp %d.%d.%d", ring->me, ring->pipe, ring->queue); <nl> +		sprintf(ring->name, "comp_%d.%d.%d", ring->me, ring->pipe, ring->queue); <nl>  		irq_type = AMDGPU_CP_IRQ_COMPUTE_MEC1_PIPE0_EOP + ring->pipe; <nl>  		r = amdgpu_ring_init(adev, ring, 1024, <nl>  				     &adev->gfx.eop_irq, irq_type);
@@ -31,6 +31,7 @@ extern void to_tm(int tim, struct rtc_time * tm); <nl>  extern void tick_broadcast_ipi_handler(void); <nl>   <nl>  extern void generic_calibrate_decr(void); <nl> +extern void hdec_interrupt(struct pt_regs *regs); <nl>   <nl>  /* Some sane defaults: 125 MHz timebase, 1GHz processor */ <nl>  extern unsigned long ppc_proc_freq;
@@ -379,12 +379,12 @@ static int special_clk_ctl_put(struct snd_kcontrol *kctl, <nl>  	struct special_params *params = bebob->maudio_special_quirk; <nl>  	int err, id; <nl>   <nl> -	mutex_lock(&bebob->mutex); <nl> - <nl>  	id = uval->value.enumerated.item[0]; <nl>  	if (id >= ARRAY_SIZE(special_clk_labels)) <nl>  		return 0; <nl>   <nl> +	mutex_lock(&bebob->mutex); <nl> + <nl>  	err = avc_maudio_set_special_clk(bebob, id, <nl>  					 params->dig_in_fmt, <nl>  					 params->dig_out_fmt,
@@ -893,6 +893,8 @@ static int falcon_mtd_probe(struct efx_nic *efx) <nl>   <nl>  	/* Allocate space for maximum number of partitions */ <nl>  	parts = kcalloc(2, sizeof(*parts), GFP_KERNEL); <nl> +	if (!parts) <nl> +		return -ENOMEM; <nl>  	n_parts = 0; <nl>   <nl>  	spi = &nic_data->spi_flash;
@@ -175,6 +175,7 @@ static int crypt_iv_essiv_ctr(struct crypt_config *cc, struct dm_target *ti, <nl>   <nl>  	if (err) { <nl>  		ti->error = "Error calculating hash in ESSIV"; <nl> +		kfree(salt); <nl>  		return err; <nl>  	} <nl>  
@@ -453,6 +453,7 @@ static int mt9t112_init_pll(const struct i2c_client *client) <nl>  	 * I2C Master Clock Divider <nl>  	 */ <nl>  	mt9t112_reg_write(ret, client, 0x0014, 0x3046); <nl> +	mt9t112_reg_write(ret, client, 0x0016, 0x0400); /* JPEG initialization workaround */ <nl>  	mt9t112_reg_write(ret, client, 0x0022, 0x0190); <nl>  	mt9t112_reg_write(ret, client, 0x3B84, 0x0212); <nl>  
@@ -42,14 +42,17 @@ static int udf_pc_to_char(struct super_block *sb, unsigned char *from, <nl>  	tolen--; <nl>  	while (elen < fromlen) { <nl>  		pc = (struct pathComponent *)(from + elen); <nl> +		elen += sizeof(struct pathComponent); <nl>  		switch (pc->componentType) { <nl>  		case 1: <nl>  			/* <nl>  			 * Symlink points to some place which should be agreed <nl>   			 * upon between originator and receiver of the media. Ignore. <nl>  			 */ <nl> -			if (pc->lengthComponentIdent > 0) <nl> +			if (pc->lengthComponentIdent > 0) { <nl> +				elen += pc->lengthComponentIdent; <nl>  				break; <nl> +			} <nl>  			/* Fall through */ <nl>  		case 2: <nl>  			if (tolen == 0) <nl> @@ -74,6 +77,9 @@ static int udf_pc_to_char(struct super_block *sb, unsigned char *from, <nl>  			/* that would be . - just ignore */ <nl>  			break; <nl>  		case 5: <nl> +			elen += pc->lengthComponentIdent; <nl> +			if (elen > fromlen) <nl> +				return -EIO; <nl>  			comp_len = udf_get_filename(sb, pc->componentIdent, <nl>  						    pc->lengthComponentIdent, <nl>  						    p, tolen); <nl> @@ -85,7 +91,6 @@ static int udf_pc_to_char(struct super_block *sb, unsigned char *from, <nl>  			tolen--; <nl>  			break; <nl>  		} <nl> -		elen += sizeof(struct pathComponent) + pc->lengthComponentIdent; <nl>  	} <nl>  	if (p > to + 1) <nl>  		p[-1] = '\0';
@@ -374,6 +374,7 @@ static int __br_mdb_add(struct net *net, struct net_bridge *br, <nl>  	if (!p || p->br != br || p->state == BR_STATE_DISABLED) <nl>  		return -EINVAL; <nl>   <nl> +	memset(&ip, 0, sizeof(ip)); <nl>  	ip.proto = entry->addr.proto; <nl>  	if (ip.proto == htons(ETH_P_IP)) <nl>  		ip.u.ip4 = entry->addr.u.ip4; <nl> @@ -420,6 +421,7 @@ static int __br_mdb_del(struct net_bridge *br, struct br_mdb_entry *entry) <nl>  	if (!netif_running(br->dev) || br->multicast_disabled) <nl>  		return -EINVAL; <nl>   <nl> +	memset(&ip, 0, sizeof(ip)); <nl>  	ip.proto = entry->addr.proto; <nl>  	if (ip.proto == htons(ETH_P_IP)) { <nl>  		if (timer_pending(&br->ip4_other_query.timer))
@@ -2302,7 +2302,7 @@ void task_tick_numa(struct rq *rq, struct task_struct *curr) <nl>  	now = curr->se.sum_exec_runtime; <nl>  	period = (u64)curr->numa_scan_period * NSEC_PER_MSEC; <nl>   <nl> -	if (now - curr->node_stamp > period) { <nl> +	if (now > curr->node_stamp + period) { <nl>  		if (!curr->node_stamp) <nl>  			curr->numa_scan_period = task_scan_min(curr); <nl>  		curr->node_stamp += period;
@@ -439,6 +439,8 @@ int asn1_ber_decoder(const struct asn1_decoder *decoder, <nl>  			else <nl>  				act = machine[pc + 1]; <nl>  			ret = actions[act](context, hdr, 0, data + tdp, len); <nl> +			if (ret < 0) <nl> +				return ret; <nl>  		} <nl>  		pc += asn1_op_lengths[op]; <nl>  		goto next_op;
@@ -176,7 +176,7 @@ int bdi_register(struct backing_dev_info *bdi, struct device *parent, <nl>  	int ret = 0; <nl>  	struct device *dev; <nl>   <nl> -	if (WARN_ON(bdi->dev)) <nl> +	if (bdi->dev)	/* The driver needs to use separate queues per device */ <nl>  		goto exit; <nl>   <nl>  	va_start(args, fmt);
@@ -326,10 +326,11 @@ static void oz_usb_handle_ep_data(struct oz_usb_ctx *usb_ctx, <nl>  			struct oz_multiple_fixed *body = <nl>  				(struct oz_multiple_fixed *)data_hdr; <nl>  			u8 *data = body->data; <nl> -			int n; <nl> -			if (!body->unit_size) <nl> +			unsigned int n; <nl> +			if (!body->unit_size || <nl> +				len < sizeof(struct oz_multiple_fixed) - 1) <nl>  				break; <nl> -			n = (len - sizeof(struct oz_multiple_fixed)+1) <nl> +			n = (len - (sizeof(struct oz_multiple_fixed) - 1)) <nl>  				/ body->unit_size; <nl>  			while (n--) { <nl>  				oz_hcd_data_ind(usb_ctx->hport, body->endpoint,
@@ -327,10 +327,10 @@ static ssize_t blk_msg_write(struct file *filp, const char __user *buffer, <nl>  	char *msg; <nl>  	struct blk_trace *bt; <nl>   <nl> -	if (count > BLK_TN_MAX_MSG) <nl> +	if (count > BLK_TN_MAX_MSG - 1) <nl>  		return -EINVAL; <nl>   <nl> -	msg = kmalloc(count, GFP_KERNEL); <nl> +	msg = kmalloc(count + 1, GFP_KERNEL); <nl>  	if (msg == NULL) <nl>  		return -ENOMEM; <nl>   <nl> @@ -339,6 +339,7 @@ static ssize_t blk_msg_write(struct file *filp, const char __user *buffer, <nl>  		return -EFAULT; <nl>  	} <nl>   <nl> +	msg[count] = '\0'; <nl>  	bt = filp->private_data; <nl>  	__trace_note_message(bt, "%s", msg); <nl>  	kfree(msg);
@@ -390,6 +390,8 @@ void ath10k_htt_tx_free(struct ath10k_htt *htt) <nl>  { <nl>  	int size; <nl>   <nl> +	tasklet_kill(&htt->txrx_compl_task); <nl> + <nl>  	idr_for_each(&htt->pending_tx, ath10k_htt_tx_clean_up_pending, htt->ar); <nl>  	idr_destroy(&htt->pending_tx); <nl>  
@@ -531,6 +531,7 @@ int __init igafb_init(void) <nl>  		iounmap(info->screen_base); <nl>  		kfree(par->mmap_map); <nl>  		kfree(info); <nl> +		return -ENODEV; <nl>          } <nl>   <nl>  #ifdef CONFIG_SPARC
@@ -54,6 +54,7 @@ struct clk_plt_data { <nl>  	struct clk_plt_fixed **parents; <nl>  	u8 nparents; <nl>  	struct clk_plt *clks[PMC_CLK_NUM]; <nl> +	struct clk_lookup *mclk_lookup; <nl>  }; <nl>   <nl>  /* Return an index in parent table */ <nl> @@ -337,6 +338,11 @@ static int plt_clk_probe(struct platform_device *pdev) <nl>  			goto err_unreg_clk_plt; <nl>  		} <nl>  	} <nl> +	data->mclk_lookup = clkdev_hw_create(&data->clks[3]->hw, "mclk", NULL); <nl> +	if (IS_ERR(data->mclk_lookup)) { <nl> +		err = PTR_ERR(data->mclk_lookup); <nl> +		goto err_unreg_clk_plt; <nl> +	} <nl>   <nl>  	plt_clk_free_parent_names_loop(parent_names, data->nparents); <nl>   <nl> @@ -356,6 +362,7 @@ static int plt_clk_remove(struct platform_device *pdev) <nl>   <nl>  	data = platform_get_drvdata(pdev); <nl>   <nl> +	clkdev_drop(data->mclk_lookup); <nl>  	plt_clk_unregister_loop(data, PMC_CLK_NUM); <nl>  	plt_clk_unregister_parents(data); <nl>  	return 0;
@@ -55,7 +55,7 @@ struct platform_device *__init imx_add_mxc_mmc( <nl>  	struct resource res[] = { <nl>  		{ <nl>  			.start = data->iobase, <nl> -			.end = data->iobase + SZ_4K - 1, <nl> +			.end = data->iobase + data->iosize - 1, <nl>  			.flags = IORESOURCE_MEM, <nl>  		}, { <nl>  			.start = data->irq,
@@ -794,7 +794,7 @@ xfrm_state_find(xfrm_address_t *daddr, xfrm_address_t *saddr, <nl>  { <nl>  	static xfrm_address_t saddr_wildcard = { }; <nl>  	struct net *net = xp_net(pol); <nl> -	unsigned int h; <nl> +	unsigned int h, h_wildcard; <nl>  	struct hlist_node *entry; <nl>  	struct xfrm_state *x, *x0, *to_put; <nl>  	int acquire_in_progress = 0; <nl> @@ -819,8 +819,8 @@ xfrm_state_find(xfrm_address_t *daddr, xfrm_address_t *saddr, <nl>  	if (best) <nl>  		goto found; <nl>   <nl> -	h = xfrm_dst_hash(net, daddr, &saddr_wildcard, tmpl->reqid, family); <nl> -	hlist_for_each_entry(x, entry, net->xfrm.state_bydst+h, bydst) { <nl> +	h_wildcard = xfrm_dst_hash(net, daddr, &saddr_wildcard, tmpl->reqid, family); <nl> +	hlist_for_each_entry(x, entry, net->xfrm.state_bydst+h_wildcard, bydst) { <nl>  		if (x->props.family == family && <nl>  		    x->props.reqid == tmpl->reqid && <nl>  		    !(x->props.flags & XFRM_STATE_WILDRECV) &&
@@ -931,6 +931,7 @@ static void __init_discard_policy(struct f2fs_sb_info *sbi, <nl>  		dpolicy->min_interval = DEF_MIN_DISCARD_ISSUE_TIME; <nl>  		dpolicy->max_interval = DEF_MAX_DISCARD_ISSUE_TIME; <nl>  		dpolicy->io_aware = true; <nl> +		dpolicy->sync = false; <nl>  		if (utilization(sbi) > DEF_DISCARD_URGENT_UTIL) { <nl>  			dpolicy->granularity = 1; <nl>  			dpolicy->max_interval = DEF_MIN_DISCARD_ISSUE_TIME;
@@ -423,6 +423,9 @@ bool Decoder::canSplitFunctionOn( <nl>  				continue; <nl>  			} <nl>  			auto up = fncStarts.upper_bound(bAddr); <nl> +			if (up == fncStarts.begin()) { <nl> +				return false; <nl> +			}	 <nl>  			--up; <nl>  			Address bFnc = *up; <nl>   <nl> @@ -442,6 +445,9 @@ bool Decoder::canSplitFunctionOn( <nl>  					continue; <nl>  				} <nl>  				auto up = fncStarts.upper_bound(pAddr); <nl> +				if (up == fncStarts.begin()) { <nl> +					return false; <nl> +				} <nl>  				--up; <nl>  				Address pFnc = *up; <nl>  
@@ -548,6 +548,7 @@ static void host_callback(void *arg, int status, int timeouts, <nl>    else if (status == ARES_EDESTRUCTION) <nl>      { <nl>        end_hquery(hquery, status); <nl> +      return; <nl>      } <nl>   <nl>    if (!hquery->remaining)
@@ -950,6 +950,7 @@ static cdk_error_t skip_packet(cdk_stream_t inp, size_t pktlen) <nl>  	return 0; <nl>  } <nl>   <nl> +#define MAX_PACKET_LEN (1<<24) <nl>   <nl>  /** <nl>   * cdk_pkt_read: <nl> @@ -1002,6 +1003,13 @@ cdk_error_t cdk_pkt_read(cdk_stream_t inp, cdk_packet_t pkt) <nl>  	else <nl>  		read_old_length(inp, ctb, &pktlen, &pktsize); <nl>   <nl> +	/* enforce limits to ensure that the following calculations <nl> +	 * do not overflow */ <nl> +	if (pktlen >= MAX_PACKET_LEN || pktsize >= MAX_PACKET_LEN) { <nl> +		_cdk_log_info("cdk_pkt_read: too long packet\n"); <nl> +		return gnutls_assert_val(CDK_Inv_Packet); <nl> +	} <nl> + <nl>  	pkt->pkttype = pkttype; <nl>  	pkt->pktlen = pktlen; <nl>  	pkt->pktsize = pktsize + pktlen; <nl> @@ -1026,6 +1034,7 @@ cdk_error_t cdk_pkt_read(cdk_stream_t inp, cdk_packet_t pkt) <nl>  		break; <nl>   <nl>  	case CDK_PKT_USER_ID: <nl> + <nl>  		pkt->pkt.user_id = cdk_calloc(1, sizeof *pkt->pkt.user_id <nl>  					      + pkt->pktlen + 1); <nl>  		if (!pkt->pkt.user_id)
@@ -318,11 +318,10 @@ KCleanup::expandVariables( const KFileInfo *	item, <nl>  			   const QString &	unexpanded ) const <nl>  { <nl>      QString expanded = unexpanded; <nl> - <nl> -    expanded.replace( QRegExp( "%p" ), <nl> -		      "'" + QString::fromLocal8Bit( item->url() )  + "'" ); <nl> -    expanded.replace( QRegExp( "%n" ), <nl> -		      "'" + QString::fromLocal8Bit( item->name() ) + "'" ); <nl> +    QString url = QString::fromLocal8Bit( item->url() ).replace("'", "'\\''"); <nl> +    expanded.replace( QRegExp( "%p" ), "'" + url + "'" ); <nl> +    QString name = QString::fromLocal8Bit( item->name() ).replace("'", "'\\''"); <nl> +    expanded.replace( QRegExp( "%n" ), "'" + name + "'" ); <nl>   <nl>     // if ( KDE::versionMajor() >= 3 && KDE::versionMinor() >= 4 ) <nl>  	expanded.replace( QRegExp( "%t" ), "trash:/" );
@@ -1618,7 +1618,9 @@ void fmtutil_macbitmap_read_pixmap_only_fields(deark *c, dbuf *f, struct fmtutil <nl>  	de_dbg(c, "pixel type=%d, bits/pixel=%d, components/pixel=%d, bits/comp=%d", <nl>  		(int)bi->pixeltype, (int)bi->pixelsize, (int)bi->cmpcount, (int)bi->cmpsize); <nl>   <nl> -	bi->pdwidth = (bi->rowbytes*8)/bi->pixelsize; <nl> +	if(bi->pixelsize>0) { <nl> +		bi->pdwidth = (bi->rowbytes*8)/bi->pixelsize; <nl> +	} <nl>  	if(bi->pdwidth < bi->npwidth) { <nl>  		bi->pdwidth = bi->npwidth; <nl>  	}
@@ -644,6 +644,12 @@ void *enc_untrusted_realloc(void *ptr, size_t size) { <nl>    if (!result && size != 0) { <nl>      errno = FromkLinuxErrorNumber(klinux_errno); <nl>    } <nl> + <nl> +  if (!::asylo::primitives::TrustedPrimitives::IsOutsideEnclave(result, size)) { <nl> +    ::asylo::primitives::TrustedPrimitives::BestEffortAbort( <nl> +        "enc_untrusted_realloc: realloc result should be in untrusted " <nl> +        "memory"); <nl> +  } <nl>    return result; <nl>  } <nl>  
@@ -1934,7 +1934,7 @@ static int prctl_set_vma_anon_name(unsigned long start, unsigned long end, <nl>  			tmp = end; <nl>   <nl>  		/* Here vma->vm_start <= start < tmp <= (end|vma->vm_end). */ <nl> -		error = prctl_update_vma_anon_name(vma, &prev, start, end, <nl> +		error = prctl_update_vma_anon_name(vma, &prev, start, tmp, <nl>  				(const char __user *)arg); <nl>  		if (error) <nl>  			return error;
@@ -399,6 +399,14 @@ void LanLinkProvider::newConnection() <nl>  void LanLinkProvider::dataReceived() <nl>  { <nl>      QSslSocket* socket = qobject_cast<QSslSocket*>(sender()); <nl> +    //the size here is arbitrary and is now at 8192 bytes. It needs to be considerably long as it includes the capabilities but there needs to be a limit <nl> +    //Tested between my systems and I get around 2000 per identity package. <nl> +    if (socket->bytesAvailable() > 8192) { <nl> +        qCWarning(KDECONNECT_CORE) << "LanLinkProvider/newConnection: Suspiciously long identity package received. Closing connection." << socket->peerAddress() << socket->bytesAvailable(); <nl> +        socket->disconnectFromHost(); <nl> +        return; <nl> +    } <nl> + <nl>  #if QT_VERSION < QT_VERSION_CHECK(5,7,0) <nl>      if (!socket->canReadLine()) <nl>          return;
@@ -15,6 +15,9 @@ namespace ivm { <nl>   * RAII wrapper around libuv dlopen <nl>   */ <nl>  NativeModule::NativeModule(const std::string& filename) : init(nullptr) { <nl> +	if (!IsolateEnvironment::GetCurrent()->IsDefault()) { <nl> +		throw RuntimeGenericError("NativeModule may only be instantiated from default nodejs isolate"); <nl> +	} <nl>  	if (uv_dlopen(filename.c_str(), &lib) != 0) { <nl>  		throw RuntimeGenericError("Failed to load module"); <nl>  	}
@@ -857,7 +857,7 @@ static int decode_font(ASS_Track *track) <nl>          ass_msg(track->library, MSGL_ERR, "Bad encoded data size"); <nl>          goto error_decode_font; <nl>      } <nl> -    buf = malloc(size / 4 * 3 + FFMAX(size % 4 - 1, 0)); <nl> +    buf = malloc(size / 4 * 3 + FFMAX(size % 4, 1) - 1); <nl>      if (!buf) <nl>          goto error_decode_font; <nl>      q = buf; <nl> @@ -871,7 +871,7 @@ static int decode_font(ASS_Track *track) <nl>          q = decode_chars(p, q, 3); <nl>      } <nl>      dsize = q - buf; <nl> -    assert(dsize == size / 4 * 3 + FFMAX(size % 4 - 1, 0)); <nl> +    assert(dsize == size / 4 * 3 + FFMAX(size % 4, 1) - 1); <nl>   <nl>      if (track->library->extract_fonts) { <nl>          ass_add_font(track->library, track->parser_priv->fontname,
@@ -320,7 +320,7 @@ static int shm_create(XShmSegmentInfo *shm, XImage **ximg_ptr, int w, int h, <nl>   <nl>  #if HAVE_XSHM <nl>  	shm->shmid = shmget(IPC_PRIVATE, <nl> -	    xim->bytes_per_line * xim->height, IPC_CREAT | 0777); <nl> +	    xim->bytes_per_line * xim->height, IPC_CREAT | 0600); <nl>   <nl>  	if (shm->shmid == -1) { <nl>  		rfbErr("shmget(%s) failed.\n", name);
@@ -883,7 +883,7 @@ bit_write_MC (Bit_Chain *dat, BITCODE_MC val) <nl>      if (byte[i] & 0x7f) <nl>        break; <nl>   <nl> -  if (byte[i] & 0x40) <nl> +  if (byte[i] & 0x40 && i > 0) <nl>      i--; <nl>    byte[i] &= 0x7f; <nl>    if (negative) <nl> @@ -953,7 +953,7 @@ bit_write_UMC (Bit_Chain *dat, BITCODE_UMC val) <nl>      if (byte[i] & 0x7f) <nl>        break; <nl>   <nl> -  if (byte[i] & 0x40) <nl> +  if (byte[i] & 0x40 && i > 0) <nl>      i--; <nl>    byte[i] &= 0x7f; <nl>    for (j = 4; j >= i; j--)
@@ -258,7 +258,7 @@ writefile(const char *name, struct string *s) <nl>  		return -1; <nl>  	} <nl>  	ret = 0; <nl> -	if (fwrite(s->s, 1, s->n, f) != s->n || fflush(f) != 0) { <nl> +	if (s && (fwrite(s->s, 1, s->n, f) != s->n || fflush(f) != 0)) { <nl>  		warn("write %s:", name); <nl>  		ret = -1; <nl>  	}
@@ -304,6 +304,7 @@ const char *			/* O - File extension */ <nl>  file_extension(const char *s)	/* I - Filename or URL */ <nl>  { <nl>    const char	*extension;	/* Pointer to directory separator */ <nl> +  char		*bufptr;	/* Pointer into buffer */ <nl>    static char	buf[1024];	/* Buffer for files with targets */ <nl>   <nl>   <nl> @@ -334,7 +335,8 @@ file_extension(const char *s)	/* I - Filename or URL */ <nl>   <nl>    strlcpy(buf, extension, sizeof(buf)); <nl>   <nl> -  *(char *)strchr(buf, '#') = '\0'; <nl> +  if ((bufptr = strchr(buf, '#')) != NULL) <nl> +    *bufptr = '\0'; <nl>   <nl>    return (buf); <nl>  }
@@ -969,6 +969,13 @@ static void cmd_parse_status (IMAP_DATA* idata, char* s) <nl>        idata->status = IMAP_FATAL; <nl>        return; <nl>      } <nl> + <nl> +    if (strlen(idata->buf) < litlen) <nl> +    { <nl> +      dprint (1, (debugfile, "Error parsing STATUS mailbox\n")); <nl> +      return; <nl> +    } <nl> + <nl>      mailbox = idata->buf; <nl>      s = mailbox + litlen; <nl>      *s = '\0';
@@ -586,7 +586,7 @@ static int cmd_handle_untagged (IMAP_DATA* idata) <nl>      dprint (2, (debugfile, "Handling untagged NO\n")); <nl>   <nl>      /* Display the warning message from the server */ <nl> -    mutt_error ("%s", s+3); <nl> +    mutt_error ("%s", s+2); <nl>      mutt_sleep (2); <nl>    } <nl>  
@@ -720,11 +720,11 @@ static bool checkreturn decode_pointer_field(pb_istream_t *stream, pb_wire_type_ <nl>                  if (!check_wire_type(wire_type, field)) <nl>                      PB_RETURN_ERROR(stream, "wrong wire type"); <nl>   <nl> -                (*size)++; <nl> -                if (!allocate_field(stream, field->pField, field->data_size, *size)) <nl> +                if (!allocate_field(stream, field->pField, field->data_size, (size_t)(*size + 1))) <nl>                      return false; <nl>               <nl> -                field->pData = *(char**)field->pField + field->data_size * (*size - 1); <nl> +                field->pData = *(char**)field->pField + field->data_size * (*size); <nl> +                (*size)++; <nl>                  initialize_pointer_field(field->pData, field); <nl>                  return decode_basic_field(stream, field); <nl>              }
@@ -112,6 +112,7 @@ static int cbor2json (OSCTXT* pCborCtxt, OSCTXT* pJsonCtxt) <nl>     case OSRTCBOR_UTF8STR: { <nl>        OSUTF8CHAR* utf8str; <nl>        ret = rtCborDecDynUTF8Str (pCborCtxt, ub, (char**)&utf8str); <nl> +      if (0 != ret) return LOG_RTERR (pCborCtxt, ret); <nl>   <nl>        ret = rtJsonEncStringValue (pJsonCtxt, utf8str); <nl>        rtxMemFreePtr (pCborCtxt, utf8str);
@@ -370,7 +370,7 @@ int update_timestamp(const char *key, const struct efi_time *timestamp, char *la <nl>  static uint64_t unpack_timestamp(const struct efi_time *timestamp) <nl>  { <nl>  	uint64_t val = 0; <nl> -	uint16_t year = le32_to_cpu(timestamp->year); <nl> +	uint16_t year = le16_to_cpu(timestamp->year); <nl>   <nl>  	/* pad1, nanosecond, timezone, daylight and pad2 are meant to be zero */ <nl>  	val |= ((uint64_t) timestamp->pad1 & 0xFF) << 0;
@@ -4803,6 +4803,7 @@ int StreamTcpPacket (ThreadVars *tv, Packet *p, StreamTcpThread *stt, <nl>      /* broken TCP http://ask.wireshark.org/questions/3183/acknowledgment-number-broken-tcp-the-acknowledge-field-is-nonzero-while-the-ack-flag-is-not-set */ <nl>      if (!(p->tcph->th_flags & TH_ACK) && TCP_GET_ACK(p) != 0) { <nl>          StreamTcpSetEvent(p, STREAM_PKT_BROKEN_ACK); <nl> +        goto error; <nl>      } <nl>   <nl>      /* If we are on IPS mode, and got a drop action triggered from <nl> @@ -6929,7 +6930,7 @@ static int StreamTcpTest10 (void) <nl>   <nl>      tcph.th_win = htons(5480); <nl>      tcph.th_seq = htonl(10); <nl> -    tcph.th_ack = htonl(11); <nl> +    tcph.th_ack = 0; <nl>      tcph.th_flags = TH_SYN; <nl>      p->tcph = &tcph; <nl>  
@@ -444,8 +444,8 @@ int PasswdMgr::updatePasswdSpecialFile(const std::string& userName, <nl>          return -EIO; <nl>      } <nl>   <nl> -    // Set the file mode as of actual ipmi-pass file. <nl> -    if (fchmod(fileno((temp)()), st.st_mode) < 0) <nl> +    // Set the file mode as read-write for owner only <nl> +    if (fchmod(fileno((temp)()), S_IRUSR | S_IWUSR) < 0) <nl>      { <nl>          log<level::DEBUG>("Error setting fchmod for temp file"); <nl>          return -EIO;
@@ -1483,7 +1483,7 @@ static const unsigned char *parse_object(cJSON *item, const unsigned char *value <nl>  fail: <nl>      if (item->child != NULL) <nl>      { <nl> -        cJSON_Delete(child); <nl> +        cJSON_Delete(item->child); <nl>          item->child = NULL; <nl>      } <nl>  
@@ -7489,7 +7489,7 @@ while (*cc != XCL_END) <nl>      { <nl>      SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP); <nl>      cc++; <nl> -    if (*cc == PT_CLIST && *cc == XCL_PROP) <nl> +    if (*cc == PT_CLIST && cc[-1] == XCL_PROP) <nl>        { <nl>        other_cases = PRIV(ucd_caseless_sets) + cc[1]; <nl>        while (*other_cases != NOTACHAR)
@@ -1739,6 +1739,7 @@ FLAC__bool read_metadata_vorbiscomment_(FLAC__StreamDecoder *decoder, FLAC__Stre <nl>  		if (obj->num_comments > 0) { <nl>  			if (0 == (obj->comments = safe_malloc_mul_2op_p(obj->num_comments, /*times*/sizeof(FLAC__StreamMetadata_VorbisComment_Entry)))) { <nl>  				decoder->protected_->state = FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR; <nl> +				obj->num_comments = 0; <nl>  				return false; <nl>  			} <nl>  			for (i = 0; i < obj->num_comments; i++) {
@@ -54,6 +54,7 @@ PJ_DEF(pj_status_t) pjstun_parse_msg( void *buf, pj_size_t buf_len, <nl>  { <nl>      pj_uint16_t msg_type, msg_len; <nl>      char *p_attr; <nl> +    int attr_max_cnt = PJ_ARRAY_SIZE(msg->attr); <nl>   <nl>      PJ_CHECK_STACK(); <nl>   <nl> @@ -83,7 +84,7 @@ PJ_DEF(pj_status_t) pjstun_parse_msg( void *buf, pj_size_t buf_len, <nl>      msg->attr_count = 0; <nl>      p_attr = (char*)buf + sizeof(pjstun_msg_hdr); <nl>   <nl> -    while (msg_len > 0) { <nl> +    while (msg_len > 0 && msg->attr_count < attr_max_cnt) { <nl>  	pjstun_attr_hdr **attr = &msg->attr[msg->attr_count]; <nl>  	pj_uint32_t len; <nl>  	pj_uint16_t attr_type; <nl> @@ -111,6 +112,10 @@ PJ_DEF(pj_status_t) pjstun_parse_msg( void *buf, pj_size_t buf_len, <nl>  	p_attr += len; <nl>  	++msg->attr_count; <nl>      } <nl> +    if (msg->attr_count == attr_max_cnt) { <nl> +	PJ_LOG(4, (THIS_FILE, "Warning: max number attribute %d reached.", <nl> +		   attr_max_cnt)); <nl> +    } <nl>   <nl>      return PJ_SUCCESS; <nl>  }
@@ -510,6 +510,12 @@ IMPEG2D_ERROR_CODES_T impeg2d_dec_p_b_slice(dec_state_t *ps_dec) <nl>   <nl>          if(ret) <nl>              return IMPEG2D_MB_TEX_DECODE_ERR; <nl> + <nl> +        if(0 >= ps_dec->u2_num_mbs_left) <nl> +        { <nl> +            break; <nl> +        } <nl> + <nl>          IMPEG2D_TRACE_MB_START(ps_dec->u2_mb_x, ps_dec->u2_mb_y); <nl>   <nl>          u4_x_dst_offset = u4_frm_offset + (ps_dec->u2_mb_x << 4);
@@ -628,6 +628,7 @@ WORD32 ihevcd_decode(iv_obj_t *ps_codec_obj, void *pv_api_ip, void *pv_api_op) <nl>   <nl>          if(IHEVCD_IGNORE_SLICE == ret) <nl>          { <nl> +            ps_codec->s_parse.i4_cur_slice_idx = MAX(0, (ps_codec->s_parse.i4_cur_slice_idx - 1)); <nl>              ps_codec->pu1_inp_bitsbuf += (nal_ofst + nal_len); <nl>              ps_codec->i4_bytes_remaining -= (nal_ofst + nal_len); <nl>  
@@ -8130,6 +8130,14 @@ xmlParsePEReference(xmlParserCtxtPtr ctxt) <nl>  	    if (xmlPushInput(ctxt, input) < 0) <nl>  		return; <nl>  	} else { <nl> +	    if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) && <nl> +	        ((ctxt->options & XML_PARSE_NOENT) == 0) && <nl> +	        ((ctxt->options & XML_PARSE_DTDVALID) == 0) && <nl> +	        ((ctxt->options & XML_PARSE_DTDLOAD) == 0) && <nl> +	        ((ctxt->options & XML_PARSE_DTDATTR) == 0) && <nl> +	        (ctxt->replaceEntities == 0) && <nl> +	        (ctxt->validate == 0)) <nl> +	        return; <nl>  	    /* <nl>  	     * TODO !!! <nl>  	     * handle the extra spaces added before and after
@@ -318,7 +318,7 @@ long ParseElementHeader(IMkvReader* pReader, long long& pos, <nl>   <nl>    // pos now designates payload <nl>   <nl> -  if (stop >= 0 && pos >= stop) <nl> +  if (stop >= 0 && pos > stop) <nl>      return E_FILE_FORMAT_INVALID; <nl>   <nl>    return 0;  // success
@@ -411,7 +411,7 @@ status_t Parcel::appendFrom(const Parcel *parcel, size_t offset, size_t len) <nl>      // Count objects in range <nl>      for (int i = 0; i < (int) size; i++) { <nl>          size_t off = objects[i]; <nl> -        if ((off >= offset) && (off < offset + len)) { <nl> +        if ((off >= offset) && (off + sizeof(flat_binder_object) <= offset + len)) { <nl>              if (firstIndex == -1) { <nl>                  firstIndex = i; <nl>              }
@@ -237,7 +237,8 @@ void unmarshallAudioAttributes(const Parcel& parcel, audio_attributes_t *attribu <nl>              // copying array size -1, array for tags was calloc'd, no need to NULL-terminate it <nl>              size_t tagSize = realTagSize > AUDIO_ATTRIBUTES_TAGS_MAX_SIZE - 1 ? <nl>                      AUDIO_ATTRIBUTES_TAGS_MAX_SIZE - 1 : realTagSize; <nl> -            utf16_to_utf8(tags.string(), tagSize, attributes->tags); <nl> +            utf16_to_utf8(tags.string(), tagSize, attributes->tags, <nl> +                    sizeof(attributes->tags) / sizeof(attributes->tags[0])); <nl>          } <nl>      } else { <nl>          ALOGE("unmarshallAudioAttributes() received unflattened tags, ignoring tag values");
@@ -231,6 +231,7 @@ sp<IMemory> MetadataRetrieverClient::getFrameAtTime(int64_t timeUs, int option) <nl>      ALOGV("rotation: %d", frameCopy->mRotationAngle); <nl>      frameCopy->mData = (uint8_t *)frameCopy + sizeof(VideoFrame); <nl>      memcpy(frameCopy->mData, frame->mData, frame->mSize); <nl> +    frameCopy->mData = 0; <nl>      delete frame;  // Fix memory leakage <nl>      return mThumbnail; <nl>  }
@@ -561,7 +561,7 @@ status_t SampleTable::setSyncSampleParams(off64_t data_offset, size_t data_size) <nl>   <nl>      if (mDataSource->readAt(data_offset + 8, mSyncSamples, <nl>              (size_t)allocSize) != (ssize_t)allocSize) { <nl> -        delete mSyncSamples; <nl> +        delete[] mSyncSamples; <nl>          mSyncSamples = NULL; <nl>          return ERROR_IO; <nl>      } <nl> @@ -987,4 +987,3 @@ int32_t SampleTable::getCompositionTimeOffset(uint32_t sampleIndex) { <nl>  } <nl>   <nl>  }  // namespace android <nl> -
@@ -811,7 +811,13 @@ AMediaCodecCryptoInfo *AMediaCodecCryptoInfo_new( <nl>          size_t *encryptedbytes) { <nl>   <nl>      // size needed to store all the crypto data <nl> -    size_t cryptosize = sizeof(AMediaCodecCryptoInfo) + sizeof(size_t) * numsubsamples * 2; <nl> +    size_t cryptosize; <nl> +    // = sizeof(AMediaCodecCryptoInfo) + sizeof(size_t) * numsubsamples * 2; <nl> +    if (__builtin_mul_overflow(sizeof(size_t) * 2, numsubsamples, &cryptosize) || <nl> +            __builtin_add_overflow(cryptosize, sizeof(AMediaCodecCryptoInfo), &cryptosize)) { <nl> +        ALOGE("crypto size overflow"); <nl> +        return NULL; <nl> +    } <nl>      AMediaCodecCryptoInfo *ret = (AMediaCodecCryptoInfo*) malloc(cryptosize); <nl>      if (!ret) { <nl>          ALOGE("couldn't allocate %zu bytes", cryptosize);
@@ -81,6 +81,10 @@ static DexString *dex_string_new(RzBuffer *buf, ut64 offset, st64 *pread) { <nl>  	DexString *string = NULL; <nl>   <nl>  	read = rz_buf_uleb128(buf, &size); <nl> +	if (UT64_ADD_OVFCHK(size, 1)) { <nl> +		return NULL; <nl> +	} <nl> + <nl>  	data = malloc(size + 1); <nl>  	if (!data || rz_buf_read(buf, (ut8 *)data, size) != size) { <nl>  		free(data); <nl> @@ -905,7 +909,9 @@ static char *dex_resolve_library(const char *library) { <nl>  	} <nl>  	char *demangled = strdup(library + 1); <nl>  	rz_str_replace_ch(demangled, '/', '.', 1); <nl> -	demangled[strlen(demangled) - 1] = 0; <nl> +	if (RZ_STR_ISNOTEMPTY(demangled)) { <nl> +		demangled[strlen(demangled) - 1] = 0; <nl> +	} <nl>  	return demangled; <nl>  } <nl>  
@@ -18,6 +18,7 @@ <nl>  #include <init.h> <nl>  #include <stdlib.h> <nl>  #include <globalvar.h> <nl> +#include <crypto.h> <nl>  #include <generated/passwd.h> <nl>  #include <crypto/pbkdf2.h> <nl>   <nl> @@ -311,7 +312,7 @@ static int check_passwd(unsigned char *passwd, size_t length) <nl>  		if (ret) <nl>  			goto err; <nl>   <nl> -		if (strncmp(passwd1_sum, key, keylen) == 0) <nl> +		if (!crypto_memneq(passwd1_sum, key, keylen)) <nl>  			ret = 1; <nl>  	} else { <nl>  		ret = digest_digest(d, passwd, length, passwd1_sum); <nl> @@ -319,7 +320,7 @@ static int check_passwd(unsigned char *passwd, size_t length) <nl>  		if (ret) <nl>  			goto err; <nl>   <nl> -		if (strncmp(passwd1_sum, passwd2_sum, hash_len) == 0) <nl> +		if (!crypto_memneq(passwd1_sum, passwd2_sum, hash_len)) <nl>  			ret = 1; <nl>  	} <nl>  
@@ -183,7 +183,8 @@ String UTF8Decoder::to_utf8(const StringView& input) <nl>  String UTF16BEDecoder::to_utf8(const StringView& input) <nl>  { <nl>      StringBuilder builder(input.length() / 2); <nl> -    for (size_t i = 0; i < input.length(); i += 2) { <nl> +    size_t utf16_length = input.length() - (input.length() % 2); <nl> +    for (size_t i = 0; i < utf16_length; i += 2) { <nl>          u16 code_point = (input[i] << 8) | input[i + 1]; <nl>          builder.append_code_point(code_point); <nl>      }
@@ -40,6 +40,12 @@ NAN_METHOD(DetectCharacterEncoding) { <nl>  		return; <nl>  	} <nl>   <nl> +	if(charsetMatch == NULL) { <nl> +		info.GetReturnValue().Set(Nan::Null()); <nl> +		ucsdet_close(charsetDetector); <nl> +		return; <nl> +	} <nl> + <nl>  	const char *charsetName = ucsdet_getName(charsetMatch, &errorCode); <nl>   <nl>  	if(U_FAILURE(errorCode)) {
@@ -1465,7 +1465,7 @@ static int r_cmd_java_call(void *user, const char *input) { <nl>  	if (input[4] != ' ') { <nl>  		return r_cmd_java_handle_help (core, input); <nl>  	} <nl> -	for (; i < END_CMDS; i++) { <nl> +	for (; i < END_CMDS - 1; i++) { <nl>  		//IFDBG r_cons_printf ("Checking cmd: %s %d %s\n", JAVA_CMDS[i].name, JAVA_CMDS[i].name_len, p); <nl>  		IFDBG r_cons_printf ("Checking cmd: %s %d\n", JAVA_CMDS[i].name, <nl>  			strncmp (input+5, JAVA_CMDS[i].name, JAVA_CMDS[i].name_len));
@@ -1015,7 +1015,7 @@ static const char *arg(RAnal *a, csh *handle, cs_insn *insn, char *buf, int n) { <nl>   <nl>  #define VEC64(n) insn->detail->arm64.operands[n].vess <nl>  #define VEC64_APPEND(sb, n, i) vector64_append(sb, handle, insn, n, i) <nl> -#define VEC64_MASK(sh, sz) (bitmask_by_width[63]^(bitmask_by_width[sz-1]<<sh)) <nl> +#define VEC64_MASK(sh, sz) (bitmask_by_width[63]^(bitmask_by_width[sz>0?sz-1:0]<<sh)) <nl>   <nl>  static void vector64_append(RStrBuf *sb, csh *handle, cs_insn *insn, int n, int i) { <nl>  	cs_arm64_op op = INSOP64 (n); <nl> @@ -1079,7 +1079,6 @@ static void vector64_dst_append(RStrBuf *sb, csh *handle, cs_insn *insn, int n, <nl>  			shift -= 64; <nl>  			regc = "h"; <nl>  		} <nl> - <nl>  		if (shift > 0 && shift < 64) { <nl>  			r_strbuf_appendf (sb, "%d,SWAP,0x%"PFMT64x",&,<<,%s%s,0x%"PFMT64x",&,|,%s%s", <nl>  				shift, mask, REG64 (n), regc, VEC64_MASK (shift, size), REG64 (n), regc);
@@ -1,4 +1,4 @@ <nl> -/* radare - LGPL - Copyright 2009-2019 - pancake */ <nl> +/* radare - LGPL - Copyright 2009-2021 - pancake */ <nl>   <nl>  #include <r_types.h> <nl>  #include <r_util.h> <nl> @@ -771,7 +771,10 @@ static void rebase_buffer(struct MACH0_(obj_t) *obj, ut64 off, RIODesc *fd, ut8 <nl>  		if (!obj->chained_starts[i]) { <nl>  			continue; <nl>  		} <nl> -		ut64 page_size = obj->chained_starts[i]->page_size; <nl> +		int page_size = obj->chained_starts[i]->page_size; <nl> +		if (page_size < 1) { <nl> +			page_size = 4096; <nl> +		} <nl>  		ut64 start = obj->segs[i].fileoff; <nl>  		ut64 end = start + obj->segs[i].filesize; <nl>  		if (end >= off && start <= eob) {
@@ -1043,7 +1043,7 @@ ngx_http_auth_spnego_handler( <nl>              /* If basic auth is enabled and basic creds are supplied <nl>               * attempt basic auth.  If we attempt basic auth, we do <nl>               * not fall through to real SPNEGO */ <nl> -            if (NGX_DECLINED == ngx_http_auth_spnego_basic(r, ctx, alcf)) { <nl> +            if (NGX_OK != ngx_http_auth_spnego_basic(r, ctx, alcf)) { <nl>                  spnego_debug0("Basic auth failed"); <nl>                  if (NGX_ERROR == ngx_http_auth_spnego_headers_basic_only(r, ctx, alcf)) { <nl>                      spnego_debug0("Error setting headers");
@@ -2809,6 +2809,7 @@ static int multiSelect( <nl>      } <nl>    #endif <nl>    } <nl> +  if( pParse->nErr ) goto multi_select_end; <nl>     <nl>    /* Compute collating sequences used by  <nl>    ** temporary tables needed to implement the compound select.
@@ -441,7 +441,7 @@ static void handle_PORT(ctrl_t *ctrl, char *str) <nl>   <nl>  	/* Convert PORT command's argument to IP address + port */ <nl>  	sscanf(str, "%d,%d,%d,%d,%d,%d", &a, &b, &c, &d, &e, &f); <nl> -	sprintf(addr, "%d.%d.%d.%d", a, b, c, d); <nl> +	snprintf(addr, sizeof(addr), "%d.%d.%d.%d", a, b, c, d); <nl>   <nl>  	/* Check IPv4 address using inet_aton(), throw away converted result */ <nl>  	if (!inet_aton(addr, &(sin.sin_addr))) {
@@ -840,9 +840,9 @@ void CConnectionTransportUDPBase::Received_Data( const uint8 *pPkt, int cbPkt, S <nl>  			ReportBadUDPPacketFromConnectionPeer( "DataPacket", "Failed to varint decode size of stats blob" ); <nl>  			return; <nl>  		} <nl> -		if ( pIn + cbStatsMsgIn > pPktEnd ) <nl> +		if ( cbStatsMsgIn > pPktEnd - pIn ) <nl>  		{ <nl> -			ReportBadUDPPacketFromConnectionPeer( "DataPacket", "stats message size doesn't make sense.  Stats message size %d, packet size %d", cbStatsMsgIn, cbPkt ); <nl> +			ReportBadUDPPacketFromConnectionPeer( "DataPacket", "stats message size doesn't make sense.  Stats message size %u, packet size %d", cbStatsMsgIn, cbPkt ); <nl>  			return; <nl>  		} <nl>  
@@ -1548,6 +1548,10 @@ static block_t *Encode( encoder_t *p_enc, picture_t *p_pic ) <nl>                       * is appended to the sequence header to allow guard <nl>                       * against poor streaming servers */ <nl>                      /* XXX, should this be done using the packetizer ? */ <nl> + <nl> +                    if( len > UINT32_MAX - sizeof( eos ) ) <nl> +                        return NULL; <nl> + <nl>                      p_enc->fmt_out.p_extra = malloc( len + sizeof( eos ) ); <nl>                      if( !p_enc->fmt_out.p_extra ) <nl>                          return NULL;
@@ -1588,7 +1588,7 @@ void APar_Print_TrackDetails(TrackInfo *track_info) { <nl>  } <nl>   <nl>  void APar_ExtractDetails(FILE *isofile, uint8_t optional_output) { <nl> -  char uint32_buffer[5]; <nl> +  char uint32_buffer[8]; <nl>    Trackage track = {0}; <nl>   <nl>    AtomicInfo *mvhdAtom = APar_FindAtom("moov.mvhd", false, VERSIONED_ATOM, 0);
@@ -188,6 +188,14 @@ void blog_index(void) { <nl>  } <nl>   <nl>  void blog_post(char post_path[]) { <nl> +	if(strlen(post_path) != 0 || post_path[0] == '.' <nl> +			|| strchr(post_path, '/') == NULL) { <nl> +		send_header("Content-type", "text/plain"); <nl> +		terminate_headers(); <nl> +		printf("No, my dear h4xxx0r :)\nYou won\'t do that :p\n"); <nl> +		return; <nl> +	} <nl> + <nl>  	if(file_exists(post_path) > 0) { <nl>  		struct blogpost post = make_blogpost(post_path); <nl>  
@@ -40,6 +40,8 @@ void TableLookUp::setTable(int ntable, const std::vector<ushort16>& table) { <nl>    assert(!table.empty()); <nl>   <nl>    const int nfilled = table.size(); <nl> +  if (nfilled >= 65536) <nl> +    ThrowRDE("Table lookup with %i entries is unsupported", nfilled); <nl>   <nl>    if (ntable > ntables) { <nl>      ThrowRDE("Table lookup with number greater than number of tables.");
@@ -3240,13 +3240,8 @@ void MainWindow::showUpgradePrompt() <nl>  { <nl>      if (Settings.checkUpgradeAutomatic()) { <nl>          showStatusMessage("Checking for upgrade..."); <nl> -        QNetworkRequest request(QUrl("https://check.shotcut.org/version.json")); <nl> -        QSslConfiguration sslConfig = request.sslConfiguration(); <nl> -        sslConfig.setPeerVerifyMode(QSslSocket::VerifyNone); <nl> -        request.setSslConfiguration(sslConfig); <nl> -        m_network.get(request); <nl> +        m_network.get(QNetworkRequest(QUrl("https://check.shotcut.org/version.json"))); <nl>      } else { <nl> -        m_network.setStrictTransportSecurityEnabled(false); <nl>          QAction* action = new QAction(tr("Click here to check for a new version of Shotcut."), 0); <nl>          connect(action, SIGNAL(triggered(bool)), SLOT(on_actionUpgrade_triggered())); <nl>          showStatusMessage(action, 15 /* seconds */); <nl> @@ -3702,7 +3697,7 @@ void MainWindow::on_actionUpgrade_triggered() <nl>              Settings.setAskUpgradeAutomatic(false); <nl>      } <nl>      showStatusMessage("Checking for upgrade..."); <nl> -    m_network.get(QNetworkRequest(QUrl("http://check.shotcut.org/version.json"))); <nl> +    m_network.get(QNetworkRequest(QUrl("https://check.shotcut.org/version.json"))); <nl>  } <nl>   <nl>  void MainWindow::on_actionOpenXML_triggered()
@@ -527,6 +527,8 @@ class MapStageOp : public OpKernel { <nl>      OP_REQUIRES_OK(ctx, ctx->input("key", &key_tensor)); <nl>      OP_REQUIRES_OK(ctx, ctx->input("indices", &indices_tensor)); <nl>      OP_REQUIRES_OK(ctx, ctx->input_list("values", &values_tensor)); <nl> +    OP_REQUIRES(ctx, key_tensor->NumElements() > 0, <nl> +                errors::InvalidArgument("key must not be empty")); <nl>   <nl>      // Create copy for insertion into Staging Area <nl>      Tensor key(*key_tensor);
@@ -68,6 +68,9 @@ constexpr char kRelu6[] = "RELU6"; <nl>  constexpr char kRelu1[] = "RELU_N1_TO_1"; <nl>   <nl>  bool L2NormalizeReduceAxis(Value sq_op, DenseElementsAttr axis) { <nl> +  if (axis.getNumElements() == 0) { <nl> +    return false; <nl> +  } <nl>    if (sq_op.getType().cast<ShapedType>().getRank() - 1 == <nl>            *axis.getValues<int>().begin() || <nl>        *axis.getValues<int>().begin() == -1) {
@@ -53,6 +53,14 @@ class UnravelIndexOp : public OpKernel { <nl>                                  dims_tensor.shape().DebugString(), "\"")); <nl>   <nl>      auto dims = dims_tensor.vec<Tidx>(); <nl> +    // Make sure dims does not contain a zero <nl> +    for (int i = 0; i < dims.size(); i++) { <nl> +      OP_REQUIRES( <nl> +          ctx, dims(i) != 0, <nl> +          errors::InvalidArgument("Input dims cannot contain a dim of zero, " <nl> +                                  "but dims contains zero at index ", <nl> +                                  i)); <nl> +    } <nl>   <nl>      // Chek to make sure indices is not out of boundary <nl>      Eigen::Tensor<Tidx, 0, Eigen::RowMajor> dims_prod_eigen = dims.prod();
@@ -746,6 +746,9 @@ StatusOr<unsigned> GraphDefImporter::ArgNumType(const NamedAttrList &attrs, <nl>  Status GraphDefImporter::ConvertNodeDef(OpBuilder &builder, ConversionState &s, <nl>                                          const NodeDef &node) { <nl>    VLOG(4) << "Importing: " << node.name(); <nl> +  if (node.op().empty()) <nl> +    return InvalidArgument("Node ", node.name(), " has an empty op name"); <nl> + <nl>    OperationState state(ConvertLocation(node), absl::StrCat("tfg.", node.op())); <nl>   <nl>    // The GraphImporter does light shape inference, but here we will defer all of
@@ -22,6 +22,7 @@ limitations under the License. <nl>  #include "tensorflow/core/framework/op_def.pb.h" <nl>  #include "tensorflow/core/framework/types.h" <nl>  #include "tensorflow/core/platform/statusor.h" <nl> +#include "tensorflow/core/protobuf/error_codes.pb.h" <nl>   <nl>  namespace tensorflow { <nl>   <nl> @@ -102,7 +103,11 @@ StatusOr<FullTypeDef> SpecializeType(const AttrSlice& attrs, <nl>        auto* arg = t->mutable_args(i); <nl>        if (arg->type_id() == TFT_VAR) { <nl>          const auto* attr = attrs.Find(arg->s()); <nl> -        DCHECK(attr != nullptr); <nl> +        if (attr == nullptr) { <nl> +          return Status( <nl> +              error::INVALID_ARGUMENT, <nl> +              absl::StrCat("Could not find an attribute for key ", arg->s())); <nl> +        } <nl>          if (attr->value_case() == AttrValue::kList) { <nl>            const auto& attr_list = attr->list(); <nl>            arg->set_type_id(TFT_PRODUCT);
@@ -668,7 +668,8 @@ class LRNGradOp : public OpKernel { <nl>          in_image.dim_size(0) == batch && in_image.dim_size(1) == rows && <nl>              in_image.dim_size(2) == cols && in_image.dim_size(3) == depth && <nl>              out_image.dim_size(0) == batch && out_image.dim_size(1) == rows && <nl> -            out_image.dim_size(2) == cols && out_image.dim_size(3) == depth, <nl> +            out_image.dim_size(2) == cols && out_image.dim_size(3) == depth && <nl> +            out_image.dims() == 4, <nl>          errors::InvalidArgument( <nl>              "input_grads, input_image, and out_image should have the same " <nl>              "shape"));
@@ -123,6 +123,11 @@ class LoadAndRemapMatrixOp : public OpKernel { <nl>      // Processes the checkpoint source and the provided Tensor name. <nl>      const Tensor* ckpt_path_t; <nl>      OP_REQUIRES_OK(context, context->input("ckpt_path", &ckpt_path_t)); <nl> +    OP_REQUIRES( <nl> +        context, ckpt_path_t->NumElements() == 1, <nl> +        errors::InvalidArgument("The `ckpt_path` tensor must have exactly one " <nl> +                                "element, got tensor of shape ", <nl> +                                ckpt_path_t->shape().DebugString())); <nl>      const string& ckpt_path = ckpt_path_t->scalar<tstring>()(); <nl>      const Tensor* old_tensor_name_t; <nl>      OP_REQUIRES_OK(context,
@@ -16,6 +16,7 @@ limitations under the License. <nl>  #include "tensorflow/core/framework/common_shape_fns.h" <nl>  #include "tensorflow/core/framework/op.h" <nl>  #include "tensorflow/core/framework/shape_inference.h" <nl> +#include "tensorflow/core/framework/types.pb.h" <nl>  #include "tensorflow/core/platform/errors.h" <nl>   <nl>  namespace tensorflow { <nl> @@ -159,6 +160,8 @@ REGISTER_OP("DeserializeSparse") <nl>      .Attr("Tserialized: {string, variant} = DT_STRING") <nl>      .SetShapeFn([](InferenceContext* c) { <nl>        // serialized sparse is [?, ..., ?, 3] vector. <nl> +      ShapeHandle unused_shape; <nl> +      TF_RETURN_IF_ERROR(c->WithRankAtLeast(c->input(0), 1, &unused_shape)); <nl>        DimensionHandle unused; <nl>        TF_RETURN_IF_ERROR(c->WithValue(c->Dim(c->input(0), -1), 3, &unused)); <nl>        c->set_output(0, c->Matrix(InferenceContext::kUnknownDim,
@@ -48,6 +48,9 @@ TfLiteStatus ResizeOutput(TfLiteContext* context, const TfLiteTensor* input, <nl>      axis_value += NumDimensions(input); <nl>    } <nl>   <nl> +  TF_LITE_ENSURE(context, axis_value >= 0); <nl> +  TF_LITE_ENSURE(context, axis_value < NumDimensions(input)); <nl> + <nl>    // Copy the input dimensions to output except the axis dimension. <nl>    TfLiteIntArray* output_dims = TfLiteIntArrayCreate(NumDimensions(input) - 1); <nl>    int j = 0;
@@ -62,6 +62,12 @@ class MemmappedTensorAllocator : public Allocator { <nl>   <nl>    void set_delete_on_deallocate() { delete_on_deallocate_ = true; } <nl>   <nl> +  // Make sure tensors or complex types (strings, variants, resources) don't get <nl> +  // their constructor called via a placement new since that would require <nl> +  // writing to immutable data. <nl> +  // See also: tensorflow/core/framework/typed_allocator.h <nl> +  bool AllocatesOpaqueHandle() const override { return true; } <nl> + <nl>   private: <nl>    std::unique_ptr<ReadOnlyMemoryRegion> memory_region_; <nl>    // If there is an error during allocation we keep it in this status.
@@ -119,7 +119,7 @@ class DrawBoundingBoxesOp : public OpKernel { <nl>   <nl>      for (int64_t b = 0; b < batch_size; ++b) { <nl>        const int64_t num_boxes = boxes.dim_size(1); <nl> -      const auto tboxes = boxes.tensor<T, 3>(); <nl> +      const auto tboxes = boxes.tensor<float, 3>(); <nl>        for (int64_t bb = 0; bb < num_boxes; ++bb) { <nl>          int64_t color_index = bb % color_table.size(); <nl>          const int64_t min_box_row =
@@ -71,6 +71,10 @@ class QuantizeAndDequantizeV2Op : public OpKernel { <nl>   <nl>    void Compute(OpKernelContext* ctx) override { <nl>      const Tensor& input = ctx->input(0); <nl> +    OP_REQUIRES( <nl> +        ctx, (axis_ == -1 || axis_ < input.shape().dims()), <nl> +        errors::InvalidArgument("Shape must be at least rank ", axis_ + 1, <nl> +                                " but is rank ", input.shape().dims())); <nl>      const int depth = (axis_ == -1) ? 1 : input.dim_size(axis_); <nl>      Tensor input_min_tensor; <nl>      Tensor input_max_tensor;
@@ -22,6 +22,7 @@ limitations under the License. <nl>  #include "tensorflow/core/framework/tensor_types.h" <nl>  #include "tensorflow/core/lib/core/errors.h" <nl>  #include "tensorflow/core/lib/core/status.h" <nl> +#include "tensorflow/core/platform/errors.h" <nl>   <nl>  namespace tensorflow { <nl>  namespace functor { <nl> @@ -63,6 +64,11 @@ Status SparseTensorToCSRSparseMatrixCPUFunctor::operator()( <nl>   <nl>      for (int64 i = 0; i < total_nnz; ++i) { <nl>        // For now, the rows pointers store the corresponding row counts. <nl> +      int64 ix = indices(i, 0) + 1; <nl> +      if (ix >= csr_row_ptr.size()) { <nl> +        return errors::InvalidArgument("Got an index ", ix, <nl> +                                       " that is outside of csr_row_ptr"); <nl> +      } <nl>        csr_row_ptr(indices(i, 0) + 1) += 1; <nl>        csr_col_ind(i) = indices(i, 1); <nl>      }
@@ -1134,7 +1134,12 @@ class SymbolicShapeRefiner { <nl>          GetUnknownOutputShape(node, output_port); <nl>      InferenceContext* ctx = GetContext(node); <nl>      if (ctx == nullptr) { <nl> -      return errors::InvalidArgument("Missing context"); <nl> +      return errors::InvalidArgument("SetUnknownShape: Missing context"); <nl> +    } <nl> +    if (output_port < 0 || output_port >= ctx->num_outputs()) { <nl> +      return errors::InvalidArgument( <nl> +          "SetUnknownShape: output_port must be in [0, ", ctx->num_outputs(), <nl> +          ") but was ", output_port); <nl>      } <nl>      ctx->set_output(output_port, shape); <nl>      return Status::OK();
@@ -116,6 +116,9 @@ class BoostedTreesCreateQuantileStreamResourceOp : public OpKernel { <nl>      const Tensor* num_streams_t; <nl>      OP_REQUIRES_OK(context, context->input(kNumStreamsName, &num_streams_t)); <nl>      int64_t num_streams = num_streams_t->scalar<int64>()(); <nl> +    OP_REQUIRES(context, num_streams >= 0, <nl> +                errors::InvalidArgument( <nl> +                    "Num_streams input cannot be a negative integer")); <nl>   <nl>      auto result = <nl>          new QuantileStreamResource(epsilon, max_elements_, num_streams);
@@ -302,6 +302,10 @@ class TensorListReserve : public OpKernel { <nl>      PartialTensorShape element_shape; <nl>      OP_REQUIRES_OK(c, TensorShapeFromTensor(c->input(0), &element_shape)); <nl>      int32 num_elements = c->input(1).scalar<int32>()(); <nl> +    OP_REQUIRES(c, num_elements >= 0, <nl> +                errors::InvalidArgument("The num_elements to reserve must be a " <nl> +                                        "non negative number, but got ", <nl> +                                        num_elements)); <nl>      TensorList output; <nl>      output.element_shape = element_shape; <nl>      output.element_dtype = element_dtype_;
@@ -100,7 +100,7 @@ StatusOr<FullTypeDef> SpecializeType(const AttrSlice& attrs, <nl>      // verifications are needed, they should be done by separately, and in a <nl>      // way that can be reused for type inference. <nl>      for (int j = 0; j < t->args_size(); j++) { <nl> -      auto* arg = t->mutable_args(i); <nl> +      auto* arg = t->mutable_args(j); <nl>        if (arg->type_id() == TFT_VAR) { <nl>          const auto* attr = attrs.Find(arg->s()); <nl>          if (attr == nullptr) {
@@ -50,6 +50,12 @@ class AssignOp : public OpKernel { <nl>      // We always return the input ref. <nl>      context->forward_ref_input_to_ref_output(0, 0); <nl>   <nl> +    // Prevent copying uninitialized data, to solve harder to debug undefined <nl> +    // behaviors that cannot be traced back to the original tensor. <nl> +    OP_REQUIRES( <nl> +        context, rhs.IsInitialized(), <nl> +        errors::Internal("Right hand side of AssignOp is not initialized")); <nl> + <nl>      // We can't always know how this value will be used downstream, so make <nl>      // conservative assumptions in specifying constraints on the memory <nl>      // allocation attributes, unless the Grappler graph analysis determined that
@@ -3505,6 +3505,9 @@ bool ConstantFolding::MulConvPushDown(GraphDef* optimized_graph, NodeDef* node, <nl>   <nl>    NodeDef* mul_left_child = node_map_->GetNode(node->input(0)); <nl>    NodeDef* mul_right_child = node_map_->GetNode(node->input(1)); <nl> +  if (mul_left_child == nullptr || mul_right_child == nullptr) { <nl> +    return false; <nl> +  } <nl>    // One child must be constant, and the second must be Conv op. <nl>    const bool left_child_is_constant = IsReallyConstant(*mul_left_child); <nl>    const bool right_child_is_constant = IsReallyConstant(*mul_right_child);
@@ -265,7 +265,7 @@ inline void BinaryBroadcastFiveFold(const ArithmeticParams& unswitched_params, <nl>        // We have broadcast y2*y3*y4 of input2 data y1 times, and now move on. <nl>        input2_data_reset = input2_data_ptr; <nl>      } <nl> -  } else { <nl> +  } else if (input1_data_ptr != nullptr) { <nl>      // Special case of y4 == 1, in which the innermost loop is a single <nl>      // element and can be combined with the next (y3) as an inner broadcast. <nl>      //
@@ -298,7 +298,7 @@ class AvgPoolingGradOp : public OpKernel { <nl>      TensorShape output_shape; <nl>      auto shape_vec = tensor_in_shape.vec<int32>(); <nl>      for (int64_t i = 0; i < tensor_in_shape.NumElements(); ++i) { <nl> -      output_shape.AddDim(shape_vec(i)); <nl> +      OP_REQUIRES_OK(context, output_shape.AddDimWithStatus(shape_vec(i))); <nl>      } <nl>      const int64_t in_rows = output_shape.dim_size(1); <nl>      const int64_t in_cols = output_shape.dim_size(2); <nl> @@ -457,7 +457,7 @@ class AvgPoolingGradOp<GPUDevice, T> : public OpKernel { <nl>      TensorShape output_shape; <nl>      auto shape_vec = tensor_in_shape.vec<int32>(); <nl>      for (int64_t i = 0; i < tensor_in_shape.NumElements(); ++i) { <nl> -      output_shape.AddDim(shape_vec(i)); <nl> +      OP_REQUIRES_OK(context, output_shape.AddDimWithStatus(shape_vec(i))); <nl>      } <nl>   <nl>      if (output_shape.num_elements() == 0) { <nl> @@ -543,7 +543,7 @@ class AvgPoolingGradOpCustomGPUKernel : public OpKernel { <nl>      TensorShape output_shape; <nl>      auto shape_vec = tensor_in_shape.vec<int32>(); <nl>      for (int64_t i = 0; i < tensor_in_shape.NumElements(); ++i) { <nl> -      output_shape.AddDim(shape_vec(i)); <nl> +      OP_REQUIRES_OK(context, output_shape.AddDimWithStatus(shape_vec(i))); <nl>      } <nl>      if (output_shape.num_elements() == 0) { <nl>        Tensor* output = nullptr;
@@ -75,12 +75,7 @@ TfLiteTensor* GetOutput(TfLiteContext* context, const TfLiteNode* node, <nl>   <nl>  const TfLiteTensor* GetOptionalInputTensor(const TfLiteContext* context, <nl>                                             const TfLiteNode* node, int index) { <nl> -  const bool use_tensor = index < node->inputs->size && <nl> -                          node->inputs->data[index] != kTfLiteOptionalTensor; <nl> -  if (use_tensor) { <nl> -    return GetMutableInput(context, node, index); <nl> -  } <nl> -  return nullptr; <nl> +  return GetInput(context, node, index); <nl>  } <nl>   <nl>  // Per-axis
@@ -62,8 +62,12 @@ TfLiteStatus PopulateQuantizedLstmParams8x8_16( <nl>        context, <nl>        GetOutputSafe(context, node, lstm::full::kOutputTensor, &output_tensor)); <nl>   <nl> +  TF_LITE_ENSURE(context, <nl> +                 cell_state->quantization.type != kTfLiteNoQuantization); <nl>    auto* cell_state_params = <nl>        static_cast<TfLiteAffineQuantization*>(cell_state->quantization.params); <nl> +  TF_LITE_ENSURE(context, <nl> +                 output_tensor->quantization.type != kTfLiteNoQuantization); <nl>    auto* proj_params = static_cast<TfLiteAffineQuantization*>( <nl>        output_tensor->quantization.params); <nl>    if (cell_clip > 0.0) { <nl> @@ -160,6 +164,8 @@ TfLiteStatus PopulateQuantizedLstmParams8x8_16( <nl>        TfLiteTensor* intermediate; <nl>        TF_LITE_ENSURE_OK(context, <nl>                          GetIntermediatesSafe(context, node, i, &intermediate)); <nl> +      TF_LITE_ENSURE(context, <nl> +                     intermediate->quantization.type != kTfLiteNoQuantization); <nl>        auto* params = static_cast<TfLiteAffineQuantization*>( <nl>            intermediate->quantization.params); <nl>        intermediate_scale.push_back(params->scale->data[0]); <nl> @@ -174,6 +180,7 @@ TfLiteStatus PopulateQuantizedLstmParams8x8_16( <nl>    // is ignored. <nl>    TfLiteTensor* hidden; <nl>    TF_LITE_ENSURE_OK(context, GetIntermediatesSafe(context, node, 4, &hidden)); <nl> +  TF_LITE_ENSURE(context, hidden->quantization.type != kTfLiteNoQuantization); <nl>    auto* hidden_params = <nl>        static_cast<TfLiteAffineQuantization*>(hidden->quantization.params); <nl>    intermediate_scale.push_back(hidden_params->scale->data[0]); <nl> @@ -760,6 +767,8 @@ TfLiteStatus PopulatePrecomputedZPTimesWeightsWithBias(TfLiteContext* context, <nl>   <nl>    const TfLiteTensor* intermediate = <nl>        &context->tensors[node->intermediates->data[4]]; <nl> +  TF_LITE_ENSURE(context, <nl> +                 intermediate->quantization.type != kTfLiteNoQuantization); <nl>    const auto* params = <nl>        static_cast<TfLiteAffineQuantization*>(intermediate->quantization.params); <nl>    const int32_t hidden_zp = params->zero_point->data[0];
@@ -89,7 +89,10 @@ class MatrixDiagPartOp : public OpKernel { <nl>            upper_diag_index = diag_index.flat<int32>()(1); <nl>          } <nl>        } <nl> -      padding_value = context->input(2).flat<T>()(0); <nl> +      const Tensor& padding_in = context->input(2); <nl> +      OP_REQUIRES(context, padding_in.NumElements() == 1, <nl> +                  errors::InvalidArgument("Padding must be scalar.")); <nl> +      padding_value = padding_in.flat<T>()(0); <nl>      } <nl>      const TensorShape& input_shape = input.shape(); <nl>  
@@ -207,7 +207,6 @@ int fmt_mtm_load_song(song_t *song, slurp_t *fp, unsigned int lflags) <nl>   <nl>  		song->patterns[pat] = csf_allocate_pattern(MAX(rows, 32)); <nl>  		song->pattern_size[pat] = song->pattern_alloc_size[pat] = 64; <nl> -		tracknote = trackdata[n]; <nl>  		for (chan = 0; chan < 32; chan++) { <nl>  			slurp_read(fp, &tmp, 2); <nl>  			tmp = bswapLE16(tmp);
@@ -148,6 +148,7 @@ static int op_get_data(OggOpusFile *_of,int _nbytes){ <nl>    int            nbytes; <nl>    OP_ASSERT(_nbytes>0); <nl>    buffer=(unsigned char *)ogg_sync_buffer(&_of->oy,_nbytes); <nl> +  if(OP_UNLIKELY(buffer==NULL))return OP_EFAULT; <nl>    nbytes=(int)(*_of->callbacks.read)(_of->stream,buffer,_nbytes); <nl>    OP_ASSERT(nbytes<=_nbytes); <nl>    if(OP_LIKELY(nbytes>0))ogg_sync_wrote(&_of->oy,nbytes); <nl> @@ -1527,6 +1528,7 @@ static int op_open1(OggOpusFile *_of, <nl>    if(_initial_bytes>0){ <nl>      char *buffer; <nl>      buffer=ogg_sync_buffer(&_of->oy,(long)_initial_bytes); <nl> +    if(OP_UNLIKELY(buffer==NULL))return OP_EFAULT; <nl>      memcpy(buffer,_initial_data,_initial_bytes*sizeof(*buffer)); <nl>      ogg_sync_wrote(&_of->oy,(long)_initial_bytes); <nl>    }
@@ -62,6 +62,12 @@ void StelScriptOutput::saveOutputAs(const QString &name) <nl>   <nl>  	const bool okToSaveToAbsolutePath=StelApp::getInstance().getSettings()->value("scripts/flag_script_allow_write_absolute_path", false).toBool(); <nl>   <nl> +	if (name.contains("config.ini")) <nl> +	{ <nl> +		qWarning() << "SCRIPTING ERROR: You are trying to overwrite config.ini. Ignoring."; <nl> +		return; <nl> +	} <nl> + <nl>  	if (!okToSaveToAbsolutePath && ((newFileNameInfo.isAbsolute() || (name.contains(".."))))) // The last condition may include dangerous/malicious paths <nl>  	{ <nl>  		qWarning() << "SCRIPTING CONFIGURATION ISSUE: You are trying to save to an absolute pathname or move up in directories.";
@@ -620,7 +620,7 @@ BZIP3_API s32 bz3_decode_block(struct bz3_state * state, u8 * buffer, s32 data_s <nl>      } <nl>   <nl>      if (bwt_idx == -1) { <nl> -        if (data_size - 8 > 64) { <nl> +        if (data_size - 8 > 64 || data_size < 8) { <nl>              state->last_error = BZ3_ERR_MALFORMED_HEADER; <nl>              return -1; <nl>          }
@@ -180,6 +180,7 @@ EventType EventTypeFromNative(const base::NativeEvent& native_event) { <nl>      case WM_NCMOUSEMOVE: <nl>        return ET_MOUSE_MOVED; <nl>      case WM_MOUSEWHEEL: <nl> +    case WM_MOUSEHWHEEL: <nl>        return ET_MOUSEWHEEL; <nl>      case WM_MOUSELEAVE: <nl>      case WM_NCMOUSELEAVE: <nl> @@ -268,8 +269,11 @@ int GetChangedMouseButtonFlagsFromNative( <nl>  } <nl>   <nl>  gfx::Vector2d GetMouseWheelOffset(const base::NativeEvent& native_event) { <nl> -  DCHECK(native_event.message == WM_MOUSEWHEEL); <nl> -  return gfx::Vector2d(0, GET_WHEEL_DELTA_WPARAM(native_event.wParam)); <nl> +  DCHECK(native_event.message == WM_MOUSEWHEEL || <nl> +         native_event.message == WM_MOUSEHWHEEL); <nl> +  if (native_event.message == WM_MOUSEWHEEL) <nl> +    return gfx::Vector2d(0, GET_WHEEL_DELTA_WPARAM(native_event.wParam)); <nl> +  return gfx::Vector2d(GET_WHEEL_DELTA_WPARAM(native_event.wParam), 0); <nl>  } <nl>   <nl>  void ClearTouchIdIfReleased(const base::NativeEvent& xev) {
@@ -27,8 +27,12 @@ class KeyboardUIImpl : public KeyboardUI, public AccessibilityObserver { <nl>    } <nl>   <nl>    void ShowInDisplay(const int64_t display_id) override { <nl> -    keyboard::KeyboardController::GetInstance()->ShowKeyboardInDisplay( <nl> -        display_id); <nl> +    keyboard::KeyboardController* controller = <nl> +        keyboard::KeyboardController::GetInstance(); <nl> +    // Controller may not exist if keyboard has been disabled. crbug.com/749989 <nl> +    if (!controller) <nl> +      return; <nl> +    controller->ShowKeyboardInDisplay(display_id); <nl>    } <nl>    void Hide() override { <nl>      // Do nothing as this is called from ash::Shell, which also calls through
@@ -12,6 +12,7 @@ <nl>  #include "grit/chromium_strings.h" <nl>  #include "grit/generated_resources.h" <nl>  #include "net/base/cert_status_flags.h" <nl> +#include "net/base/escape.h" <nl>  #include "net/base/net_errors.h" <nl>  #include "net/base/ssl_info.h" <nl>  #include "ui/base/l10n/l10n_util.h" <nl> @@ -55,7 +56,8 @@ SSLErrorInfo SSLErrorInfo::CreateError(ErrorType error_type, <nl>        details = <nl>            l10n_util::GetStringFUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_DETAILS, <nl>                                       UTF8ToUTF16(request_url.host()), <nl> -                                     UTF8ToUTF16(dns_names[i]), <nl> +                                     net::EscapeForHTML( <nl> +                                         UTF8ToUTF16(dns_names[i])), <nl>                                       UTF8ToUTF16(request_url.host())); <nl>        short_description = l10n_util::GetStringUTF16( <nl>            IDS_CERT_ERROR_COMMON_NAME_INVALID_DESCRIPTION); <nl> @@ -64,7 +66,7 @@ SSLErrorInfo SSLErrorInfo::CreateError(ErrorType error_type, <nl>        extra_info.push_back( <nl>            l10n_util::GetStringFUTF16( <nl>                IDS_CERT_ERROR_COMMON_NAME_INVALID_EXTRA_INFO_2, <nl> -              UTF8ToUTF16(cert->subject().common_name), <nl> +              net::EscapeForHTML(UTF8ToUTF16(cert->subject().common_name)), <nl>                UTF8ToUTF16(request_url.host()))); <nl>        break; <nl>      }
@@ -177,7 +177,7 @@ void SerializedScriptValue::transferArrayBuffers(v8::Isolate* isolate, const Arr <nl>   <nl>              DOMArrayBufferBase* toTransfer = arrayBuffers[i]; <nl>              if (!isNeuterable) <nl> -                toTransfer = DOMArrayBuffer::create(arrayBuffers[i]->buffer()); <nl> +                toTransfer = DOMArrayBuffer::create(arrayBuffers[i]->buffer()->data(), arrayBuffers[i]->buffer()->byteLength()); <nl>              bool result = toTransfer->transfer(contents->at(i)); <nl>              if (!result) { <nl>                  exceptionState.throwDOMException(DataCloneError, "ArrayBuffer at index " + String::number(i) + " could not be transferred.");
@@ -1319,6 +1319,7 @@ void AddPasswordsAndFormsStrings(content::WebUIDataSource* html_source) { <nl>        {"autofill", IDS_SETTINGS_AUTOFILL}, <nl>        {"googlePayments", IDS_SETTINGS_GOOGLE_PAYMENTS}, <nl>        {"googlePaymentsCached", IDS_SETTINGS_GOOGLE_PAYMENTS_CACHED}, <nl> +      {"autofillFormsLabel", IDS_SETTINGS_AUTOFILL_TOGGLE_LABEL}, <nl>        {"addresses", IDS_SETTINGS_AUTOFILL_ADDRESSES_HEADING}, <nl>        {"addAddressTitle", IDS_SETTINGS_AUTOFILL_ADDRESSES_ADD_TITLE}, <nl>        {"editAddressTitle", IDS_SETTINGS_AUTOFILL_ADDRESSES_EDIT_TITLE}, <nl> @@ -1340,6 +1341,8 @@ void AddPasswordsAndFormsStrings(content::WebUIDataSource* html_source) { <nl>        {"addCreditCardTitle", IDS_SETTINGS_ADD_CREDIT_CARD_TITLE}, <nl>        {"autofillDetail", IDS_SETTINGS_AUTOFILL_DETAIL}, <nl>        {"passwords", IDS_SETTINGS_PASSWORDS}, <nl> +      {"passwordsSavePasswordsLabel", <nl> +       IDS_SETTINGS_PASSWORDS_SAVE_PASSWORDS_TOGGLE_LABEL}, <nl>        {"passwordsAutosigninLabel", <nl>         IDS_SETTINGS_PASSWORDS_AUTOSIGNIN_CHECKBOX_LABEL}, <nl>        {"passwordsAutosigninDescription",
@@ -654,6 +654,7 @@ xsltFormatNumberFunction(xmlXPathParserContextPtr ctxt, int nargs) <nl>  void <nl>  xsltGenerateIdFunction(xmlXPathParserContextPtr ctxt, int nargs){ <nl>      xmlNodePtr cur = NULL; <nl> +    xmlXPathObjectPtr obj = NULL; <nl>      long val; <nl>      xmlChar str[30]; <nl>      xmlDocPtr doc; <nl> @@ -661,7 +662,6 @@ xsltGenerateIdFunction(xmlXPathParserContextPtr ctxt, int nargs){ <nl>      if (nargs == 0) { <nl>  	cur = ctxt->context->node; <nl>      } else if (nargs == 1) { <nl> -	xmlXPathObjectPtr obj; <nl>  	xmlNodeSetPtr nodelist; <nl>  	int i, ret; <nl>   <nl> @@ -684,7 +684,6 @@ xsltGenerateIdFunction(xmlXPathParserContextPtr ctxt, int nargs){ <nl>  	    if (ret == -1) <nl>  	        cur = nodelist->nodeTab[i]; <nl>  	} <nl> -	xmlXPathFreeObject(obj); <nl>      } else { <nl>  	xsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL, <nl>  		"generate-id() : invalid number of args %d\n", nargs); <nl> @@ -707,6 +706,9 @@ xsltGenerateIdFunction(xmlXPathParserContextPtr ctxt, int nargs){ <nl>   <nl>      } <nl>   <nl> +    if (obj) <nl> +        xmlXPathFreeObject(obj); <nl> + <nl>      val = (long)((char *)cur - (char *)doc); <nl>      if (val >= 0) { <nl>        sprintf((char *)str, "idp%ld", val);
@@ -788,8 +788,6 @@ void OverlayWindowViews::OnGestureEvent(ui::GestureEvent* event) { <nl>      TogglePlayPause(); <nl>      event->SetHandled(); <nl>    } <nl> - <nl> -  views::Widget::OnGestureEvent(event); <nl>  } <nl>   <nl>  void OverlayWindowViews::ButtonPressed(views::Button* sender,
@@ -660,16 +660,10 @@ IN_PROC_BROWSER_TEST_F(SSLUITest, TestRunsCachedInsecureContent) { <nl>    CheckAuthenticationBrokenState(tab, 0, true, false); <nl>  } <nl>   <nl> -#if defined(OS_WIN) <nl> -// See http://crbug.com/47170 <nl> -#define MAYBE_TestCNInvalidStickiness FLAKY_TestCNInvalidStickiness <nl> -#else <nl> -#define MAYBE_TestCNInvalidStickiness TestCNInvalidStickiness <nl> -#endif <nl> - <nl>  // This test ensures the CN invalid status does not 'stick' to a certificate <nl>  // (see bug #1044942) and that it depends on the host-name. <nl> -IN_PROC_BROWSER_TEST_F(SSLUITest, MAYBE_TestCNInvalidStickiness) { <nl> +// Disabled, see http://crbug.com/68448 and http://crbug.com/49377. <nl> +IN_PROC_BROWSER_TEST_F(SSLUITest, DISABLED_TestCNInvalidStickiness) { <nl>    ASSERT_TRUE(https_server_.Start()); <nl>    ASSERT_TRUE(https_server_mismatched_.Start()); <nl>  
@@ -31,7 +31,6 @@ <nl>  #include "config.h" <nl>  #include "bindings/v8/ScriptProfiler.h" <nl>   <nl> -#include "V8ArrayBufferView.h" <nl>  #include "V8Node.h" <nl>  #include "V8Window.h" <nl>  #include "bindings/v8/RetainedDOMInfo.h"
@@ -6259,14 +6259,14 @@ void WebPagePrivate::willComposite() <nl>  { <nl>      if (!m_page->settings()->developerExtrasEnabled()) <nl>          return; <nl> -    InspectorInstrumentation::willComposite(m_page); <nl> +    m_page->inspectorController()->willComposite(); <nl>  } <nl>   <nl>  void WebPagePrivate::didComposite() <nl>  { <nl>      if (!m_page->settings()->developerExtrasEnabled()) <nl>          return; <nl> -    InspectorInstrumentation::didComposite(m_page); <nl> +    m_page->inspectorController()->didComposite(); <nl>  } <nl>   <nl>  void WebPage::updateNotificationPermission(const BlackBerry::Platform::String& requestId, bool allowed)
@@ -402,8 +402,6 @@ static void willRemoveChildren(ContainerNode* container) <nl>      NodeVector children; <nl>      getChildNodes(container, children); <nl>   <nl> -    container->document().nodeChildrenWillBeRemoved(container); <nl> - <nl>      ChildListMutationScope mutation(container); <nl>      for (NodeVector::const_iterator it = children.begin(); it != children.end(); it++) { <nl>          Node* child = it->get(); <nl> @@ -546,6 +544,8 @@ void ContainerNode::removeChildren() <nl>          document().removeFocusedElementOfSubtree(this, true); <nl>      } <nl>   <nl> +    document().nodeChildrenWillBeRemoved(this); <nl> + <nl>      NodeVector removedChildren; <nl>      { <nl>          RenderWidget::UpdateSuspendScope suspendWidgetHierarchyUpdates;
@@ -38,6 +38,9 @@ static base::LazyInstance<ThreadLocalPointer<IndexedDBDispatcher> >::Leaky <nl>   <nl>  namespace { <nl>   <nl> +IndexedDBDispatcher* const HAS_BEEN_DELETED = <nl> +    reinterpret_cast<IndexedDBDispatcher*>(0x1); <nl> + <nl>  int32 CurrentWorkerId() { <nl>    return WorkerTaskRunner::Instance()->CurrentWorkerId(); <nl>  } <nl> @@ -51,10 +54,14 @@ IndexedDBDispatcher::IndexedDBDispatcher() { <nl>  } <nl>   <nl>  IndexedDBDispatcher::~IndexedDBDispatcher() { <nl> -  g_idb_dispatcher_tls.Pointer()->Set(NULL); <nl> +  g_idb_dispatcher_tls.Pointer()->Set(HAS_BEEN_DELETED); <nl>  } <nl>   <nl>  IndexedDBDispatcher* IndexedDBDispatcher::ThreadSpecificInstance() { <nl> +  if (g_idb_dispatcher_tls.Pointer()->Get() == HAS_BEEN_DELETED) { <nl> +    NOTREACHED() << "Re-instantiating TLS IndexedDBDispatcher."; <nl> +    g_idb_dispatcher_tls.Pointer()->Set(NULL); <nl> +  } <nl>    if (g_idb_dispatcher_tls.Pointer()->Get()) <nl>      return g_idb_dispatcher_tls.Pointer()->Get(); <nl>  
@@ -64,10 +64,14 @@ void SignatureUtil::CheckSignature( <nl>      for (DWORD i = 0; i < prov_data->csSigners; ++i) { <nl>        const CERT_CHAIN_CONTEXT* cert_chain_context = <nl>            prov_data->pasSigners[i].pChainContext; <nl> +      if (!cert_chain_context) <nl> +        break; <nl>        for (DWORD j = 0; j < cert_chain_context->cChain; ++j) { <nl>          CERT_SIMPLE_CHAIN* simple_chain = cert_chain_context->rgpChain[j]; <nl>          ClientDownloadRequest_CertificateChain* chain = <nl>              signature_info->add_certificate_chain(); <nl> +        if (!simple_chain) <nl> +          break; <nl>          for (DWORD k = 0; k < simple_chain->cElement; ++k) { <nl>            CERT_CHAIN_ELEMENT* element = simple_chain->rgpElement[k]; <nl>            chain->add_element()->set_certificate(
@@ -55,14 +55,17 @@ base::string16 GenerateKeywordFromNavigationEntry( <nl>        return base::string16(); <nl>    } <nl>   <nl> -  // Don't autogenerate keywords for referrers that are anything other than HTTP <nl> -  // or have a path. <nl> +  // Don't autogenerate keywords for referrers that <nl> +  // a) are anything other than HTTP/HTTPS or <nl> +  // b) have a path. <nl>    // <nl>    // If we relax the path constraint, we need to be sure to sanitize the path <nl>    // elements and update AutocompletePopup to look for keywords using the path. <nl>    // See http://b/issue?id=863583. <nl> -  if (!url.SchemeIs(url::kHttpScheme) || (url.path().length() > 1)) <nl> +  if (!(url.SchemeIs(url::kHttpScheme) || url.SchemeIs(url::kHttpsScheme)) || <nl> +      (url.path().length() > 1)) { <nl>      return base::string16(); <nl> +  } <nl>   <nl>    return TemplateURL::GenerateKeyword(url, accept_languages); <nl>  }
@@ -42,8 +42,12 @@ namespace WebCore { <nl>   <nl>  HarfBuzzShaperBase::HarfBuzzShaperBase(const Font* font, const TextRun& run) <nl>      : m_font(font) <nl> +    , m_normalizedBufferLength(0) <nl>      , m_run(run) <nl>      , m_wordSpacingAdjustment(font->wordSpacing()) <nl> +    , m_padding(0) <nl> +    , m_padPerWordBreak(0) <nl> +    , m_padError(0) <nl>      , m_letterSpacing(font->letterSpacing()) <nl>  { <nl>  }
@@ -1387,12 +1387,13 @@ static void BooleanOrNullAttributeAttributeSetter( <nl>   <nl>    ExceptionState exception_state(isolate, ExceptionState::kSetterContext, "TestObject", "booleanOrNullAttribute"); <nl>   <nl> +  bool is_null = IsUndefinedOrNull(v8_value); <nl> + <nl>    // Prepare the value to be set. <nl> -  bool cpp_value = NativeValueTraits<IDLBoolean>::NativeValue(info.GetIsolate(), v8_value, exception_state); <nl> +  bool cpp_value = is_null ? bool() : NativeValueTraits<IDLBoolean>::NativeValue(info.GetIsolate(), v8_value, exception_state); <nl>    if (exception_state.HadException()) <nl>      return; <nl>   <nl> -  bool is_null = IsUndefinedOrNull(v8_value); <nl>    impl->setBooleanOrNullAttribute(cpp_value, is_null); <nl>  } <nl>   <nl> @@ -1451,12 +1452,13 @@ static void LongOrNullAttributeAttributeSetter( <nl>   <nl>    ExceptionState exception_state(isolate, ExceptionState::kSetterContext, "TestObject", "longOrNullAttribute"); <nl>   <nl> +  bool is_null = IsUndefinedOrNull(v8_value); <nl> + <nl>    // Prepare the value to be set. <nl> -  int32_t cpp_value = NativeValueTraits<IDLLong>::NativeValue(info.GetIsolate(), v8_value, exception_state); <nl> +  int32_t cpp_value = is_null ? int32_t() : NativeValueTraits<IDLLong>::NativeValue(info.GetIsolate(), v8_value, exception_state); <nl>    if (exception_state.HadException()) <nl>      return; <nl>   <nl> -  bool is_null = IsUndefinedOrNull(v8_value); <nl>    impl->setLongOrNullAttribute(cpp_value, is_null); <nl>  } <nl>  
@@ -1158,6 +1158,9 @@ void GpuProcessHost::OnProcessCrashed(int exit_code) { <nl>    int process_crash_exit_code = exit_code; <nl>    base::debug::Alias(&process_crash_exit_code); <nl>   <nl> +  // Record crash before doing anything that could start a new GPU process. <nl> +  RecordProcessCrash(); <nl> + <nl>    // If the GPU process crashed while compiling a shader, we may have invalid <nl>    // cached binaries. Completely clear the shader cache to force shader binaries <nl>    // to be re-created. <nl> @@ -1173,7 +1176,6 @@ void GpuProcessHost::OnProcessCrashed(int exit_code) { <nl>      } <nl>    } <nl>    SendOutstandingReplies(EstablishChannelStatus::GPU_HOST_INVALID); <nl> -  RecordProcessCrash(); <nl>   <nl>    ChildProcessTerminationInfo info = <nl>        process_->GetTerminationInfo(true /* known_dead */); <nl> @@ -1211,7 +1213,8 @@ void GpuProcessHost::DidFailInitialize() { <nl>    UMA_HISTOGRAM_BOOLEAN("GPU.GPUProcessInitialized", false); <nl>    status_ = FAILURE; <nl>    GpuDataManagerImpl* gpu_data_manager = GpuDataManagerImpl::GetInstance(); <nl> -  gpu_data_manager->FallBackToNextGpuMode(); <nl> +  if (kind_ == GPU_PROCESS_KIND_SANDBOXED) <nl> +    gpu_data_manager->FallBackToNextGpuMode(); <nl>    RunRequestGPUInfoCallbacks(gpu_data_manager->GetGPUInfo()); <nl>  } <nl>  
@@ -413,6 +413,16 @@ void ImageLoader::DoUpdateFromElement(BypassMainWorldBehavior bypass_behavior, <nl>        resource_request.SetRequestContext(WebURLRequest::kRequestContextPing); <nl>      } <nl>   <nl> +    // Plug-ins should not load via service workers as plug-ins may have their <nl> +    // own origin checking logic that may get confused if service workers <nl> +    // respond with resources from another origin. <nl> +    // https://w3c.github.io/ServiceWorker/#implementer-concerns <nl> +    if (GetElement()->IsHTMLElement() && <nl> +        ToHTMLElement(GetElement())->IsPluginElement()) { <nl> +      resource_request.SetServiceWorkerMode( <nl> +          WebURLRequest::ServiceWorkerMode::kNone); <nl> +    } <nl> + <nl>      FetchParameters params(resource_request, resource_loader_options); <nl>      ConfigureRequest(params, bypass_behavior, *element_, <nl>                       document.GetClientHintsPreferences());
@@ -1625,7 +1625,7 @@ float ewk_view_scale_get(const Evas_Object* ewkView) <nl>      return priv->page->pageScaleFactor(); <nl>  } <nl>   <nl> -Eina_Bool ewk_view_scale_set(Evas_Object* ewkView, float scaleFactor, Evas_Coord centerX, Evas_Coord centerY) <nl> +Eina_Bool ewk_view_scale_set(Evas_Object* ewkView, float scaleFactor, Evas_Coord scrollX, Evas_Coord scrollY) <nl>  { <nl>      EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, false); <nl>      EWK_VIEW_PRIV_GET_OR_RETURN(smartData, priv, false); <nl> @@ -1634,12 +1634,7 @@ Eina_Bool ewk_view_scale_set(Evas_Object* ewkView, float scaleFactor, Evas_Coord <nl>      if (currentScaleFactor == -1) <nl>          return false; <nl>   <nl> -    int x, y; <nl> -    ewk_frame_scroll_pos_get(smartData->main_frame, &x, &y); <nl> - <nl> -    x = static_cast<int>(((x + centerX) / currentScaleFactor) * scaleFactor) - centerX; <nl> -    y = static_cast<int>(((y + centerY) / currentScaleFactor) * scaleFactor) - centerY; <nl> -    priv->page->setPageScaleFactor(scaleFactor, WebCore::LayoutPoint(x, y)); <nl> +    priv->page->setPageScaleFactor(scaleFactor, WebCore::LayoutPoint(scrollX, scrollY)); <nl>      return true; <nl>  } <nl>  
@@ -97,8 +97,8 @@ void TestOfflineLoadPage::NotifyBlockingPageComplete(bool proceed) { <nl>    test_page_->OnBlockingPageComplete(proceed); <nl>  } <nl>   <nl> - <nl> -TEST_F(OfflineLoadPageTest, OfflinePageProceed) { <nl> +// Tests are disabled due to crash. see crbug.com/113219. <nl> +TEST_F(OfflineLoadPageTest, DISABLED_OfflinePageProceed) { <nl>    // Start a load. <nl>    Navigate(kURL1, 1); <nl>    // Load next page. <nl> @@ -127,7 +127,7 @@ TEST_F(OfflineLoadPageTest, OfflinePageProceed) { <nl>  } <nl>   <nl>  // Tests showing an offline page and not proceeding. <nl> -TEST_F(OfflineLoadPageTest, OfflinePageDontProceed) { <nl> +TEST_F(OfflineLoadPageTest, DISABLED_OfflinePageDontProceed) { <nl>    // Start a load. <nl>    Navigate(kURL1, 1); <nl>    controller().LoadURL(GURL(kURL2), content::Referrer(),
@@ -1098,7 +1098,8 @@ int OmniboxViewViews::OnDrop(const ui::OSExchangeData& data) { <nl>    } else if (data.HasString()) { <nl>      base::string16 text; <nl>      if (data.GetString(&text)) { <nl> -      base::string16 collapsed_text(base::CollapseWhitespace(text, true)); <nl> +      base::string16 collapsed_text( <nl> +          StripJavascriptSchemas(base::CollapseWhitespace(text, true))); <nl>        if (model()->CanPasteAndGo(collapsed_text)) <nl>          model()->PasteAndGo(collapsed_text); <nl>        return ui::DragDropTypes::DRAG_COPY;
@@ -757,6 +757,8 @@ void FrameLoader::receivedFirstData() <nl>      String url; <nl>      if (!m_documentLoader) <nl>          return; <nl> +    if (m_frame->inViewSourceMode()) <nl> +        return; <nl>      if (!parseHTTPRefresh(m_documentLoader->response().httpHeaderField("Refresh"), false, delay, url)) <nl>          return; <nl>  
@@ -321,19 +321,21 @@ void SafeBrowsingBlockingPage::CommandReceived(const std::string& cmd) { <nl>   <nl>    // The "report error" and "show diagnostic" commands can have a number <nl>    // appended to them, which is the index of the element they apply to. <nl> -  int element_index = 0; <nl> +  size_t element_index = 0; <nl>    size_t colon_index = command.find(':'); <nl>    if (colon_index != std::string::npos) { <nl>      DCHECK(colon_index < command.size() - 1); <nl> +    int result_int = 0; <nl>      bool result = base::StringToInt(base::StringPiece(command.begin() + <nl>                                                        colon_index + 1, <nl>                                                        command.end()), <nl> -                                    &element_index); <nl> +                                    &result_int); <nl>      command = command.substr(0, colon_index); <nl> -    DCHECK(result); <nl> +    if (result) <nl> +      element_index = static_cast<size_t>(result_int); <nl>    } <nl>   <nl> -  if (element_index >= static_cast<int>(unsafe_resources_.size())) { <nl> +  if (element_index >= unsafe_resources_.size()) { <nl>      NOTREACHED(); <nl>      return; <nl>    }
@@ -485,7 +485,7 @@ void AccountReconcilor::FinishReconcileWithMultiloginEndpoint( <nl>      const std::string& primary_account, <nl>      const std::vector<std::string>& chrome_accounts, <nl>      std::vector<gaia::ListedAccount>&& gaia_accounts) { <nl> -  DCHECK(base::FeatureList::IsEnabled(kUseMultiloginEndpoint)); <nl> +  DCHECK(IsMultiloginEndpointEnabled()); <nl>    DCHECK(!set_accounts_in_progress_); <nl>   <nl>    bool primary_has_error =
@@ -2287,7 +2287,13 @@ int PDFiumEngine::GetMostVisiblePage() { <nl>    if (in_flight_visible_page_) <nl>      return *in_flight_visible_page_; <nl>   <nl> +  // We can call GetMostVisiblePage through a callback from PDFium. We have <nl> +  // to defer the page deletion otherwise we could potentially delete the page <nl> +  // that originated the calling JS request and destroy the objects that are <nl> +  // currently being used. <nl> +  defer_page_unload_ = true; <nl>    CalculateVisiblePages(); <nl> +  defer_page_unload_ = false; <nl>    return most_visible_page_; <nl>  } <nl>  
@@ -56,7 +56,7 @@ base::string16 GetUninstallSurveyUrl() { <nl>  bool NavigateToUrlWithEdge(const base::string16& url) { <nl>    base::string16 protocol_url = L"microsoft-edge:" + url; <nl>    SHELLEXECUTEINFO info = { sizeof(info) }; <nl> -  info.fMask = SEE_MASK_NOASYNC | SEE_MASK_FLAG_NO_UI; <nl> +  info.fMask = SEE_MASK_NOASYNC; <nl>    info.lpVerb = L"open"; <nl>    info.lpFile = protocol_url.c_str(); <nl>    info.nShow = SW_SHOWNORMAL;
@@ -874,7 +874,7 @@ std::string TestURLLoader::TestUntendedLoad() { <nl>      loader.GetDownloadProgress(&bytes_received, &total_bytes_to_be_received); <nl>      if (total_bytes_to_be_received <= 0) <nl>        return ReportError("URLLoader::GetDownloadProgress total size", <nl> -          total_bytes_to_be_received); <nl> +                         static_cast<int32_t>(total_bytes_to_be_received)); <nl>      if (bytes_received == total_bytes_to_be_received) <nl>        break; <nl>      // Yield if we're on the main thread, so that URLLoader can receive more
@@ -114,7 +114,6 @@ TEST(VideoFrameMac, CheckWrapperFrame) { <nl>        {PIXEL_FORMAT_NV12, kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange}, <nl>    }; <nl>   <nl> -  const gfx::Size size(kWidth, kHeight); <nl>    for (const auto& format_pair : format_pairs) { <nl>      base::ScopedCFTypeRef<CVPixelBufferRef> pb; <nl>      CVPixelBufferCreate(nullptr, kWidth, kHeight, format_pair.corevideo,
@@ -153,6 +153,10 @@ TracingControllerImpl::TracingControllerImpl() <nl>    base::trace_event::TraceLog::GetInstance()->AddAsyncEnabledStateObserver( <nl>        weak_ptr_factory_.GetWeakPtr()); <nl>    g_tracing_controller = this; <nl> + <nl> +  // TODO(oysteine): Instead of connecting right away, we should connect <nl> +  // in StartTracing once this no longer causes test flakiness. <nl> +  ConnectToServiceIfNeeded(); <nl>  } <nl>   <nl>  TracingControllerImpl::~TracingControllerImpl() { <nl> @@ -365,7 +369,6 @@ bool TracingControllerImpl::StartTracing( <nl>        std::make_unique<base::trace_event::TraceConfig>(trace_config); <nl>   <nl>    start_tracing_done_ = std::move(callback); <nl> -  ConnectToServiceIfNeeded(); <nl>    coordinator_->StartTracing(trace_config.ToString()); <nl>   <nl>    if (start_tracing_done_ &&
@@ -18,7 +18,8 @@ PlatformFileForTransit GetFileHandleForProcess(base::PlatformFile handle, <nl>    DWORD options = DUPLICATE_SAME_ACCESS; <nl>    if (close_source_handle) <nl>      options |= DUPLICATE_CLOSE_SOURCE; <nl> -  if (!::DuplicateHandle(::GetCurrentProcess(), <nl> +  if (handle == INVALID_HANDLE_VALUE || <nl> +      !::DuplicateHandle(::GetCurrentProcess(), <nl>                           handle, <nl>                           process, <nl>                           &out_handle,
@@ -1,4 +1,4 @@ <nl> -// Copyright (c) 2011 The Chromium Authors. All rights reserved. <nl> +// Copyright (c) 2012 The Chromium Authors. All rights reserved. <nl>  // Use of this source code is governed by a BSD-style license that can be <nl>  // found in the LICENSE file. <nl>   <nl> @@ -414,6 +414,7 @@ void ProfileImplIOData::LazyInitializeInternal( <nl>    ftp_factory_.reset( <nl>        new net::FtpNetworkLayer(io_thread_globals->host_resolver.get())); <nl>    main_context->set_ftp_transaction_factory(ftp_factory_.get()); <nl> +  media_request_context_->set_ftp_transaction_factory(ftp_factory_.get()); <nl>   <nl>    main_context->set_chrome_url_data_manager_backend( <nl>        chrome_url_data_manager_backend());
@@ -259,6 +259,7 @@ bool HTMLFormElement::validateInteractively(Event* event) <nl>   <nl>  bool HTMLFormElement::prepareForSubmission(Event* event) <nl>  { <nl> +    RefPtr<HTMLFormElement> protector(this); <nl>      Frame* frame = document().frame(); <nl>      if (m_isSubmittingOrPreparingForSubmission || !frame) <nl>          return m_isSubmittingOrPreparingForSubmission;
@@ -520,6 +520,8 @@ bool Instance::HandleInputEvent(const pp::InputEvent& event) { <nl>      } <nl>      if (page_down) { <nl>        int page = engine_->GetFirstVisiblePage(); <nl> +      if (page == -1) <nl> +        return true; <nl>        // Engine calculates visible page including delimiter to the page size. <nl>        // We need to check here if the page itself is completely out of view and <nl>        // scroll to the next one in that case. <nl> @@ -531,6 +533,8 @@ bool Instance::HandleInputEvent(const pp::InputEvent& event) { <nl>        return true; <nl>      } else if (page_up) { <nl>        int page = engine_->GetFirstVisiblePage(); <nl> +      if (page == -1) <nl> +        return true; <nl>        if (engine_->GetPageRect(page).y() * zoom_ >= v_scrollbar_->GetValue()) <nl>          page--; <nl>        ScrollToPage(page);
@@ -1018,6 +1018,9 @@ void ExtensionPrefs::UpdateManifest(const Extension* extension) { <nl>   <nl>  FilePath ExtensionPrefs::GetExtensionPath(const std::string& extension_id) { <nl>    const DictionaryValue* dict = GetExtensionPref(extension_id); <nl> +  if (!dict) <nl> +    return FilePath(); <nl> + <nl>    std::string path; <nl>    if (!dict->GetString(kPrefPath, &path)) <nl>      return FilePath();
@@ -103,6 +103,7 @@ class PowerPopupView : public views::Label { <nl>   public: <nl>    PowerPopupView() { <nl>      SetHorizontalAlignment(ALIGN_RIGHT); <nl> +    SetMultiLine(true); <nl>      UpdateText(); <nl>    } <nl>  
@@ -725,6 +725,7 @@ void FrameLoader::detachDocumentLoader(Member<DocumentLoader>& loader) <nl>      if (!loader) <nl>          return; <nl>   <nl> +    FrameNavigationDisabler navigationDisabler(*m_frame); <nl>      loader->detachFromFrame(); <nl>      loader = nullptr; <nl>  } <nl> @@ -1113,7 +1114,6 @@ bool FrameLoader::prepareForCommit() <nl>      // At this point, the provisional document loader should not detach, because <nl>      // then the FrameLoader would not have any attached DocumentLoaders. <nl>      if (m_documentLoader) { <nl> -        FrameNavigationDisabler navigationDisabler(*m_frame); <nl>          TemporaryChange<bool> inDetachDocumentLoader(m_protectProvisionalLoader, true); <nl>          detachDocumentLoader(m_documentLoader); <nl>      } <nl> @@ -1420,10 +1420,7 @@ void FrameLoader::startLoad(FrameLoadRequest& frameLoadRequest, FrameLoadType ty <nl>          return; <nl>   <nl>      m_frame->document()->cancelParsing(); <nl> -    if (m_provisionalDocumentLoader) { <nl> -        FrameNavigationDisabler navigationDisabler(*m_frame); <nl> -        detachDocumentLoader(m_provisionalDocumentLoader); <nl> -    } <nl> +    detachDocumentLoader(m_provisionalDocumentLoader); <nl>   <nl>      // beforeunload fired above, and detaching a DocumentLoader can fire <nl>      // events, which can detach this frame.
@@ -112,7 +112,7 @@ bool PlatformFontSkia::InitDefaultFont() { <nl>   <nl>    bool success = false; <nl>    std::string family = kFallbackFontFamilyName; <nl> -  int size_pixels = 12; <nl> +  int size_pixels = PlatformFont::kDefaultBaseFontSize; <nl>    int style = Font::NORMAL; <nl>    Font::Weight weight = Font::Weight::NORMAL; <nl>    FontRenderParams params;

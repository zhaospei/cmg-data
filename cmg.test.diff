@@ -544,7 +544,7 @@ guestfs___check_package_management (guestfs_h *g, struct inspect_fs *fs) <nl>  char * <nl>  guestfs___first_line_of_file (guestfs_h *g, const char *filename) <nl>  { <nl> -  CLEANUP_FREE char **lines = NULL; /* sic: not CLEANUP_FREE_STRING_LIST */ <nl> +  char **lines = NULL; /* sic: not CLEANUP_FREE_STRING_LIST */ <nl>    int64_t size; <nl>    char *ret; <nl>   <nl> @@ -573,6 +573,8 @@ guestfs___first_line_of_file (guestfs_h *g, const char *filename) <nl>   <nl>    ret = lines[0];               /* caller frees */ <nl>   <nl> +  free (lines); <nl> + <nl>    return ret; <nl>  } <nl>  
@@ -348,6 +348,10 @@ guestfs_close (guestfs_h *g) <nl>    g->fd[1] = -1; <nl>    g->sock = -1; <nl>   <nl> +  /* Wait for subprocess(es) to exit. */ <nl> +  waitpid (g->pid, NULL, 0); <nl> +  if (g->recoverypid > 0) waitpid (g->recoverypid, NULL, 0); <nl> + <nl>    /* Remove tmpfiles. */ <nl>    if (g->tmpdir) { <nl>      snprintf (filename, sizeof filename, "%s/sock", g->tmpdir);
@@ -942,9 +942,15 @@ static int mb_config_add_host (oconfig_item_t *ci) /* {{{ */ <nl>   <nl>    status = cf_util_get_string_buffer (ci, host->host, sizeof (host->host)); <nl>    if (status != 0) <nl> +  { <nl> +    sfree (host); <nl>      return (status); <nl> +  } <nl>    if (host->host[0] == 0) <nl> +  { <nl> +    sfree (host); <nl>      return (EINVAL); <nl> +  } <nl>   <nl>    for (i = 0; i < ci->children_num; i++) <nl>    {
@@ -315,7 +315,7 @@ static void submit_value (int cpu_num, int cpu_state, const char *type, value_t <nl>  	sstrncpy (vl.type_instance, cpu_state_names[cpu_state], <nl>  		  sizeof (vl.type_instance)); <nl>   <nl> -	if (cpu_num > 0) { <nl> +	if (cpu_num >= 0) { <nl>  		ssnprintf (vl.plugin_instance, sizeof (vl.plugin_instance), <nl>  			   "%i", cpu_num); <nl>  	} <nl> @@ -363,7 +363,6 @@ static void submit (int cpu_num, derive_t *derives) <nl>          gauge_t percent; <nl>           <nl>  	if (!report_percent && report_by_cpu) { <nl> - <nl>  		for (i = 1; i < CPU_SUBMIT_ACTIVE; i++) <nl>  		{ <nl>  			if (derives[i] == -1)
@@ -428,7 +428,7 @@ static int dpdk_helper_link_status_get(dpdk_helper_ctx_t *phc) { <nl>    } <nl>    ec->nb_ports = nb_ports > RTE_MAX_ETHPORTS ? RTE_MAX_ETHPORTS : nb_ports; <nl>   <nl> -  for (int i = 0; i < ec->nb_ports; i++) { <nl> +  for (unsigned int i = 0; i < ec->nb_ports; i++) { <nl>      if (ec->config.link_status.enabled_port_mask & (1 << i)) { <nl>        struct rte_eth_link link; <nl>        ec->link_info[i].read_time = cdtime(); <nl> @@ -497,7 +497,7 @@ static int dpdk_events_link_status_dispatch(dpdk_helper_ctx_t *phc) { <nl>          ec->nb_ports); <nl>   <nl>    /* dispatch Link Status values to collectd */ <nl> -  for (int i = 0; i < ec->nb_ports; i++) { <nl> +  for (unsigned int i = 0; i < ec->nb_ports; i++) { <nl>      if (ec->config.link_status.enabled_port_mask & (1 << i)) { <nl>        if (!ec->config.link_status.send_updated || <nl>            ec->link_info[i].status_updated) {
@@ -339,6 +339,9 @@ static int cpu_read (void) <nl>  			submit (cpu, "wait", wait); <nl>  			submit (cpu, "interrupt", intr); <nl>  			submit (cpu, "softirq", sitr); <nl> + <nl> +			if (numfields >= 9) <nl> +				submit (cpu, "steal", atoll (fields[8])); <nl>  		} <nl>  	} <nl>  
@@ -1106,6 +1106,14 @@ static int csnmp_strvbcopy (char *dst, /* {{{ */ <nl>      src = (char *) vb->val.string; <nl>    else if (vb->type == ASN_BIT_STR) <nl>      src = (char *) vb->val.bitstring; <nl> +  else if (vb->type == ASN_IPADDRESS) <nl> +  { <nl> +    return ssnprintf (dst, dst_size, "%d.%d.%d.%d", <nl> +          (uint8_t)vb->val.string[0], <nl> +          (uint8_t)vb->val.string[1], <nl> +          (uint8_t)vb->val.string[2], <nl> +          (uint8_t)vb->val.string[3]); <nl> +  } <nl>    else <nl>    { <nl>      dst[0] = 0; <nl> @@ -1171,7 +1179,7 @@ static int csnmp_instance_list_add (csnmp_list_instances_t **head, <nl>    } <nl>   <nl>    /* Get instance name */ <nl> -  if ((vb->type == ASN_OCTET_STR) || (vb->type == ASN_BIT_STR)) <nl> +  if ((vb->type == ASN_OCTET_STR) || (vb->type == ASN_BIT_STR) || (vb->type == ASN_IPADDRESS)) <nl>    { <nl>      char *ptr; <nl>  
@@ -612,7 +612,8 @@ static void cc_submit (const web_page_t *wp, const web_match_t *wm, /* {{{ */ <nl>    sstrncpy (vl.plugin, "curl", sizeof (vl.plugin)); <nl>    sstrncpy (vl.plugin_instance, wp->instance, sizeof (vl.plugin_instance)); <nl>    sstrncpy (vl.type, wm->type, sizeof (vl.type)); <nl> -  sstrncpy (vl.type_instance, wm->instance, sizeof (vl.type_instance)); <nl> +  if (wm->instance != NULL) <nl> +    sstrncpy (vl.type_instance, wm->instance, sizeof (vl.type_instance)); <nl>   <nl>    plugin_dispatch_values (&vl); <nl>  } /* }}} void cc_submit */
@@ -419,6 +419,9 @@ static int wh_write_command (const data_set_t *ds, const value_list_t *vl, /* {{ <nl>          } <nl>          assert (command_len < cb->send_buffer_free); <nl>   <nl> +        /* Make scan-build happy. */ <nl> +        assert (cb->send_buffer != NULL); <nl> + <nl>          /* `command_len + 1' because `command_len' does not include the <nl>           * trailing null byte. Neither does `send_buffer_fill'. */ <nl>          memcpy (cb->send_buffer + cb->send_buffer_fill,
@@ -16,18 +16,18 @@ <nl>  #ifndef __KRB5_GLUE_H__ <nl>  #define __KRB5_GLUE_H__ <nl>   <nl> -#define krb5_string2qbuf(val) str2qb((val)->string, (val)->length, 1) <nl> +#define krb5_data2qbuf(val) str2qb((val)->data, (val)->length, 1) <nl>   <nl>  #define krb5_kdcoptions2KRB5_KDCOptions(val, err) (struct type_KRB5_KDCOptions *)krb5_flags2KRB5_TicketFlags(val, err) <nl>  #define KRB5_KDCOptions2krb5_kdcoptions(val, err) KRB5_TicketFlags2krb5_flags((struct type_KRB5_TicketFlags *) (val), err) <nl>  #define krb5_apoptions2KRB5_APOptions(val, err) (struct type_KRB5_APOptions *)krb5_flags2KRB5_TicketFlags(val, err) <nl>  #define KRB5_APOptions2krb5_apoptions(val, err) KRB5_TicketFlags2krb5_flags((struct type_KRB5_APOptions *) (val), err) <nl>   <nl> -#define free_krb5_string(val) { xfree((val)->string); xfree(val);} <nl> +#define krb5_free_data(val) { xfree((val)->data); xfree(val);} <nl>   <nl> -#define free_krb5_ap_rep_enc_part xfree <nl> -#define free_krb5_checksum xfree <nl> -#define free_krb5_keyblock xfree <nl> +#define krb5_free_ap_rep_enc_part xfree <nl> +#define krb5_free_checksum xfree <nl> +#define krb5_free_keyblock xfree <nl>   <nl>  /* to keep lint happy */ <nl>  #define xfree(val) free((char *)(val))
@@ -65,7 +65,7 @@ krb5_get_cred_from_kdc (ccache, cred, tgts) <nl>      int nservers; <nl>       <nl>      /* in case we never get a TGT, zero the return */ <nl> -    tgts = 0; <nl> +    *tgts = 0; <nl>   <nl>      /* <nl>       * we know that the desired credentials aren't in the cache yet. <nl> @@ -86,7 +86,8 @@ krb5_get_cred_from_kdc (ccache, cred, tgts) <nl>       */ <nl>      tgtq.client = cred->client; <nl>   <nl> -    if (retval = krb5_tgtname(cred->server, cred->client, &tgtq.server)) <nl> +    if (retval = krb5_tgtname(krb5_princ_realm(cred->client), <nl> +			      krb5_princ_realm(cred->server), &tgtq.server)) <nl>  	return retval; <nl>   <nl>      /* try to fetch it directly */ <nl> @@ -130,12 +131,14 @@ krb5_get_cred_from_kdc (ccache, cred, tgts) <nl>  	    next_server++; <nl>  	    break;			/* found one! */ <nl>  	} <nl> +	krb5_free_realm_tree(tgs_list); <nl>  	/* allocate storage for TGT pointers. */ <nl>  	ret_tgts = (krb5_creds **)calloc(nservers+1, sizeof(krb5_creds)); <nl>  	if (!ret_tgts) { <nl>  	    retval = ENOMEM; <nl>  	    goto out; <nl>  	} <nl> +	*tgts = ret_tgts; <nl>  	for (nservers = 0; next_server; next_server++, nservers++) { <nl>  	    /* now get the TGTs */ <nl>  	    tgtq.times = tgt.times;
@@ -1190,8 +1190,12 @@ dump_db(argc, argv) <nl>  	     exit_status++; <nl>  	} <nl>  	if (ofile && f != stdout && !exit_status) { <nl> -	     fclose(f); <nl> -	     update_ok_file(ofile); <nl> +	    if (locked) { <nl> +		(void) krb5_lock_file(util_context, fileno(f), KRB5_LOCKMODE_UNLOCK); <nl> +		locked = 0; <nl> +	    } <nl> +	    fclose(f); <nl> +	    update_ok_file(ofile); <nl>  	} <nl>      } <nl>      if (locked)
@@ -35,8 +35,9 @@ krb5_ktfile_close(id) <nl>     * This routine should undo anything done by krb5_ktfile_resolve(). <nl>     */ <nl>  { <nl> -    (void) free(KTFILENAME(id)); <nl> -    (void) free((krb5_pointer)(id)->data); <nl> +    xfree(KTFILENAME(id)); <nl> +    xfree(id->data); <nl>      id->ops = 0; <nl> +    xfree(id); <nl>      return (0); /* XXX */ <nl>  }
@@ -309,9 +309,9 @@ krb5_keyblock *masterkeyblock; <nl>      /* the master key name here is from the master_princ global, <nl>         so we can safely share its substructure */ <nl>   <nl> -    tgs_server[0] = krb5_princ_realm(masterkeyname); <nl> +    krb5_princ_set_realm(tgs_server, krb5_princ_realm(masterkeyname)); <nl>      /* tgs_server[1] is init data */ <nl> -    tgs_server[2] = krb5_princ_realm(masterkeyname); <nl> +    *krb5_princ_component(tgs_server, 2) = *krb5_princ_realm(masterkeyname); <nl>      /* tgs_server[3] is init data (0) */ <nl>   <nl>      nprincs = 1;
@@ -29,6 +29,8 @@ krb5_kdc_req *val; <nl>  	krb5_free_principal(val->client); <nl>      if (val->server) <nl>  	krb5_free_principal(val->server); <nl> +    if (val->etype) <nl> +	xfree(val->etype); <nl>      if (val->addresses) <nl>  	krb5_free_address(val->addresses); <nl>      if (val->authorization_data.ciphertext.data)
@@ -31,6 +31,8 @@ strdup(str) <nl>  	int len; <nl>  	char *copy; <nl>   <nl> +	if (!str) <nl> +		return((char *)0); <nl>  	len = strlen(str) + 1; <nl>  	if (!(copy = malloc((u_int)len))) <nl>  		return((char *)0);
@@ -520,9 +520,9 @@ do_ccache(krb5_ccache cache) <nl>          return 1; <nl>      } <nl>      while (!(code = krb5_cc_next_cred(kcontext, cache, &cur, &creds))) { <nl> -        if (!show_config && krb5_is_config_principal(kcontext, creds.server)) <nl> -            continue; <nl> -        if (status_only) { <nl> +        if (!show_config && krb5_is_config_principal(kcontext, creds.server)) { <nl> +            /* Do nothing with this entry. */ <nl> +        } else if (status_only) { <nl>              if (exit_status && creds.server->length == 2 && <nl>                  data_eq(creds.server->realm, princ->realm) && <nl>                  data_eq_string(creds.server->data[0], "krbtgt") && <nl> @@ -556,6 +556,7 @@ do_ccache(krb5_ccache cache) <nl>              com_err(progname, code, _("while retrieving a ticket")); <nl>          return 1; <nl>      } <nl> +    krb5_free_principal(kcontext, princ); <nl>  } <nl>   <nl>  char *
@@ -204,6 +204,11 @@ process_tgs_req(krb5_kdc_req *request, krb5_data *pkt, <nl>          status = "FIND_FAST"; <nl>          goto cleanup; <nl>      } <nl> +    if (sprinc == NULL) { <nl> +        status = "NULL_SERVER"; <nl> +        errcode = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN; <nl> +        goto cleanup; <nl> +    } <nl>   <nl>      errcode = get_local_tgt(kdc_context, &sprinc->realm, header_server, <nl>                              &local_tgt, &local_tgt_storage, &local_tgt_key);
@@ -279,7 +279,7 @@ void doit(fd) <nl>  		exit(1); <nl>  	} <nl>  	omask = umask(077); <nl> -	lock_fd = fopen(temp_file_name, O_RDONLY); <nl> +	lock_fd = open(temp_file_name, O_RDONLY, 0600); <nl>  	(void) umask(omask); <nl>  	retval = krb5_lock_file(kpropd_context, lock_fd,  <nl>  				KRB5_LOCKMODE_EXCLUSIVE|KRB5_LOCKMODE_DONTBLOCK);
@@ -150,7 +150,7 @@ template int SSLWrap<TLSCallbacks>::TLSExtStatusCallback(SSL* s, void* arg); <nl>   <nl>   <nl>  static void crypto_threadid_cb(CRYPTO_THREADID* tid) { <nl> -  static_assert(sizeof(uv_thread_t) <= sizeof(void*), <nl> +  static_assert(sizeof(uv_thread_t) <= sizeof(void*),  // NOLINT(runtime/sizeof) <nl>                  "uv_thread_t does not fit in a pointer"); <nl>    CRYPTO_THREADID_set_pointer(tid, reinterpret_cast<void*>(uv_thread_self())); <nl>  }
@@ -65,8 +65,9 @@ void Watchdog::Destroy() { <nl>  void Watchdog::Run(void* arg) { <nl>    Watchdog* wd = static_cast<Watchdog*>(arg); <nl>   <nl> -  // UV_RUN_ONCE so async_ or timer_ wakeup exits uv_run() call. <nl> -  uv_run(wd->loop_, UV_RUN_ONCE); <nl> +  // UV_RUN_DEFAULT the loop will be stopped either by the async or the <nl> +  // timer handle. <nl> +  uv_run(wd->loop_, UV_RUN_DEFAULT); <nl>   <nl>    // Loop ref count reaches zero when both handles are closed. <nl>    // Close the timer handle on this side and let Destroy() close async_ <nl> @@ -75,11 +76,14 @@ void Watchdog::Run(void* arg) { <nl>   <nl>   <nl>  void Watchdog::Async(uv_async_t* async) { <nl> +  Watchdog* w = ContainerOf(&Watchdog::async_, async); <nl> +  uv_stop(w->loop_); <nl>  } <nl>   <nl>   <nl>  void Watchdog::Timer(uv_timer_t* timer) { <nl>    Watchdog* w = ContainerOf(&Watchdog::timer_, timer); <nl> +  uv_stop(w->loop_); <nl>    V8::TerminateExecution(w->env()->isolate()); <nl>  } <nl>  
@@ -305,6 +305,7 @@ void TLSWrap::EncOut() { <nl>    for (size_t i = 0; i < count; i++) <nl>      buf[i] = uv_buf_init(data[i], size[i]); <nl>    int r = stream_->DoWrite(write_req, buf, count, nullptr); <nl> +  write_req->Dispatched(); <nl>   <nl>    // Ignore errors, this should be already handled in js <nl>    if (!r) <nl> @@ -314,6 +315,8 @@ void TLSWrap::EncOut() { <nl>   <nl>  void TLSWrap::EncOutCb(WriteWrap* req_wrap, int status) { <nl>    TLSWrap* wrap = req_wrap->wrap()->Cast<TLSWrap>(); <nl> +  req_wrap->~WriteWrap(); <nl> +  delete[] reinterpret_cast<char*>(req_wrap); <nl>   <nl>    // Handle error <nl>    if (status) {
@@ -4011,7 +4011,9 @@ void RandomBytesCheck(RandomBytesRequest* req, Local<Value> argv[2]) { <nl>      Buffer* buffer = Buffer::New(req->data_, req->size_, RandomBytesFree, NULL); <nl>      argv[0] = Local<Value>::New(Null()); <nl>      argv[1] = Local<Object>::New(buffer->handle_); <nl> +    req->data_ = NULL; <nl>    } <nl> +  free(req->data_); <nl>  } <nl>   <nl>  
@@ -1034,7 +1034,7 @@ static int pdf_extract_obj(struct pdf_struct *pdf, struct pdf_obj *obj) <nl>  		    n -= q2 - q; <nl>  		    q = q2; <nl>  		} <nl> -	    } while (n > 0 && q2 && q2[-1] == '\\'); <nl> +	    } while (n > 0 && q2 && q2[-2] == '\\'); <nl>  	    if (q2) <nl>  		end = q2-1; <nl>  	    n = end - out;
@@ -2372,6 +2372,7 @@ inline static int ac_special_altstr(const char *hexpr, uint8_t sigopts, struct c <nl>          /* allocate reusable subexpr */ <nl>          if (!(subexpr = cli_calloc(slen+1, sizeof(char)))) { <nl>              cli_errmsg("ac_special_altstr: Can't allocate subexpr container\n"); <nl> +            free(hexprcpy); <nl>              return CL_EMEM; <nl>          } <nl>  
@@ -344,7 +344,7 @@ try_pacemaker(int command, enum cluster_type_e stack) <nl>          case 'p': <nl>              /* Go to pacemakerd */ <nl>              { <nl> -                GMainLoop *amainloop = g_main_new(FALSE); <nl> +                GMainLoop *amainloop = g_main_loop_new(NULL, FALSE); <nl>                  mainloop_io_t *ipc = <nl>                      mainloop_add_ipc_client(CRM_SYSTEM_MCP, G_PRIORITY_DEFAULT, 0, NULL, &node_callbacks); <nl>                  if (ipc != NULL) {
@@ -559,7 +559,7 @@ cib_perform_op(const char *op, int call_options, cib_op_t *fn, gboolean is_query <nl>   <nl>      if(rc == cib_ok && scratch) { <nl>  	const char *new_version = crm_element_value(scratch, XML_ATTR_CRM_VERSION); <nl> -	if(new_version && compare_version(new_version, CRM_FEATURE_SET) < 0) { <nl> +	if(new_version && compare_version(new_version, CRM_FEATURE_SET) > 0) { <nl>  	    crm_err("Discarding update with feature set '%s' greater than our own '%s'", <nl>  		    new_version, CRM_FEATURE_SET); <nl>  	    rc = cib_NOTSUPPORTED;
@@ -386,6 +386,7 @@ static int __xml_build_schema_list(void) <nl>                      xslt = get_schema_path(NULL, transform); <nl>                      if(stat(xslt, &s) != 0) { <nl>                          crm_err("Transform %s not found", xslt); <nl> +                        free(xslt); <nl>                          __xml_schema_add(2, version, NULL, NULL, NULL, -1); <nl>                          break; <nl>                      } else {
@@ -1430,7 +1430,6 @@ update_dataset(cib_t *cib, pe_working_set_t * data_set, bool simulate) <nl>              goto cleanup; <nl>          } <nl>   <nl> -        free(pid); <nl>          rc = write_xml_file(cib_xml_copy, shadow_file, FALSE); <nl>   <nl>          if (rc < 0) {
@@ -421,7 +421,9 @@ gio_poll_dispatch_del(int32_t fd) <nl>      crm_trace("Looking for fd=%d", fd); <nl>      if (qb_array_index(gio_map, fd, (void**)&adaptor) == 0) { <nl>          crm_trace("Marking adaptor %p unused", adaptor); <nl> -        g_io_channel_unref(adaptor->channel); <nl> +        if(adaptor->channel) { <nl> +            g_io_channel_unref(adaptor->channel); <nl> +        } <nl>          adaptor->is_used = QB_FALSE; <nl>      } <nl>      return 0; <nl> @@ -478,7 +480,9 @@ qb_ipcs_service_t *mainloop_add_ipc_server( <nl>   <nl>  void mainloop_del_ipc_server(qb_ipcs_service_t *server)  <nl>  { <nl> -    qb_ipcs_destroy(server); <nl> +    if(server) { <nl> +        qb_ipcs_destroy(server); <nl> +    } <nl>  } <nl>   <nl>  struct mainloop_io_s
@@ -678,10 +678,11 @@ filename2xml(const char *filename) <nl>  { <nl>      xmlNode *xml = NULL; <nl>      xmlDocPtr output = NULL; <nl> +    const char *match = NULL; <nl>      xmlParserCtxtPtr ctxt = NULL; <nl>      xmlErrorPtr last_error = NULL; <nl>      static int xml_options = XML_PARSE_NOBLANKS|XML_PARSE_RECOVER; <nl> -     <nl> + <nl>      /* create a parser context */ <nl>      ctxt = xmlNewParserCtxt(); <nl>      CRM_CHECK(ctxt != NULL, return NULL); <nl> @@ -692,11 +693,15 @@ filename2xml(const char *filename) <nl>      xmlSetGenericErrorFunc(ctxt, crm_xml_err); <nl>      /* initGenericErrorDefaultFunc(crm_xml_err); */ <nl>   <nl> +    if(filename) { <nl> +        match = strstr(filename, ".bz2"); <nl> +    } <nl> + <nl>      if(filename == NULL) { <nl>  	/* STDIN_FILENO == fileno(stdin) */ <nl>  	output = xmlCtxtReadFd(ctxt, STDIN_FILENO, "unknown.xml", NULL, xml_options); <nl>   <nl> -    } else if(strstr(filename, ".bz2") == NULL) { <nl> +    } else if(match == NULL || match[4] != 0) { <nl>  	output = xmlCtxtReadFile(ctxt, filename, NULL, xml_options); <nl>   <nl>      } else {
@@ -455,7 +455,7 @@ crm_ipc_read(crm_ipc_t *client) <nl>      crm_trace("Message recieved on %s IPC connection", client->name); <nl>   <nl>      client->buffer[0] = 0; <nl> -    client->msg_size = qb_ipcc_event_recv(client->ipc, client->buffer, client->buf_size-1, 100); <nl> +    client->msg_size = qb_ipcc_event_recv(client->ipc, client->buffer, client->buf_size-1, 0); <nl>      if(client->msg_size >= 0) { <nl>          struct qb_ipc_response_header *header = (struct qb_ipc_response_header *)client->buffer; <nl>          client->buffer[client->msg_size] = 0;
@@ -440,6 +440,8 @@ crm_graph_functions_t te_graph_fns = { <nl>  	te_fence_node <nl>  }; <nl>   <nl> +extern GMainLoop*  mainloop; <nl> + <nl>  void <nl>  notify_crmd(crm_graph_t *graph) <nl>  {	 <nl> @@ -471,6 +473,10 @@ notify_crmd(crm_graph_t *graph) <nl>   <nl>  		case tg_shutdown: <nl>  			crm_info("Exiting after transition"); <nl> +			if (mainloop != NULL && g_main_is_running(mainloop)) { <nl> +				g_main_quit(mainloop); <nl> +				return; <nl> +			} <nl>  			exit(LSB_EXIT_OK); <nl>  	} <nl>  
@@ -1,4 +1,4 @@ <nl> -/* $Id: callbacks.c,v 1.70 2005/06/27 08:22:01 andrew Exp $ */ <nl> +/* $Id: callbacks.c,v 1.71 2005/06/28 08:11:07 andrew Exp $ */ <nl>  /*  <nl>   * Copyright (C) 2004 Andrew Beekhof <andrew@beekhof.net> <nl>   *  <nl> @@ -578,8 +578,7 @@ cib_process_request(const HA_Message *request, gboolean privileged, <nl>  		crm_debug_3("Processing complete"); <nl>   <nl>  		if(rc == cib_diff_resync || rc == cib_diff_failed <nl> -/* 		   || rc == cib_old_data */ <nl> -			) { <nl> +		   || rc == cib_old_data) { <nl>  			crm_warn("%s operation failed: %s", <nl>  				crm_str(op), cib_error2string(rc)); <nl>  			
@@ -3049,6 +3049,12 @@ MigrateRsc(resource_t * rsc, action_t * stop, action_t * start, pe_working_set_t <nl>          to = custom_action(rsc, generate_op_key(rsc->id, RSC_MIGRATE, 0), RSC_MIGRATE, stop->node, <nl>                             FALSE, TRUE, data_set); <nl>   <nl> +        /* migrate_to takes place on the source node, but can  <nl> +         * have an effect on the target node depending on how <nl> +         * the agent is written. Because of this, we have to maintain <nl> +         * a record that the migrate_to occurred incase the source node  <nl> +         * loses membership while the migrate_to action is still in-flight. */ <nl> +        add_hash_param(to->meta, XML_OP_ATTR_PENDING, "true"); <nl>          for (gIter = rsc->dangling_migrations; gIter != NULL; gIter = gIter->next) { <nl>              node_t *current = (node_t *) gIter->data; <nl>              action_t *stop = stop_action(rsc, current, FALSE);
@@ -375,6 +375,8 @@ public: <nl>      }; <nl>      typedef std::set<txiter, CompareIteratorByHash> setEntries; <nl>   <nl> +    const setEntries & GetMemPoolParents(txiter entry) const; <nl> +    const setEntries & GetMemPoolChildren(txiter entry) const; <nl>  private: <nl>      typedef std::map<txiter, setEntries, CompareIteratorByHash> cacheMap; <nl>   <nl> @@ -386,8 +388,6 @@ private: <nl>      typedef std::map<txiter, TxLinks, CompareIteratorByHash> txlinksMap; <nl>      txlinksMap mapLinks; <nl>   <nl> -    const setEntries & GetMemPoolParents(txiter entry) const; <nl> -    const setEntries & GetMemPoolChildren(txiter entry) const; <nl>      void UpdateParent(txiter entry, txiter parent, bool add); <nl>      void UpdateChild(txiter entry, txiter child, bool add); <nl>  
@@ -940,6 +940,11 @@ void ServiceConnection(AcceptedConnection *conn) <nl>          // Read HTTP message headers and body <nl>          ReadHTTPMessage(conn->stream(), mapHeaders, strRequest, nProto); <nl>   <nl> +        if (strURI != "/") { <nl> +            conn->stream() << HTTPReply(HTTP_NOT_FOUND, "", false) << std::flush; <nl> +            break; <nl> +        } <nl> + <nl>          // Check authorization <nl>          if (mapHeaders.count("authorization") == 0) <nl>          {
@@ -427,6 +427,14 @@ int git_pkt_parse_line( <nl>  	if (bufflen > 0 && bufflen < (size_t)len) <nl>  		return GIT_EBUFS; <nl>   <nl> +	/* <nl> +	 * The length has to be exactly 0 in case of a flush <nl> +	 * packet or greater than PKT_LEN_SIZE, as the decoded <nl> +	 * length includes its own encoded length of four bytes. <nl> +	 */ <nl> +	if (len != 0 && len < PKT_LEN_SIZE) <nl> +		return GIT_ERROR; <nl> + <nl>  	line += PKT_LEN_SIZE; <nl>  	/* <nl>  	 * TODO: How do we deal with empty lines? Try again? with the next
@@ -295,6 +295,7 @@ void git_remote_disconnect(git_remote *remote) <nl>  			remote->transport->close(remote->transport); <nl>   <nl>  		remote->transport->free(remote->transport); <nl> +		remote->transport = NULL; <nl>  	} <nl>  } <nl>  
@@ -181,6 +181,9 @@ void git_branch_iterator_free(git_branch_iterator *_iter) <nl>  { <nl>  	branch_iter *iter = (branch_iter *) _iter; <nl>   <nl> +	if (iter == NULL) <nl> +		return; <nl> + <nl>  	git_reference_iterator_free(iter->iter); <nl>  	git__free(iter); <nl>  }
@@ -74,6 +74,7 @@ int git_blob_rawsize(git_blob *blob) <nl>  void git_blob__free(git_blob *blob) <nl>  { <nl>  	gitfo_free_buf(&blob->content); <nl> +	free(blob); <nl>  } <nl>   <nl>  int git_blob__parse(git_blob *blob)
@@ -219,6 +219,10 @@ int git_openssl_stream_global_init(void) <nl>  	 * to speak TLSv1 to perform the encryption itself. <nl>  	 */ <nl>  	git__ssl_ctx = SSL_CTX_new(SSLv23_method()); <nl> +	if (!git__ssl_ctx) { <nl> +		return -1; <nl> +	} <nl> + <nl>  	SSL_CTX_set_options(git__ssl_ctx, ssl_opts); <nl>  	SSL_CTX_set_mode(git__ssl_ctx, SSL_MODE_AUTO_RETRY); <nl>  	SSL_CTX_set_verify(git__ssl_ctx, SSL_VERIFY_NONE, NULL);
@@ -1209,9 +1209,10 @@ static struct store *imap_open_store(struct imap_server_conf *srvc) <nl>  			goto bail; <nl>  		} <nl>  		if (!srvc->pass) { <nl> -			char prompt[80]; <nl> -			sprintf(prompt, "Password (%s@%s): ", srvc->user, srvc->host); <nl> -			arg = git_getpass(prompt); <nl> +			struct strbuf prompt = STRBUF_INIT; <nl> +			strbuf_addf(&prompt, "Password (%s@%s): ", srvc->user, srvc->host); <nl> +			arg = git_getpass(prompt.buf); <nl> +			strbuf_release(&prompt); <nl>  			if (!arg) { <nl>  				perror("getpass"); <nl>  				exit(1);
@@ -180,7 +180,7 @@ static int write_tar_entry(struct archiver_args *args, <nl>   <nl>  	sprintf(header.mode, "%07o", mode & 07777); <nl>  	sprintf(header.size, "%011lo", S_ISREG(mode) ? size : 0); <nl> -	sprintf(header.mtime, "%011lo", args->time); <nl> +	sprintf(header.mtime, "%011lo", (unsigned long) args->time); <nl>   <nl>  	sprintf(header.uid, "%07o", 0); <nl>  	sprintf(header.gid, "%07o", 0);
@@ -2234,12 +2234,12 @@ static int verify_lock(struct ref_lock *lock, <nl>  			  mustexist ? RESOLVE_REF_READING : 0, <nl>  			  lock->old_sha1, NULL)) { <nl>  		int save_errno = errno; <nl> -		strbuf_addf(err, "Can't verify ref %s", lock->ref_name); <nl> +		strbuf_addf(err, "can't verify ref %s", lock->ref_name); <nl>  		errno = save_errno; <nl>  		return -1; <nl>  	} <nl>  	if (hashcmp(lock->old_sha1, old_sha1)) { <nl> -		strbuf_addf(err, "Ref %s is at %s but expected %s", <nl> +		strbuf_addf(err, "ref %s is at %s but expected %s", <nl>  			    lock->ref_name, <nl>  			    sha1_to_hex(lock->old_sha1), <nl>  			    sha1_to_hex(old_sha1));
@@ -116,6 +116,8 @@ void mark_parents_uninteresting(struct commit *commit) <nl>   <nl>  void add_pending_object(struct rev_info *revs, struct object *obj, const char *name) <nl>  { <nl> +	if (revs->no_walk && (obj->flags & UNINTERESTING)) <nl> +		die("object ranges do not make sense when not walking revisions"); <nl>  	add_object_array(obj, name, &revs->pending); <nl>  	if (revs->reflog_info && obj->type == OBJ_COMMIT) <nl>  		add_reflog_for_walk(revs->reflog_info,
@@ -30,7 +30,7 @@ static int write_tree(struct cache_entry **cachep, int maxentries, const char *b <nl>  	offset = 0; <nl>   <nl>  	nr = 0; <nl> -	do { <nl> +	while (nr < maxentries) { <nl>  		struct cache_entry *ce = cachep[nr]; <nl>  		const char *pathname = ce->name, *filename, *dirname; <nl>  		int pathlen = ce_namelen(ce), entrylen; <nl> @@ -75,7 +75,7 @@ static int write_tree(struct cache_entry **cachep, int maxentries, const char *b <nl>  		memcpy(buffer + offset, sha1, 20); <nl>  		offset += 20; <nl>  		nr++; <nl> -	} while (nr < maxentries); <nl> +	} <nl>   <nl>  	write_sha1_file(buffer, offset, "tree", returnsha1); <nl>  	free(buffer); <nl> @@ -88,8 +88,8 @@ int main(int argc, char **argv) <nl>  	int entries = read_cache(); <nl>  	unsigned char sha1[20]; <nl>   <nl> -	if (entries <= 0) <nl> -		die("write-tree: no cache contents to write"); <nl> +	if (entries < 0) <nl> +		die("write-tree: error reading cache"); <nl>   <nl>  	/* Verify that the tree is merged */ <nl>  	unmerged = 0;
@@ -658,7 +658,7 @@ static int fetch_indices(struct alt_base *repo) <nl>  		switch (data[i]) { <nl>  		case 'P': <nl>  			i++; <nl> -			if (i + 52 < buffer.posn && <nl> +			if (i + 52 <= buffer.posn && <nl>  			    !strncmp(data + i, " pack-", 6) && <nl>  			    !strncmp(data + i + 46, ".pack\n", 6)) { <nl>  				get_sha1_hex(data + i + 6, sha1); <nl> @@ -667,7 +667,7 @@ static int fetch_indices(struct alt_base *repo) <nl>  				break; <nl>  			} <nl>  		default: <nl> -			while (data[i] != '\n') <nl> +			while (i < buffer.posn && data[i] != '\n') <nl>  				i++; <nl>  		} <nl>  		i++;
@@ -1337,7 +1337,7 @@ static int try_delta(struct unpacked *trg, struct unpacked *src, <nl>  	if (max_size == 0) <nl>  		return 0; <nl>  	if (trg_entry->delta && trg_entry->delta_size <= max_size) <nl> -		max_size = trg_entry->delta_size-1; <nl> +		max_size = trg_entry->delta_size; <nl>  	src_size = src_entry->size; <nl>  	sizediff = src_size < trg_size ? trg_size - src_size : 0; <nl>  	if (sizediff >= max_size) <nl> @@ -1371,6 +1371,12 @@ static int try_delta(struct unpacked *trg, struct unpacked *src, <nl>  		return 0; <nl>   <nl>  	if (trg_entry->delta_data) { <nl> +		/* Prefer only shallower same-sized deltas. */ <nl> +		if (delta_size == trg_entry->delta_size && <nl> +		    src_entry->depth + 1 >= trg_entry->depth) { <nl> +			free(delta_buf); <nl> +			return 0; <nl> +		} <nl>  		delta_cache_size -= trg_entry->delta_size; <nl>  		free(trg_entry->delta_data); <nl>  	}
@@ -154,6 +154,7 @@ static void copy_templates(const char *git_dir, int len, char *template_dir) <nl>  	} <nl>   <nl>  	memcpy(path, git_dir, len); <nl> +	path[len] = 0; <nl>  	copy_templates_1(path, len, <nl>  			 template_path, template_len, <nl>  			 dir);
@@ -13,17 +13,19 @@ int track_object_refs = 1; <nl>   <nl>  static int hashtable_index(const unsigned char *sha1) <nl>  { <nl> -	unsigned int i = *(unsigned int *)sha1; <nl> +	unsigned int i; <nl> +	memcpy(&i, sha1, sizeof(unsigned int)); <nl>  	return (int)(i % obj_allocs); <nl>  } <nl>   <nl>  static int find_object(const unsigned char *sha1) <nl>  { <nl> -	int i = hashtable_index(sha1); <nl> +	int i; <nl>   <nl>  	if (!objs) <nl>  		return -1; <nl>   <nl> +	i = hashtable_index(sha1); <nl>  	while (objs[i]) { <nl>  		if (memcmp(sha1, objs[i]->sha1, 20) == 0) <nl>  			return i;
@@ -1461,6 +1461,13 @@ arc_buf_info(arc_buf_t *ab, arc_buf_info_t *abi, int state_index) <nl>  	l2arc_buf_hdr_t *l2hdr = NULL; <nl>  	arc_state_t *state = NULL; <nl>   <nl> +	memset(abi, 0, sizeof (arc_buf_info_t)); <nl> + <nl> +	if (hdr == NULL) <nl> +		return; <nl> + <nl> +	abi->abi_flags = hdr->b_flags; <nl> + <nl>  	if (HDR_HAS_L1HDR(hdr)) { <nl>  		l1hdr = &hdr->b_l1hdr; <nl>  		state = l1hdr->b_state; <nl> @@ -1468,9 +1475,6 @@ arc_buf_info(arc_buf_t *ab, arc_buf_info_t *abi, int state_index) <nl>  	if (HDR_HAS_L2HDR(hdr)) <nl>  		l2hdr = &hdr->b_l2hdr; <nl>   <nl> -	memset(abi, 0, sizeof (arc_buf_info_t)); <nl> -	abi->abi_flags = hdr->b_flags; <nl> - <nl>  	if (l1hdr) { <nl>  		abi->abi_datacnt = l1hdr->b_datacnt; <nl>  		abi->abi_access = l1hdr->b_arc_access;
@@ -3447,13 +3447,15 @@ int <nl>  zfs_destroy_snaps_nvl(libzfs_handle_t *hdl, nvlist_t *snaps, boolean_t defer) <nl>  { <nl>  	int ret; <nl> -	nvlist_t *errlist; <nl> +	nvlist_t *errlist = NULL; <nl>  	nvpair_t *pair; <nl>   <nl>  	ret = lzc_destroy_snaps(snaps, defer, &errlist); <nl>   <nl> -	if (ret == 0) <nl> +	if (ret == 0) { <nl> +		nvlist_free(errlist); <nl>  		return (0); <nl> +	} <nl>   <nl>  	if (nvlist_empty(errlist)) { <nl>  		char errbuf[1024]; <nl> @@ -3481,6 +3483,7 @@ zfs_destroy_snaps_nvl(libzfs_handle_t *hdl, nvlist_t *snaps, boolean_t defer) <nl>  		} <nl>  	} <nl>   <nl> +	nvlist_free(errlist); <nl>  	return (ret); <nl>  } <nl>  
@@ -438,7 +438,7 @@ traverse_dnode(traverse_data_t *td, const dnode_phys_t *dnp, <nl>  			break; <nl>  	} <nl>   <nl> -	if (dnp->dn_flags & DNODE_FLAG_SPILL_BLKPTR) { <nl> +	if (err == 0 && dnp->dn_flags & DNODE_FLAG_SPILL_BLKPTR) { <nl>  		SET_BOOKMARK(&czb, objset, object, 0, DMU_SPILL_BLKID); <nl>  		err = traverse_visitbp(td, dnp, &dnp->dn_spill, &czb); <nl>  	}
@@ -15,6 +15,7 @@ <nl>  #include "auth-common.h" <nl>  #include "client.h" <nl>  #include "client-authenticate.h" <nl> +#include "ssl-proxy.h" <nl>   <nl>  static enum auth_mech auth_mechs = 0; <nl>  static char *auth_mechs_capability = NULL; <nl> @@ -45,6 +46,7 @@ int cmd_capa(struct pop3_client *client, const char *args __attr_unused__) <nl>  	} <nl>   <nl>  	client_send_line(client, t_strconcat("+OK\r\n" POP3_CAPABILITY_REPLY, <nl> +					     ssl_initialized ? "STLS\r\n" : "", <nl>  					     auth_mechs_capability, <nl>  					     "\r\n.", NULL)); <nl>  	return TRUE;
@@ -734,6 +734,8 @@ void master_service_deinit(struct master_service **_service) <nl>  	lib_signals_deinit(); <nl>  	io_loop_destroy(&service->ioloop); <nl>   <nl> +	if (service->listener_names != NULL) <nl> +		p_strsplit_free(default_pool, service->listener_names); <nl>  	i_free(service->listeners); <nl>  	i_free(service->getopt_str); <nl>  	i_free(service->name);
@@ -93,6 +93,7 @@ struct imap_fetch_context *imap_fetch_init(struct client *client) <nl>  	ctx->seen_flag.flags = MAIL_SEEN; <nl>  	ctx->all_headers_buf = buffer_create_dynamic(client->cmd_pool, 128); <nl>  	ctx->handlers = buffer_create_dynamic(client->cmd_pool, 128); <nl> +	ctx->line_finished = TRUE; <nl>  	return ctx; <nl>  } <nl>   <nl> @@ -152,7 +153,6 @@ void imap_fetch_begin(struct imap_fetch_context *ctx, <nl>  	ctx->search_ctx = <nl>  		mailbox_search_init(ctx->trans, NULL, search_arg, NULL, <nl>  				    ctx->fetch_data, ctx->all_headers_ctx); <nl> -	ctx->line_finished = TRUE; <nl>  } <nl>   <nl>  int imap_fetch(struct imap_fetch_context *ctx)
@@ -416,7 +416,7 @@ void smtp_server_connection_data_chunk_init(struct smtp_server_cmd_ctx *cmd) <nl>  	command->hook_replied = cmd_data_chunk_replied; <nl>  	command->hook_destroy = cmd_data_destroy; <nl>   <nl> -	if (conn->state.data_chain == NULL) { <nl> +	if (!conn->state.data_failed && conn->state.data_chain == NULL) { <nl>  		i_assert(data_cmd->chunk_first); <nl>  		i_assert(conn->state.data_chain_input == NULL); <nl>  		conn->state.data_chain_input =
@@ -134,6 +134,7 @@ int hash_format_init(const char *format_string, struct hash_format **format_r, <nl>  	} T_END; <nl>  	if (ret < 0) { <nl>  		*error_r = t_strdup(*error_r); <nl> +		pool_unref(&pool); <nl>  		return -1; <nl>  	} <nl>  	*format_r = format;
@@ -224,7 +224,7 @@ tview_return_updated_ext(struct mail_index_view_transaction *tview, <nl>  		} <nl>  	} <nl>   <nl> -	if (ext->record_align <= sizeof(uint32_t)) { <nl> +	if (record_align <= sizeof(uint32_t)) { <nl>  		/* data is 32bit aligned already */ <nl>  		return data; <nl>  	} else { <nl> @@ -233,10 +233,9 @@ tview_return_updated_ext(struct mail_index_view_transaction *tview, <nl>  		if (tview->lookup_return_data == NULL) { <nl>  			tview->lookup_return_data = <nl>  				buffer_create_dynamic(default_pool, <nl> -						      ext->record_size + 64); <nl> +						      record_size + 64); <nl>  		} <nl> -		buffer_write(tview->lookup_return_data, <nl> -			     0, data, ext->record_size); <nl> +		buffer_write(tview->lookup_return_data, 0, data, record_size); <nl>  		return tview->lookup_return_data->data; <nl>  	} <nl>  }
@@ -1630,6 +1630,9 @@ squat_trie_lookup_real(struct squat_trie *trie, const char *str, <nl>  	unsigned int i, start, bytes, str_bytelen, str_charlen; <nl>  	int ret = 0; <nl>   <nl> +	array_clear(definite_uids); <nl> +	array_clear(maybe_uids); <nl> + <nl>  	memset(&ctx, 0, sizeof(ctx)); <nl>  	ctx.trie = trie; <nl>  	ctx.type = type;
@@ -680,8 +680,8 @@ DOVEADM_CMD_PARAMS_END <nl>   <nl>  struct doveadm_cmd_ver2 doveadm_cmd_mailbox_delete_ver2 = { <nl>  	.name = "mailbox delete", <nl> -        .mail_cmd = cmd_mailbox_delete_alloc, <nl> -        .usage = DOVEADM_CMD_MAIL_USAGE_PREFIX"[-s] <mailbox> [...]", <nl> +	.mail_cmd = cmd_mailbox_delete_alloc, <nl> +	.usage = DOVEADM_CMD_MAIL_USAGE_PREFIX"[-s] <mailbox> [...]", <nl>  DOVEADM_CMD_PARAMS_START <nl>  DOVEADM_CMD_MAIL_COMMON <nl>  DOVEADM_CMD_PARAM('s', "subscriptions", CMD_PARAM_BOOL, 0)
@@ -62,6 +62,12 @@ expire_env_parse(struct expire_env *env, struct mail_namespace *namespaces, <nl>  		box.type = type; <nl>  		box.expire_secs = strtoul(names[1], NULL, 10) * 3600 * 24; <nl>   <nl> +		if (getenv("DEBUG") != NULL) { <nl> +			i_info("expire: pattern=%s type=%s secs=%u", <nl> +			       box.pattern, type == EXPIRE_TYPE_EXPUNGE ? <nl> +			       "expunge" : "altmove", box.expire_secs); <nl> +		} <nl> + <nl>  		array_append(&env->expire_boxes, &box, 1); <nl>  	} <nl>  }
@@ -1167,7 +1167,7 @@ static int maildir_sync_context(struct maildir_sync_context *ctx, int forced, <nl>  			return -1; <nl>   <nl>  		if (!new_changed && !cur_changed) <nl> -			return 0; <nl> +			return 1; <nl>  	} else { <nl>  		new_changed = cur_changed = TRUE; <nl>  	}
@@ -1283,6 +1283,11 @@ dsync_mailbox_import_match_msg(struct dsync_mailbox_importer *importer, <nl>  	/* verify hdr_hash if it exists */ <nl>  	if (change->hdr_hash == NULL) { <nl>  		i_assert(*importer->cur_guid == '\0'); <nl> +		if (change->type == DSYNC_MAIL_CHANGE_TYPE_EXPUNGE) { <nl> +			/* the message was already expunged, so we don't know <nl> +			   its header. return "unknown". */ <nl> +			return -1; <nl> +		} <nl>  		i_error("Mailbox %s: GUIDs not supported, " <nl>  			"sync with header hashes instead", <nl>  			mailbox_get_vname(importer->box));
@@ -34,7 +34,7 @@ <nl>  #include <sys/un.h> <nl>  #include <sys/uio.h> <nl>   <nl> -#if defined (__sun__) && !defined(CMSG_SPACE) <nl> +#ifndef CMSG_SPACE <nl>  #  define CMSG_ALIGN(len) \ <nl>  	(((len) + sizeof(size_t) - 1) & ~(sizeof(size_t) - 1)) <nl>  #  define CMSG_SPACE(len) \
@@ -370,7 +370,8 @@ static int auth_master_run_cmd(struct auth_master_connection *conn, <nl>  		io_loop_run(conn->ioloop); <nl>  	} <nl>   <nl> -	auth_master_unset_io(conn, prev_ioloop); <nl> +	if (prev_ioloop != NULL) <nl> +		auth_master_unset_io(conn, prev_ioloop); <nl>  	if (conn->aborted) { <nl>  		conn->aborted = FALSE; <nl>  		auth_connection_close(conn);
@@ -731,7 +731,7 @@ mail_storage_service_init_post(struct mail_storage_service_ctx *ctx, <nl>  			if (errno == EACCES) { <nl>  				i_error("%s", eacces_error_get("chdir", <nl>  						t_strconcat(home, "/", NULL))); <nl> -			} if (errno != ENOENT) <nl> +			} else if (errno != ENOENT) <nl>  				i_error("chdir(%s) failed: %m", home); <nl>  			else if (mail_set->mail_debug) <nl>  				i_debug("Home dir not found: %s", home);
@@ -27,7 +27,7 @@ static void push_notification_event_mailboxunsubscribe_event( <nl>   <nl>      data = p_new(ptxn->pool, <nl>                   struct push_notification_event_mailboxunsubscribe_data, 1); <nl> -    data->subscribe = TRUE; <nl> +    data->subscribe = FALSE; <nl>   <nl>      push_notification_txn_mbox_set_eventdata(ptxn, mbox, ec, data); <nl>  }
@@ -300,6 +300,7 @@ static int maildir_index_sync_dir(struct mail_index *index, const char *dir, <nl>  	const char *fname; <nl>  	void *orig_key, *orig_value; <nl>  	unsigned int new_count; <nl> +	size_t size; <nl>  	int failed, check_content_changes; <nl>   <nl>  	i_assert(dir != NULL); <nl> @@ -312,7 +313,9 @@ static int maildir_index_sync_dir(struct mail_index *index, const char *dir, <nl>  	} <nl>   <nl>  	/* read current messages in index into hash */ <nl> -	pool = pool_alloconly_create("maildir sync", 16384); <nl> +	size = nearest_power(index->header->messages_count * <nl> +			     sizeof(struct maildir_hash_rec) + 1024); <nl> +	pool = pool_alloconly_create("maildir sync", I_MAX(size, 16384)); <nl>  	files = hash_create(default_pool, pool, index->header->messages_count*2, <nl>  			    maildir_hash, maildir_cmp); <nl>  
@@ -462,7 +462,10 @@ static int mail_index_open_init(MailIndex *index, int update_recent, <nl>  		index->set_flags |= MAIL_INDEX_FLAG_REBUILD; <nl>  	} <nl>   <nl> -	return TRUE; <nl> +	/* finally reset the modify log marks, fsck or syncing might have <nl> +	   deleted some messages, and since we're only just opening the <nl> +	   index, there's no need to remember them */ <nl> +	return mail_modifylog_mark_synced(index->modifylog); <nl>  } <nl>   <nl>  static int mail_index_open_file(MailIndex *index, const char *filename,
@@ -157,7 +157,7 @@ static void imapc_untagged_fetch(const struct imapc_untagged_reply *reply, <nl>  	struct imapc_seqmap *seqmap; <nl>  	const struct imap_arg *list, *flags_list; <nl>  	const char *atom; <nl> -	const struct mail_index_record *rec; <nl> +	const struct mail_index_record *rec = NULL; <nl>  	enum mail_flags flags; <nl>  	uint32_t uid, old_count; <nl>  	unsigned int i, j; <nl> @@ -228,8 +228,9 @@ static void imapc_untagged_fetch(const struct imapc_untagged_reply *reply, <nl>  			return; <nl>  		i_assert(lseq == old_count + 1); <nl>  		mail_index_append(mbox->delayed_sync_trans, uid, &lseq); <nl> +		rec = NULL; <nl>  	} <nl> -	if (seen_flags && rec->flags != flags) { <nl> +	if (seen_flags && (rec == NULL || rec->flags != flags)) { <nl>  		mail_index_update_flags(mbox->delayed_sync_trans, lseq, <nl>  					MODIFY_REPLACE, flags); <nl>  	}
@@ -174,7 +174,7 @@ lookup_ip(const char *addr, int aftype, DNSCB callback, void *data) <nl>  	return (rid); <nl>  } <nl>   <nl> -uint32_t <nl> +static uint32_t <nl>  get_nameservers(DNSLISTCB callback, void *data) <nl>  { <nl>  	struct dnsstatreq *req = rb_malloc(sizeof(struct dnsstatreq));
@@ -2142,7 +2142,7 @@ add_conf_item(const char *topconf, const char *name, int type, void (*func) (voi <nl>  	if((tc = find_top_conf(topconf)) == NULL) <nl>  		return -1; <nl>   <nl> -	if((cf = find_conf_item(tc, name)) != NULL) <nl> +	if(find_conf_item(tc, name) != NULL) <nl>  		return -1; <nl>   <nl>  	cf = rb_malloc(sizeof(struct ConfEntry));
@@ -554,6 +554,10 @@ int Curl_resolv_timeout(struct connectdata *conn, <nl>   <nl>    *entry = NULL; <nl>   <nl> +  if(timeoutms < 0) <nl> +    /* got an already expired timeout */ <nl> +    return CURLRESOLV_TIMEDOUT; <nl> + <nl>  #ifdef USE_ALARM_TIMEOUT <nl>    if(data->set.no_signal) <nl>      /* Ignore the timeout when signals are disabled */
@@ -470,8 +470,9 @@ _CURL_WARNING(_curl_easy_getinfo_err_curl_socket, <nl>  #endif <nl>   <nl>  /* evaluates to true if expr is of type FILE* */ <nl> -#define _curl_is_FILE(expr)                                                   \ <nl> -  (__builtin_types_compatible_p(__typeof__(expr), FILE *)) <nl> +#define _curl_is_FILE(expr)                                             \ <nl> +  (_curl_is_NULL(expr) ||                                              \ <nl> +   (__builtin_types_compatible_p(__typeof__(expr), FILE *))) <nl>   <nl>  /* evaluates to true if expr can be passed as POST data (void* or char*) */ <nl>  #define _curl_is_postfields(expr)                                             \
@@ -1400,7 +1400,7 @@ static CURLcode ssh_statemach_act(struct connectdata *conn, bool *block) <nl>      case SSH_SFTP_QUOTE_MKDIR: <nl>        rc = libssh2_sftp_mkdir_ex(sshc->sftp_session, sshc->quote_path1, <nl>                                   (unsigned int)strlen(sshc->quote_path1), <nl> -                                 0755); <nl> +                                 data->set.new_directory_perms); <nl>        if(rc == LIBSSH2_ERROR_EAGAIN) { <nl>          break; <nl>        }
@@ -101,7 +101,11 @@ curl_thread_t Curl_thread_create(unsigned int (CURL_STDCALL *func) (void*), void <nl>  #ifdef _WIN32_WCE <nl>    return CreateThread(NULL, 0, func, arg, 0, NULL); <nl>  #else <nl> -  return (curl_thread_t)_beginthreadex(NULL, 0, func, arg, 0, NULL); <nl> +  curl_thread_t t; <nl> +  t = (curl_thread_t)_beginthreadex(NULL, 0, func, arg, 0, NULL); <nl> +  if((t == 0) || (t == (curl_thread_t)-1L)) <nl> +    return curl_thread_t_null; <nl> +  return t; <nl>  #endif <nl>  } <nl>  
@@ -311,6 +311,10 @@ CURLcode Curl_output_ntlm(struct connectdata *conn, <nl>      passwdp = conn->passwd; <nl>      ntlm = &conn->ntlm; <nl>    } <nl> + <nl> +  if(!userp || !passwdp) <nl> +    /* no user, no auth */ <nl> +    return CURLE_OK; <nl>     <nl>    switch(ntlm->state) { <nl>    case NTLMSTATE_TYPE1:
@@ -5,7 +5,7 @@ <nl>   *                            | (__| |_| |  _ <| |___ <nl>   *                             \___|\___/|_| \_\_____| <nl>   * <nl> - * Copyright (C) 1998 - 2011, Daniel Stenberg, <daniel@haxx.se>, et al. <nl> + * Copyright (C) 1998 - 2013, Daniel Stenberg, <daniel@haxx.se>, et al. <nl>   * <nl>   * This software is licensed as described in the file COPYING, which <nl>   * you should have received as part of this distribution. The terms <nl> @@ -159,7 +159,8 @@ CURLcode Curl_urldecode(struct SessionHandle *data, <nl>   <nl>    while(--alloc > 0) { <nl>      in = *string; <nl> -    if(('%' == in) && ISXDIGIT(string[1]) && ISXDIGIT(string[2])) { <nl> +    if(('%' == in) && (alloc > 2) && <nl> +       ISXDIGIT(string[1]) && ISXDIGIT(string[2])) { <nl>        /* this is two hexadecimal digits following a '%' */ <nl>        char hexstr[3]; <nl>        char *ptr;
@@ -302,10 +302,10 @@ utf8asn1str(char **to, int type, const char *from, const char *end) <nl>        case 4: <nl>          wc = (wc << 8) | *(const unsigned char *) from++; <nl>          wc = (wc << 8) | *(const unsigned char *) from++; <nl> -        /* fallthrough */ <nl> +        /* FALLTHROUGH */ <nl>        case 2: <nl>          wc = (wc << 8) | *(const unsigned char *) from++; <nl> -        /* fallthrough */ <nl> +        /* FALLTHROUGH */ <nl>        default: /* case 1: */ <nl>          wc = (wc << 8) | *(const unsigned char *) from++; <nl>        }
@@ -2711,7 +2711,7 @@ CURLcode Curl_setopt(struct Curl_easy *data, CURLoption option, <nl>      arg = va_arg(param, long); <nl>      if(arg < CURLSSH_AUTH_NONE) <nl>        return CURLE_BAD_FUNCTION_ARGUMENT; <nl> -    data->set.ssh_auth_types = va_arg(param, long); <nl> +    data->set.ssh_auth_types = arg; <nl>      break; <nl>   <nl>    case CURLOPT_SSH_PUBLIC_KEYFILE:
@@ -30,6 +30,9 @@ char *curlx_strdup(const char *str) <nl>    int len; <nl>    char *newstr; <nl>   <nl> +  if (!str) <nl> +    return (char *)NULL; <nl> + <nl>    len = strlen(str); <nl>    newstr = (char *) malloc((len+1)*sizeof(char)); <nl>    if (!newstr)
@@ -290,7 +290,7 @@ void *queue_route(void *vp) <nl>    exit(1); <nl>    } <nl>   <nl> -void acct_close(void) <nl> +void acct_close(bool) <nl>    { <nl>    fprintf(stderr, "The call to acct_close needs to be mocked!!\n"); <nl>    exit(1);
@@ -220,8 +220,8 @@ START_TEST(add_node_attribute_to_list_test) <nl>    snprintf(line, sizeof(line), "100"); <nl>    ptr = line; <nl>    fail_unless(add_node_attribute_to_list(strdup("TTL"), &ptr, &th, 1) == PBSE_NONE); <nl> -  fail_unless(strcmp(attrname.c_str(), "TTL") == 0); <nl> -  fail_unless(strcmp(attrval.c_str(), "100") == 0); <nl> +  fail_unless(attrname == "TTL"); <nl> +  fail_unless(attrval == "100"); <nl>    attrlist_free(); <nl>    attrname.clear(); <nl>    attrval.clear(); <nl> @@ -229,8 +229,8 @@ START_TEST(add_node_attribute_to_list_test) <nl>    snprintf(line, sizeof(line), "bob,tom"); <nl>    ptr = line; <nl>    fail_unless(add_node_attribute_to_list(strdup("acl"), &ptr, &th, 1) == PBSE_NONE); <nl> -  fail_unless(strcmp(attrname.c_str(), "acl") == 0); <nl> -  fail_unless(strcmp(attrval.c_str(), "bob,tom") == 0); <nl> +  fail_unless(attrname == "acl"); <nl> +  fail_unless(attrval == "bob,tom"); <nl>    attrlist_free(); <nl>    attrname.clear(); <nl>    attrval.clear();
@@ -1425,6 +1425,14 @@ void Chip::calculateStepCounts( <nl>    int &place_count_remaining) <nl>   <nl>    { <nl> +   if (lprocs_per_task == 0) <nl> +     { <nl> +     step = 0; <nl> +     step_remainder = processing_units_per_task; <nl> +     place_count = 0; <nl> +     return; <nl> +     } <nl> + <nl>     if (lprocs_per_task == 1) <nl>      { <nl>      step = (processing_units_per_task/2) + 1;
@@ -3676,7 +3676,6 @@ void req_cpyfile( <nl>  #ifdef  _CRAY <nl>    char            tmpdirname[MAXPATHLEN + 1]; <nl>  #endif  /* _CRAY */ <nl> -  char            localname_alt[MAXPATHLEN + 1]; <nl>   <nl>    struct stat     myspooldir; <nl>    int             rcstat; <nl> @@ -3892,7 +3891,7 @@ void req_cpyfile( <nl>          snprintf(localname, sizeof(localname), "%s/%s", spool_dir.c_str(), pair->fp_local); <nl>   <nl>          // If we can't find it under the spool we determined, try path_spool <nl> -        rcstat = stat(localname_alt, &myspooldir); <nl> +        rcstat = stat(localname, &myspooldir); <nl>   <nl>          if ((rcstat != 0) || <nl>              (!S_ISREG(myspooldir.st_mode))) <nl> @@ -4081,7 +4080,8 @@ error: <nl>      } <nl>   <nl>    // In single transaction mode, delete the staged in files next <nl> -  if (pjob->ji_qs.ji_substate == JOB_SUBSTATE_STAGEOUT) <nl> +  if ((pjob != NULL) &&  <nl> +      (pjob->ji_qs.ji_substate == JOB_SUBSTATE_STAGEOUT)) <nl>      delete_staged_in_files(pjob, HDir, &bad_list); <nl>   <nl>    /* we are the child, exit not return */
@@ -180,6 +180,8 @@ job_array *get_array( <nl>    char      *tmpjobid; <nl>   <nl>    tmpjobid = get_correct_jobname(id); <nl> +  if (tmpjobid == NULL) <nl> +    return(NULL); <nl>   <nl>    pthread_mutex_lock(allarrays.allarrays_mutex); <nl>  
@@ -197,6 +197,8 @@ int user_route_uri(struct sip_msg * _msg, char * _user, char * _domain) { <nl>  	domain = (int)_domain; <nl>  	struct rewrite_data * rd = NULL; <nl>  	struct carrier_tree * ct = NULL; <nl> +	// TODO it would be better to use the new introduced pv_parse and pv_print functions <nl> +	// like in textops:append_to_reply_f and :it_list_fixup. <nl>  	switch (hf_type->id) { <nl>  		case REQ_URI: /* Request-URI */ <nl>  			if (get_request_uri(_msg, &uri) < 0) { <nl> @@ -277,6 +279,7 @@ int user_route_uri(struct sip_msg * _msg, char * _user, char * _domain) { <nl>  			} else { <nl>  				LM_ERR("desired routing tree with id %i doesn't exist\n", <nl>  					carrier_id); <nl> +				release_data(rd); <nl>  				return -1; <nl>  			} <nl>  		} else {
@@ -71,7 +71,7 @@ struct tcp_connection* get_cur_connection(struct sip_msg* msg) <nl>  		return 0; <nl>  	} <nl>   <nl> -	c = tcpconn_get(msg->rcv.proto_reserved1, 0, 0, tls_con_lifetime); <nl> +	c = tcpconn_get(msg->rcv.proto_reserved1, 0, 0, 0, tls_con_lifetime); <nl>  	if (c && c->type != PROTO_TLS) { <nl>  		ERR("Connection found but is not TLS\n"); <nl>  		tcpconn_put(c);
@@ -334,8 +334,10 @@ int convert_temporary_dialog(ua_pres_t *dialog) <nl>  	temp_dialog = get_temporary_dialog(dialog, hash_code); <nl>  	if (temp_dialog) <nl>  		delete_htable(temp_dialog, hash_code); <nl> -	else <nl> +	else { <nl> +		lock_release(&HashT->p_records[hash_code].lock); <nl>  		return -1; <nl> +	} <nl>   <nl>  	insert_htable(dialog, hash_code); <nl>  
@@ -1099,6 +1099,10 @@ int rval_get_tmp_str(struct run_act_ctx* h, struct sip_msg* msg, <nl>  	avp_t* r_avp; <nl>  	int i; <nl>   <nl> +	if(rv==NULL) { <nl> +		return -1; <nl> +	} <nl> + <nl>  	switch(rv->type){ <nl>  		case RV_INT: <nl>  			tmpv->s=sint2strbuf(rv->v.l, tmp_cache->i2s,
@@ -804,6 +804,7 @@ inline static str* binrpc_val_conv_str(struct binrpc_ctx* ctx, <nl>  			s=int2str(v->u.intval, &len); <nl>  			ret=ctl_malloc(sizeof(*ret)+len+1); <nl>  			if (ret==0 || binrpc_gc_track(ctx, ret)!=0){ <nl> +				if(ret!=0) ctl_free(ret); <nl>  				*err=E_BINRPC_OVERFLOW; <nl>  				return 0; <nl>  			}
@@ -228,6 +228,7 @@ int recvpkt4(int sock, char* buf, int len, union sockaddr_union* from, <nl>   <nl>  	iov[0].iov_base=buf; <nl>  	iov[0].iov_len=len; <nl> +	memset(&rcv_msg, 0, sizeof(struct msghdr)); <nl>  	rcv_msg.msg_name=from; <nl>  	rcv_msg.msg_namelen=sockaddru_len(*from); <nl>  	rcv_msg.msg_control=msg_ctrl_buf; <nl> @@ -603,7 +604,7 @@ int raw_iphdr_udp4_send(int rsock, char* buf, unsigned int len, <nl>  	int ret; <nl>   <nl>  	totlen = len + sizeof(hdr); <nl> -	if (unlikely(totlen) > 65535) <nl> +	if (unlikely(totlen > 65535)) <nl>  		return -2; <nl>  	memset(&snd_msg, 0, sizeof(snd_msg)); <nl>  	snd_msg.msg_name=&to->sin;
@@ -68,6 +68,7 @@ <nl>  #define EVENT_CREATED 3 <nl>  #define EVENT_REFRESHED 4 <nl>  #define EVENT_EXPIRED 5 <nl> +#define EVENT_DEACTIVATED 6 <nl>   <nl>  #define RESULT_ERROR -1 <nl>  #define RESULT_CONTACTS_FOUND 1 <nl> @@ -182,6 +183,9 @@ int reginfo_parse_event(char * s) { <nl>  			if (strncmp(s, "registered", 10) ==  0) return EVENT_REGISTERED; <nl>  			if (strncmp(s, "terminated", 10) ==  0) return EVENT_TERMINATED; <nl>  			break; <nl> +	    case 11: <nl> +			if (strncmp(s, "deactivated", 11) ==  0) return EVENT_DEACTIVATED; <nl> +			break; <nl>  		case 12: <nl>  			if (strncmp(s, "unregistered", 12) ==  0) return EVENT_UNREGISTERED; <nl>  			break;
@@ -89,8 +89,10 @@ static int child_init(int); <nl>  static void destroy(void); <nl>   <nl>  /* Fixup functions to be defined later */ <nl> -static int fixup_http_query(void** param, int param_no); <nl> -static int fixup_free_http_query(void** param, int param_no); <nl> +static int fixup_http_query_get(void** param, int param_no); <nl> +static int fixup_free_http_query_get(void** param, int param_no); <nl> +static int fixup_http_query_post(void** param, int param_no); <nl> +static int fixup_free_http_query_post(void** param, int param_no); <nl>   <nl>  /* Wrappers for http_query to be defined later */ <nl>  static int w_http_query(struct sip_msg* _m, char* _url, char* _result);
@@ -174,6 +174,9 @@ static int mod_init(void) <nl>   */ <nl>  static int child_init(int rank) <nl>  { <nl> +	if(rank==PROC_INIT) { <nl> +		return 0; <nl> +	} <nl>  	_apy_process_rank = rank; <nl>  	PyOS_AfterFork(); <nl>  	return apy_init_script(rank);
@@ -237,8 +237,9 @@ static struct timeval time_from_string( str* time_value) <nl>          return time_error; <nl>      } <nl>       <nl> -    return (struct timeval) { atoi( zero_terminated_value), <nl> -                            atoi( dot_address + 1)}; <nl> +    time_res->tv_sec = strtol( zero_terminated_value, (char **)NULL, 10); <nl> +    time_res->tv_usec = strtol( dot_address + 1, (char **)NULL, 10); <nl> +    return 0; <nl>  } <nl>   <nl>  /* set the duration in the dialog struct */
@@ -1136,7 +1136,7 @@ static int do_load_gws(struct sip_msg* _m, int grp_id) <nl>  	} <nl>  	from_uri = get_from(_m)->uri; <nl>      } <nl> -    if (from_uri.len < MAX_FROM_URI_LEN) { <nl> +    if (from_uri.len <= MAX_FROM_URI_LEN) { <nl>  	strncpy(from_uri_str, from_uri.s, from_uri.len); <nl>  	from_uri_str[from_uri.len] = '\0'; <nl>      } else {
@@ -242,7 +242,7 @@ int t_relay_to( struct sip_msg  *p_msg , struct proxy_l *proxy, int proto, <nl>  			init_branch_iterator(); <nl>  			while((ack_uri.s=next_branch(&ack_uri.len))) { <nl>  				p_msg->new_uri=ack_uri; <nl> -				proxy=uri2proxy(ack_uri, proto); <nl> +				proxy=uri2proxy(&GET_NEXT_HOP(p_msg), proto); <nl>  				if (proxy==0) continue; <nl>  				forward_request(p_msg, proxy, proto); <nl>  				free_proxy( proxy );	
@@ -128,6 +128,7 @@ int build_challenge_hf(struct sip_msg* msg, int stale, str* realm, int hftype) <nl>  	pkg_free(hf.s); <nl>  	return -1; <nl>      } <nl> +	pkg_free(hf.s); <nl>   <nl>      return 0; <nl>  }
@@ -1358,8 +1358,8 @@ int tlsf_malloc_init_pkg_manager(void) <nl>  	ma.xavailable = tlsf_available; <nl>  	ma.xsums      = tlsf_sums; <nl>  	ma.xdestroy   = tlsf_malloc_destroy_pkg_manager; <nl> -	ma.xstats     = tlsf_mod_get_stats; <nl> -	ma.xfstats    = tlsf_mod_free_stats; <nl> +	ma.xmodstats  = tlsf_mod_get_stats; <nl> +	ma.xfmodstats = tlsf_mod_free_stats; <nl>   <nl>  	return pkg_init_api(&ma); <nl>  } <nl> @@ -1508,8 +1508,8 @@ int tlsf_malloc_init_shm_manager(void) <nl>  	ma.xavailable     = tlsf_shm_available; <nl>  	ma.xsums          = tlsf_shm_sums; <nl>  	ma.xdestroy       = tlsf_malloc_destroy_shm_manager; <nl> -	ma.xstats         = tlsf_mod_get_stats; <nl> -	ma.xfstats        = tlsf_mod_free_stats; <nl> +	ma.xmodstats      = tlsf_mod_get_stats; <nl> +	ma.xfmodstats     = tlsf_mod_free_stats; <nl>   <nl>  	if(shm_init_api(&ma)<0) { <nl>  		LM_ERR("cannot initialize the core shm api\n");
@@ -129,7 +129,7 @@ pcontact_t * getContactP(struct sip_msg* _m, udomain_t* _d) { <nl>  		} <nl>   <nl>  		for (ct = b->contacts; ct; ct = ct->next) { <nl> -			if (ul.get_pcontact(_d, &ct->uri, &c) == 1) { <nl> +			if (ul.get_pcontact(_d, &ct->uri, &c) == 0) { <nl>  				if ((c->reg_state == PCONTACT_REGISTERED) && (c->received_port == _m->rcv.src_port) && (c->received_proto == _m->rcv.proto)) { <nl>  					received_host.len = ip_addr2sbuf(&_m->rcv.src_ip, srcip, sizeof(srcip)); <nl>  					received_host.s = srcip;
@@ -330,13 +330,13 @@ rs_load_raw_from_memory(RS_IMAGE *rs) <nl>  		for (x=0; x<rs->raw->raw.width; x++) <nl>  		{ <nl>  			rs->pixels[R][y*rs->pitch+x] = CLAMP65535(((src[(y*rs->w+x)*4+R] <nl> -				- rs->raw->black)*mul[R])>>11); <nl> +				- rs->raw->black)*mul[R])>>12); <nl>  			rs->pixels[G][y*rs->pitch+x] = CLAMP65535(((src[(y*rs->w+x)*4+G] <nl> -				- rs->raw->black)*mul[G])>>11); <nl> +				- rs->raw->black)*mul[G])>>12); <nl>  			rs->pixels[B][y*rs->pitch+x] = CLAMP65535(((src[(y*rs->w+x)*4+B] <nl> -				- rs->raw->black)*mul[B])>>11); <nl> +				- rs->raw->black)*mul[B])>>12); <nl>  			if (rs->channels==4) rs->pixels[G2][y*rs->pitch+x] = CLAMP65535(((src[(y*rs->w+x)*4+G2] <nl> -				- rs->raw->black)*mul[G2])>>11); <nl> +				- rs->raw->black)*mul[G2])>>12); <nl>  		} <nl>  	} <nl>  	rs->in_use=TRUE;
@@ -172,8 +172,7 @@ static void set_format(WAVEFORMATEXTENSIBLE *wformat, WORD bytepersample, <nl>      wformat->Format.nAvgBytesPerSec = samplerate * block_align; <nl>      wformat->Format.nBlockAlign = block_align; <nl>      wformat->Format.wBitsPerSample = bytepersample * 8; <nl> -    wformat->Format.cbSize = <nl> -        22; /* must be at least 22 for WAVE_FORMAT_EXTENSIBLE */ <nl> +    wformat->Format.cbSize = sizeof(WAVEFORMATEXTENSIBLE) - sizeof(WAVEFORMATEX); <nl>      if (bytepersample == 4) <nl>          wformat->SubFormat = mp_KSDATAFORMAT_SUBTYPE_IEEE_FLOAT; <nl>      else
@@ -444,8 +444,10 @@ int mp_initialize(struct MPContext *mpctx, char **options) <nl>          m_config_set_option0(mpctx->mconfig, "osc", "no"); <nl>          m_config_set_option0(mpctx->mconfig, "framedrop", "no"); <nl>          // never use auto <nl> -        if (!opts->audio_output_channels.num) <nl> -            m_config_set_option0(mpctx->mconfig, "audio-channels", "stereo"); <nl> +        if (!opts->audio_output_channels.num) { <nl> +            m_config_set_option_ext(mpctx->mconfig, bstr0("audio-channels"), <nl> +                                    bstr0("stereo"), M_SETOPT_PRESERVE_CMDLINE); <nl> +        } <nl>          mp_input_enable_section(mpctx->input, "encode", MP_INPUT_EXCLUSIVE); <nl>      } <nl>  #endif
@@ -1108,6 +1108,16 @@ static int radeonfb_pci_register (struct pci_dev *pdev, <nl>  	/* mem size is bits [28:0], mask off the rest */ <nl>  	rinfo->video_ram = tmp & CONFIG_MEMSIZE_MASK; <nl>   <nl> +	/* according to XFree86 4.2.0, some production M6's return <nl> +	   0 for 8MB */ <nl> +	if (rinfo->video_ram == 0 &&  <nl> +	    (pdev->device == PCI_DEVICE_ID_RADEON_LY || <nl> +	     pdev->device == PCI_DEVICE_ID_RADEON_LZ)) <nl> +	{ <nl> +	    rinfo->video_ram = 8192*1024; <nl> +	    printk("radeonfb: workarounding buggy Radeon M6 (0 vs 8MB memory)\n"); <nl> +	} <nl> + <nl>  	/* ram type */ <nl>  	rinfo->MemCntl = INREG(MEM_SDRAM_MODE_REG); <nl>  	switch ((MEM_CFG_TYPE & rinfo->MemCntl) >> 30) {
@@ -304,6 +304,10 @@ static void drm_egl_uninit(MPGLContext *ctx) <nl>   <nl>  static int drm_egl_init(struct MPGLContext *ctx, int flags) <nl>  { <nl> +    if (ctx->vo->probing) { <nl> +        MP_VERBOSE(ctx->vo, "DRM EGL backend can be activated only manually.\n"); <nl> +        return -1; <nl> +    } <nl>      struct priv *p = ctx->priv; <nl>      p->kms = NULL; <nl>      p->old_crtc = NULL;
@@ -3487,7 +3487,7 @@ int get_current_chapter(struct MPContext *mpctx) <nl>  // currently returns a string allocated with malloc, not talloc <nl>  char *chapter_display_name(struct MPContext *mpctx, int chapter) <nl>  { <nl> -    if (!mpctx->chapters || !mpctx->sh_video) <nl> +    if (!mpctx->chapters) <nl>          return demuxer_chapter_display_name(mpctx->demuxer, chapter); <nl>      return talloc_strdup(NULL, mpctx->chapters[chapter].name); <nl>  } <nl> @@ -3496,7 +3496,7 @@ int seek_chapter(struct MPContext *mpctx, int chapter, double *seek_pts, <nl>                   char **chapter_name) <nl>  { <nl>      mpctx->last_chapter_seek = -2; <nl> -    if (!mpctx->chapters || !mpctx->sh_video) { <nl> +    if (!mpctx->chapters) { <nl>          int res = demuxer_seek_chapter(mpctx->demuxer, chapter, seek_pts, <nl>                                         chapter_name); <nl>          if (res >= 0) {
@@ -129,7 +129,7 @@ static int find_entrypoint(int format, VAEntrypoint *ep, int num_ep) <nl>   <nl>  static int is_direct_mapping(VADisplay display) <nl>  { <nl> -    VADisplayAttribute attr; <nl> +    VADisplayAttribute attr = {0}; <nl>      VAStatus status; <nl>   <nl>  #if VA_CHECK_VERSION(0,34,0)
@@ -332,6 +332,7 @@ while(1){ <nl>  		sh_video->aspect = GET_AVI_ASPECT(vprp->dwFrameAspectRatio); <nl>  	} <nl>  	if(verbose>=1) print_vprp(vprp); <nl> +	free(vprp); <nl>  	break; <nl>      } <nl>      case mmioFOURCC('d', 'm', 'l', 'h'): {
@@ -2100,7 +2100,7 @@ if(!sh_video) { <nl>  	    float d=delay-sh_audio->delay; <nl>  	    // we should avoid dropping to many frames in sequence unless we <nl>  	    // are too late. and we allow 100ms A-V delay here: <nl> -	    if(d<-dropped_frames*frame_time-0.100){ <nl> +	    if(d<-dropped_frames*frame_time-0.100 && osd_function != OSD_PAUSE){ <nl>  		drop_frame=frame_dropping; <nl>  		++drop_frame_cnt; <nl>  		++dropped_frames;
@@ -309,9 +309,10 @@ int demux_lavf_fill_buffer(demuxer_t *demux){ <nl>          av_free_packet(&pkt); <nl>      } <nl>   <nl> -    priv->last_pts= pkt.pts; <nl> -     <nl> -    dp->pts=pkt.pts / (float)AV_TIME_BASE; <nl> +    if(pkt.pts != AV_NOPTS_VALUE){ <nl> +        priv->last_pts= pkt.pts; <nl> +        dp->pts=pkt.pts / (float)AV_TIME_BASE; <nl> +    } <nl>      dp->pos=demux->filepos; <nl>      dp->flags= !!(pkt.flags&PKT_FLAG_KEY); <nl>      // append packet to DS stream:
@@ -5273,6 +5273,9 @@ struct exports exp_msvcr80[]={ <nl>      FF(_initterm_e, -1) <nl>      FF(_initterm, -1) <nl>      FF(_decode_pointer, -1) <nl> +/* needed by KGV1-VFW.dll */ <nl> +    {"??2@YAPAXI@Z", -1, expnew}, <nl> +    {"??3@YAXPAX@Z", -1, expdelete} <nl>  }; <nl>   <nl>  struct exports exp_msvcp60[]={
@@ -192,6 +192,7 @@ stream_t* new_stream(int fd,int type){ <nl>    stream_t *s=malloc(sizeof(stream_t)); <nl>    s->fd=fd; <nl>    s->type=type; <nl> +  s->buf_pos=s->buf_len=0; <nl>    stream_reset(s); <nl>    return s; <nl>  }
@@ -449,7 +449,8 @@ static HRESULT init_session_display(struct wasapi_state *state) { <nl>  exit_label: <nl>      MP_ERR(state, "Error setting audio session display name: %s (0x%"PRIx32")\n", <nl>             wasapi_explain_err(hr), (uint32_t)hr); <nl> -    return hr; <nl> +    // No reason to abort initialization. <nl> +    return S_OK; <nl>  } <nl>   <nl>  static HRESULT fix_format(struct ao *ao)
@@ -461,13 +461,13 @@ struct m_config_option *m_config_get_co(const struct m_config *config, <nl>      return NULL; <nl>  } <nl>   <nl> -const char *m_config_get_positional_option(const struct m_config *config, int n) <nl> +const char *m_config_get_positional_option(const struct m_config *config, int p) <nl>  { <nl>      int pos = 0; <nl>      for (int n = 0; n < config->num_opts; n++) { <nl>          struct m_config_option *co = &config->opts[n]; <nl>          if (!co->is_generated) { <nl> -            if (pos == n) <nl> +            if (pos == p) <nl>                  return co->name; <nl>              pos++; <nl>          }
@@ -378,8 +378,8 @@ void spudec_assemble(void *this, unsigned char *packet, unsigned int len, unsign <nl>  #if 1 <nl>    // check if we have a complete packet (unfortunatelly packet_size is bad <nl>    // for some disks) <nl> -//  if (spu->packet_offset == spu->packet_size) <nl> -  { unsigned int x=0,y; <nl> +  if (spu->packet_offset == spu->packet_size){ <nl> +    unsigned int x=0,y; <nl>      while(x+4<=spu->packet_offset){ <nl>        y=get_be16(spu->packet+x+2); // next control pointer <nl>        mp_msg(MSGT_SPUDEC,MSGL_DBG2,"SPUtest: x=%d y=%d off=%d size=%d\n",x,y,spu->packet_offset,spu->packet_size);
@@ -393,10 +393,14 @@ static struct cmd_bind *find_bind_for_key_section(struct input_ctx *ictx, <nl>      memcpy(keys, ictx->key_history, sizeof(keys)); <nl>      key_buf_add(keys, code); <nl>   <nl> +    struct cmd_bind *best = NULL; <nl> + <nl>      // Prefer user-defined keys over builtin bindings <nl>      for (int builtin = 0; builtin < 2; builtin++) { <nl>          if (builtin && !ictx->default_bindings) <nl>              break; <nl> +        if (best) <nl> +            break; <nl>          for (int n = 0; n < bs->num_binds; n++) { <nl>              if (bs->binds[n].is_builtin == (bool)builtin) { <nl>                  struct cmd_bind *b = &bs->binds[n]; <nl> @@ -406,12 +410,13 @@ static struct cmd_bind *find_bind_for_key_section(struct input_ctx *ictx, <nl>                      if (b->keys[i] != keys[b->num_keys - 1 - i]) <nl>                          goto skip; <nl>                  } <nl> -                return b; <nl> +                if (!best || b->num_keys >= best->num_keys) <nl> +                    best = b; <nl>              skip: ; <nl>              } <nl>          } <nl>      } <nl> -    return NULL; <nl> +    return best; <nl>  } <nl>   <nl>  static struct cmd_bind *find_any_bind_for_key(struct input_ctx *ictx,
@@ -188,7 +188,7 @@ static int init(sh_video_t *sh){ <nl>      if(vd_use_slices && (lavc_codec->capabilities&CODEC_CAP_DRAW_HORIZ_BAND) && !do_vis_debug) <nl>  	ctx->do_slices=1; <nl>    <nl> -    if(lavc_codec->capabilities&CODEC_CAP_DR1 && !do_vis_debug) <nl> +    if(lavc_codec->capabilities&CODEC_CAP_DR1 && !do_vis_debug && lavc_codec->id != CODEC_ID_H264) <nl>  	ctx->do_dr1=1; <nl>      ctx->b_age= ctx->ip_age[0]= ctx->ip_age[1]= 256*256*256*64; <nl>      ctx->ip_count= ctx->b_count= 0;
@@ -138,7 +138,7 @@ static af_instance_t* af_create(af_stream_t* s, const char* name_with_cmd) <nl>    if(AF_OK == new->info->open(new) &&  <nl>       AF_ERROR < new->control(new,AF_CONTROL_POST_CREATE,&s->cfg)){ <nl>      if(cmdline){ <nl> -      if(!AF_ERROR<new->control(new,AF_CONTROL_COMMAND_LINE,cmdline)) <nl> +      if(AF_ERROR>=new->control(new,AF_CONTROL_COMMAND_LINE,cmdline)) <nl>          goto err_out; <nl>      } <nl>      free(name);
@@ -58,6 +58,7 @@ <nl>  #include "version.h" <nl>  #include "stream.h" <nl>  #include "network.h" <nl> +#include "libavutil/intreadwrite.h" <nl>   <nl>  #define DEFAULT_FREEDB_SERVER	"freedb.freedb.org" <nl>  #define DEFAULT_CACHE_DIR	"/.cddb/" <nl> @@ -503,8 +504,9 @@ cddb_parse_matches_list(HTTP_header_t *http_hdr, cddb_data_t *cddb_data) { <nl>  		} else { <nl>  			len = ptr2-ptr+1; <nl>  		} <nl> +		len = FFMIN(sizeof(album_title) - 1, len); <nl>  		strncpy(album_title, ptr, len); <nl> -		album_title[len-2]='\0'; <nl> +		album_title[len]='\0'; <nl>  	} <nl>  	mp_msg(MSGT_DEMUX, MSGL_STATUS, MSGTR_MPDEMUX_CDDB_ParseOKFoundAlbumTitle, album_title); <nl>  	return 0; <nl> @@ -540,8 +542,9 @@ cddb_query_parse(HTTP_header_t *http_hdr, cddb_data_t *cddb_data) { <nl>  				} else { <nl>  					len = ptr2-ptr+1; <nl>  				} <nl> +				len = FFMIN(sizeof(album_title) - 1, len); <nl>  				strncpy(album_title, ptr, len); <nl> -				album_title[len-2]='\0'; <nl> +				album_title[len]='\0'; <nl>  			} <nl>  			mp_msg(MSGT_DEMUX, MSGL_STATUS, MSGTR_MPDEMUX_CDDB_ParseOKFoundAlbumTitle, album_title); <nl>  			return cddb_request_titles(cddb_data);
@@ -43,8 +43,8 @@ inline void TranslateFilename( int c,char * tmp ) <nl>     case STREAMTYPE_FILE: <nl>            if ( ( guiIntfStruct.Filename )&&( guiIntfStruct.Filename[0] ) ) <nl>             { <nl> -	    if ( strrchr( guiIntfStruct.Filename,'/' ) ) strcpy( tmp,strrchr( guiIntfStruct.Filename,'/' ) + 1 ); <nl> -	     else strcpy( tmp,guiIntfStruct.Filename ); <nl> +	    if ( strrchr( guiIntfStruct.Filename,'/' ) ) strncpy( tmp,strrchr( guiIntfStruct.Filename,'/' ) + 1, 511 ); <nl> +	     else strncpy( tmp,guiIntfStruct.Filename , 511); <nl>              if ( tmp[strlen( tmp ) - 4] == '.' ) tmp[strlen( tmp ) - 4]=0; <nl>              if ( tmp[strlen( tmp ) - 5] == '.' ) tmp[strlen( tmp ) - 5]=0; <nl>             } else strcpy( tmp,MSGTR_NoFileLoaded );
@@ -109,6 +109,7 @@ static demuxer_t *demux_mpc_open(demuxer_t* demuxer) { <nl>    stream_read(s, (void *)&priv->dword, 4); <nl>    priv->pos = 8; <nl>    demuxer->priv = priv; <nl> +  demuxer->seekable = 0; <nl>    demuxer->audio->id = 0; <nl>    demuxer->audio->sh = sh_audio; <nl>    sh_audio->ds = demuxer->audio;
@@ -1061,9 +1061,13 @@ void cgtimer_time(cgtimer_t *ts_start) <nl>   <nl>  static void liSleep(LARGE_INTEGER *li, int timeout) <nl>  { <nl> -	HANDLE hTimer = CreateWaitableTimer(NULL, TRUE, NULL); <nl> +	HANDLE hTimer; <nl>  	DWORD ret; <nl>   <nl> +	if (unlikely(timeout <= 0)) <nl> +		return; <nl> + <nl> +	hTimer = CreateWaitableTimer(NULL, TRUE, NULL); <nl>  	if (unlikely(!hTimer)) <nl>  		quit(1, "Failed to create hTimer in liSleep"); <nl>  	ret = SetWaitableTimer(hTimer, li, 0, NULL, NULL, 0);
@@ -11830,7 +11830,7 @@ begin_bench: <nl>  #endif <nl>   <nl>  #ifdef HAVE_BFG_HOTPLUG <nl> -	if (opt_hotplug && !opt_scrypt) <nl> +	if (opt_hotplug) <nl>  		hotplug_start(); <nl>  #endif <nl>  
@@ -38,7 +38,6 @@ static <nl>  pthread_mutex_t getwork_clients_mutex; <nl>   <nl>  // TODO: X-Hashes-Done? <nl> -// TODO: block getworks if disabled? <nl>   <nl>  static <nl>  void prune_worklog() <nl> @@ -240,6 +239,12 @@ int handle_getwork(struct MHD_Connection *conn, bytes_t *upbuf) <nl>  		goto out; <nl>  	} <nl>  	 <nl> +	if (cgpu->deven == DEV_DISABLED) <nl> +	{ <nl> +		ret = getwork_error(conn, -10, "Virtual device has been disabled", idstr, idstr_sz); <nl> +		goto out; <nl> +	} <nl> +	 <nl>  	{ <nl>  		const size_t replysz = 451 + idstr_sz; <nl>  		
@@ -123,4 +123,9 @@ extern FILE *open_bitstream(const char *dname, const char *filename); <nl>   <nl>  extern void close_device_fd(struct thr_info *); <nl>   <nl> +#define for_each_managed_proc(procvar, dev)  \ <nl> +	for (struct cgpu_info *procvar = dev; procvar; procvar = procvar->next_proc) <nl> +#define for_each_logical_proc(procvar, dev)  \ <nl> +	for (struct cgpu_info *procvar = dev; procvar->proc_id < dev->procs; procvar = procvar->next_proc) <nl> + <nl>  #endif
@@ -8863,6 +8863,12 @@ static <nl>  void _submit_work_async(struct work *work) <nl>  { <nl>  	applog(LOG_DEBUG, "Pushing submit work to work thread"); <nl> +	 <nl> +	if (opt_benchmark) <nl> +	{ <nl> +		free_work(work); <nl> +		return; <nl> +	} <nl>   <nl>  	mutex_lock(&submitting_lock); <nl>  	++total_submitting; <nl> @@ -11767,6 +11773,7 @@ begin_bench: <nl>  	cgtime(&total_tv_start); <nl>  	cgtime(&total_tv_end); <nl>   <nl> +	if (!opt_benchmark) <nl>  	{ <nl>  		pthread_t submit_thread; <nl>  		if (unlikely(pthread_create(&submit_thread, NULL, submit_work_thread, NULL)))
@@ -2,7 +2,7 @@ <nl>  /****************************************************************************** <nl>   * <nl>   * Module Name: exutils - interpreter/scanner utilities <nl> - *              $Revision: 1.107 $ <nl> + *              $Revision: 1.109 $ <nl>   * <nl>   *****************************************************************************/ <nl>   <nl> @@ -10,7 +10,7 @@ <nl>   * <nl>   * 1. Copyright Notice <nl>   * <nl> - * Some or all of this work - Copyright (c) 1999 - 2002, Intel Corp. <nl> + * Some or all of this work - Copyright (c) 1999 - 2003, Intel Corp. <nl>   * All rights reserved. <nl>   * <nl>   * 2. License <nl> @@ -372,7 +372,11 @@ AcpiExDigitsNeeded ( <nl>      /* <nl>       * ACPI_INTEGER is unsigned, so we don't worry about a '-' <nl>       */ <nl> -    CurrentValue = Value; <nl> +    if ((CurrentValue = Value) == 0) <nl> +    { <nl> +	    return_VALUE (1); <nl> +    } <nl> + <nl>      NumDigits = 0; <nl>   <nl>      while (CurrentValue)
@@ -121,8 +121,9 @@ <nl>  #include <namespace.h> <nl>  #include <globals.h> <nl>   <nl> -#define _THIS_MODULE        "cmalloc.c" <nl>  #define _COMPONENT          MISCELLANEOUS <nl> +        MODULE_NAME         ("cmalloc"); <nl> + <nl>   <nl>  /* <nl>   * Most of this code is for tracking memory leaks in the subsystem, and it
@@ -629,9 +629,9 @@ static const char           *AcpiGbl_GenericNotify[ACPI_GENERIC_NOTIFY_MAX + 1] <nl>      /* 09 */ "Device PLD Check", <nl>      /* 0A */ "Reserved", <nl>      /* 0B */ "System Locality Update", <nl> -    /* 0C */ "Shutdown Request", /* Reserved in ACPI 6.0 */ <nl> +    /* 0C */ "Reserved (was previously Shutdown Request)",  /* Reserved in ACPI 6.0 */ <nl>      /* 0D */ "System Resource Affinity Update", <nl> -    /* 0E */ "Heterogeneous Memory Attributes Update" /* ACPI 6.2 */ <nl> +    /* 0E */ "Heterogeneous Memory Attributes Update"       /* ACPI 6.2 */ <nl>  }; <nl>   <nl>  static const char           *AcpiGbl_DeviceNotify[5] =
@@ -2,7 +2,7 @@ <nl>  /****************************************************************************** <nl>   * <nl>   * Module Name: asllisting - Listing file generation <nl> - *              $Revision: 1.24 $ <nl> + *              $Revision: 1.25 $ <nl>   * <nl>   *****************************************************************************/ <nl>   <nl> @@ -621,7 +621,7 @@ LsWriteNodeToListing ( <nl>       */ <nl>   <nl>      OpInfo  = AcpiPsGetOpcodeInfo (Node->AmlOpcode); <nl> -    OpClass = ACPI_GET_OP_CLASS (OpInfo); <nl> +    OpClass = OpInfo->Class; <nl>   <nl>      switch (OpClass) <nl>      {
@@ -2052,6 +2052,13 @@ main(int argc, char *argv[]) <nl>  	(void) sigaddset(&block_cld, SIGCHLD); <nl>  	(void) sigprocmask(SIG_BLOCK, &block_cld, NULL); <nl>   <nl> +	/* <nl> +	 * The parent only needs stderr after the fork, so close other fd's <nl> +	 * that we inherited from zoneadm so that the parent doesn't have those <nl> +	 * open while waiting. The child will close the rest after the fork. <nl> +	 */ <nl> +	closefrom(3); <nl> + <nl>  	if ((ctfd = init_template()) == -1) { <nl>  		zerror(zlogp, B_TRUE, "failed to create contract"); <nl>  		return (1);
@@ -216,8 +216,7 @@ nocount: <nl>  /* <nl>   *	Find the line on the screen <nl>   */ <nl> -		for (i = 0; i <= WECHO; i++) <nl> -		{ <nl> +		for (i = 0; i <= WECHO; i++) { <nl>  			if (vlinfo[i].vliny >= mouse_y) <nl>  				break; <nl>  		} <nl> @@ -226,10 +225,8 @@ nocount: <nl>  /* <nl>   *	Look for lines longer than one line - note  odd case at zero <nl>   */ <nl> -		if (i) <nl> -		{ <nl> -			if (vlinfo[i - 1].vdepth > 1) <nl> -			{ <nl> +		if (i) { <nl> +			if (vlinfo[i - 1].vdepth > 1) { <nl>  				mouse_x += WCOLS * (mouse_y - <nl>  					(vlinfo[i].vliny - <nl>  					(vlinfo[i - 1].vdepth - 1)));
@@ -438,6 +438,7 @@ vhci_failover_modopen(struct scsi_vhci *vhci) <nl>  	if (scsi_nfailover == 0) { <nl>  		cmn_err(CE_WARN, "scsi_vhci: " <nl>  		    "scsi_vhci.conf has empty 'ddi-forceload'"); <nl> +		ddi_prop_free(module); <nl>  		return; <nl>  	} <nl>   <nl> @@ -513,6 +514,8 @@ vhci_failover_modopen(struct scsi_vhci *vhci) <nl>  		if (sf->sf_sfo && sf->sf_sfo->sfo_init) <nl>  			(*sf->sf_sfo->sfo_init)(); <nl>  	} <nl> + <nl> +	ddi_prop_free(module); <nl>  } <nl>   <nl>  /*
@@ -999,11 +999,16 @@ build_ssdt(GArray *table_data, GArray *linker, <nl>             AcpiCpuInfo *cpu, AcpiPmInfo *pm, AcpiMiscInfo *misc, <nl>             PcPciInfo *pci, PcGuestInfo *guest_info) <nl>  { <nl> -    int acpi_cpus = MIN(0xff, guest_info->apic_id_limit); <nl> +    unsigned acpi_cpus = guest_info->apic_id_limit; <nl>      int ssdt_start = table_data->len; <nl>      uint8_t *ssdt_ptr; <nl>      int i; <nl>   <nl> +    /* The current AML generator can cover the APIC ID range [0..255], <nl> +     * inclusive, for VCPU hotplug. */ <nl> +    QEMU_BUILD_BUG_ON(ACPI_CPU_HOTPLUG_ID_LIMIT > 256); <nl> +    g_assert(acpi_cpus <= ACPI_CPU_HOTPLUG_ID_LIMIT); <nl> + <nl>      /* Copy header and patch values in the S3_ / S4_ / S5_ packages */ <nl>      ssdt_ptr = acpi_data_push(table_data, sizeof(ssdp_misc_aml)); <nl>      memcpy(ssdt_ptr, ssdp_misc_aml, sizeof(ssdp_misc_aml));
@@ -324,9 +324,14 @@ void throttle_group_config(BlockDriverState *bs, ThrottleConfig *cfg) <nl>      ThrottleState *ts = bs->throttle_state; <nl>      ThrottleGroup *tg = container_of(ts, ThrottleGroup, ts); <nl>      qemu_mutex_lock(&tg->lock); <nl> -    throttle_config(ts, tt, cfg); <nl>      /* throttle_config() cancels the timers */ <nl> -    tg->any_timer_armed[0] = tg->any_timer_armed[1] = false; <nl> +    if (timer_pending(tt->timers[0])) { <nl> +        tg->any_timer_armed[0] = false; <nl> +    } <nl> +    if (timer_pending(tt->timers[1])) { <nl> +        tg->any_timer_armed[1] = false; <nl> +    } <nl> +    throttle_config(ts, tt, cfg); <nl>      qemu_mutex_unlock(&tg->lock); <nl>  } <nl>  
@@ -192,7 +192,7 @@ static void virtex_init(ram_addr_t ram_size, <nl>      CPUState *env; <nl>      target_phys_addr_t ram_base = 0; <nl>      DriveInfo *dinfo; <nl> -    ram_addr_t phys_ram; <nl> +    MemoryRegion *phys_ram = g_new(MemoryRegion, 1); <nl>      qemu_irq irq[32], *cpu_irq; <nl>      int kernel_size; <nl>      int i; <nl> @@ -205,8 +205,8 @@ static void virtex_init(ram_addr_t ram_size, <nl>      env = ppc440_init_xilinx(&ram_size, 1, cpu_model, 400000000); <nl>      qemu_register_reset(main_cpu_reset, env); <nl>   <nl> -    phys_ram = qemu_ram_alloc(NULL, "ram", ram_size); <nl> -    cpu_register_physical_memory(ram_base, ram_size, phys_ram | IO_MEM_RAM); <nl> +    memory_region_init_ram(phys_ram, NULL, "ram", ram_size); <nl> +    memory_region_add_subregion(address_space_mem, ram_base, phys_ram); <nl>   <nl>      dinfo = drive_get(IF_PFLASH, 0, 0); <nl>      pflash_cfi01_register(0xfc000000, NULL, "virtex.flash", FLASH_SIZE,
@@ -216,7 +216,7 @@ static int raw_open(BlockDriverState *bs, const char *filename, int flags) <nl>          } <nl>  #endif <nl>  #ifdef CONFIG_COCOA <nl> -        u_int32_t   blockSize = 512; <nl> +        uint32_t blockSize = 512; <nl>          if ( !ioctl( fd, DKIOCGETBLOCKSIZE, &blockSize ) && blockSize > bufsize) { <nl>              bufsize = blockSize; <nl>          }
@@ -694,7 +694,6 @@ void qmp_migrate(const char *uri, bool has_blk, bool blk, <nl>          error_setg(errp, QERR_MIGRATION_ACTIVE); <nl>          return; <nl>      } <nl> - <nl>      if (runstate_check(RUN_STATE_INMIGRATE)) { <nl>          error_setg(errp, "Guest is waiting for an incoming migration"); <nl>          return; <nl> @@ -709,6 +708,12 @@ void qmp_migrate(const char *uri, bool has_blk, bool blk, <nl>          return; <nl>      } <nl>   <nl> +    /* We are starting a new migration, so we want to start in a clean <nl> +       state.  This change is only needed if previous migration <nl> +       failed/was cancelled.  We don't use migrate_set_state() because <nl> +       we are setting the initial state, not changing it. */ <nl> +    s->state = MIGRATION_STATUS_NONE; <nl> + <nl>      s = migrate_init(&params); <nl>   <nl>      if (strstart(uri, "tcp:", &p)) {
@@ -361,10 +361,15 @@ int queue_signal(CPUState *env, int sig, target_siginfo_t *info) <nl>      k = &ts->sigtab[sig - 1]; <nl>      handler = sigact_table[sig - 1]._sa_handler; <nl>      if (handler == TARGET_SIG_DFL) { <nl> +        if (sig == TARGET_SIGTSTP || sig == TARGET_SIGTTIN || sig == TARGET_SIGTTOU) { <nl> +            kill(getpid(),SIGSTOP); <nl> +            return 0; <nl> +        } else <nl>          /* default handler : ignore some signal. The other are fatal */ <nl>          if (sig != TARGET_SIGCHLD && <nl>              sig != TARGET_SIGURG && <nl> -            sig != TARGET_SIGWINCH) { <nl> +            sig != TARGET_SIGWINCH && <nl> +            sig != TARGET_SIGCONT) { <nl>              force_sig(sig); <nl>          } else { <nl>              return 0; /* indicate ignored */
@@ -224,7 +224,7 @@ uint32_t lm4549_write_samples(lm4549_state *s, uint32_t left, uint32_t right) <nl>         This model supports 16-bit playback. <nl>      */ <nl>   <nl> -    if (s->buffer_level >= LM4549_BUFFER_SIZE) { <nl> +    if (s->buffer_level > LM4549_BUFFER_SIZE - 2) { <nl>          DPRINTF("write_sample Buffer full\n"); <nl>          return 0; <nl>      }
@@ -891,7 +891,8 @@ int virtio_set_features(VirtIODevice *vdev, uint32_t val) <nl>   <nl>  int virtio_load(VirtIODevice *vdev, QEMUFile *f) <nl>  { <nl> -    int num, i, ret; <nl> +    int i, ret; <nl> +    uint32_t num; <nl>      uint32_t features; <nl>      uint32_t supported_features; <nl>      BusState *qbus = qdev_get_parent_bus(DEVICE(vdev)); <nl> @@ -919,6 +920,11 @@ int virtio_load(VirtIODevice *vdev, QEMUFile *f) <nl>   <nl>      num = qemu_get_be32(f); <nl>   <nl> +    if (num > VIRTIO_PCI_QUEUE_MAX) { <nl> +        error_report("Invalid number of PCI queues: 0x%x", num); <nl> +        return -1; <nl> +    } <nl> + <nl>      for (i = 0; i < num; i++) { <nl>          vdev->vq[i].vring.num = qemu_get_be32(f); <nl>          if (k->has_variable_vring_alignment) {
@@ -2080,7 +2080,7 @@ void cpu_loop(CPUMIPSState *env) <nl>              syscall_num = env->active_tc.gpr[2] - 4000; <nl>              env->active_tc.PC += 4; <nl>              if (syscall_num >= sizeof(mips_syscall_args)) { <nl> -                ret = -ENOSYS; <nl> +                ret = -TARGET_ENOSYS; <nl>              } else { <nl>                  int nb_args; <nl>                  abi_ulong sp_reg;
@@ -1304,7 +1304,7 @@ static void ide_atapi_cmd(IDEState *s) <nl>          break; <nl>      case GPCMD_START_STOP_UNIT: <nl>          { <nl> -            int start, eject, err = 0; <nl> +            int start, eject, sense, err = 0; <nl>              start = packet[4] & 1; <nl>              eject = (packet[4] >> 1) & 1; <nl>   <nl> @@ -1317,7 +1317,11 @@ static void ide_atapi_cmd(IDEState *s) <nl>                  ide_atapi_cmd_ok(s); <nl>                  break; <nl>              case -EBUSY: <nl> -                ide_atapi_cmd_error(s, SENSE_NOT_READY, <nl> +                sense = SENSE_NOT_READY; <nl> +                if (bdrv_is_inserted(s->bs)) { <nl> +                    sense = SENSE_ILLEGAL_REQUEST; <nl> +                } <nl> +                ide_atapi_cmd_error(s, sense, <nl>                                      ASC_MEDIA_REMOVAL_PREVENTED); <nl>                  break; <nl>              default:
@@ -184,11 +184,6 @@ exynos4210_combiner_read(void *opaque, target_phys_addr_t offset, unsigned size) <nl>      uint32_t reg_n;              /* Register number inside the quad */ <nl>      uint32_t val; <nl>   <nl> -    if (s->external && (offset > 0x3c && offset != 0x100)) { <nl> -        hw_error("exynos4210.combiner: unallowed read access at offset 0x" <nl> -                TARGET_FMT_plx "\n", offset); <nl> -    } <nl> - <nl>      req_quad_base_n = offset >> 4; <nl>      grp_quad_base_n = req_quad_base_n << 2; <nl>      reg_n = (offset - (req_quad_base_n << 4)) >> 2; <nl> @@ -281,11 +276,6 @@ static void exynos4210_combiner_write(void *opaque, target_phys_addr_t offset, <nl>      uint32_t grp_quad_base_n;    /* Base of group quad */ <nl>      uint32_t reg_n;              /* Register number inside the quad */ <nl>   <nl> -    if (s->external && (offset > 0x3c && offset != 0x100)) { <nl> -        hw_error("exynos4210.combiner: unallowed write access at offset 0x" <nl> -                TARGET_FMT_plx "\n", offset); <nl> -    } <nl> - <nl>      req_quad_base_n = offset >> 4; <nl>      grp_quad_base_n = req_quad_base_n << 2; <nl>      reg_n = (offset - (req_quad_base_n << 4)) >> 2;
@@ -492,6 +492,9 @@ struct nand_flash_s *nand_init(int manf_id, int chip_id) <nl>      if (pagesize) <nl>          s->storage = (uint8_t *) memset(qemu_malloc(s->pages * pagesize), <nl>                          0xff, s->pages * pagesize); <nl> +    /* Give s->ioaddr a sane value in case we save state before it <nl> +       is used.  */ <nl> +    s->ioaddr = s->io; <nl>   <nl>      register_savevm("nand", -1, 0, nand_save, nand_load, s); <nl>  
@@ -372,13 +372,16 @@ int qemu_create_pidfile(const char *filename) <nl>          return -1; <nl>      } <nl>      if (lockf(fd, F_TLOCK, 0) == -1) { <nl> +        close(fd); <nl>          return -1; <nl>      } <nl>      len = snprintf(buffer, sizeof(buffer), FMT_pid "\n", getpid()); <nl>      if (write(fd, buffer, len) != len) { <nl> +        close(fd); <nl>          return -1; <nl>      } <nl>   <nl> +    close(fd); <nl>      return 0; <nl>  } <nl>  
@@ -181,6 +181,10 @@ tight_detect_smooth_image24(VncState *vs, int w, int h) <nl>          } <nl>      } <nl>   <nl> +    if (pixels == 0) { <nl> +        return 0; <nl> +    } <nl> + <nl>      /* 95% smooth or more ... */ <nl>      if (stats[0] * 33 / pixels >= 95) { <nl>          return 0; <nl> @@ -267,7 +271,9 @@ tight_detect_smooth_image24(VncState *vs, int w, int h) <nl>                  y += w;                                                 \ <nl>              }                                                           \ <nl>          }                                                               \ <nl> -                                                                        \ <nl> +        if (pixels == 0) {                                              \ <nl> +            return 0;                                                   \ <nl> +        }                                                               \ <nl>          if ((stats[0] + stats[1]) * 100 / pixels >= 90) {               \ <nl>              return 0;                                                   \ <nl>          }                                                               \
@@ -142,6 +142,7 @@ void espdma_memory_read(void *opaque, uint8_t *buf, int len) <nl>      DPRINTF("DMA read, direction: %c, addr 0x%8.8x\n", <nl>              s->dmaregs[0] & DMA_WRITE_MEM ? 'w': 'r', s->dmaregs[1]); <nl>      sparc_iommu_memory_read(s->iommu, s->dmaregs[1], buf, len); <nl> +    DPRINTF("Raise IRQ\n"); <nl>      s->dmaregs[0] |= DMA_INTR; <nl>      s->dmaregs[1] += len; <nl>  } <nl> @@ -153,6 +154,7 @@ void espdma_memory_write(void *opaque, uint8_t *buf, int len) <nl>      DPRINTF("DMA write, direction: %c, addr 0x%8.8x\n", <nl>              s->dmaregs[0] & DMA_WRITE_MEM ? 'w': 'r', s->dmaregs[1]); <nl>      sparc_iommu_memory_write(s->iommu, s->dmaregs[1], buf, len); <nl> +    DPRINTF("Raise IRQ\n"); <nl>      s->dmaregs[0] |= DMA_INTR; <nl>      s->dmaregs[1] += len; <nl>  }
@@ -524,6 +524,11 @@ static int cli_cvdverify(FILE *fs, struct cl_cvd *cvdpt, unsigned int skipsig) <nl>      } <nl>   <nl>      md5 = cli_hashstream(fs, NULL, 1); <nl> +    if (md5 == NULL) { <nl> +	cli_dbgmsg("cli_cvdverify: Cannot generate hash, out of memory\n"); <nl> +	cl_cvdfree(cvd); <nl> +	return CL_EMEM; <nl> +    } <nl>      cli_dbgmsg("MD5(.tar.gz) = %s\n", md5); <nl>   <nl>      if(strncmp(md5, cvd->md5, 32)) {
@@ -69,12 +69,14 @@ int main(int argc, char *argv[]) <nl>      f = fopen(argv[1], "r"); <nl>      if (!f) { <nl>  	fprintf(stderr, "Unable to load %s\n", argv[1]); <nl> +	optfree(opts); <nl>  	exit(2); <nl>      } <nl>   <nl>      bc = malloc(sizeof(*bc)); <nl>      if (!bc) { <nl>  	fprintf(stderr, "Out of memory\n"); <nl> +	optfree(opts); <nl>  	exit(3); <nl>      } <nl>   <nl> @@ -82,6 +84,7 @@ int main(int argc, char *argv[]) <nl>      rc = cli_bytecode_load(bc, f, NULL); <nl>      if (rc != CL_SUCCESS) { <nl>  	fprintf(stderr,"Unable to load bytecode: %s\n", cl_strerror(rc)); <nl> +	optfree(opts); <nl>  	exit(4); <nl>      } <nl>      fclose(f); <nl> @@ -99,5 +102,6 @@ int main(int argc, char *argv[]) <nl>      cli_bytecode_destroy_context(ctx); <nl>      cli_bytecode_destroy(bc); <nl>      free(bc); <nl> +    optfree(opts); <nl>      return 0; <nl>  }
@@ -651,7 +651,7 @@ void cache_add(unsigned char *md5, size_t size, cli_ctx *ctx) { <nl>      uint32_t level; <nl>      struct CACHE *c; <nl>   <nl> -    if(!ctx || !ctx->engine || !ctx->engine->cache) <nl> +    if(!ctx || !ctx->engine || !ctx->engine->cache || ctx->found_possibly_unwanted) <nl>         return; <nl>   <nl>      level =  (*ctx->fmap && (*ctx->fmap)->dont_cache_flag) ? ctx->recursion : 0;
@@ -34,7 +34,9 @@ extern "C" { <nl>   <nl>  #ifdef DEBUG <nl>  # include <stdio.h> <nl> +# include <stdint.h> <nl>   <nl> +extern uint8_t cli_debug_flag; <nl>  /* Old GCCs don't have __func__, but __FUNCTION__: <nl>   * http://gcc.gnu.org/onlinedocs/gcc/Function-Names.html <nl>   */ <nl> @@ -46,8 +48,11 @@ extern "C" { <nl>  #  endif <nl>  # endif <nl>  /* Adding custom clamav debug code. */ <nl> -# define D(x) do {   printf("LibClamAV debug: %s:%d (%s)", __FILE__, __LINE__, __func__); \ <nl> -                     printf x ; fputc('\n', stdout); fflush(stdout);} while (0); <nl> +# define D(x) do {   if(cli_debug_flag) { \ <nl> +                        printf("LibClamAV debug: %s:%d (%s)", __FILE__, __LINE__, __func__); \ <nl> +                        printf x ; fputc('\n', stdout); fflush(stdout); \ <nl> +                     } \ <nl> +                  } while (0); <nl>   <nl>  #else <nl>  # define D(x)
@@ -1811,10 +1811,11 @@ abort: <nl>  		if(file_buff_text->fd != -1) <nl>  			close(file_buff_text->fd); <nl>  		free(file_buff_text); <nl> +        file_buff_text=NULL; <nl>  	} <nl>  	if(file_tmp_o1) { <nl>  		html_output_flush(file_tmp_o1); <nl> -		if(file_buff_text->fd != -1) <nl> +		if(file_buff_text && file_buff_text->fd != -1) <nl>  			close(file_tmp_o1->fd); <nl>  		free(file_tmp_o1); <nl>  	}
@@ -100,7 +100,7 @@ float Segment::justify(Slot *pSlot, const Font *font, float width, GR_MAYBE_UNUS <nl>      int numLevels = silf()->numJustLevels(); <nl>      if (!numLevels) <nl>      { <nl> -        for (s = pSlot; s && s != end; s = s->next()) <nl> +        for (s = pSlot; s && s != end; s = s->nextSibling()) <nl>          { <nl>              CharInfo *c = charinfo(s->before()); <nl>              if (isWhitespace(c->unicodeChar())) <nl> @@ -113,7 +113,7 @@ float Segment::justify(Slot *pSlot, const Font *font, float width, GR_MAYBE_UNUS <nl>          } <nl>          if (!icount) <nl>          { <nl> -            for (s = pSlot; s != end; s = s->nextSibling()) <nl> +            for (s = pSlot; s && s != end; s = s->nextSibling()) <nl>              { <nl>                  s->setJustify(this, 0, 3, 1); <nl>                  s->setJustify(this, 0, 2, 1); <nl> @@ -124,7 +124,7 @@ float Segment::justify(Slot *pSlot, const Font *font, float width, GR_MAYBE_UNUS <nl>      } <nl>   <nl>      Vector<JustifyTotal> stats(numLevels); <nl> -    for (s = pFirst; s != end; s = s->nextSibling()) <nl> +    for (s = pFirst; s && s != end; s = s->nextSibling()) <nl>      { <nl>          float w = s->origin().x / scale + s->advance() - base; <nl>          if (w > currWidth) currWidth = w; <nl> @@ -145,7 +145,7 @@ float Segment::justify(Slot *pSlot, const Font *font, float width, GR_MAYBE_UNUS <nl>              diff = width - currWidth; <nl>              diffpw = diff / tWeight; <nl>              tWeight = 0; <nl> -            for (s = pFirst; s != end; s = s->nextSibling()) // don't include final glyph <nl> +            for (s = pFirst; s && s != end; s = s->nextSibling()) // don't include final glyph <nl>              { <nl>                  int w = s->getJustify(this, i, 3); <nl>                  float pref = diffpw * w + error;
@@ -164,6 +164,10 @@ GlyphCache::GlyphCache(const Face & face, const uint32 face_options) <nl>          } <nl>          delete _glyph_loader; <nl>          _glyph_loader = 0; <nl> +	// coverity[leaked_storage : FALSE] - calling read_glyph on index 0 saved <nl> +	// glyphs as _glyphs[0]. Setting _glyph_loader to nullptr here flags that <nl> +	// the dtor needs to call delete[] on _glyphs[0] to release what was allocated <nl> +	// as glyphs <nl>      } <nl>   <nl>      if (_glyphs && glyph(0) == 0)
@@ -452,7 +452,7 @@ static int parse_prlim(struct rlimit *lim, char *ops, size_t id) <nl>   <nl>  static int add_prlim(char *ops, struct list_head *lims, size_t id) <nl>  { <nl> -	struct prlimit *lim = calloc(1, sizeof(*lim)); <nl> +	struct prlimit *lim = xcalloc(1, sizeof(*lim)); <nl>   <nl>  	INIT_LIST_HEAD(&lim->lims); <nl>  	lim->desc = &prlimit_desc[id];
@@ -194,12 +194,11 @@ static int fincore_fd (struct fincore_control *ctl, <nl>  		       off_t *count_incore) <nl>  { <nl>  	size_t window_size = N_PAGES_IN_WINDOW * ctl->pagesize; <nl> -	off_t file_offset; <nl> +	off_t file_offset, len; <nl>  	int rc = 0; <nl>  	int warned_once = 0; <nl>   <nl> -	for (file_offset = 0; file_offset < file_size; file_offset += window_size) { <nl> -		off_t len; <nl> +	for (file_offset = 0; file_offset < file_size; file_offset += len) { <nl>  		void  *window = NULL; <nl>   <nl>  		len = file_size - file_offset;
@@ -189,7 +189,8 @@ static void test_super(int *start, size_t * length) <nl>  	if (super.flags & ~CRAMFS_SUPPORTED_FLAGS) <nl>  		errx(FSCK_EX_ERROR, _("unsupported filesystem features")); <nl>   <nl> -	if (super.size < page_size) <nl> +	/* What are valid superblock sizes? */ <nl> +	if (super.size < sizeof(struct cramfs_super)) <nl>  		errx(FSCK_EX_UNCORRECTED, _("superblock size (%d) too small"), <nl>  		     super.size); <nl>  
@@ -540,7 +540,7 @@ xbsd_write_bootstrap (void) <nl>    memmove (&dl, d, sizeof (struct xbsd_disklabel)); <nl>   <nl>    /* The disklabel will be overwritten by 0's from bootxx anyway */ <nl> -  bzero (d, sizeof (struct xbsd_disklabel)); <nl> +  memset (d, 0, sizeof (struct xbsd_disklabel)); <nl>   <nl>    snprintf (path, sizeof(path), "%s/boot%s", bootdir, dkbasename); <nl>    if (!xbsd_get_bootstrap (path, &disklabelbuffer[xbsd_dlabel.d_secsize], <nl> @@ -656,7 +656,7 @@ xbsd_initlabel (struct partition *p, struct xbsd_disklabel *d, int pindex) { <nl>  	struct geom g; <nl>   <nl>  	get_geometry (fd, &g); <nl> -	bzero (d, sizeof (struct xbsd_disklabel)); <nl> +	memset (d, 0, sizeof (struct xbsd_disklabel)); <nl>   <nl>  	d -> d_magic = BSD_DISKMAGIC; <nl>  
@@ -246,14 +246,14 @@ int mnt_optmap_enum_to_number(const struct mnt_optmap *mapent, <nl>  	int n = -1; <nl>   <nl>  	if (!rawdata || !*rawdata || !mapent || !len) <nl> -		return -1; <nl> +		return -EINVAL; <nl>   <nl>  	p = strrchr(mapent->name, '='); <nl>  	if (!p || *(p + 1) == '{') <nl> -		return -1;	/* value unexpected or not "enum" */ <nl> +		return -EINVAL;	/* value unexpected or not "enum" */ <nl>  	p += 2; <nl>  	if (!*p || *(p + 1) == '}') <nl> -		return -1;	/* hmm... option <type> is "={" or "={}" */ <nl> +		return -EINVAL;	/* hmm... option <type> is "={" or "={}" */ <nl>   <nl>  	/* we cannot use strstr(), @rawdata is not terminated */ <nl>  	for (; p && *p; p++) { <nl> @@ -266,7 +266,7 @@ int mnt_optmap_enum_to_number(const struct mnt_optmap *mapent, <nl>  		if (!begin || !end) <nl>  			continue; <nl>  		if (end <= begin) <nl> -			return -1; <nl> +			return -EINVAL; <nl>  		n++; <nl>  		if (len == end - begin && strncasecmp(begin, rawdata, len) == 0) <nl>  			return n;
@@ -421,8 +421,10 @@ static wchar_t *mbs_to_wcs(const char *s) <nl>  		return NULL; <nl>  	wcs = xmalloc((n + 1) * sizeof(wchar_t)); <nl>  	n = mbstowcs(wcs, s, n + 1); <nl> -	if (n < 0) <nl> +	if (n < 0) { <nl> +		free(wcs); <nl>  		return NULL; <nl> +	} <nl>  	return wcs; <nl>  } <nl>  #endif
@@ -258,7 +258,7 @@ int read_hypervisor_dmi(void) <nl>  	if (rc) <nl>  		goto done; <nl>  	free(buf); <nl> - <nl> +	buf = NULL; <nl>  memory_scan: <nl>  #if defined(__x86_64__) || defined(__i386__) <nl>  	/* Fallback to memory scan (x86, x86_64) */
@@ -533,13 +533,15 @@ modify_environment (const struct passwd *pw, const char *shell) <nl>      { <nl>        /* Leave TERM unchanged.  Set HOME, SHELL, USER, LOGNAME, PATH. <nl>           Unset all other environment variables.  */ <nl> -      char const *term = getenv ("TERM"); <nl> +      char *term = getenv ("TERM"); <nl>        if (term) <nl>  	term = xstrdup (term); <nl>        environ = xmalloc ((6 + !!term) * sizeof (char *)); <nl>        environ[0] = NULL; <nl> -      if (term) <nl> +      if (term) { <nl>  	xsetenv ("TERM", term, 1); <nl> +	free(term); <nl> +      } <nl>        xsetenv ("HOME", pw->pw_dir, 1); <nl>        if (shell) <nl>  	xsetenv ("SHELL", shell, 1);
@@ -326,7 +326,7 @@ enomem: <nl>  /* <nl>   * Parses one line from /proc/swaps <nl>   */ <nl> -static int mnt_parse_swaps_line(struct libmnt_fs *fs, char *s) <nl> +static int mnt_parse_swaps_line(struct libmnt_fs *fs, const char *s) <nl>  { <nl>  	uintmax_t fsz, usz; <nl>  	int rc;
@@ -197,10 +197,11 @@ readlink_to_namei(struct namei *nm, const char *path) <nl>  		err(EXIT_FAILURE, _("out of memory?")); <nl>   <nl>  	if (*sym != '/') { <nl> +		/* create the absolute path from the relative symlink */ <nl>  		memcpy(nm->abslink, path, nm->relstart); <nl>  		*(nm->abslink + nm->relstart) = '/'; <nl>  		nm->relstart++; <nl> -		memcpy(nm->abslink + nm->relstart, sym, sz); <nl> +		memcpy(nm->abslink + nm->relstart, sym, sz - nm->relstart); <nl>  	} else <nl>  		memcpy(nm->abslink, sym, sz); <nl>  	nm->abslink[sz] = '\0';
@@ -25,12 +25,8 @@ <nl>   */ <nl>  blkid_loff_t blkid_get_dev_size(int fd) <nl>  { <nl> -	struct stat st; <nl>  	unsigned long long bytes; <nl>   <nl> -	if (fstat(fd, &st) == 0 && S_ISREG(st.st_mode)) <nl> -		return st.st_size; <nl> - <nl>  	if (blkdev_get_size(fd, &bytes)) <nl>  		return 0; <nl>  
@@ -626,6 +626,8 @@ void TrackerFiltersList::handleFavicoDownload(const QString& url, const QString& <nl>      } <nl>   <nl>      QListWidgetItem *trackerItem = item(rowFromTracker(host)); <nl> +    if (!trackerItem) return; <nl> + <nl>      QIcon icon(filePath); <nl>      //Detect a non-decodable icon <nl>      QList<QSize> sizes = icon.availableSizes();
@@ -219,7 +219,10 @@ GUI::~GUI() { <nl>    delete status_bar; <nl>    delete transferList; <nl>    delete guiUpdater; <nl> - <nl> +  if (console) <nl> +    delete console; <nl> +  if(options) <nl> +    delete options; <nl>    if(rssWidget) <nl>      delete rssWidget; <nl>    delete searchEngine;
@@ -1820,7 +1820,7 @@ void Bittorrent::addConsoleMessage(QString msg, QString) { <nl>            if(!defaultTempPath.isEmpty()) { <nl>              // Check if directory is different <nl>              QDir current_dir(h.save_path()); <nl> -            QDir save_dir(getSavePath(h.hash())); <nl> +            QDir save_dir(getSavePath(hash)); <nl>              if(current_dir != save_dir) { <nl>                h.move_storage(save_dir.path()); <nl>              } <nl> @@ -2048,7 +2048,6 @@ void Bittorrent::addConsoleMessage(QString msg, QString) { <nl>              } <nl>            } <nl>            emit torrentFinishedChecking(h); <nl> -          emit metadataReceived(h); <nl>            if(torrentsToPausedAfterChecking.contains(hash)) { <nl>              torrentsToPausedAfterChecking.removeOne(hash); <nl>              h.pause();
@@ -259,7 +259,8 @@ spk_fslurp(spk_t* spk, const char* path, size_t *out_size) <nl>  	al_fseek(spk->file, p_entry->offset, ALLEGRO_SEEK_SET); <nl>  	if (al_fread(spk->file, packdata, p_entry->pack_size) < p_entry->pack_size) <nl>  		goto on_error; <nl> -	if (!(unpacked = malloc(p_entry->file_size))) goto on_error; <nl> +	if (!(unpacked = malloc(p_entry->file_size + 1))) <nl> +		goto on_error; <nl>  	z.avail_in = (uInt)p_entry->pack_size; <nl>  	z.next_in = packdata; <nl>  	z.avail_out = (uInt)p_entry->file_size; <nl> @@ -269,6 +270,8 @@ spk_fslurp(spk_t* spk, const char* path, size_t *out_size) <nl>  		goto on_error; <nl>  	inflateEnd(&z); <nl>  	free(packdata); <nl> +	*((char*)unpacked + p_entry->file_size) = '\0'; <nl> +	 <nl>  	*out_size = p_entry->file_size; <nl>  	return unpacked; <nl>  
@@ -39,6 +39,7 @@ static void migrateDataDir() { <nl>  	QString linksTo = QFile::readLink(olddir); <nl>  	if (!QFile::exists(newdir) && QFile::exists(olddir) && linksTo.isEmpty()) { <nl>  		QDir d; <nl> +		d.mkpath(newdir + QLatin1String("/..")); <nl>  		if (d.rename(olddir, newdir)) { <nl>  			if (d.cd(QDir::homePath() + QLatin1String("/Library/Preferences"))) { <nl>  				if (QFile::link(d.relativeFilePath(newdir), olddir)) {
@@ -14,6 +14,7 @@ static const char *overlayLaunchers[] = { <nl>  	"UbisoftGameLauncher.exe", // Uplay <nl>  	"UbisoftGameLauncher64.exe", // Uplay <nl>  	"itch.exe", // itch.io <nl> +	"LaunchPad.exe", // Daybreak Games LaunchPad <nl>   <nl>  	"evelauncher.exe", // EVE Online launcher <nl>  	"ffxivlauncher.exe", // Final Fantasy XIV Launcher
@@ -103,7 +103,9 @@ int rpmdbRebuild(char * rootdir) { <nl>  			"to recover", dbpath, newdbpath); <nl>  	    return 1; <nl>  	} <nl> -	rmdir(newdbpath); <nl> +	if (rmdir(newdbpath)) <nl> +	    rpmMessage(RPMERR_RMDIR, "failed to remove %s: %s\n", <nl> +			newdbpath, strerror(errno)); <nl>      } <nl>   <nl>  
@@ -32,8 +32,6 @@ struct rpmte_s { <nl>      char * release;		/*!< Release: */ <nl>      char * arch;		/*!< Architecture hint. */ <nl>      char * os;			/*!< Operating system hint. */ <nl> -    int archScore;		/*!< (TR_ADDED) Arch score. */ <nl> -    int osScore;		/*!< (TR_ADDED) Os score. */ <nl>      int isSource;		/*!< (TR_ADDED) source rpm? */ <nl>   <nl>      rpmte depends;              /*!< Package updated by this package (ERASE te) */ <nl> @@ -233,10 +231,7 @@ static void addTE(rpmte p, Header h, fnpyKey key, rpmRelocation * relocs) <nl>      p->epoch = headerGetAsString(h, RPMTAG_EPOCH); <nl>   <nl>      p->arch = headerGetAsString(h, RPMTAG_ARCH); <nl> -    p->archScore = p->arch ? rpmMachineScore(RPM_MACHTABLE_INSTARCH, p->arch) : 0; <nl> - <nl>      p->os = headerGetAsString(h, RPMTAG_OS); <nl> -    p->osScore = p->os ? rpmMachineScore(RPM_MACHTABLE_INSTOS, p->os) : 0; <nl>   <nl>      p->isSource = headerIsSource(h); <nl>      
@@ -72,7 +72,7 @@ void rpmstrPoolFreeze(rpmstrPool pool) <nl>   <nl>  void rpmstrPoolUnfreeze(rpmstrPool pool) <nl>  { <nl> -    if (pool) { <nl> +    if (pool && pool->hash == NULL) { <nl>  	int sizehint = (pool->offs_size / 2) - 1; <nl>  	if (sizehint < STRHASH_INITSIZE) <nl>  	    sizehint = STRHASH_INITSIZE;
@@ -4,6 +4,7 @@ <nl>   <nl>  #include "system.h" <nl>   <nl> +#include <assert.h> <nl>  #include <netinet/in.h> <nl>   <nl>  #include "rpmmacro.h" <nl> @@ -26,12 +27,13 @@ <nl>  #define	IPPORT_PGPKEYSERVER	11371 <nl>  #endif <nl>   <nl> +#define	URLMAGIC	0xd00b1ed0 <nl> +#define	URLSANE(u)	assert(u && u->magic == URLMAGIC) <nl> + <nl>  /** <nl>   */ <nl>  int _url_debug = 0; <nl>   <nl> -#define	URLDBG(_f, _m, _x)	if ((_url_debug | (_f)) & (_m)) fprintf _x <nl> - <nl>  urlinfo urlNew() <nl>  { <nl>      urlinfo u;
@@ -64,7 +64,12 @@ int pkgReadHeader(int fd, Header * hdr, int * isSource) { <nl>  	    readOldHeader(fd, hdr, isSource); <nl>  	    arch = getArchNum(); <nl>  	    addEntry(*hdr, RPMTAG_ARCH, INT8_TYPE, &arch, 1); <nl> -	} else if (lead.major == 2) { <nl> +	} else if (lead.major == 2 || lead.major == 3) { <nl> +	    if (lead.minor) { <nl> +		error(RPMERR_NEWPACKAGE, "only packages with minor numbers = 0" <nl> +			" are supported by this version of RPM"); <nl> +		return 2; <nl> +	    } <nl>  	    if (!readSignature(fd, lead.signature_type, NULL)) { <nl>  	       return 2; <nl>  	    }
@@ -57,7 +57,7 @@ static int isSpecFile(const char *specfile) <nl>      int count; <nl>      int checking; <nl>   <nl> -    if ((fd = fdOpen(specfile, O_RDONLY, 0)) < 0) { <nl> +    if (fdFileno((fd = fdOpen(specfile, O_RDONLY, 0))) < 0) { <nl>  	fprintf(stderr, _("Unable to open spec file: %s\n"), specfile); <nl>  	return 0; <nl>      }
@@ -451,7 +451,7 @@ static int callout_run_socket(const char *callout, <nl>   <nl>      memset(&mysun, 0, sizeof(mysun)); <nl>      mysun.sun_family = AF_UNIX; <nl> -    strncpy(mysun.sun_path, callout, sizeof(mysun.sun_path)); <nl> +    xstrncpy(mysun.sun_path, callout, sizeof(mysun.sun_path)); <nl>      r = connect(sock, (struct sockaddr *)&mysun, sizeof(mysun)); <nl>      if (r < 0) { <nl>          syslog(LOG_ERR, "cannot connect socket for callout: %m");
@@ -447,8 +447,8 @@ void config_read_file(const char *filename) <nl>  	infile = fopen(filename, "r"); <nl>   <nl>      if (!infile) { <nl> -	snprintf(buf, bufsize, "can't open configuration file %s: %m", <nl> -		 filename); <nl> +	snprintf(buf, bufsize, "can't open configuration file %s: %s", <nl> +		 filename, strerror(errno)); <nl>  	fatal(buf, EC_CONFIG); <nl>      } <nl>  
@@ -66,7 +66,7 @@ char **reply; <nl>      r = connect(s, (struct sockaddr *)&srvaddr, sizeof(srvaddr)); <nl>      if (r == -1) { <nl>  	*reply = "cannot connect to pwcheck server"; <nl> -	return 0; <nl> +	return 1; <nl>      } <nl>   <nl>      iov[0].iov_base = user;
@@ -6541,6 +6541,9 @@ static int jmap_write_calendarevent(json_t *event, <nl>          } <nl>          jmap_calendarevent_to_ical(comp, event, &rock); <nl>          jmap_timezones_to_ical(ical, &rock); <nl> +        if (rock.oldcomp) { <nl> +            icalcomponent_free(rock.oldcomp); <nl> +        } <nl>          calevent_rock_free(&rock); <nl>   <nl>          /* Handle any property errors and bail out. */
@@ -69,6 +69,7 @@ <nl>  #include <errno.h> <nl>  #include <limits.h> <nl>  #include <math.h> <nl> +#include <inttypes.h> <nl>   <nl>  #ifndef INADDR_NONE <nl>  #define INADDR_NONE 0xffffffff <nl> @@ -1890,6 +1891,11 @@ static void limit_fds(rlim_t x) <nl>   <nl>  #ifdef HAVE_GETRLIMIT <nl>      if (!getrlimit(RLIMIT_NUMFDS, &rl)) { <nl> +        if (x != RLIM_INFINITY && rl.rlim_max != RLIM_INFINITY && x > rl.rlim_max) { <nl> +            syslog(LOG_WARNING, <nl> +                   "limit_fds: requested %" PRIu64 ", but capped to %" PRIu64, <nl> +                   (uint64_t) x, (uint64_t) rl.rlim_max); <nl> +        } <nl>          rl.rlim_cur = (x == RLIM_INFINITY || x > rl.rlim_max) ? rl.rlim_max : x; <nl>      } <nl>      else
@@ -436,9 +436,9 @@ static int principal_parse_path(const char *path, struct request_target_t *tgt, <nl>          tgt->userid = xstrndup(p, len); <nl>   <nl>          if (httpd_extradomain) { <nl> -            p = strchr(tgt->userid, '@'); <nl> -            if (p && !strcmp(p+1, httpd_extradomain)) <nl> -                *p = 0; <nl> +            char *at = strchr(tgt->userid, '@'); <nl> +            if (at && !strcmp(at+1, httpd_extradomain)) <nl> +                *at = 0; <nl>          } <nl>   <nl>          p += len;
@@ -855,7 +855,7 @@ int deliver(message_data_t *msgdata, char *authuser, <nl>              proxy_adddest(&dlist, recip, n, mbentry->server, authuser); <nl>              status[n] = nosieve; <nl>          } <nl> -        else { <nl> +        else if (!r) { <nl>              /* local mailbox */ <nl>              mydata.cur_rcpt = n; <nl>  #ifdef USE_SIEVE
@@ -1425,7 +1425,7 @@ EXPORTED int mailbox_remove_user_flag(struct mailbox *mailbox, int flagnum) <nl>      return 0; <nl>  } <nl>   <nl> -int mailbox_record_hasflag(struct mailbox *mailbox, <nl> +EXPORTED int mailbox_record_hasflag(struct mailbox *mailbox, <nl>                             const struct index_record *record, <nl>                             const char *flag) <nl>  {
@@ -2406,6 +2406,10 @@ EXPORTED int index_snippets(struct index_state *state, <nl>      int nmatches = 0; <nl>      struct snippet_rock srock; <nl>   <nl> +    /* reload index */ <nl> +    r = index_refresh(state); <nl> +    if (r) return r; <nl> + <nl>      bx = search_begin_search(state->mailbox, SEARCH_MULTIPLE); <nl>      if (!bx) { <nl>  	r = IMAP_INTERNAL;
@@ -3269,8 +3269,6 @@ int meth_delete(struct transaction_t *txn, void *params) <nl>  	else if (r == IMAP_MAILBOX_NONEXISTENT) ret = HTTP_NOT_FOUND; <nl>  	else if (r) ret = HTTP_SERVER_ERROR; <nl>   <nl> -	dparams->davdb.close_db(davdb); <nl> - <nl>  	goto done; <nl>      } <nl>  
@@ -1,6 +1,6 @@ <nl>  /* lmtpd.c -- Program to deliver mail to a mailbox <nl>   * <nl> - * $Id: lmtpd.c,v 1.34 2000/06/06 21:10:44 ken3 Exp $ <nl> + * $Id: lmtpd.c,v 1.35 2000/06/06 21:13:50 ken3 Exp $ <nl>   * Copyright (c) 1999-2000 Carnegie Mellon University.  All rights reserved. <nl>   * <nl>   * Redistribution and use in source and binary forms, with or without <nl> @@ -42,7 +42,7 @@ <nl>   * <nl>   */ <nl>   <nl> -/*static char _rcsid[] = "$Id: lmtpd.c,v 1.34 2000/06/06 21:10:44 ken3 Exp $";*/ <nl> +/*static char _rcsid[] = "$Id: lmtpd.c,v 1.35 2000/06/06 21:13:50 ken3 Exp $";*/ <nl>   <nl>  #include <config.h> <nl>   <nl> @@ -632,7 +632,7 @@ int sieve_fileinto(void *ac, void *ic, void *sc, void *mc, const char **errmsg) <nl>   <nl>      ret = deliver_mailbox(md->data, &mdata->stage, md->size, <nl>  			  fc->imapflags->flag, fc->imapflags->nflags, <nl> -                          sd->authuser, sd->authstate, md->id, <nl> +                          sd->username, sd->authstate, md->id, <nl>                            sd->username, mdata->notifyheader, <nl>                            fc->mailbox, quotaoverride, 0); <nl>  
@@ -72,6 +72,7 @@ <nl>  /* global state */ <nl>  static volatile sig_atomic_t sigquit = 0; <nl>  static int verbose = 0; <nl> +static int keep_flagged = 1; <nl>   <nl>  /* current namespace */ <nl>  static struct namespace expire_namespace; <nl> @@ -227,7 +228,7 @@ static unsigned archive_cb(struct mailbox *mailbox __attribute__((unused)), <nl>  	return 1; <nl>   <nl>      /* don't archive flagged messages - XXX, optional? */ <nl> -    if (record->system_flags & FLAG_FLAGGED) <nl> +    if (keep_flagged && (record->system_flags & FLAG_FLAGGED)) <nl>  	return 0; <nl>   <nl>      /* archive all other old messages */ <nl> @@ -507,7 +508,7 @@ int main(int argc, char *argv[]) <nl>      memset(&crock, 0, sizeof(crock)); <nl>      construct_hash_table(&crock.seen, 100, 1); <nl>   <nl> -    while ((opt = getopt(argc, argv, "C:D:E:X:A:p:u:vaxtc")) != EOF) { <nl> +    while ((opt = getopt(argc, argv, "C:D:E:X:A:p:u:vaxtcF")) != EOF) { <nl>  	switch (opt) { <nl>  	case 'C': /* alt config file */ <nl>  	    alt_config = optarg; <nl> @@ -533,6 +534,10 @@ int main(int argc, char *argv[]) <nl>  	    if (!parse_duration(optarg, &expunge_seconds)) usage(); <nl>  	    break; <nl>   <nl> +	case 'F': <nl> +	    keep_flagged = 0; <nl> +	    break; <nl> + <nl>  	case 'p': <nl>  	    find_prefix = optarg; <nl>  	    break;
@@ -477,6 +477,10 @@ int mailbox_ensure_cache(struct mailbox *mailbox, unsigned offset) <nl>  	mailbox->cache_fd = open(fname, openflags, 0); <nl>  	if (mailbox->cache_fd == -1) <nl>  	    goto fail; <nl> + <nl> +	if (mailbox->cache_buf.s) <nl> +	    map_free((const char **)&mailbox->cache_buf.s, &mailbox->cache_len); <nl> +	mailbox->cache_buf.len = 0; <nl>      } <nl>   <nl>      if (offset >= mailbox->cache_buf.len) {
@@ -149,6 +149,7 @@ void **state;			/* On success, filled in with state ptr */ <nl>      char realm[REALM_SZ]; <nl>      char uinst[INST_SZ]; <nl>      char urealm[INST_SZ]; <nl> +    KTEXT_ST authent; <nl>      CREDENTIALS cr; <nl>      struct krb_state *kstate; <nl>   <nl> @@ -170,6 +171,10 @@ void **state;			/* On success, filled in with state ptr */ <nl>      strcpy(realm, krb_realmofhost(host_name->h_name)); <nl>      strcpy(instance, krb_get_phost(host_name->h_name)); <nl>   <nl> +    /* Fetch imap.hostname service key */ <nl> +    (void) krb_mk_req(&authent, "imap", instance, realm, 0); <nl> +    memset(&authent, 0, sizeof(authent)); <nl> + <nl>      if (krb_get_cred("imap", instance, realm, &cr)) { <nl>  	return ACTE_FAIL; <nl>      }
@@ -1,6 +1,6 @@ <nl>  /* mupdate-slave.c -- cyrus murder database clients <nl>   * <nl> - * $Id: mupdate-slave.c,v 1.25 2003/11/14 15:37:04 rjs3 Exp $ <nl> + * $Id: mupdate-slave.c,v 1.26 2004/03/08 19:23:04 rjs3 Exp $ <nl>   * Copyright (c) 1998-2003 Carnegie Mellon University.  All rights reserved. <nl>   * <nl>   * Redistribution and use in source and binary forms, with or without <nl> @@ -264,6 +264,7 @@ static void mupdate_listen(mupdate_handle *handle, int pingtimeout) <nl>      for(;num_kick_fds;num_kick_fds--) { <nl>        close(kick_fds[num_kick_fds-1]); <nl>      } <nl> +    close(kicksock); <nl>  } <nl>   <nl>  void *mupdate_client_start(void *rock __attribute__((unused)))
@@ -5381,8 +5381,9 @@ int report_sync_col(struct transaction_t *txn, <nl>  	    continue; <nl>   <nl>  	/* Get resource filename from Content-Disposition header */ <nl> -	if ((p = index_getheader(&istate, msgno, "Content-Disposition"))) { <nl> -	    resource = strstr(p, "filename=") + 9; <nl> +	if ((p = index_getheader(&istate, msgno, "Content-Disposition")) && <nl> +	    (p = strstr(p, "filename="))) { <nl> +	    resource = p + 9; <nl>  	} <nl>  	if (!resource) continue;  /* No filename */ <nl>  
@@ -184,7 +184,7 @@ static void process_message(struct sockaddr_un *remote, idle_message_t *msg) <nl>  		     * through it's graceful shutdown path, so don't syslog. */ <nl>  		    if (r != ENOENT) <nl>  			syslog(LOG_ERR, "IDLE: error sending message " <nl> -					"NOTIFY to imapd %s for mailbox %s: %s, ", <nl> +					"NOTIFY to imapd %s for mailbox %s: %s, " <nl>  					"forgetting.", <nl>  					idle_id_from_addr(&t->remote), <nl>  					msg->mboxname, error_message(r)); <nl> @@ -243,7 +243,7 @@ static void send_alert(const char *key, <nl>  	     * through it's graceful shutdown path, so don't syslog. */ <nl>  	    if (r != ENOENT) <nl>  		syslog(LOG_ERR, "IDLE: error sending message " <nl> -				"ALERT to imapd %s: %s, ", <nl> +				"ALERT to imapd %s for mailbox %s: %s, " <nl>  				"forgetting.", <nl>  				idle_id_from_addr(&t->remote), <nl>  				msg.mboxname, error_message(r));
@@ -7918,6 +7918,7 @@ static void discardCommand(redisClient *c) { <nl>      freeClientMultiState(c); <nl>      initClientMultiState(c); <nl>      c->flags &= (~REDIS_MULTI); <nl> +    unwatchAllKeys(c); <nl>      addReply(c,shared.ok); <nl>  } <nl>  
@@ -51,10 +51,9 @@ <nl>   * <len> is the length of the following string (key or value). <nl>   * <len> lengths are encoded in a single value or in a 5 bytes value. <nl>   * If the first byte value (as an unsigned 8 bit value) is between 0 and <nl> - * 252, it's a single-byte length. If it is 253 then a four bytes unsigned <nl> + * 253, it's a single-byte length. If it is 254 then a four bytes unsigned <nl>   * integer follows (in the host byte ordering). A value of 255 is used to <nl> - * signal the end of the hash. The special value 254 is used to mark <nl> - * empty space that can be used to add new key/value pairs. <nl> + * signal the end of the hash. <nl>   * <nl>   * <free> is the number of free unused bytes after the string, resulting <nl>   * from modification of values associated to a key. For instance if "foo"
@@ -495,7 +495,7 @@ static void f_parser (lua_State *L, void *ud) { <nl>    struct SParser *p = cast(struct SParser *, ud); <nl>    int c = luaZ_lookahead(p->z); <nl>    luaC_checkGC(L); <nl> -  tf = ((c == LUA_SIGNATURE[0]) ? luaU_undump : luaY_parser)(L, p->z, <nl> +  tf = (luaY_parser)(L, p->z, <nl>                                                               &p->buff, p->name); <nl>    cl = luaF_newLclosure(L, tf->nups, hvalue(gt(L))); <nl>    cl->l.p = tf;
@@ -798,7 +798,9 @@ int loadAppendOnlyFile(char *filename) { <nl>      } <nl>   <nl>      /* This point can only be reached when EOF is reached without errors. <nl> -     * If the client is in the middle of a MULTI/EXEC, log error and quit. */ <nl> +     * If the client is in the middle of a MULTI/EXEC, handle it as it was <nl> +     * a short read, even if technically the protocol is correct: we want <nl> +     * to remove the unprocessed tail and continue. */ <nl>      if (fakeClient->flags & CLIENT_MULTI) goto uxeof; <nl>   <nl>  loaded_ok: /* DB loaded, cleanup and return C_OK to the caller. */
@@ -385,6 +385,7 @@ void mp_encode_lua_table_as_array(lua_State *L, mp_buf *buf, int level) { <nl>  #endif <nl>   <nl>      mp_encode_array(L,buf,len); <nl> +    luaL_checkstack(L, 1, "in function mp_encode_lua_table_as_array"); <nl>      for (j = 1; j <= len; j++) { <nl>          lua_pushnumber(L,j); <nl>          lua_gettable(L,-2); <nl> @@ -400,6 +401,7 @@ void mp_encode_lua_table_as_map(lua_State *L, mp_buf *buf, int level) { <nl>       * Lua API, we need to iterate a first time. Note that an alternative <nl>       * would be to do a single run, and then hack the buffer to insert the <nl>       * map opcodes for message pack. Too hackish for this lib. */ <nl> +    luaL_checkstack(L, 3, "in function mp_encode_lua_table_as_map"); <nl>      lua_pushnil(L); <nl>      while(lua_next(L,-2)) { <nl>          lua_pop(L,1); /* remove value, keep key for next iteration. */ <nl> @@ -522,6 +524,7 @@ int mp_pack(lua_State *L) { <nl>      for(i = 1; i <= nargs; i++) { <nl>          /* Copy argument i to top of stack for _encode processing; <nl>           * the encode function pops it from the stack when complete. */ <nl> +        luaL_checkstack(L, 1, "in function mp_check"); <nl>          lua_pushvalue(L, i); <nl>   <nl>          mp_encode_lua_type(L,buf,0); <nl> @@ -550,6 +553,7 @@ void mp_decode_to_lua_array(lua_State *L, mp_cur *c, size_t len) { <nl>      int index = 1; <nl>   <nl>      lua_newtable(L); <nl> +    luaL_checkstack(L, 1, "in function mp_decode_to_lua_array"); <nl>      while(len--) { <nl>          lua_pushnumber(L,index++); <nl>          mp_decode_to_lua_type(L,c); <nl> @@ -824,6 +828,9 @@ int mp_unpack_full(lua_State *L, int limit, int offset) { <nl>           * subtract the entire buffer size from the unprocessed size <nl>           * to get our next start offset */ <nl>          int offset = len - c.left; <nl> + <nl> +        luaL_checkstack(L, 1, "in function mp_unpack_full"); <nl> + <nl>          /* Return offset -1 when we have have processed the entire buffer. */ <nl>          lua_pushinteger(L, c.left == 0 ? -1 : offset); <nl>          /* Results are returned with the arg elements still
@@ -1351,6 +1351,11 @@ void xreadCommand(client *c) { <nl>          } <nl>   <nl>          if (strcmp(c->argv[i]->ptr,"$") == 0) { <nl> +            if (xreadgroup) { <nl> +                addReplyError(c,"The $ ID can be specified only when calling " <nl> +                              "XREAD without GROUP option."); <nl> +                goto cleanup; <nl> +            } <nl>              if (o) { <nl>                  stream *s = o->ptr; <nl>                  ids[id_idx] = s->last_id;
@@ -183,7 +183,7 @@ size_t zmalloc_size(void *ptr) { <nl>      return size+PREFIX_SIZE; <nl>  } <nl>  size_t zmalloc_usable(void *ptr) { <nl> -    return zmalloc_usable(ptr)-PREFIX_SIZE; <nl> +    return zmalloc_size(ptr)-PREFIX_SIZE; <nl>  } <nl>  #endif <nl>  
@@ -94,6 +94,7 @@ static struct config { <nl>      sds mb_delim; <nl>      char prompt[128]; <nl>      char *eval; <nl> +    int last_cmd_type; <nl>  } config; <nl>   <nl>  static volatile sig_atomic_t force_cancel_loop = 0; <nl> @@ -131,7 +132,7 @@ static void cliRefreshPrompt(void) { <nl>                         strchr(config.hostip,':') ? "[%s]:%d" : "%s:%d", <nl>                         config.hostip, config.hostport); <nl>      /* Add [dbnum] if needed */ <nl> -    if (config.dbnum != 0) <nl> +    if (config.dbnum != 0 && config.last_cmd_type != REDIS_REPLY_ERROR) <nl>          len += snprintf(config.prompt+len,sizeof(config.prompt)-len,"[%d]", <nl>              config.dbnum); <nl>      snprintf(config.prompt+len,sizeof(config.prompt)-len,"> "); <nl> @@ -532,6 +533,8 @@ static int cliReadReply(int output_raw_strings) { <nl>   <nl>      reply = (redisReply*)_reply; <nl>   <nl> +    config.last_cmd_type = reply->type; <nl> + <nl>      /* Check if we need to connect to a different node and reissue the <nl>       * request. */ <nl>      if (config.cluster_mode && reply->type == REDIS_REPLY_ERROR && <nl> @@ -1887,6 +1890,8 @@ int main(int argc, char **argv) { <nl>      config.stdinarg = 0; <nl>      config.auth = NULL; <nl>      config.eval = NULL; <nl> +    config.last_cmd_type = -1; <nl> + <nl>      if (!isatty(fileno(stdout)) && (getenv("FAKETTY") == NULL)) <nl>          config.output = OUTPUT_RAW; <nl>      else
@@ -615,6 +615,7 @@ ff_rm_parse_packet (AVFormatContext *s, AVStream *st, int len, AVPacket *pkt, <nl>              } <nl>          } else <nl>              av_get_packet(pb, pkt, len); <nl> +            rm_ac3_swap_bytes(st, pkt); <nl>   <nl>      } else <nl>          av_get_packet(pb, pkt, len); <nl> @@ -707,6 +708,7 @@ static int rm_read_packet(AVFormatContext *s, AVPacket *pkt) <nl>              } <nl>              pkt->size = len; <nl>          } <nl> +        rm_ac3_swap_bytes(st, pkt); <nl>      } else { <nl>          int seq=1; <nl>  resync: <nl> @@ -724,7 +726,6 @@ resync: <nl>          } <nl>      } <nl>   <nl> -    rm_ac3_swap_bytes(st, pkt); <nl>      return 0; <nl>  } <nl>  
@@ -30,7 +30,7 @@ typedef struct ASSContext{ <nl>      unsigned int event_index; <nl>  }ASSContext; <nl>   <nl> -static void get_line(ByteIOContext *s, char *buf, int maxlen) <nl> +static void ff_get_line(ByteIOContext *s, char *buf, int maxlen) <nl>  { <nl>      int i = 0; <nl>      char c; <nl> @@ -108,7 +108,7 @@ static int read_header(AVFormatContext *s, AVFormatParameters *ap) <nl>      while(!url_feof(pb)){ <nl>          uint8_t line[MAX_LINESIZE]; <nl>   <nl> -        get_line(pb, line, sizeof(line)); <nl> +        ff_get_line(pb, line, sizeof(line)); <nl>   <nl>          if(!memcmp(line, "[Events]", 8)) <nl>              header_remaining= 2;
@@ -347,9 +347,9 @@ static int dnxhd_decode_frame(AVCodecContext *avctx, void *data, int *got_frame, <nl>          first_field = 1; <nl>      } <nl>   <nl> -    if (av_image_check_size(ctx->width, ctx->height, 0, avctx)) <nl> -        return -1; <nl> -    avcodec_set_dimensions(avctx, ctx->width, ctx->height); <nl> +    ret = ff_set_dimensions(avctx, ctx->width, ctx->height); <nl> +    if (ret < 0) <nl> +        return ret; <nl>   <nl>      if (first_field) { <nl>          if ((ret = ff_get_buffer(avctx, picture, 0)) < 0) {
@@ -236,7 +236,8 @@ static int process_line(URLContext *h, char *line, int line_count, <nl>   <nl>          /* error codes are 4xx and 5xx, but regard 401 as a success, so we <nl>           * don't abort until all headers have been parsed. */ <nl> -        if (s->http_code >= 400 && s->http_code < 600 && s->http_code != 401) { <nl> +        if (s->http_code >= 400 && s->http_code < 600 && (s->http_code != 401 <nl> +            || s->auth_state.auth_type != HTTP_AUTH_NONE)) { <nl>              end += strspn(end, SPACE_CHARS); <nl>              av_log(h, AV_LOG_WARNING, "HTTP error %d %s\n", <nl>                     s->http_code, end);
@@ -69,6 +69,10 @@ int avfilter_graph_add_filter(AVFilterGraph *graph, AVFilterContext *filter) <nl>      graph->filters = filters; <nl>      graph->filters[graph->nb_filters++] = filter; <nl>   <nl> +#if FF_API_FOO_COUNT <nl> +    graph->filter_count = graph->nb_filters; <nl> +#endif <nl> + <nl>      return 0; <nl>  } <nl>  
@@ -1046,6 +1046,7 @@ static int dvvideo_decode_frame(AVCodecContext *avctx, <nl>      s->picture.key_frame = 1; <nl>      s->picture.pict_type = FF_I_TYPE; <nl>      avctx->pix_fmt = s->sys->pix_fmt; <nl> +    avctx->time_base = (AVRational){s->sys->frame_rate_base, s->sys->frame_rate}; <nl>      avcodec_set_dimensions(avctx, s->sys->width, s->sys->height); <nl>      if(avctx->get_buffer(avctx, &s->picture) < 0) { <nl>          av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n");
@@ -2072,7 +2072,7 @@ decode_intra_mb: <nl>                      sl->intra4x4_pred_mode_cache[scan8[i]] = decode_cabac_mb_intra4x4_pred_mode(sl, pred); <nl>   <nl>                      ff_dlog(h->avctx, "i4x4 pred=%d mode=%d\n", pred, <nl> -                            h->intra4x4_pred_mode_cache[scan8[i]]); <nl> +                            sl->intra4x4_pred_mode_cache[scan8[i]]); <nl>                  } <nl>              } <nl>              write_back_intra_pred_mode(h, sl);
@@ -4408,7 +4408,7 @@ static int encode_thread(AVCodecContext *c, void *arg){ <nl>                              if(qp < s->avctx->qmin || qp > s->avctx->qmax) <nl>                                  break; <nl>                              backup_s.dquant= dquant; <nl> -                            if(s->mb_intra){ <nl> +                            if(s->mb_intra && s->dc_val[0]){ <nl>                                  for(i=0; i<6; i++){ <nl>                                      dc[i]= s->dc_val[0][ s->block_index[i] ]; <nl>                                      memcpy(ac[i], s->ac_val[0][s->block_index[i]], sizeof(DCTELEM)*16); <nl> @@ -4418,7 +4418,7 @@ static int encode_thread(AVCodecContext *c, void *arg){ <nl>                              encode_mb_hq(s, &backup_s, &best_s, CANDIDATE_MB_TYPE_INTER /* wrong but unused */, pb, pb2, tex_pb,  <nl>                                           &dmin, &next_block, s->mv[mvdir][0][0], s->mv[mvdir][0][1]); <nl>                              if(best_s.qscale != qp){ <nl> -                                if(s->mb_intra){ <nl> +                                if(s->mb_intra && s->dc_val[0]){ <nl>                                      for(i=0; i<6; i++){ <nl>                                          s->dc_val[0][ s->block_index[i] ]= dc[i]; <nl>                                          memcpy(s->ac_val[0][s->block_index[i]], ac[i], sizeof(DCTELEM)*16);
@@ -3107,15 +3107,15 @@ i--; <nl>  		int i; <nl>              if(flags & SWS_ACCURATE_RND){ <nl>                          for(i=0; i<vLumFilterSize; i+=2){ <nl> -                                lumMmxFilter[2*i+0]= lumSrcPtr[i  ]; <nl> -                                lumMmxFilter[2*i+1]= lumSrcPtr[i+(vLumFilterSize>1)]; <nl> +                                lumMmxFilter[2*i+0]= (int32_t)lumSrcPtr[i  ]; <nl> +                                lumMmxFilter[2*i+1]= (int32_t)lumSrcPtr[i+(vLumFilterSize>1)]; <nl>                                  lumMmxFilter[2*i+2]= <nl>                                  lumMmxFilter[2*i+3]= vLumFilter[dstY*vLumFilterSize + i    ] <nl>                                                  + (vLumFilterSize>1 ? vLumFilter[dstY*vLumFilterSize + i + 1]<<16 : 0); <nl>                          } <nl>                          for(i=0; i<vChrFilterSize; i+=2){ <nl> -                                chrMmxFilter[2*i+0]= chrSrcPtr[i  ]; <nl> -                                chrMmxFilter[2*i+1]= chrSrcPtr[i+(vChrFilterSize>1)]; <nl> +                                chrMmxFilter[2*i+0]= (int32_t)chrSrcPtr[i  ]; <nl> +                                chrMmxFilter[2*i+1]= (int32_t)chrSrcPtr[i+(vChrFilterSize>1)]; <nl>                                  chrMmxFilter[2*i+2]= <nl>                                  chrMmxFilter[2*i+3]= vChrFilter[chrDstY*vChrFilterSize + i    ] <nl>                                                  + (vChrFilterSize>1 ? vChrFilter[chrDstY*vChrFilterSize + i + 1]<<16 : 0);
@@ -252,14 +252,14 @@ static void iv_Decode_Chunk(Indeo3DecodeContext *s, <nl>   <nl>          if(cmd == 0) { <nl>              strip++; <nl> -            memcpy(strip, strip-1, sizeof(struct ustr)); <nl> +            memcpy(strip, strip-1, sizeof(*strip)); <nl>              strip->split_flag = 1; <nl>              strip->split_direction = 0; <nl>              strip->height = (strip->height > 8 ? ((strip->height+8)>>4)<<3 : 4); <nl>              continue; <nl>          } else if(cmd == 1) { <nl>              strip++; <nl> -            memcpy(strip, strip-1, sizeof(struct ustr)); <nl> +            memcpy(strip, strip-1, sizeof(*strip)); <nl>              strip->split_flag = 1; <nl>              strip->split_direction = 1; <nl>              strip->width = (strip->width > 8 ? ((strip->width+8)>>4)<<3 : 4);
@@ -90,6 +90,9 @@ static void mm_decode_intra(MmContext * s, int half_horiz, int half_vert, const <nl>      while(i<buf_size) { <nl>          int run_length, color; <nl>   <nl> +        if (y >= s->avctx->height) <nl> +            return; <nl> + <nl>          if (buf[i] & 0x80) { <nl>              run_length = 1; <nl>              color = buf[i]; <nl> @@ -138,6 +141,9 @@ static void mm_decode_inter(MmContext * s, int half_horiz, int half_vert, const <nl>              continue; <nl>          } <nl>   <nl> +        if (y + half_vert >= s->avctx->height) <nl> +            return; <nl> + <nl>          for(i=0; i<length; i++) { <nl>              for(j=0; j<8; j++) { <nl>                  int replace = (buf[r+i] >> (7-j)) & 1;
@@ -201,13 +201,14 @@ int avfilter_poll_frame(AVFilterLink *link) <nl>  void avfilter_start_frame(AVFilterLink *link, AVFilterPicRef *picref) <nl>  { <nl>      void (*start_frame)(AVFilterLink *, AVFilterPicRef *); <nl> +    AVFilterPad *dst = &link_dpad(link); <nl>   <nl> -    if(!(start_frame = link_dpad(link).start_frame)) <nl> +    if(!(start_frame = dst->start_frame)) <nl>          start_frame = avfilter_default_start_frame; <nl>   <nl>      /* prepare to copy the picture if it has insufficient permissions */ <nl> -    if((link_dpad(link).min_perms & picref->perms) != link_dpad(link).min_perms || <nl> -        link_dpad(link).rej_perms & picref->perms) { <nl> +    if((dst->min_perms & picref->perms) != dst->min_perms || <nl> +        dst->rej_perms & picref->perms) { <nl>          /* <nl>          av_log(link->dst, AV_LOG_INFO, <nl>                  "frame copy needed (have perms %x, need %x, reject %x)\n", <nl> @@ -215,7 +216,7 @@ void avfilter_start_frame(AVFilterLink *link, AVFilterPicRef *picref) <nl>                  link_dpad(link).min_perms, link_dpad(link).rej_perms); <nl>          */ <nl>   <nl> -        link->cur_pic = avfilter_default_get_video_buffer(link, link_dpad(link).min_perms); <nl> +        link->cur_pic = avfilter_default_get_video_buffer(link, dst->min_perms); <nl>          link->srcpic = picref; <nl>          link->cur_pic->pts = link->srcpic->pts; <nl>      }
@@ -222,7 +222,7 @@ static CodecTags codec_tags[]={ <nl>      {"A_AC3"            , CODEC_ID_AC3}, <nl>      {"A_DTS"            , CODEC_ID_DTS}, <nl>      {"A_VORBIS"         , CODEC_ID_VORBIS}, <nl> -    {"A_AAC/"           , CODEC_ID_AAC}, <nl> +    {"A_AAC"            , CODEC_ID_AAC}, <nl>      {"A_WAVPACK4"       , CODEC_ID_WAVPACK}, <nl>      {NULL               , CODEC_ID_NONE} <nl>  /* TODO: AC3-9/10 (?), Real, Musepack, Quicktime */ <nl> @@ -2245,7 +2245,7 @@ matroska_read_header (AVFormatContext    *s, <nl>   <nl>              } <nl>   <nl> -            if (codec_id==CODEC_ID_AAC) { <nl> +            else if (codec_id == CODEC_ID_AAC && !track->codec_priv_size) { <nl>                  MatroskaAudioTrack *audiotrack = (MatroskaAudioTrack *) track; <nl>                  int profile = matroska_aac_profile(track->codec_id); <nl>                  int sri = matroska_aac_sri(audiotrack->internal_samplerate);
@@ -489,6 +489,7 @@ static int dv_probe(AVProbeData *p) <nl>      unsigned state, marker_pos = 0; <nl>      int i; <nl>      int matches = 0; <nl> +    int secondary_matches = 0; <nl>   <nl>      if (p->buf_size < 5) <nl>          return 0; <nl> @@ -497,6 +498,10 @@ static int dv_probe(AVProbeData *p) <nl>      for (i = 4; i < p->buf_size; i++) { <nl>          if ((state & 0xffffff7f) == 0x1f07003f) <nl>              matches++; <nl> +        // any section header, also with seq/chan num != 0, <nl> +        // should appear around every 12000 bytes, at least 10 per frame <nl> +        if ((state & 0xff07ff7f) == 0x1f07003f) <nl> +            secondary_matches++; <nl>          if (state == 0x003f0700 || state == 0xff3f0700) <nl>              marker_pos = i; <nl>          if (state == 0xff3f0701 && i - marker_pos == 80) <nl> @@ -505,7 +510,7 @@ static int dv_probe(AVProbeData *p) <nl>      } <nl>   <nl>      if (matches && p->buf_size / matches < 1024*1024) { <nl> -        if (matches > 4) <nl> +        if (matches > 4 || (secondary_matches >= 10 && p->buf_size / secondary_matches < 24000)) <nl>              return AVPROBE_SCORE_MAX*3/4; // not max to avoid dv in mov to match <nl>          return AVPROBE_SCORE_MAX/4; <nl>      }
@@ -149,6 +149,8 @@ static int nuv_header(AVFormatContext *s, AVFormatParameters *ap) { <nl>      if (v_packs) { <nl>          ctx->v_id = stream_nr++; <nl>          vst = av_new_stream(s, ctx->v_id); <nl> +        if (!vst) <nl> +            return AVERROR(ENOMEM); <nl>          vst->codec->codec_type = CODEC_TYPE_VIDEO; <nl>          vst->codec->codec_id = CODEC_ID_NUV; <nl>          vst->codec->width = width; <nl> @@ -163,6 +165,8 @@ static int nuv_header(AVFormatContext *s, AVFormatParameters *ap) { <nl>      if (a_packs) { <nl>          ctx->a_id = stream_nr++; <nl>          ast = av_new_stream(s, ctx->a_id); <nl> +        if (!ast) <nl> +            return AVERROR(ENOMEM); <nl>          ast->codec->codec_type = CODEC_TYPE_AUDIO; <nl>          ast->codec->codec_id = CODEC_ID_PCM_S16LE; <nl>          ast->codec->channels = 2;
@@ -2020,6 +2020,7 @@ static int mpegts_read_packet(AVFormatContext *s, <nl>      MpegTSContext *ts = s->priv_data; <nl>      int ret, i; <nl>   <nl> +    pkt->size = -1; <nl>      ts->pkt = pkt; <nl>      ret = handle_packets(ts, 0); <nl>      if (ret < 0) { <nl> @@ -2037,6 +2038,8 @@ static int mpegts_read_packet(AVFormatContext *s, <nl>          } <nl>      } <nl>   <nl> +    if (!ret && pkt->size < 0) <nl> +        ret = AVERROR(EINTR); <nl>      return ret; <nl>  } <nl>  
@@ -35,6 +35,12 @@ static int a64_write_header(AVFormatContext *s) <nl>          0x00, //charset_lifetime (multi only) <nl>          0x00  //fps in 50/fps; <nl>      }; <nl> + <nl> +    if (avctx->extradata_size < 4) { <nl> +        av_log(s, AV_LOG_ERROR, "Missing extradata\n"); <nl> +        return AVERROR(EINVAL); <nl> +    } <nl> + <nl>      switch (avctx->codec->id) { <nl>      case AV_CODEC_ID_A64_MULTI: <nl>          header[2] = 0x00;
@@ -496,7 +496,7 @@ static void unpack_alpha(GetBitContext *gb, uint16_t *dst, int num_coeffs, <nl>                  dst[idx++] = alpha_val >> 6; <nl>              else <nl>                  dst[idx++] = (alpha_val << 2) | (alpha_val >> 6); <nl> -            if (idx == num_coeffs - 1) <nl> +            if (idx >= num_coeffs - 1) <nl>                  break; <nl>          } while (get_bits1(gb)); <nl>          val = get_bits(gb, 4);
@@ -57,6 +57,11 @@ static int decode_frame(AVCodecContext *avctx, <nl>      if (p->data[0]) <nl>          avctx->release_buffer(avctx, p); <nl>   <nl> +    if (avctx->height <= 0 || avctx->width <= 0) { <nl> +        av_log(avctx, AV_LOG_ERROR, "Invalid width or height\n"); <nl> +        return AVERROR_INVALIDDATA; <nl> +    } <nl> + <nl>      if (buf_size / avctx->height < avctx->width) { <nl>          av_log(avctx, AV_LOG_ERROR, <nl>                 "Resolution larger than buffer size. Invalid header?\n");
@@ -264,7 +264,9 @@ int av_opt_show(void *obj, void *av_log_obj){ <nl>          av_log(av_log_obj, AV_LOG_INFO, "%c", (opt->flags & AV_OPT_FLAG_AUDIO_PARAM   ) ? 'A' : '.'); <nl>          av_log(av_log_obj, AV_LOG_INFO, "%c", (opt->flags & AV_OPT_FLAG_SUBTITLE_PARAM) ? 'S' : '.'); <nl>           <nl> -        av_log(av_log_obj, AV_LOG_INFO, " %s\n", opt->help); <nl> +        if(opt->help) <nl> +            av_log(av_log_obj, AV_LOG_INFO, " %s", opt->help); <nl> +        av_log(av_log_obj, AV_LOG_INFO, "\n"); <nl>      } <nl>      return 0; <nl>  }
@@ -964,6 +964,8 @@ static void flush_encoders(void) <nl>                      pkt.pts = av_rescale_q(pkt.pts, enc->time_base, ost->st->time_base); <nl>                  if (pkt.dts != AV_NOPTS_VALUE) <nl>                      pkt.dts = av_rescale_q(pkt.dts, enc->time_base, ost->st->time_base); <nl> +                if (pkt.duration > 0) <nl> +                    pkt.duration = av_rescale_q(pkt.duration, enc->time_base, ost->st->time_base); <nl>                  write_frame(os, &pkt, ost); <nl>              } <nl>  
@@ -868,9 +868,10 @@ static int msmpeg4_decode_block(MpegEncContext * s, DCTELEM * block, <nl>                      if (code < 0 || code >= rl->n) <nl>                          return -1; <nl>                      run = rl->table_run[code]; <nl> -                    level = rl->table_level[code] * qmul + qadd; <nl> +                    level = rl->table_level[code]; <nl>                      last = code >= rl->last; <nl>                      run += rl->max_run[last][level] + run_diff; <nl> +                    level= level * qmul + qadd; <nl>                      if (get_bits1(&s->gb)) <nl>                          level = -level; <nl>                  }
@@ -127,7 +127,7 @@ static int rm_read_audio_stream_info(AVFormatContext *s, AVStream *st, <nl>              } <nl>   <nl>              rm->audiobuf = av_malloc(rm->audio_framesize * sub_packet_h); <nl> -        } else if ((!strcmp(buf, "cook")) || (!strcmp(buf, "atrc"))) { <nl> +        } else if ((!strcmp(buf, "cook")) || (!strcmp(buf, "atrc")) || (!strcmp(buf, "sipr"))) { <nl>              int codecdata_length, i; <nl>              get_be16(pb); get_byte(pb); <nl>              if (((version >> 16) & 0xff) == 5) <nl> @@ -139,6 +139,7 @@ static int rm_read_audio_stream_info(AVFormatContext *s, AVStream *st, <nl>              } <nl>   <nl>              if (!strcmp(buf, "cook")) st->codec->codec_id = CODEC_ID_COOK; <nl> +            else if (!strcmp(buf, "sipr")) st->codec->codec_id = CODEC_ID_SIPR; <nl>              else st->codec->codec_id = CODEC_ID_ATRAC3; <nl>              st->codec->extradata_size= codecdata_length; <nl>              st->codec->extradata= av_mallocz(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE); <nl> @@ -557,7 +558,8 @@ ff_rm_parse_packet (AVFormatContext *s, AVStream *st, int len, AVPacket *pkt, <nl>      } else if (st->codec->codec_type == CODEC_TYPE_AUDIO) { <nl>          if ((st->codec->codec_id == CODEC_ID_RA_288) || <nl>              (st->codec->codec_id == CODEC_ID_COOK) || <nl> -            (st->codec->codec_id == CODEC_ID_ATRAC3)) { <nl> +            (st->codec->codec_id == CODEC_ID_ATRAC3) || <nl> +            (st->codec->codec_id == CODEC_ID_SIPR)) { <nl>              int x; <nl>              int sps = rm->sub_packet_size; <nl>              int cfs = rm->coded_framesize;
@@ -977,6 +977,10 @@ static int amrnb_decode_frame(AVCodecContext *avctx, void *data, <nl>   <nl>          pitch_sharpening(p, subframe, p->cur_frame_mode, &fixed_sparse); <nl>   <nl> +        if (fixed_sparse.pitch_lag == 0) { <nl> +            av_log(avctx, AV_LOG_ERROR, "The file is corrupted, pitch_lag = 0 is not allowed\n"); <nl> +            return AVERROR_INVALIDDATA; <nl> +        } <nl>          ff_set_fixed_vector(p->fixed_vector, &fixed_sparse, 1.0, <nl>                              AMR_SUBFRAME_SIZE); <nl>  
@@ -421,9 +421,12 @@ static inline int ape_decode_value(APEContext *ctx, APERice *rice) <nl>   <nl>          if (tmpk <= 16) <nl>              x = range_decode_bits(ctx, tmpk); <nl> -        else { <nl> +        else if (tmpk <= 32) { <nl>              x = range_decode_bits(ctx, 16); <nl>              x |= (range_decode_bits(ctx, tmpk - 16) << 16); <nl> +        } else { <nl> +            av_log(ctx->avctx, AV_LOG_ERROR, "Too many bits: %d\n", tmpk); <nl> +            return AVERROR_INVALIDDATA; <nl>          } <nl>          x += overflow << tmpk; <nl>      } else {
@@ -587,11 +587,10 @@ static inline int wmv2_decode_inter_block(Wmv2Context *w, DCTELEM *block, int n, <nl>  static void wmv2_add_block(Wmv2Context *w, DCTELEM *block1, uint8_t *dst, int stride, int n){ <nl>      MpegEncContext * const s= &w->s; <nl>   <nl> +  if (s->block_last_index[n] >= 0) { <nl>      switch(w->abt_type_table[n]){ <nl>      case 0: <nl> -        if (s->block_last_index[n] >= 0) { <nl> -            s->dsp.idct_add (dst, stride, block1); <nl> -        } <nl> +        s->dsp.idct_add (dst, stride, block1); <nl>          break; <nl>      case 1: <nl>          simple_idct84_add(dst           , stride, block1); <nl> @@ -606,6 +605,7 @@ static void wmv2_add_block(Wmv2Context *w, DCTELEM *block1, uint8_t *dst, int st <nl>      default: <nl>          av_log(s->avctx, AV_LOG_ERROR, "internal error in WMV2 abt\n"); <nl>      } <nl> +  } <nl>  } <nl>   <nl>  void ff_wmv2_add_mb(MpegEncContext *s, DCTELEM block1[6][64], uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr){
@@ -637,12 +637,7 @@ static int wma_decode_block(WMACodecContext *s) <nl>              s->channel_coded[0] = 1; <nl>          } <nl>   <nl> -        for(i = 0; i < s->block_len; i++) { <nl> -            a = s->coefs[0][i]; <nl> -            b = s->coefs[1][i]; <nl> -            s->coefs[0][i] = a + b; <nl> -            s->coefs[1][i] = a - b; <nl> -        } <nl> +        s->dsp.butterflies_float(s->coefs[0], s->coefs[1], s->block_len); <nl>      } <nl>   <nl>  next:
@@ -352,6 +352,8 @@ static int parse_pixel_format(AVCodecContext *avctx) <nl>          /*  8 bpp */ <nl>          if (bpp == 8 && r == 0xff && g == 0 && b == 0 && a == 0) <nl>              avctx->pix_fmt = AV_PIX_FMT_GRAY8; <nl> +        else if (bpp == 8 && r == 0 && g == 0 && b == 0 && a == 0xff) <nl> +            avctx->pix_fmt = AV_PIX_FMT_GRAY8; <nl>          /* 16 bpp */ <nl>          else if (bpp == 16 && r == 0xff && g == 0 && b == 0 && a == 0xff00) <nl>              avctx->pix_fmt = AV_PIX_FMT_YA8;
@@ -100,7 +100,7 @@ static int config_input(AVFilterLink *inlink) <nl>      PadContext *pad = ctx->priv; <nl>      const AVPixFmtDescriptor *pix_desc = &av_pix_fmt_descriptors[inlink->format]; <nl>      uint8_t rgba_color[4]; <nl> -    uint8_t rgba_map[4]; <nl> +    uint8_t rgba_map[4] = {0}; <nl>      int i, is_packed_rgb = 1; <nl>   <nl>      switch (inlink->format) {
@@ -131,6 +131,8 @@ static int parse_strk(AVFormatContext *s, <nl>          return AVERROR_INVALIDDATA; <nl>   <nl>      track = AV_RL32(buf + 8); <nl> +    if (track < 0) <nl> +        return AVERROR_INVALIDDATA; <nl>      if (track + 1 > fourxm->track_count) { <nl>          if (av_reallocp_array(&fourxm->tracks, track + 1, sizeof(AudioTrack))) <nl>              return AVERROR(ENOMEM);
@@ -821,6 +821,7 @@ static int cbs_h264_read_nal_unit(CodedBitstreamContext *ctx, <nl>              err = cbs_h264_read_sei(ctx, &bc, sei); <nl>              if (err < 0) { <nl>                  cbs_h264_free_sei(sei); <nl> +                av_free(sei); <nl>                  return err; <nl>              } <nl>  
@@ -746,6 +746,7 @@ _enable_carbons_handler(xmpp_conn_t * const conn, xmpp_stanza_t * const stanza, <nl>          char *error_message = stanza_get_error_message(stanza); <nl>          cons_show_error("Server error enabling message carbons: %s", error_message); <nl>          log_debug("Error enabling carbons: %s", error_message); <nl> +        free(error_message); <nl>      } else { <nl>          log_debug("Message carbons enabled."); <nl>      } <nl> @@ -761,6 +762,7 @@ _disable_carbons_handler(xmpp_conn_t * const conn, xmpp_stanza_t * const stanza, <nl>          char *error_message = stanza_get_error_message(stanza); <nl>          cons_show_error("Server error disabling message carbons: %s", error_message); <nl>          log_debug("Error disabling carbons: %s", error_message); <nl> +        free(error_message); <nl>      } else { <nl>          log_debug("Message carbons disabled."); <nl>      }
@@ -43,14 +43,10 @@ void create_input_window(void); <nl>  gboolean inp_readline(void); <nl>  void inp_nonblocking(gboolean reset); <nl>  void inp_close(void); <nl> -char* inp_read(int *key_type, wint_t *ch); <nl>  void inp_win_clear(void); <nl>  void inp_win_resize(void); <nl>  void inp_put_back(void); <nl> -void inp_non_block(gint); <nl>  void inp_block(void); <nl>  void inp_get_password(char *passwd); <nl> -void inp_history_append(char *inp); <nl> -void inp_write(char *line, int offset); <nl>   <nl>  #endif
@@ -337,6 +337,7 @@ static int sqlcounter_expand(char *out, int outlen, const char *fmt, void *insta <nl>   <nl>  			case '%': <nl>  				*q++ = *p; <nl> +				break; <nl>  			case 'b': /* last_reset */ <nl>  				snprintf(tmpdt, sizeof(tmpdt), "%lu", data->last_reset); <nl>  				strlcpy(q, tmpdt, freespace);
@@ -986,6 +986,12 @@ static int process_attribute(const char* fn, const int line, <nl>  		return -1; <nl>  	} <nl>   <nl> +	if (strncmp(argv[1], "Attr-", 5) == 0) { <nl> +		fr_strerror_printf("dict_init: %s[%d]: Invalid attribute name", <nl> +				   fn, line); <nl> +		return -1; <nl> +	} <nl> + <nl>  	memset(&flags, 0, sizeof(flags)); <nl>   <nl>  	/*
@@ -448,6 +448,14 @@ static int sqlcounter_instantiate(CONF_SECTION *conf, void **instance) <nl>  		return -1; <nl>  	} <nl>   <nl> +	/* <nl> +	 *	No query, die. <nl> +	 */ <nl> +	if (data->query == NULL) { <nl> +		radlog(L_ERR, "rlm_sqlcounter: 'query' must be set."); <nl> +		return -1; <nl> +	} <nl> + <nl>  	/* <nl>  	 *	Safe characters list for sql queries. Everything else is <nl>  	 *	replaced with their mime-encoded equivalents.
@@ -1883,7 +1883,7 @@ static int ldap_authenticate(void *instance, REQUEST * request) <nl>  		LDAP_CONN       *conn1; <nl>  		int auth_state = -1; <nl>  		char            *challenge = NULL; <nl> -		int             challenge_len = MAX_CHALLENGE_LEN; <nl> +		size_t          challenge_len = MAX_CHALLENGE_LEN; <nl>  		char            *state = NULL; <nl>   <nl>  		dattr = dict_attrbyname("eDir-APC");
@@ -716,8 +716,9 @@ autz_redo: <nl>   <nl>  		tmp = pairfind(request->config_items, PW_SESSION_TYPE, 0); <nl>  		if (tmp) { <nl> -			RDEBUG2("Using Session-Type %s", tmp->vp_strvalue); <nl>  			session_type = tmp->vp_integer; <nl> +			RDEBUG2("Using Session-Type %s", <nl> +				dict_valnamebyattr(PW_SESSION_TYPE, 0, session_type)); <nl>  		} <nl>   <nl>  		/*
@@ -2463,7 +2463,7 @@ static uint8_t *rad_coalesce(int attribute, size_t length, uint8_t *data, <nl>  static VALUE_PAIR *rad_continuation2vp(const RADIUS_PACKET *packet, <nl>  				       const RADIUS_PACKET *original, <nl>  				       const char *secret, int attribute, <nl> -				       int length, <nl> +				       int length, /* CANNOT be zero */ <nl>  				       uint8_t *data, size_t packet_length, <nl>  				       int flag, DICT_ATTR *da) <nl>  { <nl> @@ -2845,6 +2845,11 @@ int rad_decode(RADIUS_PACKET *packet, RADIUS_PACKET *original, <nl>  		if (vendorlen == 0) vendorcode = 0; <nl>  		packet_length -= (vsa_tlen + vsa_llen + vsa_offset); <nl>   <nl> +		/* <nl> +		 *	Ignore VSAs that have no data. <nl> +		 */ <nl> +		if (attrlen == 0) goto next; <nl> + <nl>  		/* <nl>  		 *	WiMAX attributes of type 0 are ignored.  They <nl>  		 *	are a secret flag to us that the attribute has
@@ -164,6 +164,13 @@ static int dhcp_process(REQUEST *request) <nl>  		break; <nl>  	} <nl>   <nl> +	/* <nl> +	 *	Releases don't get replies. <nl> +	 */ <nl> +	if (request->packet->code == PW_DHCP_RELEASE) { <nl> +		request->reply->code = 0; <nl> +	} <nl> + <nl>  	return 1; <nl>  } <nl>  
@@ -404,7 +404,7 @@ static int generate_realms(const char *filename) <nl>  					strlen(authhost), sizeof(c->server) - 1); <nl>  			return -1; <nl>  		} <nl> -                if (strlen(accthost) >= sizeof(c->acct_server)) { <nl> +                if (accthost && strlen(accthost) >= sizeof(c->acct_server)) { <nl>                          radlog(L_ERR, "%s[%d]: Server name of length %d is greater than allowed: %d", <nl>                                          filename, cf_section_lineno(cs), <nl>                                          strlen(accthost), sizeof(c->acct_server) - 1); <nl> @@ -418,8 +418,8 @@ static int generate_realms(const char *filename) <nl>  		} <nl>  		 <nl>  		strcpy(c->realm, name2); <nl> -                strcpy(c->server, authhost); <nl> -		strcpy(c->acct_server, accthost);	 <nl> +                if (authhost) strcpy(c->server, authhost); <nl> +		if (accthost) strcpy(c->acct_server, accthost);	 <nl>   <nl>  		/* <nl>  		 *	If one or the other of authentication/accounting
@@ -54,7 +54,11 @@ static VALUE_PAIR *pairalloc(DICT_ATTR *da) <nl>  		strlcpy(vp->name, da->name, sizeof(vp->name)); <nl>  		vp->flags = da->flags; <nl>  	} else { <nl> +		vp->attribute = 0; <nl> +		vp->vendor = 0;	 <nl>  		vp->type = PW_TYPE_OCTETS; <nl> +		vp->name[0] = '\0'; <nl> +		memset(&vp->flags, 0, sizeof(vp->flags)); <nl>  	} <nl>   <nl>  	switch (vp->type) {
@@ -41,6 +41,7 @@ xt_status jabber_pkt_presence( struct xt_node *node, gpointer data ) <nl>  			char *s = xt_to_string( node ); <nl>  			serv_got_crap( gc, "WARNING: Ignoring presence tag with bare JID: %s\n", s ); <nl>  			g_free( s ); <nl> +			return XT_HANDLED; <nl>  		} <nl>  		 <nl>  		if( !( bud = jabber_buddy_by_jid( gc, from ) ) ) <nl> @@ -81,6 +82,7 @@ xt_status jabber_pkt_presence( struct xt_node *node, gpointer data ) <nl>  			char *s = xt_to_string( node ); <nl>  			serv_got_crap( gc, "WARNING: Ignoring presence tag with bare JID: %s\n", s ); <nl>  			g_free( s ); <nl> +			return XT_HANDLED; <nl>  		} <nl>  		 <nl>  		jabber_buddy_remove( gc, from );
@@ -4232,6 +4232,7 @@ elem_signal(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, guint32 off <nl>          break; <nl>      } <nl>   <nl> +    other_decode_bitfield_value(a_bigbuf, oct, 0x03, 8); <nl>      proto_tree_add_text(tree, <nl>          tvb, curr_offset, 1, <nl>          "%s : Alert Pitch: %s", <nl> @@ -6516,6 +6517,10 @@ elem_fwd_ms_info_recs(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, g <nl>                  curr_offset++; <nl>                  break; <nl>   <nl> +            case ANSI_FWD_MS_INFO_REC_SIGNAL: <nl> +                curr_offset += elem_signal(tvb, pinfo, subtree, curr_offset, len, add_string, string_len); <nl> +                break; <nl> + <nl>              default: <nl>                  proto_tree_add_text(subtree, <nl>                      tvb, curr_offset, oct_len,
@@ -3645,14 +3645,18 @@ tvb_skip_wsp(tvbuff_t *tvb, const gint offset, const gint maxlength) <nl>  } <nl>   <nl>  gint <nl> -tvb_skip_wsp_return(tvbuff_t *tvb, const gint offset) { <nl> +tvb_skip_wsp_return(tvbuff_t *tvb, const gint offset) <nl> +{ <nl>  	gint   counter = offset; <nl>  	guint8 tempchar; <nl>   <nl> -	for(counter = offset; counter > 0 && <nl> +	DISSECTOR_ASSERT(tvb && tvb->initialized); <nl> + <nl> +	for (counter = offset; counter > 0 && <nl>  		((tempchar = tvb_get_guint8(tvb,counter)) == ' ' || <nl>  		tempchar == '\t' || tempchar == '\n' || tempchar == '\r'); counter--); <nl>  	counter++; <nl> + <nl>  	return (counter); <nl>  } <nl>  
@@ -1090,7 +1090,7 @@ dissect_spoolss_uint16uni(tvbuff_t *tvb, int offset, packet_info *pinfo _U_, <nl>   <nl>  	/* Get remaining data in buffer as a string */ <nl>   <nl> -	remaining = tvb_captured_length_remaining(tvb, offset); <nl> +	remaining = tvb_reported_length_remaining(tvb, offset); <nl>  	if (remaining <= 0) { <nl>  		if (data) <nl>  			*data = g_strdup(""); <nl> @@ -6198,9 +6198,10 @@ dissect_spoolss_keybuffer(tvbuff_t *tvb, int offset, packet_info *pinfo, <nl>  		end_offset = tvb_reported_length_remaining(tvb, offset) + 1; <nl>  	} <nl>   <nl> -	while (offset < end_offset) <nl> +	while (offset > 0 && offset < end_offset) { <nl>  		offset = dissect_spoolss_uint16uni( <nl>  			tvb, offset, pinfo, tree, drep, NULL, hf_keybuffer); <nl> +	} <nl>   <nl>  	return offset; <nl>  }
@@ -1,7 +1,7 @@ <nl>  /* file.c <nl>   * File I/O routines <nl>   * <nl> - * $Id: file.c,v 1.59 1999/08/10 04:13:36 guy Exp $ <nl> + * $Id: file.c,v 1.60 1999/08/10 06:54:12 guy Exp $ <nl>   * <nl>   * Ethereal - Network traffic analyzer <nl>   * By Gerald Combs <gerald@zing.org> <nl> @@ -475,6 +475,7 @@ wtap_dispatch_cb(u_char *user, const struct wtap_pkthdr *phdr, int offset, <nl>    /* Allocate the next list entry, and add it to the list. */ <nl>    fdata = (frame_data *) g_malloc(sizeof(frame_data)); <nl>   <nl> +  fdata->next = NULL; <nl>    fdata->pkt_len  = phdr->len; <nl>    fdata->cap_len  = phdr->caplen; <nl>    fdata->file_off = offset;
@@ -2757,7 +2757,7 @@ dissect_data_chunk(tvbuff_t *chunk_tvb, <nl>         */ <nl>        if (b_bit) <nl>        { <nl> -	gboolean retval; <nl> +	gboolean retval = FALSE; <nl>   <nl>  	/* <nl>  	 * If this particular fragment happens to get a ReportedBoundsError
@@ -1,6 +1,6 @@ <nl>  /* pppdump.c <nl>   * <nl> - * $Id: pppdump.c,v 1.5 2000/11/19 03:47:36 guy Exp $ <nl> + * $Id: pppdump.c,v 1.6 2000/11/19 20:56:17 gerald Exp $ <nl>   * <nl>   * Copyright (c) 2000 by Gilbert Ramirez <gram@xiexie.org> <nl>   *  <nl> @@ -334,6 +334,11 @@ process_data(pppdump_t *state, FILE_T fh, pkt_t *pkt, int n, guint8 *pd, int *er <nl>  						return 0; <nl>  					} <nl>   <nl> +					if (num_written > sizeof(pd)) { <nl> +						*err = WTAP_ERR_UNC_OVERFLOW; <nl> +						return -1; <nl> +					} <nl> + <nl>  					memcpy(pd, pkt->buf, num_written); <nl>   <nl>  					num_bytes--;
@@ -3899,7 +3899,7 @@ check_payload_crc_for_heur(tvbuff_t *tvb, guint16 header_length) <nl>  static guint32 <nl>  generate_ue_id_for_heur(packet_info *pinfo) <nl>  { <nl> -    if (pinfo->ptype != PT_UDP &&  pinfo->src.type == AT_IPv4 &&  pinfo->dst.type == AT_IPv4) { <nl> +    if (pinfo->ptype == PT_UDP &&  pinfo->src.type == AT_IPv4 &&  pinfo->dst.type == AT_IPv4) { <nl>          /* This logic assumes FP is delivered over IP/UDP*/ <nl>          /* Will return the same ID even if the address and ports are reversed */ <nl>  
@@ -3128,15 +3128,15 @@ PRIVATE void tplt_xfer(const char *name, FILE *in, FILE *out, int *lineno) <nl>  PRIVATE FILE *tplt_open(struct lemon *lemp) <nl>  { <nl>    static char templatename[] = "lempar.c"; <nl> -  char* buf; <nl>    FILE *in; <nl>    char *tpltname = NULL; <nl>    char *cp; <nl>   <nl>    if (lemp->templatename) { <nl>  	  tpltname = strdup(lemp->templatename); <nl> -  } <nl> -  else { <nl> +  } else { <nl> +	  char* buf; <nl> + <nl>  	  cp = strrchr(lemp->filename,'.'); <nl>  	  buf = malloc(1000); <nl>  	  if( cp ){ <nl> @@ -3145,13 +3145,13 @@ PRIVATE FILE *tplt_open(struct lemon *lemp) <nl>  	    sprintf(buf,"%s.lt",lemp->filename); <nl>  	  } <nl>  	  if( access(buf,004)==0 ){ <nl> -	    tpltname = buf; <nl> +	    tpltname = strdup(buf); <nl>  	  }else if( access(templatename,004)==0 ){ <nl>  	    tpltname = strdup(templatename); <nl>  	  }else{ <nl>  	    tpltname = pathsearch(lemp->argv0,templatename,0); <nl> -		free(buf); <nl>  	  } <nl> +	  free(buf); <nl>    } <nl>    if( tpltname==0 ){ <nl>      fprintf(stderr,"Can't find the parser driver template file \"%s\".\n",
@@ -2,7 +2,7 @@ <nl>  * Routines for megaco packet disassembly <nl>  * RFC 3015 <nl>  * <nl> -* $Id: packet-megaco.c,v 1.15 2004/04/21 19:58:14 etxrab Exp $ <nl> +* $Id: packet-megaco.c,v 1.16 2004/04/23 03:20:58 guy Exp $ <nl>  * <nl>  * Christian Falckenberg, 2002/10/17 <nl>  * Copyright (c) 2002 by Christian Falckenberg <nl> @@ -505,8 +505,7 @@ dissect_megaco_text(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) <nl>  					if(tree) <nl>  						len = tvb_len - tvb_previous_offset;  <nl>  						proto_tree_add_text(megaco_tree, tvb, tvb_previous_offset, -1, <nl> -							"%s",tvb_format_text(tvb, tvb_previous_offset, len), tvb_len,  <nl> -							tvb_previous_offset); <nl> +							"%s",tvb_format_text(tvb, tvb_previous_offset, len)); <nl>  					if(global_megaco_raw_text){ <nl>  						tvb_raw_text_add(tvb, megaco_tree); <nl>  						}
@@ -69,12 +69,14 @@ dissect_epon(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, <nl>    guint       dpoe_sec_byte; <nl>    gboolean    dpoe_encrypted = FALSE; <nl>   <nl> -  /* Start_of_Packet delimiter (/S/) can either happen in byte 1 or byte 2, <nl> -   * making the captured preamble either 7 or 6 bytes in length. If the <nl> +  /* Start_of_Packet delimiter (/S/) can happen in byte 1, 2 or 3, <nl> +   * making the captured preamble 8, 7 or 6 bytes in length. If the <nl>     * preamble starts with 0x55, then /S/ happened in byte 1, making the <nl>     * captured preamble 7 bytes in length. <nl>     */ <nl> -  if (tvb_get_ntoh24(tvb, 0) == 0x55D555) { <nl> +  if (tvb_get_ntohl(tvb, 0) == 0x5555D555) { <nl> +    offset += 2; <nl> +  } else if (tvb_get_ntoh24(tvb, 0) == 0x55D555) { <nl>      offset += 1; <nl>    } else if (tvb_get_ntohs(tvb, 0) == 0xD555) { <nl>      offset += 0;
@@ -38,7 +38,7 @@ <nl>  #include <epan/packet.h> <nl>  #include "prefs.h" <nl>   <nl> -static int ISUP_thinTCPPort = 0; <nl> +static guint ISUP_thinTCPPort = 0; <nl>   <nl>  /* Initialize the protocol and registered fields */ <nl>  static int proto_isup_thin		= -1; <nl> @@ -191,9 +191,9 @@ dissect_isup_thin(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) <nl>  void <nl>  proto_reg_handoff_isup_thin(void) <nl>  { <nl> -	static int Initialized=FALSE; <nl> +	static gboolean Initialized=FALSE; <nl>  	static dissector_handle_t isup_thin_handle; <nl> -	static int saved_tcp_port; <nl> +	static guint saved_tcp_port; <nl>  	 <nl>  	if (!Initialized) { <nl>  		isup_thin_handle = find_dissector("isup_thin");
@@ -328,6 +328,11 @@ AirPDcapDecryptWPABroadcastKey(const EAPOL_RSN_KEY *pEAPKey, guint8  *decryption <nl>      }else if (key_version == AIRPDCAP_WPA_KEY_VER_AES_CCMP){ <nl>          /* AES */ <nl>          key_bytes_len = pntoh16(pEAPKey->key_data_len); <nl> + <nl> +        /* AES keys must be at least 128 bits = 16 bytes. */ <nl> +        if (key_bytes_len < 16) { <nl> +            return; <nl> +        } <nl>      } <nl>   <nl>      if (key_bytes_len > TKIP_GROUP_KEYBYTES_LEN_MAX || key_bytes_len == 0) { /* Don't read past the end of pEAPKey->ie */
@@ -1029,6 +1029,8 @@ netmon_process_record(wtap *wth, FILE_T fh, struct wtap_pkthdr *phdr, <nl>  			switch (network) <nl>  			{ <nl>  			case 0xE080:    // "WiFi Message" <nl> +				pkt_encap = WTAP_ENCAP_IEEE_802_11; <nl> +				break; <nl>  			case 0xE081:    // "Ndis Etw WiFi Channel Message" <nl>  			case 0xE082:    // "Fiddler Netmon Message" <nl>  			case 0xE089:    // "Pef Ndis Msg";
@@ -2468,7 +2468,7 @@ proto_register_sua(void) <nl>                                   "  This may affect TCAP's ability to recognize which messages belong to which TCAP session.", &set_addresses); <nl>   <nl>    heur_subdissector_list = register_heur_dissector_list("sua"); <nl> -  sua_parameter_table = register_dissector_table("sua.prop.tags", "SUA Proprietary Tags", FT_UINT16, BASE_DEC, DISSECTOR_TABLE_NOT_ALLOW_DUPLICATE); <nl> +  sua_parameter_table = register_dissector_table("sua.prop.tags", "SUA Proprietary Tags", FT_UINT16, BASE_DEC, DISSECTOR_TABLE_ALLOW_DUPLICATE); <nl>    sua_tap = register_tap("sua"); <nl>   <nl>    assocs = wmem_tree_new_autoreset(wmem_epan_scope(), wmem_file_scope());
@@ -89,7 +89,7 @@ dissect_vmlab(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) <nl>      guint8	    attributes; <nl>      guint8	    portgroup; <nl>   <nl> -    guint16 encap_proto; <nl> +    volatile guint16 encap_proto; <nl>   <nl>      col_set_str(pinfo->cinfo, COL_PROTOCOL, "VMLAB"); <nl>      col_clear(pinfo->cinfo, COL_INFO);
@@ -598,8 +598,13 @@ nextcontext: <nl>  		tvb_previous_offset = tvb_find_guint8(tvb, tvb_current_offset, <nl>  			tvb_len, '=')+1; <nl>  		tvb_previous_offset = tvb_skip_wsp(tvb, tvb_previous_offset); <nl> -		tvb_current_offset = tvb_find_guint8(tvb, tvb_previous_offset, <nl> +		tvb_next_offset = tvb_find_guint8(tvb, tvb_previous_offset, <nl>  			tvb_len, '{'); <nl> +		if (tvb_current_offset >= tvb_next_offset) { <nl> +			proto_tree_add_text(megaco_tree, tvb, 0, 0, "[ Parse error: Invalid offset ]"); <nl> +			return; <nl> +		} <nl> +		tvb_current_offset = tvb_next_offset; <nl>  		 <nl>  		 <nl>  		tokenlen = tvb_current_offset - tvb_previous_offset;
@@ -275,7 +275,16 @@ dissect_data_segment(proto_tree *ltp_tree, tvbuff_t *tvb,packet_info *pinfo,int <nl>  		} <nl>  	} <nl>  	/* Adding size of the data */ <nl> +	if ((segment_offset + (int)length < segment_offset) || (segment_offset + (int)length < (int)length)) { <nl> +	/* Addition result has wrapped */ <nl> +		return 0; <nl> +	} <nl>  	segment_offset+= (int)length; <nl> + <nl> +	if ((segment_offset + frame_offset < segment_offset) || (segment_offset + frame_offset < frame_offset)) { <nl> +	/* Addition result has wrapped */ <nl> +		return 0; <nl> +	} <nl>  	if((unsigned)(frame_offset + segment_offset) > tvb_length(tvb)){ <nl>  	/* This would mean the data segment is incomplete */ <nl>  		return 0;
@@ -1,6 +1,6 @@ <nl>  /* main.c <nl>   * <nl> - * $Id: main.c,v 1.386 2004/02/01 20:28:11 ulfl Exp $ <nl> + * $Id: main.c,v 1.387 2004/02/01 22:43:34 guy Exp $ <nl>   * <nl>   * Ethereal - Network traffic analyzer <nl>   * By Gerald Combs <gerald@ethereal.com> <nl> @@ -1196,7 +1196,11 @@ main_window_delete_event_cb(GtkWidget *widget _U_, GdkEvent *event _U_, gpointer <nl>  } <nl>   <nl>  static void <nl> -main_load_window_geometry(GtkWidget *widget) <nl> +main_load_window_geometry(GtkWidget *widget <nl> +#if GTK_MAJOR_VERSION < 2 <nl> +	_U_ <nl> +#endif <nl> +) <nl>  { <nl>      /* as we now have the geometry from the recent file, set it */ <nl>      if (prefs.gui_geometry_save_position) {
@@ -205,7 +205,7 @@ dissect_vtp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) <nl>  		while (tvb_reported_length_remaining(tvb, offset) > 0) { <nl>  			vlan_info_len = <nl>  				dissect_vlan_info(tvb, pinfo, offset, vtp_tree); <nl> -			if (vlan_info_len < 0) <nl> +			if (vlan_info_len <= 0) <nl>  				break; <nl>  			offset += vlan_info_len; <nl>  		}
@@ -518,7 +518,9 @@ dissect_h264_exp_golomb_code(proto_tree *tree, int hf_index, tvbuff_t *tvb, gint <nl>  	codenum = 1; <nl>  	codenum = codenum << leading_zero_bits; <nl>  	mask = codenum>>1; <nl> -	if (leading_zero_bits > 8) <nl> +	if (leading_zero_bits > 16) <nl> +		value = tvb_get_bits32(tvb, bit_offset,leading_zero_bits, FALSE); <nl> +	else if (leading_zero_bits > 8) <nl>  		value = tvb_get_bits16(tvb, bit_offset,leading_zero_bits, FALSE); <nl>  	else <nl>  		value = tvb_get_bits8(tvb, bit_offset,leading_zero_bits );
@@ -1841,11 +1841,12 @@ dissect_quic_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, <nl>   <nl>      /* Diversification Nonce */ <nl>      if(puflags & PUFLAGS_DNONCE && quic_info->version >= 33){ <nl> -        proto_tree_add_item(quic_tree, hf_quic_diversification_nonce, tvb, offset, 32, ENC_NA); <nl> -        offset += 32; <nl> +        if(pinfo->srcport == 443){ /* Diversification nonce is only present from server to client */ <nl> +            proto_tree_add_item(quic_tree, hf_quic_diversification_nonce, tvb, offset, 32, ENC_NA); <nl> +            offset += 32; <nl> +        } <nl>      } <nl>   <nl> - <nl>      /* Packet Number */ <nl>   <nl>      /* Get len of packet number (and packet number), may be a more easy function to get the length... */
@@ -48,9 +48,16 @@ int intl_stringFromChar(UnicodeString &ret, char *str, int32_t str_len, UErrorCo <nl>  } <nl>  /* }}} */ <nl>   <nl> -/* {{{ intl_charFromString */ <nl> +/* {{{ intl_charFromString <nl> + * faster than doing intl_convert_utf16_to_utf8(&res, &res_len, <nl> + *		from.getBuffer(), from.length(), &status), <nl> + * but consumes more memory */ <nl>  int intl_charFromString(const UnicodeString &from, char **res, int *res_len, UErrorCode *status) <nl>  { <nl> +	if (from.isBogus()) { <nl> +		return FAILURE; <nl> +	} <nl> + <nl>  	//the number of UTF-8 code units is not larger than that of UTF-16 code <nl>  	//units * 3 + 1 for the terminator <nl>  	int32_t capacity = from.length() * 3 + 1;
@@ -180,6 +180,15 @@ void gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quantization) <nl>  	/* Conversion to Y,U,V buffer */ <nl>      yuv_width = (width + 1) >> 1; <nl>      yuv_height = (height + 1) >> 1; <nl> + <nl> +	if (overflow2(width, height)) { <nl> +		return; <nl> +	} <nl> +	/* simplification possible, because WebP must not be larger than 16384**2 */ <nl> +	if (overflow2(width * height, 2 * sizeof(unsigned char))) { <nl> +		return; <nl> +	} <nl> + <nl>      yuv_nbytes = width * height + 2 * yuv_width * yuv_height; <nl>   <nl>      if ((Y = (unsigned char *)gdCalloc(yuv_nbytes, sizeof(unsigned char))) == NULL) {
@@ -1585,6 +1585,7 @@ php_mysqlnd_rowp_read_text_protocol_aux(MYSQLND_MEMORY_POOL_CHUNK * row_buffer, <nl>  	zend_uchar * p = row_buffer->ptr; <nl>  	size_t data_size = row_buffer->app; <nl>  	zend_uchar * bit_area = (zend_uchar*) row_buffer->ptr + data_size + 1; /* we allocate from here */ <nl> +	const zend_uchar * const packet_end = (zend_uchar*) row_buffer->ptr + data_size; <nl>   <nl>  	DBG_ENTER("php_mysqlnd_rowp_read_text_protocol_aux"); <nl>   <nl> @@ -1606,8 +1607,13 @@ php_mysqlnd_rowp_read_text_protocol_aux(MYSQLND_MEMORY_POOL_CHUNK * row_buffer, <nl>  		/* Don't reverse the order. It is significant!*/ <nl>  		zend_uchar *this_field_len_pos = p; <nl>  		/* php_mysqlnd_net_field_length() call should be after *this_field_len_pos = p; */ <nl> -		unsigned long len = php_mysqlnd_net_field_length(&p); <nl> +		const unsigned long len = php_mysqlnd_net_field_length(&p); <nl>   <nl> +		if (len != MYSQLND_NULL_LENGTH && ((p + len) > packet_end)) { <nl> +			php_error_docref(NULL, E_WARNING, "Malformed server packet. Field length pointing "MYSQLND_SZ_T_SPEC <nl> +											  " bytes after end of packet", (p + len) - packet_end - 1); <nl> +			DBG_RETURN(FAIL); <nl> +		} <nl>  		if (copy_data == FALSE && current_field > start_field && last_field_was_string) { <nl>  			/* <nl>  			  Normal queries:
@@ -3307,7 +3307,7 @@ ZEND_METHOD(reflection_class, hasProperty) <nl>  		{ <nl>  			MAKE_STD_ZVAL(property); <nl>  			ZVAL_STRINGL(property, name, name_len, 1); <nl> -			if (Z_OBJ_HANDLER_P(intern->obj, has_property)(intern->obj, property, 2 TSRMLS_CC)) { <nl> +			if (Z_OBJ_HANDLER_P(intern->obj, has_property)(intern->obj, property, 0 TSRMLS_CC)) { <nl>  				zval_ptr_dtor(&property); <nl>  				RETURN_TRUE; <nl>  			}
@@ -675,6 +675,7 @@ static void php_execute_post_request_startup(PLS_D) <nl>  	if (PG(post_request_startup_ok)) { <nl>  		zend_llist_apply(&PG(ll_post_request_startup), php_start_request_hook); <nl>  		zend_llist_destroy(&PG(ll_post_request_startup)); <nl> +		PG(post_request_startup_ok) = 0; <nl>  	} <nl>  } <nl>  
@@ -1,4 +1,4 @@ <nl> -/* Generated by re2c 0.13.7.5 on Thu Dec 11 19:26:19 2014 */ <nl> +/* Generated by re2c 0.13.7.5 on Thu Jan  1 14:43:18 2015 */ <nl>  #line 1 "ext/standard/var_unserializer.re" <nl>  /* <nl>    +----------------------------------------------------------------------+ <nl> @@ -343,7 +343,7 @@ static inline int process_nested_data(UNSERIALIZE_PARAMETER, HashTable *ht, long <nl>  		} else { <nl>  			/* object properties should include no integers */ <nl>  			convert_to_string(key); <nl> -			if (zend_symtable_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, (void **)&old_data)==SUCCESS) { <nl> +			if (zend_hash_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, (void **)&old_data)==SUCCESS) { <nl>  				var_push_dtor(var_hash, old_data); <nl>  			} <nl>  			zend_hash_update(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, &data,
@@ -3031,7 +3031,7 @@ void zend_do_foreach_cont(znode *value, znode *key, znode *as_token, znode *fore <nl>  		result_key = opline->result; <nl>  	} <nl>   <nl> -	if (1 && assign_by_ref) { <nl> +	if (assign_by_ref) { <nl>  		zend_do_assign_ref(&dummy, value, &result_value TSRMLS_CC); <nl>  	} else { <nl>  		zend_do_assign(&dummy, value, &result_value TSRMLS_CC);
@@ -117,6 +117,8 @@ PHP_FUNCTION( msgfmt_format_message ) <nl>  		RETURN_FALSE; <nl>  	} <nl>   <nl> +	INTL_CHECK_LOCALE_LEN(slocale_len); <nl> + <nl>  	msgformat_data_init(&mfo->mf_data TSRMLS_CC); <nl>   <nl>  	if(pattern && pattern_len) {
@@ -513,7 +513,7 @@ static char *substring_conf(char *start, int len, char quote TSRMLS_DC) <nl>  #if HAVE_MBSTRING && !defined(COMPILE_DL_MBSTRING) <nl>  			if (php_mb_encoding_translation(TSRMLS_C)) { <nl>  				size_t j = php_mb_mbchar_bytes(start+i TSRMLS_CC); <nl> -				while (j-- > 0) { <nl> +				while (j-- > 0 && i < len) { <nl>  					*resp++ = start[i++]; <nl>  				} <nl>  				--i;
@@ -310,6 +310,9 @@ int phar_parse_zipfile(php_stream *fp, char *fname, int fname_len, char *alias, <nl>  			if (mydata->metadata) { \ <nl>  				zval_dtor(mydata->metadata); \ <nl>  			} \ <nl> +			if (mydata->signature) { \ <nl> +				efree(mydata->signature); \ <nl> +			} \ <nl>  			if (error) { \ <nl>  				spprintf(error, 4096, "phar error: %s in zip-based phar \"%s\"", errmsg, mydata->fname); \ <nl>  			} \ <nl> @@ -331,6 +334,9 @@ int phar_parse_zipfile(php_stream *fp, char *fname, int fname_len, char *alias, <nl>  			if (mydata->metadata) { \ <nl>  				zval_dtor(mydata->metadata); \ <nl>  			} \ <nl> +			if (mydata->signature) { \ <nl> +				efree(mydata->signature); \ <nl> +			} \ <nl>  			if (error) { \ <nl>  				spprintf(error, 4096, "phar error: %s in zip-based phar \"%s\"", errmsg, mydata->fname); \ <nl>  			} \ <nl> @@ -766,7 +772,6 @@ static int phar_zip_changed_apply(void *data, void *arg TSRMLS_DC) /* {{{ */ <nl>  	php_uint32 newcrc32; <nl>  	off_t offset; <nl>  	int not_really_modified = 0; <nl> - <nl>  	entry = (phar_entry_info *)data; <nl>  	p = (struct _phar_zip_pass*) arg; <nl>  
@@ -231,6 +231,7 @@ static void _free_mysql_result(zend_rsrc_list_entry *rsrc TSRMLS_DC) <nl>  	MYSQL_RES *mysql_result = (MYSQL_RES *)rsrc->ptr; <nl>   <nl>  	mysql_free_result(mysql_result); <nl> +	MySG(result_allocated)--; <nl>  } <nl>  /* }}} */ <nl>  
@@ -276,6 +276,9 @@ onig_snprintf_with_pattern(buf, bufsize, enc, pat, pat_end, fmt, va_alist) <nl>   <nl>    va_init_list(args, fmt); <nl>    n = vsnprintf(buf, bufsize, fmt, args); <nl> +  if (n < 0 || n >= bufsize) { <nl> +    n = bufsize - 1; <nl> +  } <nl>    va_end(args); <nl>   <nl>    need = (pat_end - pat) * 4 + 4;
@@ -1477,6 +1477,7 @@ oci_fetch(oci_statement *statement, ub4 nrows, char *func) <nl>  			zend_hash_destroy(statement->columns); <nl>  			efree(statement->columns); <nl>  			statement->columns = 0; <nl> +			statement->ncolumns = 0; <nl>  		} <nl>  		statement->executed = 0; <nl>  
@@ -421,13 +421,13 @@ void zend_optimizer_compact_literals(zend_op_array *op_array, zend_optimizer_ctx <nl>  				case IS_CONSTANT: <nl>  					if (info[i].flags & LITERAL_MAY_MERGE) { <nl>  						if (info[i].flags & LITERAL_EX_OBJ) { <nl> -							int key_len = MAX_LENGTH_OF_LONG + sizeof("->") + Z_STRLEN(op_array->literals[i]); <nl> +							int key_len = MAX_LENGTH_OF_LONG + sizeof("->") - 1 + Z_STRLEN(op_array->literals[i]); <nl>  							key = zend_string_alloc(key_len, 0); <nl>  							ZSTR_LEN(key) = snprintf(ZSTR_VAL(key), ZSTR_LEN(key)-1, "%d->%s", info[i].u.num, Z_STRVAL(op_array->literals[i])); <nl>  						} else if (info[i].flags & LITERAL_EX_CLASS) { <nl>  							int key_len; <nl>  							zval *class_name = &op_array->literals[(info[i].u.num < i) ? map[info[i].u.num] : info[i].u.num]; <nl> -							key_len = Z_STRLEN_P(class_name) + sizeof("::") + Z_STRLEN(op_array->literals[i]); <nl> +							key_len = Z_STRLEN_P(class_name) + sizeof("::") - 1 + Z_STRLEN(op_array->literals[i]); <nl>  							key = zend_string_alloc(key_len, 0); <nl>  							memcpy(ZSTR_VAL(key), Z_STRVAL_P(class_name), Z_STRLEN_P(class_name)); <nl>  							memcpy(ZSTR_VAL(key) + Z_STRLEN_P(class_name), "::", sizeof("::") - 1);
@@ -290,8 +290,9 @@ PHPDBG_API int phpdbg_rlog(FILE *fp, const char *fmt, ...) { /* {{{ */ <nl>  	if (gettimeofday(&tp, NULL) == SUCCESS) { <nl>  		char friendly[100]; <nl>  		char *format = NULL, *buffer = NULL; <nl> +		const time_t tt = tp.tv_sec; <nl>   <nl> -		strftime(friendly, 100, "%a %b %d %T.%%04d %Y", localtime(&tp.tv_sec)); <nl> +		strftime(friendly, 100, "%a %b %d %T.%%04d %Y", localtime(&tt)); <nl>  		asprintf( <nl>  			&buffer, friendly, tp.tv_usec/1000); <nl>  		asprintf(
@@ -466,6 +466,9 @@ static int firebird_stmt_param_hook(pdo_stmt_t *stmt, struct pdo_bound_param_dat <nl>  		case PDO_PARAM_EVT_ALLOC: <nl>  			if (param->is_param) { <nl>  				/* allocate the parameter */ <nl> +				if (var->sqlind) { <nl> +					efree(var->sqlind); <nl> +				} <nl>  				var->sqlind = (void*)emalloc(var->sqllen + 2*sizeof(short)); <nl>  				var->sqldata = &((char*)var->sqlind)[sizeof(short)]; <nl>  			}
@@ -343,10 +343,14 @@ int _php_mb_encoding_handler_ex(int data_type, zval *arg, char *res, char *separ <nl>  			val_len = len_list[n]; <nl>  		} <nl>  		n++; <nl> +		/* we need val to be emalloc()ed */ <nl> +		val = estrndup(val, val_len); <nl>  		if (sapi_module.input_filter(data_type, var, &val, val_len, &new_val_len TSRMLS_CC)) { <nl>  			/* add variable to symbol table */ <nl>  			php_register_variable_safe(var, val, new_val_len, array_ptr TSRMLS_CC); <nl>  		} <nl> +		efree(val); <nl> +		 <nl>  		if (convd != NULL){ <nl>  			mbfl_string_clear(&resvar); <nl>  			mbfl_string_clear(&resval);
@@ -448,6 +448,11 @@ int fpm_log_write(char *log_format) /* {{{ */ <nl>  				b += len2; <nl>  				len += len2; <nl>  			} <nl> +			if (len >= FPM_LOG_BUFFER) { <nl> +				zlog(ZLOG_NOTICE, "the log buffer is full (%d). The access log request has been truncated.", FPM_LOG_BUFFER); <nl> +				len = FPM_LOG_BUFFER; <nl> +				break; <nl> +			} <nl>  			continue; <nl>  		} <nl>  
@@ -1122,7 +1122,7 @@ void dom_get_elements_by_tag_name_ns_raw(xmlNodePtr nodep, char *ns, char *local <nl>  /* {{{ void dom_normalize (xmlNodePtr nodep TSRMLS_DC) */ <nl>  void dom_normalize (xmlNodePtr nodep TSRMLS_DC) <nl>  { <nl> -	xmlNodePtr child, nextp; <nl> +	xmlNodePtr child, nextp, newnextp; <nl>  	xmlAttrPtr attr; <nl>  	xmlChar	*strContent;  <nl>   <nl> @@ -1133,12 +1133,15 @@ void dom_normalize (xmlNodePtr nodep TSRMLS_DC) <nl>  				nextp = child->next; <nl>  				while (nextp != NULL) { <nl>  					if (nextp->type == XML_TEXT_NODE) { <nl> +						newnextp = nextp->next; <nl>  						strContent = xmlNodeGetContent(nextp); <nl>  						xmlNodeAddContent(child, strContent); <nl>  						xmlFree(strContent); <nl>  						xmlUnlinkNode(nextp); <nl>  						node_free_resource(nextp TSRMLS_CC); <nl> -						nextp = child->next; <nl> +						nextp = newnextp; <nl> +					} else { <nl> +						break; <nl>  					} <nl>  				} <nl>  				break;
@@ -4641,7 +4641,7 @@ void zend_do_declare_stmt(znode *var, znode *val TSRMLS_DC) <nl>  		zend_encoding *new_encoding, *old_encoding; <nl>  		zend_encoding_filter old_input_filter; <nl>   <nl> -		if (Z_TYPE(val->u.constant) == IS_CONSTANT) { <nl> +		if ((Z_TYPE(val->u.constant) & IS_CONSTANT_TYPE_MASK) == IS_CONSTANT) { <nl>  			zend_error(E_COMPILE_ERROR, "Cannot use constants as encoding"); <nl>  		} <nl>  
@@ -2058,7 +2058,7 @@ PHP_FUNCTION(strip_tags) <nl>  			break; <nl>  	} <nl>  	convert_to_string_ex(str); <nl> -	buf = estrdup((*str)->value.str.val); <nl> +	buf = estrndup((*str)->value.str.val,(*str)->value.str.len); <nl>  	php_strip_tags(buf, (*str)->value.str.len, 0, allowed_tags, allowed_tags_len); <nl>  	RETURN_STRING(buf, 0); <nl>  } <nl> @@ -2210,7 +2210,7 @@ PHPAPI void php_strip_tags(char *rbuf, int len, int state, char *allow, int allo <nl>  	char *tbuf, *buf, *p, *tp, *rp, c, lc; <nl>  	int br, i=0; <nl>   <nl> -	buf = estrdup(rbuf); <nl> +	buf = estrndup(rbuf,len); <nl>  	c = *buf; <nl>  	lc = '\0'; <nl>  	p = buf;
@@ -1856,15 +1856,16 @@ static ZIPARCHIVE_METHOD(addFromString) <nl>  	/* TODO: fix  _zip_replace */ <nl>  	if (cur_idx >= 0) { <nl>  		if (zip_delete(intern, cur_idx) == -1) { <nl> -			RETURN_FALSE; <nl> +			goto fail; <nl>  		} <nl>  	} <nl>   <nl> -	if (zip_add(intern, name, zs) == -1) { <nl> -		RETURN_FALSE; <nl> -	} else { <nl> +	if (zip_add(intern, name, zs) != -1) { <nl>  		RETURN_TRUE; <nl>  	} <nl> +fail: <nl> +	zip_source_free(zs); <nl> +	RETURN_FALSE;	 <nl>  } <nl>  /* }}} */ <nl>  
@@ -838,7 +838,6 @@ static int php_cli_server_poller_iter_on_active(php_cli_server_poller *poller, v <nl>  		SOCKET fd; <nl>  		int events; <nl>  	} entries[FD_SETSIZE * 2]; <nl> -	php_socket_t fd = 0; <nl>  	size_t i; <nl>  	struct socket_entry *n = entries, *m; <nl>  
@@ -80,6 +80,8 @@ private const struct { <nl>  	{ "BZh",      3, { "bzip2", "-cd", NULL }, 1 },		/* bzip2-ed */ <nl>  }; <nl>   <nl> +private size_t ncompr = sizeof(compr) / sizeof(compr[0]); <nl> + <nl>  #define NODATA ((size_t)~0) <nl>   <nl>   <nl> @@ -180,6 +182,8 @@ sread(int fd, void *buf, size_t n, int canbepipe) <nl>  #ifdef FIONREAD <nl>  	if ((canbepipe && (ioctl(fd, FIONREAD, &t) == -1)) || (t == 0)) { <nl>  #ifdef FD_ZERO <nl> +		int cnt; <nl> + <nl>  		for (cnt = 0;; cnt++) { <nl>  			fd_set check; <nl>  			struct timeval tout = {0, 100 * 1000};
@@ -4410,12 +4410,12 @@ static int zend_isset_isempty_dim_prop_obj_handler(int prop_dim, ZEND_OPCODE_HAN <nl>  		} else if ((*container)->type == IS_STRING) { /* string offsets */ <nl>  			switch (opline->extended_value) { <nl>  				case ZEND_ISSET: <nl> -					if (offset->value.lval <= Z_STRLEN_PP(container)) { <nl> +					if (offset->value.lval < Z_STRLEN_PP(container)) { <nl>  						result = 1; <nl>  					} <nl>  					break; <nl>  				case ZEND_ISEMPTY: <nl> -					if (offset->value.lval <= Z_STRLEN_PP(container) && Z_STRVAL_PP(container)[offset->value.lval] != '0') { <nl> +					if (offset->value.lval < Z_STRLEN_PP(container) && Z_STRVAL_PP(container)[offset->value.lval] != '0') { <nl>  						result = 1; <nl>  					} <nl>  					break;
@@ -206,7 +206,7 @@ static void allocate_new_resource(tsrm_tls_entry **thread_resources_ptr, THREAD_ <nl>   <nl>   <nl>  /* fetches the requested resource for the current thread */ <nl> -void *ts_resource_ex(ts_rsrc_id id, THREAD_T *th_id) <nl> +TSRM_API void *ts_resource_ex(ts_rsrc_id id, THREAD_T *th_id) <nl>  { <nl>  	THREAD_T thread_id; <nl>  	int hash_value;
@@ -164,7 +164,10 @@ readwbmp (int (*getin) (void *in), void *in, Wbmp ** return_wbmp) <nl>      } <nl>   <nl>    if (skipheader (getin, in)) <nl> -    return (-1); <nl> +    { <nl> +      gdFree (wbmp); <nl> +      return (-1); <nl> +    } <nl>   <nl>   <nl>    wbmp->width = getmbi (getin, in);
@@ -334,6 +334,7 @@ SAPI_API void sapi_activate(TSRMLS_D) <nl>  	SG(request_info).current_user = NULL; <nl>  	SG(request_info).current_user_length = 0; <nl>  	SG(request_info).no_headers = 0; <nl> +	SG(global_request_time) = 0; <nl>   <nl>  	/* It's possible to override this general case in the activate() callback, if <nl>  	 * necessary. <nl> @@ -430,6 +431,7 @@ SAPI_API void sapi_deactivate(TSRMLS_D) <nl>  	SG(sapi_started) = 0; <nl>  	SG(headers_sent) = 0; <nl>  	SG(request_info).headers_read = 0; <nl> +	SG(global_request_time) = 0; <nl>  } <nl>   <nl>  
@@ -3491,7 +3491,7 @@ PHP_FUNCTION(imagepstext) <nl>  #else <nl>  	if (_fg < 0 || _fg > gdImageColorsTotal(bg_img)) { <nl>  #endif <nl> -		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Foreground color index %d out of range", _fg); <nl> +		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Foreground color index %ld out of range", _fg); <nl>  		RETURN_FALSE; <nl>  	} <nl>   <nl> @@ -3500,7 +3500,7 @@ PHP_FUNCTION(imagepstext) <nl>  #else <nl>  	if (_bg < 0 || _bg > gdImageColorsTotal(bg_img)) { <nl>  #endif <nl> -		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Background color index %d out of range", _bg); <nl> +		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Background color index %ld out of range", _bg); <nl>  		RETURN_FALSE; <nl>  	} <nl>   <nl> @@ -3542,7 +3542,7 @@ PHP_FUNCTION(imagepstext) <nl>  			T1_AASetLevel(T1_AA_HIGH); <nl>  			break; <nl>  		default: <nl> -			php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid value %d as number of steps for antialiasing", aa_steps); <nl> +			php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid value %ld as number of steps for antialiasing", aa_steps); <nl>  			RETURN_FALSE; <nl>  	} <nl>  
@@ -1668,7 +1668,7 @@ PHP_FUNCTION(locale_accept_from_http) <nl>  						&outResult, http_accept, available, &status); <nl>  	uenum_close(available); <nl>  	INTL_CHECK_STATUS(status, "locale_accept_from_http: failed to find acceptable locale"); <nl> -	if(outResult == ULOC_ACCEPT_FAILED) { <nl> +	if (len < 0 || outResult == ULOC_ACCEPT_FAILED) { <nl>  		RETURN_FALSE; <nl>  	} <nl>  	RETURN_STRINGL(resultLocale, len, 1);
@@ -55,7 +55,13 @@ static int pdo_mysql_stmt_dtor(pdo_stmt_t *stmt TSRMLS_DC) <nl>  		efree(S->in_null); <nl>  		efree(S->in_length); <nl>  	} <nl> -	if (S->bound_result) { <nl> +	if (S->bound_result)  <nl> +	{ <nl> +		int i; <nl> +		for (i = 0; i < stmt->column_count; i++) { <nl> +			efree(S->bound_result[i].buffer); <nl> +		} <nl> +	 <nl>  		efree(S->bound_result); <nl>  		efree(S->out_null); <nl>  		efree(S->out_length);
@@ -642,6 +642,7 @@ static inline int php_tcp_sockop_connect(php_stream *stream, php_netstream_data_ <nl>  			if (xparam->want_errortext) { <nl>  				spprintf(&xparam->outputs.error_text, 0, "local_addr context option is not a string."); <nl>  			} <nl> +			efree(host); <nl>  			return -1; <nl>  		} <nl>  		bindto = parse_ip_address_ex(Z_STRVAL_PP(tmpzval), Z_STRLEN_PP(tmpzval), &bindport, xparam->want_errortext, &xparam->outputs.error_text TSRMLS_CC);
@@ -1424,6 +1424,11 @@ PHP_FUNCTION(ibase_gen_id) <nl>  			&inc, &link)) { <nl>  		RETURN_FALSE; <nl>  	} <nl> +	 <nl> +	if (gen_len > 31) { <nl> +		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid generator name"); <nl> +		RETURN_FALSE; <nl> +	} <nl>   <nl>  	PHP_IBASE_LINK_TRANS(link, ib_link, trans); <nl>  	
@@ -542,7 +542,7 @@ PHP_FUNCTION(grapheme_substr) <nl>  		length += iter_val; <nl>  	} <nl>  	 <nl> -	if ( UBRK_DONE == sub_str_end_pos ) { <nl> +	if ( UBRK_DONE == sub_str_end_pos && length < 0) { <nl>  	 <nl>  		intl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR, "grapheme_substr: length not contained in string", 1 TSRMLS_CC ); <nl>  	
@@ -812,6 +812,7 @@ SAPI_POST_HANDLER_FUNC(fdf_post_handler) <nl>  				err = FDFGetValue(theFDF,name,value,value_len-1,&nBytes); <nl>  				if(err == FDFErcOK && nBytes != 0) { <nl>  					for(p=value;*p;p++) if(*p=='\r') *p='\n'; <nl> +					if(lastfieldname) efree(lastfieldname); <nl>  					lastfieldname = estrdup(name);		 <nl>  					php_register_variable(name, value, array_ptr ELS_CC PLS_CC); <nl>  				} 
@@ -208,6 +208,8 @@ PHPAPI int php_check_specific_open_basedir(const char *basedir, const char *path <nl>  			if (path_len > 1 && path_tmp[path_len - 2] == ':') { <nl>  				/* this is c:\,  */ <nl>  				path_tmp[path_len] = '\0'; <nl> +			} else { <nl> +				path_tmp[path_len - 1] = '\0'; <nl>  			} <nl>  #else <nl>  			path_tmp[path_len - 1] = '\0';
@@ -293,17 +293,19 @@ globexp2(ptr, pattern, pglob, rv) <nl>  	} <nl>   <nl>  	for (i = 0, pl = pm = ptr; pm <= pe; pm++) { <nl> +		const Char *pb; <nl> + <nl>  		switch (*pm) { <nl>  		case LBRACKET: <nl>  			/* Ignore everything between [] */ <nl> -			for (pl = pm++; *pm != RBRACKET && *pm != EOS; pm++) <nl> +			for (pb = pm++; *pm != RBRACKET && *pm != EOS; pm++) <nl>  				; <nl>  			if (*pm == EOS) { <nl>  				/* <nl>  				 * We could not find a matching RBRACKET. <nl>  				 * Ignore and just look for RBRACE <nl>  				 */ <nl> -				pm = pl; <nl> +				pm = pb; <nl>  			} <nl>  			break; <nl>  
@@ -517,6 +517,10 @@ static u_char *php_parserr(u_char *cp, querybuf *answer, int type_to_fetch, int <nl>  				 <nl>  				while (ll < dlen) { <nl>  					n = cp[ll]; <nl> +					if ((ll + n) >= dlen) { <nl> +						// Invalid chunk length, truncate <nl> +						n = dlen - (ll + 1); <nl> +					} <nl>  					memcpy(tp + ll , cp + ll + 1, n); <nl>  					add_next_index_stringl(entries, cp + ll + 1, n, 1); <nl>  					ll = ll + n + 1;
@@ -737,9 +737,9 @@ php_stream *php_stream_url_wrap_http_ex(php_stream_wrapper *wrapper, <nl>  								tmp_line, response_code); <nl>  				} <nl>  			} <nl> -			if (tmp_line[tmp_line_len - 1] == '\n') { <nl> +			if (tmp_line_len >= 1 && tmp_line[tmp_line_len - 1] == '\n') { <nl>  				--tmp_line_len; <nl> -				if (tmp_line[tmp_line_len - 1] == '\r') { <nl> +				if (tmp_line_len >= 1 &&tmp_line[tmp_line_len - 1] == '\r') { <nl>  					--tmp_line_len; <nl>  				} <nl>  			}
@@ -325,6 +325,7 @@ static const create_table_t create[] = { <nl>    { FILE_TYPE_DIR, "self", 0755}, <nl>    { FILE_TYPE_DIR, "run", 0755}, <nl>    { FILE_TYPE_DIR, "run/dbus", 0755}, <nl> +  { FILE_TYPE_DIR, "run/media", 0755}, <nl>    { FILE_TYPE_DIR, "run/user", 0755}, <nl>    { FILE_TYPE_DIR, "run/user/%1$d", 0700, NULL}, <nl>    { FILE_TYPE_DIR, "run/user/%1$d/pulse", 0700, NULL}, <nl> @@ -1553,7 +1554,10 @@ main (int argc, <nl>      } <nl>   <nl>    if (mount_host_fs) <nl> -    mount_extra_root_dirs (mount_host_fs_ro); <nl> +    { <nl> +      mount_extra_root_dirs (mount_host_fs_ro); <nl> +      bind_mount ("/run/media", "run/media", BIND_RECURSIVE | (mount_host_fs_ro ? BIND_READONLY : 0)); <nl> +    } <nl>   <nl>    if (!mount_host_fs) <nl>      create_homedir (mount_home, app_id);
@@ -751,6 +751,7 @@ flatpak_remote_new_from_ostree (OstreeRemote     *remote, <nl>                                  OstreeRepoFinder *repo_finder, <nl>                                  FlatpakDir       *dir) <nl>  { <nl> +  g_autofree gchar *url = NULL; <nl>    FlatpakRemotePrivate *priv; <nl>    FlatpakRemote *self = g_object_new (FLATPAK_TYPE_REMOTE, <nl>                                        "name", ostree_remote_get_name (remote), <nl> @@ -761,6 +762,10 @@ flatpak_remote_new_from_ostree (OstreeRemote     *remote, <nl>    if (dir) <nl>      priv->dir = g_object_ref (dir); <nl>   <nl> +  url = ostree_remote_get_url (remote); <nl> +  if (url != NULL) <nl> +    flatpak_remote_set_url (self, url); <nl> + <nl>    return self; <nl>  } <nl>  #endif  /* FLATPAK_ENABLE_P2P */
@@ -14699,6 +14699,8 @@ static void f_synIDattr(typval_T *argvars, typval_T *rettv) <nl>      modec = TOLOWER_ASC(mode[0]); <nl>      if (modec != 'c' && modec != 'g') <nl>        modec = 0;        /* replace invalid with current */ <nl> +  } else if (ui_rgb_attached()) { <nl> +    modec = 'g'; <nl>    } else { <nl>      modec = 'c'; <nl>    }
@@ -2380,7 +2380,7 @@ set_string_option ( <nl>      saved_oldval = vim_strsave(oldval); <nl>    } <nl>   <nl> -  if ((r = did_set_string_option(opt_idx, varp, TRUE, oldval, NULL, <nl> +  if ((r = did_set_string_option(opt_idx, varp, (int)true, oldval, NULL, <nl>            opt_flags)) == NULL) <nl>      did_set_option(opt_idx, opt_flags, TRUE); <nl>  
@@ -89,15 +89,12 @@ typedef unsigned __int3264 ULONG_PTR, *PULONG_PTR; <nl>  typedef signed int LONG32; <nl>  typedef signed __int64 LONG64; <nl>   <nl> -typedef CHAR* PSTR, *LPSTR; <nl> +typedef CHAR* PSTR, *LPSTR, *LPCH; <nl>  typedef const CHAR *LPCSTR,*PCSTR; <nl>   <nl> -typedef WCHAR* LPWSTR, *PWSTR; <nl> +typedef WCHAR* LPWSTR, *PWSTR, *LPWCH; <nl>  typedef const WCHAR *LPCWSTR,*PCWSTR; <nl>   <nl> -typedef CHAR *LPSTR, *LPCH; <nl> -typedef WCHAR *LPWSTR, *LPWCH; <nl> - <nl>  typedef unsigned __int64 QWORD; <nl>  typedef UCHAR* STRING; <nl>  
@@ -111,8 +111,10 @@ int switch_root(const char *new_root) { <nl>   <nl>                  if (fstat(old_root_fd, &rb) < 0) <nl>                          log_warning("Failed to stat old root directory, leaving: %m"); <nl> -                else <nl> +                else { <nl>                          rm_rf_children(old_root_fd, false, false, &rb); <nl> +                        old_root_fd = -1; <nl> +                } <nl>          } <nl>   <nl>          r = 0;
@@ -878,7 +878,7 @@ static int get_key(struct udev *udev, char **line, char **key, enum operation_ty <nl>  	char *temp; <nl>   <nl>  	linepos = *line; <nl> -	if (linepos == NULL && linepos[0] == '\0') <nl> +	if (linepos == NULL || linepos[0] == '\0') <nl>  		return -1; <nl>   <nl>  	/* skip whitespace */
@@ -1377,9 +1377,17 @@ static int socket_recv_message(int fd, struct iovec *iov, uint32_t *_group, bool <nl>                  } <nl>          } <nl>   <nl> -        if (!auth) <nl> +        if (!auth) { <nl>                  /* not from the kernel, ignore */ <nl> +                if (peek) { <nl> +                        /* drop the message */ <nl> +                        r = recvmsg(fd, &msg, 0); <nl> +                        if (r < 0) <nl> +                                return (errno == EAGAIN || errno == EINTR) ? 0 : -errno; <nl> +                } <nl> + <nl>                  return 0; <nl> +        } <nl>   <nl>          if (group) <nl>                  *_group = group;
@@ -43,6 +43,7 @@ enum config_type { <nl>  #define VALUE_SIZE	100 <nl>  #define ID_SIZE		50 <nl>  #define PLACE_SIZE	50 <nl> +#define PROGRAM_SIZE	100 <nl>   <nl>  #define TYPE_LABEL	"LABEL" <nl>  #define TYPE_NUMBER	"NUMBER" <nl> @@ -75,7 +76,7 @@ struct config_device { <nl>  	char id[ID_SIZE]; <nl>  	char place[PLACE_SIZE]; <nl>  	char kernel_name[NAME_SIZE]; <nl> -	char exec_program[FILE_SIZE]; <nl> +	char exec_program[PROGRAM_SIZE]; <nl>  	char name[NAME_SIZE]; <nl>  	char symlink[NAME_SIZE]; <nl>  	struct sysfs_pair sysfs_pair[MAX_SYSFS_PAIRS];
@@ -381,7 +381,8 @@ static void output_units_list(const struct unit_info *unit_infos, unsigned c) { <nl>   <nl>                  n_shown++; <nl>   <nl> -                if (streq(u->load_state, "error")) { <nl> +                if (streq(u->load_state, "error") || <nl> +                    streq(u->load_state, "not-found")) { <nl>                          on_loaded = on = ansi_highlight_red(true); <nl>                          off_loaded = off = ansi_highlight_red(false); <nl>                  } else
@@ -4633,6 +4633,8 @@ static int show_one( <nl>                   */ <nl>                  if (info.pid_file && access(info.pid_file, F_OK) == 0) <nl>                          r = 1; <nl> +                else if (streq_ptr(info.load_state, "not-found") && streq_ptr(info.active_state, "inactive")) <nl> +                        r = 4; <nl>                  else <nl>                          r = 3; <nl>          }
@@ -753,11 +753,12 @@ static void do_kernelname(struct sysfs_class_device *class_dev, struct udevice * <nl>  { <nl>  	struct config_device *dev; <nl>  	struct list_head *tmp; <nl> +	int len; <nl>   <nl>  	strfieldcpy(udev->name, class_dev->name); <nl>  	list_for_each(tmp, &config_device_list) { <nl>  		dev = list_entry(tmp, struct config_device, node); <nl> -		int len = strlen(dev->name); <nl> +		len = strlen(dev->name); <nl>  		if (dev->name[len-1] == '*') { <nl>  			len--; <nl>  			if (strncmp(dev->name, class_dev->name, len))
@@ -972,11 +972,10 @@ static int message_make(sd_bus *bus, size_t size, sd_bus_message **m) { <nl>          assert(bus->state == BUS_RUNNING || bus->state == BUS_HELLO); <nl>   <nl>          if (bus->rbuffer_size > size) { <nl> -                b = memdup((const uint8_t*) bus->rbuffer + size, bus->rbuffer_size - size); <nl> -                if (!b) { <nl> -                        free(t); <nl> +                b = memdup((const uint8_t*) bus->rbuffer + size, <nl> +                           bus->rbuffer_size - size); <nl> +                if (!b) <nl>                          return -ENOMEM; <nl> -                } <nl>          } <nl>   <nl>          r = bus_message_from_malloc(bus->rbuffer, size, <nl> @@ -1536,7 +1535,6 @@ int sd_bus_get_timeout(sd_bus *bus, uint64_t *timeout_usec) { <nl>  } <nl>   <nl>  static int process_timeout(sd_bus *bus) { <nl> -        _cleanup_bus_message_unref_ sd_bus_message *reply = NULL; <nl>          struct reply_callback *c; <nl>          usec_t n; <nl>          int r;
@@ -3829,7 +3829,8 @@ static int append_assignment(DBusMessageIter *iter, const char *assignment) { <nl>   <nl>  static int set_property(DBusConnection *bus, char **args) { <nl>   <nl> -        _cleanup_free_ DBusMessage *m = NULL, *reply = NULL; <nl> +        _cleanup_dbus_message_unref_ DBusMessage *m = NULL, *reply = NULL; <nl> +        _cleanup_free_ char *n = NULL; <nl>          DBusMessageIter iter, sub; <nl>          dbus_bool_t runtime; <nl>          DBusError error; <nl> @@ -3850,7 +3851,11 @@ static int set_property(DBusConnection *bus, char **args) { <nl>   <nl>          runtime = arg_runtime; <nl>   <nl> -        if (!dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &args[1]) || <nl> +        n = unit_name_mangle(args[1]); <nl> +        if (!n) <nl> +                return log_oom(); <nl> + <nl> +        if (!dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &n) || <nl>              !dbus_message_iter_append_basic(&iter, DBUS_TYPE_BOOLEAN, &runtime) || <nl>              !dbus_message_iter_open_container(&iter, DBUS_TYPE_ARRAY, "(sv)", &sub)) <nl>                  return log_oom();
@@ -63,6 +63,7 @@ static int journal_file_object_verify(JournalFile *f, Object *o) { <nl>                  h1 = le64toh(o->data.hash); <nl>   <nl>                  if (o->object.flags & OBJECT_COMPRESSED) { <nl> +#ifdef HAVE_XZ <nl>                          void *b = NULL; <nl>                          uint64_t alloc = 0, b_size; <nl>   <nl> @@ -73,6 +74,9 @@ static int journal_file_object_verify(JournalFile *f, Object *o) { <nl>   <nl>                          h2 = hash64(b, b_size); <nl>                          free(b); <nl> +#else <nl> +                        return -EPROTONOSUPPORT; <nl> +#endif <nl>                  } else <nl>                          h2 = hash64(o->data.payload, le64toh(o->object.size) - offsetof(Object, data.payload)); <nl>  
@@ -615,7 +615,7 @@ int main(int argc, char *argv[]) { <nl>   <nl>          /* Reset the console, but only if this is really init and we <nl>           * are freshly booted */ <nl> -        if (running_as == MANAGER_INIT) <nl> +        if (running_as == MANAGER_INIT && action == ACTION_RUN) <nl>                  console_setup(getpid() == 1 && !serialization); <nl>   <nl>          /* Make sure D-Bus doesn't fiddle with the SIGPIPE handlers */
@@ -1114,8 +1114,10 @@ int session_set_controller(Session *s, const char *sender, bool force) { <nl>           * If logind crashes/restarts, we restore the controller during restart <nl>           * or reset the VT in case it crashed/exited, too. */ <nl>          r = session_prepare_vt(s); <nl> -        if (r < 0) <nl> +        if (r < 0) { <nl> +                free(t); <nl>                  return r; <nl> +        } <nl>   <nl>          session_swap_controller(s, t); <nl>  
@@ -1336,7 +1336,7 @@ int config_parse_exec_selinux_context( <nl>          } else <nl>                  ignore = false; <nl>   <nl> -        r = unit_name_printf(u, rvalue, &k); <nl> +        r = unit_full_printf(u, rvalue, &k); <nl>          if (r < 0) { <nl>                  log_syntax(unit, LOG_ERR, filename, line, r, "Failed to resolve specifiers, ignoring: %m"); <nl>                  return 0; <nl> @@ -1384,7 +1384,7 @@ int config_parse_exec_apparmor_profile( <nl>          } else <nl>                  ignore = false; <nl>   <nl> -        r = unit_name_printf(u, rvalue, &k); <nl> +        r = unit_full_printf(u, rvalue, &k); <nl>          if (r < 0) { <nl>                  log_syntax(unit, LOG_ERR, filename, line, r, "Failed to resolve specifiers, ignoring: %m"); <nl>                  return 0; <nl> @@ -1432,7 +1432,7 @@ int config_parse_exec_smack_process_label( <nl>          } else <nl>                  ignore = false; <nl>   <nl> -        r = unit_name_printf(u, rvalue, &k); <nl> +        r = unit_full_printf(u, rvalue, &k); <nl>          if (r < 0) { <nl>                  log_syntax(unit, LOG_ERR, filename, line, r, "Failed to resolve specifiers, ignoring: %m"); <nl>                  return 0; <nl> @@ -1699,7 +1699,7 @@ int config_parse_fdname( <nl>                  return 0; <nl>          } <nl>   <nl> -        r = unit_name_printf(UNIT(s), rvalue, &p); <nl> +        r = unit_full_printf(UNIT(s), rvalue, &p); <nl>          if (r < 0) { <nl>                  log_syntax(unit, LOG_ERR, filename, line, r, "Failed to resolve specifiers, ignoring: %s", rvalue); <nl>                  return 0; <nl> @@ -3720,7 +3720,7 @@ int config_parse_runtime_directory( <nl>                          return 0; <nl>                  } <nl>   <nl> -                r = unit_name_printf(u, word, &k); <nl> +                r = unit_full_printf(u, word, &k); <nl>                  if (r < 0) { <nl>                          log_syntax(unit, LOG_ERR, filename, line, r, <nl>                                     "Failed to resolve specifiers in \"%s\", ignoring: %m", word);
@@ -4313,6 +4313,10 @@ static int outer_child( <nl>          if (r < 0) <nl>                  return r; <nl>   <nl> +        r = determine_uid_shift(directory); <nl> +        if (r < 0) <nl> +                return r; <nl> + <nl>          /* Turn directory into bind mount */ <nl>          if (mount(directory, directory, NULL, MS_BIND|MS_REC, NULL) < 0) <nl>                  return log_error_errno(errno, "Failed to make bind mount: %m"); <nl> @@ -4491,10 +4495,6 @@ int main(int argc, char *argv[]) { <nl>          if (r < 0) <nl>                  goto finish; <nl>   <nl> -        r = determine_uid_shift(arg_directory); <nl> -        if (r < 0) <nl> -                return r; <nl> - <nl>          if (geteuid() != 0) { <nl>                  log_error("Need to be root."); <nl>                  r = -EPERM;
@@ -81,7 +81,7 @@ struct acpi_fpdt_boot { <nl>  }; <nl>   <nl>  int acpi_get_boot_usec(usec_t *loader_start, usec_t *loader_exit) { <nl> -        _cleanup_free_ char *buf; <nl> +        _cleanup_free_ char *buf = NULL; <nl>          struct acpi_table_header *tbl; <nl>          size_t l; <nl>          struct acpi_fpdt_header *rec;
@@ -196,6 +196,9 @@ static int swap_add_device_links(Swap *s) { <nl>          if (!s->what) <nl>                  return 0; <nl>   <nl> +        if (!s->from_fragment) <nl> +                return 0; <nl> + <nl>          if (is_device_path(s->what)) <nl>                  return unit_add_node_link(UNIT(s), s->what, UNIT(s)->manager->running_as == SYSTEMD_SYSTEM); <nl>          else
@@ -936,8 +936,13 @@ int udev_device_set_syspath(struct udev_device *udev_device, const char *syspath <nl>  	} <nl>   <nl>  	/* trailing number */ <nl> -	while (isdigit(udev_device->sysname[--len])) <nl> +	while (len > 0 && isdigit(udev_device->sysname[--len])) <nl>  		udev_device->sysnum = &udev_device->sysname[len]; <nl> + <nl> +	/* sysname is completely numeric */ <nl> +	if (len == 0) <nl> +		udev_device->sysnum = NULL; <nl> + <nl>  	return 0; <nl>  } <nl>  
@@ -155,7 +155,7 @@ static int show_status(char **args, unsigned n) { <nl>          if (info->fw_secure_boot >= 0) <nl>                  printf("  Secure Boot: %s\n", info->fw_secure_boot ? "enabled" : "disabled"); <nl>          if (info->fw_secure_boot_setup_mode >= 0) <nl> -                printf("     Setup Mode: %s\n", info->fw_secure_boot_setup_mode ? "setup" : "user"); <nl> +                printf("   Setup Mode: %s\n", info->fw_secure_boot_setup_mode ? "setup" : "user"); <nl>   <nl>          if (info->fw_entry_active >= 0) { <nl>                  printf("        Title: %s\n", strna(info->fw_entries[info->fw_entry_active].title)); <nl> @@ -180,7 +180,8 @@ static int show_status(char **args, unsigned n) { <nl>                          printf("        Entry: %s\n", info->loader_entries[info->loader_entry_active].path); <nl>                  } <nl>   <nl> -                printf("      Options: %s\n", strna(info->loader_options_added)); <nl> +                if (info->loader_options_added) <nl> +                        printf("      Options: %s\n", info->loader_options_added); <nl>          } else <nl>                  printf("No suitable data is provided by the boot manager. See:\n" <nl>                         "  http://www.freedesktop.org/wiki/Software/systemd/BootLoaderInterface\n"
@@ -349,7 +349,7 @@ static int find_location(sd_journal *j, JournalFile *f, direction_t direction, O <nl>   <nl>                          r = journal_file_move_to_entry_by_monotonic(f, j->current_location.boot_id, j->current_location.monotonic, direction, &o, &p); <nl>                          if (r <= 0) <nl> -                                return r; <nl> +                                return r == -ENOENT ? 0 : r; <nl>                  } <nl>   <nl>                  LIST_FOREACH(matches, m, j->matches) {
@@ -61,6 +61,8 @@ static void mount_point_free(MountPoint **head, MountPoint *m) { <nl>          LIST_REMOVE(mount_point, *head, m); <nl>   <nl>          free(m->path); <nl> +        free(m->options); <nl> +        free(m->type); <nl>          free(m); <nl>  } <nl>  
@@ -2232,6 +2232,8 @@ static void service_enter_restart(Service *s) { <nl>   <nl>                  if ((r = unit_watch_timer(UNIT(s), s->restart_usec, &s->timer_watch)) < 0) <nl>                          goto fail; <nl> + <nl> +                return; <nl>          } <nl>   <nl>          /* Any units that are bound to this service must also be
@@ -2638,6 +2638,9 @@ static int signal_name_owner_changed(sd_bus_message *message, void *userdata, sd <nl>                  return 0; <nl>          } <nl>   <nl> +        old_owner = isempty(old_owner) ? NULL : old_owner; <nl> +        new_owner = isempty(new_owner) ? NULL : new_owner; <nl> + <nl>          if (UNIT_VTABLE(u)->bus_name_owner_change) <nl>                  UNIT_VTABLE(u)->bus_name_owner_change(u, name, old_owner, new_owner); <nl>  
@@ -1997,13 +1997,19 @@ int dns_packet_extract(DnsPacket *p) { <nl>   <nl>                  for (i = 0; i < n; i++) { <nl>                          _cleanup_(dns_resource_record_unrefp) DnsResourceRecord *rr = NULL; <nl> +                        bool cache_flush; <nl>   <nl> -                        r = dns_packet_read_rr(p, &rr, NULL); <nl> +                        r = dns_packet_read_rr(p, &rr, &cache_flush, NULL); <nl>                          if (r < 0) <nl>                                  goto finish; <nl>   <nl>                          if (rr->key->type == DNS_TYPE_OPT) { <nl>   <nl> +                                if (!dns_name_is_root(DNS_RESOURCE_KEY_NAME(rr->key))) { <nl> +                                        r = -EBADMSG; <nl> +                                        goto finish; <nl> +                                } <nl> + <nl>                                  /* The OPT RR is only valid in the Additional section */ <nl>                                  if (i < DNS_PACKET_ANCOUNT(p) + DNS_PACKET_NSCOUNT(p)) { <nl>                                          r = -EBADMSG;
@@ -40,7 +40,7 @@ class Library_State <nl>        void add_entropy(EntropySource&, bool); <nl>        u32bit seed_prng(bool, u32bit); <nl>   <nl> -      void set_timer(Timer*); <nl> +      void set_timer(class Timer*); <nl>        u64bit system_clock() const; <nl>   <nl>        void set_option(const std::string&, const std::string&, <nl> @@ -59,7 +59,7 @@ class Library_State <nl>        std::string transcode(const std::string, <nl>                              Character_Set, Character_Set) const; <nl>   <nl> -      Library_State(class Mutex_Factory*, class Timer*); <nl> +      Library_State(class Mutex_Factory*); <nl>        ~Library_State(); <nl>     private: <nl>        Library_State(const Library_State&) {}
@@ -106,8 +106,9 @@ Client_Key_Exchange::Client_Key_Exchange(Handshake_IO& io, <nl>   <nl>           DL_Group group(p, g); <nl>   <nl> -         if(!group.verify_group(rng, true)) <nl> -            throw Internal_Error("DH group failed validation, possible attack"); <nl> +         if(!group.verify_group(rng, false)) <nl> +            throw TLS_Exception(Alert::INSUFFICIENT_SECURITY, <nl> +                                "DH group validation failed"); <nl>   <nl>           DH_PublicKey counterparty_key(group, Y); <nl>  
@@ -82,9 +82,8 @@ BOTAN_DLL void encode(const Private_Key& key, Pipe& pipe, <nl>  * @param pipe the pipe to feed the encoded key into <nl>  * @param pass the password to use for encryption <nl>  * @param rng the rng to use <nl> -* @param pbe_algo the name of the desired password-based encryption algorithm. <nl> -* Provide an empty string to use the default PBE defined in the configuration <nl> -* under base/default_pbe. <nl> +* @param pbe_algo the name of the desired password-based encryption algorithm; <nl> +         if empty ("") a reasonable (portable/secure) default will be chosen. <nl>  * @param enc the encoding type to use <nl>  */ <nl>  BOTAN_DLL void encrypt_key(const Private_Key& key, <nl> @@ -108,9 +107,8 @@ BOTAN_DLL std::string PEM_encode(const Private_Key& key); <nl>  * @param key the key to encode <nl>  * @param rng the rng to use <nl>  * @param pass the password to use for encryption <nl> -* @param pbe_algo the name of the desired password-based encryption algorithm. <nl> -* Provide an empty string to use the default PBE defined in the configuration <nl> -* under base/default_pbe. <nl> +* @param pbe_algo the name of the desired password-based encryption algorithm; <nl> +         if empty ("") a reasonable (portable/secure) default will be chosen. <nl>  */ <nl>  BOTAN_DLL std::string PEM_encode(const Private_Key& key, <nl>                                   RandomNumberGenerator& rng,
@@ -837,12 +837,12 @@ tgs_make_reply(krb5_context context, <nl>      } <nl>      if(et.renew_till){ <nl>  	time_t renew; <nl> -	renew = *et.renew_till - et.authtime; <nl> +	renew = *et.renew_till - *et.starttime; <nl>  	if(client && client->entry.max_renew) <nl>  	    renew = min(renew, *client->entry.max_renew); <nl>  	if(server->entry.max_renew) <nl>  	    renew = min(renew, *server->entry.max_renew); <nl> -	*et.renew_till = et.authtime + renew; <nl> +	*et.renew_till = *et.starttime + renew; <nl>      } <nl>   <nl>      if(et.renew_till){
@@ -595,11 +595,12 @@ copy_stream (FILE * from, FILE * to) <nl>  	    return 0; <nl>  	off = 0; <nl>  	while (off != st.st_size) { <nl> -	    size_t len = BLOCKSIZE; <nl> +	    size_t len; <nl>  	    ssize_t res; <nl>   <nl> -	    if (off + len > st.st_size) <nl> -		len = st.st_size - off; <nl> +	    len = st.st_size - off; <nl> +	    if (len > BLOCKSIZE) <nl> +		len = BLOCKSIZE; <nl>   <nl>  	    chunk = mmap (0, len, PROT_READ, MAP_SHARED, fileno (from), off); <nl>  	    if (chunk == (void *) MAP_FAILED) {
@@ -91,7 +91,7 @@ find_all_addresses (krb5_context context, krb5_addresses *res, int flags) <nl>  { <nl>      struct sockaddr sa_zero; <nl>      struct ifaddrs *ifa0, *ifa; <nl> -    krb5_error_code ret;  <nl> +    krb5_error_code ret = ENXIO;  <nl>      int num, idx; <nl>   <nl>      res->val = NULL;
@@ -570,9 +570,7 @@ write_stats(krb5_context context, slave *slaves, u_int32_t current_version) <nl>  	else <nl>  	    rtbl_add_column_entry(tbl, SLAVE_STATUS, "Up"); <nl>   <nl> -	if (strftime(str, sizeof(str), "%Y-%m-%d %H:%M:%S %Z",  <nl> -		     localtime(&slaves->seen)) == 0) <nl> -	    strlcpy(str, "Unknown time", sizeof(str)); <nl> +	ret = krb5_format_time(context, slaves->seen, str, sizeof(str), TRUE);  <nl>  	rtbl_add_column_entry(tbl, SLAVE_SEEN, str); <nl>   <nl>  	slaves = slaves->next;
@@ -187,6 +187,8 @@ imath_rsa_public_decrypt(int flen, const unsigned char* from, <nl>      mp_int_clear(&us); <nl>   <nl>      /* head zero was skipped by mp_int_to_unsigned */ <nl> +    if (*p == 0) <nl> +	return -7; <nl>      if (*p != 1) <nl>  	return -6; <nl>      size--; p++;
@@ -107,7 +107,7 @@ <nl>  #define FILIO_H 1 <nl>  #define STREAMS 1 <nl>   <nl> -#ifdef __svr4__ <nl> +#if defined(__svr4__) || defined(__SVR4) <nl>  #define SOLARIS <nl>  #endif <nl>  
@@ -603,6 +603,14 @@ sec_prot_internal(int level) <nl>      return 0; <nl>  } <nl>   <nl> +enum protection_level <nl> +set_command_prot(enum protection_level level) <nl> +{ <nl> +    enum protection_level old = command_prot; <nl> +    command_prot = level; <nl> +    return old; <nl> +} <nl> + <nl>  void <nl>  sec_prot(int argc, char **argv) <nl>  { <nl> @@ -633,7 +641,7 @@ sec_prot(int argc, char **argv) <nl>  	    return; <nl>  	} <nl>      } else if(strcasecmp(argv[1], "command") == 0) <nl> -	command_prot = level; <nl> +	set_command_prot(level); <nl>      else <nl>  	goto usage; <nl>      code = 0;
@@ -1699,6 +1699,10 @@ tgs_build_reply(astgs_request_t priv, <nl>   <nl>  	s = &adtkt.cname; <nl>  	r = adtkt.crealm; <nl> +    } else if (s == NULL) { <nl> +	ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN; <nl> +	_kdc_set_e_text(r, "No server in request"); <nl> +	goto out; <nl>      } <nl>   <nl>      _krb5_principalname2krb5_principal(context, &sp, *s, r);
@@ -207,8 +207,10 @@ int rdp_redirection_apply_settings(rdpRdp* rdp) <nl>  			settings->TargetNetAddresses[i] = _strdup(redirection->TargetNetAddresses[i]); <nl>  			if (!settings->TargetNetAddresses[i]) <nl>  			{ <nl> -				for (; i > 0; --i) <nl> -					free(settings->TargetNetAddresses[i]); <nl> +				UINT32 j; <nl> + <nl> +				for (j=0; j < i; j++) <nl> +					free(settings->TargetNetAddresses[j]); <nl>  				return -1; <nl>  			} <nl>  		}
@@ -404,7 +404,9 @@ int rdtk_font_parse_descriptor_buffer(rdtkFont* font, BYTE* buffer, int size) <nl>  	} <nl>   <nl>  	font->glyphCount = count; <nl> -	font->glyphs = (rdtkGlyph*) calloc(font->glyphCount, sizeof(rdtkGlyph)); <nl> +	font->glyphs = NULL; <nl> +	if (count > 0) <nl> +		font->glyphs = (rdtkGlyph*) calloc(font->glyphCount, sizeof(rdtkGlyph)); <nl>   <nl>  	if (!font->glyphs) <nl>  		return -1;
@@ -565,6 +565,8 @@ void update_free(rdpUpdate* update) <nl>   <nl>  		xfree(update->bitmap_update.rectangles); <nl>  		xfree(update->pointer); <nl> +		xfree(update->primary->polyline.points); <nl> +		xfree(update->primary->polygon_sc.points); <nl>  		xfree(update->primary); <nl>  		xfree(update->secondary); <nl>  		xfree(update->altsec);
@@ -586,14 +586,19 @@ int shadow_server_start(rdpShadowServer* server) <nl>  		char** list = CommandLineParseCommaSeparatedValuesEx(NULL, server->ipcSocket, &count); <nl>  		if (!list || (count <= 1)) <nl>  		{ <nl> -			free(list); <nl>  			if (server->ipcSocket == NULL) <nl>  			{ <nl>  				if (!open_port(server, NULL)) <nl> +				{ <nl> +					free(list); <nl>  					return -1; <nl> +				} <nl>  			} <nl>  			else <nl> +			{ <nl> +				free(list); <nl>  				return -1; <nl> +			} <nl>  		} <nl>   <nl>  		for (x = 1; x < count; x++)
@@ -403,7 +403,8 @@ void glyph_cache_put(rdpGlyphCache* glyph_cache, UINT32 id, UINT32 index, rdpGly <nl>  	if (prevGlyph != NULL) <nl>  	{ <nl>  		Glyph_Free(glyph_cache->context, prevGlyph); <nl> -		free(prevGlyph->aj); <nl> +		if (NULL != prevGlyph->aj) <nl> +			free(prevGlyph->aj); <nl>  		free(prevGlyph); <nl>  	} <nl>   <nl> @@ -498,12 +499,14 @@ void glyph_cache_free(rdpGlyphCache* glyph_cache) <nl>  				if (glyph != NULL) <nl>  				{ <nl>  					Glyph_Free(glyph_cache->context, glyph); <nl> -					free(glyph->aj); <nl> +					if (glyph->aj) <nl> +						free(glyph->aj); <nl>  					free(glyph); <nl>  					glyph_cache->glyphCache[i].entries[j] = NULL; <nl>  				} <nl>  			} <nl>  			free(glyph_cache->glyphCache[i].entries); <nl> +			glyph_cache->glyphCache[i].entries = NULL; <nl>  		} <nl>   <nl>  		for (i = 0; i < 255; i++)
@@ -21,6 +21,8 @@ <nl>  #include "config.h" <nl>  #endif <nl>   <nl> +#include <assert.h> <nl> + <nl>  #include "ntlm.h" <nl>  #include "../sspi.h" <nl>   <nl> @@ -143,6 +145,7 @@ NTLM_AV_PAIR* ntlm_av_pair_add(NTLM_AV_PAIR* pAvPairList, NTLM_AV_ID AvId, PBYTE <nl>  	if (!pAvPair) <nl>  		return NULL; <nl>   <nl> +	assert(Value != NULL); <nl>  	pAvPair->AvId = AvId; <nl>  	pAvPair->AvLen = AvLen; <nl>  	CopyMemory(ntlm_av_pair_get_value_pointer(pAvPair), Value, AvLen);
@@ -219,6 +219,11 @@ SECURITY_STATUS ntlm_read_NegotiateMessage(NTLM_CONTEXT* context, PSecBuffer buf <nl>  		return SEC_E_INVALID_TOKEN; <nl>  	} <nl>   <nl> +	if (Stream_GetRemainingLength(s) < 4) <nl> +	{ <nl> +		Stream_Free(s, FALSE); <nl> +		return SEC_E_INVALID_TOKEN; <nl> +	} <nl>  	Stream_Read_UINT32(s, message->NegotiateFlags); /* NegotiateFlags (4 bytes) */ <nl>   <nl>  	if (!((message->NegotiateFlags & NTLMSSP_REQUEST_TARGET) &&
@@ -435,6 +435,7 @@ static UINT android_cliprdr_server_format_data_response( <nl>  		formatId = ClipboardRegisterFormat(afc->clipboard, "UTF8_STRING"); <nl>  		data = (void*) ClipboardGetData(afc->clipboard, formatId, &size); <nl>  		attached = jni_attach_thread(&env); <nl> +		size = strnlen(data, size); <nl>  		jdata = jniNewStringUTF(env, data, size); <nl>  		freerdp_callback("OnRemoteClipboardChanged", "(JLjava/lang/String;)V", (jlong)instance, <nl>  		                 jdata);
@@ -504,10 +504,10 @@ void cleanup_handle(void *obj) <nl>  		WLog_ERR(TAG, "failed to destroy mutex [%d] %s (%d)", <nl>  				rc, strerror(errno), errno); <nl>   <nl> -	if (thread->pipe_fd[0]) <nl> +	if (thread->pipe_fd[0] >= 0) <nl>  		close(thread->pipe_fd[0]); <nl>   <nl> -	if (thread->pipe_fd[1]) <nl> +	if (thread->pipe_fd[1] >= 0) <nl>  		close(thread->pipe_fd[1]); <nl>   <nl>  	if (thread_list && ListDictionary_Contains(thread_list, &thread->thread))
@@ -1312,6 +1312,10 @@ static void xf_post_disconnect(freerdp* instance) <nl>  static int xf_logon_error_info(freerdp* instance, UINT32 data, UINT32 type) <nl>  { <nl>  	xfContext* xfc = (xfContext*) instance->context; <nl> +	const char *str_data = freerdp_get_logon_error_info_data(data); <nl> +	const char *str_type = freerdp_get_logon_error_info_type(type); <nl> +	WLog_INFO(TAG, "Logon Error Info %s [%s]", str_data, str_type); <nl> + <nl>  	xf_rail_disable_remoteapp_mode(xfc); <nl>  	return 1; <nl>  }
@@ -5,6 +5,7 @@ <nl>   * Copyright 2013 Marc-Andre Moreau <marcandre.moreau@gmail.com> <nl>   * Copyright 2015 Thincast Technologies GmbH <nl>   * Copyright 2015 DI (FH) Martin Haimberger <martin.haimberger@thincast.com> <nl> + * Copyright 2016 David PHAM-VAN <d.phamvan@inuvika.com> <nl>   * <nl>   * Licensed under the Apache License, Version 2.0 (the "License"); <nl>   * you may not use this file except in compliance with the License. <nl> @@ -317,6 +318,9 @@ static UINT disp_plugin_initialize(IWTSPlugin* pPlugin, IWTSVirtualChannelManage <nl>   */ <nl>  static UINT disp_plugin_terminated(IWTSPlugin* pPlugin) <nl>  { <nl> +	DISP_PLUGIN* disp = (DISP_PLUGIN*) pPlugin; <nl> +	free(disp->listener_callback); <nl> +	free(disp->iface.pInterface); <nl>  	free(pPlugin); <nl>  	return CHANNEL_RC_OK; <nl>  }
@@ -3762,12 +3762,13 @@ static BOOL update_recv_secondary_order(rdpUpdate* update, wStream* s, BYTE flag <nl>  		           name, end - start); <nl>  		return FALSE; <nl>  	} <nl> -	diff = start - end; <nl> +	diff = end - start; <nl>  	if (diff > 0) <nl>  	{ <nl>  		WLog_Print(update->log, WLOG_DEBUG, <nl>  		           "SECONDARY_ORDER %s: read %" PRIuz "bytes short, skipping", name, diff); <nl> -		Stream_Seek(s, diff); <nl> +		if (!Stream_SafeSeek(s, diff)) <nl> +			return FALSE; <nl>  	} <nl>  	return rc; <nl>  }
@@ -711,7 +711,7 @@ class CAdminMod : public CModule { <nl>          } <nl>   <nl>          PutModule(t_p("Channel {1} is deleted from network {2} of user {3}", <nl> -                      "Channels {2} are deleted from network {2} of user {3}", <nl> +                      "Channels {1} are deleted from network {2} of user {3}", <nl>                        vsNames.size())( <nl>              CString(", ").Join(vsNames.begin(), vsNames.end()), <nl>              pNetwork->GetName(), sUsername));
@@ -543,7 +543,7 @@ namespace mongo { <nl>      int retMissing( const ElementMatcher &bm ) { <nl>          if ( bm.compareOp != BSONObj::opEXISTS ) <nl>              return 0; <nl> -        return ( bm.toMatch.boolean() ^ bm.isNot ) ? -1 : 1; <nl> +        return bm.toMatch.boolean() ? -1 : 1; <nl>      } <nl>   <nl>      /* Check if a particular field matches. <nl> @@ -788,7 +788,7 @@ namespace mongo { <nl>              BSONElement& m = bm.toMatch; <nl>              // -1=mismatch. 0=missing element. 1=match <nl>              int cmp = matchesDotted(m.fieldName(), m, jsobj, bm.compareOp, bm , false , details ); <nl> -            if ( bm.compareOp != BSONObj::opEXISTS && bm.isNot ) <nl> +            if ( bm.isNot ) <nl>                  cmp = -cmp; <nl>              if ( cmp < 0 ) <nl>                  return false;
@@ -85,7 +85,7 @@ namespace mongo { <nl>      } <nl>   <nl>      void AuthenticationInfo::_checkLocalHostSpecialAdmin() { <nl> -        if (!_isLocalHost || !_isLocalHostAndLocalHostIsAuthorizedForAll) { <nl> +        if (noauth || !_isLocalHost || !_isLocalHostAndLocalHostIsAuthorizedForAll) { <nl>              return; <nl>          } <nl>  
@@ -35,10 +35,12 @@ using namespace mongoutils; <nl>   <nl>  namespace mongo { <nl>   <nl> +    extern string dbpath; <nl>      void ensureParentDirCreated(const boost::filesystem::path& p){ <nl>          const boost::filesystem::path parent = p.parent_path(); <nl>   <nl>          if (! boost::filesystem::exists(parent)){ <nl> +            massert(13624, "dbpath doesn't exist", parent != dbpath); <nl>              ensureParentDirCreated(parent); <nl>              log() << "creating directory " << parent.string() << endl; <nl>              boost::filesystem::create_directory(parent);
@@ -411,7 +411,12 @@ namespace mongo { <nl>          invariant(!inAWriteUnitOfWork()); <nl>   <nl>          // Only Global and Flush lock could be held at this point. <nl> -        invariant(_requests.size() == 2); <nl> +        if ( IsForMMAPV1 ) { <nl> +            invariant(_requests.size() == 2); <nl> +        } <nl> +        else { <nl> +            invariant(_requests.size() == 1); <nl> +        } <nl>   <nl>          LockRequest* globalLockRequest = _find(resourceIdGlobal); <nl>          invariant(globalLockRequest->mode == MODE_X);
@@ -669,6 +669,8 @@ int _main(int argc, char* argv[]) { <nl>   <nl>          shellHistoryInit(); <nl>   <nl> +        string prompt; <nl> + <nl>          //v8::Handle<v8::Object> shellHelper = baseContext_->Global()->Get( v8::String::New( "shellHelper" ) )->ToObject(); <nl>   <nl>          while ( 1 ) { <nl> @@ -677,8 +679,11 @@ int _main(int argc, char* argv[]) { <nl>  //            shellMainScope->localConnect; <nl>              //DBClientWithCommands *c = getConnection( JSContext *cx, JSObject *obj ); <nl>   <nl> -            string prompt(sayReplSetMemberState()+"> "); <nl> - <nl> +            if (scope->exec("prompt", "", false, false, false)) { <nl> +                prompt = scope->getString("prompt"); <nl> +             } else { <nl> +                prompt = sayReplSetMemberState()+"> "; <nl> +             } <nl>              char * line = shellReadline( prompt.c_str() ); <nl>   <nl>              if ( line ) {
@@ -140,7 +140,7 @@ namespace mongo { <nl>                  } <nl>                  if ( bestmatchlen < INT_MAX && --extra <= 0 ) <nl>                      break; <nl> -                if ( ++chain > 30 && b < MaxBucket ) { <nl> +                if ( ++chain > 30 && b <= MaxBucket ) { <nl>                      // too slow, force move to next bucket to grab a big chunk <nl>                      //b++; <nl>                      freelistIterations.increment( chain );
@@ -131,7 +131,7 @@ void ReplSetDistLockManager::doTask() { <nl>              auto txn = cc().makeOperationContext(); <nl>              auto pingStatus = _catalog->ping(txn.get(), _processID, Date_t::now()); <nl>   <nl> -            if (!pingStatus.isOK()) { <nl> +            if (!pingStatus.isOK() && pingStatus != ErrorCodes::NotMaster) { <nl>                  warning() << "pinging failed for distributed lock pinger" << causedBy(pingStatus); <nl>              } <nl>  
@@ -393,6 +393,9 @@ namespace mongo { <nl>                  double fivePct = free * 0.05; <nl>                  if ( fivePct > sz ) <nl>                      sz = fivePct; <nl> +                // we use 5% of free space up to 50GB (1TB free) <nl> +                if (fivePct > 50.0 * 1024 * 1024 * 1024) <nl> +                    sz = 50.0 * 1024 * 1024 * 1024; <nl>  #endif <nl>              } <nl>          }
@@ -56,6 +56,8 @@ namespace cling { <nl>        for (DeclStmt::decl_iterator J = DS->decl_begin(); <nl>             J != DS->decl_end(); ++J) { <nl>          NamedDecl* ND = dyn_cast<NamedDecl>(*J); <nl> +        if (isa<UsingDirectiveDecl>(*J)) <nl> +          continue; // FIXME: Here we should be more elegant. <nl>          if (ND) { <nl>            DeclContext* OldDC = ND->getDeclContext(); <nl>  
@@ -69,6 +69,8 @@ namespace cling { <nl>                            llvm::StringRef RelativePath, <nl>                            const clang::Module *Imported) { <nl>   <nl> +    if (!File) <nl> +      return; <nl>      auto iterator = m_Map.find(File->getUID()); <nl>      if (iterator == m_Map.end()) <nl>        return; // nothing to do, file not referred in any annotation
@@ -57,7 +57,8 @@ public: <nl>   <nl>     TTreeReader(): <nl>        fDirectory(0), <nl> -      fEntryStatus(kEntryNoTree) <nl> +      fEntryStatus(kEntryNoTree), <nl> +      fDirector(0) <nl>     {} <nl>   <nl>     TTreeReader(TTree* tree);
@@ -404,6 +404,10 @@ int ff_ivi_decode_blocks(GetBitContext *gb, IVIBandDesc *band, IVITile *tile) <nl>                          hi  = get_vlc2(gb, band->blk_vlc.tab->table, IVI_VLC_BITS, 1); <nl>                          val = IVI_TOSIGNED((hi << 6) | lo); /* merge them and convert into signed val */ <nl>                      } else { <nl> +                        if (sym >= 256U) { <nl> +                            av_log(NULL, AV_LOG_ERROR, "Invalid sym encountered: %d.\n", sym); <nl> +                            return -1; <nl> +                        } <nl>                          run = rvmap->runtab[sym]; <nl>                          val = rvmap->valtab[sym]; <nl>                      }
@@ -77,11 +77,6 @@ static int draw_slice(AVFilterLink *inlink, int y0, int h, int slice_dir) <nl>                  pin += 4; <nl>              } <nl>          } <nl> -    } else if (cur_buf->linesize[A] == out_buf->linesize[Y]) { <nl> -        const int linesize = cur_buf->linesize[A]; <nl> -        memcpy(out_buf->data[Y] + y0 * linesize, <nl> -               cur_buf->data[A] + y0 * linesize, <nl> -               linesize * h); <nl>      } else { <nl>          const int linesize = FFMIN(out_buf->linesize[Y], cur_buf->linesize[A]); <nl>          int y;
@@ -239,11 +239,13 @@ static inline void skip_remaining(BitstreamContext *bc, unsigned n) <nl>  /* Skip n bits in the buffer. */ <nl>  static inline void bitstream_skip(BitstreamContext *bc, unsigned n) <nl>  { <nl> -    if (n <= bc->bits_left) <nl> +    if (n < bc->bits_left) <nl>          skip_remaining(bc, n); <nl>      else { <nl>          n -= bc->bits_left; <nl> -        skip_remaining(bc, bc->bits_left); <nl> +        bc->bits      = 0; <nl> +        bc->bits_left = 0; <nl> + <nl>          if (n >= 64) { <nl>              unsigned skip = n / 8; <nl>  
@@ -179,6 +179,9 @@ static int filter_samples(AVFilterLink *inlink, AVFilterBufferRef *insamplesref) <nl>      AVFilterBufferRef *outsamplesref = ff_get_audio_buffer(outlink, AV_PERM_WRITE, n_out); <nl>      int ret; <nl>   <nl> +    if(!outsamplesref) <nl> +        return AVERROR(ENOMEM); <nl> + <nl>      avfilter_copy_buffer_ref_props(outsamplesref, insamplesref); <nl>      outsamplesref->format                = outlink->format; <nl>      outsamplesref->audio->channel_layout = outlink->channel_layout;
@@ -316,6 +316,7 @@ static int filter_frame(AVFilterLink *inlink, AVFrame *in) <nl>          direct = 1; <nl>          out = in; <nl>      } else { <nl> +        direct = 0; <nl>          out = ff_get_video_buffer(outlink, outlink->w, outlink->h); <nl>          if (!out) { <nl>              av_frame_free(&in);
@@ -46,7 +46,7 @@ struct dshow_ctx { <nl>      HANDLE event; <nl>      AVPacketList *pktl; <nl>   <nl> -    unsigned int curbufsize; <nl> +    int64_t curbufsize; <nl>      unsigned int video_frame_num; <nl>   <nl>      IMediaControl *control;
@@ -91,7 +91,7 @@ int ff_vorbis_len2vlc(uint8_t *bits, uint32_t *codes, unsigned num) <nl>          exit_at_level[i] = 0; <nl>          // construct code (append 0s to end) and introduce new exits <nl>          for (j = i + 1 ;j <= bits[p]; ++j) <nl> -            exit_at_level[j] = code + (1 << (j - 1)); <nl> +            exit_at_level[j] = code + (1u << (j - 1)); <nl>          codes[p] = code; <nl>      } <nl>  
@@ -1862,7 +1862,8 @@ static int has_codec_parameters(AVCodecContext *enc) <nl>          val = enc->sample_rate && enc->channels && enc->sample_fmt != SAMPLE_FMT_NONE; <nl>          if(!enc->frame_size && <nl>             (enc->codec_id == CODEC_ID_VORBIS || <nl> -            enc->codec_id == CODEC_ID_AAC)) <nl> +            enc->codec_id == CODEC_ID_AAC || <nl> +            enc->codec_id == CODEC_ID_SPEEX)) <nl>              return 0; <nl>          break; <nl>      case CODEC_TYPE_VIDEO:
@@ -72,7 +72,7 @@ static inline void dct_unquantize_h263_helper_c(DCTELEM *block, int qmul, int qa <nl>     int xqmul = xxqmul, xqadd = xxqadd, xcount = xxcount, xtmp; \ <nl>     int xdata1, xdata2; \ <nl>  __asm__ __volatile__( \ <nl> -        "subs %[count], #2                 \n\t" \ <nl> +        "subs %[count], %[count], #2       \n\t" \ <nl>          "ble 2f                            \n\t" \ <nl>          "ldrd r4, [%[block], #0]           \n\t" \ <nl>          "1:                                \n\t" \ <nl> @@ -128,11 +128,11 @@ __asm__ __volatile__( \ <nl>          "strh r7, [%[block]], #2            \n\t" \ <nl>          "strh %[data2], [%[block]], #2      \n\t" \ <nl>  \ <nl> -        "subs %[count], #8                  \n\t" \ <nl> +        "subs %[count], %[count], #8        \n\t" \ <nl>          "ldrgtd r4, [%[block], #0]          \n\t" /* load data early to avoid load/use pipeline stall */ \ <nl>          "bgt 1b                             \n\t" \ <nl>  \ <nl> -        "adds %[count], #2                  \n\t" \ <nl> +        "adds %[count], %[count], #2        \n\t" \ <nl>          "ble  3f                            \n\t" \ <nl>          "2:                                 \n\t" \ <nl>          "ldrsh %[data1], [%[block], #0]     \n\t" \
@@ -313,7 +313,7 @@ static void smc_decode_stream(SmcContext *s) <nl>              } else <nl>                  color_table_index = CQUAD * s->buf[stream_ptr++]; <nl>   <nl> -            while (n_blocks--) { <nl> +            while (n_blocks-- && stream_ptr + 3 < s->size) { <nl>                  color_flags = AV_RB32(&s->buf[stream_ptr]); <nl>                  stream_ptr += 4; <nl>                  /* flag mask actually acts as a bit shift count here */
@@ -1880,6 +1880,8 @@ static void copy_bits(PutBitContext *pb, <nl>      rmn_bits = rmn_bytes = get_bits_left(gb); <nl>      if (rmn_bits < nbits) <nl>          return; <nl> +    if (nbits > pb->size_in_bits - put_bits_count(pb)) <nl> +        return; <nl>      rmn_bits &= 7; rmn_bytes >>= 3; <nl>      if ((rmn_bits = FFMIN(rmn_bits, nbits)) > 0) <nl>          put_bits(pb, rmn_bits, get_bits(gb, rmn_bits));
@@ -40,7 +40,7 @@ static const uint8_t *avc_mp4_find_startcode(const uint8_t *start, const uint8_t <nl>          res = (res << 8) | *start++; <nl>      } <nl>   <nl> -    if (res + start > end) { <nl> +    if (end - start < res) { <nl>          return NULL; <nl>      } <nl>  
@@ -110,7 +110,7 @@ void checkasm_stack_clobber(uint64_t clobber, ...); <nl>          }\ <nl>      } while (0) <nl>  #else <nl> -#define bench_new(...) <nl> +#define bench_new(...) while(0) <nl>  #endif <nl>   <nl>  #endif
@@ -1013,6 +1013,8 @@ int ff_h264_decode_extradata(H264Context *h, const uint8_t *buf, int size) <nl>          p += 6; <nl>          for (i = 0; i < cnt; i++) { <nl>              nalsize = AV_RB16(p) + 2; <nl> +            if(nalsize > size - (p-buf)) <nl> +                return -1; <nl>              if(decode_nal_units(h, p, nalsize) < 0) { <nl>                  av_log(avctx, AV_LOG_ERROR, "Decoding sps %d from avcC failed\n", i); <nl>                  return -1; <nl> @@ -1023,6 +1025,8 @@ int ff_h264_decode_extradata(H264Context *h, const uint8_t *buf, int size) <nl>          cnt = *(p++); // Number of pps <nl>          for (i = 0; i < cnt; i++) { <nl>              nalsize = AV_RB16(p) + 2; <nl> +            if(nalsize > size - (p-buf)) <nl> +                return -1; <nl>              if (decode_nal_units(h, p, nalsize) < 0) { <nl>                  av_log(avctx, AV_LOG_ERROR, "Decoding pps %d from avcC failed\n", i); <nl>                  return -1;
@@ -38,10 +38,6 @@ static int parse_picture(AVFormatContext *s, uint8_t *buf, int buf_size) <nl>      int type, width, height; <nl>      int len, ret = 0; <nl>   <nl> -    st = avformat_new_stream(s, NULL); <nl> -    if (!st) <nl> -        return AVERROR(ENOMEM); <nl> - <nl>      pb = avio_alloc_context(buf, buf_size, 0, NULL, NULL, NULL, NULL); <nl>      if (!pb) <nl>          return AVERROR(ENOMEM); <nl> @@ -114,6 +110,12 @@ static int parse_picture(AVFormatContext *s, uint8_t *buf, int buf_size) <nl>          goto fail; <nl>      } <nl>   <nl> +    st = avformat_new_stream(s, NULL); <nl> +    if (!st) { <nl> +        ret = AVERROR(ENOMEM); <nl> +        goto fail; <nl> +    } <nl> + <nl>      av_init_packet(&st->attached_pic); <nl>      st->attached_pic.data         = data; <nl>      st->attached_pic.size         = len;
@@ -159,8 +159,11 @@ static int opt_pad(void *optctx, const char *opt, const char *arg) <nl>   <nl>  static int opt_sameq(void *optctx, const char *opt, const char *arg) <nl>  { <nl> -    av_log(NULL, AV_LOG_WARNING, "Ignoring option '%s'\n", opt); <nl> -    return 0; <nl> +    av_log(NULL, AV_LOG_ERROR, "Option '%s' was removed. " <nl> +           "If you are looking for an option to preserve the quality (which is not " <nl> +           "what -%s was for), use -qscale 0 or an equivalent quality factor option.\n", <nl> +           opt, opt); <nl> +    return AVERROR(EINVAL); <nl>  } <nl>   <nl>  static int opt_video_channel(void *optctx, const char *opt, const char *arg)
@@ -563,7 +563,7 @@ static void psy_3gpp_analyze_channel(FFPsyContext *ctx, int channel, <nl>      AacPsyChannel *pch  = &pctx->ch[channel]; <nl>      int start = 0; <nl>      int i, w, g; <nl> -    float desired_bits, desired_pe, delta_pe, reduction, spread_en[128] = {0}; <nl> +    float desired_bits, desired_pe, delta_pe, reduction= NAN, spread_en[128] = {0}; <nl>      float a = 0.0f, active_lines = 0.0f, norm_fac = 0.0f; <nl>      float pe = pctx->chan_bitrate > 32000 ? 0.0f : FFMAX(50.0f, 100.0f - pctx->chan_bitrate * 100.0f / 32000.0f); <nl>      const int      num_bands   = ctx->num_bands[wi->num_windows == 8];
@@ -55,6 +55,11 @@ static int v410_decode_frame(AVCodecContext *avctx, void *data, <nl>      if (pic->data[0]) <nl>          avctx->release_buffer(avctx, pic); <nl>   <nl> +    if (avpkt->size < 4 * avctx->height * avctx->width) { <nl> +        av_log(avctx, AV_LOG_ERROR, "Insufficient input data.\n"); <nl> +        return AVERROR(EINVAL); <nl> +    } <nl> + <nl>      pic->reference = 0; <nl>   <nl>      if (avctx->get_buffer(avctx, pic) < 0) {
@@ -267,6 +267,8 @@ int avcodec_default_get_buffer(AVCodecContext *s, AVFrame *pic){ <nl>              w+= EDGE_WIDTH*2; <nl>              h+= EDGE_WIDTH*2; <nl>          } <nl> +        avcodec_align_dimensions(s, &w, &h); <nl> + <nl>          avpicture_fill(&picture, NULL, s->pix_fmt, w, h); <nl>          pixel_size= picture.linesize[0]*8 / w; <nl>  //av_log(NULL, AV_LOG_ERROR, "%d %d %d %d\n", (int)picture.data[1], w, h, s->pix_fmt);
@@ -214,6 +214,7 @@ static int filter_frame(AVFilterLink *inlink, AVFrame *in) <nl>                                  in->data[i], in->linesize[i], w, h); <nl>      } <nl>   <nl> +    av_frame_free(&in); <nl>      return ff_filter_frame(outlink, out); <nl>  } <nl>  static const AVFilterPad eq_inputs[] = {
@@ -901,6 +901,9 @@ static int matroska_decode_buffer(uint8_t** buf, int* buf_size, <nl>      int result = 0; <nl>      int olen; <nl>   <nl> +    if (pkt_size >= 10000000) <nl> +        return -1; <nl> + <nl>      switch (encodings[0].compression.algo) { <nl>      case MATROSKA_TRACK_ENCODING_COMP_HEADERSTRIP: <nl>          return encodings[0].compression.settings.size;
@@ -215,7 +215,7 @@ FF_ENABLE_DEPRECATION_WARNINGS <nl>      return 0; <nl>   <nl>  failed_alloc: <nl> -    av_destruct_packet(pkt); <nl> +    av_free_packet(pkt); <nl>      return AVERROR(ENOMEM); <nl>  } <nl>   <nl> @@ -237,7 +237,7 @@ int av_copy_packet_side_data(AVPacket *pkt, AVPacket *src) <nl>      return 0; <nl>   <nl>  failed_alloc: <nl> -    av_destruct_packet(pkt); <nl> +    av_free_packet(pkt); <nl>      return AVERROR(ENOMEM); <nl>  } <nl>  
@@ -1227,7 +1227,7 @@ static int alloc_buffer(FrameBuffer **pool, AVCodecContext *s, FrameBuffer **pbu <nl>      for (i = 0; i < FF_ARRAY_ELEMS(buf->data); i++) { <nl>          const int h_shift = i==0 ? 0 : h_chroma_shift; <nl>          const int v_shift = i==0 ? 0 : v_chroma_shift; <nl> -        if ((s->flags & CODEC_FLAG_EMU_EDGE) || !buf->linesize[1] || !buf->base[i]) <nl> +        if ((s->flags & CODEC_FLAG_EMU_EDGE) || !buf->linesize[i] || !buf->base[i]) <nl>              buf->data[i] = buf->base[i]; <nl>          else <nl>              buf->data[i] = buf->base[i] +
@@ -46,6 +46,7 @@ typedef struct CompandContext { <nl>      char *attacks, *decays, *points; <nl>      CompandSegment *segments; <nl>      ChanParam *channels; <nl> +    int nb_segments; <nl>      double in_min_lin; <nl>      double out_min_lin; <nl>      double curve_dB; <nl> @@ -160,11 +161,11 @@ static double get_volume(CompandContext *s, double in_lin) <nl>   <nl>      in_log = log(in_lin); <nl>   <nl> -    for (i = 1;; i++) <nl> -        if (in_log <= s->segments[i + 1].x) <nl> +    for (i = 1; i < s->nb_segments; i++) <nl> +        if (in_log <= s->segments[i].x) <nl>              break; <nl>   <nl> -    cs = &s->segments[i]; <nl> +    cs = &s->segments[i - 1]; <nl>      in_log -= cs->x; <nl>      out_log = cs->y + in_log * (cs->a * in_log + cs->b); <nl>   <nl> @@ -318,7 +319,8 @@ static int config_output(AVFilterLink *outlink) <nl>      uninit(ctx); <nl>   <nl>      s->channels = av_mallocz_array(outlink->channels, sizeof(*s->channels)); <nl> -    s->segments = av_mallocz_array((nb_points + 4) * 2, sizeof(*s->segments)); <nl> +    s->nb_segments = (nb_points + 4) * 2; <nl> +    s->segments = av_mallocz_array(s->nb_segments, sizeof(*s->segments)); <nl>   <nl>      if (!s->channels || !s->segments) <nl>          return AVERROR(ENOMEM);
@@ -457,6 +457,7 @@ static void destroy_buffers(SANMVideoContext *ctx) <nl>      ctx->frm0_size = <nl>      ctx->frm1_size = <nl>      ctx->frm2_size = 0; <nl> +    init_sizes(ctx, 0, 0); <nl>  } <nl>   <nl>  static av_cold int init_buffers(SANMVideoContext *ctx)
@@ -159,11 +159,11 @@ static void mpegvideo_extract_headers(AVCodecParserContext *s, <nl>          av_log(avctx, AV_LOG_ERROR, "Failed to set dimensions\n"); <nl>   <nl>      if (avctx->codec_id == AV_CODEC_ID_MPEG2VIDEO && bit_rate) { <nl> -        avctx->rc_max_rate = 400*bit_rate; <nl> +        avctx->rc_max_rate = 400LL*bit_rate; <nl>      } <nl>      if (bit_rate && <nl>          ((avctx->codec_id == AV_CODEC_ID_MPEG1VIDEO && bit_rate != 0x3FFFF) || vbv_delay != 0xFFFF)) { <nl> -        avctx->bit_rate = 400*bit_rate; <nl> +        avctx->bit_rate = 400LL*bit_rate; <nl>      } <nl>   <nl>      if (pix_fmt != AV_PIX_FMT_NONE) {
@@ -82,10 +82,12 @@ static av_cold int init(AVFilterContext *ctx, const char *args) <nl>      else if (av_parse_color(rgba_color, drawbox->color_str, -1, ctx) < 0) <nl>          return AVERROR(EINVAL); <nl>   <nl> -    drawbox->yuv_color[Y] = RGB_TO_Y_CCIR(rgba_color[0], rgba_color[1], rgba_color[2]); <nl> -    drawbox->yuv_color[U] = RGB_TO_U_CCIR(rgba_color[0], rgba_color[1], rgba_color[2], 0); <nl> -    drawbox->yuv_color[V] = RGB_TO_V_CCIR(rgba_color[0], rgba_color[1], rgba_color[2], 0); <nl> -    drawbox->yuv_color[A] = rgba_color[3]; <nl> +    if (!drawbox->invert_color) { <nl> +        drawbox->yuv_color[Y] = RGB_TO_Y_CCIR(rgba_color[0], rgba_color[1], rgba_color[2]); <nl> +        drawbox->yuv_color[U] = RGB_TO_U_CCIR(rgba_color[0], rgba_color[1], rgba_color[2], 0); <nl> +        drawbox->yuv_color[V] = RGB_TO_V_CCIR(rgba_color[0], rgba_color[1], rgba_color[2], 0); <nl> +        drawbox->yuv_color[A] = rgba_color[3]; <nl> +    } <nl>   <nl>      return 0; <nl>  }
@@ -19,6 +19,7 @@ <nl>   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA <nl>   */ <nl>   <nl> +#include "libavutil/avassert.h" <nl>  #include "libavutil/base64.h" <nl>  #include "libavutil/avstring.h" <nl>  #include "libavutil/intreadwrite.h" <nl> @@ -1793,7 +1794,8 @@ int ff_rtsp_fetch_packet(AVFormatContext *s, AVPacket *pkt) <nl>                  rt->recvbuf_pos += ret; <nl>                  ret = rt->recvbuf_pos < rt->recvbuf_len; <nl>              } <nl> -        } <nl> +        } else <nl> +            av_assert0(0); <nl>          if (ret == 0) { <nl>              rt->cur_transport_priv = NULL; <nl>              return 0;
@@ -614,7 +614,7 @@ static void hl_motion(H264Context *h, uint8_t *dest_y, uint8_t *dest_cb, uint8_t <nl>  } <nl>   <nl>   <nl> -static void free_tables(H264Context *h){ <nl> +static void free_tables(H264Context *h, int free_rbsp){ <nl>      int i; <nl>      H264Context *hx; <nl>      av_freep(&h->intra4x4_pred_mode); <nl> @@ -637,10 +637,12 @@ static void free_tables(H264Context *h){ <nl>          av_freep(&hx->top_borders[1]); <nl>          av_freep(&hx->top_borders[0]); <nl>          av_freep(&hx->s.obmc_scratchpad); <nl> +        if (free_rbsp){ <nl>          av_freep(&hx->rbsp_buffer[1]); <nl>          av_freep(&hx->rbsp_buffer[0]); <nl>          hx->rbsp_buffer_size[0] = 0; <nl>          hx->rbsp_buffer_size[1] = 0; <nl> +        } <nl>          if (i) av_freep(&h->thread_context[i]); <nl>      } <nl>  } <nl> @@ -748,7 +750,7 @@ int ff_h264_alloc_tables(H264Context *h){ <nl>   <nl>      return 0; <nl>  fail: <nl> -    free_tables(h); <nl> +    free_tables(h, 1); <nl>      return -1; <nl>  } <nl>   <nl> @@ -1776,7 +1778,7 @@ static int decode_slice_header(H264Context *h, H264Context *h0){ <nl>              || av_cmp_q(h->sps.sar, s->avctx->sample_aspect_ratio))) { <nl>          if(h != h0) <nl>              return -1;   // width / height changed during parallelized decoding <nl> -        free_tables(h); <nl> +        free_tables(h, 0); <nl>          flush_dpb(s->avctx); <nl>          MPV_common_end(s); <nl>      } <nl> @@ -3331,7 +3333,7 @@ av_cold void ff_h264_free_context(H264Context *h) <nl>  { <nl>      int i; <nl>   <nl> -    free_tables(h); //FIXME cleanup init stuff perhaps <nl> +    free_tables(h, 1); //FIXME cleanup init stuff perhaps <nl>   <nl>      for(i = 0; i < MAX_SPS_COUNT; i++) <nl>          av_freep(h->sps_buffers + i);
@@ -215,7 +215,7 @@ typedef struct Jpeg2000Component { <nl>  /* misc tools */ <nl>  static inline int ff_jpeg2000_ceildivpow2(int a, int b) <nl>  { <nl> -    return -(((int64_t)(-a)) >> b); <nl> +    return -((-(int64_t)a) >> b); <nl>  } <nl>   <nl>  static inline int ff_jpeg2000_ceildiv(int a, int b)
@@ -233,10 +233,11 @@ static int read_packet(AVFormatContext *s, AVPacket *pkt) <nl>          p->current_frame_block++; <nl>      } <nl>   <nl> -    size = p->video_size - p->frames_offset_table[p->current_frame]; <nl> -    if (size < 1) <nl> +    if (p->frames_offset_table[p->current_frame] >= p->video_size) <nl>          return AVERROR_INVALIDDATA; <nl>   <nl> +    size = p->video_size - p->frames_offset_table[p->current_frame]; <nl> + <nl>      if (av_new_packet(pkt, size) < 0) <nl>          return AVERROR(ENOMEM); <nl>  
@@ -521,6 +521,7 @@ static int mov_text_decode_close(AVCodecContext *avctx) <nl>  { <nl>      MovTextContext *m = avctx->priv_data; <nl>      mov_text_cleanup_ftab(m); <nl> +    mov_text_cleanup(m); <nl>      return 0; <nl>  } <nl>  
@@ -1503,6 +1503,7 @@ static int av_encode(AVFormatContext **output_files, <nl>      /* for each output stream, we compute the right encoding parameters */ <nl>      for(i=0;i<nb_ostreams;i++) { <nl>          ost = ost_table[i]; <nl> +        os = output_files[ost->file_index]; <nl>          ist = ist_table[ost->source_index]; <nl>   <nl>          codec = ost->st->codec; <nl> @@ -1516,7 +1517,14 @@ static int av_encode(AVFormatContext **output_files, <nl>              /* if stream_copy is selected, no need to decode or encode */ <nl>              codec->codec_id = icodec->codec_id; <nl>              codec->codec_type = icodec->codec_type; <nl> -            if(!codec->codec_tag) codec->codec_tag = icodec->codec_tag; <nl> + <nl> +            if(!codec->codec_tag){ <nl> +                if(   !os->oformat->codec_tag <nl> +                   || av_codec_get_id (os->oformat->codec_tag, icodec->codec_tag) > 0 <nl> +                   || av_codec_get_tag(os->oformat->codec_tag, icodec->codec_id) <= 0) <nl> +                    codec->codec_tag = icodec->codec_tag; <nl> +            } <nl> + <nl>              codec->bit_rate = icodec->bit_rate; <nl>              codec->extradata= icodec->extradata; <nl>              codec->extradata_size= icodec->extradata_size;
@@ -96,7 +96,7 @@ static av_always_inline void RENAME(decode_line)(FFV1Context *s, int w, <nl>          } <nl>   <nl>          if (sign) <nl> -            diff = -diff; <nl> +            diff = -(unsigned)diff; <nl>   <nl>          sample[1][x] = av_mod_uintp2(RENAME(predict)(sample[1] + x, sample[0] + x) + (SUINT)diff, bits); <nl>      }
@@ -55,7 +55,7 @@ static int pix_norm1_altivec(uint8_t *pix, int line_size) <nl>      /* Sum up the four partial sums, and put the result into s. */ <nl>      sum = vec_sums((vector signed int) sv, (vector signed int) zero); <nl>      sum = vec_splat(sum, 3); <nl> -    vec_vsx_st(sum, 0, &s); <nl> +    vec_ste(sum, 0, &s); <nl>      return s; <nl>  } <nl>  #else <nl> @@ -113,7 +113,7 @@ static int pix_sum_altivec(uint8_t *pix, int line_size) <nl>      /* Sum up the four partial sums, and put the result into s. */ <nl>      sumdiffs = vec_sums((vector signed int) sad, (vector signed int) zero); <nl>      sumdiffs = vec_splat(sumdiffs, 3); <nl> -    vec_vsx_st(sumdiffs, 0, &s); <nl> +    vec_ste(sumdiffs, 0, &s); <nl>      return s; <nl>  } <nl>  #else
@@ -5121,7 +5121,10 @@ int av_stream_add_side_data(AVStream *st, enum AVPacketSideDataType type, <nl>          } <nl>      } <nl>   <nl> -    tmp = av_realloc_array(st->side_data, st->nb_side_data + 1, sizeof(*tmp)); <nl> +    if ((unsigned)st->nb_side_data + 1 >= INT_MAX / sizeof(*st->side_data)) <nl> +        return AVERROR(ERANGE); <nl> + <nl> +    tmp = av_realloc(st->side_data, st->nb_side_data + 1 * sizeof(*tmp)); <nl>      if (!tmp) { <nl>          return AVERROR(ENOMEM); <nl>      }
@@ -213,6 +213,8 @@ static void restore_median(uint8_t *src, int step, int stride, <nl>          slice_start  = ((slice * height) / slices) & cmask; <nl>          slice_height = ((((slice + 1) * height) / slices) & cmask) - <nl>                         slice_start; <nl> +        if (!slice_height) <nl> +            continue; <nl>   <nl>          bsrc = src + slice_start * stride; <nl>   <nl> @@ -269,6 +271,8 @@ static void restore_median_il(uint8_t *src, int step, int stride, <nl>          slice_height   = ((((slice + 1) * height) / slices) & cmask) - <nl>                           slice_start; <nl>          slice_height >>= 1; <nl> +        if (!slice_height) <nl> +            continue; <nl>   <nl>          bsrc = src + slice_start * stride; <nl>  
@@ -789,6 +789,11 @@ static int wavpack_decode_block(AVCodecContext *avctx, int block_no, <nl>          return -1; <nl>      } <nl>   <nl> +    if (wc->ch_offset >= avctx->channels) { <nl> +        av_log(avctx, AV_LOG_ERROR, "too many channels\n"); <nl> +        return -1; <nl> +    } <nl> + <nl>      memset(s->decorr, 0, MAX_TERMS * sizeof(Decorr)); <nl>      memset(s->ch, 0, sizeof(s->ch)); <nl>      s->extra_bits = 0;
@@ -628,7 +628,7 @@ static int read_sbr_grid(AACContext *ac, SpectralBandReplication *sbr, <nl>                           GetBitContext *gb, SBRData *ch_data) <nl>  { <nl>      int i; <nl> -    unsigned bs_pointer = 0; <nl> +    int bs_pointer = 0; <nl>      // frameLengthFlag ? 15 : 16; 960 sample length frames unsupported; this value is numTimeSlots <nl>      int abs_bord_trail = 16; <nl>      int num_rel_lead, num_rel_trail; <nl> @@ -721,7 +721,7 @@ static int read_sbr_grid(AACContext *ac, SpectralBandReplication *sbr, <nl>          break; <nl>      } <nl>   <nl> -    if (bs_pointer > ch_data->bs_num_env + 1) { <nl> +    if (bs_pointer < 0 || bs_pointer > ch_data->bs_num_env + 1) { <nl>          av_log(ac->avctx, AV_LOG_ERROR, <nl>                 "Invalid bitstream, bs_pointer points to a middle noise border outside the time borders table: %d\n", <nl>                 bs_pointer); <nl> @@ -740,7 +740,7 @@ static int read_sbr_grid(AACContext *ac, SpectralBandReplication *sbr, <nl>      ch_data->t_q[0]                     = ch_data->t_env[0]; <nl>      ch_data->t_q[ch_data->bs_num_noise] = ch_data->t_env[ch_data->bs_num_env]; <nl>      if (ch_data->bs_num_noise > 1) { <nl> -        unsigned int idx; <nl> +        int idx; <nl>          if (ch_data->bs_frame_class == FIXFIX) { <nl>              idx = ch_data->bs_num_env >> 1; <nl>          } else if (ch_data->bs_frame_class & 1) { // FIXVAR or VARVAR
@@ -220,6 +220,8 @@ static void mp_decode_frame_helper(MotionPixelsContext *mp, GetBitContext *gb) <nl>      YuvPixel p; <nl>      int y, y0; <nl>   <nl> +    av_assert1(mp->changes_map[0]); <nl> + <nl>      for (y = 0; y < mp->avctx->height; ++y) { <nl>          if (mp->changes_map[y * mp->avctx->width] != 0) { <nl>              memset(mp->gradient_scale, 1, sizeof(mp->gradient_scale));
@@ -1891,7 +1891,7 @@ int av_find_stream_info(AVFormatContext *ic) <nl>               (st->codec->codec_id == CODEC_ID_MPEG4 && !st->need_parsing))*/) <nl>              try_decode_frame(st, pkt->data, pkt->size); <nl>   <nl> -        if (av_rescale_q(codec_info_duration[st->index], st->time_base, AV_TIME_BASE_Q) >= ic->max_analyze_duration) { <nl> +        if (st->time_base.den > 0 && av_rescale_q(codec_info_duration[st->index], st->time_base, AV_TIME_BASE_Q) >= ic->max_analyze_duration) { <nl>              break; <nl>          } <nl>          count++;
@@ -351,7 +351,7 @@ static int vorbis_parse_setup_hdr_codebooks(vorbis_context *vc) { <nl>              } <nl>   <nl>  // Weed out unused vlcs and build codevector vector <nl> -            codebook_setup->codevectors=(float *)av_mallocz(used_entries*codebook_setup->dimensions * sizeof(float)); <nl> +            codebook_setup->codevectors=used_entries ? (float *)av_mallocz(used_entries*codebook_setup->dimensions * sizeof(float)) : NULL; <nl>              for(j=0, i=0;i<entries;++i) { <nl>                  uint_fast8_t dim=codebook_setup->dimensions; <nl>   <nl> @@ -1291,7 +1291,7 @@ static int vorbis_residue_decode(vorbis_context *vc, vorbis_residue *vr, uint_fa <nl>                          uint_fast8_t vqclass=classifs[j_times_ptns_to_read+partition_count]; <nl>                          int_fast16_t vqbook=vr->books[vqclass][pass]; <nl>   <nl> -                        if (vqbook>=0) { <nl> +                        if (vqbook>=0 && vc->codebooks[vqbook].codevectors) { <nl>                              uint_fast16_t coffs; <nl>                              unsigned dim= vc->codebooks[vqbook].dimensions; // not uint_fast8_t: 64bit is slower here on amd64 <nl>                              uint_fast16_t step= dim==1 ? vr->partition_size
@@ -2427,7 +2427,7 @@ static int hls_slice_data_wpp(HEVCContext *s, const uint8_t *nal, int length) <nl>          for (i = 1; i < s->threads_number; i++) { <nl>              s->sList[i] = av_malloc(sizeof(HEVCContext)); <nl>              memcpy(s->sList[i], s, sizeof(HEVCContext)); <nl> -            s->HEVClcList[i] = av_malloc(sizeof(HEVCLocalContext)); <nl> +            s->HEVClcList[i] = av_mallocz(sizeof(HEVCLocalContext)); <nl>              s->sList[i]->HEVClc = s->HEVClcList[i]; <nl>          } <nl>      }
@@ -5516,7 +5516,7 @@ av_cold int ff_vc1_decode_init_alloc_tables(VC1Context *v) <nl>      v->ttblk            = v->ttblk_base + s->mb_stride; <nl>      v->is_intra_base    = av_mallocz(sizeof(v->is_intra_base[0]) * 2 * s->mb_stride); <nl>      v->is_intra         = v->is_intra_base + s->mb_stride; <nl> -    v->luma_mv_base     = av_malloc(sizeof(v->luma_mv_base[0]) * 2 * s->mb_stride); <nl> +    v->luma_mv_base     = av_mallocz(sizeof(v->luma_mv_base[0]) * 2 * s->mb_stride); <nl>      v->luma_mv          = v->luma_mv_base + s->mb_stride; <nl>   <nl>      /* allocate block type info in that way so it could be used with s->block_index[] */
@@ -74,7 +74,7 @@ static void decode(AVCodecContext *dec_ctx, AVFrame *frame, AVPacket *pkt, <nl>   <nl>          /* the picture is allocated by the decoder. no need to <nl>             free it */ <nl> -        snprintf(buf, sizeof(buf), filename, dec_ctx->frame_number); <nl> +        snprintf(buf, sizeof(buf), "%s-%d", filename, dec_ctx->frame_number); <nl>          pgm_save(frame->data[0], frame->linesize[0], <nl>                   frame->width, frame->height, buf); <nl>      }
@@ -1141,7 +1141,7 @@ static int64_t get_bit_rate(AVCodecContext *ctx) <nl>          break; <nl>      case AVMEDIA_TYPE_AUDIO: <nl>          bits_per_sample = av_get_bits_per_sample(ctx->codec_id); <nl> -        bit_rate = bits_per_sample ? ctx->sample_rate * ctx->channels * bits_per_sample : ctx->bit_rate; <nl> +        bit_rate = bits_per_sample ? ctx->sample_rate * (int64_t)ctx->channels * bits_per_sample : ctx->bit_rate; <nl>          break; <nl>      default: <nl>          bit_rate = 0;
@@ -313,7 +313,10 @@ static av_cold int movie_common_init(AVFilterContext *ctx) <nl>              return AVERROR(ENOMEM); <nl>          pad.config_props  = movie_config_output_props; <nl>          pad.request_frame = movie_request_frame; <nl> -        ff_insert_outpad(ctx, i, &pad); <nl> +        if ((ret = ff_insert_outpad(ctx, i, &pad)) < 0) { <nl> +            av_freep(&pad.name); <nl> +            return ret; <nl> +        } <nl>          if ( movie->st[i].st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO && <nl>              !movie->st[i].st->codecpar->channel_layout) { <nl>              ret = guess_channel_layout(&movie->st[i], i, ctx);
@@ -110,7 +110,7 @@ static void lz_unpack(const unsigned char *src, int src_len, <nl>      while (s_end - s > 0 && dataleft > 0) { <nl>          tag = *s++; <nl>          if ((tag == 0xFF) && (dataleft > 8)) { <nl> -            if (d + 8 > d_end || s_end - s < 8) <nl> +            if (d_end - d < 8 || s_end - s < 8) <nl>                  return; <nl>              for (i = 0; i < 8; i++) { <nl>                  queue[qpos++] = *d++ = *s++; <nl> @@ -122,7 +122,7 @@ static void lz_unpack(const unsigned char *src, int src_len, <nl>                  if (dataleft == 0) <nl>                      break; <nl>                  if (tag & 0x01) { <nl> -                    if (d + 1 > d_end || s_end - s < 1) <nl> +                    if (d_end - d < 1 || s_end - s < 1) <nl>                          return; <nl>                      queue[qpos++] = *d++ = *s++; <nl>                      qpos &= QUEUE_MASK; <nl> @@ -138,7 +138,7 @@ static void lz_unpack(const unsigned char *src, int src_len, <nl>                              return; <nl>                          chainlen = *s++ + 0xF + 3; <nl>                      } <nl> -                    if (d + chainlen > d_end) <nl> +                    if (d_end - d < chainlen) <nl>                          return; <nl>                      for (j = 0; j < chainlen; j++) { <nl>                          *d = queue[chainofs++ & QUEUE_MASK];
@@ -272,8 +272,13 @@ static int cuvid_decode_frame(AVCodecContext *avctx, void *data, int *got_frame, <nl>      av_packet_unref(&filtered_packet); <nl>   <nl>      if (ret < 0) { <nl> -        if (ctx->internal_error) <nl> -            ret = ctx->internal_error; <nl> +        goto error; <nl> +    } <nl> + <nl> +    // cuvidParseVideoData doesn't return an error just because stuff failed... <nl> +    if (ctx->internal_error) { <nl> +        av_log(avctx, AV_LOG_ERROR, "cuvid decode callback error\n"); <nl> +        ret = ctx->internal_error; <nl>          goto error; <nl>      } <nl>  
@@ -730,6 +730,8 @@ static int flv_read_packet(AVFormatContext *s, AVPacket *pkt) <nl>          av_log(s, AV_LOG_WARNING, "Stream discovered after head already parsed\n"); <nl>          st = create_stream(s, <nl>               (int[]){AVMEDIA_TYPE_VIDEO, AVMEDIA_TYPE_AUDIO, AVMEDIA_TYPE_DATA}[stream_type]); <nl> +        if (!st) <nl> +            return AVERROR(ENOMEM); <nl>   <nl>      } <nl>      av_dlog(s, "%d %X %d \n", stream_type, flags, st->discard);
@@ -492,6 +492,7 @@ static int mmap_read_frame(AVFormatContext *ctx, AVPacket *pkt) <nl>          .type   = V4L2_BUF_TYPE_VIDEO_CAPTURE, <nl>          .memory = V4L2_MEMORY_MMAP <nl>      }; <nl> +    struct timeval buf_ts; <nl>      int res; <nl>   <nl>      pkt->size = 0; <nl> @@ -508,6 +509,8 @@ static int mmap_read_frame(AVFormatContext *ctx, AVPacket *pkt) <nl>          return res; <nl>      } <nl>   <nl> +    buf_ts = buf.timestamp; <nl> + <nl>      if (buf.index >= s->buffers) { <nl>          av_log(ctx, AV_LOG_ERROR, "Invalid buffer index received.\n"); <nl>          return AVERROR(EINVAL); <nl> @@ -583,7 +586,7 @@ static int mmap_read_frame(AVFormatContext *ctx, AVPacket *pkt) <nl>              return AVERROR(ENOMEM); <nl>          } <nl>      } <nl> -    pkt->pts = buf.timestamp.tv_sec * INT64_C(1000000) + buf.timestamp.tv_usec; <nl> +    pkt->pts = buf_ts.tv_sec * INT64_C(1000000) + buf_ts.tv_usec; <nl>      convert_timestamp(ctx, &pkt->pts); <nl>   <nl>      return pkt->size;
@@ -128,7 +128,7 @@ int ff_get_cpu_flags_arm(void) <nl>         trickle down. */ <nl>      if (flags & (AV_CPU_FLAG_VFPV3 | AV_CPU_FLAG_NEON)) <nl>          flags |= AV_CPU_FLAG_ARMV6T2; <nl> -    else <nl> +    else if (flags & (AV_CPU_FLAG_ARMV6T2 | AV_CPU_FLAG_ARMV6)) <nl>      /* Some functions use the 'setend' instruction which is deprecated on ARMv8 <nl>       * and serializing on some ARMv7 cores. This ensures such functions <nl>       * are only enabled on ARMv6. */
@@ -229,6 +229,8 @@ static int read_high_coeffs(AVCodecContext *avctx, uint8_t *src, int16_t *dst, i <nl>              cnt1 = get_bits(b, nbits); <nl>          } else { <nl>              pfx = 14 + ((((uint64_t)(value - 14)) >> 32) & (value - 14)); <nl> +            if (pfx < 1 || pfx > 25) <nl> +                return AVERROR_INVALIDDATA; <nl>              cnt1 *= (1 << pfx) - 1; <nl>              shbits = show_bits(b, pfx); <nl>              if (shbits <= 1) {
@@ -1005,6 +1005,8 @@ int ff_h264_decode_extradata(H264Context *h) <nl>          p += 6; <nl>          for (i = 0; i < cnt; i++) { <nl>              nalsize = AV_RB16(p) + 2; <nl> +            if (p - avctx->extradata + nalsize > avctx->extradata_size) <nl> +                return -1; <nl>              if(decode_nal_units(h, p, nalsize) < 0) { <nl>                  av_log(avctx, AV_LOG_ERROR, "Decoding sps %d from avcC failed\n", i); <nl>                  return -1; <nl> @@ -1015,6 +1017,8 @@ int ff_h264_decode_extradata(H264Context *h) <nl>          cnt = *(p++); // Number of pps <nl>          for (i = 0; i < cnt; i++) { <nl>              nalsize = AV_RB16(p) + 2; <nl> +            if (p - avctx->extradata + nalsize > avctx->extradata_size) <nl> +                return -1; <nl>              if (decode_nal_units(h, p, nalsize) < 0) { <nl>                  av_log(avctx, AV_LOG_ERROR, "Decoding pps %d from avcC failed\n", i); <nl>                  return -1;
@@ -255,7 +255,7 @@ static void vmd_decode(VmdVideoContext *s, AVFrame *frame) <nl>                  palette32[i] = (r << 16) | (g << 8) | (b); <nl>              } <nl>          } <nl> -        s->size -= (256 * 3 + 2); <nl> +        s->size -= PALETTE_COUNT * 3 + 2; <nl>      } <nl>      if (s->size > 0) { <nl>          /* originally UnpackFrame in VAG's code */
@@ -659,7 +659,7 @@ static int smka_decode_frame(AVCodecContext *avctx, void *data, <nl>                      res = 0; <nl>                  val |= h[3].values[res] << 8; <nl>                  pred[1] += sign_extend(val, 16); <nl> -                *samples++ = av_clip_int16(pred[1]); <nl> +                *samples++ = pred[1]; <nl>              } else { <nl>                  if(vlc[0].table) <nl>                      res = get_vlc2(&gb, vlc[0].table, SMKTREE_BITS, 3); <nl> @@ -672,7 +672,7 @@ static int smka_decode_frame(AVCodecContext *avctx, void *data, <nl>                      res = 0; <nl>                  val |= h[1].values[res] << 8; <nl>                  pred[0] += sign_extend(val, 16); <nl> -                *samples++ = av_clip_int16(pred[0]); <nl> +                *samples++ = pred[0]; <nl>              } <nl>          } <nl>      } else { //8-bit data <nl> @@ -687,14 +687,14 @@ static int smka_decode_frame(AVCodecContext *avctx, void *data, <nl>                  else <nl>                      res = 0; <nl>                  pred[1] += sign_extend(h[1].values[res], 8); <nl> -                *samples8++ = av_clip_uint8(pred[1]); <nl> +                *samples8++ = pred[1]; <nl>              } else { <nl>                  if(vlc[0].table) <nl>                      res = get_vlc2(&gb, vlc[0].table, SMKTREE_BITS, 3); <nl>                  else <nl>                      res = 0; <nl>                  pred[0] += sign_extend(h[0].values[res], 8); <nl> -                *samples8++ = av_clip_uint8(pred[0]); <nl> +                *samples8++ = pred[0]; <nl>              } <nl>          } <nl>      }
@@ -546,8 +546,11 @@ int av_packet_ref(AVPacket *dst, const AVPacket *src) <nl>          if (ret < 0) <nl>              goto fail; <nl>          memcpy(dst->buf->data, src->data, src->size); <nl> -    } else <nl> +    } else { <nl>          dst->buf = av_buffer_ref(src->buf); <nl> +        if (!dst->buf) <nl> +            goto fail; <nl> +    } <nl>   <nl>      dst->size = src->size; <nl>      dst->data = dst->buf->data;
@@ -1356,6 +1356,12 @@ static int queue_picture(VideoState *is, AVFrame *src_frame, double pts1, int64_ <nl>          while (!vp->allocated && !is->videoq.abort_request) { <nl>              SDL_CondWait(is->pictq_cond, is->pictq_mutex); <nl>          } <nl> +        /* if the queue is aborted, we have to pop the pending ALLOC event or wait for the allocation to complete */ <nl> +        if (is->videoq.abort_request && SDL_PeepEvents(&event, 1, SDL_GETEVENT, SDL_EVENTMASK(FF_ALLOC_EVENT)) != 1) { <nl> +            while (!vp->allocated) { <nl> +                SDL_CondWait(is->pictq_cond, is->pictq_mutex); <nl> +            } <nl> +        } <nl>          SDL_UnlockMutex(is->pictq_mutex); <nl>   <nl>          if (is->videoq.abort_request)
@@ -341,6 +341,14 @@ static int write_packet(AVFormatContext *s, AVPacket *pkt) <nl>              pkt->dts += offset; <nl>          if (pkt->pts != AV_NOPTS_VALUE) <nl>              pkt->pts += offset; <nl> + <nl> +        if (pkt->dts != AV_NOPTS_VALUE && pkt->dts < 0) { <nl> +            av_log(s, AV_LOG_WARNING, <nl> +                   "Packets poorly interleaved, failed to avoid negative " <nl> +                   "timestamp %"PRId64" in stream %d.\n" <nl> +                   "Try -max_interleave_delta 0 as a possible workaround.\n", <nl> +                   pkt->dts, pkt->stream_index); <nl> +        } <nl>      } <nl>      ret = s->oformat->write_packet(s, pkt); <nl>  
@@ -2721,7 +2721,7 @@ int avformat_find_stream_info(AVFormatContext *ic, AVDictionary **options) <nl>                      int framerate= get_std_framerate(i); <nl>                      double sdts= dts*framerate/(1001*12); <nl>                      for(j=0; j<2; j++){ <nl> -                        int ticks= lrintf(sdts+j*0.5); <nl> +                        int64_t ticks= llrint(sdts+j*0.5); <nl>                          double error= sdts - ticks + j*0.5; <nl>                          st->info->duration_error[j][0][i] += error; <nl>                          st->info->duration_error[j][1][i] += error*error;
@@ -805,6 +805,13 @@ static int imc_decode_block(AVCodecContext *avctx, IMCContext *q, int ch) <nl>          imc_decode_level_coefficients2(q, chctx->levlCoeffBuf, chctx->old_floor, <nl>                                         chctx->flcoeffs1, chctx->flcoeffs2); <nl>   <nl> +    for(i=0; i<BANDS; i++) { <nl> +        if(chctx->flcoeffs1[i] > INT_MAX) { <nl> +            av_log(avctx, AV_LOG_ERROR, "scalefactor out of range\n"); <nl> +            return AVERROR_INVALIDDATA; <nl> +        } <nl> +    } <nl> + <nl>      memcpy(chctx->old_floor, chctx->flcoeffs1, 32 * sizeof(float)); <nl>   <nl>      counter = 0;
@@ -2213,7 +2213,7 @@ static int open_input_stream(HTTPContext *c, const char *info) <nl>      c->pts_stream_index = 0; <nl>      for(i=0;i<c->stream->nb_streams;i++) { <nl>          if (c->pts_stream_index == 0 && <nl> -            c->stream->streams[i]->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) { <nl> +            c->stream->streams[i]->codec->codec_type == AVMEDIA_TYPE_VIDEO) { <nl>              c->pts_stream_index = i; <nl>          } <nl>      }
@@ -261,6 +261,10 @@ static av_cold int encode_init(AVCodecContext *avctx) <nl>      if (av_image_check_size(avctx->width, avctx->height, 0, avctx) < 0) { <nl>          return -1; <nl>      } <nl> +    if((avctx->width&3) || (avctx->height&3)){ <nl> +        av_log(avctx, AV_LOG_ERROR, "width and height must be multiplies of 4\n"); <nl> +        return -1; <nl> +    } <nl>   <nl>      avcodec_get_frame_defaults(&c->pic); <nl>      avctx->coded_frame = (AVFrame*)&c->pic;
@@ -161,6 +161,9 @@ static int parse_keyframes_index(AVFormatContext *s, AVIOContext *ioc, AVStream <nl>              break; <nl>   <nl>          arraylen = avio_rb32(ioc); <nl> +        if (arraylen >> 28) <nl> +            break; <nl> + <nl>          /* <nl>           * Expect only 'times' or 'filepositions' sub-arrays in other case refuse to use such metadata <nl>           * for indexing
@@ -489,8 +489,9 @@ static inline int mpeg2_fast_decode_block_non_intra(MpegEncContext *s, <nl>          } <nl>   <nl>          block[j] = level; <nl> -        if (((int32_t)GET_CACHE(re, &s->gb)) <= (int32_t)0xBFFFFFFF) <nl> +        if (((int32_t)GET_CACHE(re, &s->gb)) <= (int32_t)0xBFFFFFFF || i >= 64) <nl>              break; <nl> + <nl>          UPDATE_CACHE(re, &s->gb); <nl>      } <nl>  end:
@@ -1744,6 +1744,7 @@ static int matroska_deliver_packet(MatroskaDemuxContext *matroska, <nl>   */ <nl>  static void matroska_clear_queue(MatroskaDemuxContext *matroska) <nl>  { <nl> +    matroska->prev_pkt = NULL; <nl>      if (matroska->packets) { <nl>          int n; <nl>          for (n = 0; n < matroska->num_packets; n++) { <nl> @@ -2231,7 +2232,6 @@ static int matroska_read_seek(AVFormatContext *s, int stream_index, <nl>          avio_seek(s->pb, st->index_entries[st->nb_index_entries-1].pos, SEEK_SET); <nl>          matroska->current_id = 0; <nl>          while ((index = av_index_search_timestamp(st, timestamp, flags)) < 0) { <nl> -            matroska->prev_pkt = NULL; <nl>              matroska_clear_queue(matroska); <nl>              if (matroska_parse_cluster(matroska) < 0) <nl>                  break;
@@ -126,7 +126,7 @@ typedef struct Picture{ <nl>      int pic_id;                 /**< h264 pic_num (short -> no wrap version of pic_num, <nl>                                       pic_num & max_pic_num; long -> long_pic_num) */ <nl>      int long_ref;               ///< 1->long term reference 0->short term reference <nl> -    int ref_poc[2][2][16];      ///< h264 POCs of the frames used as reference (FIXME need per slice) <nl> +    int ref_poc[2][2][32];      ///< h264 POCs of the frames used as reference (FIXME need per slice) <nl>      int ref_count[2][2];        ///< number of entries in ref_poc              (FIXME need per slice) <nl>      int mbaff;                  ///< h264 1 -> MBAFF frame 0-> not MBAFF <nl>      int field_picture;          ///< whether or not the picture was encoded in separate fields
@@ -143,8 +143,6 @@ static av_cold int che_configure(AACContext *ac, <nl>                                   enum ChannelPosition che_pos, <nl>                                   int type, int id, int *channels) <nl>  { <nl> -    if (*channels >= MAX_CHANNELS) <nl> -        return AVERROR_INVALIDDATA; <nl>      if (che_pos) { <nl>          if (!ac->che[type][id]) { <nl>              if (!(ac->che[type][id] = av_mallocz(sizeof(ChannelElement)))) <nl> @@ -152,6 +150,8 @@ static av_cold int che_configure(AACContext *ac, <nl>              ff_aac_sbr_ctx_init(ac, &ac->che[type][id]->sbr); <nl>          } <nl>          if (type != TYPE_CCE) { <nl> +            if (*channels >= MAX_CHANNELS - 2) <nl> +                return AVERROR_INVALIDDATA; <nl>              ac->output_element[(*channels)++] = &ac->che[type][id]->ch[0]; <nl>              if (type == TYPE_CPE || <nl>                  (type == TYPE_SCE && ac->oc[1].m4ac.ps == 1)) {
@@ -977,6 +977,10 @@ static int amrnb_decode_frame(AVCodecContext *avctx, void *data, <nl>   <nl>          pitch_sharpening(p, subframe, p->cur_frame_mode, &fixed_sparse); <nl>   <nl> +        if (fixed_sparse.pitch_lag == 0) { <nl> +            av_log(avctx, AV_LOG_ERROR, "The file is corrupted, pitch_lag = 0 is not allowed\n"); <nl> +            return AVERROR_INVALIDDATA; <nl> +        } <nl>          ff_set_fixed_vector(p->fixed_vector, &fixed_sparse, 1.0, <nl>                              AMR_SUBFRAME_SIZE); <nl>  
@@ -442,7 +442,8 @@ static void vp6_parse_coeff(VP56Context *s) <nl>          model1 = model->coeff_dccv[pt]; <nl>          model2 = model->coeff_dcct[pt][ctx]; <nl>   <nl> -        for (coeff_idx=0; coeff_idx<64; ) { <nl> +        coeff_idx = 0; <nl> +        for (;;) { <nl>              if ((coeff_idx>1 && ct==0) || vp56_rac_get_prob(c, model2[0])) { <nl>                  /* parse a coeff */ <nl>                  if (vp56_rac_get_prob(c, model2[2])) { <nl> @@ -483,8 +484,10 @@ static void vp6_parse_coeff(VP56Context *s) <nl>                              run += vp56_rac_get_prob(c, model3[i+8]) << i; <nl>                  } <nl>              } <nl> - <nl> -            cg = vp6_coeff_groups[coeff_idx+=run]; <nl> +            coeff_idx += run; <nl> +            if (coeff_idx >= 64) <nl> +                break; <nl> +            cg = vp6_coeff_groups[coeff_idx]; <nl>              model1 = model2 = model->coeff_ract[pt][ct][cg]; <nl>          } <nl>  
@@ -285,8 +285,8 @@ static int hls_delete_old_segments(HLSContext *hls) { <nl>                                       path, strerror(errno)); <nl>          } <nl>   <nl> -        if (segment->sub_filename[0] != '\0') { <nl> -            sub_path_size = strlen(dirname) + strlen(segment->sub_filename) + 1; <nl> +        if ((segment->sub_filename[0] != '\0')) { <nl> +            sub_path_size = strlen(segment->sub_filename) + 1 + (dirname ? strlen(dirname) : 0); <nl>              sub_path = av_malloc(sub_path_size); <nl>              if (!sub_path) { <nl>                  ret = AVERROR(ENOMEM);
@@ -332,7 +332,7 @@ static void adpcm_compress_trellis(AVCodecContext *avctx, <nl>                      uint8_t *h;\ <nl>                      dec_sample = av_clip_int16(dec_sample);\ <nl>                      d = sample - dec_sample;\ <nl> -                    ssd = nodes[j]->ssd + d*d;\ <nl> +                    ssd = nodes[j]->ssd + d*(unsigned)d;\ <nl>                      /* Check for wraparound, skip such samples completely. \ <nl>                       * Note, changing ssd to a 64 bit variable would be \ <nl>                       * simpler, avoiding this check, but it's slower on \
@@ -274,7 +274,7 @@ static int initFilter(int16_t **outFilter, int16_t **filterPos, int *outFilterSi <nl>              int j; <nl>              (*filterPos)[i]= xx; <nl>              for (j=0; j<filterSize; j++) { <nl> -                int64_t d= ((int64_t)FFABS((xx<<17) - xDstInSrc))<<13; <nl> +                int64_t d= (FFABS(((int64_t)xx<<17) - xDstInSrc))<<13; <nl>                  double floatd; <nl>                  int64_t coeff; <nl>  
@@ -749,7 +749,7 @@ int sws_init_context(SwsContext *c, SwsFilter *srcFilter, SwsFilter *dstFilter) <nl>      int srcH= c->srcH; <nl>      int dstW= c->dstW; <nl>      int dstH= c->dstH; <nl> -    int dst_stride = FFALIGN(dstW * sizeof(int16_t), 16), dst_stride_px = dst_stride >> 1; <nl> +    int dst_stride = FFALIGN(dstW * sizeof(int16_t) + 16, 16), dst_stride_px = dst_stride >> 1; <nl>      int flags, cpu_flags; <nl>      enum PixelFormat srcFormat= c->srcFormat; <nl>      enum PixelFormat dstFormat= c->dstFormat;
@@ -1880,6 +1880,8 @@ static void copy_bits(PutBitContext *pb, <nl>      rmn_bits = rmn_bytes = get_bits_left(gb); <nl>      if (rmn_bits < nbits) <nl>          return; <nl> +    if (nbits > pb->size_in_bits - put_bits_count(pb)) <nl> +        return; <nl>      rmn_bits &= 7; rmn_bytes >>= 3; <nl>      if ((rmn_bits = FFMIN(rmn_bits, nbits)) > 0) <nl>          put_bits(pb, rmn_bits, get_bits(gb, rmn_bits));
@@ -651,7 +651,8 @@ static void frame_thread_free(AVCodecContext *avctx, int thread_count) <nl>          pthread_cond_signal(&p->input_cond); <nl>          pthread_mutex_unlock(&p->mutex); <nl>   <nl> -        pthread_join(p->thread, NULL); <nl> +        if (p->thread) <nl> +            pthread_join(p->thread, NULL); <nl>   <nl>          if (codec->close) <nl>              codec->close(p->avctx);
@@ -555,16 +555,18 @@ void ff_qsv_decode_reset(AVCodecContext *avctx, QSVContext *q) <nl>      } <nl>   <nl>      /* Reset output surfaces */ <nl> -    av_fifo_reset(q->async_fifo); <nl> +    if (q->async_fifo) <nl> +        av_fifo_reset(q->async_fifo); <nl>   <nl>      /* Reset input packets fifo */ <nl> -    while (av_fifo_size(q->pkt_fifo)) { <nl> +    while (q->pkt_fifo && av_fifo_size(q->pkt_fifo)) { <nl>          av_fifo_generic_read(q->pkt_fifo, &pkt, sizeof(pkt), NULL); <nl>          av_packet_unref(&pkt); <nl>      } <nl>   <nl>      /* Reset input bitstream fifo */ <nl> -    av_fifo_reset(q->input_fifo); <nl> +    if (q->input_fifo) <nl> +        av_fifo_reset(q->input_fifo); <nl>  } <nl>   <nl>  int ff_qsv_decode_close(QSVContext *q)
@@ -269,6 +269,8 @@ static int img_read_packet(AVFormatContext *s1, AVPacket *pkt) <nl>              return AVERROR(EIO); <nl>          for(i=0; i<3; i++){ <nl>              if (url_fopen(&f[i], filename, URL_RDONLY) < 0) { <nl> +                if(i==1) <nl> +                    break; <nl>                  av_log(s1, AV_LOG_ERROR, "Could not open file : %s\n",filename); <nl>                  return AVERROR(EIO); <nl>              }
@@ -1015,6 +1015,9 @@ static int mxf_read_close(AVFormatContext *s) <nl>          case MaterialPackage: <nl>              av_freep(&((MXFPackage *)mxf->metadata_sets[i])->tracks_refs); <nl>              break; <nl> +        case Track: <nl> +            mxf->metadata_sets[i] = NULL; /* will be freed later */ <nl> +            break; <nl>          default: <nl>              break; <nl>          }
@@ -387,11 +387,6 @@ static int avi_read_header(AVFormatContext *s, AVFormatParameters *ap) <nl>          tag = avio_rl32(pb); <nl>          size = avio_rl32(pb); <nl>   <nl> -        if(size > avi->fsize){ <nl> -            av_log(s, AV_LOG_ERROR, "chunk size is too big during header parsing\n"); <nl> -            goto fail; <nl> -        } <nl> - <nl>          print_tag("tag", tag, size); <nl>   <nl>          switch(tag) { <nl> @@ -605,7 +600,7 @@ static int avi_read_header(AVFormatContext *s, AVFormatParameters *ap) <nl>                          break; <nl>                      } <nl>   <nl> -                    if(size > 10*4 && size<(1<<30)){ <nl> +                    if(size > 10*4 && size<(1<<30) && size < avi->fsize){ <nl>                          st->codec->extradata_size= size - 10*4; <nl>                          st->codec->extradata= av_malloc(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE); <nl>                          if (!st->codec->extradata) {
@@ -548,6 +548,8 @@ static int amv_encode_picture(AVCodecContext *avctx, AVPacket *pkt, <nl>          return -1; <nl>   <nl>      pic = av_frame_alloc(); <nl> +    if (!pic) <nl> +        return AVERROR(ENOMEM); <nl>      av_frame_ref(pic, pic_arg); <nl>      //picture should be flipped upside-down <nl>      for(i=0; i < 3; i++) {
@@ -39,7 +39,7 @@ static int decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPac <nl>      const uint8_t *buf = avpkt->data; <nl>      const uint8_t *buf_end = buf + avpkt->size; <nl>      KgvContext * const c = avctx->priv_data; <nl> -    int offsets[7]; <nl> +    int offsets[8]; <nl>      uint16_t *out, *prev; <nl>      int outcnt = 0, maxcnt; <nl>      int w, h, i; <nl> @@ -69,7 +69,7 @@ static int decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPac <nl>          return -1; <nl>      c->prev = prev; <nl>   <nl> -    for (i = 0; i < 7; i++) <nl> +    for (i = 0; i < 8; i++) <nl>          offsets[i] = -1; <nl>   <nl>      while (outcnt < maxcnt && buf_end - 2 > buf) {
@@ -382,7 +382,7 @@ static int mpegps_read_packet(AVFormatContext *s, <nl>      MpegDemuxContext *m = s->priv_data; <nl>      AVStream *st; <nl>      int len, startcode, i, es_type, ret; <nl> -    int lpcm_header_len; <nl> +    int lpcm_header_len = -1; //Init to supress warning <nl>      int request_probe= 0; <nl>      enum AVCodecID codec_id = AV_CODEC_ID_NONE; <nl>      enum AVMediaType type;
@@ -42,6 +42,7 @@ <nl>  #endif <nl>   <nl>  typedef struct UDPContext { <nl> +    const AVClass *class; <nl>      int udp_fd; <nl>      int ttl; <nl>      int buffer_size; <nl> @@ -293,7 +294,7 @@ static int udp_socket_create(UDPContext *s, struct sockaddr_storage *addr, <nl>   <nl>      if (((struct sockaddr *) &s->dest_addr)->sa_family) <nl>          family = ((struct sockaddr *) &s->dest_addr)->sa_family; <nl> -    res0 = udp_resolve_host(localaddr[0] ? localaddr : NULL, s->local_port, <nl> +    res0 = udp_resolve_host((localaddr && localaddr[0]) ? localaddr : NULL, s->local_port, <nl>                              SOCK_DGRAM, family, AI_PASSIVE); <nl>      if (res0 == 0) <nl>          goto fail;
@@ -87,6 +87,12 @@ static int gsm_decode_frame(AVCodecContext *avctx, void *data, <nl>      return avctx->block_align; <nl>  } <nl>   <nl> +static void gsm_flush(AVCodecContext *avctx) <nl> +{ <nl> +    GSMContext *s = avctx->priv_data; <nl> +    memset(s, 0, sizeof(*s)); <nl> +} <nl> + <nl>  AVCodec ff_gsm_decoder = { <nl>      .name           = "gsm", <nl>      .type           = AVMEDIA_TYPE_AUDIO, <nl> @@ -94,6 +100,7 @@ AVCodec ff_gsm_decoder = { <nl>      .priv_data_size = sizeof(GSMContext), <nl>      .init           = gsm_init, <nl>      .decode         = gsm_decode_frame, <nl> +    .flush          = gsm_flush, <nl>      .long_name = NULL_IF_CONFIG_SMALL("GSM"), <nl>  }; <nl>   <nl> @@ -104,5 +111,6 @@ AVCodec ff_gsm_ms_decoder = { <nl>      .priv_data_size = sizeof(GSMContext), <nl>      .init           = gsm_init, <nl>      .decode         = gsm_decode_frame, <nl> +    .flush          = gsm_flush, <nl>      .long_name = NULL_IF_CONFIG_SMALL("GSM Microsoft variant"), <nl>  };
@@ -365,7 +365,7 @@ static int get_qcx(J2kDecoderContext *s, int n, J2kQuantStyle *q) <nl>   <nl>      if (q->quantsty == J2K_QSTY_NONE){ <nl>          n -= 3; <nl> -        if (s->buf_end - s->buf < n) <nl> +        if (s->buf_end - s->buf < n || 32*3 < n) <nl>              return AVERROR(EINVAL); <nl>          for (i = 0; i < n; i++) <nl>              q->expn[i] = bytestream_get_byte(&s->buf) >> 3; <nl> @@ -382,7 +382,7 @@ static int get_qcx(J2kDecoderContext *s, int n, J2kQuantStyle *q) <nl>          } <nl>      } else{ <nl>          n = (n - 3) >> 1; <nl> -        if (s->buf_end - s->buf < n) <nl> +        if (s->buf_end - s->buf < n || 32*3 < n) <nl>              return AVERROR(EINVAL); <nl>          for (i = 0; i < n; i++){ <nl>              x = bytestream_get_be16(&s->buf);
@@ -509,16 +509,16 @@ static inline void codeblock(DiracContext *s, SubBand *b, <nl>      } <nl>   <nl>      if (s->codeblock_mode && !(s->old_delta_quant && blockcnt_one)) { <nl> -        int quant = b->quant; <nl> +        int quant; <nl>          if (is_arith) <nl> -            quant += dirac_get_arith_int(c, CTX_DELTA_Q_F, CTX_DELTA_Q_DATA); <nl> +            quant = dirac_get_arith_int(c, CTX_DELTA_Q_F, CTX_DELTA_Q_DATA); <nl>          else <nl> -            quant += dirac_get_se_golomb(gb); <nl> -        if (quant < 0) { <nl> +            quant = dirac_get_se_golomb(gb); <nl> +        if (quant > INT_MAX - b->quant || b->quant + quant < 0) { <nl>              av_log(s->avctx, AV_LOG_ERROR, "Invalid quant\n"); <nl>              return; <nl>          } <nl> -        b->quant = quant; <nl> +        b->quant += quant; <nl>      } <nl>   <nl>      if (b->quant > (DIRAC_MAX_QUANT_INDEX - 1)) {
@@ -76,6 +76,7 @@ try to unroll inner for(x=0 ... loop to avoid these damn if(x ... checks <nl>  #include "config.h" <nl>  #include "libavutil/avutil.h" <nl>  #include "libavutil/avassert.h" <nl> +#include "libavutil/intreadwrite.h" <nl>  #include <inttypes.h> <nl>  #include <stdio.h> <nl>  #include <stdlib.h> <nl> @@ -997,7 +998,7 @@ void  pp_postprocess(const uint8_t * src[3], const int srcStride[3], <nl>              int i; <nl>              const int count= FFMAX(mbHeight * QPStride, mbWidth); <nl>              for(i=0; i<(count>>2); i++){ <nl> -                ((uint32_t*)c->nonBQPTable)[i] = ((const uint32_t*)QP_store)[i] & 0x3F3F3F3F; <nl> +                AV_WN32(c->nonBQPTable + (i<<2), AV_RN32(QP_store + (i<<2)) & 0x3F3F3F3F); <nl>              } <nl>              for(i<<=2; i<count; i++){ <nl>                  c->nonBQPTable[i] = QP_store[i] & 0x3F;
@@ -2043,8 +2043,11 @@ static int matroska_parse_rm_audio(MatroskaDemuxContext *matroska, <nl>      } <nl>   <nl>      while (track->audio.pkt_cnt) { <nl> -        AVPacket *pkt = av_mallocz(sizeof(AVPacket)); <nl> -        av_new_packet(pkt, a); <nl> +        AVPacket *pkt = NULL; <nl> +        if (!(pkt = av_mallocz(sizeof(AVPacket))) || av_new_packet(pkt, a) < 0){ <nl> +            av_free(pkt); <nl> +            return AVERROR(ENOMEM); <nl> +        } <nl>          memcpy(pkt->data, track->audio.buf <nl>                 + a * (h*w / a - track->audio.pkt_cnt--), a); <nl>          pkt->pts = track->audio.buf_timecode;
@@ -262,7 +262,7 @@ static void decode_pitch_lag_high(int *lag_int, int *lag_frac, int pitch_index, <nl>              *lag_frac = pitch_index - (*lag_int << 2) + 136; <nl>          } else if (pitch_index < 440) { <nl>              *lag_int  = (pitch_index + 257 - 376) >> 1; <nl> -            *lag_frac = (pitch_index - (*lag_int << 1) + 256 - 376) << 1; <nl> +            *lag_frac = (pitch_index - (*lag_int << 1) + 256 - 376) * 2; <nl>              /* the actual resolution is 1/2 but expressed as 1/4 */ <nl>          } else { <nl>              *lag_int  = pitch_index - 280;
@@ -711,7 +711,7 @@ typedef struct DynBuffer { <nl>  static int dyn_buf_write(void *opaque, uint8_t *buf, int buf_size) <nl>  { <nl>      DynBuffer *d = opaque; <nl> -    int new_size, new_allocated_size; <nl> +    unsigned new_size, new_allocated_size; <nl>   <nl>      /* reallocate buffer if needed */ <nl>      new_size = d->pos + buf_size;
@@ -3218,9 +3218,12 @@ static int mov_read_trun(MOVContext *c, AVIOContext *pb, MOVAtom atom) <nl>                                    MOV_FRAG_SAMPLE_FLAG_DEPENDS_YES)); <nl>          if (keyframe) <nl>              distance = 0; <nl> -        av_add_index_entry(st, offset, INT64_MAX/2, sample_size, distance, <nl> -                           keyframe ? AVINDEX_KEYFRAME : 0); <nl> -        st->index_entries[st->nb_index_entries - 1].timestamp = cts; <nl> +        err = av_add_index_entry(st, offset, INT64_MAX/2, sample_size, distance, <nl> +                                 keyframe ? AVINDEX_KEYFRAME : 0); <nl> +        if (err < 0) { <nl> +            av_log(c->fc, AV_LOG_ERROR, "Failed to add index entry\n"); <nl> +        } else <nl> +            st->index_entries[st->nb_index_entries - 1].timestamp = cts; <nl>          av_dlog(c->fc, "AVIndex stream %d, sample %d, offset %"PRIx64", cts %"PRId64", " <nl>                  "size %d, distance %d, keyframe %d\n", st->index, sc->sample_count+i, <nl>                  offset, cts, sample_size, distance, keyframe);
@@ -3169,8 +3169,9 @@ static int read_thread(void *arg) <nl>          stream_component_close(is, is->video_stream); <nl>      if (is->subtitle_stream >= 0) <nl>          stream_component_close(is, is->subtitle_stream); <nl> -    if (is->ic) { <nl> -        avformat_close_input(&is->ic); <nl> +    if (ic) { <nl> +        avformat_close_input(&ic); <nl> +        is->ic = NULL; <nl>      } <nl>   <nl>      if (ret != 0) {
@@ -115,8 +115,6 @@ static int config_props(AVFilterLink *outlink) <nl>      av_log(ctx, AV_LOG_INFO, "w:%d h:%d fmt:%s\n", <nl>             outlink->w, outlink->h, avcodec_get_pix_fmt_name(outlink->format)); <nl>   <nl> -    avcodec_get_chroma_sub_sample(outlink->format, &scale->hsub, &scale->vsub); <nl> - <nl>      scale->input_is_pal = inlink->format == PIX_FMT_PAL8      || <nl>                            inlink->format == PIX_FMT_BGR4_BYTE || <nl>                            inlink->format == PIX_FMT_RGB4_BYTE || <nl> @@ -132,6 +130,8 @@ static void start_frame(AVFilterLink *link, AVFilterPicRef *picref) <nl>      AVFilterLink *outlink = link->dst->outputs[0]; <nl>      AVFilterPicRef *outpicref; <nl>   <nl> +    avcodec_get_chroma_sub_sample(link->format, &scale->hsub, &scale->vsub); <nl> + <nl>      outpicref = avfilter_get_video_buffer(outlink, AV_PERM_WRITE, outlink->w, outlink->h); <nl>      outpicref->pts = picref->pts; <nl>      outlink->outpic = outpicref;
@@ -36,6 +36,9 @@ static int encode_init(AVCodecContext * avctx){ <nl>      if(avctx->channels > MAX_CHANNELS) <nl>          return -1; <nl>   <nl> +    if(avctx->bit_rate < 24*1000) <nl> +        return -1; <nl> + <nl>      /* extract flag infos */ <nl>      flags1 = 0; <nl>      flags2 = 1;
@@ -493,7 +493,7 @@ static inline int mjpeg_decode_dc(MJpegDecodeContext *s, int dc_index) <nl>  { <nl>      int code; <nl>      code = get_vlc2(&s->gb, s->vlcs[0][dc_index].table, 9, 2); <nl> -    if (code < 0) { <nl> +    if (code < 0 || code > 16) { <nl>          av_log(s->avctx, AV_LOG_WARNING, <nl>                 "mjpeg_decode_dc: bad vlc: %d:%d (%p)\n", <nl>                 0, dc_index, &s->vlcs[0][dc_index]);
@@ -148,8 +148,8 @@ static int twolame_encode_frame(AVCodecContext *avctx, AVPacket *avpkt, <nl>      if (ret < 0)  // twolame error <nl>          return AVERROR_UNKNOWN; <nl>   <nl> -    avpkt->duration = ff_samples_to_time_base(avctx, frame->nb_samples); <nl>      if (frame) { <nl> +        avpkt->duration = ff_samples_to_time_base(avctx, frame->nb_samples); <nl>          if (frame->pts != AV_NOPTS_VALUE) <nl>              avpkt->pts = frame->pts - ff_samples_to_time_base(avctx, avctx->initial_padding); <nl>      } else {
@@ -90,8 +90,11 @@ static int query_formats(AVFilterContext *ctx) <nl>      static const enum AVPixelFormat out_fmts[] = {AV_PIX_FMT_RGB32, AV_PIX_FMT_NONE}; <nl>      AVFilterFormats *in  = ff_make_format_list(in_fmts); <nl>      AVFilterFormats *out = ff_make_format_list(out_fmts); <nl> -    if (!in || !out) <nl> +    if (!in || !out) { <nl> +        av_freep(&in); <nl> +        av_freep(&out); <nl>          return AVERROR(ENOMEM); <nl> +    } <nl>      ff_formats_ref(in,  &ctx->inputs[0]->out_formats); <nl>      ff_formats_ref(out, &ctx->outputs[0]->in_formats); <nl>      return 0;
@@ -1822,7 +1822,7 @@ static int read_packet(AVFormatContext *s, uint8_t *buf, int raw_packet_size) <nl>  static int handle_packets(MpegTSContext *ts, int nb_packets) <nl>  { <nl>      AVFormatContext *s = ts->stream; <nl> -    uint8_t packet[TS_PACKET_SIZE]; <nl> +    uint8_t packet[TS_PACKET_SIZE + FF_INPUT_BUFFER_PADDING_SIZE]; <nl>      int packet_num, ret = 0; <nl>   <nl>      if (avio_tell(s->pb) != ts->last_pos) {
@@ -41,8 +41,11 @@ static int ass_decode_frame(AVCodecContext *avctx, void *data, int *got_sub_ptr, <nl>      int len, size = avpkt->size; <nl>   <nl>      while (size > 0) { <nl> +        int duration; <nl>          ASSDialog *dialog = ff_ass_split_dialog(avctx->priv_data, ptr, 0, NULL); <nl> -        int duration = dialog->end - dialog->start; <nl> +        if (!dialog) <nl> +            return AVERROR_INVALIDDATA; <nl> +        duration = dialog->end - dialog->start; <nl>          len = ff_ass_add_rect(data, ptr, 0, duration, 1); <nl>          if (len < 0) <nl>              return len;
@@ -279,6 +279,9 @@ static int concat_read_packet(AVFormatContext *avf, AVPacket *pkt) <nl>              (ret = open_next_file(avf)) < 0) <nl>              break; <nl>      } <nl> +    if (ret < 0) <nl> +        return ret; <nl> + <nl>      delta = av_rescale_q(cat->cur_file->start_time - cat->avf->start_time, <nl>                           AV_TIME_BASE_Q, <nl>                           cat->avf->streams[pkt->stream_index]->time_base);
@@ -504,7 +504,8 @@ static int decompress_p(AVCodecContext *avctx, <nl>                  mvx -= 256; <nl>                  mvy -= 256; <nl>   <nl> -                if (by + mvy + sy1 < 0 || bx + mvx + sx1 < 0) <nl> +                if (by + mvy + sy1 < 0 || bx + mvx + sx1 < 0 || <nl> +                    by + mvy + sy1 >= avctx->height || bx + mvx + sx1 >= avctx->width) <nl>                      return AVERROR_INVALIDDATA; <nl>   <nl>                  for (i = 0; i < sy2 - sy1 && (by + sy1 + i) < avctx->height; i++) {
@@ -3876,7 +3876,8 @@ again: <nl>   <nl>                  if (avctx->bits_per_raw_sample != h->sps.bit_depth_luma || <nl>                      h->cur_chroma_format_idc   != h->sps.chroma_format_idc) { <nl> -                    if (s->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU <nl> +                    if (s->avctx->codec && <nl> +                        s->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU <nl>                          && (h->sps.bit_depth_luma != 8 || <nl>                              h->sps.chroma_format_idc > 1)) { <nl>                          av_log(avctx, AV_LOG_ERROR,
@@ -401,6 +401,8 @@ static void vp56_decode_mb(VP56Context *s, int row, int col, int is_alpha) <nl>   <nl>      frame_current = s->framep[VP56_FRAME_CURRENT]; <nl>      frame_ref = s->framep[ref_frame]; <nl> +    if (mb_type != VP56_MB_INTRA && !frame_ref->data[0]) <nl> +        return; <nl>   <nl>      ab = 6*is_alpha; <nl>      b_max = 6 - 2*is_alpha;
@@ -2817,11 +2817,10 @@ reconnect: <nl>      } <nl>   <nl>      if (rt->is_input) { <nl> -        int err; <nl>          // generate FLV header for demuxer <nl>          rt->flv_size = 13; <nl> -        if ((err = av_reallocp(&rt->flv_data, rt->flv_size)) < 0) <nl> -            return err; <nl> +        if ((ret = av_reallocp(&rt->flv_data, rt->flv_size)) < 0) <nl> +            goto fail; <nl>          rt->flv_off  = 0; <nl>          memcpy(rt->flv_data, "FLV\1\0\0\0\0\011\0\0\0\0", rt->flv_size); <nl>   <nl> @@ -2832,7 +2831,7 @@ reconnect: <nl>          // audio or video packet arrives. <nl>          while (!rt->has_audio && !rt->has_video && !rt->received_metadata) { <nl>              if ((ret = get_packet(s, 0)) < 0) <nl> -               return ret; <nl> +               goto fail; <nl>          } <nl>   <nl>          // Either after we have read the metadata or (if there is none) the
@@ -302,6 +302,8 @@ static inline int get_ur_golomb_jpegls(GetBitContext *gb, int k, int limit, int <nl>      }else{ <nl>          int i; <nl>          for(i=0; SHOW_UBITS(re, gb, 1) == 0; i++){ <nl> +            if (get_bits_left(gb)<=0) <nl> +                return -1; <nl>              LAST_SKIP_BITS(re, gb, 1); <nl>              UPDATE_CACHE(re, gb); <nl>          }
@@ -166,6 +166,7 @@ static int config_input(AVFilterLink *inlink) <nl>      int hsub = desc->log2_chroma_w; <nl>      int vsub = desc->log2_chroma_h; <nl>   <nl> +    av_freep(&s->buf); <nl>      s->buf = av_mallocz((FFALIGN(inlink->w, 16) * (s->radius + 1) / 2 + 32) * sizeof(uint16_t)); <nl>      if (!s->buf) <nl>          return AVERROR(ENOMEM);
@@ -100,10 +100,12 @@ typedef struct DiracParseUnit { <nl>  static int unpack_parse_unit(DiracParseUnit *pu, DiracParseContext *pc, <nl>                               int offset) <nl>  { <nl> -    uint8_t *start = pc->buffer + offset; <nl> -    uint8_t *end   = pc->buffer + pc->index; <nl> -    if (start < pc->buffer || (start + 13 > end)) <nl> +    int8_t *start; <nl> + <nl> +    if (offset < 0 || pc->index - 13 < offset) <nl>          return 0; <nl> + <nl> +    start = pc->buffer + offset; <nl>      pu->pu_type = start[4]; <nl>   <nl>      pu->next_pu_offset = AV_RB32(start + 5);
@@ -488,7 +488,7 @@ static void residual_interp(int16_t *buf, int16_t *out, int lag, <nl>                            (FRAME_LEN - lag) * sizeof(*out)); <nl>      } else {  /* Unvoiced */ <nl>          for (i = 0; i < FRAME_LEN; i++) { <nl> -            *rseed = *rseed * 521 + 259; <nl> +            *rseed = (int16_t)(*rseed * 521 + 259); <nl>              out[i] = gain * *rseed >> 15; <nl>          } <nl>          memset(buf, 0, (FRAME_LEN + PITCH_MAX) * sizeof(*buf));
@@ -106,7 +106,7 @@ static char *value_string(char *buf, int buf_size, struct unit_value uv) <nl>          const char *prefix_string = ""; <nl>          int l; <nl>   <nl> -        if (use_value_prefix) { <nl> +        if (use_value_prefix && vald > 1) { <nl>              long long int index; <nl>   <nl>              if (uv.unit == unit_byte_str && use_byte_value_binary_prefix) {
@@ -67,7 +67,7 @@ typedef struct Context { <nl>   <nl>  static int cmp(const void *key, const void *node) <nl>  { <nl> -    return (*(const int64_t *) key) - ((const CacheEntry *) node)->logical_pos; <nl> +    return FFDIFFSIGN(*(const int64_t *)key, ((const CacheEntry *) node)->logical_pos); <nl>  } <nl>   <nl>  static int cache_open(URLContext *h, const char *arg, int flags, AVDictionary **options)
@@ -7505,7 +7505,7 @@ static int decode_nal_units(H264Context *h, const uint8_t *buf, int buf_size){ <nl>              nalsize = 0; <nl>              for(i = 0; i < h->nal_length_size; i++) <nl>                  nalsize = (nalsize << 8) | buf[buf_index++]; <nl> -            if(nalsize <= 1 || (nalsize+buf_index > buf_size)){ <nl> +            if(nalsize <= 1 || nalsize > buf_size - buf_index){ <nl>                  if(nalsize == 1){ <nl>                      buf_index++; <nl>                      continue;
@@ -117,7 +117,8 @@ static int mpc_read_packet(AVFormatContext *s, AVPacket *pkt) <nl>  { <nl>      MPCContext *c = s->priv_data; <nl>      int ret, size, size2, curbits, cur = c->curframe; <nl> -    int64_t tmp, pos; <nl> +    unsigned tmp; <nl> +    int64_t pos; <nl>   <nl>      if (c->curframe >= c->fcount && c->fcount) <nl>          return -1; <nl> @@ -134,8 +135,7 @@ static int mpc_read_packet(AVFormatContext *s, AVPacket *pkt) <nl>      if(curbits <= 12){ <nl>          size2 = (tmp >> (12 - curbits)) & 0xFFFFF; <nl>      }else{ <nl> -        tmp = (tmp << 32) | avio_rl32(s->pb); <nl> -        size2 = (tmp >> (44 - curbits)) & 0xFFFFF; <nl> +        size2 = (tmp << (curbits - 12) | avio_rl32(s->pb) >> (44 - curbits)) & 0xFFFFF; <nl>      } <nl>      curbits += 20; <nl>      avio_seek(s->pb, pos, SEEK_SET);
@@ -70,6 +70,7 @@ static int pcm_dvd_parse_header(AVCodecContext *avctx, const uint8_t *header) <nl>      /* early exit if the header didn't change apart from the frame number */ <nl>      if (s->last_header == header_int) <nl>          return 0; <nl> +    s->last_header = -1; <nl>   <nl>      if (avctx->debug & FF_DEBUG_PICT_INFO) <nl>          av_dlog(avctx, "pcm_dvd_parse_header: header = %02x%02x%02x\n",
@@ -88,11 +88,10 @@ static int rtp_mpegts_write_header(AVFormatContext *s) <nl>      st->time_base.num   = 1; <nl>      st->time_base.den   = 90000; <nl>      st->codec->codec_id = AV_CODEC_ID_MPEG2TS; <nl> -    chain->rtp_ctx = rtp_ctx; <nl>      rtp_ctx->pb = s->pb; <nl>      if ((ret = avformat_write_header(rtp_ctx, NULL)) < 0) <nl>          goto fail; <nl> -    rtp_ctx = NULL; <nl> +    chain->rtp_ctx = rtp_ctx; <nl>   <nl>      return 0; <nl>  
@@ -1237,8 +1237,12 @@ static av_cold int png_dec_init(AVCodecContext *avctx) <nl>      s->previous_picture.f = av_frame_alloc(); <nl>      s->last_picture.f = av_frame_alloc(); <nl>      s->picture.f = av_frame_alloc(); <nl> -    if (!s->previous_picture.f || !s->last_picture.f || !s->picture.f) <nl> +    if (!s->previous_picture.f || !s->last_picture.f || !s->picture.f) { <nl> +        av_frame_free(&s->previous_picture.f); <nl> +        av_frame_free(&s->last_picture.f); <nl> +        av_frame_free(&s->picture.f); <nl>          return AVERROR(ENOMEM); <nl> +    } <nl>   <nl>      if (!avctx->internal->is_copy) { <nl>          avctx->internal->allocate_progress = 1;
@@ -2543,7 +2543,7 @@ static void search_for_ms_mips(AACEncContext *s, ChannelElement *cpe) <nl>  #endif /* HAVE_INLINE_ASM */ <nl>   <nl>  void ff_aac_coder_init_mips(AACEncContext *c) { <nl> -#if HAVE_INLINE_ASM <nl> +#if 0 // HAVE_INLINE_ASM <nl>      AACCoefficientsEncoder *e = c->coder; <nl>      int option = c->options.aac_coder; <nl>  
@@ -693,12 +693,12 @@ av_cold void ff_dsputil_init_x86(DSPContext *c, AVCodecContext *avctx) <nl>                  c->idct                  = ff_simple_idct_mmx; <nl>                  c->idct_permutation_type = FF_SIMPLE_IDCT_PERM; <nl>              } else if (idct_algo == FF_IDCT_XVIDMMX) { <nl> -                if (cpu_flags & AV_CPU_FLAG_SSE2) { <nl> +                if (X86_SSE2(cpu_flags)) { <nl>                      c->idct_put              = ff_idct_xvid_sse2_put; <nl>                      c->idct_add              = ff_idct_xvid_sse2_add; <nl>                      c->idct                  = ff_idct_xvid_sse2; <nl>                      c->idct_permutation_type = FF_SSE2_IDCT_PERM; <nl> -                } else if (cpu_flags & AV_CPU_FLAG_MMXEXT) { <nl> +                } else if (X86_MMXEXT(cpu_flags)) { <nl>                      c->idct_put              = ff_idct_xvid_mmxext_put; <nl>                      c->idct_add              = ff_idct_xvid_mmxext_add; <nl>                      c->idct                  = ff_idct_xvid_mmxext;
@@ -955,7 +955,8 @@ static int decode_subframe(WmallDecodeCtx *s) <nl>                  else <nl>                      use_normal_update_speed(s, i); <nl>                  revert_cdlms(s, i, 0, subframe_len); <nl> -            } <nl> +            } else <nl> +                memset(s->channel_residues, 0, sizeof(s->channel_residues)); <nl>      } <nl>      if (s->do_mclms) <nl>          revert_mclms(s, subframe_len);
@@ -3185,6 +3185,11 @@ static int decode_header(SnowContext *s){ <nl>      s->mv_scale= get_symbol(&s->c, s->header_state, 0); <nl>      s->qbias= get_symbol(&s->c, s->header_state, 1); <nl>      s->block_max_depth= get_symbol(&s->c, s->header_state, 0); <nl> +    if(s->block_max_depth > 1){ <nl> +        av_log(s->avctx, AV_LOG_ERROR, "block_max_depth= %d is too large", s->block_max_depth); <nl> +        s->block_max_depth= 0; <nl> +        return -1; <nl> +    } <nl>   <nl>      return 0; <nl>  }
@@ -2540,6 +2540,8 @@ static int alloc_tables(H264Context *h){ <nl>          } <nl>      } <nl>   <nl> +    s->obmc_scratchpad = NULL; <nl> + <nl>      return 0; <nl>  fail: <nl>      free_tables(h);
@@ -2342,11 +2342,11 @@ static void update_stream_timings(AVFormatContext *ic) <nl>                      start_time_text = start_time1; <nl>              } else <nl>                  start_time = FFMIN(start_time, start_time1); <nl> -            end_time1   = AV_NOPTS_VALUE; <nl> -            if (st->duration != AV_NOPTS_VALUE) { <nl> -                end_time1 = start_time1 + <nl> -                            av_rescale_q(st->duration, st->time_base, <nl> -                                         AV_TIME_BASE_Q); <nl> +            end_time1 = av_rescale_q_rnd(st->duration, st->time_base, <nl> +                                         AV_TIME_BASE_Q, <nl> +                                         AV_ROUND_NEAR_INF|AV_ROUND_PASS_MINMAX); <nl> +            if (end_time1 != AV_NOPTS_VALUE) { <nl> +                end_time1 += start_time1; <nl>                  end_time = FFMAX(end_time, end_time1); <nl>              } <nl>              for (p = NULL; (p = av_find_program_from_stream(ic, p, i)); ) {
@@ -443,7 +443,7 @@ unsigned int vf_match_csp(vf_instance_t** vfp,const unsigned int* list,unsigned <nl>  } <nl>   <nl>  mp_image_t* vf_get_image(vf_instance_t* vf, unsigned int outfmt, int mp_imgtype, int mp_imgflag, int w, int h){ <nl> -    MPContext *m= ((uint8_t*)vf) - offsetof(MPContext, next_vf); <nl> +    MPContext *m= (MPContext*)(((uint8_t*)vf) - offsetof(MPContext, next_vf)); <nl>    mp_image_t* mpi=NULL; <nl>    int w2; <nl>    int number = mp_imgtype >> 16; <nl> @@ -615,7 +615,7 @@ int vf_next_put_image(struct vf_instance *vf,mp_image_t *mpi, double pts){ <nl>          goto fail; <nl>   <nl>      picref->buf = pic; <nl> -    picref->buf->please_use_av_free= av_free; <nl> +    picref->buf->please_use_av_free= (void*)av_free; <nl>      if (!(picref->video = av_mallocz(sizeof(AVFilterBufferRefVideoProps)))) <nl>          goto fail; <nl>  
@@ -2246,7 +2246,6 @@ static int transcode(OutputFile *output_files, <nl>          int64_t ipts_min; <nl>          double opts_min; <nl>   <nl> -    redo: <nl>          ipts_min = INT64_MAX; <nl>          opts_min= 1e100; <nl>   <nl> @@ -2361,7 +2360,7 @@ static int transcode(OutputFile *output_files, <nl>              if (exit_on_error) <nl>                  exit_program(1); <nl>              av_free_packet(&pkt); <nl> -            goto redo; <nl> +            continue; <nl>          } <nl>   <nl>      discard_packet:
@@ -629,6 +629,8 @@ int ff_vc1_parse_frame_header(VC1Context *v, GetBitContext* gb) <nl>  { <nl>      int pqindex, lowquant, status; <nl>   <nl> +    v->field_mode = 0; <nl> +    v->fcm = 0; <nl>      if (v->finterpflag) <nl>          v->interpfrm = get_bits1(gb); <nl>      if (!v->s.avctx->codec)
@@ -462,11 +462,11 @@ static void destroy_buffers(SANMVideoContext *ctx) <nl>   <nl>  static av_cold int init_buffers(SANMVideoContext *ctx) <nl>  { <nl> -    av_fast_padded_malloc(&ctx->frm0, &ctx->frm0_size, ctx->buf_size); <nl> -    av_fast_padded_malloc(&ctx->frm1, &ctx->frm1_size, ctx->buf_size); <nl> -    av_fast_padded_malloc(&ctx->frm2, &ctx->frm2_size, ctx->buf_size); <nl> +    av_fast_padded_mallocz(&ctx->frm0, &ctx->frm0_size, ctx->buf_size); <nl> +    av_fast_padded_mallocz(&ctx->frm1, &ctx->frm1_size, ctx->buf_size); <nl> +    av_fast_padded_mallocz(&ctx->frm2, &ctx->frm2_size, ctx->buf_size); <nl>      if (!ctx->version) <nl> -        av_fast_padded_malloc(&ctx->stored_frame, <nl> +        av_fast_padded_mallocz(&ctx->stored_frame, <nl>                                &ctx->stored_frame_size, ctx->buf_size); <nl>   <nl>      if (!ctx->frm0 || !ctx->frm1 || !ctx->frm2 ||
@@ -25,7 +25,7 @@ <nl>  #include <stddef.h> <nl>  #include <stdint.h> <nl>   <nl> -typedef int16_t dwtcoef; <nl> +typedef int32_t dwtcoef; <nl>   <nl>  enum VC2TransformType { <nl>      VC2_TRANSFORM_9_7    = 0,   /* Deslauriers-Dubuc (9,7)  */
@@ -2813,6 +2813,8 @@ static int wavpack_encode_block(WavPackEncodeContext *s, <nl>      block_size = bytestream2_tell_p(&pb); <nl>      AV_WL32(out + 4, block_size - 8); <nl>   <nl> +    av_assert0(put_bits_left(&s->pb) > 0); <nl> + <nl>      return block_size; <nl>  } <nl>  
@@ -317,9 +317,12 @@ static int64_t mkv_write_seekhead(AVIOContext *pb, mkv_seekhead *seekhead) <nl>   <nl>      currentpos = avio_tell(pb); <nl>   <nl> -    if (seekhead->reserved_size > 0) <nl> -        if (avio_seek(pb, seekhead->filepos, SEEK_SET) < 0) <nl> -            return -1; <nl> +    if (seekhead->reserved_size > 0) { <nl> +        if (avio_seek(pb, seekhead->filepos, SEEK_SET) < 0) { <nl> +            currentpos = -1; <nl> +            goto fail; <nl> +        } <nl> +    } <nl>   <nl>      metaseek = start_ebml_master(pb, MATROSKA_ID_SEEKHEAD, seekhead->reserved_size); <nl>      for (i = 0; i < seekhead->num_entries; i++) { <nl> @@ -343,6 +346,7 @@ static int64_t mkv_write_seekhead(AVIOContext *pb, mkv_seekhead *seekhead) <nl>   <nl>          currentpos = seekhead->filepos; <nl>      } <nl> +fail: <nl>      av_free(seekhead->entries); <nl>      av_free(seekhead); <nl>  
@@ -247,7 +247,7 @@ static void check_luma_dc_wht(void) <nl>  } <nl>   <nl>  #define SRC_BUF_STRIDE 32 <nl> -#define SRC_BUF_SIZE ((size + 5) * SRC_BUF_STRIDE) <nl> +#define SRC_BUF_SIZE (((size << (size < 16)) + 5) * SRC_BUF_STRIDE) <nl>  // The mc subpixel interpolation filter needs the 2 previous pixels in either <nl>  // direction, the +1 is to make sure the actual load addresses always are <nl>  // unaligned.
@@ -620,6 +620,8 @@ null_chunk_retry: <nl>              bps = avio_r8(pb); <nl>              channels = avio_r8(pb); <nl>              samplerate = avio_rl16(pb); <nl> +            if (!channels || !samplerate) <nl> +                return AVERROR_INVALIDDATA; <nl>              asize-=4; <nl>              av_dlog(s, "NSV RAWAUDIO: bps %d, nchan %d, srate %d\n", bps, channels, samplerate); <nl>              if (fill_header) {
@@ -3636,15 +3636,18 @@ static int read_ffserver_streams(OptionsContext *o, AVFormatContext *s, const ch <nl>          AVStream *st; <nl>          OutputStream *ost; <nl>          AVCodec *codec; <nl> +        AVCodecContext *avctx; <nl>   <nl>          codec = avcodec_find_encoder(ic->streams[i]->codec->codec_id); <nl>          ost   = new_output_stream(o, s, codec->type); <nl>          st    = ost->st; <nl> +        avctx = st->codec; <nl>   <nl>          // FIXME: a more elegant solution is needed <nl>          memcpy(st, ic->streams[i], sizeof(AVStream)); <nl>          st->info = av_malloc(sizeof(*st->info)); <nl>          memcpy(st->info, ic->streams[i]->info, sizeof(*st->info)); <nl> +        st->codec= avctx; <nl>          avcodec_copy_context(st->codec, ic->streams[i]->codec); <nl>   <nl>          if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO && !ost->stream_copy)
@@ -207,14 +207,16 @@ static int ra288_decode_frame(AVCodecContext * avctx, void *data, <nl>          return AVERROR_INVALIDDATA; <nl>      } <nl>   <nl> +    ret = init_get_bits8(&gb, buf, avctx->block_align); <nl> +    if (ret < 0) <nl> +        return ret; <nl> + <nl>      /* get output buffer */ <nl>      frame->nb_samples = RA288_BLOCK_SIZE * RA288_BLOCKS_PER_FRAME; <nl>      if ((ret = ff_get_buffer(avctx, frame, 0)) < 0) <nl>          return ret; <nl>      out = (float *)frame->data[0]; <nl>   <nl> -    init_get_bits8(&gb, buf, avctx->block_align); <nl> - <nl>      for (i=0; i < RA288_BLOCKS_PER_FRAME; i++) { <nl>          float gain = amptable[get_bits(&gb, 3)]; <nl>          int cb_coef = get_bits(&gb, 6 + (i&1));
@@ -248,6 +248,10 @@ static int mpc7_decode_frame(AVCodecContext * avctx, void *data, <nl>              if(i) t = get_vlc2(&gb, hdr_vlc.table, MPC7_HDR_BITS, 1) - 5; <nl>              if(t == 4) bands[i].res[ch] = get_bits(&gb, 4); <nl>              else bands[i].res[ch] = bands[i-1].res[ch] + t; <nl> +            if (bands[i].res[ch] < -1 || bands[i].res[ch] > 17) { <nl> +                av_log(avctx, AV_LOG_ERROR, "subband index invalid\n"); <nl> +                return AVERROR_INVALIDDATA; <nl> +            } <nl>          } <nl>   <nl>          if(bands[i].res[0] || bands[i].res[1]){
@@ -79,6 +79,7 @@ static void free_geotags(TiffContext *const s) <nl>              av_freep(&s->geotags[i].val); <nl>      } <nl>      av_freep(&s->geotags); <nl> +    s->geotag_count = 0; <nl>  } <nl>   <nl>  #define RET_GEOKEY(TYPE, array, element)\
@@ -1913,6 +1913,9 @@ static int transcode_video(InputStream *ist, AVPacket *pkt, int *got_output, int <nl>   <nl>      rate_emu_sleep(ist); <nl>   <nl> +    if (ist->st->sample_aspect_ratio.num) <nl> +        decoded_frame->sample_aspect_ratio = ist->st->sample_aspect_ratio; <nl> + <nl>      for (i = 0; i < nb_output_streams; i++) { <nl>          OutputStream *ost = &output_streams[i]; <nl>          int frame_size, resample_changed; <nl> @@ -1941,8 +1944,6 @@ static int transcode_video(InputStream *ist, AVPacket *pkt, int *got_output, int <nl>              ost->resample_pix_fmt = decoded_frame->format; <nl>          } <nl>   <nl> -        if (ist->st->sample_aspect_ratio.num) <nl> -            decoded_frame->sample_aspect_ratio = ist->st->sample_aspect_ratio; <nl>          if (ist->st->codec->codec->capabilities & CODEC_CAP_DR1) { <nl>              FrameBuffer      *buf = decoded_frame->opaque; <nl>              AVFilterBufferRef *fb = avfilter_get_video_buffer_ref_from_arrays(
@@ -124,6 +124,8 @@ X264_close(AVCodecContext *avctx) <nl>  { <nl>      X264Context *x4 = avctx->priv_data; <nl>   <nl> +    av_freep(&avctx->extradata); <nl> + <nl>      if(x4->enc) <nl>          x264_encoder_close(x4->enc); <nl>  
@@ -31,9 +31,6 @@ static int read_random(uint32_t *dst, const char *file) <nl>   <nl>      if (fd == -1) <nl>          return -1; <nl> -#if HAVE_FCNTL && defined(O_NONBLOCK) <nl> -    if (fcntl(fd, F_SETFL, fcntl(fd, F_GETFL) | O_NONBLOCK) != -1) <nl> -#endif <nl>          err = read(fd, dst, sizeof(*dst)); <nl>      close(fd); <nl>  
@@ -1902,7 +1902,10 @@ static int transcode_video(InputStream *ist, AVPacket *pkt, int *got_output, int <nl>                  *frame_sample_aspect = ist->st->sample_aspect_ratio; <nl>              decoded_frame->pts = ist->pts; <nl>   <nl> -            av_vsrc_buffer_add_frame(ost->input_video_filter, decoded_frame, AV_VSRC_BUF_FLAG_OVERWRITE); <nl> +            if((av_vsrc_buffer_add_frame(ost->input_video_filter, decoded_frame, AV_VSRC_BUF_FLAG_OVERWRITE)) < 0){ <nl> +                av_log(0, AV_LOG_FATAL, "Failed to inject frame into filter network\n"); <nl> +                exit_program(1); <nl> +            } <nl>          } <nl>      } <nl>  #endif
@@ -127,6 +127,11 @@ static int vble_decode_frame(AVCodecContext *avctx, void *data, int *data_size, <nl>      if (pic->data[0]) <nl>          avctx->release_buffer(avctx, pic); <nl>   <nl> +    if (avpkt->size < 4 || avpkt->size - 4 > INT_MAX/8) { <nl> +        av_log(avctx, AV_LOG_ERROR, "Invalid packet size\n"); <nl> +        return AVERROR_INVALIDDATA; <nl> +    } <nl> + <nl>      /* Allocate buffer */ <nl>      if (avctx->get_buffer(avctx, pic) < 0) { <nl>          av_log(avctx, AV_LOG_ERROR, "Could not allocate buffer.\n");
@@ -664,7 +664,7 @@ static int estimate_sid_gain(G723_1_Context *p) <nl>          t = p->sid_gain << shift; <nl>      else <nl>          t = p->sid_gain >> -shift; <nl> -    x = t * cng_filt[0] >> 16; <nl> +    x = av_clipl_int32(t * (int64_t)cng_filt[0] >> 16); <nl>   <nl>      if (x >= cng_bseg[2]) <nl>          return 0x3F; <nl> @@ -733,7 +733,7 @@ static void generate_noise(G723_1_Context *p) <nl>          off[i * 2 + 1] = ((t >> 1) & 1) + SUBFRAME_LEN; <nl>          t >>= 2; <nl>          for (j = 0; j < 11; j++) { <nl> -            signs[i * 11 + j] = (t & 1) * 2 - 1 << 14; <nl> +            signs[i * 11 + j] = ((t & 1) * 2 - 1)  * (1 << 14); <nl>              t >>= 1; <nl>          } <nl>      } <nl> @@ -777,7 +777,7 @@ static void generate_noise(G723_1_Context *p) <nl>          sum = 0; <nl>          if (shift < 0) { <nl>             for (j = 0; j < SUBFRAME_LEN * 2; j++) { <nl> -               t      = vector_ptr[j] << -shift; <nl> +               t      = vector_ptr[j] * (1 << -shift); <nl>                 sum   += t * t; <nl>                 tmp[j] = t; <nl>             } <nl> @@ -815,7 +815,7 @@ static void generate_noise(G723_1_Context *p) <nl>          if (shift < 0) <nl>             x >>= -shift; <nl>          else <nl> -           x <<= shift; <nl> +           x *= 1 << shift; <nl>          x = av_clip(x, -10000, 10000); <nl>   <nl>          for (j = 0; j < 11; j++) {
@@ -559,7 +559,9 @@ static int query_formats(AVFilterGraph *graph, AVClass *log_ctx) <nl>                  if ((ret = avfilter_insert_filter(link, convert, 0, 0)) < 0) <nl>                      return ret; <nl>   <nl> -                filter_query_formats(convert); <nl> +                if ((ret = filter_query_formats(convert)) < 0) <nl> +                    return ret; <nl> + <nl>                  inlink  = convert->inputs[0]; <nl>                  outlink = convert->outputs[0]; <nl>                  av_assert0( inlink-> in_formats->refcount > 0);
@@ -368,6 +368,10 @@ static int config_output(AVFilterLink *outlink) <nl>      p = s->attacks; <nl>      for (i = 0, new_nb_items = 0; i < nb_attacks; i++) { <nl>          char *tstr = av_strtok(p, " |", &saveptr); <nl> +        if (!tstr) { <nl> +            uninit(ctx); <nl> +            return AVERROR(EINVAL); <nl> +        } <nl>          p = NULL; <nl>          new_nb_items += sscanf(tstr, "%lf", &s->channels[i].attack) == 1; <nl>          if (s->channels[i].attack < 0) { <nl> @@ -380,6 +384,10 @@ static int config_output(AVFilterLink *outlink) <nl>      p = s->decays; <nl>      for (i = 0, new_nb_items = 0; i < nb_decays; i++) { <nl>          char *tstr = av_strtok(p, " |", &saveptr); <nl> +        if (!tstr) { <nl> +            uninit(ctx); <nl> +            return AVERROR(EINVAL); <nl> +        } <nl>          p = NULL; <nl>          new_nb_items += sscanf(tstr, "%lf", &s->channels[i].decay) == 1; <nl>          if (s->channels[i].decay < 0) { <nl> @@ -407,7 +415,7 @@ static int config_output(AVFilterLink *outlink) <nl>      for (i = 0, new_nb_items = 0; i < nb_points; i++) { <nl>          char *tstr = av_strtok(p, " |", &saveptr); <nl>          p = NULL; <nl> -        if (sscanf(tstr, "%lf/%lf", &S(i).x, &S(i).y) != 2) { <nl> +        if (!tstr || sscanf(tstr, "%lf/%lf", &S(i).x, &S(i).y) != 2) { <nl>              av_log(ctx, AV_LOG_ERROR, <nl>                      "Invalid and/or missing input/output value.\n"); <nl>              uninit(ctx);
@@ -57,7 +57,7 @@ typedef struct { <nl>   <nl>  typedef struct  { <nl>      int64_t frames_hdr_strm; <nl> -    int audio_strm_length; <nl> +    int64_t audio_strm_length; <nl>      int packet_count; <nl>      int entry; <nl>  
@@ -216,7 +216,7 @@ static inline int l1_unscale(int n, int mant, int scale_factor) <nl>      shift   = scale_factor_modshift[scale_factor]; <nl>      mod     = shift & 3; <nl>      shift >>= 2; <nl> -    val     = MUL64(mant + (-1 << n) + 1, scale_factor_mult[n-1][mod]); <nl> +    val     = MUL64((int)(mant + (-1U << n) + 1), scale_factor_mult[n-1][mod]); <nl>      shift  += n; <nl>      /* NOTE: at this point, 1 <= shift >= 21 + 15 */ <nl>      return (int)((val + (1LL << (shift - 1))) >> shift);
@@ -479,9 +479,11 @@ static int decode_frame(AVCodecContext *avctx, <nl>                  } else if (s->bit_depth == 1 && <nl>                             s->color_type == PNG_COLOR_TYPE_GRAY) { <nl>                      avctx->pix_fmt = PIX_FMT_MONOBLACK; <nl> -                } else if (s->color_type == PNG_COLOR_TYPE_PALETTE) { <nl> +                } else if (s->bit_depth == 8 && <nl> +                           s->color_type == PNG_COLOR_TYPE_PALETTE) { <nl>                      avctx->pix_fmt = PIX_FMT_PAL8; <nl> -                } else if (s->color_type == PNG_COLOR_TYPE_GRAY_ALPHA) { <nl> +                } else if (s->bit_depth == 8 && <nl> +                           s->color_type == PNG_COLOR_TYPE_GRAY_ALPHA) { <nl>                      avctx->pix_fmt = PIX_FMT_Y400A; <nl>                  } else { <nl>                      goto fail;
@@ -938,6 +938,10 @@ static int encode_frame(AVCodecContext *avctx, AVPacket *avpkt, <nl>      for (i = 0; i < SUBFRAMES; i++) <nl>          put_subframe(c, i); <nl>   <nl> + <nl> +    for (i = put_bits_count(&c->pb); i < 8*c->frame_size; i++) <nl> +        put_bits(&c->pb, 1, 0); <nl> + <nl>      flush_put_bits(&c->pb); <nl>   <nl>      avpkt->pts      = frame->pts;
@@ -416,7 +416,7 @@ static int filter_frame(AVFilterLink *link, AVFrame *in) <nl>                                 FFMIN(in->height, ctx->graph->nb_threads)); <nl>      else if (in->format == AV_PIX_FMT_YUV420P) <nl>          ctx->internal->execute(ctx, process_slice_yuv420p, &td, NULL, <nl> -                               FFMIN(in->height, ctx->graph->nb_threads)); <nl> +                               FFMAX(1, FFMIN(in->height, ctx->graph->nb_threads) & ~1)); <nl>      else <nl>          ctx->internal->execute(ctx, process_slice_uyvy422, &td, NULL, <nl>                                 FFMIN(in->height, ctx->graph->nb_threads));
@@ -117,7 +117,7 @@ int32_t ff_mlp_pack_output(int32_t lossless_check_data, <nl>                            (1U << output_shift[mat_ch]); <nl>              lossless_check_data ^= (sample & 0xffffff) << mat_ch; <nl>              if (is32) <nl> -                *data_32++ = sample << 8; <nl> +                *data_32++ = sample * 256; <nl>              else <nl>                  *data_16++ = sample >> 8; <nl>          }
@@ -523,7 +523,10 @@ static int vmdaudio_decode_frame(AVCodecContext *avctx, <nl>   <nl>      silent_chunks = 0; <nl>      if (block_type == BLOCK_TYPE_INITIAL) { <nl> -        uint32_t flags = AV_RB32(buf); <nl> +        uint32_t flags; <nl> +        if (buf_size < 4) <nl> +            return -1; <nl> +        flags = AV_RB32(buf); <nl>          silent_chunks  = av_popcount(flags); <nl>          buf      += 4; <nl>          buf_size -= 4;
@@ -1700,6 +1700,7 @@ static int get_video_frame(VideoState *is, AVFrame *frame, int64_t *pts, AVPacke <nl>                      is->frame_last_dropped_pos = pkt->pos; <nl>                      is->frame_last_dropped_pts = dpts; <nl>                      is->frame_drops_early++; <nl> +                    av_frame_unref(frame); <nl>                      ret = 0; <nl>                  } <nl>              }
@@ -86,10 +86,14 @@ typedef struct { <nl>   <nl>  static int ape_probe(AVProbeData * p) <nl>  { <nl> -    if (p->buf[0] == 'M' && p->buf[1] == 'A' && p->buf[2] == 'C' && p->buf[3] == ' ') <nl> -        return AVPROBE_SCORE_MAX; <nl> +    int version = AV_RL16(p->buf+4); <nl> +    if (AV_RL32(p->buf) != MKTAG('M', 'A', 'C', ' ')) <nl> +        return 0; <nl>   <nl> -    return 0; <nl> +    if (version < APE_MIN_VERSION || version > APE_MAX_VERSION) <nl> +        return AVPROBE_SCORE_MAX/4; <nl> + <nl> +    return AVPROBE_SCORE_MAX; <nl>  } <nl>   <nl>  static void ape_dumpinfo(AVFormatContext * s, APEContext * ape_ctx)
@@ -98,6 +98,8 @@ static int decode_frame(AVCodecContext *avctx, void *data, <nl>          for (row = 0; row < height; row++) { <nl>              pixptr = c->pic.data[0] + row * c->pic.linesize[0] + planemap[p]; <nl>              pixptr_end = pixptr + c->pic.linesize[0]; <nl> +            if(lp - encoded + row*2 + 1 >= buf_size) <nl> +                return -1; <nl>              dlen = av_be2ne16(*(const unsigned short *)(lp + row * 2)); <nl>              /* Decode a row of this plane */ <nl>              while (dlen > 0) {
@@ -117,7 +117,7 @@ static double get_f64l(uint8_t *p) <nl>   <nl>  int main(int argc, char *argv[]) <nl>  { <nl> -    int i, j; <nl> +    uint64_t i, j; <nl>      uint64_t sse = 0; <nl>      double sse_d = 0.0; <nl>      FILE *f[2]; <nl> @@ -126,8 +126,8 @@ int main(int argc, char *argv[]) <nl>      int64_t max; <nl>      int shift      = argc < 5 ? 0 : atoi(argv[4]); <nl>      int skip_bytes = argc < 6 ? 0 : atoi(argv[5]); <nl> -    int size0      = 0; <nl> -    int size1      = 0; <nl> +    uint64_t size0   = 0; <nl> +    uint64_t size1   = 0; <nl>      uint64_t maxdist = 0; <nl>      double maxdist_d = 0.0; <nl>   <nl> @@ -251,7 +251,7 @@ int main(int argc, char *argv[]) <nl>          else <nl>              psnr = 1000 * F - 1; // floating point free infinity :) <nl>   <nl> -        printf("stddev:%5d.%02d PSNR:%3d.%02d MAXDIFF:%5"PRIu64" bytes:%9d/%9d\n", <nl> +        printf("stddev:%5d.%02d PSNR:%3d.%02d MAXDIFF:%5"PRIu64" bytes:%9"PRIu64"/%9"PRIu64"\n", <nl>                 (int)(dev / F), (int)(dev % F), <nl>                 (int)(psnr / F), (int)(psnr % F), <nl>                 maxdist, size0, size1); <nl> @@ -271,7 +271,7 @@ int main(int argc, char *argv[]) <nl>   <nl>          maxdist = maxdist_d * scale; <nl>   <nl> -        printf("stddev:%10.2f PSNR:%s MAXDIFF:%10"PRIu64" bytes:%9d/%9d\n", <nl> +        printf("stddev:%10.2f PSNR:%s MAXDIFF:%10"PRIu64" bytes:%9"PRIu64"/%9"PRIu64"\n", <nl>                 dev * scale, psnr_str, maxdist, size0, size1); <nl>          break; <nl>      }
@@ -59,7 +59,7 @@ static int bitpacked_decode_yuv422p10(AVCodecContext *avctx, AVFrame *frame, <nl>                                        AVPacket *avpkt) <nl>  { <nl>      uint64_t frame_size = (uint64_t)avctx->width * (uint64_t)avctx->height * 20; <nl> -    uint64_t packet_size = avpkt->size * 8; <nl> +    uint64_t packet_size = (uint64_t)avpkt->size * 8; <nl>      GetBitContext bc; <nl>      uint16_t *y, *u, *v; <nl>      int ret, i;
@@ -197,10 +197,12 @@ int main(void) <nl>          }; <nl>   <nl>          for (i=0; i < FF_ARRAY_ELEMS(strings); i++) { <nl> -            const char *p= strings[i]; <nl> +            const char *p = strings[i], *q; <nl>              printf("|%s|", p); <nl> -            printf(" -> |%s|", av_get_token(&p, ":")); <nl> +            q = av_get_token(&p, ":"); <nl> +            printf(" -> |%s|", q); <nl>              printf(" + |%s|\n", p); <nl> +            av_free(q); <nl>          } <nl>      } <nl>  
@@ -90,7 +90,7 @@ static av_always_inline void predict_slice_buffered(SnowContext *s, slice_buffer <nl>   <nl>      if(s->avmv && mb_y < mb_h && plane_index == 0) <nl>          for(mb_x=0; mb_x<mb_w; mb_x++){ <nl> -            AVMotionVector *avmv = s->avmv + (s->avmv_index++); <nl> +            AVMotionVector *avmv = s->avmv + s->avmv_index; <nl>              const int b_width = s->b_width  << s->block_max_depth; <nl>              const int b_stride= b_width; <nl>              BlockNode *bn= &s->block[mb_x + mb_y*b_stride]; <nl> @@ -98,6 +98,8 @@ static av_always_inline void predict_slice_buffered(SnowContext *s, slice_buffer <nl>              if (bn->type) <nl>                  continue; <nl>   <nl> +            s->avmv_index++; <nl> + <nl>              avmv->w = block_w; <nl>              avmv->h = block_h; <nl>              avmv->dst_x = block_w*mb_x - block_w/2;
@@ -684,7 +684,7 @@ void ff_rtp_reset_packet_queue(RTPDemuxContext *s) <nl>      s->prev_ret  = 0; <nl>  } <nl>   <nl> -static void enqueue_packet(RTPDemuxContext *s, uint8_t *buf, int len) <nl> +static int enqueue_packet(RTPDemuxContext *s, uint8_t *buf, int len) <nl>  { <nl>      uint16_t seq   = AV_RB16(buf + 2); <nl>      RTPPacket **cur = &s->queue, *packet; <nl> @@ -699,7 +699,7 @@ static void enqueue_packet(RTPDemuxContext *s, uint8_t *buf, int len) <nl>   <nl>      packet = av_mallocz(sizeof(*packet)); <nl>      if (!packet) <nl> -        return; <nl> +        return AVERROR(ENOMEM); <nl>      packet->recvtime = av_gettime_relative(); <nl>      packet->seq      = seq; <nl>      packet->len      = len; <nl> @@ -707,6 +707,8 @@ static void enqueue_packet(RTPDemuxContext *s, uint8_t *buf, int len) <nl>      packet->next     = *cur; <nl>      *cur = packet; <nl>      s->queue_len++; <nl> + <nl> +    return 0; <nl>  } <nl>   <nl>  static int has_next_packet(RTPDemuxContext *s) <nl> @@ -804,7 +806,9 @@ static int rtp_parse_one_packet(RTPDemuxContext *s, AVPacket *pkt, <nl>              return rv; <nl>          } else { <nl>              /* Still missing some packet, enqueue this one. */ <nl> -            enqueue_packet(s, buf, len); <nl> +            rv = enqueue_packet(s, buf, len); <nl> +            if (rv < 0) <nl> +                return rv; <nl>              *bufptr = NULL; <nl>              /* Return the first enqueued packet if the queue is full, <nl>               * even if we're missing something */
@@ -1127,13 +1127,16 @@ static int mxf_read_seek(AVFormatContext *s, int stream_index, int64_t sample_ti <nl>  { <nl>      AVStream *st = s->streams[stream_index]; <nl>      int64_t seconds; <nl> +    int ret; <nl>   <nl>      if (!s->bit_rate) <nl>          return AVERROR_INVALIDDATA; <nl>      if (sample_time < 0) <nl>          sample_time = 0; <nl>      seconds = av_rescale(sample_time, st->time_base.num, st->time_base.den); <nl> -    avio_seek(s->pb, (s->bit_rate * seconds) >> 3, SEEK_SET); <nl> + <nl> +    if ((ret = avio_seek(s->pb, (s->bit_rate * seconds) >> 3, SEEK_SET)) < 0) <nl> +        return ret; <nl>      ff_update_cur_dts(s, st, sample_time); <nl>      return 0; <nl>  }
@@ -1075,6 +1075,10 @@ int ff_h263_decode_picture_header(MpegEncContext *s) <nl>          s->qscale = get_bits(&s->gb, 5); <nl>      } <nl>   <nl> +    if (s->width == 0 || s->height == 0) { <nl> +        av_log(s->avctx, AV_LOG_ERROR, "dimensions 0\n"); <nl> +        return -1; <nl> +    } <nl>      s->mb_width = (s->width  + 15) / 16; <nl>      s->mb_height = (s->height  + 15) / 16; <nl>      s->mb_num = s->mb_width * s->mb_height;
@@ -480,7 +480,7 @@ static inline int wv_unpack_stereo(WavpackFrameContext *s, GetBitContext *gb, <nl>          } <nl>   <nl>          if (type == AV_SAMPLE_FMT_S16P) { <nl> -            if (FFABS(L) + FFABS(R) > (1<<19)) { <nl> +            if (FFABS(L) + (unsigned)FFABS(R) > (1<<19)) { <nl>                  av_log(s->avctx, AV_LOG_ERROR, "sample %d %d too large\n", L, R); <nl>                  return AVERROR_INVALIDDATA; <nl>              }
@@ -234,7 +234,7 @@ int av_asrc_buffer_add_buffer(AVFilterContext *ctx, <nl>                                int sample_fmt, int64_t channel_layout, int planar, <nl>                                int64_t pts, int av_unused flags) <nl>  { <nl> -    uint8_t *data[8]; <nl> +    uint8_t *data[8] = {0}; <nl>      int linesize[8]; <nl>      int nb_channels = av_get_channel_layout_nb_channels(channel_layout), <nl>          nb_samples  = buf_size / nb_channels / av_get_bytes_per_sample(sample_fmt);
@@ -73,7 +73,7 @@ static void apply_unsharp(      uint8_t *dst, int dst_stride, <nl>   <nl>      int32_t res; <nl>      int x, y, z; <nl> -    const uint8_t *src2; <nl> +    const uint8_t *src2 = NULL;  //silence a warning <nl>   <nl>      if (!fp->amount) { <nl>          if (dst_stride == src_stride)
@@ -188,14 +188,13 @@ int alloc_picture(MpegEncContext *s, Picture *pic, int shared){ <nl>      const int b8_array_size= s->b8_stride*s->mb_height*2; <nl>      const int b4_array_size= s->b4_stride*s->mb_height*4; <nl>      int i; <nl> +    int r= -1; <nl>   <nl>      if(shared){ <nl>          assert(pic->data[0]); <nl>          assert(pic->type == 0 || pic->type == FF_BUFFER_TYPE_SHARED); <nl>          pic->type= FF_BUFFER_TYPE_SHARED; <nl>      }else{ <nl> -        int r; <nl> - <nl>          assert(!pic->data[0]); <nl>   <nl>          r= s->avctx->get_buffer(s->avctx, (AVFrame*)pic); <nl> @@ -207,11 +206,13 @@ int alloc_picture(MpegEncContext *s, Picture *pic, int shared){ <nl>   <nl>          if(s->linesize && (s->linesize != pic->linesize[0] || s->uvlinesize != pic->linesize[1])){ <nl>              av_log(s->avctx, AV_LOG_ERROR, "get_buffer() failed (stride changed)\n"); <nl> +            s->avctx->release_buffer(s->avctx, (AVFrame*)pic); <nl>              return -1; <nl>          } <nl>   <nl>          if(pic->linesize[1] != pic->linesize[2]){ <nl>              av_log(s->avctx, AV_LOG_ERROR, "get_buffer() failed (uv stride mismatch)\n"); <nl> +            s->avctx->release_buffer(s->avctx, (AVFrame*)pic); <nl>              return -1; <nl>          } <nl>   <nl> @@ -261,6 +262,8 @@ int alloc_picture(MpegEncContext *s, Picture *pic, int shared){ <nl>   <nl>      return 0; <nl>  fail: //for the CHECKED_ALLOCZ macro <nl> +    if(r>=0) <nl> +        s->avctx->release_buffer(s->avctx, (AVFrame*)pic); <nl>      return -1; <nl>  } <nl>  
@@ -525,7 +525,7 @@ ASSStyle *ff_ass_style_get(ASSSplitContext *ctx, const char *style) <nl>      if (!style || !*style) <nl>          style = "Default"; <nl>      for (i=0; i<ass->styles_count; i++) <nl> -        if (!strcmp(ass->styles[i].name, style)) <nl> +        if (ass->styles[i].name && !strcmp(ass->styles[i].name, style)) <nl>              return ass->styles + i; <nl>      return NULL; <nl>  }
@@ -2052,8 +2052,9 @@ static int mov_read_trak(MOVContext *c, AVIOContext *pb, MOVAtom atom) <nl>                                               ((double)st->codec->width * sc->height), INT_MAX); <nl>          } <nl>   <nl> -        av_reduce(&st->avg_frame_rate.num, &st->avg_frame_rate.den, <nl> -                  sc->time_scale*st->nb_frames, st->duration, INT_MAX); <nl> +        if (st->duration != AV_NOPTS_VALUE) <nl> +            av_reduce(&st->avg_frame_rate.num, &st->avg_frame_rate.den, <nl> +                      sc->time_scale*st->nb_frames, st->duration, INT_MAX); <nl>   <nl>  #if FF_API_R_FRAME_RATE <nl>          if (sc->stts_count == 1 || (sc->stts_count == 2 && sc->stts_data[1].count == 1))
@@ -154,7 +154,7 @@ static int vmd_read_header(AVFormatContext *s, <nl>      vmd->frame_table = NULL; <nl>      sound_buffers = AV_RL16(&vmd->vmd_header[808]); <nl>      raw_frame_table_size = vmd->frame_count * 6; <nl> -    if(vmd->frame_count * vmd->frames_per_block  >= UINT_MAX / sizeof(vmd_frame)){ <nl> +    if(vmd->frame_count * vmd->frames_per_block  >= (UINT_MAX - sound_buffers) / sizeof(vmd_frame)){ <nl>          av_log(s, AV_LOG_ERROR, "vmd->frame_count * vmd->frames_per_block too large\n"); <nl>          return -1; <nl>      }
@@ -801,10 +801,14 @@ static int dca_subframe_header(DCAContext *s, int base_channel, int block_index) <nl>              } <nl>          } else { <nl>              int am = s->amode & DCA_CHANNEL_MASK; <nl> +            if (am < 16) { <nl>              for (j = base_channel; j < s->prim_channels; j++) { <nl>                  s->downmix_coef[j][0] = dca_default_coeffs[am][j][0]; <nl>                  s->downmix_coef[j][1] = dca_default_coeffs[am][j][1]; <nl>              } <nl> +            } else { <nl> +                av_log(s->avctx, AV_LOG_WARNING, "amode > 15 default downmix_coef unsupported\n"); <nl> +            } <nl>          } <nl>      } <nl>  
@@ -4554,7 +4554,7 @@ static int decode_nal_units(H264Context *h, const uint8_t *buf, int buf_size, <nl>                  h->workaround_bugs |= FF_BUG_TRUNCATED; <nl>   <nl>              if (!(h->workaround_bugs & FF_BUG_TRUNCATED)) <nl> -                while (ptr[dst_length - 1] == 0 && dst_length > 0) <nl> +                while (dst_length > 0 && ptr[dst_length - 1] == 0) <nl>                      dst_length--; <nl>              bit_length = !dst_length ? 0 <nl>                                       : (8 * dst_length -
@@ -559,9 +559,12 @@ static void reduce_matrix(AudioMix *am, const double *matrix, int stride) <nl>          if (zero) { <nl>              am->output_zero[o] = 1; <nl>              am->out_matrix_channels--; <nl> +            if (o < am->in_channels) <nl> +                am->in_matrix_channels--; <nl>          } <nl>      } <nl> -    if (am->out_matrix_channels == 0) { <nl> +    if (am->out_matrix_channels == 0 || am->in_matrix_channels == 0) { <nl> +        am->out_matrix_channels = 0; <nl>          am->in_matrix_channels = 0; <nl>          return; <nl>      } <nl> @@ -683,7 +686,7 @@ int ff_audio_mix_set_matrix(AudioMix *am, const double *matrix, int stride) <nl>                                       am->in_matrix_channels;                \ <nl>          for (i = 0, i0 = 0; i < am->in_channels; i++) {                     \ <nl>              double v;                                                       \ <nl> -            if (am->input_skip[i])                                          \ <nl> +            if (am->input_skip[i] || am->output_zero[i])                    \ <nl>                  continue;                                                   \ <nl>              v = matrix[o * stride + i];                                     \ <nl>              am->matrix_## type[o0][i0] = expr;                              \
@@ -104,7 +104,7 @@ static int huff_build10(VLC *vlc, uint8_t *len) <nl>      for (i = 0; i < 1024; i++) { <nl>          he[i].sym = 1023 - i; <nl>          he[i].len = len[i]; <nl> -        if (len[i] == 0) <nl> +        if (len[i] == 0 || len[i] > 32) <nl>              return AVERROR_INVALIDDATA; <nl>      } <nl>      AV_QSORT(he, 1024, HuffEntry, huff_cmp_len10); <nl> @@ -136,7 +136,7 @@ static int huff_build12(VLC *vlc, uint8_t *len) <nl>      for (i = 0; i < 4096; i++) { <nl>          he[i].sym = 4095 - i; <nl>          he[i].len = len[i]; <nl> -        if (len[i] == 0) <nl> +        if (len[i] == 0 || len[i] > 32) <nl>              return AVERROR_INVALIDDATA; <nl>      } <nl>      AV_QSORT(he, 4096, HuffEntry, huff_cmp_len12); <nl> @@ -168,7 +168,7 @@ static int huff_build(VLC *vlc, uint8_t *len) <nl>      for (i = 0; i < 256; i++) { <nl>          he[i].sym = 255 - i; <nl>          he[i].len = len[i]; <nl> -        if (len[i] == 0) <nl> +        if (len[i] == 0 || len[i] > 32) <nl>              return AVERROR_INVALIDDATA; <nl>      } <nl>      AV_QSORT(he, 256, HuffEntry, huff_cmp_len);
@@ -34,7 +34,7 @@ typedef struct AMRWBContext { <nl>  } AMRWBContext; <nl>   <nl>  static const AVOption options[] = { <nl> -    { "dtx", "Allow DTX (generate comfort noise)", offsetof(AMRWBContext, allow_dtx), FF_OPT_TYPE_INT, 0, 0, 1, AV_OPT_FLAG_AUDIO_PARAM | AV_OPT_FLAG_ENCODING_PARAM }, <nl> +    { "dtx", "Allow DTX (generate comfort noise)", offsetof(AMRWBContext, allow_dtx), FF_OPT_TYPE_INT, { 0 }, 0, 1, AV_OPT_FLAG_AUDIO_PARAM | AV_OPT_FLAG_ENCODING_PARAM }, <nl>      { NULL } <nl>  }; <nl>  
@@ -347,7 +347,7 @@ static void output_segment_list(OutputStream *os, AVIOContext *out, AVFormatCont <nl>          int timescale = c->use_timeline ? os->ctx->streams[0]->time_base.den : AV_TIME_BASE; <nl>          avio_printf(out, "\t\t\t\t<SegmentTemplate timescale=\"%d\" ", timescale); <nl>          if (!c->use_timeline) <nl> -            avio_printf(out, "duration=\"%"PRId64"\" ", c->last_duration); <nl> +            avio_printf(out, "duration=\"%"PRId64"\" ", c->seg_duration); <nl>          avio_printf(out, "initialization=\"%s\" media=\"%s\" startNumber=\"%d\">\n", c->init_seg_name, c->media_seg_name, c->use_timeline ? start_number : 1); <nl>          if (c->use_timeline) { <nl>              int64_t cur_time = 0;
@@ -192,7 +192,7 @@ static int deband_8_coupling_c(AVFilterContext *ctx, void *arg, int jobnr, int n <nl>      for (y = start; y < end; y++) { <nl>          const int pos = y * s->planewidth[0]; <nl>   <nl> -        for (x = 0; x < s->planewidth[p]; x++) { <nl> +        for (x = 0; x < s->planewidth[0]; x++) { <nl>              const int x_pos = s->x_pos[pos + x]; <nl>              const int y_pos = s->y_pos[pos + x]; <nl>              int avg[4], cmp[4] = { 0 }, src[4]; <nl> @@ -257,7 +257,7 @@ static int deband_16_coupling_c(AVFilterContext *ctx, void *arg, int jobnr, int <nl>      for (y = start; y < end; y++) { <nl>          const int pos = y * s->planewidth[0]; <nl>   <nl> -        for (x = 0; x < s->planewidth[p]; x++) { <nl> +        for (x = 0; x < s->planewidth[0]; x++) { <nl>              const int x_pos = s->x_pos[pos + x]; <nl>              const int y_pos = s->y_pos[pos + x]; <nl>              int avg[4], cmp[4] = { 0 }, src[4];
@@ -485,7 +485,7 @@ static int mov_text_decode_frame(AVCodecContext *avctx, <nl>                  m->size_var = 8; <nl>              //size_var is equal to 8 or 16 depending on the size of box <nl>   <nl> -            if (m->tracksize + tsmb_size > avpkt->size) <nl> +            if (tsmb_size > avpkt->size - m->tracksize) <nl>                  break; <nl>   <nl>              for (size_t i = 0; i < box_count; i++) {
@@ -1313,9 +1313,9 @@ static int mpegts_write_packet_internal(AVFormatContext *s, AVPacket *pkt) <nl>              if (!ts_st->amux) { <nl>                  av_log(s, AV_LOG_ERROR, "AAC bitstream not in ADTS format " <nl>                                          "and extradata missing\n"); <nl> -                return AVERROR_INVALIDDATA; <nl> -            } <nl> - <nl> +                if (!st->nb_frames) <nl> +                    return AVERROR_INVALIDDATA; <nl> +            } else { <nl>              av_init_packet(&pkt2); <nl>              pkt2.data = pkt->data; <nl>              pkt2.size = pkt->size; <nl> @@ -1334,6 +1334,7 @@ static int mpegts_write_packet_internal(AVFormatContext *s, AVPacket *pkt) <nl>              size            = avio_close_dyn_buf(ts_st->amux->pb, &data); <nl>              ts_st->amux->pb = NULL; <nl>              buf             = data; <nl> +            } <nl>          } <nl>      } else if (st->codec->codec_id == AV_CODEC_ID_HEVC) { <nl>          int ret = check_hevc_startcode(s, st, pkt);
@@ -190,8 +190,13 @@ static int asf_read_unknown(AVFormatContext *s, const GUIDParseTable *g) <nl>          if ((ret = detect_unknown_subobject(s, asf->unknown_offset, <nl>                                              asf->unknown_size)) < 0) <nl>              return ret; <nl> -    } else <nl> +    } else { <nl> +        if (size < 24) { <nl> +            av_log(s, AV_LOG_ERROR, "Too small size %"PRIu64" (< 24).\n", size); <nl> +            return AVERROR_INVALIDDATA; <nl> +        } <nl>          avio_skip(pb, size - 24); <nl> +    } <nl>   <nl>      return 0; <nl>  }
@@ -74,7 +74,8 @@ static int dca_find_frame_end(DCAParseContext * pc1, const uint8_t * buf, <nl>              if (IS_MARKER(state, i, buf, buf_size) && (state == pc1->lastmarker || pc1->lastmarker == DCA_HD_MARKER)) { <nl>                  if(pc1->framesize > pc1->size) <nl>                      continue; <nl> -                if(!pc1->framesize){ <nl> +                // We have to check that we really read a full frame here, and that it isn't a pure HD frame, because their size is not constant. <nl> +                if(!pc1->framesize && state == pc1->lastmarker && state != DCA_HD_MARKER){ <nl>                      pc1->framesize = pc1->hd_pos ? pc1->hd_pos : pc1->size; <nl>                  } <nl>                  pc->frame_start_found = 0;
@@ -2419,6 +2419,7 @@ static int audio_decode_frame(VideoState *is) <nl>                             "Cannot create sample rate converter for conversion of %d Hz %s %d channels to %d Hz %s %d channels!\n", <nl>                              is->frame->sample_rate, av_get_sample_fmt_name(is->frame->format), av_frame_get_channels(is->frame), <nl>                              is->audio_tgt.freq, av_get_sample_fmt_name(is->audio_tgt.fmt), is->audio_tgt.channels); <nl> +                    swr_free(&is->swr_ctx); <nl>                      break; <nl>                  } <nl>                  is->audio_src.channel_layout = dec_channel_layout; <nl> @@ -2454,7 +2455,8 @@ static int audio_decode_frame(VideoState *is) <nl>                  } <nl>                  if (len2 == out_count) { <nl>                      av_log(NULL, AV_LOG_WARNING, "audio buffer is probably too small\n"); <nl> -                    swr_init(is->swr_ctx); <nl> +                    if (swr_init(is->swr_ctx) < 0) <nl> +                        swr_free(&is->swr_ctx); <nl>                  } <nl>                  is->audio_buf = is->audio_buf1; <nl>                  resampled_data_size = len2 * is->audio_tgt.channels * av_get_bytes_per_sample(is->audio_tgt.fmt);
@@ -2097,7 +2097,7 @@ static int audio_decode_frame(VideoState *is) <nl>      int len1, len2, data_size, resampled_data_size; <nl>      int64_t dec_channel_layout; <nl>      int got_frame; <nl> -    av_unused double pts; <nl> +    av_unused double audio_clock0; <nl>      int new_packet = 0; <nl>      int flush_complete = 0; <nl>      int wanted_nb_samples; <nl> @@ -2195,15 +2195,15 @@ static int audio_decode_frame(VideoState *is) <nl>              } <nl>   <nl>              /* if no pts, then compute it */ <nl> -            pts = is->audio_clock; <nl> +            audio_clock0 = is->audio_clock; <nl>              is->audio_clock += (double)data_size / <nl>                  (is->frame->channels * is->frame->sample_rate * av_get_bytes_per_sample(is->frame->format)); <nl>  #ifdef DEBUG <nl>              { <nl>                  static double last_clock; <nl> -                printf("audio: delay=%0.3f clock=%0.3f pts=%0.3f\n", <nl> +                printf("audio: delay=%0.3f clock=%0.3f clock0=%0.3f\n", <nl>                         is->audio_clock - last_clock, <nl> -                       is->audio_clock, pts); <nl> +                       is->audio_clock, audio_clock0); <nl>                  last_clock = is->audio_clock; <nl>              } <nl>  #endif
@@ -99,6 +99,7 @@ typedef struct AppleHTTPContext { <nl>      int cur_seq_no; <nl>      int end_of_segment; <nl>      int first_packet; <nl> +    int64_t first_timestamp; <nl>      AVIOInterruptCB *interrupt_callback; <nl>  } AppleHTTPContext; <nl>   <nl> @@ -527,6 +528,7 @@ static int applehttp_read_header(AVFormatContext *s, AVFormatParameters *ap) <nl>      } <nl>   <nl>      c->first_packet = 1; <nl> +    c->first_timestamp = AV_NOPTS_VALUE; <nl>   <nl>      return 0; <nl>  fail: <nl> @@ -591,6 +593,9 @@ start: <nl>                  if (!var->pb.eof_reached) <nl>                      return ret; <nl>                  reset_packet(&var->pkt); <nl> +            } else { <nl> +                if (c->first_timestamp == AV_NOPTS_VALUE) <nl> +                    c->first_timestamp = var->pkt.dts; <nl>              } <nl>          } <nl>          /* Check if this stream has the packet with the lowest dts */ <nl> @@ -639,7 +644,10 @@ static int applehttp_read_seek(AVFormatContext *s, int stream_index, <nl>      for (i = 0; i < c->n_variants; i++) { <nl>          /* Reset reading */ <nl>          struct variant *var = c->variants[i]; <nl> -        int64_t pos = 0; <nl> +        int64_t pos = c->first_timestamp == AV_NOPTS_VALUE ? 0 : <nl> +                      av_rescale_rnd(c->first_timestamp, 1, <nl> +                          stream_index >= 0 ? s->streams[stream_index]->time_base.den : AV_TIME_BASE, <nl> +                          flags & AVSEEK_FLAG_BACKWARD ? AV_ROUND_DOWN : AV_ROUND_UP); <nl>          if (var->input) { <nl>              ffurl_close(var->input); <nl>              var->input = NULL;
@@ -4266,9 +4266,7 @@ static void free_stream(AVStream **pst) <nl>      av_freep(&st->index_entries); <nl>  #if FF_API_LAVF_AVCTX <nl>  FF_DISABLE_DEPRECATION_WARNINGS <nl> -    av_freep(&st->codec->extradata); <nl> -    av_freep(&st->codec->subtitle_header); <nl> -    av_freep(&st->codec); <nl> +    avcodec_free_context(&st->codec); <nl>  FF_ENABLE_DEPRECATION_WARNINGS <nl>  #endif <nl>      av_freep(&st->priv_data);
@@ -719,6 +719,11 @@ static int frame_thread_init(AVCodecContext *avctx) <nl>          p->parent = fctx; <nl>          p->avctx  = copy; <nl>   <nl> +        if (!copy) { <nl> +            err = AVERROR(ENOMEM); <nl> +            goto error; <nl> +        } <nl> + <nl>          *copy = *src; <nl>          copy->thread_opaque = p; <nl>          copy->pkt = &p->avpkt; <nl> @@ -732,6 +737,10 @@ static int frame_thread_init(AVCodecContext *avctx) <nl>              update_context_from_thread(avctx, copy, 1); <nl>          } else { <nl>              copy->priv_data = av_malloc(codec->priv_data_size); <nl> +            if (!copy->priv_data) { <nl> +                err = AVERROR(ENOMEM); <nl> +                goto error; <nl> +            } <nl>              memcpy(copy->priv_data, src->priv_data, codec->priv_data_size); <nl>              copy->internal = av_malloc(sizeof(AVCodecInternal)); <nl>              if (!copy->internal) {
@@ -244,6 +244,13 @@ static int mace_decode_frame(AVCodecContext *avctx, void *data, <nl>      int i, j, k, l, ret; <nl>      int is_mace3 = (avctx->codec_id == AV_CODEC_ID_MACE3); <nl>   <nl> +    if (buf_size % (avctx->channels << is_mace3)) { <nl> +        av_log(avctx, AV_LOG_ERROR, "buffer size %d is odd\n", buf_size); <nl> +        buf_size -= buf_size % (avctx->channels << is_mace3); <nl> +        if (!buf_size) <nl> +            return AVERROR_INVALIDDATA; <nl> +    } <nl> + <nl>      /* get output buffer */ <nl>      frame->nb_samples = 3 * (buf_size << (1 - is_mace3)) / avctx->channels; <nl>      if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)
@@ -324,7 +324,7 @@ static int open_file(AVFormatContext *avf, unsigned fileno) <nl>      if (!cat->avf) <nl>          return AVERROR(ENOMEM); <nl>   <nl> -    cat->avf->flags |= avf->flags; <nl> +    cat->avf->flags |= avf->flags & ~AVFMT_FLAG_CUSTOM_IO; <nl>      cat->avf->interrupt_callback = avf->interrupt_callback; <nl>   <nl>      if ((ret = ff_copy_whiteblacklists(cat->avf, avf)) < 0)
@@ -128,8 +128,7 @@ static inline void silk_stabilize_lsf(int16_t nlsf[16], int order, const uint16_ <nl>      if (nlsf[0] < min_delta[0]) <nl>          nlsf[0] = min_delta[0]; <nl>      for (i = 1; i < order; i++) <nl> -        if (nlsf[i] < nlsf[i - 1] + min_delta[i]) <nl> -            nlsf[i] = nlsf[i - 1] + min_delta[i]; <nl> +        nlsf[i] = FFMAX(nlsf[i], FFMIN(nlsf[i - 1] + min_delta[i], 32767)); <nl>   <nl>      /* push backwards to increase distance */ <nl>      if (nlsf[order-1] > 32768 - min_delta[order])
@@ -1349,7 +1349,7 @@ static void show_packets(WriterContext *w, AVFormatContext *fmt_ctx) <nl>          if (do_show_frames && <nl>              get_video_frame(fmt_ctx, &frame, &pkt)) { <nl>              show_frame(w, &frame, fmt_ctx->streams[pkt.stream_index]); <nl> -            av_destruct_packet(&pkt); <nl> +            av_free_packet(&pkt); <nl>          } <nl>      } <nl>      av_init_packet(&pkt);
@@ -162,6 +162,7 @@ static int segment_mux_init(AVFormatContext *s) <nl>      oc->opaque             = s->opaque; <nl>      oc->io_close           = s->io_close; <nl>      oc->io_open            = s->io_open; <nl> +    oc->flags              = s->flags; <nl>   <nl>      for (i = 0; i < s->nb_streams; i++) { <nl>          AVStream *st;
@@ -532,11 +532,16 @@ static int nsv_read_header(AVFormatContext *s) <nl>      for (i = 0; i < NSV_MAX_RESYNC_TRIES; i++) { <nl>          if (nsv_resync(s) < 0) <nl>              return -1; <nl> -        if (nsv->state == NSV_FOUND_NSVF) <nl> +        if (nsv->state == NSV_FOUND_NSVF) { <nl>              err = nsv_parse_NSVf_header(s); <nl> +            if (err < 0) <nl> +                return err; <nl> +        } <nl>              /* we need the first NSVs also... */ <nl>          if (nsv->state == NSV_FOUND_NSVS) { <nl>              err = nsv_parse_NSVs_header(s); <nl> +            if (err < 0) <nl> +                return err; <nl>              break; /* we just want the first one */ <nl>          } <nl>      }
@@ -416,9 +416,9 @@ int ff_jpeg2000_init_component(Jpeg2000Component *comp, <nl>                  if (!prec->zerobits) <nl>                      return AVERROR(ENOMEM); <nl>   <nl> -                prec->cblk = av_malloc_array(prec->nb_codeblocks_width * <nl> -                                             prec->nb_codeblocks_height, <nl> -                                             sizeof(*prec->cblk)); <nl> +                prec->cblk = av_mallocz_array(prec->nb_codeblocks_width * <nl> +                                              prec->nb_codeblocks_height, <nl> +                                              sizeof(*prec->cblk)); <nl>                  if (!prec->cblk) <nl>                      return AVERROR(ENOMEM); <nl>                  for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) {
@@ -118,11 +118,11 @@ static void filter(AVFilterContext *ctx) <nl>          } <nl>      } <nl>   <nl> -    if      (alpha[0] / (float)alpha[1] > idet->interlace_threshold){ <nl> +    if      (alpha[0] > idet->interlace_threshold * alpha[1]){ <nl>          type = TFF; <nl> -    }else if(alpha[1] / (float)alpha[0] > idet->interlace_threshold){ <nl> +    }else if(alpha[1] > idet->interlace_threshold * alpha[0]){ <nl>          type = BFF; <nl> -    }else if(alpha[1] / (float)delta    > idet->progressive_threshold){ <nl> +    }else if(alpha[1] > idet->progressive_threshold * delta){ <nl>          type = PROGRSSIVE; <nl>      }else{ <nl>          type = UNDETERMINED;
@@ -680,8 +680,9 @@ static inline void rv34_mc(RV34DecContext *r, const int block_type, <nl>      srcY += src_y * s->linesize + src_x; <nl>      srcU += uvsrc_y * s->uvlinesize + uvsrc_x; <nl>      srcV += uvsrc_y * s->uvlinesize + uvsrc_x; <nl> -    if(   (unsigned)(src_x - !!lx*2) > s->h_edge_pos - !!lx*2 - (width <<3) - 4 <nl> -       || (unsigned)(src_y - !!ly*2) > s->v_edge_pos - !!ly*2 - (height<<3) - 4){ <nl> +    if(s->h_edge_pos - (width << 3) < 6 || s->v_edge_pos - (height << 3) < 6 || <nl> +       (unsigned)(src_x - !!lx*2) > s->h_edge_pos - !!lx*2 - (width <<3) - 4 || <nl> +       (unsigned)(src_y - !!ly*2) > s->v_edge_pos - !!ly*2 - (height<<3) - 4) { <nl>          uint8_t *uvbuf = s->edge_emu_buffer + 22 * s->linesize; <nl>   <nl>          srcY -= 2 + 2*s->linesize;
@@ -217,7 +217,8 @@ void mpeg_motion_internal(MpegEncContext *s, <nl>  { <nl>      uint8_t *ptr_y, *ptr_cb, *ptr_cr; <nl>      int dxy, uvdxy, mx, my, src_x, src_y, <nl> -        uvsrc_x, uvsrc_y, v_edge_pos, uvlinesize, linesize; <nl> +        uvsrc_x, uvsrc_y, v_edge_pos; <nl> +    ptrdiff_t uvlinesize, linesize; <nl>   <nl>  #if 0 <nl>  if(s->quarter_sample)
@@ -280,8 +280,8 @@ static av_cold void init_cplscales_table(COOKContext *q) <nl>  static inline int decode_bytes(const uint8_t *inbuffer, uint8_t *out, int bytes) <nl>  { <nl>      static const uint32_t tab[4] = { <nl> -        AV_BE2NE32C(0x37c511f2), AV_BE2NE32C(0xf237c511), <nl> -        AV_BE2NE32C(0x11f237c5), AV_BE2NE32C(0xc511f237), <nl> +        AV_BE2NE32C(0x37c511f2U), AV_BE2NE32C(0xf237c511U), <nl> +        AV_BE2NE32C(0x11f237c5U), AV_BE2NE32C(0xc511f237U), <nl>      }; <nl>      int i, off; <nl>      uint32_t c;
@@ -225,7 +225,7 @@ static int wv_get_value(WavpackFrameContext *ctx, GetBitContext *gb, <nl>          INC_MED(1); <nl>          DEC_MED(2); <nl>      } else { <nl> -        base = GET_MED(0) + GET_MED(1) + GET_MED(2) * (t - 2); <nl> +        base = GET_MED(0) + GET_MED(1) + GET_MED(2) * (t - 2U); <nl>          add  = GET_MED(2) - 1; <nl>          INC_MED(0); <nl>          INC_MED(1);
@@ -87,7 +87,7 @@ static int doTest(uint8_t *ref[4], int refStride[4], int w, int h, <nl>      static int srcStride[4]; <nl>      uint8_t *dst[4] = { 0 }; <nl>      uint8_t *out[4] = { 0 }; <nl> -    int dstStride[4]; <nl> +    int dstStride[4] = {0}; <nl>      int i; <nl>      uint64_t ssdY, ssdU = 0, ssdV = 0, ssdA = 0; <nl>      struct SwsContext *dstContext = NULL, *outContext = NULL;
@@ -290,8 +290,7 @@ static MMSSCPacketType get_tcp_server_response(MMSTContext *mmst) <nl>                  return read_result < 0 ? read_result : AVERROR_IO; <nl>              } <nl>              packet_type= AV_RL16(mms->in_buffer+36); <nl> -            hr = AV_RL32(mms->in_buffer + 40); <nl> -            if (hr) { <nl> +            if (read_result >= 44 && (hr = AV_RL32(mms->in_buffer + 40))) { <nl>                  av_log(NULL, AV_LOG_ERROR, <nl>                         "Server sent a message with packet type 0x%x and error status code 0x%08x\n", packet_type, hr); <nl>                  return AVERROR_UNKNOWN;
@@ -467,7 +467,6 @@ static int decode_frame_header(AVCodecContext *ctx, <nl>      last_invisible    = s->invisible; <nl>      s->invisible      = !get_bits1(&s->gb); <nl>      s->errorres       = get_bits1(&s->gb); <nl> -    // FIXME disable this upon resolution change <nl>      s->use_last_frame_mvs = !s->errorres && !last_invisible; <nl>      if (s->keyframe) { <nl>          if (get_bits_long(&s->gb, 24) != VP9_SYNCCODE) { // synccode <nl> @@ -526,6 +525,8 @@ static int decode_frame_header(AVCodecContext *ctx, <nl>                  w = get_bits(&s->gb, 16) + 1; <nl>                  h = get_bits(&s->gb, 16) + 1; <nl>              } <nl> +            s->use_last_frame_mvs &= s->frames[LAST_FRAME].tf.f->width == w && <nl> +                                     s->frames[LAST_FRAME].tf.f->height == h; <nl>              if (get_bits1(&s->gb)) // display size <nl>                  skip_bits(&s->gb, 32); <nl>              s->highprecisionmvs = get_bits1(&s->gb);
@@ -278,7 +278,7 @@ static int select_frame(AVFilterContext *ctx, AVFrame *frame) <nl>              select->var_values[VAR_SCENE] = get_scene_score(ctx, frame); <nl>              // TODO: document metadata <nl>              snprintf(buf, sizeof(buf), "%f", select->var_values[VAR_SCENE]); <nl> -            av_dict_set(&frame->metadata, "lavfi.scene_score", buf, 0); <nl> +            av_dict_set(avpriv_frame_get_metadatap(frame), "lavfi.scene_score", buf, 0); <nl>          } <nl>  #endif <nl>          break;
@@ -746,7 +746,7 @@ int ff_h264_decode_ref_pic_marking(H264Context *h, GetBitContext *gb, <nl>                                     int first_slice) <nl>  { <nl>      int i, ret; <nl> -    MMCO mmco_temp[MAX_MMCO_COUNT], *mmco = first_slice ? h->mmco : mmco_temp; <nl> +    MMCO mmco_temp[MAX_MMCO_COUNT], *mmco = mmco_temp; <nl>      int mmco_index = 0; <nl>   <nl>      if (h->nal_unit_type == NAL_IDR_SLICE) { // FIXME fields <nl> @@ -812,6 +812,7 @@ int ff_h264_decode_ref_pic_marking(H264Context *h, GetBitContext *gb, <nl>      } <nl>   <nl>      if (first_slice && mmco_index != -1) { <nl> +        memcpy(h->mmco, mmco_temp, sizeof(h->mmco)); <nl>          h->mmco_index = mmco_index; <nl>      } else if (!first_slice && mmco_index >= 0 && <nl>                 (mmco_index != h->mmco_index ||
@@ -115,7 +115,7 @@ int ff_scale_eval_dimensions(void *log_ctx, <nl>      int factor_w, factor_h; <nl>      int eval_w, eval_h; <nl>      int ret; <nl> -    const char scale2ref = outlink->src->inputs[1] == inlink; <nl> +    const char scale2ref = outlink->src->nb_inputs == 2 && outlink->src->inputs[1] == inlink; <nl>      double var_values[VARS_NB + VARS_S2R_NB], res; <nl>      const AVPixFmtDescriptor *main_desc; <nl>      const AVFilterLink *main_link;
@@ -396,8 +396,14 @@ static int asf_read_header(AVFormatContext *s, AVFormatParameters *ap) <nl>   <nl>                  st->codec->codec_tag = tag1; <nl>                  st->codec->codec_id = ff_codec_get_id(ff_codec_bmp_tags, tag1); <nl> -                if(tag1 == MKTAG('D', 'V', 'R', ' ')) <nl> +                if(tag1 == MKTAG('D', 'V', 'R', ' ')){ <nl>                      st->need_parsing = AVSTREAM_PARSE_FULL; <nl> +                    // issue658 containse wrong w/h and MS even puts a fake seq header with wrong w/h in extradata while a correct one is in te stream. maximum lameness <nl> +                    st->codec->width  = <nl> +                    st->codec->height = 0; <nl> +                    av_freep(&st->codec->extradata); <nl> +                    st->codec->extradata_size=0; <nl> +                } <nl>                  if(st->codec->codec_id == CODEC_ID_H264) <nl>                      st->need_parsing = AVSTREAM_PARSE_FULL_ONCE; <nl>              }
@@ -209,11 +209,9 @@ static av_cold int ac3_decode_init(AVCodecContext *avctx) <nl>      s->downmixed = 1; <nl>   <nl>      /* allocate context input buffer */ <nl> -    if (avctx->error_recognition >= FF_ER_CAREFUL) { <nl>          s->input_buffer = av_mallocz(AC3_FRAME_BUFFER_SIZE + FF_INPUT_BUFFER_PADDING_SIZE); <nl>          if (!s->input_buffer) <nl>              return AVERROR(ENOMEM); <nl> -    } <nl>   <nl>      avctx->sample_fmt = AV_SAMPLE_FMT_S16; <nl>      return 0; <nl> @@ -1314,15 +1312,12 @@ static int ac3_decode_frame(AVCodecContext * avctx, void *data, int *data_size, <nl>      const uint8_t *channel_map; <nl>      const float *output[AC3_MAX_CHANNELS]; <nl>   <nl> -    /* initialize the GetBitContext with the start of valid AC-3 Frame */ <nl> -    if (s->input_buffer) { <nl>          /* copy input buffer to decoder context to avoid reading past the end <nl>             of the buffer, which can be caused by a damaged input stream. */ <nl>          memcpy(s->input_buffer, buf, FFMIN(buf_size, AC3_FRAME_BUFFER_SIZE)); <nl> -        init_get_bits(&s->gbc, s->input_buffer, buf_size * 8); <nl> -    } else { <nl> +    buf = s->input_buffer; <nl> +    /* initialize the GetBitContext with the start of valid AC-3 Frame */ <nl>          init_get_bits(&s->gbc, buf, buf_size * 8); <nl> -    } <nl>   <nl>      /* parse the syncinfo */ <nl>      *data_size = 0;
@@ -1622,6 +1622,10 @@ static int matroska_read_header(AVFormatContext *s) <nl>              track->audio.sub_packet_h    = avio_rb16(&b); <nl>              track->audio.frame_size      = avio_rb16(&b); <nl>              track->audio.sub_packet_size = avio_rb16(&b); <nl> +            if (flavor <= 0 || track->audio.coded_framesize <= 0 || <nl> +                track->audio.sub_packet_h <= 0 || track->audio.frame_size <= 0 || <nl> +                track->audio.sub_packet_size <= 0) <nl> +                return AVERROR_INVALIDDATA; <nl>              track->audio.buf = av_malloc(track->audio.frame_size * track->audio.sub_packet_h); <nl>              if (codec_id == AV_CODEC_ID_RA_288) { <nl>                  st->codec->block_align = track->audio.coded_framesize;
@@ -247,9 +247,9 @@ static int decode_init(AVCodecContext *avctx) { <nl>      c->codec_frameheader = avctx->codec_tag == MKTAG('R', 'J', 'P', 'G'); <nl>      if (avctx->extradata_size) <nl>          get_quant(avctx, c, avctx->extradata, avctx->extradata_size); <nl> +    dsputil_init(&c->dsp, avctx); <nl>      if (!codec_reinit(avctx, avctx->width, avctx->height, -1)) <nl>          return 1; <nl> -    dsputil_init(&c->dsp, avctx); <nl>      return 0; <nl>  } <nl>  
@@ -117,11 +117,14 @@ void ff_lpc_end(LPCContext *s); <nl>   <nl>  #if USE_FIXED <nl>  typedef int LPC_TYPE; <nl> +typedef unsigned LPC_TYPE_U; <nl>  #else <nl>  #ifdef LPC_USE_DOUBLE <nl>  typedef double LPC_TYPE; <nl> +typedef double LPC_TYPE_U; <nl>  #else <nl>  typedef float LPC_TYPE; <nl> +typedef float LPC_TYPE_U; <nl>  #endif <nl>  #endif // USE_FIXED <nl>   <nl> @@ -192,8 +195,8 @@ static inline int AAC_RENAME(compute_lpc_coefs)(const LPC_TYPE *autoc, int max_o <nl>          for(j=0; j < (i+1)>>1; j++) { <nl>              LPC_TYPE f = lpc_last[    j]; <nl>              LPC_TYPE b = lpc_last[i-1-j]; <nl> -            lpc[    j] = f + AAC_MUL26(r, b); <nl> -            lpc[i-1-j] = b + AAC_MUL26(r, f); <nl> +            lpc[    j] = f + (LPC_TYPE_U)AAC_MUL26(r, b); <nl> +            lpc[i-1-j] = b + (LPC_TYPE_U)AAC_MUL26(r, f); <nl>          } <nl>   <nl>          if (fail && err < 0)
@@ -197,10 +197,6 @@ const CodecTag codec_wav_tags[] = { <nl>      { CODEC_ID_IMC, 0x401 }, <nl>   <nl>      /* FIXME: All of the IDs below are not 16 bit and thus illegal. */ <nl> -    { CODEC_ID_TTA, MKTAG('T', 'T', 'A', '1') }, <nl> -    { CODEC_ID_WAVPACK, MKTAG('W', 'V', 'P', 'K') }, <nl> -    { CODEC_ID_SHORTEN, MKTAG('s', 'h', 'r', 'n') }, <nl> - <nl>      // for NuppelVideo (nuv.c) <nl>      { CODEC_ID_PCM_S16LE, MKTAG('R', 'A', 'W', 'A') }, <nl>      { CODEC_ID_MP3, MKTAG('L', 'A', 'M', 'E') },
@@ -376,7 +376,7 @@ static void vp6_parse_coeff_huffman(VP56Context *s) <nl>          if (b > 3) pt = 1; <nl>          vlc_coeff = &s->dccv_vlc[pt]; <nl>   <nl> -        for (coeff_idx=0; coeff_idx<64; ) { <nl> +        for (coeff_idx = 0;;) { <nl>              int run = 1; <nl>              if (coeff_idx<2 && s->nb_null[coeff_idx][pt]) { <nl>                  s->nb_null[coeff_idx][pt]--; <nl> @@ -413,6 +413,8 @@ static void vp6_parse_coeff_huffman(VP56Context *s) <nl>                  } <nl>              } <nl>              coeff_idx+=run; <nl> +            if (coeff_idx >= 64) <nl> +                break; <nl>              cg = FFMIN(vp6_coeff_groups[coeff_idx], 3); <nl>              vlc_coeff = &s->ract_vlc[pt][ct][cg]; <nl>          }
@@ -828,6 +828,10 @@ static void do_subtitle_out(AVFormatContext *s, <nl>          sub->pts = av_rescale_q(pts, ist->st->time_base, AV_TIME_BASE_Q); <nl>          subtitle_out_size = avcodec_encode_subtitle(enc, subtitle_out, <nl>                                                      subtitle_out_max_size, sub); <nl> +        if (subtitle_out_size < 0) { <nl> +            fprintf(stderr, "Subtitle encoding failed\n"); <nl> +            av_exit(1); <nl> +        } <nl>   <nl>          av_init_packet(&pkt); <nl>          pkt.stream_index = ost->index;
@@ -372,7 +372,8 @@ static int decode_band_hdr(IVI4DecContext *ctx, IVIBandDesc *band, <nl>   <nl>          if (!get_bits1(&ctx->gb) || ctx->frame_type == FRAMETYPE_INTRA) { <nl>              transform_id = get_bits(&ctx->gb, 5); <nl> -            if (!transforms[transform_id].inv_trans) { <nl> +            if (transform_id >= FF_ARRAY_ELEMS(transforms) || <nl> +                !transforms[transform_id].inv_trans) { <nl>                  av_log_ask_for_sample(avctx, "Unimplemented transform: %d!\n", transform_id); <nl>                  return AVERROR_PATCHWELCOME; <nl>              }
@@ -94,7 +94,8 @@ void av_log_default_callback(void* ptr, int level, const char* fmt, va_list vl) <nl>  { <nl>      static int print_prefix=1; <nl>      static int count; <nl> -    static char line[1024], prev[1024]; <nl> +    static char prev[1024]; <nl> +    char line[1024]; <nl>      static int is_atty; <nl>      AVClass* avc= ptr ? *(AVClass**)ptr : NULL; <nl>      if(level>av_log_level)
@@ -2070,8 +2070,8 @@ int av_get_audio_frame_duration(AVCodecContext *avctx, int frame_bytes) <nl>      bps = av_get_exact_bits_per_sample(avctx->codec_id); <nl>   <nl>      /* codecs with an exact constant bits per sample */ <nl> -    if (bps > 0 && ch > 0 && frame_bytes > 0) <nl> -        return (frame_bytes * 8) / (bps * ch); <nl> +    if (bps > 0 && ch > 0 && frame_bytes > 0 && ch < 32768 && bps < 32768) <nl> +        return (frame_bytes * 8LL) / (bps * ch); <nl>      bps = avctx->bits_per_coded_sample; <nl>   <nl>      /* codecs with a fixed packet duration */
@@ -313,7 +313,7 @@ av_cold static int auto_matrix(SwrContext *s) <nl>      } else <nl>          maxval = INT_MAX; <nl>   <nl> -    if(maxcoef > maxval){ <nl> +    if(maxcoef > maxval || s->rematrix_volume  < 0){ <nl>          maxcoef /= maxval; <nl>          for(i=0; i<SWR_CH_MAX; i++) <nl>              for(j=0; j<SWR_CH_MAX; j++){
@@ -146,7 +146,7 @@ int main(int argc, char *argv[]) <nl>          } <nl>      } <nl>   <nl> -    max = (1 << (8 * len)) - 1; <nl> +    max = (1LL << (8 * len)) - 1; <nl>   <nl>      f[0] = fopen(argv[1], "rb"); <nl>      f[1] = fopen(argv[2], "rb");
@@ -909,7 +909,8 @@ static void qmf_32_subbands(DCAContext * s, int chans, <nl>      for (subindex = 0; subindex < 8; subindex++) { <nl>          /* Load in one sample from each subband and clear inactive subbands */ <nl>          for (i = 0; i < sb_act; i++){ <nl> -            uint32_t v = AV_RN32A(&samples_in[i][subindex]) ^ ((i-1)&2)<<30; <nl> +            unsigned sign = (i - 1) & 2; <nl> +            uint32_t v = AV_RN32A(&samples_in[i][subindex]) ^ sign << 30; <nl>              AV_WN32A(&s->raXin[i], v); <nl>          } <nl>  
@@ -271,7 +271,8 @@ static void rtcp_send_sr(AVFormatContext *s1, int64_t ntp_time, int bye) <nl>      avio_w8(s1->pb, RTCP_SR); <nl>      avio_wb16(s1->pb, 6); /* length in words - 1 */ <nl>      avio_wb32(s1->pb, s->ssrc); <nl> -    avio_wb64(s1->pb, NTP_TO_RTP_FORMAT(ntp_time)); <nl> +    avio_wb32(s1->pb, ntp_time / 1000000); <nl> +    avio_wb32(s1->pb, ((ntp_time % 1000000) << 32) / 1000000); <nl>      avio_wb32(s1->pb, rtp_ts); <nl>      avio_wb32(s1->pb, s->packet_count); <nl>      avio_wb32(s1->pb, s->octet_count);
@@ -2299,6 +2299,11 @@ static int decode_chunks(AVCodecContext *avctx, <nl>                  if (s2->picture_structure == PICT_BOTTOM_FIELD) <nl>                      mb_y++; <nl>   <nl> +                if (buf_end - buf_ptr < 2) { <nl> +                    av_log(s2->avctx, AV_LOG_ERROR, "slice too small\n"); <nl> +                    return AVERROR_INVALIDDATA; <nl> +                } <nl> + <nl>                  if (mb_y >= s2->mb_height) { <nl>                      av_log(s2->avctx, AV_LOG_ERROR, "slice below image (%d >= %d)\n", mb_y, s2->mb_height); <nl>                      return -1;
@@ -127,7 +127,7 @@ for examples see get_bits, show_bits, skip_bits, get_vlc <nl>   <nl>  #   define OPEN_READER(name, gb)                \ <nl>      unsigned int name##_index = (gb)->index;    \ <nl> -    int name##_cache          = 0 <nl> +    unsigned int name##_cache = 0 <nl>   <nl>  #   define CLOSE_READER(name, gb) (gb)->index = name##_index <nl>  
@@ -80,17 +80,17 @@ static int init_ralf_vlc(VLC *vlc, const uint8_t *data, int elems) <nl>      int counts[17], prefixes[18]; <nl>      int i, cur_len; <nl>      int max_bits = 0; <nl> -    GetBitContext gb; <nl> - <nl> -    init_get_bits(&gb, data, elems * 4); <nl> +    int nb = 0; <nl>   <nl>      for (i = 0; i <= 16; i++) <nl>          counts[i] = 0; <nl>      for (i = 0; i < elems; i++) { <nl> -        cur_len  = get_bits(&gb, 4) + 1; <nl> +        cur_len  = (nb ? *data & 0xF : *data >> 4) + 1; <nl>          counts[cur_len]++; <nl>          max_bits = FFMAX(max_bits, cur_len); <nl>          lens[i]  = cur_len; <nl> +        data    += nb; <nl> +        nb      ^= 1; <nl>      } <nl>      prefixes[1] = 0; <nl>      for (i = 1; i <= 16; i++)
@@ -132,6 +132,10 @@ static int bfi_read_packet(AVFormatContext * s, AVPacket * pkt) <nl>          video_offset    = avio_rl32(pb); <nl>          audio_size      = video_offset - audio_offset; <nl>          bfi->video_size = chunk_size - video_offset; <nl> +        if (audio_size < 0 || bfi->video_size < 0) { <nl> +            av_log(s, AV_LOG_ERROR, "Invalid audio/video offsets or chunk size\n"); <nl> +            return AVERROR_INVALIDDATA; <nl> +        } <nl>   <nl>          //Tossing an audio packet at the audio decoder. <nl>          ret = av_get_packet(pb, pkt, audio_size);
@@ -483,9 +483,10 @@ static char *get_content_url(xmlNodePtr *baseurl_nodes, <nl>              return NULL; <nl>          } <nl>          av_strlcpy(tmp_str, url, sizeof(tmp_str)); <nl> -        av_free(url); <nl>      } <nl>      if (rep_bandwidth_val && tmp_str[0] != '\0') { <nl> +        // free any previously assigned url before reassigning <nl> +        av_free(url); <nl>          url = av_strireplace(tmp_str, "$Bandwidth$", (const char*)rep_bandwidth_val); <nl>          if (!url) { <nl>              return NULL;
@@ -391,7 +391,7 @@ static void fill_caches(H264Context *h, int mb_type, int for_deblock){ <nl>                  } <nl>              } <nl>   <nl> -            if((for_deblock || (IS_DIRECT(mb_type) && !h->direct_spatial_mv_pred)) && !FRAME_MBAFF) <nl> +            if(for_deblock || ((IS_DIRECT(mb_type) && !h->direct_spatial_mv_pred) && !FRAME_MBAFF)) <nl>                  continue; <nl>   <nl>              if(USES_LIST(topleft_type, list)){
@@ -327,6 +327,7 @@ static int decode_band_hdr(IVI4DecContext *ctx, IVIBandDesc *band, <nl>  { <nl>      int plane, band_num, indx, transform_id, scan_indx; <nl>      int i; <nl> +    int quant_mat; <nl>   <nl>      plane    = get_bits(&ctx->gb, 2); <nl>      band_num = get_bits(&ctx->gb, 4); <nl> @@ -408,15 +409,16 @@ static int decode_band_hdr(IVI4DecContext *ctx, IVIBandDesc *band, <nl>              } <nl>              band->scan = scan_index_to_tab[scan_indx]; <nl>   <nl> -            band->quant_mat = get_bits(&ctx->gb, 5); <nl> -            if (band->quant_mat == 31) { <nl> +            quant_mat = get_bits(&ctx->gb, 5); <nl> +            if (quant_mat == 31) { <nl>                  av_log(avctx, AV_LOG_ERROR, "Custom quant matrix encountered!\n"); <nl>                  return AVERROR_INVALIDDATA; <nl>              } <nl> -            if (band->quant_mat > 21) { <nl> +            if (quant_mat > 21) { <nl>                  av_log(avctx, AV_LOG_ERROR, "Invalid quant matrix encountered!\n"); <nl>                  return AVERROR_INVALIDDATA; <nl>              } <nl> +            band->quant_mat = quant_mat; <nl>          } <nl>   <nl>          /* decode block huffman codebook */
@@ -86,6 +86,13 @@ static av_always_inline av_const float roundf(float x) <nl>  } <nl>  #endif /* HAVE_ROUNDF */ <nl>   <nl> +#if !HAVE_TRUNC <nl> +static av_always_inline av_const double trunc(double x) <nl> +{ <nl> +    return (x > 0) ? floor(x) : ceil(x); <nl> +} <nl> +#endif /* HAVE_TRUNC */ <nl> + <nl>  #if !HAVE_TRUNCF <nl>  static av_always_inline av_const float truncf(float x) <nl>  {
@@ -960,9 +960,9 @@ static int jpeg2000_decode_packet(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile, <nl>              if (!cblk->npasses) { <nl>                  int v = expn[bandno] + numgbits - 1 - <nl>                          tag_tree_decode(s, prec->zerobits + cblkno, 100); <nl> -                if (v < 0) { <nl> +                if (v < 0 || v > 30) { <nl>                      av_log(s->avctx, AV_LOG_ERROR, <nl> -                           "nonzerobits %d invalid\n", v); <nl> +                           "nonzerobits %d invalid or unsupported\n", v); <nl>                      return AVERROR_INVALIDDATA; <nl>                  } <nl>                  cblk->nonzerobits = v;
@@ -36,13 +36,13 @@ void avfilter_graph_destroy(AVFilterGraph *graph) <nl>   <nl>  int avfilter_graph_add_filter(AVFilterGraph *graph, AVFilterContext *filter) <nl>  { <nl> -    graph->filters = av_realloc(graph->filters, <nl> -                                sizeof(AVFilterContext*) * ++graph->filter_count); <nl> - <nl> -    if (!graph->filters) <nl> +    AVFilterContext **filters = av_realloc(graph->filters, <nl> +                                           sizeof(AVFilterContext*) * (graph->filter_count+1)); <nl> +    if (!filters) <nl>          return AVERROR(ENOMEM); <nl>   <nl> -    graph->filters[graph->filter_count - 1] = filter; <nl> +    graph->filters = filters; <nl> +    graph->filters[graph->filter_count++] = filter; <nl>   <nl>      return 0; <nl>  }
@@ -1934,8 +1934,10 @@ static int decode_frame_mp3on4(AVCodecContext *avctx, void *data, <nl>          } <nl>          header = (AV_RB32(buf) & 0x000fffff) | s->syncword; // patch header <nl>   <nl> -        if (ff_mpa_check_header(header) < 0) // Bad header, discard block <nl> -            break; <nl> +        if (ff_mpa_check_header(header) < 0) { <nl> +            av_log(avctx, AV_LOG_ERROR, "Bad header, discard block\n"); <nl> +            return AVERROR_INVALIDDATA; <nl> +        } <nl>   <nl>          avpriv_mpegaudio_decode_header((MPADecodeHeader *)m, header); <nl>  
@@ -375,7 +375,8 @@ int avresample_convert(AVAudioResampleContext *avr, void **output, <nl>          } <nl>      } <nl>   <nl> -    return handle_buffered_output(avr, &output_buffer, current_buffer); <nl> +    return handle_buffered_output(avr, output ? &output_buffer : NULL, <nl> +                                  current_buffer); <nl>  } <nl>   <nl>  int avresample_available(AVAudioResampleContext *avr)
@@ -290,8 +290,7 @@ static MMSSCPacketType get_tcp_server_response(MMSTContext *mmst) <nl>                  return read_result < 0 ? read_result : AVERROR_IO; <nl>              } <nl>              packet_type= AV_RL16(mms->in_buffer+36); <nl> -            hr = AV_RL32(mms->in_buffer + 40); <nl> -            if (hr) { <nl> +            if (read_result >= 44 && (hr = AV_RL32(mms->in_buffer + 40))) { <nl>                  av_log(NULL, AV_LOG_ERROR, <nl>                         "Server sent a message with packet type 0x%x and error status code 0x%08x\n", packet_type, hr); <nl>                  return AVERROR_UNKNOWN;
@@ -240,7 +240,7 @@ static inline int decode_vui_parameters(H264Context *h, SPS *sps){ <nl>          sps->num_reorder_frames= get_ue_golomb(&s->gb); <nl>          get_ue_golomb(&s->gb); /*max_dec_frame_buffering*/ <nl>   <nl> -        if(s->gb.size_in_bits < get_bits_count(&s->gb)){ <nl> +        if(get_bits_left(&s->gb) < 0){ <nl>              sps->num_reorder_frames=0; <nl>              sps->bitstream_restriction_flag= 0; <nl>          } <nl> @@ -250,8 +250,8 @@ static inline int decode_vui_parameters(H264Context *h, SPS *sps){ <nl>              return -1; <nl>          } <nl>      } <nl> -    if(s->gb.size_in_bits < get_bits_count(&s->gb)){ <nl> -        av_log(h->s.avctx, AV_LOG_ERROR, "Overread VUI by %d bits\n", get_bits_count(&s->gb) - s->gb.size_in_bits); <nl> +    if(get_bits_left(&s->gb) < 0){ <nl> +        av_log(h->s.avctx, AV_LOG_ERROR, "Overread VUI by %d bits\n", -get_bits_left(&s->gb)); <nl>          return -1; <nl>      } <nl>   <nl> @@ -568,7 +568,7 @@ int ff_h264_decode_picture_parameter_set(H264Context *h, int bit_length){ <nl>      memcpy(pps->scaling_matrix8, h->sps_buffers[pps->sps_id]->scaling_matrix8, sizeof(pps->scaling_matrix8)); <nl>   <nl>      bits_left = bit_length - get_bits_count(&s->gb); <nl> -    if(get_bits_count(&s->gb) < bit_length){ <nl> +    if(bits_left > 0){ <nl>          pps->transform_8x8_mode= get_bits1(&s->gb); <nl>          decode_scaling_matrices(h, h->sps_buffers[pps->sps_id], pps, 0, pps->scaling_matrix4, pps->scaling_matrix8); <nl>          pps->chroma_qp_index_offset[1]= get_se_golomb(&s->gb); //second_chroma_qp_index_offset
@@ -503,6 +503,7 @@ static av_cold int dvdsub_init(AVCodecContext *avctx) <nl>  { <nl>      DVDSubContext *ctx = avctx->priv_data; <nl>      char *data, *cur; <nl> +    int ret = 0; <nl>   <nl>      if (!avctx->extradata || !avctx->extradata_size) <nl>          return 0; <nl> @@ -527,16 +528,18 @@ static av_cold int dvdsub_init(AVCodecContext *avctx) <nl>          } else if (!strncmp("size:", cur, 5)) { <nl>              int w, h; <nl>              if (sscanf(cur + 5, "%dx%d", &w, &h) == 2) { <nl> -               int ret = ff_set_dimensions(avctx, w, h); <nl> +               ret = ff_set_dimensions(avctx, w, h); <nl>                 if (ret < 0) <nl> -                   return ret; <nl> +                   goto fail; <nl>              } <nl>          } <nl>          cur += strcspn(cur, "\n\r"); <nl>          cur += strspn(cur, "\n\r"); <nl>      } <nl> + <nl> +fail: <nl>      av_free(data); <nl> -    return 0; <nl> +    return ret; <nl>  } <nl>   <nl>  AVCodec ff_dvdsub_decoder = {
@@ -117,6 +117,11 @@ static int smacker_read_header(AVFormatContext *s) <nl>      smk->height = avio_rl32(pb); <nl>      smk->frames = avio_rl32(pb); <nl>      smk->pts_inc = (int32_t)avio_rl32(pb); <nl> +    if (smk->pts_inc > INT_MAX / 100) { <nl> +        av_log(s, AV_LOG_ERROR, "pts_inc %d is too large\n", smk->pts_inc); <nl> +        return AVERROR_INVALIDDATA; <nl> +    } <nl> + <nl>      smk->flags = avio_rl32(pb); <nl>      if(smk->flags & SMACKER_FLAG_RING_FRAME) <nl>          smk->frames++;
@@ -495,6 +495,7 @@ int ff_probe_input_buffer(ByteIOContext **pb, AVInputFormat **fmt, <nl>                  return ret; <nl>              } <nl>              score = 0; <nl> +            ret = 0;            /* error was end of file, nothing read */ <nl>          } <nl>          pd.buf_size += ret; <nl>          pd.buf = &buf[offset];
@@ -1457,7 +1457,7 @@ static void dequantization_int_97(int x, int y, Jpeg2000Cblk *cblk, <nl>          int32_t *datap = &comp->i_data[(comp->coord[0][1] - comp->coord[0][0]) * (y + j) + x]; <nl>          int *src = t1->data[j]; <nl>          for (i = 0; i < w; ++i) <nl> -            datap[i] = (src[i] * band->i_stepsize + (1<<14)) >> 15; <nl> +            datap[i] = (src[i] * (int64_t)band->i_stepsize + (1<<14)) >> 15; <nl>      } <nl>  } <nl>  
@@ -496,6 +496,10 @@ static int udp_open(URLContext *h, const char *uri, int flags) <nl>              /* assume if no digits were found it is a request to enable it */ <nl>              if (buf == endptr) <nl>                  s->overrun_nonfatal = 1; <nl> +            if (!HAVE_PTHREAD_CANCEL) <nl> +                av_log(h, AV_LOG_WARNING, <nl> +                       "'overrun_nonfatal' option was set but it is not supported " <nl> +                       "on this build (pthread support is required)\n"); <nl>          } <nl>          if (av_find_info_tag(buf, sizeof(buf), "ttl", p)) { <nl>              s->ttl = strtol(buf, NULL, 10); <nl> @@ -514,6 +518,10 @@ static int udp_open(URLContext *h, const char *uri, int flags) <nl>          } <nl>          if (av_find_info_tag(buf, sizeof(buf), "fifo_size", p)) { <nl>              s->circular_buffer_size = strtol(buf, NULL, 10)*188; <nl> +            if (!HAVE_PTHREAD_CANCEL) <nl> +                av_log(h, AV_LOG_WARNING, <nl> +                       "'circular_buffer_size' option was set but it is not supported " <nl> +                       "on this build (pthread support is required)\n"); <nl>          } <nl>          if (av_find_info_tag(buf, sizeof(buf), "localaddr", p)) { <nl>              av_strlcpy(localaddr, buf, sizeof(localaddr));
@@ -2440,6 +2440,7 @@ static int mxf_write_header(AVFormatContext *s) <nl>                  mxf->edit_unit_byte_count += klv_fill_size(mxf->edit_unit_byte_count); <nl>   <nl>                  sc->signal_standard = 1; <nl> +                sc->color_siting = 0; <nl>              } <nl>              if (mxf->signal_standard >= 0) <nl>                  sc->signal_standard = mxf->signal_standard;
@@ -259,12 +259,8 @@ static int scale_vector(int16_t *dst, const int16_t *vector, int length) <nl>   <nl>      bits  = normalize_bits(max, 15); <nl>   <nl> -    if (bits == 15) <nl> -        for (i = 0; i < length; i++) <nl> -            dst[i] = vector[i] * 0x7fff >> 3; <nl> -    else <nl> -        for (i = 0; i < length; i++) <nl> -            dst[i] = vector[i] << bits >> 3; <nl> +    for (i = 0; i < length; i++) <nl> +        dst[i] = vector[i] << bits >> 3; <nl>   <nl>      return bits - 3; <nl>  }
@@ -133,7 +133,8 @@ static av_cold int init(AVFilterContext *ctx, const char *args, void *opaque) <nl>          sscanf(args, "%d:%d:%lf:%d:%d:%lf", &lmsize_x, &lmsize_y, &lamount, <nl>                                              &cmsize_x, &cmsize_y, &camount); <nl>   <nl> -    if (lmsize_x < 2 || lmsize_y < 2 || cmsize_x < 2 || cmsize_y < 2) { <nl> +    if ((lamount && (lmsize_x < 2 || lmsize_y < 2)) || <nl> +        (camount && (cmsize_x < 2 || cmsize_y < 2))) { <nl>          av_log(ctx, AV_LOG_ERROR, <nl>                 "Invalid value <2 for lmsize_x:%d or lmsize_y:%d or cmsize_x:%d or cmsize_y:%d\n", <nl>                 lmsize_x, lmsize_y, cmsize_x, cmsize_y);
@@ -484,7 +484,7 @@ static int filter_frame(AVFilterLink *inlink, AVFrame *in) <nl>      AVFilterContext *ctx = inlink->dst; <nl>      ShowFreqsContext *s = ctx->priv; <nl>      AVFrame *fin = NULL; <nl> -    int ret; <nl> +    int ret = 0; <nl>   <nl>      av_audio_fifo_write(s->fifo, (void **)in->extended_data, in->nb_samples); <nl>      while (av_audio_fifo_size(s->fifo) >= s->win_size) {
@@ -30,6 +30,7 @@ <nl>  #include "libavutil/intreadwrite.h" <nl>  #include "avformat.h" <nl>  #include "internal.h" <nl> +#include "avio_internal.h" <nl>   <nl>  #define FILM_TAG MKBETAG('F', 'I', 'L', 'M') <nl>  #define FDSC_TAG MKBETAG('F', 'D', 'S', 'C') <nl> @@ -264,6 +265,8 @@ static int film_read_packet(AVFormatContext *s, <nl>          (film->audio_type != CODEC_ID_ADPCM_ADX)) { <nl>          /* stereo PCM needs to be interleaved */ <nl>   <nl> +        if (ffio_limit(pb, sample->sample_size) != sample->sample_size) <nl> +            return AVERROR(EIO); <nl>          if (av_new_packet(pkt, sample->sample_size)) <nl>              return AVERROR(ENOMEM); <nl>  
@@ -154,6 +154,8 @@ static int mm_decode_inter(MmContext * s, int half_horiz, int half_vert) <nl>              int replace_array = bytestream2_get_byte(&s->gb); <nl>              for(j=0; j<8; j++) { <nl>                  int replace = (replace_array >> (7-j)) & 1; <nl> +                if (x + half_horiz >= s->avctx->width) <nl> +                    return AVERROR_INVALIDDATA; <nl>                  if (replace) { <nl>                      int color = bytestream2_get_byte(&data_ptr); <nl>                      s->frame->data[0][y*s->frame->linesize[0] + x] = color;
@@ -91,10 +91,10 @@ void FUNCC(ff_h264_idct8_add)(uint8_t *_dst, int16_t *_block, int stride){ <nl>          const int a5 = -block[i+1*8] + (unsigned)block[i+7*8] + block[i+5*8] + (block[i+5*8]>>1); <nl>          const int a7 =  block[i+3*8] + (unsigned)block[i+5*8] + block[i+1*8] + (block[i+1*8]>>1); <nl>   <nl> -        const int b1 = (a7>>2) + a1; <nl> -        const int b3 =  a3 + (a5>>2); <nl> -        const int b5 = (a3>>2) - a5; <nl> -        const int b7 =  a7 - (a1>>2); <nl> +        const int b1 = (a7>>2) + (unsigned)a1; <nl> +        const int b3 =  (unsigned)a3 + (a5>>2); <nl> +        const int b5 = (a3>>2) - (unsigned)a5; <nl> +        const int b7 =  (unsigned)a7 - (a1>>2); <nl>   <nl>          block[i+0*8] = b0 + b7; <nl>          block[i+7*8] = b0 - b7;
@@ -385,8 +385,7 @@ static void encode_scale_factors(AVCodecContext *avctx, AACEncContext *s, <nl>          for (i = 0; i < sce->ics.max_sfb; i++) { <nl>              if (!sce->zeroes[w*16 + i]) { <nl>                  diff = sce->sf_idx[w*16 + i] - off + SCALE_DIFF_ZERO; <nl> -                if (diff < 0 || diff > 120) <nl> -                    av_log(avctx, AV_LOG_ERROR, "Scalefactor difference is too big to be coded\n"); <nl> +                av_assert0(diff >= 0 && diff <= 120); <nl>                  off = sce->sf_idx[w*16 + i]; <nl>                  put_bits(&s->pb, ff_aac_scalefactor_bits[diff], ff_aac_scalefactor_code[diff]); <nl>              }
@@ -4010,6 +4010,8 @@ again: <nl>                             "SPS decoding failure, trying again with the complete NAL\n"); <nl>                      if (h->is_avc) <nl>                          av_assert0(next_avc - buf_index + consumed == nalsize); <nl> +                    if ((next_avc - buf_index + consumed - 1) >= INT_MAX/8) <nl> +                        break; <nl>                      init_get_bits(&s->gb, &buf[buf_index + 1 - consumed], <nl>                                    8*(next_avc - buf_index + consumed - 1)); <nl>                      ff_h264_decode_seq_parameter_set(h);
@@ -555,7 +555,7 @@ int av_image_fill_black(uint8_t *dst_data[4], const ptrdiff_t dst_linesize[4], <nl>      int nb_planes = av_pix_fmt_count_planes(pix_fmt); <nl>      // A pixel or a group of pixels on each plane, with a value that represents black. <nl>      // Consider e.g. AV_PIX_FMT_UYVY422 for non-trivial cases. <nl> -    uint8_t clear_block[4][MAX_BLOCK_SIZE] = {0}; // clear padding with 0 <nl> +    uint8_t clear_block[4][MAX_BLOCK_SIZE] = {{0}}; // clear padding with 0 <nl>      int clear_block_size[4] = {0}; <nl>      ptrdiff_t plane_line_bytes[4] = {0}; <nl>      int rgb, limited;
@@ -151,6 +151,9 @@ static int prepare_packet(AVPacket *pkt,const FailingMuxerPacketData *pkt_data, <nl>  { <nl>      int ret; <nl>      FailingMuxerPacketData *data = av_malloc(sizeof(*data)); <nl> +    if (!data) { <nl> +        return AVERROR(ENOMEM); <nl> +    } <nl>      memcpy(data, pkt_data, sizeof(FailingMuxerPacketData)); <nl>      ret = av_packet_from_data(pkt, (uint8_t*) data, sizeof(*data)); <nl>  
@@ -48,6 +48,9 @@ static int sami_paragraph_to_ass(AVCodecContext *avctx, const char *src) <nl>      AVBPrint *dst_content = &sami->encoded_content; <nl>      AVBPrint *dst_source = &sami->encoded_source; <nl>   <nl> +    if (!dupsrc) <nl> +        return AVERROR(ENOMEM); <nl> + <nl>      av_bprint_clear(&sami->encoded_content); <nl>      av_bprint_clear(&sami->content); <nl>      av_bprint_clear(&sami->encoded_source);
@@ -954,6 +954,11 @@ int ff_parse_mpeg2_descriptor(AVFormatContext *fc, AVStream *st, int stream_type <nl>          language[2] = get8(pp, desc_end); <nl>          language[3] = 0; <nl>          av_metadata_set2(&st->metadata, "language", language, 0); <nl> +        switch (get8(pp, desc_end)) { <nl> +            case 0x01: st->disposition |= AV_DISPOSITION_CLEAN_EFFECTS; break; <nl> +            case 0x02: st->disposition |= AV_DISPOSITION_HEARING_IMPAIRED; break; <nl> +            case 0x03: st->disposition |= AV_DISPOSITION_VISUAL_IMPAIRED; break; <nl> +        } <nl>          break; <nl>      case 0x05: /* registration descriptor */ <nl>          st->codec->codec_tag = bytestream_get_le32(pp);
@@ -125,6 +125,7 @@ static int dsf_read_header(AVFormatContext *s) <nl>          return AVERROR_INVALIDDATA; <nl>      } <nl>      st->codecpar->block_align *= st->codecpar->channels; <nl> +    st->codecpar->bit_rate = st->codecpar->channels * st->codecpar->sample_rate * 8LL; <nl>      avio_skip(pb, 4); <nl>   <nl>      /* data chunk */
@@ -3154,12 +3154,16 @@ static int mov_write_header(AVFormatContext *s) <nl>      /* Set the FRAGMENT flag if any of the fragmentation methods are <nl>       * enabled. */ <nl>      if (mov->max_fragment_duration || mov->max_fragment_size || <nl> -        mov->mode == MODE_ISM || <nl>          mov->flags & (FF_MOV_FLAG_EMPTY_MOOV | <nl>                        FF_MOV_FLAG_FRAG_KEYFRAME | <nl>                        FF_MOV_FLAG_FRAG_CUSTOM)) <nl>          mov->flags |= FF_MOV_FLAG_FRAGMENT; <nl>   <nl> +    /* Set other implicit flags immediately */ <nl> +    if (mov->mode == MODE_ISM) <nl> +        mov->flags |= FF_MOV_FLAG_EMPTY_MOOV | FF_MOV_FLAG_SEPARATE_MOOF | <nl> +                      FF_MOV_FLAG_FRAGMENT; <nl> + <nl>      /* faststart: moov at the beginning of the file, if supported */ <nl>      if (mov->flags & FF_MOV_FLAG_FASTSTART) { <nl>          if ((mov->flags & FF_MOV_FLAG_FRAGMENT) || <nl> @@ -3297,7 +3301,6 @@ static int mov_write_header(AVFormatContext *s) <nl>                              FF_MOV_FLAG_FRAG_CUSTOM)) && <nl>              !mov->max_fragment_duration && !mov->max_fragment_size) <nl>              mov->max_fragment_duration = 5000000; <nl> -        mov->flags |= FF_MOV_FLAG_EMPTY_MOOV | FF_MOV_FLAG_SEPARATE_MOOF; <nl>      } <nl>   <nl>      if (!(mov->flags & FF_MOV_FLAG_FRAGMENT)) {
@@ -1758,7 +1758,7 @@ static void estimate_timings_from_bit_rate(AVFormatContext *ic) <nl>          for(i=0;i<ic->nb_streams;i++) { <nl>              st = ic->streams[i]; <nl>              if (st->codec->bit_rate > 0) { <nl> -                if (INT_MAX - st->codec->bit_rate > bit_rate) { <nl> +                if (INT_MAX - st->codec->bit_rate < bit_rate) { <nl>                      bit_rate = 0; <nl>                      break; <nl>                  }
@@ -190,6 +190,7 @@ static int read_packet(AVFormatContext *s, AVPacket *pkt) <nl>                  pkt->data[4]      = jvf->video_type; <nl>                  if ((size = avio_read(pb, pkt->data + JV_PREAMBLE_SIZE, size)) < 0) <nl>                      return AVERROR(EIO); <nl> +                memset(pkt->data + JV_PREAMBLE_SIZE + size, 0, FF_INPUT_BUFFER_PADDING_SIZE); <nl>   <nl>                  pkt->size         = size + JV_PREAMBLE_SIZE; <nl>                  pkt->stream_index = 1;
@@ -611,12 +611,16 @@ static int open_url(HLSContext *c, URLContext **uc, const char *url, AVDictionar <nl>      AVDictionary *tmp = NULL; <nl>      int ret; <nl>      const char *proto_name = avio_find_protocol_name(url); <nl> + <nl> +    if (!proto_name) <nl> +        return AVERROR_INVALIDDATA; <nl> + <nl>      // only http(s) & file are allowed <nl>      if (!av_strstart(proto_name, "http", NULL) && !av_strstart(proto_name, "file", NULL)) <nl>          return AVERROR_INVALIDDATA; <nl>      if (!strncmp(proto_name, url, strlen(proto_name)) && url[strlen(proto_name)] == ':') <nl>          ; <nl> -    else if (strcmp(proto_name, "file") || !strcmp(url, "file,")) <nl> +    else if (strcmp(proto_name, "file") || !strncmp(url, "file,", 5)) <nl>          return AVERROR_INVALIDDATA; <nl>   <nl>      av_dict_copy(&tmp, c->avio_opts, 0);
@@ -204,7 +204,7 @@ static int parse_playlist(AppleHTTPContext *c, const char *url, <nl>      enum KeyType key_type = KEY_NONE; <nl>      uint8_t iv[16] = ""; <nl>      int has_iv = 0; <nl> -    char key[MAX_URL_SIZE]; <nl> +    char key[MAX_URL_SIZE] = ""; <nl>      char line[1024]; <nl>      const char *ptr; <nl>      int close_in = 0;
@@ -100,14 +100,14 @@ static av_cold int init(AVFilterContext *ctx, const char *args) <nl>          if ((ret = av_opt_set(fade, "start_frame", expr, 0)) < 0) { <nl>              av_log(ctx, AV_LOG_ERROR, <nl>                     "Invalid value '%s' for start_frame option\n", expr); <nl> -            return ret; <nl> +            goto end; <nl>          } <nl>      } <nl>      if (expr = av_strtok(NULL, ":", &bufptr)) { <nl>          if ((ret = av_opt_set(fade, "nb_frames", expr, 0)) < 0) { <nl>              av_log(ctx, AV_LOG_ERROR, <nl>                     "Invalid value '%s' for nb_frames option\n", expr); <nl> -            return ret; <nl> +            goto end; <nl>          } <nl>      } <nl>  
@@ -39,7 +39,7 @@ static const AVClass filtergraph_class = { <nl>   <nl>  AVFilterGraph *avfilter_graph_alloc(void) <nl>  { <nl> -    AVFilterGraph *ret = av_mallocz(sizeof(AVFilterGraph)); <nl> +    AVFilterGraph *ret = av_mallocz(sizeof(*ret)); <nl>      if (!ret) <nl>          return NULL; <nl>      ret->av_class = &filtergraph_class; <nl> @@ -61,7 +61,7 @@ void avfilter_graph_free(AVFilterGraph **graph) <nl>  int avfilter_graph_add_filter(AVFilterGraph *graph, AVFilterContext *filter) <nl>  { <nl>      AVFilterContext **filters = av_realloc(graph->filters, <nl> -                                           sizeof(AVFilterContext*) * (graph->nb_filters + 1)); <nl> +                                           sizeof(*filters) * (graph->nb_filters + 1)); <nl>      if (!filters) <nl>          return AVERROR(ENOMEM); <nl>  
@@ -695,13 +695,13 @@ static int estimate_sid_gain(G723_1_Context *p) <nl>      if (y <= 0) { <nl>          t = seg * 32 + (val + 1 << seg2); <nl>          t = t * t - x; <nl> -        val = (seg2 - 1 << 4) + val; <nl> +        val = (seg2 - 1) * 16 + val; <nl>          if (t >= y) <nl>              val++; <nl>      } else { <nl>          t = seg * 32 + (val - 1 << seg2); <nl>          t = t * t - x; <nl> -        val = (seg2 - 1 << 4) + val; <nl> +        val = (seg2 - 1) * 16 + val; <nl>          if (t >= y) <nl>              val--; <nl>      }
@@ -28,6 +28,8 @@ <nl>  #include "get_bits.h" <nl>  #include "internal.h" <nl>   <nl> +#define PCX_HEADER_SIZE 128 <nl> + <nl>  /** <nl>   * @return advanced src pointer <nl>   */ <nl> @@ -85,6 +87,11 @@ static int pcx_decode_frame(AVCodecContext *avctx, void *data, int *got_frame, <nl>      uint8_t *scanline; <nl>      int ret = -1; <nl>   <nl> +    if (buf_size < PCX_HEADER_SIZE) { <nl> +        av_log(avctx, AV_LOG_ERROR, "Packet too small\n"); <nl> +        return AVERROR_INVALIDDATA; <nl> +    } <nl> + <nl>      if (buf[0] != 0x0a || buf[1] > 5) { <nl>          av_log(avctx, AV_LOG_ERROR, "this is not PCX encoded data\n"); <nl>          return AVERROR_INVALIDDATA;
@@ -282,8 +282,8 @@ void avfilter_set_common_formats(AVFilterContext *ctx, AVFilterFormats *formats) <nl>   <nl>  int avfilter_default_query_formats(AVFilterContext *ctx) <nl>  { <nl> -    enum AVMediaType type = ctx->inputs [0] ? ctx->inputs [0]->type : <nl> -                            ctx->outputs[0] ? ctx->outputs[0]->type : <nl> +    enum AVMediaType type = ctx->inputs  && ctx->inputs [0] ? ctx->inputs [0]->type : <nl> +                            ctx->outputs && ctx->outputs[0] ? ctx->outputs[0]->type : <nl>                              AVMEDIA_TYPE_VIDEO; <nl>   <nl>      avfilter_set_common_formats(ctx, avfilter_all_formats(type));
@@ -471,7 +471,9 @@ int attribute_align_arg avcodec_open(AVCodecContext *avctx, AVCodec *codec) <nl>      else if(avctx->width && avctx->height) <nl>          avcodec_set_dimensions(avctx, avctx->width, avctx->height); <nl>   <nl> -    if((avctx->coded_width||avctx->coded_height) && avcodec_check_dimensions(avctx,avctx->coded_width,avctx->coded_height)){ <nl> +#define SANE_NB_CHANNELS 128U <nl> +    if((avctx->coded_width||avctx->coded_height) && avcodec_check_dimensions(avctx,avctx->coded_width,avctx->coded_height) || <nl> +        avctx->channels > SANE_NB_CHANNELS) { <nl>          av_freep(&avctx->priv_data); <nl>          ret = AVERROR(EINVAL); <nl>          goto end;
@@ -528,6 +528,7 @@ int ff_mov_read_esds(AVFormatContext *fc, ByteIOContext *pb, MOVAtom atom) <nl>              dprintf(fc, "Specific MPEG4 header len=%d\n", len); <nl>              if((uint64_t)len > (1<<30)) <nl>                  return -1; <nl> +            av_free(st->codec->extradata); <nl>              st->codec->extradata = av_mallocz(len + FF_INPUT_BUFFER_PADDING_SIZE); <nl>              if (!st->codec->extradata) <nl>                  return AVERROR(ENOMEM);
@@ -31,8 +31,8 @@ int ff_flac_parse_picture(AVFormatContext *s, uint8_t *buf, int buf_size) <nl>      uint8_t mimetype[64], *desc = NULL; <nl>      AVIOContext *pb = NULL; <nl>      AVStream *st; <nl> -    int type, width, height; <nl> -    int len, ret = 0; <nl> +    int width, height, ret = 0; <nl> +    unsigned int type, len; <nl>   <nl>      pb = avio_alloc_context(buf, buf_size, 0, NULL, NULL, NULL, NULL); <nl>      if (!pb) <nl> @@ -40,7 +40,7 @@ int ff_flac_parse_picture(AVFormatContext *s, uint8_t *buf, int buf_size) <nl>   <nl>      /* read the picture type */ <nl>      type = avio_rb32(pb); <nl> -    if (type >= FF_ARRAY_ELEMS(ff_id3v2_picture_types) || type < 0) { <nl> +    if (type >= FF_ARRAY_ELEMS(ff_id3v2_picture_types)) { <nl>          av_log(s, AV_LOG_ERROR, "Invalid picture type: %d.\n", type); <nl>          if (s->error_recognition & AV_EF_EXPLODE) { <nl>              ret = AVERROR_INVALIDDATA; <nl> @@ -51,7 +51,7 @@ int ff_flac_parse_picture(AVFormatContext *s, uint8_t *buf, int buf_size) <nl>   <nl>      /* picture mimetype */ <nl>      len = avio_rb32(pb); <nl> -    if (len <= 0 || <nl> +    if (!len || len >= 64 || <nl>          avio_read(pb, mimetype, FFMIN(len, sizeof(mimetype) - 1)) != len) { <nl>          av_log(s, AV_LOG_ERROR, "Could not read mimetype from an attached " <nl>                 "picture.\n"); <nl> @@ -100,7 +100,7 @@ int ff_flac_parse_picture(AVFormatContext *s, uint8_t *buf, int buf_size) <nl>   <nl>      /* picture data */ <nl>      len = avio_rb32(pb); <nl> -    if (len <= 0) { <nl> +    if (!len) { <nl>          av_log(s, AV_LOG_ERROR, "Invalid attached picture size: %d.\n", len); <nl>          if (s->error_recognition & AV_EF_EXPLODE) <nl>              ret = AVERROR_INVALIDDATA;
@@ -587,7 +587,7 @@ static int opus_decode_packet(AVCodecContext *avctx, void *data, <nl>              memset(frame->extended_data[i], 0, frame->linesize[0]); <nl>          } <nl>   <nl> -        if (c->gain_i) { <nl> +        if (c->gain_i && decoded_samples > 0) { <nl>              c->fdsp.vector_fmul_scalar((float*)frame->extended_data[i], <nl>                                         (float*)frame->extended_data[i], <nl>                                         c->gain, FFALIGN(decoded_samples, 8));
@@ -660,7 +660,7 @@ static int config_input(AVFilterLink *inlink) <nl>  static av_cold int init(AVFilterContext *ctx) <nl>  { <nl>      HeadphoneContext *s = ctx->priv; <nl> -    int i; <nl> +    int i, ret; <nl>   <nl>      AVFilterPad pad = { <nl>          .name         = "in0", <nl> @@ -668,7 +668,8 @@ static av_cold int init(AVFilterContext *ctx) <nl>          .config_props = config_input, <nl>          .filter_frame = filter_frame, <nl>      }; <nl> -    ff_insert_inpad(ctx, 0, &pad); <nl> +    if ((ret = ff_insert_inpad(ctx, 0, &pad)) < 0) <nl> +        return ret; <nl>   <nl>      if (!s->map) { <nl>          av_log(ctx, AV_LOG_ERROR, "Valid mapping must be set.\n"); <nl> @@ -690,7 +691,10 @@ static av_cold int init(AVFilterContext *ctx) <nl>          }; <nl>          if (!name) <nl>              return AVERROR(ENOMEM); <nl> -        ff_insert_inpad(ctx, i, &pad); <nl> +        if ((ret = ff_insert_inpad(ctx, i, &pad)) < 0) { <nl> +            av_freep(&pad.name); <nl> +            return ret; <nl> +        } <nl>      } <nl>   <nl>      s->fdsp = avpriv_float_dsp_alloc(0);
@@ -848,33 +848,33 @@ int attribute_align_arg sws_scale(struct SwsContext *c, <nl>              y = av_clip_uint8((RY * r + GY * g + BY * b + ( 33 << (RGB2YUV_SHIFT - 1))) >> RGB2YUV_SHIFT); <nl>              u = av_clip_uint8((RU * r + GU * g + BU * b + (257 << (RGB2YUV_SHIFT - 1))) >> RGB2YUV_SHIFT); <nl>              v = av_clip_uint8((RV * r + GV * g + BV * b + (257 << (RGB2YUV_SHIFT - 1))) >> RGB2YUV_SHIFT); <nl> -            c->pal_yuv[i]= y + (u<<8) + (v<<16) + (a<<24U); <nl> +            c->pal_yuv[i]= y + (u<<8) + (v<<16) + ((unsigned)a<<24); <nl>   <nl>              switch (c->dstFormat) { <nl>              case AV_PIX_FMT_BGR32: <nl>  #if !HAVE_BIGENDIAN <nl>              case AV_PIX_FMT_RGB24: <nl>  #endif <nl> -                c->pal_rgb[i]=  r + (g<<8) + (b<<16) + (a<<24U); <nl> +                c->pal_rgb[i]=  r + (g<<8) + (b<<16) + ((unsigned)a<<24); <nl>                  break; <nl>              case AV_PIX_FMT_BGR32_1: <nl>  #if HAVE_BIGENDIAN <nl>              case AV_PIX_FMT_BGR24: <nl>  #endif <nl> -                c->pal_rgb[i]= a + (r<<8) + (g<<16) + (b<<24U); <nl> +                c->pal_rgb[i]= a + (r<<8) + (g<<16) + ((unsigned)b<<24); <nl>                  break; <nl>              case AV_PIX_FMT_RGB32_1: <nl>  #if HAVE_BIGENDIAN <nl>              case AV_PIX_FMT_RGB24: <nl>  #endif <nl> -                c->pal_rgb[i]= a + (b<<8) + (g<<16) + (r<<24U); <nl> +                c->pal_rgb[i]= a + (b<<8) + (g<<16) + ((unsigned)r<<24); <nl>                  break; <nl>              case AV_PIX_FMT_RGB32: <nl>  #if !HAVE_BIGENDIAN <nl>              case AV_PIX_FMT_BGR24: <nl>  #endif <nl>              default: <nl> -                c->pal_rgb[i]=  b + (g<<8) + (r<<16) + (a<<24U); <nl> +                c->pal_rgb[i]=  b + (g<<8) + (r<<16) + ((unsigned)a<<24); <nl>              } <nl>          } <nl>      }
@@ -3391,7 +3391,7 @@ static int decode_slice_header(H264Context *h, H264Context *h0) <nl>   <nl>      if (h->ref_count[0] > max_refs || h->ref_count[1] > max_refs) { <nl>          av_log(h->avctx, AV_LOG_ERROR, "reference overflow\n"); <nl> -        h->ref_count[0] = h->ref_count[1] = 1; <nl> +        h->ref_count[0] = h->ref_count[1] = 0; <nl>          return AVERROR_INVALIDDATA; <nl>      } <nl>  
@@ -946,7 +946,7 @@ static void opt_list(void *obj, void *av_log_obj, const char *unit, <nl>              av_log(av_log_obj, AV_LOG_INFO, " (default "); <nl>              switch (opt->type) { <nl>              case AV_OPT_TYPE_FLAGS: <nl> -                av_log(av_log_obj, AV_LOG_INFO, "%0llX", opt->default_val.i64); <nl> +                av_log(av_log_obj, AV_LOG_INFO, "%"PRIX64, opt->default_val.i64); <nl>                  break; <nl>              case AV_OPT_TYPE_DURATION: <nl>              case AV_OPT_TYPE_INT:
@@ -504,8 +504,12 @@ int vp56_decode_frame(AVCodecContext *avctx, void *data, int *data_size, <nl>      int is_alpha, av_uninit(alpha_offset); <nl>   <nl>      if (s->has_alpha) { <nl> +        if (remaining_buf_size < 3) <nl> +            return -1; <nl>          alpha_offset = bytestream_get_be24(&buf); <nl>          remaining_buf_size -= 3; <nl> +        if (remaining_buf_size < alpha_offset) <nl> +            return -1; <nl>      } <nl>   <nl>      for (is_alpha=0; is_alpha < 1+s->has_alpha; is_alpha++) {
@@ -61,7 +61,7 @@ int av_strerror(int errnum, char *errbuf, size_t errbuf_size) <nl>          av_strlcpy(errbuf, entry->str, errbuf_size); <nl>      } else { <nl>  #if HAVE_STRERROR_R <nl> -        ret = strerror_r(AVUNERROR(errnum), errbuf, errbuf_size); <nl> +        ret = AVERROR(strerror_r(AVUNERROR(errnum), errbuf, errbuf_size)); <nl>  #else <nl>          ret = -1; <nl>  #endif
@@ -4816,7 +4816,7 @@ static int mov_read_sidx(MOVContext *c, AVIOContext *pb, MOVAtom atom) <nl>                  MOVFragmentStreamInfo * si; <nl>                  si = &item->stream_info[j]; <nl>                  if (si->sidx_pts != AV_NOPTS_VALUE) { <nl> -                    ref_st = c->fc->streams[i]; <nl> +                    ref_st = c->fc->streams[j]; <nl>                      ref_sc = ref_st->priv_data; <nl>                      break; <nl>                  }
@@ -205,6 +205,10 @@ static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame, <nl>      if (flags & VB_HAS_GMC) { <nl>          i = (int16_t)bytestream2_get_le16(&c->stream); <nl>          j = (int16_t)bytestream2_get_le16(&c->stream); <nl> +        if (FFABS(j) > avctx->height) { <nl> +            av_log(avctx, AV_LOG_ERROR, "GMV out of range\n"); <nl> +            return AVERROR_INVALIDDATA; <nl> +        } <nl>          offset = i + j * avctx->width; <nl>      } <nl>      if (flags & VB_HAS_VIDEO) {
@@ -1305,7 +1305,7 @@ static void do_apply_filter(APEContext *ctx, int version, APEFilter *f, <nl>              /* Update the adaption coefficients */ <nl>              absres = FFABS(res); <nl>              if (absres) <nl> -                *f->adaptcoeffs = ((res & (-1<<31)) ^ (-1<<30)) >> <nl> +                *f->adaptcoeffs = ((res & ((~0UL) << 31)) ^ ((~0UL) << 30)) >> <nl>                                    (25 + (absres <= f->avg*3) + (absres <= f->avg*4/3)); <nl>              else <nl>                  *f->adaptcoeffs = 0;
@@ -31,6 +31,7 @@ <nl>  typedef struct PCMDVDContext { <nl>      uint32_t last_header;    // Cached header to see if parsing is needed <nl>      int block_size;          // Size of a block of samples in bytes <nl> +    int last_block_size;     // Size of the last block of samples in bytes <nl>      int samples_per_block;   // Number of samples per channel per block <nl>      int groups_per_block;    // Number of 20/24bit sample groups per block <nl>      uint8_t *extra_samples;  // Pointer to leftover samples from a frame <nl> @@ -223,6 +224,11 @@ static int pcm_dvd_decode_frame(AVCodecContext *avctx, void *data, <nl>   <nl>      if ((retval = pcm_dvd_parse_header(avctx, src))) <nl>          return retval; <nl> +    if (s->last_block_size != s->block_size) { <nl> +        av_log(avctx, AV_LOG_WARNING, "block_size has changed\n"); <nl> +        s->extra_sample_count = 0; <nl> +    } <nl> +    s->last_block_size = s->block_size; <nl>      src      += 3; <nl>      buf_size -= 3; <nl>  
@@ -386,7 +386,7 @@ static int seg_write_header(AVFormatContext *s) <nl>      } <nl>      if (seg->oformat->flags & AVFMT_NOFILE) { <nl>          av_log(s, AV_LOG_ERROR, "format %s not supported.\n", <nl> -               oc->oformat->name); <nl> +               seg->oformat->name); <nl>          ret = AVERROR(EINVAL); <nl>          goto fail; <nl>      }
@@ -611,6 +611,9 @@ void ff_ivi_output_plane(IVIPlaneDesc *plane, uint8_t *dst, int dst_pitch) <nl>      const int16_t   *src  = plane->bands[0].buf; <nl>      uint32_t        pitch = plane->bands[0].pitch; <nl>   <nl> +    if(!src) <nl> +        return; <nl> + <nl>      for (y = 0; y < plane->height; y++) { <nl>          for (x = 0; x < plane->width; x++) <nl>              dst[x] = av_clip_uint8(src[x] + 128);
@@ -731,12 +731,6 @@ fail: <nl>      if (pkt->stream_index == seg->reference_stream_index) <nl>          seg->frame_count++; <nl>   <nl> -    if (ret < 0) { <nl> -        if (seg->list) <nl> -            avio_close(seg->list_pb); <nl> -        avformat_free_context(oc); <nl> -    } <nl> - <nl>      return ret; <nl>  } <nl>  
@@ -701,12 +701,12 @@ static int decode_idat_chunk(AVCodecContext *avctx, PNGDecContext *s, <nl>              if ((ret = ff_thread_get_buffer(avctx, &s->previous_picture, AV_GET_BUFFER_FLAG_REF)) < 0) <nl>                  return ret; <nl>          } <nl> -        ff_thread_finish_setup(avctx); <nl> - <nl>          p->pict_type        = AV_PICTURE_TYPE_I; <nl>          p->key_frame        = 1; <nl>          p->interlaced_frame = !!s->interlace_type; <nl>   <nl> +        ff_thread_finish_setup(avctx); <nl> + <nl>          /* compute the compressed row size */ <nl>          if (!s->interlace_type) { <nl>              s->crow_size = s->row_size + 1;
@@ -164,14 +164,16 @@ static int decode_0(AVCodecContext *avctx, uint8_t code, uint8_t *pkt) <nl>          } while (--i); <nl>      } <nl>   <nl> -    dst = c->frame[c->current_frame]; <nl> +    dst  = c->frame[c->current_frame]; <nl> +    dend = c->frame[c->current_frame] + c->frame_size; <nl>      do { <nl>          a    = bytestream2_get_byte(&c->gb); <nl>          b    = bytestream2_get_byte(&c->gb); <nl>          p    = (a & 0xC0) >> 6; <nl>          src  = c->frame[p] + get_video_page_offset(avctx, a, b); <nl>          send = c->frame[p] + c->frame_size; <nl> -        if (src + 3 * avctx->width + 4 > send) <nl> +        if ((src + 3 * avctx->width + 4 > send) || <nl> +            (dst + 3 * avctx->width + 4 > dend)) <nl>              return AVERROR_INVALIDDATA; <nl>          copy_block4(dst, src, avctx->width, avctx->width, 4); <nl>          i++;
@@ -69,7 +69,7 @@ static void get_tree_codes(uint32_t *bits, int16_t *lens, uint8_t *xlat, <nl>   <nl>      s = nodes[node].sym; <nl>      if (s != -1) { <nl> -        bits[*pos] = (~pfx) & ((1U << FFMAX(pl, 1)) - 1); <nl> +        bits[*pos] = (~pfx) & ((1ULL << FFMAX(pl, 1)) - 1); <nl>          lens[*pos] = FFMAX(pl, 1); <nl>          xlat[*pos] = s + (pl == 0); <nl>          (*pos)++;
@@ -585,9 +585,12 @@ static inline int convert_frame(AVAudioResampleContext *avr, <nl>   <nl>  static inline int available_samples(AVFrame *out) <nl>  { <nl> +    int samples; <nl>      int bytes_per_sample = av_get_bytes_per_sample(out->format); <nl> -    int samples = out->linesize[0] / bytes_per_sample; <nl> +    if (!bytes_per_sample) <nl> +        return AVERROR(EINVAL); <nl>   <nl> +    samples = out->linesize[0] / bytes_per_sample; <nl>      if (av_sample_fmt_is_planar(out->format)) { <nl>          return samples; <nl>      } else {
@@ -827,7 +827,7 @@ static int wma_decode_superframe(AVCodecContext *avctx, <nl>          return 0; <nl>      } <nl>      if (buf_size < s->block_align) <nl> -        return 0; <nl> +        return AVERROR(EINVAL); <nl>      buf_size = s->block_align; <nl>   <nl>      samples = data;
@@ -780,6 +780,7 @@ int ff_ivi_decode_frame(AVCodecContext *avctx, void *data, int *data_size, <nl>          avctx->release_buffer(avctx, &ctx->frame); <nl>   <nl>      ctx->frame.reference = 0; <nl> +    avcodec_set_dimensions(avctx, ctx->planes[0].width, ctx->planes[0].height); <nl>      if ((result = avctx->get_buffer(avctx, &ctx->frame)) < 0) { <nl>          av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n"); <nl>          return result;
@@ -46,8 +46,8 @@ typedef struct AudioBitScopeContext { <nl>  #define FLAGS AV_OPT_FLAG_FILTERING_PARAM|AV_OPT_FLAG_VIDEO_PARAM <nl>   <nl>  static const AVOption abitscope_options[] = { <nl> -    { "rate", "set video rate", OFFSET(frame_rate), AV_OPT_TYPE_VIDEO_RATE, {.str="25"}, 0, 0, FLAGS }, <nl> -    { "r",    "set video rate", OFFSET(frame_rate), AV_OPT_TYPE_VIDEO_RATE, {.str="25"}, 0, 0, FLAGS }, <nl> +    { "rate", "set video rate", OFFSET(frame_rate), AV_OPT_TYPE_VIDEO_RATE, {.str="25"}, 0, INT_MAX, FLAGS }, <nl> +    { "r",    "set video rate", OFFSET(frame_rate), AV_OPT_TYPE_VIDEO_RATE, {.str="25"}, 0, INT_MAX, FLAGS }, <nl>      { "size", "set video size", OFFSET(w), AV_OPT_TYPE_IMAGE_SIZE, {.str="1024x256"}, 0, 0, FLAGS }, <nl>      { "s",    "set video size", OFFSET(w), AV_OPT_TYPE_IMAGE_SIZE, {.str="1024x256"}, 0, 0, FLAGS }, <nl>      { "colors", "set channels colors", OFFSET(colors), AV_OPT_TYPE_STRING, {.str = "red|green|blue|yellow|orange|lime|pink|magenta|brown" }, 0, 0, FLAGS },
@@ -477,12 +477,17 @@ static int <nl>  ogg_read_header (AVFormatContext * s, AVFormatParameters * ap) <nl>  { <nl>      struct ogg *ogg = s->priv_data; <nl> +    int i; <nl>      ogg->curidx = -1; <nl>      //linear headers seek from start <nl>      if (ogg_get_headers (s) < 0){ <nl>          return -1; <nl>      } <nl>   <nl> +    for (i = 0; i < ogg->nstreams; i++) <nl> +        if (ogg->streams[i].header < 0) <nl> +            ogg->streams[i].codec = NULL; <nl> + <nl>      //linear granulepos seek from end <nl>      ogg_get_length (s); <nl>  
@@ -615,9 +615,7 @@ static int decode_tns(AACContext * ac, TemporalNoiseShaping * tns, <nl>      const int is8 = ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE; <nl>      const int tns_max_order = is8 ? 7 : ac->m4ac.object_type == AOT_AAC_MAIN ? 20 : 12; <nl>      for (w = 0; w < ics->num_windows; w++) { <nl> -        tns->n_filt[w] = get_bits(gb, 2 - is8); <nl> - <nl> -        if (tns->n_filt[w]) <nl> +        if ((tns->n_filt[w] = get_bits(gb, 2 - is8))) { <nl>              coef_res = get_bits1(gb); <nl>   <nl>          for (filt = 0; filt < tns->n_filt[w]; filt++) { <nl> @@ -638,6 +636,7 @@ static int decode_tns(AACContext * ac, TemporalNoiseShaping * tns, <nl>              for (i = 0; i < tns->order[w][filt]; i++) <nl>                  tns->coef[w][filt][i] = tns_tmp2_map[tmp2_idx][get_bits(gb, coef_len)]; <nl>          } <nl> +        } <nl>      } <nl>      return 0; <nl>  }
@@ -662,7 +662,7 @@ static void choose_sample_rate(AVStream *st, AVCodec *codec) <nl>  { <nl>      if(codec && codec->supported_samplerates){ <nl>          const int *p= codec->supported_samplerates; <nl> -        int best;//=0; <nl> +        int best=0; <nl>          int best_dist=INT_MAX; <nl>          for(; *p; p++){ <nl>              int dist= abs(st->codec->sample_rate - *p);
@@ -182,10 +182,11 @@ void avfilter_link_free(AVFilterLink **link) <nl>   <nl>                  av_freep(&picref->audio); <nl>                  av_freep(&picref->video); <nl> -                av_freep(&picref); <nl> +                av_freep(&(*link)->pool->pic[i]); <nl>              } <nl>          } <nl> -        av_freep(&(*link)->pool); <nl> +        (*link)->pool->count = 0; <nl> +//        av_freep(&(*link)->pool); <nl>      } <nl>      av_freep(link); <nl>  }
@@ -1237,6 +1237,7 @@ static void ebml_free(EbmlSyntax *syntax, void *data) <nl>                       j++, ptr += syntax[i].list_elem_size) <nl>                      ebml_free(syntax[i].def.n, ptr); <nl>                  av_freep(&list->elem); <nl> +                list->nb_elem = 0; <nl>              } else <nl>                  ebml_free(syntax[i].def.n, data_off); <nl>          default:
@@ -364,6 +364,8 @@ static void conv411(uint8_t *dst, int dst_wrap, <nl>      int w, c; <nl>      uint8_t *s1, *s2, *d; <nl>   <nl> +    width>>=1; <nl> + <nl>      for(;height > 0; height--) { <nl>          s1 = src; <nl>          s2 = src + src_wrap;
@@ -1489,7 +1489,7 @@ static int asf_build_simple_index(AVFormatContext *s, int stream_index) <nl>      ff_asf_guid g; <nl>      ASFContext *asf     = s->priv_data; <nl>      int64_t current_pos = avio_tell(s->pb); <nl> -    int ret = 0; <nl> +    int64_t ret; <nl>   <nl>      if((ret = avio_seek(s->pb, asf->data_object_offset + asf->data_object_size, SEEK_SET)) < 0) { <nl>          return ret; <nl> @@ -1559,7 +1559,7 @@ static int asf_read_seek(AVFormatContext *s, int stream_index, <nl>   <nl>      /* Try using the protocol's read_seek if available */ <nl>      if (s->pb) { <nl> -        int ret = avio_seek_time(s->pb, stream_index, pts, flags); <nl> +        int64_t ret = avio_seek_time(s->pb, stream_index, pts, flags); <nl>          if (ret >= 0) <nl>              asf_reset_header(s); <nl>          if (ret != AVERROR(ENOSYS))
@@ -980,12 +980,19 @@ static int b44_uncompress(EXRContext *s, const uint8_t *src, int compressed_size <nl>              } <nl>              target_channel_offset += 2; <nl>          } else {/* Float or UINT 32 channel */ <nl> +            if (stayToUncompress < td->ysize * td->xsize * 4) { <nl> +                av_log(s, AV_LOG_ERROR, "Not enough data for uncompress channel: %d", stayToUncompress); <nl> +                return AVERROR_INVALIDDATA; <nl> +            } <nl> + <nl>              for (y = 0; y < td->ysize; y++) { <nl>                  indexOut = target_channel_offset * td->xsize + y * td->channel_line_size; <nl>                  memcpy(&td->uncompressed_data[indexOut], sr, td->xsize * 4); <nl>                  sr += td->xsize * 4; <nl>              } <nl>              target_channel_offset += 4; <nl> + <nl> +            stayToUncompress -= td->ysize * td->xsize * 4; <nl>          } <nl>      } <nl>  
@@ -164,6 +164,12 @@ static int wsaud_read_packet(AVFormatContext *s, <nl>          if (ret != chunk_size) <nl>              return AVERROR(EIO); <nl>   <nl> +        if (st->codecpar->channels <= 0) { <nl> +            av_log(s, AV_LOG_ERROR, "invalid number of channels %d\n", <nl> +                   st->codecpar->channels); <nl> +            return AVERROR_INVALIDDATA; <nl> +        } <nl> + <nl>          /* 2 samples/byte, 1 or 2 samples per frame depending on stereo */ <nl>          pkt->duration = (chunk_size * 2) / st->codecpar->channels; <nl>      }
@@ -1103,7 +1103,7 @@ int ff_rtsp_make_setup_request(AVFormatContext *s, const char *host, int port, <nl>                                int lower_transport, const char *real_challenge) <nl>  { <nl>      RTSPState *rt = s->priv_data; <nl> -    int rtx, j, i, err, interleave = 0; <nl> +    int rtx = 0, j, i, err, interleave = 0; <nl>      RTSPStream *rtsp_st; <nl>      RTSPMessageHeader reply1, *reply = &reply1; <nl>      char cmd[2048];
@@ -576,7 +576,7 @@ static int aac_encode_frame(AVCodecContext *avctx, AVPacket *avpkt, <nl>          } <nl>          start_ch += chans; <nl>      } <nl> -    if ((ret = ff_alloc_packet2(avctx, avpkt, 768 * s->channels))) { <nl> +    if ((ret = ff_alloc_packet2(avctx, avpkt, 8192 * s->channels))) { <nl>          av_log(avctx, AV_LOG_ERROR, "Error getting output packet\n"); <nl>          return ret; <nl>      }
@@ -157,7 +157,7 @@ static int mp3_write_xing(AVFormatContext *s) <nl>      } <nl>   <nl>      /* dummy MPEG audio header */ <nl> -    header  =  0xff                                  << 24; // sync <nl> +    header  =  0xffU                                 << 24; // sync <nl>      header |= (0x7 << 5 | ver << 3 | 0x1 << 1 | 0x1) << 16; // sync/audio-version/layer 3/no crc*/ <nl>      header |= (srate_idx << 2) <<  8; <nl>      header |= channels << 6;
@@ -106,8 +106,8 @@ static int xa_read_packet(AVFormatContext *s, <nl>      packet_size = 15*st->codec->channels; <nl>   <nl>      ret = av_get_packet(pb, pkt, packet_size); <nl> -    if(ret != packet_size) <nl> -        return AVERROR(EIO); <nl> +    if(ret < 0) <nl> +        return ret; <nl>   <nl>      pkt->stream_index = st->index; <nl>      xa->sent_bytes += packet_size;
@@ -372,7 +372,7 @@ int main(int argc, char **argv){ <nl>              sse= sum_aa + sum_bb - 2*sum_ab; <nl>              if(sse < 0 && sse > -0.00001) sse=0; //fix rounding error <nl>   <nl> -            fprintf(stderr, "[e:%f c:%f max:%f] len:%5d\n", sqrt(sse/out_count), sum_ab/(sqrt(sum_aa*sum_bb)), maxdiff, out_count); <nl> +            fprintf(stderr, "[e:%f c:%f max:%f] len:%5d\n", out_count ? sqrt(sse/out_count) : 0, sum_ab/(sqrt(sum_aa*sum_bb)), maxdiff, out_count); <nl>          } <nl>   <nl>          flush_i++;
@@ -257,7 +257,6 @@ static int scale_vector(int16_t *dst, const int16_t *vector, int length) <nl>      for (i = 0; i < length; i++) <nl>          max |= FFABS(vector[i]); <nl>   <nl> -    max   = FFMIN(max, 0x7FFF); <nl>      bits  = normalize_bits(max, 15); <nl>   <nl>      if (bits == 15)
@@ -285,9 +285,10 @@ static int packed_16bpc_bswap(SwsContext *c, const uint8_t *src[], <nl>      int dststr = dstStride[0] >> 1; <nl>      uint16_t       *dstPtr =       (uint16_t *) dst[0]; <nl>      const uint16_t *srcPtr = (const uint16_t *) src[0]; <nl> +    int min_stride         = FFMIN(srcstr, dststr); <nl>   <nl>      for (i = 0; i < srcSliceH; i++) { <nl> -        for (j = 0; j < srcstr; j++) { <nl> +        for (j = 0; j < min_stride; j++) { <nl>              dstPtr[j] = av_bswap16(srcPtr[j]); <nl>          } <nl>          srcPtr += srcstr;
@@ -5794,6 +5794,7 @@ static int mov_read_close(AVFormatContext *s) <nl>      av_freep(&mov->fragment_index_data); <nl>   <nl>      av_freep(&mov->aes_decrypt); <nl> +    av_freep(&mov->chapter_tracks); <nl>   <nl>      return 0; <nl>  }
@@ -30,6 +30,7 @@ <nl>  #include <stdlib.h> <nl>  #include <errno.h> <nl>  #include <limits.h> <nl> +#include <stdatomic.h> <nl>  #include <stdint.h> <nl>   <nl>  #if HAVE_IO_H <nl> @@ -319,7 +320,7 @@ void term_exit(void) <nl>   <nl>  static volatile int received_sigterm = 0; <nl>  static volatile int received_nb_signals = 0; <nl> -static volatile int transcode_init_done = 0; <nl> +static atomic_int transcode_init_done = ATOMIC_VAR_INIT(0); <nl>  static volatile int ffmpeg_exited = 0; <nl>  static int main_return_code = 0; <nl>   <nl> @@ -457,7 +458,7 @@ static int read_key(void) <nl>   <nl>  static int decode_interrupt_cb(void *ctx) <nl>  { <nl> -    return received_nb_signals > transcode_init_done; <nl> +    return received_nb_signals > atomic_load(&transcode_init_done); <nl>  } <nl>   <nl>  const AVIOInterruptCB int_cb = { decode_interrupt_cb, NULL }; <nl> @@ -612,7 +613,7 @@ static void ffmpeg_cleanup(int ret) <nl>      if (received_sigterm) { <nl>          av_log(NULL, AV_LOG_INFO, "Exiting normally, received signal %d.\n", <nl>                 (int) received_sigterm); <nl> -    } else if (ret && transcode_init_done) { <nl> +    } else if (ret && atomic_load(&transcode_init_done)) { <nl>          av_log(NULL, AV_LOG_INFO, "Conversion failed!\n"); <nl>      } <nl>      term_exit(); <nl> @@ -3758,7 +3759,7 @@ static int transcode_init(void) <nl>          return ret; <nl>      } <nl>   <nl> -    transcode_init_done = 1; <nl> +    atomic_store(&transcode_init_done, 1); <nl>   <nl>      return 0; <nl>  }
@@ -112,12 +112,12 @@ static int fraps2_decode_plane(FrapsContext *s, uint8_t *dst, int stride, int w, <nl>               */ <nl>              if(j) dst[i] += dst[i - stride]; <nl>              else if(Uoff) dst[i] += 0x80; <nl> +            if(get_bits_left(&gb) < 0){ <nl> +                free_vlc(&vlc); <nl> +                return -1; <nl> +            } <nl>          } <nl>          dst += stride; <nl> -        if(get_bits_left(&gb) < 0){ <nl> -            free_vlc(&vlc); <nl> -            return -1; <nl> -        } <nl>      } <nl>      free_vlc(&vlc); <nl>      return 0;
@@ -303,6 +303,11 @@ int ff_jni_init_jfields(JNIEnv *env, void *jfields, const struct FFJniField *jfi <nl>   <nl>              last_clazz = *(jclass*)((uint8_t*)jfields + jfields_mapping[i].offset) = <nl>                      global ? (*env)->NewGlobalRef(env, clazz) : clazz; <nl> + <nl> +            if (global) { <nl> +                (*env)->DeleteLocalRef(env, clazz); <nl> +            } <nl> + <nl>          } else { <nl>   <nl>              if (!last_clazz) {
@@ -124,6 +124,10 @@ static int pmp_packet(AVFormatContext *s, AVPacket *pkt) <nl>      if (pmp->cur_stream == 0) { <nl>          int num_packets; <nl>          pmp->audio_packets = avio_r8(pb); <nl> +        if (!pmp->audio_packets) { <nl> +            av_log_ask_for_sample(s, "0 audio packets\n"); <nl> +            return AVERROR_PATCHWELCOME; <nl> +        } <nl>          num_packets = (pmp->num_streams - 1) * pmp->audio_packets + 1; <nl>          avio_skip(pb, 8); <nl>          pmp->current_packet = 0;
@@ -1049,7 +1049,7 @@ static int svq3_decode_frame(AVCodecContext *avctx, <nl>              } else if (s->pict_type == AV_PICTURE_TYPE_B && mb_type >= 4) { <nl>                  mb_type += 4; <nl>              } <nl> -            if (mb_type > 33 || svq3_decode_mb(svq3, mb_type)) { <nl> +            if ((unsigned)mb_type > 33 || svq3_decode_mb(svq3, mb_type)) { <nl>                  av_log(h->s.avctx, AV_LOG_ERROR, "error while decoding MB %d %d\n", s->mb_x, s->mb_y); <nl>                  return -1; <nl>              }
@@ -80,7 +80,7 @@ static void picmemset(PicContext *s, AVFrame *frame, int value, int run, <nl>                     value <<= bits_per_plane; <nl>                     mask  <<= bits_per_plane; <nl>                     if (*plane >= s->nb_planes) <nl> -                       break; <nl> +                       return; <nl>                  } <nl>              } <nl>          } <nl> @@ -236,7 +236,7 @@ static int decode_frame(AVCodecContext *avctx, <nl>              } <nl>          } <nl>   <nl> -        if (x < avctx->width) { <nl> +        if (plane < s->nb_planes && x < avctx->width) { <nl>              int run = (y + 1) * avctx->width - x; <nl>              if (bits_per_plane == 8) <nl>                  picmemset_8bpp(s, frame, val, run, &x, &y);
@@ -5514,7 +5514,7 @@ static void vc1_sprite_flush(AVCodecContext *avctx) <nl>         Since we can't enforce it, clear to black the missing sprite. This is <nl>         wrong but it looks better than doing nothing. */ <nl>   <nl> -    if (f->data[0]) <nl> +    if (f && f->data[0]) <nl>          for (plane = 0; plane < (s->flags&CODEC_FLAG_GRAY ? 1 : 3); plane++) <nl>              for (i = 0; i < v->sprite_height>>!!plane; i++) <nl>                  memset(f->data[plane] + i * f->linesize[plane],
@@ -2355,6 +2355,9 @@ int avformat_find_stream_info(AVFormatContext *ic, AVDictionary **options) <nl>                  int      best_fps = 0; <nl>                  double best_error = 0.01; <nl>   <nl> +                if (delta_dts     >= INT64_MAX / st->time_base.num || <nl> +                    delta_packets >= INT64_MAX / st->time_base.den) <nl> +                    continue; <nl>                  av_reduce(&st->avg_frame_rate.num, &st->avg_frame_rate.den, <nl>                            delta_packets*(int64_t)st->time_base.den, <nl>                            delta_dts*(int64_t)st->time_base.num, 60000);
@@ -208,6 +208,9 @@ static int msmpeg4v34_decode_mb(MpegEncContext *s, int16_t block[6][64]) <nl>      uint8_t *coded_val; <nl>      uint32_t * const mb_type_ptr = &s->current_picture.mb_type[s->mb_x + s->mb_y*s->mb_stride]; <nl>   <nl> +    if (get_bits_left(&s->gb) <= 0) <nl> +        return AVERROR_INVALIDDATA; <nl> + <nl>      if (s->pict_type == AV_PICTURE_TYPE_P) { <nl>          if (s->use_skip_mb_code) { <nl>              if (get_bits1(&s->gb)) {
@@ -776,7 +776,7 @@ static void reset_codec(WmallDecodeCtx *s) <nl>      s->mclms_recent = s->mclms_order * s->num_channels; <nl>      for (ich = 0; ich < s->num_channels; ich++) { <nl>          for (ilms = 0; ilms < s->cdlms_ttl[ich]; ilms++) <nl> -            s->cdlms[ich][ilms].recent = s->cdlms[ich][ilms].order; <nl> +            s->cdlms[ich][ilms].recent = s->cdlms[ich][ilms].order - 1; <nl>          /* first sample of a seekable subframe is considered as the starting of <nl>             a transient area which is samples_per_frame samples long */ <nl>          s->channel[ich].transient_counter = s->samples_per_frame;
@@ -155,7 +155,7 @@ static void fix_bitshift(ShortenContext *s, int32_t *buffer) <nl>   <nl>      if (s->bitshift != 0) <nl>          for (i = 0; i < s->blocksize; i++) <nl> -            buffer[s->nwrap + i] <<= s->bitshift; <nl> +            buffer[i] <<= s->bitshift; <nl>  } <nl>   <nl>  
@@ -307,8 +307,10 @@ static int dxva2_map_frame(AVHWFramesContext *ctx, AVFrame *dst, const AVFrame * <nl>      } <nl>   <nl>      map = av_mallocz(sizeof(*map)); <nl> -    if (!map) <nl> +    if (!map) { <nl> +        err = AVERROR(ENOMEM); <nl>          goto fail; <nl> +    } <nl>   <nl>      err = ff_hwframe_map_create(src->hw_frames_ctx, dst, src, <nl>                                  dxva2_unmap_frame, map);
@@ -75,6 +75,7 @@ typedef struct GifState { <nl>   <nl>      AVCodecContext *avctx; <nl>      int keyframe; <nl> +    int keyframe_ok; <nl>      int trans_color;    /**< color value that is used instead of transparent color */ <nl>  } GifState; <nl>   <nl> @@ -472,6 +473,7 @@ static int gif_decode_frame(AVCodecContext *avctx, void *data, int *got_frame, A <nl>      } <nl>   <nl>      if (s->keyframe) { <nl> +        s->keyframe_ok = 0; <nl>          if ((ret = gif_read_header1(s)) < 0) <nl>              return ret; <nl>   <nl> @@ -489,7 +491,13 @@ static int gif_decode_frame(AVCodecContext *avctx, void *data, int *got_frame, A <nl>   <nl>          s->picture.pict_type = AV_PICTURE_TYPE_I; <nl>          s->picture.key_frame = 1; <nl> +        s->keyframe_ok = 1; <nl>      } else { <nl> +        if (!s->keyframe_ok) { <nl> +            av_log(avctx, AV_LOG_ERROR, "cannot decode frame without keyframe\n"); <nl> +            return AVERROR_INVALIDDATA; <nl> +        } <nl> + <nl>          if ((ret = avctx->reget_buffer(avctx, &s->picture)) < 0) { <nl>              av_log(avctx, AV_LOG_ERROR, "reget_buffer() failed\n"); <nl>              return ret;
@@ -1074,8 +1074,8 @@ static int mkv_write_chapters(AVFormatContext *s) <nl>      for (i = 0; i < s->nb_chapters; i++) { <nl>          ebml_master chapteratom, chapterdisplay; <nl>          AVChapter *c     = s->chapters[i]; <nl> -        int chapterstart = av_rescale_q(c->start, c->time_base, scale); <nl> -        int chapterend   = av_rescale_q(c->end,   c->time_base, scale); <nl> +        int64_t chapterstart = av_rescale_q(c->start, c->time_base, scale); <nl> +        int64_t chapterend   = av_rescale_q(c->end,   c->time_base, scale); <nl>          AVDictionaryEntry *t = NULL; <nl>          if (chapterstart < 0 || chapterstart > chapterend) <nl>              return AVERROR_INVALIDDATA;
@@ -439,7 +439,7 @@ static int decode_ga_specific_config(AACContext *ac, GetBitContext *gb, <nl>   * @param   data        pointer to AVCodecContext extradata <nl>   * @param   data_size   size of AVCCodecContext extradata <nl>   * <nl> - * @return  Returns error status. 0 - OK, !0 - error <nl> + * @return  Returns error status or number of consumed bits. <0 - error <nl>   */ <nl>  static int decode_audio_specific_config(AACContext *ac, <nl>                                          MPEG4AudioConfig *m4ac, void *data, <nl> @@ -473,7 +473,7 @@ static int decode_audio_specific_config(AACContext *ac, <nl>          return -1; <nl>      } <nl>   <nl> -    return 0; <nl> +    return get_bits_count(&gb); <nl>  } <nl>   <nl>  /**
@@ -721,11 +721,15 @@ static int iff_read_packet(AVFormatContext *s, <nl>          if (st->codec->codec_tag == ID_DSD || st->codec->codec_tag == ID_MAUD) { <nl>              ret = av_get_packet(pb, pkt, FFMIN(iff->body_end - pos, 1024 * st->codec->block_align)); <nl>          } else { <nl> +            if (iff->body_size > INT_MAX) <nl> +                return AVERROR_INVALIDDATA; <nl>              ret = av_get_packet(pb, pkt, iff->body_size); <nl>          } <nl>      } else if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) { <nl>          uint8_t *buf; <nl>   <nl> +        if (iff->body_size > INT_MAX - 2) <nl> +            return AVERROR_INVALIDDATA; <nl>          if (av_new_packet(pkt, iff->body_size + 2) < 0) { <nl>              return AVERROR(ENOMEM); <nl>          }
@@ -2566,6 +2566,7 @@ int ff_mpeg4_decode_picture_header(Mpeg4DecContext *ctx, GetBitContext *gb) <nl>      MpegEncContext *s = &ctx->m; <nl>      unsigned startcode, v; <nl>      int ret; <nl> +    int vol = 0; <nl>   <nl>      /* search next start code */ <nl>      align_get_bits(gb); <nl> @@ -2654,6 +2655,11 @@ int ff_mpeg4_decode_picture_header(Mpeg4DecContext *ctx, GetBitContext *gb) <nl>          } <nl>   <nl>          if (startcode >= 0x120 && startcode <= 0x12F) { <nl> +            if (vol) { <nl> +                av_log(s->avctx, AV_LOG_ERROR, "Multiple VOL headers"); <nl> +                return AVERROR_INVALIDDATA; <nl> +            } <nl> +            vol++; <nl>              if ((ret = decode_vol_header(ctx, gb)) < 0) <nl>                  return ret; <nl>          } else if (startcode == USER_DATA_STARTCODE) {
@@ -224,7 +224,7 @@ int ff_jpeg2000_init_component(Jpeg2000Component *comp, <nl>          if (!comp->i_data) <nl>              return AVERROR(ENOMEM); <nl>      } <nl> -    comp->reslevel = av_malloc_array(codsty->nreslevels, sizeof(*comp->reslevel)); <nl> +    comp->reslevel = av_calloc(codsty->nreslevels, sizeof(*comp->reslevel)); <nl>      if (!comp->reslevel) <nl>          return AVERROR(ENOMEM); <nl>      /* LOOP on resolution levels */
@@ -1825,7 +1825,7 @@ static int h264_slice_header_parse(const H264Context *h, H264SliceContext *sl, <nl>      } <nl>   <nl>      sl->last_qscale_diff = 0; <nl> -    tmp = pps->init_qp + get_se_golomb(&sl->gb); <nl> +    tmp = pps->init_qp + (unsigned)get_se_golomb(&sl->gb); <nl>      if (tmp > 51 + 6 * (sps->bit_depth_luma - 8)) { <nl>          av_log(h->avctx, AV_LOG_ERROR, "QP %u out of range\n", tmp); <nl>          return AVERROR_INVALIDDATA;
@@ -82,8 +82,8 @@ static int diff_MMX(unsigned char *old, unsigned char *new, int os, int ns) <nl>  static int diff_C(unsigned char *old, unsigned char *new, int os, int ns) <nl>  { <nl>      int x, y, d=0; <nl> -    for (y = 8; y; y--) { <nl> -        for (x = 8; x; x--) { <nl> +    for (y = 0; y < 8; y++) { <nl> +        for (x = 0; x < 8; x++) { <nl>              d += abs(new[x] - old[x]); <nl>          } <nl>          new += ns;
@@ -1547,7 +1547,7 @@ AVCodec mjpeg_decoder = { <nl>      ff_mjpeg_decode_frame, <nl>      CODEC_CAP_DR1, <nl>      NULL, <nl> -    .max_lowres = 8, <nl> +    .max_lowres = 4, <nl>      .long_name = NULL_IF_CONFIG_SMALL("MJPEG (Motion JPEG)"), <nl>  }; <nl>  
@@ -88,14 +88,14 @@ static inline void s_zero(int cur_diff, struct G722Band *band) <nl>          ACCUM(3, band->diff_mem[2], 1); <nl>          ACCUM(2, band->diff_mem[1], 1); <nl>          ACCUM(1, band->diff_mem[0], 1); <nl> -        ACCUM(0, cur_diff << 1, 1); <nl> +        ACCUM(0, cur_diff * 2, 1); <nl>      } else { <nl>          ACCUM(5, band->diff_mem[4], 0); <nl>          ACCUM(4, band->diff_mem[3], 0); <nl>          ACCUM(3, band->diff_mem[2], 0); <nl>          ACCUM(2, band->diff_mem[1], 0); <nl>          ACCUM(1, band->diff_mem[0], 0); <nl> -        ACCUM(0, cur_diff << 1, 0); <nl> +        ACCUM(0, cur_diff * 2, 0); <nl>      } <nl>      #undef ACCUM <nl>      band->s_zero = s_zero; <nl> @@ -119,14 +119,14 @@ static void do_adaptive_prediction(struct G722Band *band, const int cur_diff) <nl>      band->part_reconst_mem[0] = cur_part_reconst; <nl>   <nl>      band->pole_mem[1] = av_clip((sg[0] * av_clip(band->pole_mem[0], -8191, 8191) >> 5) + <nl> -                                (sg[1] << 7) + (band->pole_mem[1] * 127 >> 7), -12288, 12288); <nl> +                                (sg[1] * 128) + (band->pole_mem[1] * 127 >> 7), -12288, 12288); <nl>   <nl>      limit = 15360 - band->pole_mem[1]; <nl>      band->pole_mem[0] = av_clip(-192 * sg[0] + (band->pole_mem[0] * 255 >> 8), -limit, limit); <nl>   <nl>      s_zero(cur_diff, band); <nl>   <nl> -    cur_qtzd_reconst = av_clip_int16((band->s_predictor + cur_diff) << 1); <nl> +    cur_qtzd_reconst = av_clip_int16((band->s_predictor + cur_diff) * 2); <nl>      band->s_predictor = av_clip_int16(band->s_zero + <nl>                                        (band->pole_mem[0] * cur_qtzd_reconst >> 15) + <nl>                                        (band->pole_mem[1] * band->prev_qtzd_reconst >> 15));
@@ -200,6 +200,12 @@ static int xwma_read_header(AVFormatContext *s) <nl>   <nl>          /* Estimate the duration from the total number of output bytes. */ <nl>          const uint64_t total_decoded_bytes = dpds_table[dpds_table_size - 1]; <nl> + <nl> +        if(!bytes_per_sample) { <nl> +            av_log(s, AV_LOG_ERROR, "bytes_per_sample is 0\n"); <nl> +            return AVERROR_INVALIDDATA; <nl> +        } <nl> + <nl>          st->duration = total_decoded_bytes / bytes_per_sample; <nl>   <nl>          /* Use the dpds data to build a seek table.  We can only do this after
@@ -452,7 +452,7 @@ static inline int decode_subframe(FLACContext *s, int channel) <nl>      if (wasted) { <nl>          int i; <nl>          for (i = 0; i < s->blocksize; i++) <nl> -            decoded[i] <<= wasted; <nl> +            decoded[i] = (unsigned)decoded[i] << wasted; <nl>      } <nl>   <nl>      return 0;
@@ -368,13 +368,13 @@ static int mkv_add_cuepoint(mkv_cues *cues, int stream, int64_t ts, int64_t clus <nl>  { <nl>      mkv_cuepoint *entries = cues->entries; <nl>   <nl> +    if (ts < 0) <nl> +        return 0; <nl> + <nl>      entries = av_realloc(entries, (cues->num_entries + 1) * sizeof(mkv_cuepoint)); <nl>      if (entries == NULL) <nl>          return AVERROR(ENOMEM); <nl>   <nl> -    if (ts < 0) <nl> -        return 0; <nl> - <nl>      entries[cues->num_entries  ].pts = ts; <nl>      entries[cues->num_entries  ].tracknum = stream + 1; <nl>      entries[cues->num_entries++].cluster_pos = cluster_pos - cues->segment_offset;
@@ -1757,8 +1757,13 @@ static void estimate_timings_from_bit_rate(AVFormatContext *ic) <nl>          int bit_rate = 0; <nl>          for(i=0;i<ic->nb_streams;i++) { <nl>              st = ic->streams[i]; <nl> -            if (st->codec->bit_rate > 0) <nl> -            bit_rate += st->codec->bit_rate; <nl> +            if (st->codec->bit_rate > 0) { <nl> +                if (INT_MAX - st->codec->bit_rate > bit_rate) { <nl> +                    bit_rate = 0; <nl> +                    break; <nl> +                } <nl> +                bit_rate += st->codec->bit_rate; <nl> +            } <nl>          } <nl>          ic->bit_rate = bit_rate; <nl>      }
@@ -322,7 +322,7 @@ static int filter_frame(AVFilterLink *inlink, AVFrame *insamples) <nl>  static av_cold int init(AVFilterContext *ctx) <nl>  { <nl>      AMergeContext *s = ctx->priv; <nl> -    int i; <nl> +    int i, ret; <nl>   <nl>      s->in = av_calloc(s->nb_inputs, sizeof(*s->in)); <nl>      if (!s->in) <nl> @@ -336,7 +336,10 @@ static av_cold int init(AVFilterContext *ctx) <nl>          }; <nl>          if (!name) <nl>              return AVERROR(ENOMEM); <nl> -        ff_insert_inpad(ctx, i, &pad); <nl> +        if ((ret = ff_insert_inpad(ctx, i, &pad)) < 0) { <nl> +            av_freep(&pad.name); <nl> +            return ret; <nl> +        } <nl>      } <nl>      return 0; <nl>  }
@@ -61,7 +61,7 @@ static int skeleton_header(AVFormatContext *s, int idx) <nl>          start_num = AV_RL64(buf+12); <nl>          start_den = AV_RL64(buf+20); <nl>   <nl> -        if (start_den) { <nl> +        if (start_den > 0 && start_num > 0) { <nl>              int base_den; <nl>              av_reduce(&start_time, &base_den, start_num, start_den, INT_MAX); <nl>              avpriv_set_pts_info(st, 64, 1, base_den);
@@ -71,6 +71,7 @@ static void mpeg_er_decode_mb(void *opaque, int ref, int mv_dir, int mv_type, <nl>      s->mb_skipped = mb_skipped; <nl>      s->mb_x       = mb_x; <nl>      s->mb_y       = mb_y; <nl> +    s->mcsel      = 0; <nl>      memcpy(s->mv, mv, sizeof(*mv)); <nl>   <nl>      ff_init_block_index(s);
@@ -113,7 +113,7 @@ static int film_read_header(AVFormatContext *s) <nl>          film->audio_samplerate = AV_RB16(&scratch[24]); <nl>          film->audio_channels = scratch[21]; <nl>          film->audio_bits = scratch[22]; <nl> -        if (scratch[23] == 2) <nl> +        if (scratch[23] == 2 && film->audio_channels > 0) <nl>              film->audio_type = AV_CODEC_ID_ADPCM_ADX; <nl>          else if (film->audio_channels > 0) { <nl>              if (film->audio_bits == 8)
@@ -99,8 +99,11 @@ static int get_stats(AVCodecContext *avctx, int eos) <nl>          return AVERROR_EXTERNAL; <nl>      } <nl>      if (!eos) { <nl> -        h->stats = av_fast_realloc(h->stats, &h->stats_size, <nl> +        void *tmp = av_fast_realloc(h->stats, &h->stats_size, <nl>                                     h->stats_offset + bytes); <nl> +        if (!tmp) <nl> +            return AVERROR(ENOMEM); <nl> +        h->stats = tmp; <nl>          memcpy(h->stats + h->stats_offset, buf, bytes); <nl>          h->stats_offset += bytes; <nl>      } else {
@@ -1092,6 +1092,7 @@ static int jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile, <nl>      if (s->precision <= 8) { <nl>          for (compno = 0; compno < s->ncomponents; compno++) { <nl>              Jpeg2000Component *comp = tile->comp + compno; <nl> +            Jpeg2000CodingStyle *codsty = tile->codsty + compno; <nl>              float *datap = comp->f_data; <nl>              int32_t *i_datap = comp->i_data; <nl>              int cbps = s->cbps[compno]; <nl> @@ -1105,7 +1106,7 @@ static int jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile, <nl>                  x   = tile->comp[compno].coord[0][0] - s->image_offset_x; <nl>                  dst = line + x * s->ncomponents + compno; <nl>   <nl> -                if (tile->codsty->transform == FF_DWT97) { <nl> +                if (codsty->transform == FF_DWT97) { <nl>                      for (; x < w; x += s->cdx[compno]) { <nl>                          int val = lrintf(*datap) + (1 << (cbps - 1)); <nl>                          /* DC level shift and clip see ISO 15444-1:2002 G.1.2 */ <nl> @@ -1130,6 +1131,7 @@ static int jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile, <nl>      } else { <nl>          for (compno = 0; compno < s->ncomponents; compno++) { <nl>              Jpeg2000Component *comp = tile->comp + compno; <nl> +            Jpeg2000CodingStyle *codsty = tile->codsty + compno; <nl>              float *datap = comp->f_data; <nl>              int32_t *i_datap = comp->i_data; <nl>              uint16_t *linel; <nl> @@ -1143,7 +1145,7 @@ static int jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile, <nl>   <nl>                  x   = tile->comp[compno].coord[0][0] - s->image_offset_x; <nl>                  dst = linel + (x * s->ncomponents + compno); <nl> -                if (tile->codsty->transform == FF_DWT97) { <nl> +                if (codsty->transform == FF_DWT97) { <nl>                      for (; x < w; x += s-> cdx[compno]) { <nl>                          int  val = lrintf(*datap) + (1 << (cbps - 1)); <nl>                          /* DC level shift and clip see ISO 15444-1:2002 G.1.2 */
@@ -237,6 +237,8 @@ static int dnxhd_write_header(AVCodecContext *avctx, uint8_t *buf) <nl>      DNXHDEncContext *ctx = avctx->priv_data; <nl>      const uint8_t header_prefix[5] = { 0x00,0x00,0x02,0x80,0x01 }; <nl>   <nl> +    memset(buf, 0, 640); <nl> + <nl>      memcpy(buf, header_prefix, 5); <nl>      buf[5] = ctx->interlaced ? ctx->cur_field+2 : 0x01; <nl>      buf[6] = 0x80; // crc flag off <nl> @@ -753,6 +755,9 @@ static int dnxhd_encode_picture(AVCodecContext *avctx, unsigned char *buf, int b <nl>   <nl>      avctx->execute(avctx, dnxhd_encode_thread, (void**)&ctx->thread[0], NULL, avctx->thread_count, sizeof(void*)); <nl>   <nl> +    assert(640 + offset + 4 <= ctx->cid_table->coding_unit_size); <nl> +    memset(buf + 640 + offset, 0, ctx->cid_table->coding_unit_size - 4 - offset - 640); <nl> + <nl>      AV_WB32(buf + ctx->cid_table->coding_unit_size - 4, 0x600DC0DE); // EOF <nl>   <nl>      if (ctx->interlaced && first_field) {
@@ -1428,8 +1428,7 @@ static int decode_header(EXRContext *s) <nl>                      return AVERROR_PATCHWELCOME; <nl>                  } <nl>   <nl> -                if (s->channel_offsets[channel_index] == -1){/* channel have not been previously assign */ <nl> -                    if (channel_index >= 0) { <nl> +                if (channel_index >= 0 && s->channel_offsets[channel_index] == -1) { /* channel has not been previously assigned */ <nl>                          if (s->pixel_type != EXR_UNKNOWN && <nl>                              s->pixel_type != current_pixel_type) { <nl>                              av_log(s->avctx, AV_LOG_ERROR, <nl> @@ -1438,7 +1437,6 @@ static int decode_header(EXRContext *s) <nl>                          } <nl>                          s->pixel_type                     = current_pixel_type; <nl>                          s->channel_offsets[channel_index] = s->current_channel_offset; <nl> -                    } <nl>                  } <nl>   <nl>                  s->channels = av_realloc(s->channels,
@@ -1022,17 +1022,19 @@ static int showspectrumpic_request_frame(AVFilterLink *outlink) <nl>      AVFilterContext *ctx = outlink->src; <nl>      ShowSpectrumContext *s = ctx->priv; <nl>      AVFilterLink *inlink = ctx->inputs[0]; <nl> -    int ret; <nl> +    int ret, samples; <nl>   <nl>      ret = ff_request_frame(inlink); <nl> -    if (ret == AVERROR_EOF && s->outpicref) { <nl> -        int samples = av_audio_fifo_size(s->fifo); <nl> +    samples = av_audio_fifo_size(s->fifo); <nl> +    if (ret == AVERROR_EOF && s->outpicref && samples > 0) { <nl>          int consumed = 0; <nl>          int y, x = 0, sz = s->orientation == VERTICAL ? s->w : s->h; <nl>          int ch, spf, spb; <nl>          AVFrame *fin; <nl>   <nl>          spf = s->win_size * (samples / ((s->win_size * sz) * ceil(samples / (float)(s->win_size * sz)))); <nl> +        spf = FFMAX(1, spf); <nl> + <nl>          spb = (samples / (spf * sz)) * spf; <nl>   <nl>          fin = ff_get_audio_buffer(inlink, s->win_size);
@@ -263,10 +263,14 @@ static av_cold int tta_decode_init(AVCodecContext * avctx) <nl>   <nl>          if (s->bps == 2) { <nl>              s->decode_buffer = av_mallocz(sizeof(int32_t)*s->frame_length*s->channels); <nl> +            if (!s->decode_buffer) <nl> +                return AVERROR(ENOMEM); <nl>          } <nl>          s->ch_ctx = av_malloc(avctx->channels * sizeof(*s->ch_ctx)); <nl> -        if (!s->ch_ctx) <nl> +        if (!s->ch_ctx) { <nl> +            av_freep(&s->decode_buffer); <nl>              return AVERROR(ENOMEM); <nl> +        } <nl>      } else { <nl>          av_log(avctx, AV_LOG_ERROR, "Wrong extradata present\n"); <nl>          return -1;
@@ -385,7 +385,7 @@ static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc, in <nl>      if(s->extra_bits){ <nl>          S <<= s->extra_bits; <nl>   <nl> -        if(s->got_extra_bits){ <nl> +        if(s->got_extra_bits && get_bits_left(&s->gb_extra_bits) >= s->extra_bits){ <nl>              S |= get_bits(&s->gb_extra_bits, s->extra_bits); <nl>              *crc = *crc * 9 + (S&0xffff) * 3 + ((unsigned)S>>16); <nl>          }
@@ -109,6 +109,10 @@ static int read_header(AVFormatContext *s) <nl>          avio_skip(pb, 5); <nl>   <nl>          ico->images[i].size   = avio_rl32(pb); <nl> +        if (ico->images[i].size <= 0) { <nl> +            av_log(s, AV_LOG_ERROR, "Invalid image size %d\n", ico->images[i].size); <nl> +            return AVERROR_INVALIDDATA; <nl> +        } <nl>          ico->images[i].offset = avio_rl32(pb); <nl>   <nl>          if (avio_seek(pb, ico->images[i].offset, SEEK_SET) < 0) <nl> @@ -174,9 +178,9 @@ static int read_packet(AVFormatContext *s, AVPacket *pkt) <nl>          bytestream_put_le16(&buf, 0); <nl>          bytestream_put_le32(&buf, 0); <nl>   <nl> -        if ((ret = avio_read(pb, buf, image->size)) < 0) { <nl> +        if ((ret = avio_read(pb, buf, image->size)) != image->size) { <nl>              av_packet_unref(pkt); <nl> -            return ret; <nl> +            return ret < 0 ? ret : AVERROR_INVALIDDATA; <nl>          } <nl>   <nl>          st->codecpar->bits_per_coded_sample = AV_RL16(buf + 14);
@@ -417,7 +417,7 @@ static int encode_plane(AVCodecContext *avctx, uint8_t *src, <nl>          /* If non-zero count is found, see if it matches width * height */ <nl>          if (counts[symbol]) { <nl>              /* Special case if only one symbol was used */ <nl> -            if (counts[symbol] == width * height) { <nl> +            if (counts[symbol] == width * (int64_t)height) { <nl>                  /* <nl>                   * Write a zero for the single symbol <nl>                   * used in the plane, else 0xFF.
@@ -3103,7 +3103,8 @@ static int transcode_init(void) <nl>                      ost->filter->filter->inputs[0]->sample_aspect_ratio; <nl>                  codec->pix_fmt = ost->filter->filter->inputs[0]->format; <nl>   <nl> -                if (codec->width   != icodec->width  || <nl> +                if (!icodec || <nl> +                    codec->width   != icodec->width  || <nl>                      codec->height  != icodec->height || <nl>                      codec->pix_fmt != icodec->pix_fmt) { <nl>                      codec->bits_per_raw_sample = frame_bits_per_raw_sample;
@@ -294,8 +294,6 @@ av_cold int ff_dvvideo_init(AVCodecContext *avctx) <nl>              ff_dv_rl_vlc[i].run   = run; <nl>          } <nl>          ff_free_vlc(&dv_vlc); <nl> - <nl> -        dv_vlc_map_tableinit(); <nl>      } <nl>   <nl>      /* Generic DSP setup */ <nl> @@ -338,6 +336,8 @@ static av_cold int dvvideo_init_encoder(AVCodecContext *avctx) <nl>          return AVERROR(EINVAL); <nl>      } <nl>   <nl> +    dv_vlc_map_tableinit(); <nl> + <nl>      return ff_dvvideo_init(avctx); <nl>  } <nl>  
@@ -228,7 +228,7 @@ static int mpc7_decode_frame(AVCodecContext * avctx, void *data, <nl>      buf_size  -= 4; <nl>   <nl>      /* get output buffer */ <nl> -    c->frame.nb_samples = last_frame ? c->lastframelen : MPC_FRAME_SIZE; <nl> +    c->frame.nb_samples = MPC_FRAME_SIZE; <nl>      if ((ret = avctx->get_buffer(avctx, &c->frame)) < 0) { <nl>          av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n"); <nl>          return ret; <nl> @@ -298,6 +298,8 @@ static int mpc7_decode_frame(AVCodecContext * avctx, void *data, <nl>              idx_to_quant(c, &gb, bands[i].res[ch], c->Q[ch] + off); <nl>   <nl>      ff_mpc_dequantize_and_synth(c, mb, c->frame.data[0], 2); <nl> +    if(last_frame) <nl> +        c->frame.nb_samples = c->lastframelen; <nl>   <nl>      bits_used = get_bits_count(&gb); <nl>      bits_avail = buf_size * 8;
@@ -291,6 +291,10 @@ static int http_connect(URLContext *h, const char *path, const char *hoststr, <nl>      if (post) { <nl>          /* always use chunked encoding for upload data */ <nl>          s->chunksize = 0; <nl> +        /* Pretend that it did work. We didn't read any header yet, since <nl> +         * we've still to send the POST data, but the code calling this <nl> +         * function will check http_code after we return. */ <nl> +        s->http_code = 200; <nl>          return 0; <nl>      } <nl>  
@@ -89,6 +89,12 @@ static int adx_decode_header(AVCodecContext *avctx, const uint8_t *buf, <nl>      if (bufsize < offset || memcmp(buf + offset - 6, "(c)CRI", 6)) <nl>          return AVERROR_INVALIDDATA; <nl>   <nl> +    /* check for encoding=3 block_size=18, sample_size=4 */ <nl> +    if (buf[4] != 3 || buf[5] != 18 || buf[6] != 4) { <nl> +        av_log_ask_for_sample(avctx, "unsupported ADX format\n"); <nl> +        return AVERROR_PATCHWELCOME; <nl> +    } <nl> + <nl>      c->channels = avctx->channels = buf[7]; <nl>      if (avctx->channels > 2) <nl>          return AVERROR_INVALIDDATA;
@@ -686,8 +686,8 @@ static int tak_decode_frame(AVCodecContext *avctx, void *data, <nl>      if ((ret = ff_tak_decode_frame_header(avctx, gb, &s->ti, 0)) < 0) <nl>          return ret; <nl>   <nl> +    hsize = get_bits_count(gb) / 8; <nl>      if (avctx->err_recognition & (AV_EF_CRCCHECK|AV_EF_COMPLIANT)) { <nl> -        hsize = get_bits_count(gb) / 8; <nl>          if (ff_tak_check_crc(pkt->data, hsize)) { <nl>              av_log(avctx, AV_LOG_ERROR, "CRC error\n"); <nl>              if (avctx->err_recognition & AV_EF_EXPLODE)
@@ -35,6 +35,7 @@ <nl>  #include "libavutil/intreadwrite.h" <nl>  #include "libavutil/mathematics.h" <nl>  #include "dv.h" <nl> +#include "libavutil/avassert.h" <nl>   <nl>  struct DVDemuxContext { <nl>      const DVprofile*  sys;    /* Current DV profile. E.g.: 525/60, 625/50 */ <nl> @@ -130,15 +131,19 @@ static int dv_extract_audio(uint8_t* frame, uint8_t* ppcm[4], <nl>      /* We work with 720p frames split in half, thus even frames have <nl>       * channels 0,1 and odd 2,3. */ <nl>      ipcm = (sys->height == 720 && !(frame[1] & 0x0C)) ? 2 : 0; <nl> -    pcm  = ppcm[ipcm++]; <nl>   <nl>      /* for each DIF channel */ <nl>      for (chan = 0; chan < sys->n_difchan; chan++) { <nl> +        av_assert0(ipcm<4); <nl> +        pcm = ppcm[ipcm++]; <nl> +        if (!pcm) <nl> +            break; <nl>          /* for each DIF segment */ <nl>          for (i = 0; i < sys->difseg_size; i++) { <nl>              frame += 6 * 80; /* skip DIF segment header */ <nl>              if (quant == 1 && i == half_ch) { <nl>                  /* next stereo channel (12bit mode only) */ <nl> +                av_assert0(ipcm<4); <nl>                  pcm = ppcm[ipcm++]; <nl>                  if (!pcm) <nl>                      break; <nl> @@ -183,9 +188,6 @@ static int dv_extract_audio(uint8_t* frame, uint8_t* ppcm[4], <nl>          } <nl>   <nl>          /* next stereo channel (50Mbps and 100Mbps only) */ <nl> -        pcm = ppcm[ipcm++]; <nl> -        if (!pcm) <nl> -            break; <nl>      } <nl>   <nl>      return size;
@@ -34,6 +34,7 @@ <nl>  #include "libavdevice/avdevice.h" <nl>  #include "libavresample/avresample.h" <nl>  #include "libswscale/swscale.h" <nl> +#include "libavutil/avassert.h" <nl>  #include "libavutil/avstring.h" <nl>  #include "libavutil/mathematics.h" <nl>  #include "libavutil/parseutils.h" <nl> @@ -905,6 +906,7 @@ int check_stream_specifier(AVFormatContext *s, AVStream *st, const char *spec) <nl>          case 's': type = AVMEDIA_TYPE_SUBTITLE;   break; <nl>          case 'd': type = AVMEDIA_TYPE_DATA;       break; <nl>          case 't': type = AVMEDIA_TYPE_ATTACHMENT; break; <nl> +        default:  av_assert0(0); <nl>          } <nl>          if (type != st->codec->codec_type) <nl>              return 0;
@@ -93,9 +93,11 @@ static void mov_text_cleanup(MovTextContext *m) <nl>  static void mov_text_cleanup_ftab(MovTextContext *m) <nl>  { <nl>      int i; <nl> -    for(i = 0; i < m->count_f; i++) { <nl> -        av_freep(&m->ftab[i]->font); <nl> -        av_freep(&m->ftab[i]); <nl> +    if (m->ftab) { <nl> +        for(i = 0; i < m->count_f; i++) { <nl> +            av_freep(&m->ftab[i]->font); <nl> +            av_freep(&m->ftab[i]); <nl> +        } <nl>      } <nl>      av_freep(&m->ftab); <nl>  }
@@ -758,6 +758,8 @@ do {                                                                    \ <nl>              const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(frame->format); <nl>   <nl>              planes = av_pix_fmt_count_planes(frame->format); <nl> +            if (!planes) <nl> +                planes = 1; <nl>              if (!desc || planes <= 0) { <nl>                  ret = AVERROR(EINVAL); <nl>                  goto fail;
@@ -991,6 +991,8 @@ typedef struct AVStream { <nl>       * String containing pairs of key and values describing recommended encoder configuration. <nl>       * Pairs are separated by ','. <nl>       * Keys are separated from values by '='. <nl> +     * <nl> +     * @deprecated unused <nl>       */ <nl>      attribute_deprecated <nl>      char *recommended_encoder_configuration; <nl> @@ -1220,8 +1222,8 @@ attribute_deprecated <nl>  AVRational av_stream_get_r_frame_rate(const AVStream *s); <nl>  attribute_deprecated <nl>  void       av_stream_set_r_frame_rate(AVStream *s, AVRational r); <nl> -attribute_deprecated <nl>  #if FF_API_LAVF_FFSERVER <nl> +attribute_deprecated <nl>  char* av_stream_get_recommended_encoder_configuration(const AVStream *s); <nl>  attribute_deprecated <nl>  void  av_stream_set_recommended_encoder_configuration(AVStream *s, char *configuration);
@@ -319,7 +319,7 @@ static void draw_slice(AVFilterLink *inlink, int y, int h, int slice_dir) <nl>          } <nl>      } else { <nl>          /* planar */ <nl> -        for (plane = 0; inpic->data[plane]; plane++) { <nl> +        for (plane = 0; plane < 4 && inpic->data[plane]; plane++) { <nl>              int vsub = plane == 1 || plane == 2 ? lut->vsub : 0; <nl>              int hsub = plane == 1 || plane == 2 ? lut->hsub : 0; <nl>  
@@ -238,6 +238,11 @@ static int extract_header(AVCodecContext *const avctx, <nl>                  s->mask_buf = av_malloc((s->planesize * 32) + FF_INPUT_BUFFER_PADDING_SIZE); <nl>                  if (!s->mask_buf) <nl>                      return AVERROR(ENOMEM); <nl> +                if (s->bpp > 16) { <nl> +                    av_log(avctx, AV_LOG_ERROR, "bpp %d too large for palette\n", s->bpp); <nl> +                    av_freep(&s->mask_buf); <nl> +                    return AVERROR(ENOMEM); <nl> +                } <nl>                  s->mask_palbuf = av_malloc((2 << s->bpp) * sizeof(uint32_t) + FF_INPUT_BUFFER_PADDING_SIZE); <nl>                  if (!s->mask_palbuf) { <nl>                      av_freep(&s->mask_buf);
@@ -715,9 +715,10 @@ static int v4l2_read_close(AVFormatContext *s1) <nl>   <nl>  #define OFFSET(x) offsetof(struct video_data, x) <nl>  #define DEC AV_OPT_FLAG_DECODING_PARAM <nl> + <nl>  static const AVOption options[] = { <nl> -    { "standard", "", offsetof(struct video_data, standard), FF_OPT_TYPE_STRING, {.str = "NTSC" }, 0, 0, AV_OPT_FLAG_DECODING_PARAM }, <nl> -    { "channel",  "", offsetof(struct video_data, channel),  FF_OPT_TYPE_INT,    {.dbl = 0 }, 0, INT_MAX, AV_OPT_FLAG_DECODING_PARAM }, <nl> +    { "standard", "", OFFSET(standard), FF_OPT_TYPE_STRING, {.str = "NTSC" }, 0, 0, AV_OPT_FLAG_DECODING_PARAM }, <nl> +    { "channel",  "", OFFSET(channel),  FF_OPT_TYPE_INT,    {.dbl = 0 }, 0, INT_MAX, AV_OPT_FLAG_DECODING_PARAM }, <nl>      { "video_size", "A string describing frame size, such as 640x480 or hd720.", OFFSET(video_size), FF_OPT_TYPE_STRING, {.str = NULL}, 0, 0, DEC }, <nl>      { NULL }, <nl>  };
@@ -1122,7 +1122,7 @@ int ff_rtsp_send_cmd_with_content(AVFormatContext *s, <nl>  { <nl>      RTSPState *rt = s->priv_data; <nl>      HTTPAuthType cur_auth_type; <nl> -    int ret; <nl> +    int ret, attempts = 0; <nl>   <nl>  retry: <nl>      cur_auth_type = rt->auth_state.auth_type; <nl> @@ -1133,9 +1133,11 @@ retry: <nl>   <nl>      if ((ret = ff_rtsp_read_reply(s, reply, content_ptr, 0, method) ) < 0) <nl>          return ret; <nl> +    attempts++; <nl>   <nl> -    if (reply->status_code == 401 && cur_auth_type == HTTP_AUTH_NONE && <nl> -        rt->auth_state.auth_type != HTTP_AUTH_NONE) <nl> +    if (reply->status_code == 401 && <nl> +        (cur_auth_type == HTTP_AUTH_NONE || rt->auth_state.stale) && <nl> +        rt->auth_state.auth_type != HTTP_AUTH_NONE && attempts < 2) <nl>          goto retry; <nl>   <nl>      if (reply->status_code > 400){
@@ -1448,7 +1448,7 @@ static int g2m_decode_frame(AVCodecContext *avctx, void *data, <nl>              c->tile_height = bytestream2_get_be32(&bc); <nl>              if (c->tile_width <= 0 || c->tile_height <= 0 || <nl>                  ((c->tile_width | c->tile_height) & 0xF) || <nl> -                c->tile_width * 4LL * c->tile_height >= INT_MAX <nl> +                c->tile_width * (uint64_t)c->tile_height >= INT_MAX / 4 <nl>              ) { <nl>                  av_log(avctx, AV_LOG_ERROR, <nl>                         "Invalid tile dimensions %dx%d\n",
@@ -150,7 +150,7 @@ static int ac3_sync(uint64_t state, AACAC3ParseContext *hdr_info, <nl>      int err; <nl>      union { <nl>          uint64_t u64; <nl> -        uint8_t  u8[8]; <nl> +        uint8_t  u8[8 + FF_INPUT_BUFFER_PADDING_SIZE]; <nl>      } tmp = { av_be2ne64(state) }; <nl>      AC3HeaderInfo hdr; <nl>      GetBitContext gbc;
@@ -47,6 +47,7 @@ static int adts_aac_probe(AVProbeData *p) <nl>              fsize = (AV_RB32(buf2 + 3) >> 13) & 0x1FFF; <nl>              if(fsize < 7) <nl>                  break; <nl> +            fsize = FFMIN(fsize, end - buf2); <nl>              buf2 += fsize; <nl>          } <nl>          max_frames = FFMAX(max_frames, frames);
@@ -1599,7 +1599,9 @@ static int output_packet(InputStream *ist, int ist_index, <nl>                  int frame_size; <nl>   <nl>                  ost = &ost_table[i]; <nl> -                if (ost->source_index == ist_index) { <nl> +                if (ost->source_index != ist_index) <nl> +                    continue; <nl> + <nl>  #if CONFIG_AVFILTER <nl>                  frame_available = ist->st->codec->codec_type != AVMEDIA_TYPE_VIDEO || <nl>                      !ost->output_video_filter || avfilter_poll_frame(ost->output_video_filter->inputs[0]); <nl> @@ -1706,7 +1708,6 @@ static int output_packet(InputStream *ist, int ist_index, <nl>                          avfilter_unref_buffer(ost->picref); <nl>                  } <nl>  #endif <nl> -                } <nl>              } <nl>   <nl>          av_free(buffer_to_free);
@@ -232,7 +232,10 @@ static av_cold int join_init(AVFilterContext *ctx) <nl>   <nl>          pad.needs_fifo = 1; <nl>   <nl> -        ff_insert_inpad(ctx, i, &pad); <nl> +        if ((ret = ff_insert_inpad(ctx, i, &pad)) < 0) { <nl> +            av_freep(&pad.name); <nl> +            return ret; <nl> +        } <nl>      } <nl>   <nl>      return 0;
@@ -127,7 +127,7 @@ static inline int ff_fast_malloc(void *ptr, unsigned int *size, size_t min_size, <nl>      void **p = ptr; <nl>      if (min_size <= *size && *p) <nl>          return 0; <nl> -    min_size = FFMAX(17 * min_size / 16 + 32, min_size); <nl> +    min_size = FFMAX(min_size + min_size / 16 + 32, min_size); <nl>      av_free(*p); <nl>      *p = zero_realloc ? av_mallocz(min_size) : av_malloc(min_size); <nl>      if (!*p)
@@ -117,7 +117,7 @@ static int opus_packet(AVFormatContext *avf, int idx) <nl>   <nl>      if (!os->psize) <nl>          return AVERROR_INVALIDDATA; <nl> -    if (os->granule > INT64_MAX - UINT32_MAX) { <nl> +    if (os->granule > (1LL << 62)) { <nl>          av_log(avf, AV_LOG_ERROR, "Unsupported huge granule pos %"PRId64 "\n", os->granule); <nl>          return AVERROR_INVALIDDATA; <nl>      }
@@ -259,6 +259,11 @@ static int smacker_decode_header_tree(SmackVContext *smk, GetBitContext *gb, int <nl>      if(ctx.last[0] == -1) ctx.last[0] = huff.current++; <nl>      if(ctx.last[1] == -1) ctx.last[1] = huff.current++; <nl>      if(ctx.last[2] == -1) ctx.last[2] = huff.current++; <nl> +    if(huff.current > huff.length){ <nl> +        ctx.last[0] = ctx.last[1] = ctx.last[2] = 1; <nl> +        av_log(smk->avctx, AV_LOG_ERROR, "bigtree damaged\n"); <nl> +        return -1; <nl> +    } <nl>   <nl>      *recodes = huff.values; <nl>  
@@ -187,7 +187,7 @@ static int bmp_decode_frame(AVCodecContext *avctx, <nl>      switch(depth){ <nl>      case 24: <nl>          for(i = 0; i < avctx->height; i++){ <nl> -            memcpy(ptr, buf, n); <nl> +            memcpy(ptr, buf, avctx->width*(depth>>3)); <nl>              buf += n; <nl>              ptr += linesize; <nl>          }
@@ -122,13 +122,16 @@ static uint64_t get_channel_layout_single(const char *name, int name_len) <nl>              strlen(channel_names[i].name) == name_len && <nl>              !memcmp(channel_names[i].name, name, name_len)) <nl>              return (int64_t)1 << i; <nl> + <nl> +    errno = 0; <nl>      i = strtol(name, &end, 10); <nl>   <nl> -    if ((end + 1 - name == name_len && *end  == 'c')) <nl> +    if (!errno && (end + 1 - name == name_len && *end  == 'c')) <nl>          return av_get_default_channel_layout(i); <nl>   <nl> +    errno = 0; <nl>      layout = strtoll(name, &end, 0); <nl> -    if (end - name == name_len) <nl> +    if (!errno && end - name == name_len) <nl>          return FFMAX(layout, 0); <nl>      return 0; <nl>  }
@@ -257,8 +257,14 @@ static void decode_scaling_list(GetBitContext *gb, uint8_t *factors, int size, <nl>          memcpy(factors, fallback_list, size * sizeof(uint8_t)); <nl>      else <nl>          for (i = 0; i < size; i++) { <nl> -            if (next) <nl> -                next = (last + get_se_golomb(gb)) & 0xff; <nl> +            if (next) { <nl> +                int v = get_se_golomb(gb); <nl> +                if (v < -128 || v > 127) { <nl> +                    av_log(NULL, AV_LOG_ERROR, "delta scale %d is invalid\n", v); <nl> +                    v = -last; <nl> +                } <nl> +                next = (last + v) & 0xff; <nl> +            } <nl>              if (!i && !next) { /* matrix not written, we use the preset one */ <nl>                  memcpy(factors, jvt_list, size * sizeof(uint8_t)); <nl>                  break;
@@ -487,7 +487,8 @@ static int join_request_frame(AVFilterLink *outlink) <nl>   <nl>      ret = ff_filter_frame(outlink, frame); <nl>   <nl> -    memset(s->input_frames, 0, sizeof(*s->input_frames) * ctx->nb_inputs); <nl> +    for (i = 0; i < ctx->nb_inputs; i++) <nl> +        av_frame_free(&s->input_frames[i]); <nl>   <nl>      return ret; <nl>  
@@ -37,7 +37,7 @@ static int dxtory_decode_v1_rgb(AVCodecContext *avctx, AVFrame *pic, <nl>      uint8_t *dst; <nl>      int ret; <nl>   <nl> -    if (src_size < avctx->width * avctx->height * bpp) { <nl> +    if (src_size < avctx->width * avctx->height * (int64_t)bpp) { <nl>          av_log(avctx, AV_LOG_ERROR, "packet too small\n"); <nl>          return AVERROR_INVALIDDATA; <nl>      } <nl> @@ -63,7 +63,7 @@ static int dxtory_decode_v1_410(AVCodecContext *avctx, AVFrame *pic, <nl>      uint8_t *Y1, *Y2, *Y3, *Y4, *U, *V; <nl>      int ret; <nl>   <nl> -    if (src_size < avctx->width * avctx->height * 18 / 16) { <nl> +    if (src_size < avctx->width * avctx->height * 9L / 8) { <nl>          av_log(avctx, AV_LOG_ERROR, "packet too small\n"); <nl>          return AVERROR_INVALIDDATA; <nl>      } <nl> @@ -106,7 +106,7 @@ static int dxtory_decode_v1_420(AVCodecContext *avctx, AVFrame *pic, <nl>      uint8_t *Y1, *Y2, *U, *V; <nl>      int ret; <nl>   <nl> -    if (src_size < avctx->width * avctx->height * 3 / 2) { <nl> +    if (src_size < avctx->width * avctx->height * 3L / 2) { <nl>          av_log(avctx, AV_LOG_ERROR, "packet too small\n"); <nl>          return AVERROR_INVALIDDATA; <nl>      } <nl> @@ -143,7 +143,7 @@ static int dxtory_decode_v1_444(AVCodecContext *avctx, AVFrame *pic, <nl>      uint8_t *Y, *U, *V; <nl>      int ret; <nl>   <nl> -    if (src_size < avctx->width * avctx->height * 3) { <nl> +    if (src_size < avctx->width * avctx->height * 3L) { <nl>          av_log(avctx, AV_LOG_ERROR, "packet too small\n"); <nl>          return AVERROR_INVALIDDATA; <nl>      }
@@ -97,8 +97,8 @@ static int crypto_open(URLContext *h, const char *uri, int flags) <nl>   <nl>      return 0; <nl>  err: <nl> -    av_free(c->key); <nl> -    av_free(c->iv); <nl> +    av_freep(c->key); <nl> +    av_freep(c->iv); <nl>      return ret; <nl>  } <nl>   <nl> @@ -157,8 +157,6 @@ static int crypto_close(URLContext *h) <nl>      if (c->hd) <nl>          ffurl_close(c->hd); <nl>      av_freep(&c->aes); <nl> -    av_freep(&c->key); <nl> -    av_freep(&c->iv); <nl>      return 0; <nl>  } <nl>  
@@ -66,6 +66,7 @@ typedef struct FFBufferRef { <nl>  typedef struct MMALDecodeContext { <nl>      AVClass *av_class; <nl>      int extra_buffers; <nl> +    int extra_decoder_buffers; <nl>   <nl>      MMAL_COMPONENT_T *decoder; <nl>      MMAL_QUEUE_T *queue_decoded_frames; <nl> @@ -382,6 +383,11 @@ static av_cold int ffmmal_init_decoder(AVCodecContext *avctx) <nl>      av_get_codec_tag_string(tmp, sizeof(tmp), format_in->encoding); <nl>      av_log(avctx, AV_LOG_DEBUG, "Using MMAL %s encoding.\n", tmp); <nl>   <nl> +    if (mmal_port_parameter_set_uint32(decoder->input[0], MMAL_PARAMETER_VIDEO_MAX_NUM_CALLBACKS, <nl> +                                       -1 - ctx->extra_decoder_buffers)) { <nl> +        av_log(avctx, AV_LOG_WARNING, "Could not set input buffering limit.\n"); <nl> +    } <nl> + <nl>      if ((status = mmal_port_format_commit(decoder->input[0]))) <nl>          goto fail; <nl>   <nl> @@ -812,6 +818,7 @@ AVHWAccel ff_vc1_mmal_hwaccel = { <nl>   <nl>  static const AVOption options[]={ <nl>      {"extra_buffers", "extra buffers", offsetof(MMALDecodeContext, extra_buffers), AV_OPT_TYPE_INT, {.i64 = 10}, 0, 256, 0}, <nl> +    {"extra_decoder_buffers", "extra MMAL internal buffered frames", offsetof(MMALDecodeContext, extra_decoder_buffers), AV_OPT_TYPE_INT, {.i64 = 10}, 0, 256, 0}, <nl>      {NULL} <nl>  }; <nl>  
@@ -4938,15 +4938,17 @@ static void vc1_draw_sprites(VC1Context *v, SpriteData* sd) <nl>                  int      iline  = s->current_picture.f.linesize[plane]; <nl>                  int      ycoord = yoff[sprite] + yadv[sprite] * row; <nl>                  int      yline  = ycoord >> 16; <nl> +                int      next_line; <nl>                  ysub[sprite] = ycoord & 0xFFFF; <nl>                  if (sprite) { <nl>                      iplane = s->last_picture.f.data[plane]; <nl>                      iline  = s->last_picture.f.linesize[plane]; <nl>                  } <nl> +                next_line = FFMIN(yline + 1, (v->sprite_height >> !!plane) - 1) * iline; <nl>                  if (!(xoff[sprite] & 0xFFFF) && xadv[sprite] == 1 << 16) { <nl>                          src_h[sprite][0] = iplane + (xoff[sprite] >> 16) +  yline      * iline; <nl>                      if (ysub[sprite]) <nl> -                        src_h[sprite][1] = iplane + (xoff[sprite] >> 16) + (yline + 1) * iline; <nl> +                        src_h[sprite][1] = iplane + (xoff[sprite] >> 16) + next_line; <nl>                  } else { <nl>                      if (sr_cache[sprite][0] != yline) { <nl>                          if (sr_cache[sprite][1] == yline) { <nl> @@ -4958,7 +4960,9 @@ static void vc1_draw_sprites(VC1Context *v, SpriteData* sd) <nl>                          } <nl>                      } <nl>                      if (ysub[sprite] && sr_cache[sprite][1] != yline + 1) { <nl> -                        v->vc1dsp.sprite_h(v->sr_rows[sprite][1], iplane + (yline + 1) * iline, xoff[sprite], xadv[sprite], width); <nl> +                        v->vc1dsp.sprite_h(v->sr_rows[sprite][1], <nl> +                                           iplane + next_line, xoff[sprite], <nl> +                                           xadv[sprite], width); <nl>                          sr_cache[sprite][1] = yline + 1; <nl>                      } <nl>                      src_h[sprite][0] = v->sr_rows[sprite][0];
@@ -3419,7 +3419,7 @@ static int mov_read_header(AVFormatContext *s) <nl>          } <nl>          if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO && sc->nb_frames_for_fps > 0 && sc->duration_for_fps > 0) <nl>              av_reduce(&st->avg_frame_rate.num, &st->avg_frame_rate.den, <nl> -                      sc->time_scale*sc->nb_frames_for_fps, sc->duration_for_fps, INT_MAX); <nl> +                      sc->time_scale*(int64_t)sc->nb_frames_for_fps, sc->duration_for_fps, INT_MAX); <nl>      } <nl>   <nl>      if (mov->trex_data) {
@@ -252,6 +252,14 @@ static int init_image(TiffContext *s, AVFrame *frame) <nl>  { <nl>      int ret; <nl>   <nl> +    // make sure there is no aliasing in the following switch <nl> +    if (s->bpp >= 100 || s->bppcount >= 10) { <nl> +        av_log(s->avctx, AV_LOG_ERROR, <nl> +               "Unsupported image parameters: bpp=%d, bppcount=%d\n", <nl> +               s->bpp, s->bppcount); <nl> +        return AVERROR_INVALIDDATA; <nl> +    } <nl> + <nl>      switch (s->planar * 1000 + s->bpp * 10 + s->bppcount) { <nl>      case 11: <nl>          s->avctx->pix_fmt = AV_PIX_FMT_MONOBLACK;
@@ -37,7 +37,7 @@ static av_cold int init(AVFilterContext *ctx, const char *args, void *opaque) <nl>      aspect->ratio = (AVRational) {0, 1}; <nl>   <nl>      if (args) { <nl> -        if (av_parse_ratio(&aspect->ratio, args, 100, 0, ctx) || <nl> +        if (av_parse_ratio(&aspect->ratio, args, 100, 0, ctx) < 0 || <nl>              aspect->ratio.num < 0 || aspect->ratio.den <= 0) { <nl>              av_log(ctx, AV_LOG_ERROR, <nl>                     "Invalid string '%s' for aspect ratio.\n", args);
@@ -2221,6 +2221,8 @@ static int handle_metadata(RTMPContext *rt, RTMPPacket *pkt) <nl>              pts = cts; <nl>          ts += cts - pts; <nl>          pts = cts; <nl> +        if (size + 3 + 4 > pkt->data + pkt->size - next) <nl> +            break; <nl>          bytestream_put_byte(&p, type); <nl>          bytestream_put_be24(&p, size); <nl>          bytestream_put_be24(&p, ts);
@@ -1391,7 +1391,7 @@ int ff_rtsp_make_setup_request(AVFormatContext *s, const char *host, int port, <nl>              goto fail; <nl>      } <nl>   <nl> -    if (reply->timeout > 0) <nl> +    if (rt->nb_rtsp_streams && reply->timeout > 0) <nl>          rt->timeout = reply->timeout; <nl>   <nl>      if (rt->server_type == RTSP_SERVER_REAL)
@@ -764,8 +764,8 @@ static int ffserver_parse_config_stream(FFServerConfig *config, const char *cmd, <nl>          ffserver_get_arg(arg, sizeof(arg), p); <nl>          stream->max_time = atof(arg) * 1000; <nl>      } else if (!av_strcasecmp(cmd, "AudioBitRate")) { <nl> -        ffserver_get_arg(arg, sizeof(arg), p); <nl>          float f; <nl> +        ffserver_get_arg(arg, sizeof(arg), p); <nl>          ffserver_set_float_param(&f, arg, 1000, 0, FLT_MAX, config, line_num, "Invalid %s: %s\n", cmd, arg); <nl>          if (av_dict_set_int(&config->audio_conf, cmd, lrintf(f), 0) < 0) <nl>              goto nomem;
@@ -1762,7 +1762,7 @@ static int aac_decode_frame(AVCodecContext *avccontext, void *data, <nl>              memset(new_che_pos, 0, 4 * MAX_ELEM_ID * sizeof(new_che_pos[0][0])); <nl>              if ((err = decode_pce(ac, new_che_pos, &gb))) <nl>                  break; <nl> -            if (ac->output_configured <= OC_TRIAL_PCE) <nl> +            if (ac->output_configured > OC_TRIAL_PCE) <nl>                  av_log(avccontext, AV_LOG_ERROR, <nl>                         "Not evaluating a further program_config_element as this construct is dubious at best.\n"); <nl>              else
@@ -370,10 +370,10 @@ static int mp2_write_trailer(struct AVFormatContext *s) <nl>      return 0; <nl>  } <nl>   <nl> -static int query_codec(enum CodecID id, int std_compliance) <nl> +static int query_codec(enum AVCodecID id, int std_compliance) <nl>  { <nl>      CodecMime *cm= ff_id3v2_mime_tags; <nl> -    while(cm->id != CODEC_ID_NONE) { <nl> +    while(cm->id != AV_CODEC_ID_NONE) { <nl>          if(id == cm->id) <nl>              return MKTAG('A', 'P', 'I', 'C'); <nl>          cm++;
@@ -196,6 +196,8 @@ static av_cold int amr_nb_encode_init(AVCodecContext *avctx) <nl>   <nl>      avctx->frame_size  = 160; <nl>      avctx->coded_frame = avcodec_alloc_frame(); <nl> +    if (!avctx->coded_frame) <nl> +        return AVERROR(ENOMEM); <nl>   <nl>      s->enc_state = Encoder_Interface_init(s->enc_dtx); <nl>      if (!s->enc_state) {
@@ -106,8 +106,8 @@ static int mov_read_udta_string(MOVContext *c, ByteIOContext *pb, MOVAtom atom) <nl>      switch (atom.type) { <nl>      case MKTAG(0xa9,'n','a','m'): key = "title";     break; <nl>      case MKTAG(0xa9,'a','u','t'): <nl> -    case MKTAG(0xa9,'A','R','T'): <nl> -    case MKTAG(0xa9,'w','r','t'): key = "author";    break; <nl> +    case MKTAG(0xa9,'A','R','T'): key = "author";    break; <nl> +    case MKTAG(0xa9,'w','r','t'): key = "composer";  break; <nl>      case MKTAG(0xa9,'c','p','y'): key = "copyright"; break; <nl>      case MKTAG(0xa9,'c','m','t'): <nl>      case MKTAG(0xa9,'i','n','f'): key = "comment";   break;
@@ -2000,6 +2000,8 @@ static int read_ffserver_streams(OptionsContext *o, AVFormatContext *s, const ch <nl>  { <nl>      int i, err; <nl>      AVFormatContext *ic = avformat_alloc_context(); <nl> +    if (!ic) <nl> +        return AVERROR(ENOMEM); <nl>   <nl>      ic->interrupt_callback = int_cb; <nl>      err = avformat_open_input(&ic, filename, NULL, NULL);
@@ -2219,18 +2219,15 @@ static void estimate_timings_from_bit_rate(AVFormatContext *ic) <nl>   <nl>      /* if bit_rate is already set, we believe it */ <nl>      if (ic->bit_rate <= 0) { <nl> -        int bit_rate = 0; <nl> +        int64_t bit_rate = 0; <nl>          for(i=0;i<ic->nb_streams;i++) { <nl>              st = ic->streams[i]; <nl>              if (st->codec->bit_rate > 0) { <nl> -                if (INT_MAX - st->codec->bit_rate > bit_rate) { <nl> -                    bit_rate = 0; <nl> -                    break; <nl> -                } <nl>                  bit_rate += st->codec->bit_rate; <nl>              } <nl>          } <nl> -        ic->bit_rate = bit_rate; <nl> +        if (bit_rate <= INT_MAX) <nl> +            ic->bit_rate = bit_rate; <nl>      } <nl>   <nl>      /* if duration is already set, we believe it */
@@ -46,7 +46,7 @@ static int dvdsub_parse(AVCodecParserContext *s, <nl>   <nl>      if (pc->packet_index == 0) { <nl>          if (buf_size < 2) <nl> -            return 0; <nl> +            return buf_size; <nl>          pc->packet_len = AV_RB16(buf); <nl>          if (pc->packet_len == 0) /* HD-DVD subpicture packet */ <nl>              pc->packet_len = AV_RB32(buf+2);
@@ -321,7 +321,7 @@ static int process_ipmovie_chunk(IPMVEContext *s, AVIOContext *pb, <nl>   <nl>          case OPCODE_CREATE_TIMER: <nl>              av_dlog(NULL, "create timer\n"); <nl> -            if ((opcode_version > 0) || (opcode_size > 6)) { <nl> +            if ((opcode_version > 0) || (opcode_size != 6)) { <nl>                  av_dlog(NULL, "bad create_timer opcode\n"); <nl>                  chunk_type = CHUNK_BAD; <nl>                  break;
@@ -2398,6 +2398,12 @@ static int hls_slice_data_wpp(HEVCContext *s, const uint8_t *nal, int length) <nl>      int startheader, cmpt = 0; <nl>      int i, j, res = 0; <nl>   <nl> +    if (!ret || !arg) { <nl> +        av_free(ret); <nl> +        av_free(arg); <nl> +        return AVERROR(ENOMEM); <nl> +    } <nl> + <nl>   <nl>      if (!s->sList[1]) { <nl>          ff_alloc_entries(s->avctx, s->sh.num_entry_point_offsets + 1); <nl> @@ -2933,6 +2939,8 @@ static int decode_nal_units(HEVCContext *s, const uint8_t *buf, int length) <nl>   <nl>              s->skipped_bytes_pos_size_nal[s->nals_allocated] = 1024; // initial buffer size <nl>              s->skipped_bytes_pos_nal[s->nals_allocated] = av_malloc_array(s->skipped_bytes_pos_size_nal[s->nals_allocated], sizeof(*s->skipped_bytes_pos)); <nl> +            if (!s->skipped_bytes_pos_nal[s->nals_allocated]) <nl> +                goto fail; <nl>              s->nals_allocated = new_size; <nl>          } <nl>          s->skipped_bytes_pos_size = s->skipped_bytes_pos_size_nal[s->nb_nals];
@@ -1010,6 +1010,7 @@ static int mov_read_extradata(MOVContext *c, AVIOContext *pb, MOVAtom atom, <nl>          av_log(c->fc, AV_LOG_WARNING, "truncated extradata\n"); <nl>          st->codec->extradata_size -= atom.size - err; <nl>      } <nl> +    memset(buf + 8 + err, 0, FF_INPUT_BUFFER_PADDING_SIZE); <nl>      return 0; <nl>  } <nl>  
@@ -55,9 +55,12 @@ static int get_swf_tag(AVIOContext *pb, int *len_ptr) <nl>   <nl>  static int swf_probe(AVProbeData *p) <nl>  { <nl> +    if(p->buf_size < 15) <nl> +        return 0; <nl> + <nl>      /* check file header */ <nl>      if ((p->buf[0] == 'F' || p->buf[0] == 'C') && p->buf[1] == 'W' && <nl> -        p->buf[2] == 'S') <nl> +        p->buf[2] == 'S' && p->buf[3] < 20) <nl>          return AVPROBE_SCORE_MAX; <nl>      else <nl>          return 0;
@@ -1533,7 +1533,7 @@ int ff_rv34_decode_frame(AVCodecContext *avctx, <nl>              break; <nl>      } <nl>   <nl> -    if(last){ <nl> +    if(last && s->current_picture_ptr){ <nl>          if(r->loop_filter) <nl>              r->loop_filter(r, s->mb_height - 1); <nl>          ff_er_frame_end(s);
@@ -72,7 +72,7 @@ void avfilter_default_start_frame(AVFilterLink *link, AVFilterPicRef *picref) <nl>          out = link->dst->outputs[0]; <nl>   <nl>      if(out) { <nl> -        out->outpic      = avfilter_get_video_buffer(out, AV_PERM_WRITE, link->w, link->h); <nl> +        out->outpic      = avfilter_get_video_buffer(out, AV_PERM_WRITE, out->w, out->h); <nl>          out->outpic->pts = picref->pts; <nl>          avfilter_start_frame(out, avfilter_ref_pic(out->outpic, ~0)); <nl>      }
@@ -206,7 +206,7 @@ static int set_string_number(void *obj, void *target_obj, const AVOption *o, con <nl>          } <nl>   <nl>          { <nl> -            const AVOption *o_named = av_opt_find(target_obj, buf, o->unit, 0, 0); <nl> +            const AVOption *o_named = av_opt_find(target_obj, i ? buf : val, o->unit, 0, 0); <nl>              int res; <nl>              int ci = 0; <nl>              double const_values[64];
@@ -374,7 +374,7 @@ void avcodec_align_dimensions2(AVCodecContext *s, int *width, int *height, <nl>      case AV_PIX_FMT_YUVJ411P: <nl>      case AV_PIX_FMT_UYYVYY411: <nl>          w_align = 32; <nl> -        h_align = 8; <nl> +        h_align = 16 * 2; <nl>          break; <nl>      case AV_PIX_FMT_YUV410P: <nl>          if (s->codec_id == AV_CODEC_ID_SVQ1) {
@@ -924,6 +924,12 @@ void ff_er_frame_end(MpegEncContext *s) <nl>          return; <nl>      }; <nl>   <nl> +    if (   s->picture_structure == PICT_FRAME <nl> +        && s->current_picture.f.linesize[0] != s->current_picture_ptr->f.linesize[0]) { <nl> +        av_log(s->avctx, AV_LOG_ERROR, "Error concealment not possible, frame not fully initialized\n"); <nl> +        return; <nl> +    } <nl> + <nl>      if (s->current_picture.f.motion_val[0] == NULL) { <nl>          av_log(s->avctx, AV_LOG_ERROR, "Warning MVs not available\n"); <nl>  
@@ -1975,7 +1975,9 @@ static int dirac_decode_picture_header(DiracContext *s) <nl>              for (j = 0; j < MAX_FRAMES; j++) <nl>                  if (!s->all_frames[j].avframe->data[0]) { <nl>                      s->ref_pics[i] = &s->all_frames[j]; <nl> -                    get_buffer_with_edge(s->avctx, s->ref_pics[i]->avframe, AV_GET_BUFFER_FLAG_REF); <nl> +                    ret = get_buffer_with_edge(s->avctx, s->ref_pics[i]->avframe, AV_GET_BUFFER_FLAG_REF); <nl> +                    if (ret < 0) <nl> +                        return ret; <nl>                      break; <nl>                  } <nl>  
@@ -62,7 +62,8 @@ static int decode_frame(AVCodecContext *avctx, <nl>      AVFrame *const p = &s->picture; <nl>      uint8_t *ptr; <nl>   <nl> -    int magic_num, offset, endian; <nl> +    unsigned int offset; <nl> +    int magic_num, endian; <nl>      int x, y; <nl>      int w, h, stride, bits_per_color, descriptor, elements, target_packet_size, source_packet_size; <nl>  
@@ -1536,7 +1536,7 @@ static int process_output_surface(AVCodecContext *avctx, AVPacket *pkt, NvencSur <nl>      NV_ENCODE_API_FUNCTION_LIST *p_nvenc = &dl_fn->nvenc_funcs; <nl>   <nl>      uint32_t slice_mode_data; <nl> -    uint32_t *slice_offsets; <nl> +    uint32_t *slice_offsets = NULL; <nl>      NV_ENC_LOCK_BITSTREAM lock_params = { 0 }; <nl>      NVENCSTATUS nv_status; <nl>      int res = 0;
@@ -147,7 +147,9 @@ static int vp9_superframe_filter(AVBSFContext *ctx, AVPacket *out) <nl>          goto done; <nl>      } <nl>   <nl> -    av_packet_move_ref(s->cache[s->n_cache++], in); <nl> +    res = av_packet_ref(s->cache[s->n_cache++], in); <nl> +    if (res < 0) <nl> +        goto done; <nl>   <nl>      if (invisible) { <nl>          res = AVERROR(EAGAIN);
@@ -2597,11 +2597,14 @@ static void update_stream_timings(AVFormatContext *ic) <nl>              if (ic->nb_programs > 1) { <nl>                  for (i = 0; i < ic->nb_programs; i++) { <nl>                      p = ic->programs[i]; <nl> -                    if (p->start_time != AV_NOPTS_VALUE && p->end_time > p->start_time) <nl> +                    if (p->start_time != AV_NOPTS_VALUE && <nl> +                        p->end_time > p->start_time && <nl> +                        p->end_time - (uint64_t)p->start_time <= INT64_MAX) <nl>                          duration = FFMAX(duration, p->end_time - p->start_time); <nl>                  } <nl> -            } else <nl> +            } else if (end_time >= start_time && end_time - (uint64_t)start_time <= INT64_MAX) { <nl>                  duration = FFMAX(duration, end_time - start_time); <nl> +            } <nl>          } <nl>      } <nl>      if (duration != INT64_MIN && duration > 0 && ic->duration == AV_NOPTS_VALUE) {
@@ -1722,6 +1722,7 @@ static int dirac_decode_data_unit(AVCodecContext *avctx, const uint8_t *buf, int <nl>      DiracContext *s   = avctx->priv_data; <nl>      DiracFrame *pic   = NULL; <nl>      int i, parse_code = buf[4]; <nl> +    unsigned tmp; <nl>   <nl>      if (size < DATA_UNIT_HEADER_SIZE) <nl>          return -1; <nl> @@ -1772,7 +1773,12 @@ static int dirac_decode_data_unit(AVCodecContext *avctx, const uint8_t *buf, int <nl>          avcodec_get_frame_defaults(&pic->avframe); <nl>   <nl>          /* [DIRAC_STD] Defined in 9.6.1 ... */ <nl> -        s->num_refs    =  parse_code & 0x03;                   /* [DIRAC_STD] num_refs()      */ <nl> +        tmp            =  parse_code & 0x03;                   /* [DIRAC_STD] num_refs()      */ <nl> +        if (tmp > 2) { <nl> +            av_log(avctx, AV_LOG_ERROR, "num_refs of 3\n"); <nl> +            return -1; <nl> +        } <nl> +        s->num_refs    = tmp; <nl>          s->is_arith    = (parse_code & 0x48) == 0x08;          /* [DIRAC_STD] using_ac()      */ <nl>          s->low_delay   = (parse_code & 0x88) == 0x88;          /* [DIRAC_STD] is_low_delay()  */ <nl>          pic->avframe.reference = (parse_code & 0x0C) == 0x0C;  /* [DIRAC_STD]  is_reference() */
@@ -245,8 +245,8 @@ ogg_read_page (AVFormatContext * s, int *str) <nl>                  int n; <nl>   <nl>                  for (n = 0; n < ogg->nstreams; n++) { <nl> -                    av_free(ogg->streams[n].buf); <nl> -                    av_free(ogg->streams[n].private); <nl> +                    av_freep(&ogg->streams[n].buf); <nl> +                    av_freep(&ogg->streams[n].private); <nl>                  } <nl>                  ogg->curidx   = -1; <nl>                  ogg->nstreams = 0;
@@ -59,7 +59,7 @@ static const AVOption options[]={ <nl>  {"fdebug", "print specific debug info", OFFSET(debug), FF_OPT_TYPE_FLAGS, {.dbl = DEFAULT }, 0, INT_MAX, E|D, "fdebug"}, <nl>  {"ts", NULL, 0, FF_OPT_TYPE_CONST, {.dbl = FF_FDEBUG_TS }, INT_MIN, INT_MAX, E|D, "fdebug"}, <nl>  {"max_delay", "maximum muxing or demuxing delay in microseconds", OFFSET(max_delay), FF_OPT_TYPE_INT, {.dbl = DEFAULT }, 0, INT_MAX, E|D}, <nl> -{"fpsprobesize", "number of frames used to probe fps", OFFSET(fps_probe_size), FF_OPT_TYPE_INT, -1, -1, INT_MAX-1, D}, <nl> +{"fpsprobesize", "number of frames used to probe fps", OFFSET(fps_probe_size), FF_OPT_TYPE_INT, {.dbl = -1}, -1, INT_MAX-1, D}, <nl>  {NULL}, <nl>  }; <nl>  
@@ -205,7 +205,7 @@ static int filter_frame(AVFilterLink *inlink, AVFrame *buf) <nl>      } <nl>   <nl>      /* now wait for the next timestamp */ <nl> -    if (buf->pts == AV_NOPTS_VALUE) { <nl> +    if (buf->pts == AV_NOPTS_VALUE || av_fifo_size(s->fifo) <= 0) { <nl>          return write_to_fifo(s->fifo, buf); <nl>      } <nl>  
@@ -316,7 +316,7 @@ void avfilter_start_frame(AVFilterLink *link, AVFilterBufferRef *picref) <nl>                  picref->perms, <nl>                  link_dpad(link).min_perms, link_dpad(link).rej_perms); <nl>   <nl> -        link->cur_buf = avfilter_default_get_video_buffer(link, dst->min_perms, link->w, link->h); <nl> +        link->cur_buf = avfilter_get_video_buffer(link, dst->min_perms, link->w, link->h); <nl>          link->src_buf = picref; <nl>          avfilter_copy_buffer_ref_props(link->cur_buf, link->src_buf); <nl>      }
@@ -263,8 +263,8 @@ static int fic_decode_frame(AVCodecContext *avctx, void *data, <nl>      } <nl>   <nl>      for (slice = 0; slice < nslices; slice++) { <nl> -        int slice_off = AV_RB32(src + tsize + FIC_HEADER_SIZE + slice * 4); <nl> -        int slice_size; <nl> +        unsigned slice_off = AV_RB32(src + tsize + FIC_HEADER_SIZE + slice * 4); <nl> +        unsigned slice_size; <nl>          int y_off   = ctx->slice_h * slice; <nl>          int slice_h = ctx->slice_h; <nl>   <nl> @@ -279,11 +279,11 @@ static int fic_decode_frame(AVCodecContext *avctx, void *data, <nl>              slice_size = AV_RB32(src + tsize + FIC_HEADER_SIZE + slice * 4 + 4); <nl>          } <nl>   <nl> -        slice_size -= slice_off; <nl> - <nl> -        if (slice_off > msize || slice_off + slice_size > msize) <nl> +        if (slice_size < slice_off || slice_size > msize) <nl>              continue; <nl>   <nl> +        slice_size -= slice_off; <nl> + <nl>          ctx->slice_data[slice].src      = sdata + slice_off; <nl>          ctx->slice_data[slice].src_size = slice_size; <nl>          ctx->slice_data[slice].slice_h  = slice_h;
@@ -754,9 +754,12 @@ static int resolve_content_path(AVFormatContext *s, const char *url, int *max_ur <nl>          if (!(node = baseurl_nodes[rootId])) { <nl>              continue; <nl>          } <nl> -        if (ishttp(xmlNodeGetContent(node))) { <nl> +        text = xmlNodeGetContent(node); <nl> +        if (ishttp(text)) { <nl> +            xmlFree(text); <nl>              break; <nl>          } <nl> +        xmlFree(text); <nl>      } <nl>   <nl>      node = baseurl_nodes[rootId];
@@ -3553,6 +3553,7 @@ static void mov_fix_index(MOVContext *mov, AVStream *st) <nl>      // Free the old index and the old CTTS structures <nl>      av_free(e_old); <nl>      av_free(ctts_data_old); <nl> +    av_freep(&frame_duration_buffer); <nl>   <nl>      // Null terminate the index ranges array <nl>      current_index_range++;
@@ -821,6 +821,7 @@ static int cbs_h264_read_nal_unit(CodedBitstreamContext *ctx, <nl>              err = cbs_h264_read_sei(ctx, &bc, sei); <nl>              if (err < 0) { <nl>                  cbs_h264_free_sei(sei); <nl> +                av_free(sei); <nl>                  return err; <nl>              } <nl>  
@@ -641,9 +641,13 @@ int avformat_open_input(AVFormatContext **ps, const char *filename, AVInputForma <nl>          if ((ret = s->iformat->read_header(s)) < 0) <nl>              goto fail; <nl>   <nl> -    if (id3v2_extra_meta && <nl> -        (ret = ff_id3v2_parse_apic(s, &id3v2_extra_meta)) < 0) <nl> -        goto fail; <nl> +    if (id3v2_extra_meta) { <nl> +        if (!strcmp(s->iformat->name, "mp3")) { <nl> +            if((ret = ff_id3v2_parse_apic(s, &id3v2_extra_meta)) < 0) <nl> +                goto fail; <nl> +        } else <nl> +            av_log(s, AV_LOG_DEBUG, "demuxer does not support additional id3 data, skiping\n"); <nl> +    } <nl>      ff_id3v2_free_extra_meta(&id3v2_extra_meta); <nl>   <nl>      avformat_queue_attached_pictures(s);
@@ -1440,8 +1440,8 @@ static int synth_frame(AVCodecContext *ctx, GetBitContext *gb, int frame_idx, <nl>                         float *excitation, float *synth) <nl>  { <nl>      WMAVoiceContext *s = ctx->priv_data; <nl> -    int n, n_blocks_x2, log_n_blocks_x2, cur_pitch_val; <nl> -    int pitch[MAX_BLOCKS], last_block_pitch; <nl> +    int n, n_blocks_x2, log_n_blocks_x2, av_uninit(cur_pitch_val); <nl> +    int pitch[MAX_BLOCKS], av_uninit(last_block_pitch); <nl>   <nl>      /* Parse frame type ("frame header"), see frame_descs */ <nl>      int bd_idx = s->vbm_tree[get_vlc2(gb, frame_type_vlc.table, 6, 3)], block_nsamples;
@@ -2254,6 +2254,7 @@ static int http_prepare_data(HTTPContext *c) <nl>                          c->state = HTTPSTATE_SEND_DATA_TRAILER; <nl>                      } <nl>   <nl> +                    av_freep(&c->pb_buffer); <nl>                      len = avio_close_dyn_buf(ctx->pb, &c->pb_buffer); <nl>                      c->cur_frame_bytes = len; <nl>                      c->buffer_ptr = c->pb_buffer;
@@ -910,6 +910,7 @@ static int decode_lowdelay(DiracContext *s) <nl>          s->slice_params_buf = av_realloc_f(s->slice_params_buf, s->num_x * s->num_y, sizeof(DiracSlice)); <nl>          if (!s->slice_params_buf) { <nl>              av_log(s->avctx, AV_LOG_ERROR, "slice params buffer allocation failure\n"); <nl> +            s->slice_params_num_buf = 0; <nl>              return AVERROR(ENOMEM); <nl>          } <nl>          s->slice_params_num_buf = s->num_x * s->num_y;
@@ -68,6 +68,12 @@ static int decode_frame(AVCodecContext *avctx, <nl>      V = a->pic.data[2]; <nl>   <nl>      stride = avctx->width - 4; <nl> + <nl> +    if (buf_size < avctx->width * avctx->height) { <nl> +        av_log(avctx, AV_LOG_ERROR, "Packet is too small\n"); <nl> +        return AVERROR_INVALIDDATA; <nl> +    } <nl> + <nl>      for (i = 0; i < avctx->height; i++) { <nl>          /* lines are stored in reversed order */ <nl>          buf += stride;
@@ -492,9 +492,11 @@ static int dtext_prepare_text(AVFilterContext *ctx) <nl>          /* get glyph */ <nl>          dummy.code = code; <nl>          glyph = av_tree_find(dtext->glyphs, &dummy, glyph_cmp, NULL); <nl> -        if (!glyph) <nl> +        if (!glyph) { <nl>              ret = load_glyph(ctx, &glyph, code); <nl> -        if (ret) return ret; <nl> +            if (ret) <nl> +                return ret; <nl> +        } <nl>   <nl>          y_min = FFMIN(glyph->bbox.yMin, y_min); <nl>          y_max = FFMAX(glyph->bbox.yMax, y_max);
@@ -26,6 +26,10 @@ <nl>   <nl>  #include "../avcodec.h" <nl>   <nl> +#undef malloc <nl> +#undef free <nl> +#undef realloc <nl> + <nl>  #ifndef LIBA52_DOUBLE <nl>  typedef float sample_t; <nl>  #else
@@ -2795,6 +2795,7 @@ static int encode_thread(AVCodecContext *c, void *arg){ <nl>                  av_fast_padded_malloc(&new_buffer, &new_buffer_size, new_size); <nl>                  if (new_buffer) { <nl>                      memcpy(new_buffer, s->avctx->internal->byte_buffer, s->avctx->internal->byte_buffer_size); <nl> +                    av_free(s->avctx->internal->byte_buffer); <nl>                      s->avctx->internal->byte_buffer      = new_buffer; <nl>                      s->avctx->internal->byte_buffer_size = new_buffer_size; <nl>                      rebase_put_bits(&s->pb, new_buffer, new_buffer_size);
@@ -292,7 +292,7 @@ static av_cold int vpx_init(AVCodecContext *avctx, <nl>      if (enccfg.g_pass == VPX_RC_FIRST_PASS) <nl>          enccfg.g_lag_in_frames = 0; <nl>      else if (enccfg.g_pass == VPX_RC_LAST_PASS) { <nl> -        int decode_size; <nl> +        int decode_size, ret; <nl>   <nl>          if (!avctx->stats_in) { <nl>              av_log(avctx, AV_LOG_ERROR, "No stats file for second pass\n"); <nl> @@ -300,12 +300,12 @@ static av_cold int vpx_init(AVCodecContext *avctx, <nl>          } <nl>   <nl>          ctx->twopass_stats.sz  = strlen(avctx->stats_in) * 3 / 4; <nl> -        ctx->twopass_stats.buf = av_malloc(ctx->twopass_stats.sz); <nl> -        if (!ctx->twopass_stats.buf) { <nl> +        ret = av_reallocp(&ctx->twopass_stats.buf, ctx->twopass_stats.sz); <nl> +        if (ret < 0) { <nl>              av_log(avctx, AV_LOG_ERROR, <nl>                     "Stat buffer alloc (%zu bytes) failed\n", <nl>                     ctx->twopass_stats.sz); <nl> -            return AVERROR(ENOMEM); <nl> +            return ret; <nl>          } <nl>          decode_size = av_base64_decode(ctx->twopass_stats.buf, avctx->stats_in, <nl>                                         ctx->twopass_stats.sz);
@@ -126,11 +126,14 @@ static int set_string_binary(void *obj, const AVOption *o, const char *val, uint <nl>  { <nl>      int *lendst = (int *)(dst + 1); <nl>      uint8_t *bin, *ptr; <nl> -    int len = strlen(val); <nl> +    int len; <nl>   <nl>      av_freep(dst); <nl>      *lendst = 0; <nl>   <nl> +    if (!val || !(len = strlen(val))) <nl> +        return 0; <nl> + <nl>      if (len & 1) <nl>          return AVERROR(EINVAL); <nl>      len /= 2;
@@ -101,7 +101,7 @@ void ff_lzw_decode_tail(LZWState *p) <nl>      struct LZWState *s = (struct LZWState *)p; <nl>   <nl>      if(s->mode == FF_LZW_GIF) { <nl> -        while(s->pbuf < s->ebuf && s->bs>0){ <nl> +        while(s->pbuf + s->bs < s->ebuf && s->bs>0){ <nl>              s->pbuf += s->bs; <nl>              s->bs = *s->pbuf++; <nl>          }
@@ -302,7 +302,7 @@ static int decode_subframe_fixed(FLACContext *s, int32_t *decoded, <nl>      if (pred_order > 2) <nl>          c = b - decoded[pred_order-2] + decoded[pred_order-3]; <nl>      if (pred_order > 3) <nl> -        d = c - decoded[pred_order-2] + 2*decoded[pred_order-3] - decoded[pred_order-4]; <nl> +        d = c - decoded[pred_order-2] + 2U*decoded[pred_order-3] - decoded[pred_order-4]; <nl>   <nl>      switch (pred_order) { <nl>      case 0:
@@ -2728,7 +2728,7 @@ static int vc1_decode_i_block_adv(VC1Context *v, int16_t block[64], int n, <nl>      MpegEncContext *s = &v->s; <nl>      int dc_pred_dir = 0; /* Direction of the DC prediction used */ <nl>      int i; <nl> -    int16_t *dc_val; <nl> +    int16_t *dc_val = NULL; <nl>      int16_t *ac_val, *ac_val2; <nl>      int dcdiff; <nl>      int a_avail = v->a_avail, c_avail = v->c_avail; <nl> @@ -2940,7 +2940,7 @@ static int vc1_decode_intra_block(VC1Context *v, int16_t block[64], int n, <nl>      MpegEncContext *s = &v->s; <nl>      int dc_pred_dir = 0; /* Direction of the DC prediction used */ <nl>      int i; <nl> -    int16_t *dc_val; <nl> +    int16_t *dc_val = NULL; <nl>      int16_t *ac_val, *ac_val2; <nl>      int dcdiff; <nl>      int mb_pos = s->mb_x + s->mb_y * s->mb_stride;
@@ -460,6 +460,11 @@ static int ivi_decode_blocks(GetBitContext *gb, IVIBandDesc *band, IVITile *tile <nl>              } <nl>   <nl>              if (cbp & 1) { /* block coded ? */ <nl> +                if (!band->scan) { <nl> +                    av_log(avctx, AV_LOG_ERROR, "Scan pattern is not set.\n"); <nl> +                    return AVERROR_INVALIDDATA; <nl> +                } <nl> + <nl>                  scan_pos = -1; <nl>                  memset(trvec, 0, num_coeffs*sizeof(trvec[0])); /* zero transform vector */ <nl>                  memset(col_flags, 0, sizeof(col_flags));      /* zero column flags */
@@ -206,11 +206,6 @@ static int libschroedinger_encode_init(AVCodecContext *avccontext) <nl>      schro_video_format_set_std_signal_range(p_schro_params->format, <nl>                                              SCHRO_SIGNAL_RANGE_8BIT_VIDEO); <nl>   <nl> - <nl> -    /* Hardcode motion vector precision to quarter pixel. */ <nl> -    schro_encoder_setting_set_double (p_schro_params->encoder, <nl> -                                      "mv_precision", 2); <nl> - <nl>      /* Set the encoder format. */ <nl>      schro_encoder_set_video_format(p_schro_params->encoder, <nl>                                     p_schro_params->format);
@@ -2589,7 +2589,7 @@ static int h264_slice_header_init(H264Context *h, int reinit) <nl>              return ret; <nl>          } <nl>      } else { <nl> -        if ((ret = ff_MPV_common_init(s) < 0)) { <nl> +        if ((ret = ff_MPV_common_init(s)) < 0) { <nl>              av_log(h->s.avctx, AV_LOG_ERROR, "ff_MPV_common_init() failed.\n"); <nl>              return ret; <nl>          }
@@ -108,6 +108,8 @@ ogm_header(AVFormatContext *s, int idx) <nl>              if (size > 52) { <nl>                  av_assert0(AV_INPUT_BUFFER_PADDING_SIZE <= 52); <nl>                  size -= 52; <nl> +                if (bytestream2_get_bytes_left(&p) < size) <nl> +                    return AVERROR_INVALIDDATA; <nl>                  ff_alloc_extradata(st->codecpar, size); <nl>                  bytestream2_get_buffer(&p, st->codecpar->extradata, st->codecpar->extradata_size); <nl>              }
@@ -203,6 +203,11 @@ static int push_single_pic(AVFilterLink *outlink) <nl>      int col = 0; <nl>      int64_t *sum = showwaves->sum; <nl>   <nl> +    if (max_samples == 0) { <nl> +        av_log(ctx, AV_LOG_ERROR, "Too few samples\n"); <nl> +        return AVERROR(EINVAL); <nl> +    } <nl> + <nl>      av_log(ctx, AV_LOG_DEBUG, "Create frame averaging %"PRId64" samples per column\n", max_samples); <nl>   <nl>      memset(sum, 0, nb_channels);
@@ -2356,7 +2356,7 @@ matroska_read_header (AVFormatContext    *s, <nl>              MatroskaDemuxIndex *idx = &matroska->index[i]; <nl>              track = matroska_find_track_by_num(matroska, idx->track); <nl>              stream = matroska->tracks[track]->stream_index; <nl> -            if (stream >= 0) <nl> +            if (stream >= 0 && stream < matroska->ctx->nb_streams) <nl>                  av_add_index_entry(matroska->ctx->streams[stream], <nl>                                     idx->pos, idx->time/matroska->time_scale, <nl>                                     0, 0, AVINDEX_KEYFRAME); <nl> @@ -2400,7 +2400,7 @@ matroska_parse_block(MatroskaDemuxContext *matroska, uint8_t *data, int size, <nl>          return res; <nl>      } <nl>      stream_index = matroska->tracks[track]->stream_index; <nl> -    if (stream_index < 0) { <nl> +    if (stream_index < 0 || stream_index >= matroska->ctx->nb_streams) { <nl>          av_free(origdata); <nl>          return res; <nl>      }
@@ -568,7 +568,7 @@ void ff_rtsp_undo_setup(AVFormatContext *s) <nl>                  avformat_free_context(rtpctx); <nl>              } else if (rt->transport == RTSP_TRANSPORT_RDT && CONFIG_RTPDEC) <nl>                  ff_rdt_parse_close(rtsp_st->transport_priv); <nl> -            else if (rt->transport == RTSP_TRANSPORT_RAW && CONFIG_RTPDEC) <nl> +            else if (rt->transport == RTSP_TRANSPORT_RTP && CONFIG_RTPDEC) <nl>                  ff_rtp_parse_close(rtsp_st->transport_priv); <nl>          } <nl>          rtsp_st->transport_priv = NULL;
@@ -420,12 +420,12 @@ static int init_duplicate_context(MpegEncContext *s, MpegEncContext *base) <nl>      // edge emu needs blocksize + filter length - 1 <nl>      // (= 17x17 for  halfpel / 21x21 for  h264) <nl>      FF_ALLOCZ_OR_GOTO(s->avctx, s->edge_emu_buffer, <nl> -                      (s->width + 64) * 2 * 21 * 2, fail);    // (width + edge + align)*interlaced*MBsize*tolerance <nl> +                      (s->width + 95) * 2 * 21 * 4, fail);    // (width + edge + align)*interlaced*MBsize*tolerance <nl>   <nl>      // FIXME should be linesize instead of s->width * 2 <nl>      // but that is not known before get_buffer() <nl>      FF_ALLOCZ_OR_GOTO(s->avctx, s->me.scratchpad, <nl> -                      (s->width + 64) * 4 * 16 * 2 * sizeof(uint8_t), fail) <nl> +                      (s->width + 95) * 4 * 16 * 2 * sizeof(uint8_t), fail) <nl>      s->me.temp         = s->me.scratchpad; <nl>      s->rd_scratchpad   = s->me.scratchpad; <nl>      s->b_scratchpad    = s->me.scratchpad;
@@ -141,6 +141,13 @@ int av_parser_parse2(AVCodecParserContext *s, AVCodecContext *avctx, <nl>      int index, i; <nl>      uint8_t dummy_buf[AV_INPUT_BUFFER_PADDING_SIZE]; <nl>   <nl> +    /* Parsers only work for the specified codec ids. */ <nl> +    av_assert1(avctx->codec_id == s->parser->codec_ids[0] || <nl> +               avctx->codec_id == s->parser->codec_ids[1] || <nl> +               avctx->codec_id == s->parser->codec_ids[2] || <nl> +               avctx->codec_id == s->parser->codec_ids[3] || <nl> +               avctx->codec_id == s->parser->codec_ids[4]); <nl> + <nl>      if (!(s->flags & PARSER_FLAG_FETCHED_OFFSET)) { <nl>          s->next_frame_offset = <nl>          s->cur_offset        = pos;
@@ -808,9 +808,8 @@ static void imc_get_coeffs(AVCodecContext *avctx, <nl>                          av_log(avctx, AV_LOG_WARNING, <nl>                              "Potential problem on band %i, coefficient %i" <nl>                              ": cw_len=%i\n", i, j, cw_len); <nl> -                    } <nl> - <nl> -                    cw = get_bits(&q->gb, cw_len); <nl> +                    } else <nl> +                        cw = get_bits(&q->gb, cw_len); <nl>                  } <nl>   <nl>                  chctx->codewords[j] = cw;
@@ -162,7 +162,7 @@ static void lpc_filter(const int16_t *lpc_coefs, uint16_t *in, int len) <nl>          new_val = ptr[10] - sum; <nl>   <nl>          if (new_val < -32768 || new_val > 32767) { <nl> -            memset(in, 0, 100); <nl> +            memset(in, 0, 50*sizeof(*in)); <nl>              return; <nl>          } <nl>   <nl> @@ -224,7 +224,7 @@ static void do_output_subblock(RA144Context *ractx, <nl>      m[2] = ((cb2_base[cb2_idx] >> 4) * gval) >> 8; <nl>   <nl>      memmove(ractx->adapt_cb, ractx->adapt_cb + BLOCKSIZE, <nl> -            (BUFFERSIZE - BLOCKSIZE) * 2); <nl> +            (BUFFERSIZE - BLOCKSIZE) * sizeof(*ractx->adapt_cb)); <nl>   <nl>      block = ractx->adapt_cb + BUFFERSIZE - BLOCKSIZE; <nl>  
@@ -90,7 +90,7 @@ static int qsv_decode_init(AVCodecContext *avctx, QSVContext *q) <nl>      const AVPixFmtDescriptor *desc; <nl>      mfxSession session = NULL; <nl>      int iopattern = 0; <nl> -    mfxVideoParam param = { { 0 } }; <nl> +    mfxVideoParam param = { 0 }; <nl>      int frame_width  = avctx->coded_width; <nl>      int frame_height = avctx->coded_height; <nl>      int ret;
@@ -2987,8 +2987,10 @@ static int aac_decode_frame_int(AVCodecContext *avctx, void *data, <nl>          if (avctx->debug & FF_DEBUG_STARTCODE) <nl>              av_log(avctx, AV_LOG_DEBUG, "Elem type:%x id:%x\n", elem_type, elem_id); <nl>   <nl> -        if (!avctx->channels && elem_type != TYPE_PCE) <nl> +        if (!avctx->channels && elem_type != TYPE_PCE) { <nl> +            err = AVERROR_INVALIDDATA; <nl>              goto fail; <nl> +        } <nl>   <nl>          if (elem_type < TYPE_DSE) { <nl>              if (!(che=get_che(ac, elem_type, elem_id))) {
@@ -265,7 +265,7 @@ static int request_frame(AVFilterLink *outlink) <nl>      AVFilterContext *ctx = outlink->src; <nl>      ZPContext *s = ctx->priv; <nl>      AVFrame *in = s->in; <nl> -    double zoom, dx, dy; <nl> +    double zoom=1, dx=0, dy=0; <nl>      int ret; <nl>   <nl>      if (in) {
@@ -97,8 +97,8 @@ static int crypto_open(URLContext *h, const char *uri, int flags) <nl>   <nl>      return 0; <nl>  err: <nl> -    av_free(c->key); <nl> -    av_free(c->iv); <nl> +    av_freep(&c->key); <nl> +    av_freep(&c->iv); <nl>      return ret; <nl>  } <nl>  
@@ -1033,7 +1033,9 @@ static int remove_decoded_packets(AVFormatContext *ctx, int64_t scr){ <nl>          while(pkt_desc && scr > pkt_desc->dts){ //FIXME > vs >= <nl>              if(stream->buffer_index < pkt_desc->size || <nl>                 stream->predecode_packet == stream->premux_packet){ <nl> -                av_log(ctx, AV_LOG_ERROR, "buffer underflow\n"); <nl> +                av_log(ctx, AV_LOG_ERROR, <nl> +                       "buffer underflow i=%d bufi=%d size=%d\n", <nl> +                       i, stream->buffer_index, pkt_desc->size); <nl>                  break; <nl>              } <nl>              stream->buffer_index -= pkt_desc->size;
@@ -702,8 +702,12 @@ int configure_filtergraph(FilterGraph *fg) <nl>              return ret; <nl>      avfilter_inout_free(&inputs); <nl>   <nl> -    for (cur = outputs, i = 0; cur; cur = cur->next, i++) <nl> -        configure_output_filter(fg, fg->outputs[i], cur); <nl> +    for (cur = outputs, i = 0; cur; cur = cur->next, i++) { <nl> +        OutputFilter *ofilter = fg->outputs[i]; <nl> +        if (ofilter->ost) <nl> +            configure_output_filter(fg, ofilter, cur); <nl> +    } <nl> + <nl>      avfilter_inout_free(&outputs); <nl>   <nl>      if ((ret = avfilter_graph_config(fg->graph, NULL)) < 0)
@@ -1438,7 +1438,7 @@ static int ape_decode_frame(AVCodecContext *avctx, void *data, <nl>          } <nl>          if (s->fileversion < 3950) // previous versions overread two bytes <nl>              buf_size += 2; <nl> -        av_fast_malloc(&s->data, &s->data_size, buf_size); <nl> +        av_fast_padded_malloc(&s->data, &s->data_size, buf_size); <nl>          if (!s->data) <nl>              return AVERROR(ENOMEM); <nl>          s->dsp.bswap_buf((uint32_t*)s->data, (const uint32_t*)buf, buf_size >> 2);
@@ -1112,7 +1112,7 @@ decode_intra_mb: <nl>   <nl>          dquant= get_se_golomb(&sl->gb); <nl>   <nl> -        sl->qscale += dquant; <nl> +        sl->qscale += (unsigned)dquant; <nl>   <nl>          if (((unsigned)sl->qscale) > max_qp){ <nl>              if (sl->qscale < 0) sl->qscale += max_qp + 1;
@@ -238,6 +238,9 @@ static int get_siz(J2kDecoderContext *s) <nl>      s->numXtiles = ff_j2k_ceildiv(s->width - s->tile_offset_x, s->tile_width); <nl>      s->numYtiles = ff_j2k_ceildiv(s->height - s->tile_offset_y, s->tile_height); <nl>   <nl> +    if(s->numXtiles * (uint64_t)s->numYtiles > INT_MAX/sizeof(J2kTile)) <nl> +        return AVERROR(EINVAL); <nl> + <nl>      s->tile = av_mallocz(s->numXtiles * s->numYtiles * sizeof(J2kTile)); <nl>      if (!s->tile) <nl>          return AVERROR(ENOMEM);
@@ -888,8 +888,10 @@ end: <nl>  int ff_get_buffer(AVCodecContext *avctx, AVFrame *frame, int flags) <nl>  { <nl>      int ret = get_buffer_internal(avctx, frame, flags); <nl> -    if (ret < 0) <nl> +    if (ret < 0) { <nl>          av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n"); <nl> +        frame->width = frame->height = 0; <nl> +    } <nl>      return ret; <nl>  } <nl>  
@@ -416,6 +416,10 @@ static int query_formats(AVFilterContext *ctx) <nl>   <nl>  static int glyph_enu_free(void *opaque, void *elem) <nl>  { <nl> +    Glyph *glyph = elem; <nl> + <nl> +    FT_Done_Glyph(*glyph->glyph); <nl> +    av_freep(&glyph->glyph); <nl>      av_free(elem); <nl>      return 0; <nl>  }
@@ -175,7 +175,6 @@ void ff_svq3_add_idct_c(uint8_t *dst, DCTELEM *block, int stride, int qp, <nl>  { <nl>      const int qmul = svq3_dequant_coeff[qp]; <nl>      int i; <nl> -    uint8_t *cm = ff_cropTbl + MAX_NEG_CROP; <nl>   <nl>      if (dc) { <nl>          dc = 13*13*((dc == 1) ? 1538*block[0] : ((qmul*(block[0] >> 3)) / 2)); <nl> @@ -201,10 +200,10 @@ void ff_svq3_add_idct_c(uint8_t *dst, DCTELEM *block, int stride, int qp, <nl>          const int z3 = 17* block[i + 4*1] +  7*block[i + 4*3]; <nl>          const int rr = (dc + 0x80000); <nl>   <nl> -        dst[i + stride*0] = cm[ dst[i + stride*0] + (((z0 + z3)*qmul + rr) >> 20) ]; <nl> -        dst[i + stride*1] = cm[ dst[i + stride*1] + (((z1 + z2)*qmul + rr) >> 20) ]; <nl> -        dst[i + stride*2] = cm[ dst[i + stride*2] + (((z1 - z2)*qmul + rr) >> 20) ]; <nl> -        dst[i + stride*3] = cm[ dst[i + stride*3] + (((z0 - z3)*qmul + rr) >> 20) ]; <nl> +        dst[i + stride*0] = av_clip_uint8( dst[i + stride*0] + (((z0 + z3)*qmul + rr) >> 20) ); <nl> +        dst[i + stride*1] = av_clip_uint8( dst[i + stride*1] + (((z1 + z2)*qmul + rr) >> 20) ); <nl> +        dst[i + stride*2] = av_clip_uint8( dst[i + stride*2] + (((z1 - z2)*qmul + rr) >> 20) ); <nl> +        dst[i + stride*3] = av_clip_uint8( dst[i + stride*3] + (((z0 - z3)*qmul + rr) >> 20) ); <nl>      } <nl>  } <nl>  
@@ -1781,7 +1781,8 @@ static void show_format(WriterContext *w, AVFormatContext *fmt_ctx) <nl>      print_str("filename",         fmt_ctx->filename); <nl>      print_int("nb_streams",       fmt_ctx->nb_streams); <nl>      print_str("format_name",      fmt_ctx->iformat->name); <nl> -    print_str("format_long_name", fmt_ctx->iformat->long_name); <nl> +    if (fmt_ctx->iformat->long_name) print_str    ("format_long_name", fmt_ctx->iformat->long_name); <nl> +    else                             print_str_opt("format_long_name", "unknown"); <nl>      print_time("start_time",      fmt_ctx->start_time, &AV_TIME_BASE_Q); <nl>      print_time("duration",        fmt_ctx->duration,   &AV_TIME_BASE_Q); <nl>      if (size >= 0) print_val    ("size", size, unit_byte_str);
@@ -175,6 +175,8 @@ av_cold int ff_rate_control_init(MpegEncContext *s) <nl>          if (i <= 0 || i >= INT_MAX / sizeof(RateControlEntry)) <nl>              return -1; <nl>          rcc->entry       = av_mallocz(i * sizeof(RateControlEntry)); <nl> +        if (!rcc->entry) <nl> +            return AVERROR(ENOMEM); <nl>          rcc->num_entries = i; <nl>   <nl>          /* init all to skipped p frames <nl> @@ -953,6 +955,11 @@ static int init_pass2(MpegEncContext *s) <nl>   <nl>      qscale         = av_malloc_array(rcc->num_entries, sizeof(double)); <nl>      blurred_qscale = av_malloc_array(rcc->num_entries, sizeof(double)); <nl> +    if (!qscale || !blurred_qscale) { <nl> +        av_free(qscale); <nl> +        av_free(blurred_qscale); <nl> +        return AVERROR(ENOMEM); <nl> +    } <nl>      toobig = 0; <nl>   <nl>      for (step = 256 * 256; step > 0.0000001; step *= 0.5) {
@@ -33,6 +33,7 @@ <nl>  #include "fft.h" <nl>  #include "aacps.h" <nl>  #include "libavutil/libm.h" <nl> +#include "libavutil/avassert.h" <nl>   <nl>  #include <stdint.h> <nl>  #include <float.h> <nl> @@ -1457,6 +1458,7 @@ static void sbr_mapping(AACContext *ac, SpectralBandReplication *sbr, <nl>          uint16_t *table = ch_data->bs_freq_res[e + 1] ? sbr->f_tablehigh : sbr->f_tablelow; <nl>          int k; <nl>   <nl> +        av_assert0(sbr->kx[1] <= table[0]); <nl>          for (i = 0; i < ilim; i++) <nl>              for (m = table[i]; m < table[i + 1]; m++) <nl>                  sbr->e_origmapped[e][m - sbr->kx[1]] = ch_data->env_facs[e+1][i];
@@ -461,7 +461,7 @@ int ff_mp4_read_dec_config_descr(AVFormatContext *fc, AVStream *st, AVIOContext <nl>              return AVERROR(ENOMEM); <nl>          avio_read(pb, st->codec->extradata, len); <nl>          if (st->codec->codec_id == AV_CODEC_ID_AAC) { <nl> -            MPEG4AudioConfig cfg; <nl> +            MPEG4AudioConfig cfg = {0}; <nl>              avpriv_mpeg4audio_get_config(&cfg, st->codec->extradata, <nl>                                           st->codec->extradata_size * 8, 1); <nl>              st->codec->channels = cfg.channels;
@@ -1952,10 +1952,17 @@ static int add_metadata_from_side_data(AVCodecContext *avctx, AVFrame *frame) <nl>      if (!side_metadata) <nl>          goto end; <nl>      end = side_metadata + size; <nl> +    if (size && end[-1]) <nl> +        return AVERROR_INVALIDDATA; <nl>      while (side_metadata < end) { <nl>          const uint8_t *key = side_metadata; <nl>          const uint8_t *val = side_metadata + strlen(key) + 1; <nl> -        int ret = av_dict_set(avpriv_frame_get_metadatap(frame), key, val, 0); <nl> +        int ret; <nl> + <nl> +        if (val >= end) <nl> +            return AVERROR_INVALIDDATA; <nl> + <nl> +        ret = av_dict_set(avpriv_frame_get_metadatap(frame), key, val, 0); <nl>          if (ret < 0) <nl>              break; <nl>          side_metadata = val + strlen(val) + 1;
@@ -1965,7 +1965,7 @@ static int decode_frame_mp3on4(AVCodecContext *avctx, void *data, <nl>   <nl>          avpriv_mpegaudio_decode_header((MPADecodeHeader *)m, header); <nl>   <nl> -        if (ch + m->nb_channels > avctx->channels) { <nl> +        if (ch + m->nb_channels > avctx->channels || s->coff[fr] + m->nb_channels > avctx->channels) { <nl>              av_log(avctx, AV_LOG_ERROR, "frame channel count exceeds codec " <nl>                                          "channel count\n"); <nl>              return AVERROR_INVALIDDATA;
@@ -430,6 +430,7 @@ retry: <nl>              if (snprintf(str, str_size_alloc, "%f", val) >= str_size_alloc) { <nl>                  av_log(c->fc, AV_LOG_ERROR, <nl>                         "Failed to store the float32 number (%f) in string.\n", val); <nl> +                av_free(str); <nl>                  return AVERROR_INVALIDDATA; <nl>              } <nl>          } else {
@@ -78,9 +78,13 @@ static void to_meta_with_crop(AVCodecContext *avctx, AVFrame *p, int *dest) <nl>              for (y = blocky; y < blocky + 8 && y < C64YRES; y++) { <nl>                  for (x = blockx; x < blockx + 8 && x < C64XRES; x += 2) { <nl>                      if(x < width && y < height) { <nl> -                        /* build average over 2 pixels */ <nl> -                        luma = (src[(x + 0 + y * p->linesize[0])] + <nl> -                                src[(x + 1 + y * p->linesize[0])]) / 2; <nl> +                        if (x + 1 < width) { <nl> +                            /* build average over 2 pixels */ <nl> +                            luma = (src[(x + 0 + y * p->linesize[0])] + <nl> +                                    src[(x + 1 + y * p->linesize[0])]) / 2; <nl> +                        } else { <nl> +                            luma = src[(x + y * p->linesize[0])]; <nl> +                        } <nl>                          /* write blocks as linear data now so they are suitable for elbg */ <nl>                          dest[0] = luma; <nl>                      }
@@ -3521,7 +3521,7 @@ int av_find_best_stream(AVFormatContext *ic, enum AVMediaType type, <nl>              st->disposition & (AV_DISPOSITION_HEARING_IMPAIRED | <nl>                                 AV_DISPOSITION_VISUAL_IMPAIRED)) <nl>              continue; <nl> -        if (type == AVMEDIA_TYPE_AUDIO && !avctx->channels) <nl> +        if (type == AVMEDIA_TYPE_AUDIO && !(avctx->channels && avctx->sample_rate)) <nl>              continue; <nl>          if (decoder_ret) { <nl>              decoder = find_decoder(ic, st, st->codec->codec_id);
@@ -847,6 +847,8 @@ static void close_connection(HTTPContext *c) <nl>          ctx = c->rtp_ctx[i]; <nl>          if (ctx) { <nl>              av_write_trailer(ctx); <nl> +            av_metadata_free(&ctx->metadata); <nl> +            av_free(ctx->streams[0]); <nl>              av_free(ctx); <nl>          } <nl>          h = c->rtp_handles[i]; <nl> @@ -2280,6 +2282,7 @@ static int http_prepare_data(HTTPContext *c) <nl>              http_log("Error writing output header\n"); <nl>              return -1; <nl>          } <nl> +        av_metadata_free(&c->fmt_ctx.metadata); <nl>   <nl>          len = url_close_dyn_buf(c->fmt_ctx.pb, &c->pb_buffer); <nl>          c->buffer_ptr = c->pb_buffer; <nl> @@ -2954,6 +2957,7 @@ static int prepare_sdp_description(FFStream *stream, uint8_t **pbuffer, <nl>      } <nl>      *pbuffer = av_mallocz(2048); <nl>      avf_sdp_create(&avc, 1, *pbuffer, 2048); <nl> +    av_metadata_free(&avc->metadata); <nl>      av_free(avc); <nl>   <nl>      return strlen(*pbuffer); <nl> @@ -3010,6 +3014,7 @@ static void rtsp_cmd_describe(HTTPContext *c, const char *url) <nl>      url_fprintf(c->pb, "Content-Length: %d\r\n", content_length); <nl>      url_fprintf(c->pb, "\r\n"); <nl>      put_buffer(c->pb, content, content_length); <nl> +    av_free(content); <nl>  } <nl>   <nl>  static HTTPContext *find_rtp_session(const char *session_id)
@@ -1348,6 +1348,12 @@ int av_seek_frame_binary(AVFormatContext *s, int stream_index, int64_t target_ts <nl>          pos_limit= pos_max; <nl>      } <nl>   <nl> +    if(ts_min > ts_max){ <nl> +        return -1; <nl> +    }else if(ts_min == ts_max){ <nl> +        pos_limit= pos_min; <nl> +    } <nl> + <nl>      no_change=0; <nl>      while (pos_min < pos_limit) { <nl>  #ifdef DEBUG_SEEK
@@ -1014,6 +1014,7 @@ static int rv34_decode_macroblock(RV34DecContext *r, int8_t *intra_types) <nl>      cbp = cbp2 = rv34_decode_mb_header(r, intra_types); <nl>      r->cbp_luma  [s->mb_x + s->mb_y * s->mb_stride] = cbp; <nl>      r->cbp_chroma[s->mb_x + s->mb_y * s->mb_stride] = cbp >> 16; <nl> +    s->current_picture.qscale_table[s->mb_x + s->mb_y * s->mb_stride] = s->qscale; <nl>   <nl>      if(cbp == -1) <nl>          return -1;
@@ -617,7 +617,7 @@ static void force_codec_ids(AVFormatContext *s, AVStream *st) <nl>          break; <nl>      case AVMEDIA_TYPE_DATA: <nl>          if (s->data_codec_id) <nl> -            st->codec->codec_id = s->data_codec_id; <nl> +            st->codecpar->codec_id = s->data_codec_id; <nl>          break; <nl>      } <nl>  }
@@ -1016,7 +1016,7 @@ static int handle_p_frame_apng(AVCodecContext *avctx, PNGDecContext *s, <nl>              for (x = s->x_offset; x < s->x_offset + s->cur_w; ++x, foreground += s->bpp, background += s->bpp) { <nl>                  size_t b; <nl>                  uint8_t foreground_alpha, background_alpha, output_alpha; <nl> -                uint8_t output[4]; <nl> +                uint8_t output[10]; <nl>   <nl>                  // Since we might be blending alpha onto alpha, we use the following equations: <nl>                  // output_alpha = foreground_alpha + (1 - foreground_alpha) * background_alpha <nl> @@ -1056,6 +1056,8 @@ static int handle_p_frame_apng(AVCodecContext *avctx, PNGDecContext *s, <nl>   <nl>                  output_alpha = foreground_alpha + FAST_DIV255((255 - foreground_alpha) * background_alpha); <nl>   <nl> +                av_assert0(s->bpp <= 10); <nl> + <nl>                  for (b = 0; b < s->bpp - 1; ++b) { <nl>                      if (output_alpha == 0) { <nl>                          output[b] = 0;
@@ -58,6 +58,11 @@ static int speex_header(AVFormatContext *s, int idx) { <nl>          st->codec->codec_type = AVMEDIA_TYPE_AUDIO; <nl>          st->codec->codec_id = AV_CODEC_ID_SPEEX; <nl>   <nl> +        if (os->psize < 68) { <nl> +            av_log(s, AV_LOG_ERROR, "speex packet too small\n"); <nl> +            return AVERROR_INVALIDDATA; <nl> +        } <nl> + <nl>          st->codec->sample_rate = AV_RL32(p + 36); <nl>          st->codec->channels = AV_RL32(p + 48); <nl>          if (st->codec->channels < 1 || st->codec->channels > 2) {
@@ -174,11 +174,13 @@ static int seg_write_header(AVFormatContext *s) <nl>   <nl>  fail: <nl>      if (ret) { <nl> -        oc->streams = NULL; <nl> -        oc->nb_streams = 0; <nl> +        if (oc) { <nl> +            oc->streams = NULL; <nl> +            oc->nb_streams = 0; <nl> +            avformat_free_context(oc); <nl> +        } <nl>          if (seg->list) <nl>              avio_close(seg->pb); <nl> -        avformat_free_context(oc); <nl>      } <nl>      return ret; <nl>  }
@@ -29,6 +29,7 @@ <nl>   */ <nl>   <nl>  #include <stdio.h> <nl> +#include "libavutil/avassert.h" <nl>  #include "oggdec.h" <nl>  #include "avformat.h" <nl>  #include "internal.h" <nl> @@ -690,6 +691,7 @@ static int ogg_read_seek(AVFormatContext *s, int stream_index, <nl>      struct ogg_stream *os = ogg->streams + stream_index; <nl>      int ret; <nl>   <nl> +    av_assert0(stream_index < ogg->nstreams); <nl>      // Ensure everything is reset even when seeking via <nl>      // the generated index. <nl>      ogg_reset(ogg);
@@ -37,7 +37,7 @@ <nl>   * Powers of 2 are recommended. <nl>   */ <nl>  #ifndef FF_BUFQUEUE_SIZE <nl> -#define FF_BUFQUEUE_SIZE 32 <nl> +#define FF_BUFQUEUE_SIZE 64 <nl>  #endif <nl>   <nl>  #include "avfilter.h"
@@ -63,6 +63,9 @@ static int mp3_read_probe(AVProbeData *p) <nl>      const uint8_t *buf, *buf0, *buf2, *end; <nl>      AVCodecContext *avctx = avcodec_alloc_context3(NULL); <nl>   <nl> +    if (!avctx) <nl> +        return 0; <nl> + <nl>      buf0 = p->buf; <nl>      end = p->buf + p->buf_size - sizeof(uint32_t); <nl>      while(buf0 < end && !*buf0)
@@ -31,14 +31,14 @@ <nl>   <nl>  static const uint8_t *avc_mp4_find_startcode(const uint8_t *start, const uint8_t *end, int nal_length_size) <nl>  { <nl> -    int res = 0; <nl> +    unsigned int res = 0; <nl>   <nl>      if (end - start < nal_length_size) <nl>          return NULL; <nl>      while (nal_length_size--) <nl>          res = (res << 8) | *start++; <nl>   <nl> -    if (start + res > end || res < 0 || start + res < start) <nl> +    if (res > end - start) <nl>          return NULL; <nl>   <nl>      return start + res;
@@ -788,8 +788,8 @@ av_cold int ff_yuv2rgb_c_init_tables(SwsContext *c, const int inv_table[4], int <nl>          y_table32 = c->yuvTable; <nl>          yb = -(384<<16) - oy; <nl>          for (i = 0; i < 1024; i++) { <nl> -            uint8_t yval = av_clip_uint8((yb + 0x8000) >> 16); <nl> -            y_table32[i     ] = (yval << rbase) + (needAlpha ? 0 : (255 << abase)); <nl> +            unsigned yval = av_clip_uint8((yb + 0x8000) >> 16); <nl> +            y_table32[i     ] = (yval << rbase) + (needAlpha ? 0 : (255u << abase)); <nl>              y_table32[i+1024] = yval << gbase; <nl>              y_table32[i+2048] = yval << bbase; <nl>              yb += cy;
@@ -285,7 +285,6 @@ static inline uint32_t celt_icwrsi(uint32_t N, uint32_t K, const int *y) <nl>          idx += CELT_PVQ_U(N - i, sum) + (y[i] < 0)*i_s; <nl>          sum += FFABS(y[i]); <nl>      } <nl> -    av_assert0(sum == K); <nl>      return idx; <nl>  } <nl>  
@@ -210,7 +210,7 @@ static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame, <nl>      AVFrame *const p = data; <nl>      int mb_x, mb_y, ret; <nl>   <nl> -    if (buf_size * 8LL < a->mb_height2 * a->mb_width2 * 13LL) <nl> +    if (buf_size * 8LL < a->mb_height * a->mb_width * 13LL) <nl>          return AVERROR_INVALIDDATA; <nl>   <nl>      if ((ret = ff_get_buffer(avctx, p, 0)) < 0)
@@ -226,8 +226,10 @@ static int unpack_bitstream(G723_1_Context *p, const uint8_t *buf, <nl>  /** <nl>   * Bitexact implementation of sqrt(val/2). <nl>   */ <nl> -static int16_t square_root(int val) <nl> +static int16_t square_root(unsigned val) <nl>  { <nl> +    av_assert2(!(val & 0x80000000)); <nl> + <nl>      return (ff_sqrt(val << 1) >> 1) & (~1); <nl>  } <nl>  
@@ -533,7 +533,7 @@ static void ffmpeg_cleanup(int ret) <nl>          avcodec_free_context(&ost->enc_ctx); <nl>          avcodec_parameters_free(&ost->ref_par); <nl>   <nl> -        while (av_fifo_size(ost->muxing_queue)) { <nl> +        while (ost->muxing_queue && av_fifo_size(ost->muxing_queue)) { <nl>              AVPacket pkt; <nl>              av_fifo_generic_read(ost->muxing_queue, &pkt, sizeof(pkt), NULL); <nl>              av_packet_unref(&pkt);
@@ -76,10 +76,10 @@ void FUNCC(ff_h264_idct8_add)(uint8_t *_dst, int16_t *_block, int stride){ <nl>   <nl>      for( i = 0; i < 8; i++ ) <nl>      { <nl> -        const unsigned int a0 =  block[i+0*8] + block[i+4*8]; <nl> -        const unsigned int a2 =  block[i+0*8] - block[i+4*8]; <nl> -        const unsigned int a4 = (block[i+2*8]>>1) - block[i+6*8]; <nl> -        const unsigned int a6 = (block[i+6*8]>>1) + block[i+2*8]; <nl> +        const unsigned int a0 =  block[i+0*8] + (unsigned)block[i+4*8]; <nl> +        const unsigned int a2 =  block[i+0*8] - (unsigned)block[i+4*8]; <nl> +        const unsigned int a4 = (block[i+2*8]>>1) - (unsigned)block[i+6*8]; <nl> +        const unsigned int a6 = (block[i+6*8]>>1) + (unsigned)block[i+2*8]; <nl>   <nl>          const unsigned int b0 = a0 + a6; <nl>          const unsigned int b2 = a2 + a4;
@@ -347,6 +347,10 @@ int ff_h264_decode_seq_parameter_set(H264Context *h){ <nl>   <nl>      if(sps->profile_idc >= 100){ //high profile <nl>          sps->chroma_format_idc= get_ue_golomb_31(&s->gb); <nl> +        if (sps->chroma_format_idc > 3U) { <nl> +            av_log(h->s.avctx, AV_LOG_ERROR, "chroma_format_idc %d is illegal\n", sps->chroma_format_idc); <nl> +            goto fail; <nl> +        } <nl>          if(sps->chroma_format_idc == 3) <nl>              sps->residual_color_transform_flag = get_bits1(&s->gb); <nl>          sps->bit_depth_luma   = get_ue_golomb(&s->gb) + 8;
@@ -238,11 +238,11 @@ static int caf_write_packet(AVFormatContext *s, AVPacket *pkt) <nl>   <nl>  static int caf_write_trailer(AVFormatContext *s) <nl>  { <nl> +    CAFContext *caf = s->priv_data; <nl>      AVIOContext *pb = s->pb; <nl>      AVCodecContext *enc = s->streams[0]->codec; <nl>   <nl>      if (pb->seekable) { <nl> -        CAFContext *caf = s->priv_data; <nl>          int64_t file_size = avio_tell(pb); <nl>   <nl>          avio_seek(pb, caf->data, SEEK_SET); <nl> @@ -256,11 +256,11 @@ static int caf_write_trailer(AVFormatContext *s) <nl>              avio_wb32(pb, 0); ///< mPrimingFrames <nl>              avio_wb32(pb, 0); ///< mRemainderFrames <nl>              avio_write(pb, caf->pkt_sizes, caf->size_entries_used); <nl> -            av_freep(&caf->pkt_sizes); <nl>              caf->size_buffer_size = 0; <nl>          } <nl>          avio_flush(pb); <nl>      } <nl> +    av_freep(&caf->pkt_sizes); <nl>      return 0; <nl>  } <nl>  
@@ -42,7 +42,7 @@ IDeckLinkIterator *CreateDeckLinkIteratorInstance(void) <nl>  { <nl>      IDeckLinkIterator *iter; <nl>   <nl> -    if (CoInitialize(NULL) != S_OK) { <nl> +    if (CoInitialize(NULL) < 0) { <nl>          av_log(NULL, AV_LOG_ERROR, "COM initialization failed.\n"); <nl>          return NULL; <nl>      }
@@ -1351,6 +1351,9 @@ static int vp8_lossy_decode_frame(AVCodecContext *avctx, AVFrame *p, <nl>      if (ret < 0) <nl>          return ret; <nl>   <nl> +    if (!*got_frame) <nl> +        return AVERROR_INVALIDDATA; <nl> + <nl>      update_canvas_size(avctx, avctx->width, avctx->height); <nl>   <nl>      if (s->has_alpha) {
@@ -78,6 +78,7 @@ typedef struct { <nl>      IVIPicConfig    pic_conf; <nl>   <nl>      int gop_invalid; <nl> +    int buf_invalid[3]; <nl>  } IVI5DecContext; <nl>   <nl>   <nl> @@ -797,6 +798,7 @@ static int decode_frame(AVCodecContext *avctx, void *data, int *data_size, <nl>      //{ START_TIMER; <nl>   <nl>      if (ctx->frame_type != FRAMETYPE_NULL) { <nl> +        ctx->buf_invalid[ctx->dst_buf] = 1; <nl>          for (p = 0; p < 3; p++) { <nl>              for (b = 0; b < ctx->planes[p].num_bands; b++) { <nl>                  result = decode_band(ctx, p, &ctx->planes[p].bands[b], avctx); <nl> @@ -807,7 +809,10 @@ static int decode_frame(AVCodecContext *avctx, void *data, int *data_size, <nl>                  } <nl>              } <nl>          } <nl> +        ctx->buf_invalid[ctx->dst_buf] = 0; <nl>      } <nl> +    if (ctx->buf_invalid[ctx->dst_buf]) <nl> +        return -1; <nl>   <nl>      //STOP_TIMER("decode_planes"); } <nl>  
@@ -374,7 +374,7 @@ static int decode_header(SnowContext *s){ <nl>          } <nl>      } <nl>   <nl> -    s->spatial_decomposition_type+= get_symbol(&s->c, s->header_state, 1); <nl> +    s->spatial_decomposition_type+= (unsigned)get_symbol(&s->c, s->header_state, 1); <nl>      if(s->spatial_decomposition_type > 1U){ <nl>          av_log(s->avctx, AV_LOG_ERROR, "spatial_decomposition_type %d not supported\n", s->spatial_decomposition_type); <nl>          return AVERROR_INVALIDDATA; <nl> @@ -390,10 +390,10 @@ static int decode_header(SnowContext *s){ <nl>      } <nl>   <nl>   <nl> -    s->qlog           += get_symbol(&s->c, s->header_state, 1); <nl> -    s->mv_scale       += get_symbol(&s->c, s->header_state, 1); <nl> -    s->qbias          += get_symbol(&s->c, s->header_state, 1); <nl> -    s->block_max_depth+= get_symbol(&s->c, s->header_state, 1); <nl> +    s->qlog           += (unsigned)get_symbol(&s->c, s->header_state, 1); <nl> +    s->mv_scale       += (unsigned)get_symbol(&s->c, s->header_state, 1); <nl> +    s->qbias          += (unsigned)get_symbol(&s->c, s->header_state, 1); <nl> +    s->block_max_depth+= (unsigned)get_symbol(&s->c, s->header_state, 1); <nl>      if(s->block_max_depth > 1 || s->block_max_depth < 0 || s->mv_scale > 256U){ <nl>          av_log(s->avctx, AV_LOG_ERROR, "block_max_depth= %d is too large\n", s->block_max_depth); <nl>          s->block_max_depth= 0;
@@ -969,10 +969,7 @@ static int handle_p_frame_apng(AVCodecContext *avctx, PNGDecContext *s, <nl>                                 AVFrame *p) <nl>  { <nl>      size_t x, y; <nl> -    uint8_t *buffer = av_malloc(s->image_linesize * s->height); <nl> - <nl> -    if (!buffer) <nl> -        return AVERROR(ENOMEM); <nl> +    uint8_t *buffer; <nl>   <nl>      if (s->blend_op == APNG_BLEND_OP_OVER && <nl>          avctx->pix_fmt != AV_PIX_FMT_RGBA && <nl> @@ -983,6 +980,11 @@ static int handle_p_frame_apng(AVCodecContext *avctx, PNGDecContext *s, <nl>          return AVERROR_PATCHWELCOME; <nl>      } <nl>   <nl> +    buffer = av_malloc(s->image_linesize * s->height); <nl> +    if (!buffer) <nl> +        return AVERROR(ENOMEM); <nl> + <nl> + <nl>      // Do the disposal operation specified by the last frame on the frame <nl>      if (s->last_dispose_op != APNG_DISPOSE_OP_PREVIOUS) { <nl>          ff_thread_await_progress(&s->last_picture, INT_MAX, 0);
@@ -59,7 +59,7 @@ static void sdp_write_header(char *buff, int size, struct sdp_session_level *s) <nl>                              "o=- %d %d IN IPV4 %s\r\n" <nl>                              "t=%d %d\r\n" <nl>                              "s=%s\r\n" <nl> -                            "a=tool:libavformat\r\n", <nl> +                            "a=tool:libavformat " AV_STRINGIFY(LIBAVFORMAT_VERSION) "\r\n", <nl>                              s->sdp_version, <nl>                              s->id, s->version, s->src_addr, <nl>                              s->start_time, s->end_time,
@@ -75,6 +75,11 @@ ogm_header(AVFormatContext *s, int idx) <nl>   <nl>          time_unit   = bytestream2_get_le64(&p); <nl>          spu         = bytestream2_get_le64(&p); <nl> +        if (!time_unit || !spu) { <nl> +            av_log(s, AV_LOG_ERROR, "Invalid timing values.\n"); <nl> +            return AVERROR_INVALIDDATA; <nl> +        } <nl> + <nl>          bytestream2_skip(&p, 4);    /* default_len */ <nl>          bytestream2_skip(&p, 8);    /* buffersize + bits_per_sample */ <nl>  
@@ -59,6 +59,11 @@ static av_cold int init(AVFilterContext *ctx) <nl>      int nb_formats = 1; <nl>      int i; <nl>   <nl> +    if (!s->pix_fmts) { <nl> +        av_log(ctx, AV_LOG_ERROR, "Empty output format string.\n"); <nl> +        return AVERROR(EINVAL); <nl> +    } <nl> + <nl>      /* count the formats */ <nl>      cur = s->pix_fmts; <nl>      while ((cur = strchr(cur, '|'))) {
@@ -453,6 +453,10 @@ static int decode_mb_info(IVI5DecContext *ctx, IVIBandDesc *band, <nl>      ref_mb = tile->ref_mbs; <nl>      offs   = tile->ypos * band->pitch + tile->xpos; <nl>   <nl> +    if (!ref_mb && <nl> +        ((band->qdelta_present && band->inherit_qdelta) || band->inherit_mv)) <nl> +        return AVERROR_INVALIDDATA; <nl> + <nl>      /* scale factor for motion vectors */ <nl>      mv_scale = (ctx->planes[0].bands[0].mb_size >> 3) - (band->mb_size >> 3); <nl>      mv_x = mv_y = 0;
@@ -148,7 +148,7 @@ void ff_convert_matrix(MpegEncContext *s, int (*qmat)[64], <nl>                      qmat16[qscale][0][i] == 128 * 256) <nl>                      qmat16[qscale][0][i] = 128 * 256 - 1; <nl>                  qmat16[qscale][1][i] = <nl> -                    ROUNDED_DIV(bias << (16 - QUANT_BIAS_SHIFT), <nl> +                    ROUNDED_DIV(bias * (1<<(16 - QUANT_BIAS_SHIFT)), <nl>                                  qmat16[qscale][0][i]); <nl>              } <nl>          }
@@ -1078,6 +1078,8 @@ static int encode_audio_frame(AVFormatContext *s, OutputStream *ost, <nl>              av_log(NULL, AV_LOG_FATAL, "Audio encoding failed\n"); <nl>              exit_program(1); <nl>          } <nl> + <nl> +        ost->sync_opts += frame->nb_samples; <nl>      } <nl>   <nl>      got_packet = 0; <nl> @@ -1101,9 +1103,6 @@ static int encode_audio_frame(AVFormatContext *s, OutputStream *ost, <nl>          av_free_packet(&pkt); <nl>      } <nl>   <nl> -    if (frame) <nl> -        ost->sync_opts += frame->nb_samples; <nl> - <nl>      return ret; <nl>  } <nl>   <nl> @@ -1356,6 +1355,8 @@ static void do_subtitle_out(AVFormatContext *s, <nl>          nb = 1; <nl>   <nl>      for (i = 0; i < nb; i++) { <nl> +        ost->sync_opts = av_rescale_q(pts, ist->st->time_base, enc->time_base); <nl> + <nl>          sub->pts = av_rescale_q(pts, ist->st->time_base, AV_TIME_BASE_Q); <nl>          // start_display_time is required to be 0 <nl>          sub->pts               += av_rescale_q(sub->start_display_time, (AVRational){ 1, 1000 }, AV_TIME_BASE_Q);
@@ -793,7 +793,11 @@ static int vorbis_parse_setup_hdr_modes(vorbis_context *vc) { <nl>          mode_setup->blockflag=get_bits1(gb); <nl>          mode_setup->windowtype=get_bits(gb, 16); //FIXME check <nl>          mode_setup->transformtype=get_bits(gb, 16); //FIXME check <nl> -        mode_setup->mapping=get_bits(gb, 8); //FIXME check <nl> +        mode_setup->mapping=get_bits(gb, 8); <nl> +        if (mode_setup->mapping>=vc->mapping_count) { <nl> +            av_log(vc->avccontext, AV_LOG_ERROR, "mode mapping value %d out of range. \n", mode_setup->mapping); <nl> +            return 1; <nl> +        } <nl>   <nl>          AV_DEBUG(" %d mode: blockflag %d, windowtype %d, transformtype %d, mapping %d \n", i, mode_setup->blockflag, mode_setup->windowtype, mode_setup->transformtype, mode_setup->mapping); <nl>      } <nl> @@ -1450,6 +1454,10 @@ static int vorbis_parse_audio_packet(vorbis_context *vc) { <nl>      } else { <nl>          mode_number=get_bits(gb, ilog(vc->mode_count-1)); <nl>      } <nl> +    if (mode_number>=vc->mode_count) { <nl> +        av_log(vc->avccontext, AV_LOG_ERROR, "mode number %d out of range.\n", mode_number); <nl> +        return -1; <nl> +    } <nl>      vc->mode_number=mode_number; <nl>      mapping=&vc->mappings[vc->modes[mode_number].mapping]; <nl>  
@@ -618,9 +618,12 @@ static int svq1_decode_frame(AVCodecContext *avctx, void *data, <nl>      uint8_t *current; <nl>      int result, i, x, y, width, height; <nl>      svq1_pmv *pmv; <nl> +    int ret; <nl>   <nl>      /* initialize bit buffer */ <nl> -    init_get_bits8(&s->gb, buf, buf_size); <nl> +    ret = init_get_bits8(&s->gb, buf, buf_size); <nl> +    if (ret < 0) <nl> +        return ret; <nl>   <nl>      /* decode frame header */ <nl>      s->frame_code = get_bits(&s->gb, 22);
@@ -861,6 +861,12 @@ static int wavpack_decode_block(AVCodecContext *avctx, int block_no, <nl>                  s->and   = 1; <nl>                  s->shift = val[3]; <nl>              } <nl> +            if (s->shift > 31) { <nl> +                av_log(avctx, AV_LOG_ERROR, <nl> +                       "Invalid INT32INFO, shift = %d (> 31)\n", s->shift); <nl> +                s->and = s->or = s->shift = 0; <nl> +                continue; <nl> +            } <nl>              /* original WavPack decoder forces 32-bit lossy sound to be treated <nl>               * as 24-bit one in order to have proper clipping */ <nl>              if (s->hybrid && bpp == 4 && s->post_shift < 8 && s->shift > 8) {
@@ -87,7 +87,7 @@ static int decode_ext_header(Wmv2Context *w){ <nl>   <nl>      if(s->avctx->extradata_size<4) return -1; <nl>   <nl> -    init_get_bits(&gb, s->avctx->extradata, s->avctx->extradata_size*8); <nl> +    init_get_bits(&gb, s->avctx->extradata, 32); <nl>   <nl>      fps                = get_bits(&gb, 5); <nl>      s->bit_rate        = get_bits(&gb, 11)*1024;
@@ -940,6 +940,7 @@ static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPac <nl>          else                     v = buf_p - c->bytestream_start; <nl>          if (buf_p - c->bytestream_start < v) { <nl>              av_log(avctx, AV_LOG_ERROR, "Slice pointer chain broken\n"); <nl> +            ff_thread_report_progress(&f->picture, INT_MAX, 0); <nl>              return AVERROR_INVALIDDATA; <nl>          } <nl>          buf_p -= v;
@@ -3792,7 +3792,8 @@ static int decode_slice_header(H264Context *h, H264Context *h0){ <nl>          while(h->frame_num !=  h->prev_frame_num && <nl>                h->frame_num != (h->prev_frame_num+1)%(1<<h->sps.log2_max_frame_num)){ <nl>              av_log(NULL, AV_LOG_DEBUG, "Frame num gap %d %d\n", h->frame_num, h->prev_frame_num); <nl> -            frame_start(h); <nl> +            if (frame_start(h) < 0) <nl> +                return -1; <nl>              h->prev_frame_num++; <nl>              h->prev_frame_num %= 1<<h->sps.log2_max_frame_num; <nl>              s->current_picture_ptr->frame_num= h->prev_frame_num;
@@ -72,7 +72,7 @@ typedef struct CompandContext { <nl>  #define A AV_OPT_FLAG_AUDIO_PARAM|AV_OPT_FLAG_FILTERING_PARAM <nl>   <nl>  static const AVOption compand_options[] = { <nl> -    { "attacks", "set time over which increase of volume is determined", OFFSET(attacks), AV_OPT_TYPE_STRING, { .str = "0.3" }, 0, 0, A }, <nl> +    { "attacks", "set time over which increase of volume is determined", OFFSET(attacks), AV_OPT_TYPE_STRING, { .str = "0" }, 0, 0, A }, <nl>      { "decays", "set time over which decrease of volume is determined", OFFSET(decays), AV_OPT_TYPE_STRING, { .str = "0.8" }, 0, 0, A }, <nl>      { "points", "set points of transfer function", OFFSET(points), AV_OPT_TYPE_STRING, { .str = "-70/-70|-60/-20|1/0" }, 0, 0, A }, <nl>      { "soft-knee", "set soft-knee", OFFSET(curve_dB), AV_OPT_TYPE_DOUBLE, { .dbl = 0.01 }, 0.01, 900, A },
@@ -590,8 +590,10 @@ static int asf_read_metadata_obj(AVFormatContext *s, const GUIDParseTable *g) <nl>                           buflen); <nl>          if (!strcmp(name, "AspectRatioX") || !strcmp(name, "AspectRatioY")) { <nl>              ret = asf_store_aspect_ratio(s, st_num, name, type); <nl> -            if (ret < 0) <nl> -                return ret; <nl> +            if (ret < 0) { <nl> +                av_freep(&name); <nl> +                break; <nl> +            } <nl>          } else { <nl>              if (st_num < ASF_MAX_STREAMS) { <nl>                  if ((ret = process_metadata(s, name, name_len, val_len, type,
@@ -1098,7 +1098,11 @@ av_cold int sws_init_context(SwsContext *c, SwsFilter *srcFilter, <nl>          } <nl>      } <nl>   <nl> -#define USE_MMAP (HAVE_MMAP && HAVE_MPROTECT && defined MAP_ANONYMOUS) <nl> +#if HAVE_MMAP && HAVE_MPROTECT && defined(MAP_ANONYMOUS) <nl> +#define USE_MMAP 1 <nl> +#else <nl> +#define USE_MMAP 0 <nl> +#endif <nl>   <nl>      /* precalculate horizontal scaler filter coefficients */ <nl>      {
@@ -384,7 +384,8 @@ int avpriv_dv_produce_packet(DVDemuxContext *c, AVPacket *pkt, <nl>         c->audio_pkt[i].pts  = c->abytes * 30000*8 / c->ast[i]->codec->bit_rate; <nl>         ppcm[i] = c->audio_buf[i]; <nl>      } <nl> -    dv_extract_audio(buf, ppcm, c->sys); <nl> +    if (c->ach) <nl> +        dv_extract_audio(buf, ppcm, c->sys); <nl>   <nl>      /* We work with 720p frames split in half, thus even frames have <nl>       * channels 0,1 and odd 2,3. */
@@ -245,14 +245,6 @@ static int hevc_handle_packet(AVFormatContext *ctx, PayloadContext *rtp_hevc_ctx <nl>      case 39: <nl>      /* single NAL unit packet */ <nl>      default: <nl> -        /* sanity check for size of input packet: 1 byte payload at least */ <nl> -        if (len < 1) { <nl> -            av_log(ctx, AV_LOG_ERROR, <nl> -                   "Too short RTP/HEVC packet, got %d bytes of NAL unit type %d\n", <nl> -                   len, nal_type); <nl> -            return AVERROR_INVALIDDATA; <nl> -        } <nl> - <nl>          /* create A/V packet */ <nl>          if ((res = av_new_packet(pkt, sizeof(start_sequence) + len)) < 0) <nl>              return res;
@@ -298,9 +298,9 @@ static int commit_bitstream_and_slice_buffer(AVCodecContext *avctx, <nl>      const H264Picture *current_picture = h->cur_pic_ptr; <nl>      struct dxva2_picture_context *ctx_pic = current_picture->hwaccel_picture_private; <nl>      DXVA_Slice_H264_Short *slice = NULL; <nl> -    void     *dxva_data_ptr; <nl> +    void     *dxva_data_ptr = NULL; <nl>      uint8_t  *dxva_data, *current, *end; <nl> -    unsigned dxva_size; <nl> +    unsigned dxva_size = 0; <nl>      void     *slice_data; <nl>      unsigned slice_size; <nl>      unsigned padding;
@@ -770,7 +770,8 @@ static int parse_bintree(Indeo3DecodeContext *ctx, AVCodecContext *avctx, <nl>                  /* get motion vector index and setup the pointer to the mv set */ <nl>                  if (!ctx->need_resync) <nl>                      ctx->next_cell_data = &ctx->gb.buffer[(get_bits_count(&ctx->gb) + 7) >> 3]; <nl> -                curr_cell.mv_ptr = &ctx->mc_vectors[*(ctx->next_cell_data++) << 1]; <nl> +                if(ctx->mc_vectors) <nl> +                    curr_cell.mv_ptr = &ctx->mc_vectors[*(ctx->next_cell_data++) << 1]; <nl>                  curr_cell.tree   = 1; /* enter the VQ tree */ <nl>                  UPDATE_BITPOS(8); <nl>              } else { /* VQ tree DATA code */
@@ -2566,6 +2566,7 @@ static const AVProfile mpeg2_video_profiles[] = { <nl>      { FF_PROFILE_MPEG2_SIMPLE,       "Simple"             }, <nl>      { FF_PROFILE_RESERVED,           "Reserved"           }, <nl>      { FF_PROFILE_RESERVED,           "Reserved"           }, <nl> +    { FF_PROFILE_UNKNOWN }, <nl>  }; <nl>   <nl>  
@@ -163,10 +163,11 @@ static int av_cold libopus_encode_init(AVCodecContext *avctx) <nl>   <nl>      /* FIXME: Opus can handle up to 255 channels. However, the mapping for <nl>       * anything greater than 8 is undefined. */ <nl> -    if (avctx->channels > 8) <nl> -        av_log(avctx, AV_LOG_WARNING, <nl> +    if (avctx->channels > 8) { <nl> +        av_log(avctx, AV_LOG_ERROR, <nl>                 "Channel layout undefined for %d channels.\n", avctx->channels); <nl> - <nl> +        return AVERROR_PATCHWELCOME; <nl> +    } <nl>      if (!avctx->bit_rate) { <nl>          /* Sane default copied from opusenc */ <nl>          avctx->bit_rate = 64000 * opus->stream_count +
@@ -125,7 +125,7 @@ static int vp8_packet(AVFormatContext *s, int idx) <nl>          os->lastdts = vp8_gptopts(s, idx, os->granule, NULL) - duration; <nl>          if(s->streams[idx]->start_time == AV_NOPTS_VALUE) { <nl>              s->streams[idx]->start_time = os->lastpts; <nl> -            if (s->streams[idx]->duration) <nl> +            if (s->streams[idx]->duration && s->streams[idx]->duration != AV_NOPTS_VALUE) <nl>                  s->streams[idx]->duration -= s->streams[idx]->start_time; <nl>          } <nl>      }
@@ -710,7 +710,7 @@ int sws_setColorspaceDetails(SwsContext *c, const int inv_table[4], int srcRange <nl>   <nl>  int sws_getColorspaceDetails(SwsContext *c, int **inv_table, int *srcRange, int **table, int *dstRange, int *brightness, int *contrast, int *saturation) <nl>  { <nl> -    if (isYUV(c->dstFormat) || isGray(c->dstFormat)) return -1; <nl> +    if (!c || isYUV(c->dstFormat) || isGray(c->dstFormat)) return -1; <nl>   <nl>      *inv_table = c->srcColorspaceTable; <nl>      *table     = c->dstColorspaceTable;
@@ -1175,7 +1175,14 @@ static int ac3_decode_frame(AVCodecContext * avctx, void *data, int *data_size, <nl>                  av_log(avctx, AV_LOG_ERROR, "invalid frame size\n"); <nl>                  break; <nl>              case AC3_PARSE_ERROR_FRAME_TYPE: <nl> +                /* skip frame if CRC is ok. otherwise use error concealment. */ <nl> +                /* TODO: add support for substreams and dependent frames */ <nl> +                if(s->frame_type == EAC3_FRAME_TYPE_DEPENDENT || s->substreamid) { <nl> +                    av_log(avctx, AV_LOG_ERROR, "unsupported frame type : skipping frame\n"); <nl> +                    return s->frame_size; <nl> +                } else { <nl>                  av_log(avctx, AV_LOG_ERROR, "invalid frame type\n"); <nl> +                } <nl>                  break; <nl>              default: <nl>                  av_log(avctx, AV_LOG_ERROR, "invalid header\n");
@@ -719,8 +719,10 @@ static int ogg_read_header(AVFormatContext *s) <nl>                     "Headers mismatch for stream %d: " <nl>                     "expected %d received %d.\n", <nl>                     i, os->codec->nb_header, os->nb_header); <nl> -            if (s->error_recognition & AV_EF_EXPLODE) <nl> +            if (s->error_recognition & AV_EF_EXPLODE) { <nl> +                ogg_read_close(s); <nl>                  return AVERROR_INVALIDDATA; <nl> +            } <nl>          } <nl>          if (os->start_granule != OGG_NOGRANULE_VALUE) <nl>              os->lastpts = s->streams[i]->start_time =
@@ -1125,6 +1125,7 @@ resync: <nl>          err= av_get_packet(pb, pkt, size); <nl>          if(err<0) <nl>              return err; <nl> +        size = err; <nl>   <nl>          if(ast->has_pal && pkt->data && pkt->size<(unsigned)INT_MAX/2){ <nl>              uint8_t *pal;
@@ -257,7 +257,7 @@ static const QCELPBitmap qcelp_rate_octave_bitmap[] = { <nl>      QCELP_OF(lspv   [8], 0, 1), //  8 <nl>      QCELP_OF(cbsign[15], 0, 1), //  7 <nl>      QCELP_OF(lspv   [9], 0, 1), //  6 <nl> -    QCELP_OF(cbgain [0], 0, 2), //  7 <nl> +    QCELP_OF(cbgain [0], 0, 2), //  5 <nl>      QCELP_OF(reserved,   0, 4)  //  3 <nl>  }; <nl>  
@@ -473,9 +473,11 @@ static int mov_read_dref(MOVContext *c, AVIOContext *pb, MOVAtom atom) <nl>   <nl>      avio_rb32(pb); // version + flags <nl>      entries = avio_rb32(pb); <nl> -    if (entries >  (atom.size - 1) / MIN_DATA_ENTRY_BOX_SIZE + 1 || <nl> +    if (!entries || <nl> +        entries >  (atom.size - 1) / MIN_DATA_ENTRY_BOX_SIZE + 1 || <nl>          entries >= UINT_MAX / sizeof(*sc->drefs)) <nl>          return AVERROR_INVALIDDATA; <nl> +    sc->drefs_count = 0; <nl>      av_free(sc->drefs); <nl>      sc->drefs = av_mallocz(entries * sizeof(*sc->drefs)); <nl>      if (!sc->drefs)
@@ -685,6 +685,7 @@ void ff_er_frame_end(MpegEncContext *s){ <nl>      if(!s->error_recognition || s->error_count==0 || s->avctx->lowres || <nl>         s->avctx->hwaccel || <nl>         s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU || <nl> +       s->picture_structure != PICT_FRAME || // we dont support ER of field pictures yet, though it should not crash if enabled <nl>         s->error_count==3*s->mb_width*(s->avctx->skip_top + s->avctx->skip_bottom)) return; <nl>   <nl>      if(s->current_picture.motion_val[0] == NULL){
@@ -2506,7 +2506,7 @@ static int mov_read_ctts(MOVContext *c, AVIOContext *pb, MOVAtom atom) <nl>          av_log(c->fc, AV_LOG_TRACE, "count=%d, duration=%d\n", <nl>                  count, duration); <nl>   <nl> -        if (FFABS(duration) > (1<<28) && i+2<entries) { <nl> +        if (FFNABS(duration) < -(1<<28) && i+2<entries) { <nl>              av_log(c->fc, AV_LOG_WARNING, "CTTS invalid\n"); <nl>              av_freep(&sc->ctts_data); <nl>              sc->ctts_count = 0;
@@ -1125,11 +1125,11 @@ static int av_encode(AVFormatContext **output_files, <nl>              switch (ist->st->codec.codec_type) { <nl>              case CODEC_TYPE_AUDIO: <nl>                  av_frac_init(&ist->next_pts,  <nl> -                             0, 0, is->pts_num * ist->st->codec.sample_rate); <nl> +                             0, 0, (uint64_t)is->pts_num * ist->st->codec.sample_rate); <nl>                  break; <nl>              case CODEC_TYPE_VIDEO: <nl>                  av_frac_init(&ist->next_pts,  <nl> -                             0, 0, is->pts_num * ist->st->codec.frame_rate); <nl> +                             0, 0, (uint64_t)is->pts_num * ist->st->codec.frame_rate); <nl>                  break; <nl>              default: <nl>                  break; <nl> @@ -1275,7 +1275,7 @@ static int av_encode(AVFormatContext **output_files, <nl>                      } <nl>                      data_buf = (uint8_t *)samples; <nl>  		    av_frac_add(&ist->next_pts,  <nl> -			        is->pts_den * data_size / (2 * ist->st->codec.channels)); <nl> +			        (uint64_t)is->pts_den * data_size / (2 * ist->st->codec.channels)); <nl>                      break; <nl>                  case CODEC_TYPE_VIDEO: <nl>                      { <nl> @@ -1300,7 +1300,7 @@ static int av_encode(AVFormatContext **output_files, <nl>                              continue; <nl>                          } <nl>                          av_frac_add(&ist->next_pts,  <nl> -			            is->pts_den * ist->st->codec.frame_rate_base);           <nl> +			            (uint64_t)is->pts_den * ist->st->codec.frame_rate_base);           <nl>                      } <nl>                      break; <nl>                  default:
@@ -134,6 +134,10 @@ static int fourxm_read_header(AVFormatContext *s) <nl>          } <nl>   <nl>          if (fourcc_tag == std__TAG) { <nl> +            if (header_size < i + 16) { <nl> +                av_log(s, AV_LOG_ERROR, "std TAG truncated\n"); <nl> +                return AVERROR_INVALIDDATA; <nl> +            } <nl>              fourxm->fps = av_int2float(AV_RL32(&header[i + 12])); <nl>          } else if (fourcc_tag == vtrk_TAG) { <nl>              /* check that there is enough data */
@@ -290,8 +290,8 @@ static int parse_object_segment(AVCodecContext *avctx, <nl>      height = bytestream_get_be16(&buf); <nl>   <nl>      /* Make sure the bitmap is not too large */ <nl> -    if (avctx->width < width || avctx->height < height) { <nl> -        av_log(avctx, AV_LOG_ERROR, "Bitmap dimensions larger than video.\n"); <nl> +    if (avctx->width < width || avctx->height < height || !width || !height) { <nl> +        av_log(avctx, AV_LOG_ERROR, "Bitmap dimensions (%dx%d) invalid.\n", width, height); <nl>          return AVERROR_INVALIDDATA; <nl>      } <nl>  
@@ -491,7 +491,7 @@ static int decode_subframe(TAKDecContext *s, int32_t *decoded, <nl>                       s->residues[i + j + 1] * s->filter[j + 1] + <nl>                       s->residues[i + j    ] * s->filter[j    ]; <nl>              } <nl> -            v = (av_clip_intp2(v >> filter_quant, 13) * (1 << dshift)) - *decoded; <nl> +            v = (av_clip_intp2(v >> filter_quant, 13) * (1 << dshift)) - (unsigned)*decoded; <nl>              *decoded++ = v; <nl>              s->residues[filter_order + i] = v >> dshift; <nl>          }
@@ -163,7 +163,7 @@ static int decode_frame(AVCodecContext *avctx, <nl>          if(i) { <nl>              AVRational q = av_d2q(av_int2float(i), 4096); <nl>              if (q.num > 0 && q.den > 0) <nl> -                avctx->time_base = av_inv_q(q); <nl> +                avctx->framerate = q; <nl>          } <nl>      } <nl>  
@@ -350,6 +350,7 @@ static int config_props(AVFilterLink *outlink) <nl>      scale->isws[0] = scale->isws[1] = scale->sws = NULL; <nl>      if (inlink0->w == outlink->w && <nl>          inlink0->h == outlink->h && <nl> +        !scale->out_color_matrix && <nl>          scale->in_range == scale->out_range && <nl>          inlink0->format == outlink->format) <nl>          ;
@@ -1129,6 +1129,7 @@ static void update_initial_timestamps(AVFormatContext *s, int stream_index, <nl>      if (st->first_dts != AV_NOPTS_VALUE || <nl>          dts           == AV_NOPTS_VALUE || <nl>          st->cur_dts   == AV_NOPTS_VALUE || <nl> +        st->cur_dts < INT_MIN + RELATIVE_TS_BASE || <nl>          is_relative(dts)) <nl>          return; <nl>  
@@ -784,7 +784,7 @@ static int avcodec_find_best_pix_fmt1(int64_t pix_fmt_mask, <nl>      dst_pix_fmt = -1; <nl>      min_dist = 0x7fffffff; <nl>      for(i = 0;i < PIX_FMT_NB; i++) { <nl> -        if (pix_fmt_mask & (1 << i)) { <nl> +        if (pix_fmt_mask & (1ULL << i)) { <nl>              loss = avcodec_get_pix_fmt_loss(i, src_pix_fmt, has_alpha) & loss_mask; <nl>              if (loss == 0) { <nl>                  dist = avg_bits_per_pixel(i);
@@ -91,6 +91,10 @@ static void vector_fmul_window_fixed_c(int32_t *dst, const int32_t *src0, <nl>  AVFixedDSPContext * avpriv_alloc_fixed_dsp(int bit_exact) <nl>  { <nl>      AVFixedDSPContext * fdsp = av_malloc(sizeof(AVFixedDSPContext)); <nl> + <nl> +    if (!fdsp) <nl> +        return NULL; <nl> + <nl>      fdsp->vector_fmul_window_scaled = vector_fmul_window_fixed_scaled_c; <nl>      fdsp->vector_fmul_window = vector_fmul_window_fixed_c; <nl>  
@@ -826,6 +826,10 @@ static int mjpeg_decode_scan(MJpegDecodeContext *s, int nb_components, int Ah, i <nl>              if (s->restart_interval && !s->restart_count) <nl>                  s->restart_count = s->restart_interval; <nl>   <nl> +            if(get_bits_count(&s->gb)>s->gb.size_in_bits){ <nl> +                av_log(s->avctx, AV_LOG_ERROR, "overread %d\n", get_bits_count(&s->gb) - s->gb.size_in_bits); <nl> +                return -1; <nl> +            } <nl>              for(i=0;i<nb_components;i++) { <nl>                  uint8_t *ptr; <nl>                  int n, h, v, x, y, c, j;
@@ -40,8 +40,8 @@ static int add_crc_to_array(uint32_t crc, int64_t pts) <nl>          if (size_of_array == 0) <nl>              size_of_array = 10; <nl>          size_of_array *= 2; <nl> -        crc_array = av_realloc(crc_array, size_of_array * sizeof(uint32_t)); <nl> -        pts_array = av_realloc(pts_array, size_of_array * sizeof(int64_t)); <nl> +        crc_array = av_realloc_f(crc_array, size_of_array, sizeof(uint32_t)); <nl> +        pts_array = av_realloc_f(pts_array, size_of_array, sizeof(int64_t)); <nl>          if ((crc_array == NULL) || (pts_array == NULL)) { <nl>              av_log(NULL, AV_LOG_ERROR, "Can't allocate array to store crcs\n"); <nl>              return AVERROR(ENOMEM);
@@ -180,6 +180,7 @@ static int mp_get_vlc(MotionPixelsContext *mp, GetBitContext *gb) <nl>      int i; <nl>   <nl>      i = (mp->codes_count == 1) ? 0 : get_vlc2(gb, mp->vlc.table, mp->max_codes_bits, 1); <nl> +    i = FFMIN(i, FF_ARRAY_ELEMS(mp->codes) - 1); <nl>      return mp->codes[i].delta; <nl>  } <nl>  
@@ -1438,7 +1438,7 @@ static void decode_postinit(H264Context *h, int setup_finished){ <nl>   <nl>      if(   s->avctx->strict_std_compliance >= FF_COMPLIANCE_STRICT <nl>         && !h->sps.bitstream_restriction_flag){ <nl> -        s->avctx->has_b_frames= MAX_DELAYED_PIC_COUNT; <nl> +        s->avctx->has_b_frames = MAX_DELAYED_PIC_COUNT - 1; <nl>          s->low_delay= 0; <nl>      } <nl>  
@@ -25,6 +25,7 @@ <nl>   */ <nl>   <nl>  #include "libavutil/intreadwrite.h" <nl> +#include "libavutil/imgutils.h" <nl>  #include "avformat.h" <nl>  #include "internal.h" <nl>   <nl> @@ -68,10 +69,8 @@ static int read_header(AVFormatContext *s) <nl>      st->codecpar->height     = avio_rb16(pb); <nl>      film->leading         = avio_rb16(pb); <nl>   <nl> -    if (st->codecpar->width * 4LL * st->codecpar->height >= INT_MAX) { <nl> -        av_log(s, AV_LOG_ERROR, "dimensions too large\n"); <nl> -        return AVERROR_PATCHWELCOME; <nl> -    } <nl> +    if (av_image_check_size(st->codecpar->width, st->codecpar->height, 0, s) < 0) <nl> +        return AVERROR_INVALIDDATA; <nl>   <nl>      avpriv_set_pts_info(st, 64, 1, avio_rb16(pb)); <nl>  
@@ -85,7 +85,7 @@ static int filter_frame(AVFilterLink *inlink, AVFrame *in) <nl>  { <nl>      AVFilterContext *ctx = inlink->dst; <nl>      AVFilterLink *outlink = ctx->outputs[0]; <nl> -    AVFrame *out = ff_get_audio_buffer(inlink, in->nb_samples); <nl> +    AVFrame *out; <nl>      DCShiftContext *s = ctx->priv; <nl>      int i, j; <nl>      double dcshift = s->dcshift; <nl> @@ -93,7 +93,7 @@ static int filter_frame(AVFilterLink *inlink, AVFrame *in) <nl>      if (av_frame_is_writable(in)) { <nl>          out = in; <nl>      } else { <nl> -        out = ff_get_audio_buffer(inlink, in->nb_samples); <nl> +        out = ff_get_audio_buffer(outlink, in->nb_samples); <nl>          if (!out) { <nl>              av_frame_free(&in); <nl>              return AVERROR(ENOMEM);
@@ -1143,7 +1143,8 @@ static int decode_ics_info(AACContext *ac, IndividualChannelStream *ics, <nl>      if (aot != AOT_ER_AAC_ELD) { <nl>          if (get_bits1(gb)) { <nl>              av_log(ac->avctx, AV_LOG_ERROR, "Reserved bit set.\n"); <nl> -            return AVERROR_INVALIDDATA; <nl> +            if (ac->avctx->err_recognition & AV_EF_BITSTREAM) <nl> +                return AVERROR_INVALIDDATA; <nl>          } <nl>          ics->window_sequence[1] = ics->window_sequence[0]; <nl>          ics->window_sequence[0] = get_bits(gb, 2);
@@ -96,7 +96,7 @@ static av_cold int decode_init(AVCodecContext *avctx) <nl>          return AVERROR_INVALIDDATA; <nl>      } <nl>   <nl> -    s->version_b = avctx->extradata && avctx->extradata[3] == 'b'; <nl> +    s->version_b = avctx->extradata_size >= 4 && avctx->extradata[3] == 'b'; <nl>   <nl>      if (avctx->codec->id == CODEC_ID_BINKAUDIO_RDFT) { <nl>          // audio is already interleaved for the RDFT format variant
@@ -191,7 +191,13 @@ static int extract_header(AVCodecContext *const avctx, <nl>      const uint8_t *buf; <nl>      unsigned buf_size; <nl>      IffContext *s = avctx->priv_data; <nl> -    int palette_size = avctx->extradata_size - AV_RB16(avctx->extradata); <nl> +    int palette_size; <nl> + <nl> +    if (avctx->extradata_size < 2) { <nl> +        av_log(avctx, AV_LOG_ERROR, "not enough extradata\n"); <nl> +        return AVERROR_INVALIDDATA; <nl> +    } <nl> +    palette_size = avctx->extradata_size - AV_RB16(avctx->extradata); <nl>   <nl>      if (avpkt) { <nl>          int image_size; <nl> @@ -207,8 +213,6 @@ static int extract_header(AVCodecContext *const avctx, <nl>              return AVERROR_INVALIDDATA; <nl>          } <nl>      } else { <nl> -        if (avctx->extradata_size < 2) <nl> -            return AVERROR_INVALIDDATA; <nl>          buf = avctx->extradata; <nl>          buf_size = bytestream_get_be16(&buf); <nl>          if (buf_size <= 1 || palette_size < 0) {
@@ -181,6 +181,7 @@ static int xv_write_trailer(AVFormatContext *s) <nl>      XShmDetach(xv->display, &xv->yuv_shminfo); <nl>      shmdt(xv->yuv_image->data); <nl>      XFree(xv->yuv_image); <nl> +    XFreeGC(xv->display, xv->gc); <nl>      XCloseDisplay(xv->display); <nl>      return 0; <nl>  }
@@ -682,7 +682,7 @@ static int wavpack_decode_block(AVCodecContext *avctx, int block_no, <nl>      s->hybrid_bitrate =   s->frame_flags & WV_HYBRID_BITRATE; <nl>      s->post_shift     = bpp * 8 - orig_bpp + ((s->frame_flags >> 13) & 0x1f); <nl>      s->hybrid_maxclip =  ((1LL << (orig_bpp - 1)) - 1); <nl> -    s->hybrid_minclip = ((-1LL << (orig_bpp - 1))); <nl> +    s->hybrid_minclip = ((-1UL << (orig_bpp - 1))); <nl>      s->CRC            = bytestream2_get_le32(&gb); <nl>   <nl>      // parse metadata blocks
@@ -482,6 +482,9 @@ static int concat_read_packet(AVFormatContext *avf, AVPacket *pkt) <nl>      ConcatStream *cs; <nl>      AVStream *st; <nl>   <nl> +    if (!cat->avf) <nl> +        return AVERROR(EIO); <nl> + <nl>      while (1) { <nl>          ret = av_read_frame(cat->avf, pkt); <nl>          if (ret == AVERROR_EOF) {
@@ -708,6 +708,10 @@ static int hls_slice_header(HEVCContext *s) <nl>   <nl>      if (s->pps->slice_header_extension_present_flag) { <nl>          unsigned int length = get_ue_golomb_long(gb); <nl> +        if (length*8LL > get_bits_left(gb)) { <nl> +            av_log(s->avctx, AV_LOG_ERROR, "too many slice_header_extension_data_bytes\n"); <nl> +            return AVERROR_INVALIDDATA; <nl> +        } <nl>          for (i = 0; i < length; i++) <nl>              skip_bits(gb, 8);  // slice_header_extension_data_byte <nl>      }
@@ -3776,6 +3776,11 @@ static int webm_dash_manifest_read_header(AVFormatContext *s) <nl>          av_log(s, AV_LOG_ERROR, "Failed to read file headers\n"); <nl>          return -1; <nl>      } <nl> +    if (!s->nb_streams) { <nl> +        matroska_read_close(s); <nl> +        av_log(s, AV_LOG_ERROR, "No streams found\n"); <nl> +        return AVERROR_INVALIDDATA; <nl> +    } <nl>   <nl>      if (!matroska->is_live) { <nl>          buf = av_asprintf("%g", matroska->duration);
@@ -855,7 +855,7 @@ static int pxr24_uncompress(EXRContext *s, const uint8_t *src, <nl>                  in     = ptr[2] + td->xsize; <nl>   <nl>                  for (j = 0; j < td->xsize; ++j) { <nl> -                    uint32_t diff = (*(ptr[0]++) << 24) | <nl> +                    uint32_t diff = ((unsigned)*(ptr[0]++) << 24) | <nl>                                      (*(ptr[1]++) << 16) | <nl>                                      (*(ptr[2]++) << 8); <nl>                      pixel += diff;
@@ -226,9 +226,11 @@ static int get_metadata_size(const uint8_t *buf, int buf_size) <nl>   <nl>      buf += 4; <nl>      do { <nl> +        if (buf_end - buf < 4) <nl> +            return 0; <nl>          ff_flac_parse_block_header(buf, &metadata_last, NULL, &metadata_size); <nl>          buf += 4; <nl> -        if (buf + metadata_size > buf_end) { <nl> +        if (buf_end - buf < metadata_size) { <nl>              /* need more data in order to read the complete header */ <nl>              return 0; <nl>          }
@@ -213,12 +213,18 @@ static int query_formats(AVFilterContext *ctx) <nl>      PanContext *pan = ctx->priv; <nl>      AVFilterLink *inlink  = ctx->inputs[0]; <nl>      AVFilterLink *outlink = ctx->outputs[0]; <nl> +    AVFilterFormats *formats = NULL; <nl>      AVFilterChannelLayouts *layouts; <nl>   <nl>      pan->pure_gains = are_gains_pure(pan); <nl>      /* libswr supports any sample and packing formats */ <nl>      avfilter_set_common_sample_formats(ctx, avfilter_make_all_formats(AVMEDIA_TYPE_AUDIO)); <nl>   <nl> +    formats = ff_all_samplerates(); <nl> +    if (!formats) <nl> +        return AVERROR(ENOMEM); <nl> +    ff_set_common_samplerates(ctx, formats); <nl> + <nl>      // inlink supports any channel layout <nl>      layouts = ff_all_channel_layouts(); <nl>      ff_channel_layouts_ref(layouts, &inlink->out_channel_layouts);
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: ip_carp.c,v 1.189 2011/07/08 19:07:18 henning Exp $	*/ <nl> +/*	$OpenBSD: ip_carp.c,v 1.190 2011/09/06 16:00:22 mpf Exp $	*/ <nl>   <nl>  /* <nl>   * Copyright (c) 2002 Michael Shalayeff. All rights reserved. <nl> @@ -1820,7 +1820,7 @@ carp_set_ifp(struct carp_softc *sc, struct ifnet *ifp) <nl>  			return (EINVAL); <nl>   <nl>  		if (ifp->if_carp == NULL) { <nl> -			ncif = malloc(sizeof(*cif), M_IFADDR, M_NOWAIT); <nl> +			ncif = malloc(sizeof(*cif), M_IFADDR, M_NOWAIT|M_ZERO); <nl>  			if (ncif == NULL) <nl>  				return (ENOBUFS); <nl>  			if ((error = ifpromisc(ifp, 1))) {
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: gzopen.c,v 1.30 2016/04/28 14:21:24 millert Exp $	*/ <nl> +/*	$OpenBSD: gzopen.c,v 1.31 2016/04/29 13:50:35 millert Exp $	*/ <nl>   <nl>  /* <nl>   * Copyright (c) 1997 Michael Shalayeff <nl> @@ -509,6 +509,8 @@ gz_write(void *cookie, const char *buf, int len) <nl>  			break; <nl>  	} <nl>  	s->z_crc = crc32(s->z_crc, buf, len); <nl> +	s->z_total_in += s->z_stream.total_in; <nl> +	s->z_total_out += s->z_stream.total_out; <nl>   <nl>  	return (int)(len - s->z_stream.avail_in); <nl>  #endif
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: wsconsctl.c,v 1.23 2009/07/15 21:38:16 martynas Exp $	*/ <nl> +/*	$OpenBSD: wsconsctl.c,v 1.24 2009/07/19 15:34:45 martynas Exp $	*/ <nl>  /*	$NetBSD: wsconsctl.c,v 1.2 1998/12/29 22:40:20 hannken Exp $ */ <nl>   <nl>  /*- <nl> @@ -214,7 +214,7 @@ main(int argc, char *argv[]) <nl>  			f->flags |= FLG_SET; <nl>  			putval = (*sw->putval)(sw->name, sw->fd); <nl>  			f->flags &= ~FLG_SET; <nl> -			if (putval != 0 || f->flags & FLG_DEAD) <nl> +			if (putval != 0 || f->flags & (FLG_DEAD | FLG_NOAUTO)) <nl>  				continue; <nl>  			if (f->flags & FLG_WRONLY) { <nl>  				pr_field(sw->name, f, setsep);
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: display.c,v 1.32 2006/12/20 21:31:45 deraadt Exp $	*/ <nl> +/*	$OpenBSD: display.c,v 1.33 2006/12/24 01:07:59 kjell Exp $	*/ <nl>   <nl>  /* This file is in the public domain. */ <nl>   <nl> @@ -827,7 +827,8 @@ modeline(struct mgwin *wp) <nl>  	++n; <nl>   <nl>  	if (linenos) { <nl> -		len = snprintf(sl, sizeof(sl), "--L%d", wp->w_dotline); <nl> +		len = snprintf(sl, sizeof(sl), "--L%d--C%d", wp->w_dotline, <nl> +		    wp->w_doto); <nl>  		if (len < sizeof(sl) && len != -1) <nl>  			n += vtputs(sl); <nl>  	}
@@ -1,4 +1,4 @@ <nl> -/* $OpenBSD: library.c,v 1.7 2015/01/16 16:18:07 deraadt Exp $ */ <nl> +/* $OpenBSD: library.c,v 1.8 2015/01/19 02:44:53 deraadt Exp $ */ <nl>  /* <nl>   * Copyright (c) 2006 Dale Rahn <drahn@dalerahn.com> <nl>   * <nl> @@ -199,6 +199,7 @@ nohints: <nl>  		else <nl>  			searchpath = _dl_default_path; <nl>  	} <nl> +	memset(&bsod, 0, sizeof(bsod)); <nl>  	for (pp = searchpath; *pp != NULL; pp++) { <nl>  		if ((dd = opendir(*pp)) != NULL) { <nl>  			match = 0;
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: efidev.c,v 1.25 2017/05/11 01:37:24 yasuoka Exp $	*/ <nl> +/*	$OpenBSD: efidev.c,v 1.26 2017/05/16 02:56:23 yasuoka Exp $	*/ <nl>   <nl>  /* <nl>   * Copyright (c) 1996 Michael Shalayeff <nl> @@ -789,7 +789,7 @@ efi_dump_diskinfo(void) <nl>  		printf("hd%d\t%u\t%u\t%u%s\t0x%x\t0x%x\t%s\n", <nl>  		    (bdi->bios_number & 0x7f), <nl>  		    ed->blkio->Media->BlockSize, <nl> -		    ed->blkio->Media->IoAlign, (int)siz, sizu, <nl> +		    ed->blkio->Media->IoAlign, (unsigned)siz, sizu, <nl>  		    bdi->flags, bdi->checksum, <nl>  		    (ed->blkio->Media->RemovableMedia)? "Removable" : ""); <nl>  	}
@@ -1,4 +1,4 @@ <nl> -/*	$Id: roff.c,v 1.83 2014/06/25 00:19:17 schwarze Exp $ */ <nl> +/*	$Id: roff.c,v 1.84 2014/06/29 21:19:34 schwarze Exp $ */ <nl>  /* <nl>   * Copyright (c) 2010, 2011, 2012 Kristaps Dzonsons <kristaps@bsd.lv> <nl>   * Copyright (c) 2010-2014 Ingo Schwarze <schwarze@openbsd.org> <nl> @@ -2064,7 +2064,8 @@ roff_setstrn(struct roffkv **r, const char *name, size_t namesz, <nl>  	/* Search for an existing string with the same name. */ <nl>  	n = *r; <nl>   <nl> -	while (n && strcmp(name, n->key.p)) <nl> +	while (n && (namesz != n->key.sz || <nl> +			strncmp(n->key.p, name, namesz))) <nl>  		n = n->next; <nl>   <nl>  	if (NULL == n) {
@@ -1,4 +1,4 @@ <nl> -/* $OpenBSD: tmux.h,v 1.449 2014/04/16 21:02:41 nicm Exp $ */ <nl> +/* $OpenBSD: tmux.h,v 1.450 2014/04/16 21:16:19 nicm Exp $ */ <nl>   <nl>  /* <nl>   * Copyright (c) 2007 Nicholas Marriott <nicm@users.sourceforge.net> <nl> @@ -2335,7 +2335,6 @@ char   *get_proc_name(int, char *); <nl>  void		 log_open(const char *); <nl>  void		 log_close(void); <nl>  void printflike1 log_debug(const char *, ...); <nl> -void printflike1 log_debug2(const char *, ...); <nl>  __dead void printflike1 log_fatal(const char *, ...); <nl>  __dead void printflike1 log_fatalx(const char *, ...); <nl>   <nl> @@ -2356,7 +2355,9 @@ const char	*style_tostring(struct grid_cell *); <nl>  void		 style_update_new(struct options *, const char *, const char *); <nl>  void		 style_update_old(struct options *, const char *, <nl>  		     struct grid_cell *); <nl> -void	style_apply(struct grid_cell *, struct options *, const char *); <nl> -void	style_apply_update(struct grid_cell *, struct options *, const char *); <nl> +void		 style_apply(struct grid_cell *, struct options *, <nl> +		     const char *); <nl> +void		 style_apply_update(struct grid_cell *, struct options *, <nl> +		     const char *); <nl>   <nl>  #endif /* TMUX_H */
@@ -702,7 +702,7 @@ epget(sc, totlen) <nl>  	bus_io_handle_t ioh = sc->sc_ioh; <nl>  	struct ifnet *ifp = &sc->sc_arpcom.ac_if; <nl>  	struct mbuf *top, **mp, *m; <nl> -	int len; <nl> +	int len, pad; <nl>  	int sh; <nl>   <nl>  	m = sc->mb[sc->next_mb]; <nl> @@ -722,7 +722,9 @@ epget(sc, totlen) <nl>  	} <nl>  	m->m_pkthdr.rcvif = ifp; <nl>  	m->m_pkthdr.len = totlen; <nl> -	len = MHLEN; <nl> +	pad = ALIGN(sizeof(struct ether_header)) - sizeof(struct ether_header); <nl> +	m->m_data += pad; <nl> +	len = MHLEN - pad; <nl>  	top = 0; <nl>  	mp = &top; <nl>   <nl> @@ -749,7 +751,7 @@ epget(sc, totlen) <nl>  			} <nl>  			len = MLEN; <nl>  		} <nl> -		if (totlen >= MINCLSIZE) { <nl> +		if (top && totlen >= MINCLSIZE) { <nl>  			MCLGET(m, M_DONTWAIT); <nl>  			if (m->m_flags & M_EXT) <nl>  				len = MCLBYTES;
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: kern_pledge.c,v 1.146 2016/01/09 06:13:43 semarie Exp $	*/ <nl> +/*	$OpenBSD: kern_pledge.c,v 1.147 2016/01/18 17:19:55 deraadt Exp $	*/ <nl>   <nl>  /* <nl>   * Copyright (c) 2015 Nicholas Marriott <nicm@openbsd.org> <nl> @@ -279,6 +279,7 @@ const uint64_t pledge_syscalls[SYS_MAXSYSCALL] = { <nl>  	[SYS_faccessat] = PLEDGE_RPATH | PLEDGE_WPATH, <nl>  	[SYS_readlinkat] = PLEDGE_RPATH | PLEDGE_WPATH, <nl>  	[SYS_lstat] = PLEDGE_RPATH | PLEDGE_WPATH | PLEDGE_TMPPATH, <nl> +	[SYS_truncate] = PLEDGE_WPATH, <nl>  	[SYS_rename] = PLEDGE_CPATH, <nl>  	[SYS_rmdir] = PLEDGE_CPATH, <nl>  	[SYS_renameat] = PLEDGE_CPATH,
@@ -656,7 +656,7 @@ strerror (errnoval) <nl>    else if ((sys_errlist == NULL) || (sys_errlist[errnoval] == NULL)) <nl>      { <nl>        /* In range, but no sys_errlist or no entry at this index. */ <nl> -      sprintf (buf, "Error %d", errnoval); <nl> +      snprintf (buf, sizeof buf, "Error %d", errnoval); <nl>        msg = buf; <nl>      } <nl>    else <nl> @@ -727,7 +727,7 @@ strerrno (errnoval) <nl>    else if ((error_names == NULL) || (error_names[errnoval] == NULL)) <nl>      { <nl>        /* In range, but no error_names or no entry at this index. */ <nl> -      sprintf (buf, "Error %d", errnoval); <nl> +      snprintf (buf, sizeof buf, "Error %d", errnoval); <nl>        name = (const char *) buf; <nl>      } <nl>    else
@@ -23,7 +23,7 @@ <nl>   * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF <nl>   * SUCH DAMAGE. <nl>   * <nl> - *	$OpenBSD: bundle.c,v 1.37 2000/06/13 09:57:50 brian Exp $ <nl> + *	$OpenBSD: bundle.c,v 1.38 2000/06/18 10:08:59 brian Exp $ <nl>   */ <nl>   <nl>  #include <sys/param.h> <nl> @@ -1159,7 +1159,7 @@ bundle_ShowStatus(struct cmdargs const *arg) <nl>      prompt_Printf(arg->prompt, ", up time %d:%02d:%02d", secs / 3600, <nl>                    (secs / 60) % 60, secs % 60); <nl>    } <nl> -  prompt_Printf(arg->prompt, "\n Queued:        %u of %u\n", <nl> +  prompt_Printf(arg->prompt, "\n Queued:        %lu of %u\n", <nl>                  ip_QueueLen(&arg->bundle->ncp.ipcp), arg->bundle->cfg.ifqueue); <nl>   <nl>    prompt_Printf(arg->prompt, "\nDefaults:\n");
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: signal.c,v 1.12 2008/05/02 06:09:11 brad Exp $	*/ <nl> +/*	$OpenBSD: signal.c,v 1.13 2010/01/10 00:36:35 guenther Exp $	*/ <nl>   <nl>  /* <nl>   * Copyright 2000-2002 Niels Provos <provos@citi.umich.edu> <nl> @@ -138,7 +138,12 @@ evsignal_add(struct event *ev) <nl>  int <nl>  evsignal_del(struct event *ev) <nl>  { <nl> -	return (sigaction(EVENT_SIGNAL(ev),(struct sigaction *)SIG_DFL, NULL)); <nl> +	struct sigaction sa; <nl> + <nl> +	memset(&sa, 0, sizeof(sa)); <nl> +	sigemptyset(&sa.sa_mask); <nl> +	sa.sa_handler = SIG_DFL; <nl> +	return (sigaction(EVENT_SIGNAL(ev), &sa, NULL)); <nl>  } <nl>   <nl>  static void
@@ -1,5 +1,5 @@ <nl>  /*	$OpenPackages$ */ <nl> -/*	$OpenBSD: cmd_exec.c,v 1.3 2002/08/05 17:04:36 millert Exp $ */ <nl> +/*	$OpenBSD: cmd_exec.c,v 1.4 2003/10/19 20:23:34 tedu Exp $ */ <nl>  /* <nl>   * Copyright (c) 2001 Marc Espie. <nl>   * <nl> @@ -126,7 +126,7 @@ Cmd_Exec(cmd, err) <nl>  	/* The result is null terminated, Convert newlines to spaces. */ <nl>  	cp = result + length - 1; <nl>   <nl> -	if (*cp == '\n') <nl> +	if (cp >= result && *cp == '\n') <nl>  	    /* A final newline is just stripped.  */ <nl>  	    *cp-- = '\0'; <nl>  
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: lka_filter.c,v 1.64 2020/12/20 13:27:46 martijn Exp $	*/ <nl> +/*	$OpenBSD: lka_filter.c,v 1.65 2020/12/23 20:17:49 millert Exp $	*/ <nl>   <nl>  /* <nl>   * Copyright (c) 2018 Gilles Chehade <gilles@poolp.org> <nl> @@ -600,11 +600,6 @@ filter_session_io(struct io *io, int evt, void *arg) <nl>  		filter_data(fs->id, line); <nl>   <nl>  		goto nextline; <nl> - <nl> -	case IO_DISCONNECTED: <nl> -		io_free(fs->io); <nl> -		fs->io = NULL; <nl> -		break; <nl>  	} <nl>  } <nl>  
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: machdep.c,v 1.120 2003/12/18 08:05:20 mickey Exp $	*/ <nl> +/*	$OpenBSD: machdep.c,v 1.121 2003/12/20 16:13:53 miod Exp $	*/ <nl>   <nl>  /* <nl>   * Copyright (c) 1999-2002 Michael Shalayeff <nl> @@ -768,7 +768,7 @@ microtime(struct timeval *tv) <nl>  	splx(s); <nl>   <nl>  	tv->tv_usec += itmr * cpu_ticksdenom / cpu_ticksnum; <nl> -	if (tv->tv_usec > 1000000) { <nl> +	if (tv->tv_usec >= 1000000) { <nl>  		tv->tv_usec -= 1000000; <nl>  		tv->tv_sec++; <nl>  	}
@@ -1,4 +1,4 @@ <nl> -/* $OpenBSD: bioctl.c,v 1.56 2007/05/31 04:23:23 grunk Exp $       */ <nl> +/* $OpenBSD: bioctl.c,v 1.57 2007/06/01 00:00:54 tedu Exp $       */ <nl>   <nl>  /* <nl>   * Copyright (c) 2004, 2005 Marco Peereboom <nl> @@ -104,7 +104,10 @@ main(int argc, char *argv[]) <nl>  			break; <nl>  		case 'c': /* create */ <nl>  			func |= BIOC_CREATERAID; <nl> -			cr_level = atoi(optarg); <nl> +			if (isdigit(*optarg)) <nl> +				cr_level = atoi(optarg); <nl> +			else <nl> +				cr_level = *optarg; <nl>  			break; <nl>  		case 'u': /* unblink */ <nl>  			func |= BIOC_BLINK; <nl> @@ -605,6 +608,9 @@ bio_createraid(u_int16_t level, char *dev_list) <nl>  	case 1: <nl>  		min_disks = 2; <nl>  		break; <nl> +	case 'c': <nl> +		min_disks = 1; <nl> +		break; <nl>  	default: <nl>  		errx(1, "unsupported raid level"); <nl>  	}
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: uvm_map.c,v 1.189 2015/03/30 21:08:40 miod Exp $	*/ <nl> +/*	$OpenBSD: uvm_map.c,v 1.190 2015/03/30 21:09:55 miod Exp $	*/ <nl>  /*	$NetBSD: uvm_map.c,v 1.86 2000/11/27 08:40:03 chs Exp $	*/ <nl>   <nl>  /* <nl> @@ -3732,7 +3732,7 @@ uvm_map_hint(struct vmspace *vm, vm_prot_t prot, vaddr_t minaddr, <nl>  	} <nl>  #endif <nl>   <nl> -#if defined (__LP64__) && !defined (__mips64__) <nl> +#if defined (__LP64__) <nl>  	spacing = (MIN((4UL * 1024 * 1024 * 1024), BRKSIZ) - 1); <nl>  #else <nl>  	spacing = (MIN((256 * 1024 * 1024), BRKSIZ) - 1);
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: apm.c,v 1.8 1997/09/22 12:07:45 deraadt Exp $	*/ <nl> +/*	$OpenBSD: apm.c,v 1.9 1997/09/22 14:55:13 deraadt Exp $	*/ <nl>   <nl>  /*- <nl>   * Copyright (c) 1995 John T. Kohl.  All rights reserved. <nl> @@ -185,7 +185,7 @@ struct apmregs *regs; <nl>  		    sc->sc_dev.dv_xname, <nl>  		    BATT_LIFE(regs)); <nl>  	} <nl> -	printf("%s: A/C state: ", sc->sc_dev.dv_xname); <nl> +	printf("%s: AC state: ", sc->sc_dev.dv_xname); <nl>  	switch (AC_STATE(regs)) { <nl>  	case APM_AC_OFF: <nl>  		printf("off\n");
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: smi.c,v 1.8 2012/09/17 16:43:59 reyk Exp $	*/ <nl> +/*	$OpenBSD: smi.c,v 1.9 2013/06/21 07:07:55 gerhard Exp $	*/ <nl>   <nl>  /* <nl>   * Copyright (c) 2007, 2008 Reyk Floeter <reyk@openbsd.org> <nl> @@ -124,6 +124,7 @@ smi_delete(struct oid *oid) <nl>  { <nl>  	struct oid	 key, *value; <nl>   <nl> +	bzero(&key, sizeof(key)); <nl>  	bcopy(&oid->o_id, &key.o_id, sizeof(struct ber_oid)); <nl>  	if ((value = RB_FIND(oidtree, &smi_oidtree, &key)) != NULL && <nl>  	    value == oid) <nl> @@ -145,6 +146,7 @@ smi_insert(struct oid *oid) <nl>  	if ((oid->o_flags & OID_TABLE) && oid->o_get == NULL) <nl>  		fatalx("smi_insert: invalid MIB table"); <nl>   <nl> +	bzero(&key, sizeof(key)); <nl>  	bcopy(&oid->o_id, &key.o_id, sizeof(struct ber_oid)); <nl>  	value = RB_FIND(oidtree, &smi_oidtree, &key); <nl>  	if (value != NULL)
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: usbdi.c,v 1.34 2007/10/11 18:30:50 deraadt Exp $ */ <nl> +/*	$OpenBSD: usbdi.c,v 1.35 2008/06/21 22:24:45 fgsch Exp $ */ <nl>  /*	$NetBSD: usbdi.c,v 1.103 2002/09/27 15:37:38 provos Exp $	*/ <nl>  /*	$FreeBSD: src/sys/dev/usb/usbdi.c,v 1.28 1999/11/17 22:33:49 n_hibma Exp $	*/ <nl>   <nl> @@ -753,7 +753,7 @@ usb_transfer_complete(usbd_xfer_handle xfer) <nl>   <nl>  #ifdef DIAGNOSTIC <nl>  	if (pipe == NULL) { <nl> -		printf("usbd_transfer_cb: pipe==0, xfer=%p\n", xfer); <nl> +		printf("usbd_transfer_complete: pipe==0, xfer=%p\n", xfer); <nl>  		return; <nl>  	} <nl>  #endif <nl> @@ -803,7 +803,7 @@ usb_transfer_complete(usbd_xfer_handle xfer) <nl>  	xfer->done = 1; <nl>  	if (!xfer->status && xfer->actlen < xfer->length && <nl>  	    !(xfer->flags & USBD_SHORT_XFER_OK)) { <nl> -		DPRINTFN(-1,("usbd_transfer_cb: short transfer %d<%d\n", <nl> +		DPRINTFN(-1,("usbd_transfer_complete: short transfer %d<%d\n", <nl>  		    xfer->actlen, xfer->length)); <nl>  		xfer->status = USBD_SHORT_XFER; <nl>  	}
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: kern_event.c,v 1.69 2015/12/17 17:00:48 tedu Exp $	*/ <nl> +/*	$OpenBSD: kern_event.c,v 1.70 2015/12/20 17:56:18 tedu Exp $	*/ <nl>   <nl>  /*- <nl>   * Copyright (c) 1999,2000,2001 Jonathan Lemon <jlemon@FreeBSD.org> <nl> @@ -1033,8 +1033,8 @@ knote_attach(struct knote *kn, struct filedesc *fdp) <nl>  		    fdp->fd_knlistsize * sizeof(struct klist)); <nl>  		memset(&list[fdp->fd_knlistsize], 0, <nl>  		    (size - fdp->fd_knlistsize) * sizeof(struct klist)); <nl> -		if (fdp->fd_knlist != NULL) <nl> -			free(fdp->fd_knlist, M_TEMP, 0); <nl> +		free(fdp->fd_knlist, M_TEMP, <nl> +		    fdp->fd_knlistsize * sizeof(struct klist)); <nl>  		fdp->fd_knlistsize = size; <nl>  		fdp->fd_knlist = list; <nl>  	}
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: ifstated.c,v 1.40 2011/07/04 04:34:14 claudio Exp $	*/ <nl> +/*	$OpenBSD: ifstated.c,v 1.41 2013/05/30 19:22:48 henning Exp $	*/ <nl>   <nl>  /* <nl>   * Copyright (c) 2004 Marco Pfatschbacher <mpf@openbsd.org> <nl> @@ -169,7 +169,12 @@ startup_handler(int fd, short event, void *arg) <nl>  	rtfilter = ROUTE_FILTER(RTM_IFINFO); <nl>  	if (setsockopt(rt_fd, PF_ROUTE, ROUTE_MSGFILTER, <nl>  	    &rtfilter, sizeof(rtfilter)) == -1)         /* not fatal */ <nl> -		log_warn("startup_handler: setsockopt"); <nl> +		log_warn("startup_handler: setsockopt msgfilter"); <nl> + <nl> +	rtfilter = RTABLE_ANY; <nl> +	if (setsockopt(rt_fd, PF_ROUTE, ROUTE_TABLEFILTER, <nl> +	    &rtfilter, sizeof(rtfilter)) == -1)         /* not fatal */ <nl> +		log_warn("startup_handler: setsockopt tablefilter"); <nl>  	 <nl>  	event_set(&rt_msg_ev, rt_fd, EV_READ|EV_PERSIST, rt_msg_handler, NULL); <nl>  	event_add(&rt_msg_ev, NULL);
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: radeon_ring.c,v 1.2 2014/02/09 11:03:31 jsg Exp $	*/ <nl> +/*	$OpenBSD: radeon_ring.c,v 1.3 2014/02/09 13:22:04 jsg Exp $	*/ <nl>  /* <nl>   * Copyright 2008 Advanced Micro Devices, Inc. <nl>   * Copyright 2008 Red Hat Inc. <nl> @@ -386,6 +386,13 @@ int radeon_ring_alloc(struct radeon_device *rdev, struct radeon_ring *ring, unsi <nl>  		return -ENOMEM; <nl>  	/* Align requested size with padding so unlock_commit can <nl>  	 * pad safely */ <nl> +	radeon_ring_free_size(rdev, ring); <nl> +	if (ring->ring_free_dw == (ring->ring_size / 4)) { <nl> +		/* This is an empty ring update lockup info to avoid <nl> +		 * false positive. <nl> +		 */ <nl> +		radeon_ring_lockup_update(ring); <nl> +	} <nl>  	ndw = (ndw + ring->align_mask) & ~ring->align_mask; <nl>  	while (ndw > (ring->ring_free_dw - 1)) { <nl>  		radeon_ring_free_size(rdev, ring);
@@ -40,7 +40,7 @@ <nl>   */ <nl>   <nl>  #include "includes.h" <nl> -RCSID("$OpenBSD: sshd.c,v 1.131 2000/10/12 09:59:20 markus Exp $"); <nl> +RCSID("$OpenBSD: sshd.c,v 1.132 2000/10/13 18:34:46 markus Exp $"); <nl>   <nl>  #include "xmalloc.h" <nl>  #include "rsa.h" <nl> @@ -331,6 +331,10 @@ sshd_exchange_identification(int sock_in, int sock_out) <nl>  			if (buf[i] == '\r') { <nl>  				buf[i] = '\n'; <nl>  				buf[i + 1] = 0; <nl> +				/* Kludge for F-Secure Macintosh < 1.0.2 */ <nl> +				if (i == 12 && <nl> +				    strncmp(buf, "SSH-1.5-W1.0", 12) == 0) <nl> +					break; <nl>  				continue; <nl>  			} <nl>  			if (buf[i] == '\n') {
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: bgpctl.c,v 1.46 2004/03/11 15:08:46 claudio Exp $ */ <nl> +/*	$OpenBSD: bgpctl.c,v 1.47 2004/03/11 16:39:34 claudio Exp $ */ <nl>   <nl>  /* <nl>   * Copyright (c) 2003 Henning Brauer <henning@openbsd.org> <nl> @@ -710,11 +710,8 @@ show_rib_summary_msg(struct imsg *imsg) <nl>   <nl>  		asdata = imsg->data; <nl>  		asdata += sizeof(struct ctl_show_rib); <nl> -		aspath = malloc(aspath_strlen(asdata, rib->aspath_len) + 1); <nl> -		if (aspath == NULL) <nl> +		if (aspath_asprint(&aspath, asdata, rib->aspath_len) == -1) <nl>  			err(1, NULL); <nl> -		aspath_snprint(aspath, aspath_strlen(asdata, <nl> -		    rib->aspath_len) + 1, asdata, rib->aspath_len); <nl>  		if (strlen(aspath) > 0) <nl>  			printf("%s ", aspath); <nl>  
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: cpu.c,v 1.65 2017/04/20 15:42:26 visa Exp $ */ <nl> +/*	$OpenBSD: cpu.c,v 1.66 2017/04/22 15:43:35 visa Exp $ */ <nl>   <nl>  /* <nl>   * Copyright (c) 1997-2004 Opsycon AB (www.opsycon.se) <nl> @@ -205,6 +205,9 @@ cpuattach(struct device *parent, struct device *dev, void *aux) <nl>  		case 0x05: <nl>  			printf("STC Loongson3%c CPU", 'A' + vers_min - 5); <nl>  			break; <nl> +		case 0x08: <nl> +			printf("STC Loongson3A2000/3B2000 CPU"); <nl> +			break; <nl>  		default: <nl>  			printf("Unknown STC Loongson CPU type (%02x)", <nl>  			    ch->c0prid & 0xff); <nl> @@ -304,6 +307,9 @@ cpuattach(struct device *parent, struct device *dev, void *aux) <nl>  		case 0x05: <nl>  			printf("STC Loongson3%c FPU", 'A' + vers_min - 5); <nl>  			break; <nl> +		case 0x08: <nl> +			printf("STC Loongson3A2000/3B2000 FPU"); <nl> +			break; <nl>  		default: <nl>  			printf("Unknown STC Loongson FPU type (%02x)", <nl>  			    ch->c1prid & 0xff);
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: ipmi.c,v 1.25 2005/12/16 03:16:47 marco Exp $ */ <nl> +/*	$OpenBSD: ipmi.c,v 1.26 2006/01/04 23:51:16 marco Exp $ */ <nl>   <nl>  /* <nl>   * Copyright (c) 2005 Jordan Hargrave <nl> @@ -319,7 +319,7 @@ bmc_io_wait_cold(struct ipmi_softc *sc, int offset, u_int8_t mask, <nl>      u_int8_t value, const char *lbl) <nl>  { <nl>  	volatile u_int8_t	v; <nl> -	int			count = 1000; <nl> +	int			count = 100000; <nl>   <nl>  	while (count--) { <nl>  		v = bmc_read(sc, offset); <nl> @@ -1740,7 +1740,7 @@ ipmi_attach(struct device *parent, struct device *self, void *aux) <nl>  	/* setup ticker */ <nl>  	sc->sc_retries = 0; <nl>  	sc->sc_wakeup = 0; <nl> -	sc->sc_max_retries = 1000; /* XXX 50ms the right value? */ <nl> +	sc->sc_max_retries = 100000; /* XXX 5s the right value? */ <nl>  	timeout_set(&sc->sc_timeout, _bmc_io_wait, sc); <nl>  } <nl>  
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: if_ether.c,v 1.102 2013/07/04 08:22:19 mpi Exp $	*/ <nl> +/*	$OpenBSD: if_ether.c,v 1.103 2013/08/01 08:27:43 mpi Exp $	*/ <nl>  /*	$NetBSD: if_ether.c,v 1.31 1996/05/11 12:59:58 mycroft Exp $	*/ <nl>   <nl>  /* <nl> @@ -822,8 +822,9 @@ struct llinfo_arp * <nl>  arplookup(u_int32_t addr, int create, int proxy, u_int tableid) <nl>  { <nl>  	struct rtentry *rt; <nl> -	static struct sockaddr_inarp sin; <nl> +	struct sockaddr_inarp sin; <nl>   <nl> +	bzero(&sin, sizeof(sin)); <nl>  	sin.sin_len = sizeof(sin); <nl>  	sin.sin_family = AF_INET; <nl>  	sin.sin_addr.s_addr = addr;
@@ -1,4 +1,4 @@ <nl> -/* $OpenBSD: kex.c,v 1.126 2016/09/28 21:44:52 djm Exp $ */ <nl> +/* $OpenBSD: kex.c,v 1.127 2016/10/10 19:28:48 markus Exp $ */ <nl>  /* <nl>   * Copyright (c) 2000, 2001 Markus Friedl.  All rights reserved. <nl>   * <nl> @@ -461,6 +461,7 @@ kex_input_kexinit(int type, u_int32_t seq, void *ctxt) <nl>  	if (kex == NULL) <nl>  		return SSH_ERR_INVALID_ARGUMENT; <nl>   <nl> +	ssh_dispatch_set(ssh, SSH2_MSG_KEXINIT, NULL); <nl>  	ptr = sshpkt_ptr(ssh, &dlen); <nl>  	if ((r = sshbuf_put(kex->peer, ptr, dlen)) != 0) <nl>  		return r;
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: ci.c,v 1.14 2005/10/09 19:29:22 joris Exp $	*/ <nl> +/*	$OpenBSD: ci.c,v 1.15 2005/10/09 21:17:59 niallo Exp $	*/ <nl>  /* <nl>   * Copyright (c) 2005 Niall O'Higgins <niallo@openbsd.org> <nl>   * All rights reserved. <nl> @@ -211,7 +211,8 @@ checkin_main(int argc, char **argv) <nl>  		 */ <nl>  		if (newrev != NULL) <nl>  			rcs_head_set(file, newrev); <nl> - <nl> +		else <nl> +			newrev = file->rf_head; <nl>  		/* <nl>  		 * New head revision has to contain entire file; <nl>  		 */
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: paths.h,v 1.6 1997/04/16 03:41:52 millert Exp $	*/ <nl> +/*	$OpenBSD: paths.h,v 1.7 1997/06/12 00:35:18 deraadt Exp $	*/ <nl>  /*	$NetBSD: paths.h,v 1.7 1994/10/26 00:56:12 cgd Exp $	*/ <nl>   <nl>  /* <nl> @@ -53,6 +53,7 @@ <nl>  #define	_PATH_DRUM	"/dev/drum" <nl>  #define	_PATH_FSIRAND	"/sbin/fsirand" <nl>  #define	_PATH_KMEM	"/dev/kmem" <nl> +#define	_PATH_KVMDB	"/var/db/kvm.db" <nl>  #define	_PATH_LOCALE	"/usr/share/locale" <nl>  #define	_PATH_MAILDIR	"/var/mail" <nl>  #define	_PATH_MAN	"/usr/share/man"
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: db_interface.h,v 1.8 2006/07/11 21:17:58 mickey Exp $	*/ <nl> +/*	$OpenBSD: db_interface.h,v 1.9 2006/07/12 05:55:22 deraadt Exp $	*/ <nl>  /*	$NetBSD: db_interface.h,v 1.1 1996/02/05 01:57:03 christos Exp $	*/ <nl>   <nl>  /* <nl> @@ -45,6 +45,9 @@ void db_show_all_procs(db_expr_t, int, db_expr_t, char *); <nl>  /* kern/kern_timeout.c */ <nl>  void db_show_callout(db_expr_t, int, db_expr_t, char *); <nl>   <nl> +struct mount; <nl> +struct vnode; <nl> + <nl>  /* kern/vfs_subr.c */ <nl>  void vfs_buf_print(struct buf *, int, int (*)(const char *, ...)); <nl>  void vfs_vnode_print(struct vnode *, int, int (*)(const char *, ...));
@@ -1,4 +1,4 @@ <nl> -/* $OpenBSD: cmd-set-environment.c,v 1.6 2012/07/11 07:10:15 nicm Exp $ */ <nl> +/* $OpenBSD: cmd-set-environment.c,v 1.7 2012/10/31 19:11:18 okan Exp $ */ <nl>   <nl>  /* <nl>   * Copyright (c) 2009 Nicholas Marriott <nicm@users.sourceforge.net> <nl> @@ -57,7 +57,7 @@ cmd_set_environment_exec(struct cmd *self, struct cmd_ctx *ctx) <nl>  		return (CMD_RETURN_ERROR); <nl>  	} <nl>   <nl> -	if (args->argc < 1) <nl> +	if (args->argc < 2) <nl>  		value = NULL; <nl>  	else <nl>  		value = args->argv[1];
@@ -1256,7 +1256,7 @@ API_EXPORT(int) ap_call_exec(request_rec *r, child_info *pinfo, char *argv0, <nl>  	else if ((conf->cgi_command_args == AP_FLAG_OFF) <nl>              || (!r->args) || (!r->args[0]) <nl>              || strchr(r->args, '=')) { <nl> -	    execle(r->filename, argv0, NULL, env); <nl> +	    execle(r->filename, argv0, (void*)NULL, env); <nl>  	} <nl>   <nl>  	else {
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: expand.c,v 1.1 2009/11/08 23:15:03 gilles Exp $	*/ <nl> +/*	$OpenBSD: expand.c,v 1.2 2009/11/09 10:32:48 jacekm Exp $	*/ <nl>   <nl>  /* <nl>   * Copyright (c) 2009 Gilles Chehade <gilles@openbsd.org> <nl> @@ -46,7 +46,8 @@ void <nl>  expandtree_insert(struct expandtree *expandtree, struct expand_node *node) <nl>  { <nl>  	node->id = generate_uid(); <nl> -	RB_INSERT(expandtree, expandtree, node); <nl> +	if (RB_INSERT(expandtree, expandtree, node)) <nl> +		fatalx("expandtree_insert: node already exists"); <nl>  } <nl>   <nl>  void
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: ip_output.c,v 1.65 2000/03/17 10:25:22 angelos Exp $	*/ <nl> +/*	$OpenBSD: ip_output.c,v 1.66 2000/03/30 04:53:36 angelos Exp $	*/ <nl>  /*	$NetBSD: ip_output.c,v 1.28 1996/02/13 23:43:07 christos Exp $	*/ <nl>   <nl>  /* <nl> @@ -645,8 +645,10 @@ sendit: <nl>  		} <nl>   <nl>  		/* We don't need this anymore */ <nl> -		if (re->re_rt) <nl> +		if (re->re_rt) { <nl>  			RTFREE(re->re_rt); <nl> +			re->re_rt = NULL; <nl> +		} <nl>   <nl>  		/* Massage the IP header for use by the IPsec code */ <nl>  		ip->ip_len = htons((u_short) ip->ip_len);
@@ -1,4 +1,4 @@ <nl> -/* $OpenBSD: channels.c,v 1.342 2015/04/24 01:36:00 deraadt Exp $ */ <nl> +/* $OpenBSD: channels.c,v 1.343 2015/05/08 03:25:07 dtucker Exp $ */ <nl>  /* <nl>   * Author: Tatu Ylonen <ylo@cs.hut.fi> <nl>   * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland <nl> @@ -3498,7 +3498,7 @@ void <nl>  channel_disable_adm_local_opens(void) <nl>  { <nl>  	channel_clear_adm_permitted_opens(); <nl> -	permitted_adm_opens = xmalloc(sizeof(*permitted_adm_opens)); <nl> +	permitted_adm_opens = xcalloc(sizeof(*permitted_adm_opens), 1); <nl>  	permitted_adm_opens[num_adm_permitted_opens].host_to_connect = NULL; <nl>  	num_adm_permitted_opens = 1; <nl>  }
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: ntp.c,v 1.29 2006/09/17 17:03:56 ckuethe Exp $	*/ <nl> +/*	$OpenBSD: ntp.c,v 1.30 2010/08/16 11:09:26 krw Exp $	*/ <nl>   <nl>  /* <nl>   * Copyright (c) 1996, 1997 by N.M. Maclaren. All rights reserved. <nl> @@ -282,7 +282,7 @@ write_packet(int fd, struct ntp_data *data) <nl>  	 * the transmit field intelligible. <nl>  	 */ <nl>   <nl> -	*(u_int64_t *)(packet + NTP_TRANSMIT) = data->xmitck; <nl> +	bcopy(&data->xmitck, (packet + NTP_TRANSMIT), sizeof(data->xmitck)); <nl>   <nl>  	data->originate = current_time(JAN_1970); <nl>   <nl> @@ -424,7 +424,7 @@ unpack_ntp(struct ntp_data *data, u_char *packet) <nl>  	data->transmit = d / NTP_SCALE; <nl>   <nl>  	/* See write_packet for why this isn't an endian problem. */ <nl> -	data->recvck = *(u_int64_t *)(packet + NTP_ORIGINATE); <nl> +	bcopy((packet + NTP_ORIGINATE), &data->recvck, sizeof(data->recvck)); <nl>  } <nl>   <nl>  /*
@@ -1,4 +1,4 @@ <nl> -/*      $OpenBSD: pf_key_v2.c,v 1.72 2001/06/29 19:08:11 ho Exp $  */ <nl> +/*      $OpenBSD: pf_key_v2.c,v 1.73 2001/07/01 05:16:03 angelos Exp $  */ <nl>  /*	$EOM: pf_key_v2.c,v 1.79 2000/12/12 00:33:19 niklas Exp $	*/ <nl>   <nl>  /* <nl> @@ -2350,6 +2350,10 @@ pf_key_v2_delete_spi (struct sa *sa, struct proto *proto, int incoming) <nl>    struct sadb_x_sa2 ssa2; <nl>  #endif <nl>   <nl> +  /* If it's not an established SA, don't proceed. */ <nl> +  if (!(sa->flags & SA_FLAG_READY)) <nl> +    return 0; <nl> + <nl>    /* <nl>     * If the SA was not replaced and was not one acquired through the <nl>     * kernel (ACQUIRE message), remove the flow associated with it.
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: uipc_usrreq.c,v 1.113 2017/01/27 20:31:42 bluhm Exp $	*/ <nl> +/*	$OpenBSD: uipc_usrreq.c,v 1.114 2017/02/09 10:40:57 mpi Exp $	*/ <nl>  /*	$NetBSD: uipc_usrreq.c,v 1.18 1996/02/09 19:00:50 christos Exp $	*/ <nl>   <nl>  /* <nl> @@ -132,7 +132,10 @@ uipc_usrreq(struct socket *so, int req, struct mbuf *m, struct mbuf *nam, <nl>  		break; <nl>   <nl>  	case PRU_DETACH: <nl> +		/* XXXSMP breaks atomicity */ <nl> +		rw_exit_write(&netlock); <nl>  		unp_detach(unp); <nl> +		rw_enter_write(&netlock); <nl>  		break; <nl>   <nl>  	case PRU_BIND: <nl> @@ -394,7 +397,7 @@ void <nl>  unp_detach(struct unpcb *unp) <nl>  { <nl>  	struct vnode *vp; <nl> -	 <nl> + <nl>  	LIST_REMOVE(unp, unp_link); <nl>  	if (unp->unp_vnode) { <nl>  		unp->unp_vnode->v_socket = NULL;
@@ -1,5 +1,5 @@ <nl> -/*	$OpenBSD: sa.h,v 1.16 2000/06/08 20:50:07 niklas Exp $	*/ <nl> -/*	$EOM: sa.h,v 1.56 2000/05/19 05:47:53 angelos Exp $	*/ <nl> +/*	$OpenBSD: sa.h,v 1.17 2000/08/03 07:23:18 niklas Exp $	*/ <nl> +/*	$EOM: sa.h,v 1.57 2000/07/12 20:50:49 angelos Exp $	*/ <nl>   <nl>  /* <nl>   * Copyright (c) 1998, 1999 Niklas Hallqvist.  All rights reserved. <nl> @@ -185,6 +185,7 @@ extern void proto_free (struct proto *proto); <nl>  extern int sa_add_transform (struct sa *, struct payload *, int, <nl>  			     struct proto **); <nl>  extern int sa_create (struct exchange *, struct transport *); <nl> +extern int sa_enter (struct sa *); <nl>  extern void sa_delete (struct sa *, int); <nl>  extern struct sa *sa_find (int (*) (struct sa *, void *), void *); <nl>  extern int sa_flag (char *);
@@ -39,7 +39,7 @@ <nl>   */ <nl>   <nl>  #include "includes.h" <nl> -RCSID("$OpenBSD: channels.c,v 1.128 2001/06/25 08:25:35 markus Exp $"); <nl> +RCSID("$OpenBSD: channels.c,v 1.129 2001/06/29 18:40:28 stevesk Exp $"); <nl>   <nl>  #include "ssh.h" <nl>  #include "ssh1.h" <nl> @@ -1142,7 +1142,7 @@ static void <nl>  channel_post_connecting(Channel *c, fd_set * readset, fd_set * writeset) <nl>  { <nl>  	int err = 0; <nl> -	int sz = sizeof(err); <nl> +	socklen_t sz = sizeof(err); <nl>   <nl>  	if (FD_ISSET(c->sock, writeset)) { <nl>  		if (getsockopt(c->sock, SOL_SOCKET, SO_ERROR, (char *)&err,
@@ -1,4 +1,4 @@ <nl> -/* $OpenBSD: wskbd.c,v 1.27 2001/10/25 14:30:43 drahn Exp $ */ <nl> +/* $OpenBSD: wskbd.c,v 1.28 2001/10/30 05:15:37 mickey Exp $ */ <nl>  /* $NetBSD: wskbd.c,v 1.38 2000/03/23 07:01:47 thorpej Exp $ */ <nl>   <nl>  /* <nl> @@ -966,6 +966,11 @@ getbell: <nl>  		kkdp = &sc->sc_keyrepeat_data; <nl>  setkeyrepeat: <nl>  		ukdp = (struct wskbd_keyrepeat_data *)data; <nl> +		if ((ukdp->which & WSKBD_KEYREPEAT_DODEL1 && <nl> +		     (hz * ukdp->del1) / 1000 <= 0) || <nl> +		    (ukdp->which & WSKBD_KEYREPEAT_DODELN && <nl> +		     (hz * ukdp->delN) / 1000 <= 0)) <nl> +			return (EINVAL); <nl>  		SETKEYREPEAT(kkdp, ukdp, kkdp); <nl>  		return (0); <nl>  
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: util.c,v 1.115 2015/10/02 00:41:25 gilles Exp $	*/ <nl> +/*	$OpenBSD: util.c,v 1.116 2015/10/05 22:08:14 stsp Exp $	*/ <nl>   <nl>  /* <nl>   * Copyright (c) 2000,2001 Markus Friedl.  All rights reserved. <nl> @@ -735,6 +735,7 @@ getmailname(char *hostname, size_t len) <nl>  			fatal("exiting"); <nl>  		} <nl>  		memcpy(lbuf, buf, buflen); <nl> +		buf = lbuf; <nl>  	} <nl>   <nl>  	if (strlcpy(hostname, buf, len) >= len)
@@ -1,4 +1,4 @@ <nl> -/* $OpenBSD: softraid.c,v 1.376 2016/05/31 15:19:12 jsing Exp $ */ <nl> +/* $OpenBSD: softraid.c,v 1.377 2016/07/20 20:45:13 krw Exp $ */ <nl>  /* <nl>   * Copyright (c) 2007, 2008, 2009 Marco Peereboom <marco@peereboom.us> <nl>   * Copyright (c) 2008 Chris Kuethe <ckuethe@openbsd.org> <nl> @@ -3313,7 +3313,7 @@ sr_ioctl_createraid(struct sr_softc *sc, struct bioc_createraid *bc, <nl>  	struct scsi_link	*link; <nl>  	struct device		*dev; <nl>  	char			*uuid, devname[32]; <nl> -	dev_t			*dt; <nl> +	dev_t			*dt = NULL; <nl>  	int			i, no_chunk, rv = EINVAL, target, vol; <nl>  	int			no_meta; <nl>   <nl> @@ -3586,9 +3586,13 @@ sr_ioctl_createraid(struct sr_softc *sc, struct bioc_createraid *bc, <nl>   <nl>  	sd->sd_ready = 1; <nl>   <nl> +	free(dt, M_DEVBUF, bc->bc_dev_list_len); <nl> + <nl>  	return (rv); <nl>   <nl>  unwind: <nl> +	free(dt, M_DEVBUF, bc->bc_dev_list_len); <nl> + <nl>  	sr_discipline_shutdown(sd, 0); <nl>   <nl>  	if (rv == EAGAIN)
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: sd.c,v 1.19 1996/10/31 01:09:25 niklas Exp $	*/ <nl> +/*	$OpenBSD: sd.c,v 1.20 1996/12/03 08:08:00 deraadt Exp $	*/ <nl>  /*	$NetBSD: sd.c,v 1.100.4.1 1996/06/04 23:14:08 thorpej Exp $	*/ <nl>   <nl>  /* <nl> @@ -866,6 +866,7 @@ sd_get_parms(sd, flags) <nl>  	/* <nl>  	 * do a "mode sense page 4" <nl>  	 */ <nl> +	bzero(&scsi_sense, sizeof(scsi_sense)); <nl>  	bzero(&scsi_cmd, sizeof(scsi_cmd)); <nl>  	scsi_cmd.opcode = MODE_SENSE; <nl>  	scsi_cmd.page = 4;
@@ -1,4 +1,4 @@ <nl> -/* $OpenBSD: cmd-pipe-pane.c,v 1.1 2009/10/11 10:04:27 nicm Exp $ */ <nl> +/* $OpenBSD: cmd-pipe-pane.c,v 1.2 2009/10/21 18:12:31 nicm Exp $ */ <nl>   <nl>  /* <nl>   * Copyright (c) 2009 Nicholas Marriott <nicm@users.sourceforge.net> <nl> @@ -47,11 +47,10 @@ int <nl>  cmd_pipe_pane_exec(struct cmd *self, struct cmd_ctx *ctx) <nl>  { <nl>  	struct cmd_target_data	*data = self->data; <nl> -	struct winlink		*wl; <nl>  	struct window_pane	*wp; <nl>  	int			 old_fd, pipe_fd[2], null_fd, mode; <nl>   <nl> -	if ((wl = cmd_find_pane(ctx, data->target, NULL, &wp)) == NULL) <nl> +	if (cmd_find_pane(ctx, data->target, NULL, &wp) == NULL) <nl>  		return (-1); <nl>   <nl>  	/* Destroy the old pipe. */
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: file_media.c,v 1.13 2016/01/11 07:57:54 jasper Exp $	*/ <nl> +/*	$OpenBSD: file_media.c,v 1.14 2016/01/11 14:27:29 jasper Exp $	*/ <nl>   <nl>  /* <nl>   * file_media.c - <nl> @@ -179,6 +179,7 @@ compute_block_size(int fd) <nl>  	    } <nl>  	} <nl>      } <nl> +    free(buffer); <nl>      return 0; <nl>  } <nl>  
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: uhub.c,v 1.58 2011/07/03 15:47:17 matthew Exp $ */ <nl> +/*	$OpenBSD: uhub.c,v 1.59 2011/09/29 11:18:01 stsp Exp $ */ <nl>  /*	$NetBSD: uhub.c,v 1.64 2003/02/08 03:32:51 ichiro Exp $	*/ <nl>  /*	$FreeBSD: src/sys/dev/usb/uhub.c,v 1.18 1999/11/17 22:33:43 n_hibma Exp $	*/ <nl>   <nl> @@ -331,10 +331,11 @@ uhub_attach(struct device *parent, struct device *self, void *aux) <nl>   bad: <nl>  	if (sc->sc_statusbuf) <nl>  		free(sc->sc_statusbuf, M_USBDEV); <nl> -	if (hub->ports) <nl> -		free(hub->ports, M_USBDEV); <nl> -	if (hub) <nl> +	if (hub) { <nl> +		if (hub->ports) <nl> +			free(hub->ports, M_USBDEV); <nl>  		free(hub, M_USBDEV); <nl> +	} <nl>  	dev->hub = NULL; <nl>  } <nl>  
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: tree.c,v 1.9 1999/07/14 13:37:24 millert Exp $	*/ <nl> +/*	$OpenBSD: tree.c,v 1.10 2002/02/27 19:37:09 dhartmei Exp $	*/ <nl>   <nl>  /* <nl>   * command tree climbing <nl> @@ -508,7 +508,7 @@ tcopy(t, ap) <nl>  		for (tw = t->vars; *tw++ != NULL; ) <nl>  			; <nl>  		rw = r->vars = (char **) <nl> -			alloc((int)(tw - t->vars) * sizeof(*tw), ap); <nl> +			alloc((tw - t->vars + 1) * sizeof(*tw), ap); <nl>  		for (tw = t->vars; *tw != NULL; ) <nl>  			*rw++ = wdcopy(*tw++, ap); <nl>  		*rw = NULL; <nl> @@ -520,7 +520,7 @@ tcopy(t, ap) <nl>  		for (tw = t->args; *tw++ != NULL; ) <nl>  			; <nl>  		rw = r->args = (char **) <nl> -			alloc((int)(tw - t->args) * sizeof(*tw), ap); <nl> +			alloc((tw - t->args + 1) * sizeof(*tw), ap); <nl>  		for (tw = t->args; *tw != NULL; ) <nl>  			*rw++ = wdcopy(*tw++, ap); <nl>  		*rw = NULL; <nl> @@ -681,7 +681,7 @@ iocopy(iow, ap) <nl>   <nl>  	for (ior = iow; *ior++ != NULL; ) <nl>  		; <nl> -	ior = (struct ioword **) alloc((int)(ior - iow) * sizeof(*ior), ap); <nl> +	ior = (struct ioword **) alloc((ior - iow + 1) * sizeof(*ior), ap); <nl>   <nl>  	for (i = 0; iow[i] != NULL; i++) { <nl>  		register struct ioword *p, *q;
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: expl.c,v 1.4 1999/02/01 06:53:56 d Exp $	*/ <nl> +/*	$OpenBSD: expl.c,v 1.5 1999/08/30 23:30:08 d Exp $	*/ <nl>  /*	$NetBSD: expl.c,v 1.2 1997/10/10 16:33:18 lukem Exp $	*/ <nl>  /* <nl>   *  Hunt <nl> @@ -34,6 +34,10 @@ showexpl(y, x, type) <nl>  	if (x < 0 || x >= WIDTH) <nl>  		return; <nl>  	ep = (EXPL *) malloc(sizeof (EXPL));	/* NOSTRICT */ <nl> +	if (ep == NULL) { <nl> +		log(LOG_ERR, "malloc"); <nl> +		return; <nl> +	} <nl>  	ep->e_y = y; <nl>  	ep->e_x = x; <nl>  	ep->e_char = type;
@@ -231,6 +231,8 @@ bool LoopIdiomRecognize::runOnLoop(Loop *L) { <nl>    StringRef Name = L->getHeader()->getParent()->getName(); <nl>    if (Name == "memset" || Name == "memcpy") <nl>      return false; <nl> +  if (Name == "_libc_memset" || Name == "_libc_memcpy") <nl> +    return false; <nl>   <nl>    // Determine if code size heuristics need to be applied. <nl>    ApplyCodeSizeHeuristics =
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: ldpctl.c,v 1.23 2015/09/27 17:30:38 stsp Exp $ <nl> +/*	$OpenBSD: ldpctl.c,v 1.24 2015/10/23 10:11:20 renato Exp $ <nl>   * <nl>   * Copyright (c) 2009 Michele Marchetto <michele@openbsd.org> <nl>   * Copyright (c) 2005 Claudio Jeker <claudio@openbsd.org> <nl> @@ -94,6 +94,9 @@ main(int argc, char *argv[]) <nl>  	if (connect(ctl_sock, (struct sockaddr *)&sun, sizeof(sun)) == -1) <nl>  		err(1, "connect: %s", LDPD_SOCKET); <nl>   <nl> +	if (pledge("stdio", NULL) == -1) <nl> +		err(1, "pledge"); <nl> + <nl>  	if ((ibuf = malloc(sizeof(struct imsgbuf))) == NULL) <nl>  		err(1, NULL); <nl>  	imsg_init(ibuf, ctl_sock);
@@ -1,4 +1,4 @@ <nl> -/* $Id: engine.c,v 1.1 2008/06/12 22:26:01 canacar Exp $	 */ <nl> +/* $Id: engine.c,v 1.2 2008/06/13 01:06:06 canacar Exp $	 */ <nl>  /* <nl>   * Copyright (c) 2001, 2007 Can Erkin Acar <canacar@openbsd.org> <nl>   * <nl> @@ -802,6 +802,9 @@ next_order(void) <nl>  { <nl>  	order_type *o, *oc; <nl>   <nl> +	if (curr_view->mgr->order_list == NULL) <nl> +		return; <nl> + <nl>  	oc = curr_view->mgr->order_curr; <nl>   <nl>  	for (o = curr_view->mgr->order_list; o->name != NULL; o++) {
@@ -1,4 +1,4 @@ <nl> -/* $OpenBSD: ssh-keygen.c,v 1.231 2013/08/13 18:32:08 djm Exp $ */ <nl> +/* $OpenBSD: ssh-keygen.c,v 1.232 2013/08/13 18:33:08 djm Exp $ */ <nl>  /* <nl>   * Author: Tatu Ylonen <ylo@cs.hut.fi> <nl>   * Copyright (c) 1994 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland <nl> @@ -1985,7 +1985,7 @@ update_krl_from_file(struct passwd *pw, const char *file, const Key *ca, <nl>  			} <nl>  		} else if (strncasecmp(cp, "id:", 3) == 0) { <nl>  			if (ca == NULL) { <nl> -				fatal("revoking certificated by key ID " <nl> +				fatal("revoking certificates by key ID " <nl>  				    "requires specification of a CA key"); <nl>  			} <nl>  			cp += 3;
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: atombios_encoders.c,v 1.1 2013/08/12 04:11:53 jsg Exp $	*/ <nl> +/*	$OpenBSD: atombios_encoders.c,v 1.2 2014/01/23 00:40:52 jsg Exp $	*/ <nl>  /* <nl>   * Copyright 2007-11 Advanced Micro Devices, Inc. <nl>   * Copyright 2008 Red Hat Inc. <nl> @@ -1630,8 +1630,12 @@ radeon_atom_encoder_dpms_dig(struct drm_encoder *encoder, int mode) <nl>  			atombios_dig_encoder_setup(encoder, ATOM_ENABLE, 0); <nl>  			atombios_dig_transmitter_setup(encoder, ATOM_TRANSMITTER_ACTION_SETUP, 0, 0); <nl>  			atombios_dig_transmitter_setup(encoder, ATOM_TRANSMITTER_ACTION_ENABLE, 0, 0); <nl> -			/* some early dce3.2 boards have a bug in their transmitter control table */ <nl> -			if ((rdev->family != CHIP_RV710) && (rdev->family != CHIP_RV730)) <nl> +			/* some dce3.x boards have a bug in their transmitter control table. <nl> +			 * ACTION_ENABLE_OUTPUT can probably be dropped since ACTION_ENABLE <nl> +			 * does the same thing and more. <nl> +			 */ <nl> +			if ((rdev->family != CHIP_RV710) && (rdev->family != CHIP_RV730) && <nl> +			    (rdev->family != CHIP_RS880)) <nl>  				atombios_dig_transmitter_setup(encoder, ATOM_TRANSMITTER_ACTION_ENABLE_OUTPUT, 0, 0); <nl>  		} <nl>  		if (ENCODER_MODE_IS_DP(atombios_get_encoder_mode(encoder)) && connector) {
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: auth_subr.c,v 1.47 2015/10/23 04:52:21 guenther Exp $	*/ <nl> +/*	$OpenBSD: auth_subr.c,v 1.48 2015/11/02 17:03:29 mmcc Exp $	*/ <nl>   <nl>  /* <nl>   * Copyright (c) 2000-2002,2004 Todd C. Miller <Todd.Miller@courtesan.com> <nl> @@ -745,7 +745,7 @@ auth_check_expire(auth_session_t *as) <nl>   <nl>  	if (as->pwd && (quad_t)as->pwd->pw_expire != 0) { <nl>  		if (as->now.tv_sec == 0) <nl> -			gettimeofday(&as->now, (struct timezone *)NULL); <nl> +			gettimeofday(&as->now, NULL); <nl>  		if ((quad_t)as->now.tv_sec >= (quad_t)as->pwd->pw_expire) { <nl>  			as->state &= ~AUTH_ALLOW; <nl>  			as->state |= AUTH_EXPIRED; <nl> @@ -772,7 +772,7 @@ auth_check_change(auth_session_t *as) <nl>   <nl>  	if (as->pwd && (quad_t)as->pwd->pw_change) { <nl>  		if (as->now.tv_sec == 0) <nl> -			gettimeofday(&as->now, (struct timezone *)NULL); <nl> +			gettimeofday(&as->now, NULL); <nl>  		if (as->now.tv_sec >= (quad_t)as->pwd->pw_change) { <nl>  			as->state &= ~AUTH_ALLOW; <nl>  			as->state |= AUTH_PWEXPIRED;
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: log.c,v 1.42 2004/11/18 14:30:10 henning Exp $ */ <nl> +/*	$OpenBSD: log.c,v 1.43 2005/03/26 18:49:34 tedu Exp $ */ <nl>   <nl>  /* <nl>   * Copyright (c) 2003, 2004 Henning Brauer <henning@openbsd.org> <nl> @@ -276,19 +276,19 @@ log_notification(const struct peer *peer, u_int8_t errcode, u_int8_t subcode, <nl>  	p = log_fmt_peer(&peer->conf); <nl>  	switch (errcode) { <nl>  	case ERR_HEADER: <nl> -		if (subcode > sizeof(suberr_header_names)/sizeof(char *)) <nl> +		if (subcode >= sizeof(suberr_header_names)/sizeof(char *)) <nl>  			uk = 1; <nl>  		else <nl>  			suberrname = suberr_header_names[subcode]; <nl>  		break; <nl>  	case ERR_OPEN: <nl> -		if (subcode > sizeof(suberr_open_names)/sizeof(char *)) <nl> +		if (subcode >= sizeof(suberr_open_names)/sizeof(char *)) <nl>  			uk = 1; <nl>  		else <nl>  			suberrname = suberr_open_names[subcode]; <nl>  		break; <nl>  	case ERR_UPDATE: <nl> -		if (subcode > sizeof(suberr_update_names)/sizeof(char *)) <nl> +		if (subcode >= sizeof(suberr_update_names)/sizeof(char *)) <nl>  			uk = 1; <nl>  		else <nl>  			suberrname = suberr_update_names[subcode];
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: uvm_pdaemon.c,v 1.50 2009/06/17 00:13:59 oga Exp $	*/ <nl> +/*	$OpenBSD: uvm_pdaemon.c,v 1.51 2009/06/26 20:26:02 oga Exp $	*/ <nl>  /*	$NetBSD: uvm_pdaemon.c,v 1.23 2000/08/20 10:24:14 bjh21 Exp $	*/ <nl>   <nl>  /*  <nl> @@ -823,8 +823,13 @@ uvmpd_scan_inactive(struct pglist *pglst) <nl>  			/* released during I/O? */ <nl>  			if (p->pg_flags & PG_RELEASED) { <nl>  				if (anon) { <nl> -					/* remove page so we can get nextpg */ <nl> +					/* <nl> +					 * remove page so we can get nextpg, <nl> +					 * also zero out anon so we don't use <nl> +					 * it after the free. <nl> +					 */ <nl>  					anon->an_page = NULL; <nl> +					p->uanon = NULL; <nl>   <nl>  					simple_unlock(&anon->an_lock); <nl>  					uvm_anfree(anon);	/* kills anon */
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: smtp_session.c,v 1.90 2009/05/19 11:42:52 jacekm Exp $	*/ <nl> +/*	$OpenBSD: smtp_session.c,v 1.91 2009/05/19 12:33:53 jacekm Exp $	*/ <nl>   <nl>  /* <nl>   * Copyright (c) 2008 Gilles Chehade <gilles@openbsd.org> <nl> @@ -119,6 +119,11 @@ session_rfc3207_stls_handler(struct session *s, char *args) <nl>  		return 1; <nl>  	} <nl>   <nl> +	if (s->s_state != S_HELO) { <nl> +		session_respond(s, "503 TLS not allowed at this stage"); <nl> +		return 1; <nl> +	} <nl> + <nl>  	if (args != NULL) { <nl>  		session_respond(s, "501 No parameters allowed"); <nl>  		return 1;
@@ -3,7 +3,7 @@ <nl>   * DONT EDIT THIS FILE <nl>   */ <nl>   <nl> -/*	$OpenBSD: cn30xxgmxreg.h,v 1.3 2016/06/09 15:29:22 visa Exp $	*/ <nl> +/*	$OpenBSD: cn30xxgmxreg.h,v 1.4 2016/06/18 15:43:08 visa Exp $	*/ <nl>   <nl>  /* <nl>   * Copyright (c) 2007 Internet Initiative Japan, Inc. <nl> @@ -650,7 +650,7 @@ <nl>   <nl>  /* Low-level SGMII link control */ <nl>   <nl> -#define	PCS_BASE(g, i)	(0x00011800b0001000ULL + 0x20000 * (g) + 0x400 * (i)) <nl> +#define	PCS_BASE(g, i)	(0x00011800b0001000ULL + 0x8000000 * (g) + 0x400 * (i)) <nl>  #define	PCS_SIZE	0x98 <nl>   <nl>  #define	PCS_MR_CONTROL				0x00
@@ -1,4 +1,4 @@ <nl> -/* $OpenBSD: window.c,v 1.134 2015/06/17 16:50:28 nicm Exp $ */ <nl> +/* $OpenBSD: window.c,v 1.135 2015/07/17 13:09:07 nicm Exp $ */ <nl>   <nl>  /* <nl>   * Copyright (c) 2007 Nicholas Marriott <nicm@users.sourceforge.net> <nl> @@ -341,12 +341,12 @@ window_create(const char *name, int argc, char **argv, const char *path, <nl>  void <nl>  window_destroy(struct window *w) <nl>  { <nl> -	window_unzoom(w); <nl> - <nl>  	RB_REMOVE(windows, &windows, w); <nl>   <nl>  	if (w->layout_root != NULL) <nl> -		layout_free(w); <nl> +		layout_free_cell(w->layout_root); <nl> +	if (w->saved_layout_root != NULL) <nl> +		layout_free_cell(w->saved_layout_root); <nl>  	free(w->old_layout); <nl>   <nl>  	if (event_initialized(&w->name_timer))
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: pchb.c,v 1.49 2005/06/14 20:35:45 deraadt Exp $	*/ <nl> +/*	$OpenBSD: pchb.c,v 1.50 2005/12/29 04:26:17 brad Exp $	*/ <nl>  /*	$NetBSD: pchb.c,v 1.6 1997/06/06 23:29:16 thorpej Exp $	*/ <nl>   <nl>  /* <nl> @@ -251,7 +251,7 @@ pchbattach(parent, self, aux) <nl>  				printf(": Compatibility PB (bus %d)", pbnum); <nl>  				break; <nl>  			case PCISET_INTEL_TYPE_AUX: <nl> -				printf(": Auxiliary PB (bus %d)\n", pbnum); <nl> +				printf(": Auxiliary PB (bus %d)", pbnum); <nl>  				neednl = 0; <nl>   <nl>  				/*
@@ -1,4 +1,4 @@ <nl> -/*	$OpenBSD: azalia_codec.c,v 1.163 2014/07/13 23:10:23 deraadt Exp $	*/ <nl> +/*	$OpenBSD: azalia_codec.c,v 1.164 2014/11/17 16:34:51 landry Exp $	*/ <nl>  /*	$NetBSD: azalia_codec.c,v 1.8 2006/05/10 11:17:27 kent Exp $	*/ <nl>   <nl>  /*- <nl> @@ -149,11 +149,13 @@ azalia_codec_init_vtbl(codec_t *this) <nl>  		this->name = "Realtek ALC885"; <nl>  		this->qrks |= AZ_QRK_WID_CDIN_1C | AZ_QRK_WID_BEEP_1D; <nl>  		if (this->subid == 0x00a1106b ||	/* APPLE_MB3 */ <nl> +		    this->subid == 0xcb7910de ||	/* APPLE_MACMINI3_1 (line-in + hp) */ <nl>  		    this->subid == 0x00a0106b ||	/* APPLE_MB3_1 */ <nl>  		    this->subid == 0x00a3106b) {	/* APPLE_MB4 */ <nl>  			this->qrks |= AZ_QRK_GPIO_UNMUTE_0; <nl>  		} <nl>  		if (this->subid == 0x00a1106b || <nl> +		    this->subid == 0xcb7910de ||	/* APPLE_MACMINI3_1 (internal spkr) */ <nl>  		    this->subid == 0x00a0106b) <nl>  			this->qrks |= AZ_QRK_WID_OVREF50; <nl>  		break;
@@ -608,6 +608,7 @@ static void virtio_gpu_set_scanout(VirtIOGPU *g, <nl>              cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC; <nl>              return; <nl>          } <nl> +        pixman_image_unref(rect); <nl>          dpy_gfx_replace_surface(g->scanout[ss.scanout_id].con, scanout->ds); <nl>      } <nl>  
@@ -7538,7 +7538,7 @@ static target_ulong disas_insn(DisasContext *s, target_ulong pc_start) <nl>              break; <nl>          case 5: /* lfence */ <nl>          case 6: /* mfence */ <nl> -            if ((modrm & 0xc7) != 0xc0 || !(s->cpuid_features & CPUID_SSE)) <nl> +            if ((modrm & 0xc7) != 0xc0 || !(s->cpuid_features & CPUID_SSE2)) <nl>                  goto illegal_op; <nl>              break; <nl>          case 7: /* sfence / clflush */
@@ -1030,6 +1030,7 @@ void ppce500_init(MachineState *machine, PPCE500Params *params) <nl>              exit(1); <nl>          } <nl>      } <nl> +    g_free(filename); <nl>   <nl>      /* Reserve space for dtb */ <nl>      dt_base = (loadaddr + bios_size + DTC_LOAD_PAD) & ~DTC_PAD_MASK;
@@ -168,7 +168,7 @@ static int blk_root_inactivate(BdrvChild *child) <nl>       * this point because the VM is stopped) and unattached monitor-owned <nl>       * BlockBackends. If there is still any other user like a block job, then <nl>       * we simply can't inactivate the image. */ <nl> -    if (!blk->dev && !blk->name[0]) { <nl> +    if (!blk->dev && !blk_name(blk)[0]) { <nl>          return -EPERM; <nl>      } <nl>  
@@ -1432,7 +1432,7 @@ void cpu_interrupt(CPUState *env, int mask) <nl>         signals are used primarily to interrupt blocking syscalls.  */ <nl>  #else <nl>      if (use_icount) { <nl> -        env->icount_decr.u16.high = 0x8000; <nl> +        env->icount_decr.u16.high = 0xffff; <nl>  #ifndef CONFIG_USER_ONLY <nl>          /* CPU_INTERRUPT_EXIT isn't a real interrupt.  It just means <nl>             an async event happened and we need to process it.  */
@@ -3451,7 +3451,7 @@ CPUArchState *cpu_copy(CPUArchState *env) <nl>  { <nl>      CPUState *cpu = ENV_GET_CPU(env); <nl>      CPUState *new_cpu = cpu_init(cpu_model); <nl> -    CPUArchState *new_env = cpu->env_ptr; <nl> +    CPUArchState *new_env = new_cpu->env_ptr; <nl>      CPUBreakpoint *bp; <nl>      CPUWatchpoint *wp; <nl>  
@@ -660,7 +660,6 @@ int net_init_l2tpv3(const NetClientOptions *opts, <nl>      if (fd == -1) { <nl>          fd = -errno; <nl>          error_report("l2tpv3_open : socket creation failed, errno = %d", -fd); <nl> -        freeaddrinfo(result); <nl>          goto outerr; <nl>      } <nl>      if (bind(fd, (struct sockaddr *) result->ai_addr, result->ai_addrlen)) {
@@ -609,6 +609,7 @@ static const RunStateTransition runstate_transitions_def[] = { <nl>      { RUN_STATE_WATCHDOG, RUN_STATE_FINISH_MIGRATE }, <nl>   <nl>      { RUN_STATE_GUEST_PANICKED, RUN_STATE_PAUSED }, <nl> +    { RUN_STATE_GUEST_PANICKED, RUN_STATE_FINISH_MIGRATE }, <nl>   <nl>      { RUN_STATE_MAX, RUN_STATE_MAX }, <nl>  };
@@ -45,6 +45,10 @@ <nl>  #define PI 3.14159265358979323846 <nl>  #endif <nl>   <nl> +#ifndef ARRAY_SIZE <nl> +#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0])) <nl> +#endif <nl> + <nl>  /* -------------------- for debug --------------------- */ <nl>  /* #define OPL_OUTPUT_LOG */ <nl>  #ifdef OPL_OUTPUT_LOG <nl> @@ -595,7 +599,7 @@ static void init_timetables( FM_OPL *OPL , int ARRATE , int DRRATE ) <nl>  		OPL->AR_TABLE[i] = rate / ARRATE; <nl>  		OPL->DR_TABLE[i] = rate / DRRATE; <nl>  	} <nl> -	for (i = 60;i < 76;i++) <nl> +	for (i = 60; i < ARRAY_SIZE(OPL->AR_TABLE); i++) <nl>  	{ <nl>  		OPL->AR_TABLE[i] = EG_AED-1; <nl>  		OPL->DR_TABLE[i] = OPL->DR_TABLE[60];
@@ -2473,7 +2473,7 @@ int xbzrle_encode_buffer(uint8_t *old_buf, uint8_t *new_buf, int slen, <nl>          /* word at a time for speed, use of 32-bit long okay */ <nl>          if (!res) { <nl>              /* truncation to 32-bit long okay */ <nl> -            long mask = 0x0101010101010101ULL; <nl> +            long mask = (long)0x0101010101010101ULL; <nl>              while (i < slen) { <nl>                  xor = *(long *)(old_buf + i) ^ *(long *)(new_buf + i); <nl>                  if ((xor - mask) & ~xor & (mask << 7)) {
@@ -261,10 +261,6 @@ static void virtio_balloon_save(QEMUFile *f, void *opaque) <nl>   <nl>      qemu_put_be32(f, s->num_pages); <nl>      qemu_put_be32(f, s->actual); <nl> -    qemu_put_buffer(f, (uint8_t *)&s->stats_vq_elem, sizeof(VirtQueueElement)); <nl> -    qemu_put_buffer(f, (uint8_t *)&s->stats_vq_offset, sizeof(size_t)); <nl> -    qemu_put_buffer(f, (uint8_t *)&s->stats_callback, sizeof(MonitorCompletion)); <nl> -    qemu_put_buffer(f, (uint8_t *)&s->stats_opaque_callback_data, sizeof(void)); <nl>  } <nl>   <nl>  static int virtio_balloon_load(QEMUFile *f, void *opaque, int version_id) <nl> @@ -278,11 +274,6 @@ static int virtio_balloon_load(QEMUFile *f, void *opaque, int version_id) <nl>   <nl>      s->num_pages = qemu_get_be32(f); <nl>      s->actual = qemu_get_be32(f); <nl> -    qemu_get_buffer(f, (uint8_t *)&s->stats_vq_elem, sizeof(VirtQueueElement)); <nl> -    qemu_get_buffer(f, (uint8_t *)&s->stats_vq_offset, sizeof(size_t)); <nl> -    qemu_get_buffer(f, (uint8_t *)&s->stats_callback, sizeof(MonitorCompletion)); <nl> -    qemu_get_buffer(f, (uint8_t *)&s->stats_opaque_callback_data, sizeof(void)); <nl> - <nl>      return 0; <nl>  } <nl>  
@@ -280,7 +280,7 @@ static void pmac_ide_atapi_transfer_cb(void *opaque, int ret) <nl>      } <nl>   <nl>      /* Calculate current offset */ <nl> -    offset = (int64_t)(s->lba << 11) + s->io_buffer_index; <nl> +    offset = ((int64_t)s->lba << 11) + s->io_buffer_index; <nl>   <nl>      pmac_dma_read(s->blk, offset, io->len, pmac_ide_atapi_transfer_cb, io); <nl>      return;
@@ -472,7 +472,7 @@ static target_ulong h_resize_hpt_prepare(PowerPCCPU *cpu, <nl>      target_ulong flags = args[0]; <nl>      int shift = args[1]; <nl>      sPAPRPendingHPT *pending = spapr->pending_hpt; <nl> -    uint64_t current_ram_size = MACHINE(spapr)->ram_size; <nl> +    uint64_t current_ram_size; <nl>      int rc; <nl>   <nl>      if (spapr->resize_hpt == SPAPR_RESIZE_HPT_DISABLED) { <nl> @@ -494,7 +494,7 @@ static target_ulong h_resize_hpt_prepare(PowerPCCPU *cpu, <nl>          return H_PARAMETER; <nl>      } <nl>   <nl> -    current_ram_size = pc_existing_dimms_capacity(&error_fatal); <nl> +    current_ram_size = MACHINE(spapr)->ram_size + get_plugged_memory_size(); <nl>   <nl>      /* We only allow the guest to allocate an HPT one order above what <nl>       * we'd normally give them (to stop a small guest claiming a huge
@@ -2931,6 +2931,8 @@ void qemu_ram_free(ram_addr_t addr) <nl>                  } else { <nl>                      qemu_vfree(block->host); <nl>                  } <nl> +#else <nl> +                abort(); <nl>  #endif <nl>              } else { <nl>  #if defined(TARGET_S390X) && defined(CONFIG_KVM) <nl> @@ -2979,6 +2981,8 @@ void qemu_ram_remap(ram_addr_t addr, ram_addr_t length) <nl>                          area = mmap(vaddr, length, PROT_READ | PROT_WRITE, <nl>                                      flags, -1, 0); <nl>                      } <nl> +#else <nl> +                    abort(); <nl>  #endif <nl>                  } else { <nl>  #if defined(TARGET_S390X) && defined(CONFIG_KVM)
@@ -2228,6 +2228,7 @@ void qmp_getfd(const char *fdname, Error **errp) <nl>      } <nl>   <nl>      if (qemu_isdigit(fdname[0])) { <nl> +        close(fd); <nl>          error_set(errp, QERR_INVALID_PARAMETER_VALUE, "fdname", <nl>                    "a name not starting with a digit"); <nl>          return;
@@ -88,6 +88,8 @@ static void pcie_host_init(Object *obj) <nl>      PCIExpressHost *e = PCIE_HOST_BRIDGE(obj); <nl>   <nl>      e->base_addr = PCIE_BASE_ADDR_UNMAPPED; <nl> +    memory_region_init_io(&e->mmio, OBJECT(e), &pcie_mmcfg_ops, e, "pcie-mmcfg-mmio", <nl> +                          PCIE_MMCFG_SIZE_MAX); <nl>  } <nl>   <nl>  void pcie_host_mmcfg_unmap(PCIExpressHost *e) <nl> @@ -104,8 +106,7 @@ void pcie_host_mmcfg_init(PCIExpressHost *e, uint32_t size) <nl>      assert(size >= PCIE_MMCFG_SIZE_MIN); <nl>      assert(size <= PCIE_MMCFG_SIZE_MAX); <nl>      e->size = size; <nl> -    memory_region_init_io(&e->mmio, OBJECT(e), &pcie_mmcfg_ops, e, <nl> -                          "pcie-mmcfg", e->size); <nl> +    memory_region_set_size(&e->mmio, e->size); <nl>  } <nl>   <nl>  void pcie_host_mmcfg_map(PCIExpressHost *e, hwaddr addr, <nl> @@ -121,10 +122,12 @@ void pcie_host_mmcfg_update(PCIExpressHost *e, <nl>                              hwaddr addr, <nl>                              uint32_t size) <nl>  { <nl> +    memory_region_transaction_begin(); <nl>      pcie_host_mmcfg_unmap(e); <nl>      if (enable) { <nl>          pcie_host_mmcfg_map(e, addr, size); <nl>      } <nl> +    memory_region_transaction_commit(); <nl>  } <nl>   <nl>  static const TypeInfo pcie_host_type_info = {
@@ -825,8 +825,8 @@ static int blk_connect(struct XenDevice *xendev) <nl>   <nl>      /* Fill in number of sector size and number of sectors */ <nl>      xenstore_write_be_int(&blkdev->xendev, "sector-size", blkdev->file_blk); <nl> -    xenstore_write_be_int(&blkdev->xendev, "sectors", <nl> -                          blkdev->file_size / blkdev->file_blk); <nl> +    xenstore_write_be_int64(&blkdev->xendev, "sectors", <nl> +                            blkdev->file_size / blkdev->file_blk); <nl>   <nl>      if (xenstore_read_fe_int(&blkdev->xendev, "ring-ref", &blkdev->ring_ref) == -1) { <nl>          return -1;
@@ -26,12 +26,14 @@ static void openrisc_pic_cpu_handler(void *opaque, int irq, int level) <nl>  { <nl>      OpenRISCCPU *cpu = (OpenRISCCPU *)opaque; <nl>      CPUState *cs = CPU(cpu); <nl> -    uint32_t irq_bit = 1 << irq; <nl> +    uint32_t irq_bit; <nl>   <nl>      if (irq > 31 || irq < 0) { <nl>          return; <nl>      } <nl>   <nl> +    irq_bit = 1U << irq; <nl> + <nl>      if (level) { <nl>          cpu->env.picsr |= irq_bit; <nl>      } else {
@@ -2506,6 +2506,11 @@ CharDriverState *qemu_chr_open_opts(QemuOpts *opts, <nl>          return NULL; <nl>      } <nl>   <nl> +    if (qemu_opt_get(opts, "backend") == NULL) { <nl> +        fprintf(stderr, "chardev: \"%s\" missing backend\n", <nl> +                qemu_opts_id(opts)); <nl> +        return NULL; <nl> +    } <nl>      for (i = 0; i < ARRAY_SIZE(backend_table); i++) { <nl>          if (strcmp(backend_table[i].name, qemu_opt_get(opts, "backend")) == 0) <nl>              break;
@@ -493,21 +493,21 @@ static int vhost_verify_ring_mappings(struct vhost_dev *dev, <nl>          j = 0; <nl>          r = vhost_verify_ring_part_mapping(dev, vq->desc, vq->desc_phys, <nl>                                             vq->desc_size, start_addr, size); <nl> -        if (!r) { <nl> +        if (r) { <nl>              break; <nl>          } <nl>   <nl>          j++; <nl>          r = vhost_verify_ring_part_mapping(dev, vq->avail, vq->avail_phys, <nl>                                             vq->avail_size, start_addr, size); <nl> -        if (!r) { <nl> +        if (r) { <nl>              break; <nl>          } <nl>   <nl>          j++; <nl>          r = vhost_verify_ring_part_mapping(dev, vq->used, vq->used_phys, <nl>                                             vq->used_size, start_addr, size); <nl> -        if (!r) { <nl> +        if (r) { <nl>              break; <nl>          } <nl>      }
@@ -182,7 +182,8 @@ static void cleanup_unknown_header_ext(BlockDriverState *bs) <nl>      } <nl>  } <nl>   <nl> -static void report_unsupported(BlockDriverState *bs, const char *fmt, ...) <nl> +static void GCC_FMT_ATTR(2, 3) report_unsupported(BlockDriverState *bs, <nl> +    const char *fmt, ...) <nl>  { <nl>      char msg[64]; <nl>      va_list ap;
@@ -332,7 +332,7 @@ static int cow_create(const char *filename, QemuOpts *opts, Error **errp) <nl>      char *image_filename = NULL; <nl>      Error *local_err = NULL; <nl>      int ret; <nl> -    BlockDriverState *cow_bs; <nl> +    BlockDriverState *cow_bs = NULL; <nl>   <nl>      /* Read out options */ <nl>      image_sectors = qemu_opt_get_size_del(opts, BLOCK_OPT_SIZE, 0) / 512; <nl> @@ -344,7 +344,6 @@ static int cow_create(const char *filename, QemuOpts *opts, Error **errp) <nl>          goto exit; <nl>      } <nl>   <nl> -    cow_bs = NULL; <nl>      ret = bdrv_open(&cow_bs, filename, NULL, NULL, <nl>                      BDRV_O_RDWR | BDRV_O_PROTOCOL, NULL, &local_err); <nl>      if (ret < 0) { <nl> @@ -383,7 +382,9 @@ static int cow_create(const char *filename, QemuOpts *opts, Error **errp) <nl>   <nl>  exit: <nl>      g_free(image_filename); <nl> -    bdrv_unref(cow_bs); <nl> +    if (cow_bs) { <nl> +        bdrv_unref(cow_bs); <nl> +    } <nl>      return ret; <nl>  } <nl>  
@@ -200,8 +200,14 @@ static uint64_t msix_pba_mmio_read(void *opaque, hwaddr addr, <nl>      return pci_get_long(dev->msix_pba + addr); <nl>  } <nl>   <nl> +static void msix_pba_mmio_write(void *opaque, hwaddr addr, <nl> +                                uint64_t val, unsigned size) <nl> +{ <nl> +} <nl> + <nl>  static const MemoryRegionOps msix_pba_mmio_ops = { <nl>      .read = msix_pba_mmio_read, <nl> +    .write = msix_pba_mmio_write, <nl>      .endianness = DEVICE_LITTLE_ENDIAN, <nl>      .valid = { <nl>          .min_access_size = 4,
@@ -31,6 +31,9 @@ static int virtio_ccw_hcall_notify(const uint64_t *args) <nl>      if (!sch || !css_subch_visible(sch)) { <nl>          return -EINVAL; <nl>      } <nl> +    if (queue >= VIRTIO_PCI_QUEUE_MAX) { <nl> +        return -EINVAL; <nl> +    } <nl>      virtio_queue_notify(virtio_ccw_get_vdev(sch), queue); <nl>      return 0; <nl>  
@@ -142,6 +142,8 @@ static uint32_t expand4[256]; <nl>  static uint16_t expand2[256]; <nl>  static uint8_t expand4to8[16]; <nl>   <nl> +static void vbe_update_vgaregs(VGACommonState *s); <nl> + <nl>  static inline bool vbe_enabled(VGACommonState *s) <nl>  { <nl>      return s->vbe_regs[VBE_DISPI_INDEX_ENABLE] & VBE_DISPI_ENABLED; <nl> @@ -484,6 +486,7 @@ void vga_ioport_write(void *opaque, uint32_t addr, uint32_t val) <nl>          printf("vga: write SR%x = 0x%02x\n", s->sr_index, val); <nl>  #endif <nl>          s->sr[s->sr_index] = val & sr_mask[s->sr_index]; <nl> +        vbe_update_vgaregs(s); <nl>          if (s->sr_index == VGA_SEQ_CLOCK_MODE) { <nl>              s->update_retrace_info(s); <nl>          } <nl> @@ -515,6 +518,7 @@ void vga_ioport_write(void *opaque, uint32_t addr, uint32_t val) <nl>          printf("vga: write GR%x = 0x%02x\n", s->gr_index, val); <nl>  #endif <nl>          s->gr[s->gr_index] = val & gr_mask[s->gr_index]; <nl> +        vbe_update_vgaregs(s); <nl>          vga_update_memory_access(s); <nl>          break; <nl>      case VGA_CRT_IM: <nl> @@ -533,10 +537,12 @@ void vga_ioport_write(void *opaque, uint32_t addr, uint32_t val) <nl>              if (s->cr_index == VGA_CRTC_OVERFLOW) { <nl>                  s->cr[VGA_CRTC_OVERFLOW] = (s->cr[VGA_CRTC_OVERFLOW] & ~0x10) | <nl>                      (val & 0x10); <nl> +                vbe_update_vgaregs(s); <nl>              } <nl>              return; <nl>          } <nl>          s->cr[s->cr_index] = val; <nl> +        vbe_update_vgaregs(s); <nl>   <nl>          switch(s->cr_index) { <nl>          case VGA_CRTC_H_TOTAL:
@@ -753,10 +753,12 @@ static void set_mac(Object *obj, Visitor *v, void *opaque, <nl>          } <nl>          mac->a[i] = strtol(str+pos, &p, 16); <nl>      } <nl> +    g_free(str); <nl>      return; <nl>   <nl>  inval: <nl>      error_set_from_qdev_prop_error(errp, EINVAL, dev, prop, str); <nl> +    g_free(str); <nl>  } <nl>   <nl>  PropertyInfo qdev_prop_macaddr = { <nl> @@ -825,7 +827,7 @@ static void set_pci_devfn(Object *obj, Visitor *v, void *opaque, <nl>      uint32_t *ptr = qdev_get_prop_ptr(dev, prop); <nl>      unsigned int slot, fn, n; <nl>      Error *local_err = NULL; <nl> -    char *str = (char *)""; <nl> +    char *str; <nl>   <nl>      if (dev->state != DEV_STATE_CREATED) { <nl>          error_set(errp, QERR_PERMISSION_DENIED); <nl> @@ -848,10 +850,12 @@ static void set_pci_devfn(Object *obj, Visitor *v, void *opaque, <nl>          goto invalid; <nl>      } <nl>      *ptr = slot << 3 | fn; <nl> +    g_free(str); <nl>      return; <nl>   <nl>  invalid: <nl>      error_set_from_qdev_prop_error(errp, EINVAL, dev, prop, str); <nl> +    g_free(str); <nl>  } <nl>   <nl>  static int print_pci_devfn(DeviceState *dev, Property *prop, char *dest, size_t len)
@@ -4603,7 +4603,7 @@ long do_sigreturn(CPUPPCState *env) <nl>  { <nl>      struct target_sigcontext *sc = NULL; <nl>      struct target_mcontext *sr = NULL; <nl> -    target_ulong sr_addr, sc_addr; <nl> +    target_ulong sr_addr = 0, sc_addr; <nl>      sigset_t blocked; <nl>      target_sigset_t set; <nl>  
@@ -195,7 +195,8 @@ static size_t send_control_msg(VirtIOSerial *vser, void *buf, size_t len) <nl>          return 0; <nl>      } <nl>   <nl> -    memcpy(elem.in_sg[0].iov_base, buf, len); <nl> +    /* TODO: detect a buffer that's too short, set NEEDS_RESET */ <nl> +    iov_from_buf(elem.in_sg, elem.in_num, 0, buf, len); <nl>   <nl>      virtqueue_push(vq, &elem, len); <nl>      virtio_notify(VIRTIO_DEVICE(vser), vq);
@@ -335,6 +335,7 @@ bool aio_poll(AioContext *ctx, bool blocking) <nl>          event = NULL; <nl>          if ((DWORD) (ret - WAIT_OBJECT_0) < count) { <nl>              event = events[ret - WAIT_OBJECT_0]; <nl> +            events[ret - WAIT_OBJECT_0] = events[--count]; <nl>          } else if (!have_select_revents) { <nl>              break; <nl>          } <nl> @@ -343,9 +344,6 @@ bool aio_poll(AioContext *ctx, bool blocking) <nl>          blocking = false; <nl>   <nl>          progress |= aio_dispatch_handlers(ctx, event); <nl> - <nl> -        /* Try again, but only call each handler once.  */ <nl> -        events[ret - WAIT_OBJECT_0] = events[--count]; <nl>      } <nl>   <nl>      progress |= timerlistgroup_run_timers(&ctx->tlg);
@@ -907,7 +907,7 @@ static void build_pci_bus_end(PCIBus *bus, void *bus_state) <nl>   <nl>              build_append_byte(notify, 0x7B); /* AndOp */ <nl>              build_append_byte(notify, 0x68); /* Arg0Op */ <nl> -            build_append_int(notify, 0x1 << i); <nl> +            build_append_int(notify, 0x1U << i); <nl>              build_append_byte(notify, 0x00); /* NullName */ <nl>              build_append_byte(notify, 0x86); /* NotifyOp */ <nl>              build_append_nameseg(notify, "S%.02X_", PCI_DEVFN(i, 0));
@@ -9946,8 +9946,10 @@ GEN_HANDLER2(slbmfee, "slbmfee", 0x1F, 0x13, 0x1C, 0x001F0001, PPC_SEGMENT_64B), <nl>  GEN_HANDLER2(slbmfev, "slbmfev", 0x1F, 0x13, 0x1A, 0x001F0001, PPC_SEGMENT_64B), <nl>  #endif <nl>  GEN_HANDLER(tlbia, 0x1F, 0x12, 0x0B, 0x03FFFC01, PPC_MEM_TLBIA), <nl> -GEN_HANDLER(tlbiel, 0x1F, 0x12, 0x08, 0x03FF0001, PPC_MEM_TLBIE), <nl> -GEN_HANDLER(tlbie, 0x1F, 0x12, 0x09, 0x03FF0001, PPC_MEM_TLBIE), <nl> +/* XXX Those instructions will need to be handled differently for <nl> + * different ISA versions */ <nl> +GEN_HANDLER(tlbiel, 0x1F, 0x12, 0x08, 0x001F0001, PPC_MEM_TLBIE), <nl> +GEN_HANDLER(tlbie, 0x1F, 0x12, 0x09, 0x001F0001, PPC_MEM_TLBIE), <nl>  GEN_HANDLER(tlbsync, 0x1F, 0x16, 0x11, 0x03FFF801, PPC_MEM_TLBSYNC), <nl>  #if defined(TARGET_PPC64) <nl>  GEN_HANDLER(slbia, 0x1F, 0x12, 0x0F, 0x03FFFC01, PPC_SLBI),
@@ -51,12 +51,8 @@ static void error_exit(int err, const char *msg) <nl>  void qemu_mutex_init(QemuMutex *mutex) <nl>  { <nl>      int err; <nl> -    pthread_mutexattr_t mutexattr; <nl>   <nl> -    pthread_mutexattr_init(&mutexattr); <nl> -    pthread_mutexattr_settype(&mutexattr, PTHREAD_MUTEX_ERRORCHECK); <nl> -    err = pthread_mutex_init(&mutex->lock, &mutexattr); <nl> -    pthread_mutexattr_destroy(&mutexattr); <nl> +    err = pthread_mutex_init(&mutex->lock, NULL); <nl>      if (err) <nl>          error_exit(err, __func__); <nl>  }
@@ -435,6 +435,11 @@ static void handle_ti(ESPState *s) <nl>  { <nl>      uint32_t dmalen, minlen; <nl>   <nl> +    if (s->dma && !s->dma_enabled) { <nl> +        s->dma_cb = handle_ti; <nl> +        return; <nl> +    } <nl> + <nl>      dmalen = s->rregs[ESP_TCLO] | (s->rregs[ESP_TCMID] << 8); <nl>      if (dmalen==0) { <nl>        dmalen=0x10000;
@@ -163,7 +163,7 @@ static int pfpu_decode_insn(MilkymistPFPUState *s) <nl>      uint32_t reg_b = (insn >> 11) & 0x7f; <nl>      uint32_t op = (insn >> 7) & 0xf; <nl>      uint32_t reg_d = insn & 0x7f; <nl> -    uint32_t r; <nl> +    uint32_t r = 0; <nl>      int latency = 0; <nl>   <nl>      switch (op) {
@@ -389,10 +389,11 @@ static void omap_disc_write(void *opaque, target_phys_addr_t addr, <nl>          s->dig.enable = (value >> 1) & 1; <nl>          s->lcd.enable = (value >> 0) & 1; <nl>          if (value & (1 << 12))			/* OVERLAY_OPTIMIZATION */ <nl> -            if (~((s->dispc.l[1].attr | s->dispc.l[2].attr) & 1)) <nl> -                 fprintf(stderr, "%s: Overlay Optimization when no overlay " <nl> -                                 "region effectively exists leads to " <nl> -                                 "unpredictable behaviour!\n", __FUNCTION__); <nl> +            if (!((s->dispc.l[1].attr | s->dispc.l[2].attr) & 1)) { <nl> +                fprintf(stderr, "%s: Overlay Optimization when no overlay " <nl> +                        "region effectively exists leads to " <nl> +                        "unpredictable behaviour!\n", __func__); <nl> +            } <nl>          if (value & (1 << 6)) {				/* GODIGITAL */ <nl>              /* XXX: Shadowed fields are: <nl>               * s->dispc.config
@@ -656,7 +656,7 @@ static void tgen_arithi(TCGContext *s, int c, int r0, <nl>         partial flags update stalls on Pentium4 and are not recommended <nl>         by current Intel optimization manuals.  */ <nl>      if (!cf && (c == ARITH_ADD || c == ARITH_SUB) && (val == 1 || val == -1)) { <nl> -        _Bool is_inc = (c == ARITH_ADD) ^ (val < 0); <nl> +        int is_inc = (c == ARITH_ADD) ^ (val < 0); <nl>          if (TCG_TARGET_REG_BITS == 64) { <nl>              /* The single-byte increment encodings are re-tasked as the <nl>                 REX prefixes.  Use the MODRM encoding.  */
@@ -25,6 +25,7 @@ <nl>  #include "sysemu/numa.h" <nl>  #include "sysemu/kvm.h" <nl>  #include "trace.h" <nl> +#include "hw/virtio/vhost.h" <nl>   <nl>  typedef struct pc_dimms_capacity { <nl>       uint64_t size; <nl> @@ -96,6 +97,12 @@ void pc_dimm_memory_plug(DeviceState *dev, MemoryHotplugState *hpms, <nl>          goto out; <nl>      } <nl>   <nl> +    if (!vhost_has_free_slot()) { <nl> +        error_setg(&local_err, "a used vhost backend has no free" <nl> +                               " memory slots left"); <nl> +        goto out; <nl> +    } <nl> + <nl>      memory_region_add_subregion(&hpms->mr, addr - hpms->base, mr); <nl>      vmstate_register_ram(mr, dev); <nl>      numa_set_mem_node_id(addr, memory_region_size(mr), dimm->node);
@@ -1008,6 +1008,10 @@ TPMVersion tpm_tis_get_tpm_version(Object *obj) <nl>  { <nl>      TPMState *s = TPM(obj); <nl>   <nl> +    if (tpm_backend_had_startup_error(s->be_driver)) { <nl> +        return TPM_VERSION_UNSPEC; <nl> +    } <nl> + <nl>      return tpm_backend_get_tpm_version(s->be_driver); <nl>  } <nl>  
@@ -600,6 +600,7 @@ static int dirty_bitmap_load_bits(QEMUFile *f, DirtyBitmapLoadState *s) <nl>          ret = qemu_get_buffer(f, buf, buf_size); <nl>          if (ret != buf_size) { <nl>              error_report("Failed to read bitmap bits"); <nl> +            g_free(buf); <nl>              return -EIO; <nl>          } <nl>  
@@ -290,6 +290,10 @@ static void virtio_blk_handle_write(VirtIOBlockReq *req, MultiReqBuffer *mrb) <nl>          virtio_blk_rw_complete(req, -EIO); <nl>          return; <nl>      } <nl> +    if (req->qiov.size % req->dev->conf->logical_block_size) { <nl> +        virtio_blk_rw_complete(req, -EIO); <nl> +        return; <nl> +    } <nl>   <nl>      if (mrb->num_writes == 32) { <nl>          virtio_submit_multiwrite(req->dev->bs, mrb); <nl> @@ -317,6 +321,10 @@ static void virtio_blk_handle_read(VirtIOBlockReq *req) <nl>          virtio_blk_rw_complete(req, -EIO); <nl>          return; <nl>      } <nl> +    if (req->qiov.size % req->dev->conf->logical_block_size) { <nl> +        virtio_blk_rw_complete(req, -EIO); <nl> +        return; <nl> +    } <nl>   <nl>      acb = bdrv_aio_readv(req->dev->bs, sector, &req->qiov, <nl>                           req->qiov.size / BDRV_SECTOR_SIZE,
@@ -204,6 +204,7 @@ static void s390_init(ram_addr_t ram_size, <nl>   <nl>          bios_filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name); <nl>          bios_size = load_image(bios_filename, qemu_get_ram_ptr(ZIPL_LOAD_ADDR)); <nl> +        qemu_free(bios_filename); <nl>   <nl>          if ((long)bios_size < 0) { <nl>              hw_error("could not load bootloader '%s'\n", bios_name);
@@ -678,6 +678,10 @@ static ssize_t gem_receive(NetClientState *nc, const uint8_t *buf, size_t size) <nl>      } else { <nl>          unsigned crc_val; <nl>   <nl> +        if (size > sizeof(rxbuf) - sizeof(crc_val)) { <nl> +            size = sizeof(rxbuf) - sizeof(crc_val); <nl> +        } <nl> +        bytes_to_copy = size; <nl>          /* The application wants the FCS field, which QEMU does not provide. <nl>           * We must try and calculate one. <nl>           */
@@ -303,11 +303,11 @@ int print_insn_lm32(bfd_vma memaddr, struct disassemble_info *info) <nl>                  } <nl>                  case 'c': { <nl>                      uint8_t csr; <nl> -                    const char *csr_name; <nl> +                    const Lm32CsrInfo *info; <nl>                      csr = (op >> 21) & 0x1f; <nl> -                    csr_name = find_csr_info(csr)->name; <nl> -                    if (csr_name) { <nl> -                        fprintf_fn(stream, "%s", csr_name); <nl> +                    info = find_csr_info(csr); <nl> +                    if (info) { <nl> +                        fprintf_fn(stream, "%s", info->name); <nl>                      } else { <nl>                          fprintf_fn(stream, "0x%x", csr); <nl>                      }
@@ -3248,6 +3248,7 @@ char *vnc_display_local_addr(const char *id) <nl>  { <nl>      VncDisplay *vs = vnc_display_find(id); <nl>   <nl> +    assert(vs); <nl>      return vnc_socket_local_addr("%s:%s", vs->lsock); <nl>  } <nl>  
@@ -268,8 +268,9 @@ static void esp_pci_dma_memory_rw(PCIESPState *pci, uint8_t *buf, int len, <nl>      /* update status registers */ <nl>      pci->dma_regs[DMA_WBC] -= len; <nl>      pci->dma_regs[DMA_WAC] += len; <nl> -    if (pci->dma_regs[DMA_WBC] == 0) <nl> +    if (pci->dma_regs[DMA_WBC] == 0) { <nl>          pci->dma_regs[DMA_STAT] |= DMA_STAT_DONE; <nl> +    } <nl>  } <nl>   <nl>  static void esp_pci_dma_memory_read(void *opaque, uint8_t *buf, int len)
@@ -224,15 +224,15 @@ DriveInfo *drive_init(QemuOpts *opts, int default_to_scsi, int *fatal_error) <nl>   <nl>      if (cyls || heads || secs) { <nl>          if (cyls < 1 || (type == IF_IDE && cyls > 16383)) { <nl> -            fprintf(stderr, "qemu: '%s' invalid physical cyls number\n", buf); <nl> +            fprintf(stderr, "qemu: invalid physical cyls number\n"); <nl>  	    return NULL; <nl>  	} <nl>          if (heads < 1 || (type == IF_IDE && heads > 16)) { <nl> -            fprintf(stderr, "qemu: '%s' invalid physical heads number\n", buf); <nl> +            fprintf(stderr, "qemu: invalid physical heads number\n"); <nl>  	    return NULL; <nl>  	} <nl>          if (secs < 1 || (type == IF_IDE && secs > 63)) { <nl> -            fprintf(stderr, "qemu: '%s' invalid physical secs number\n", buf); <nl> +            fprintf(stderr, "qemu: invalid physical secs number\n"); <nl>  	    return NULL; <nl>  	} <nl>      }
@@ -2451,6 +2451,10 @@ static bool is_zero_sectors(BlockDriverState *bs, int64_t start, <nl>      BlockDriverState *file; <nl>      int64_t res; <nl>   <nl> +    if (start + count > bs->total_sectors) { <nl> +        count = bs->total_sectors - start; <nl> +    } <nl> + <nl>      if (!count) { <nl>          return true; <nl>      } <nl> @@ -2469,6 +2473,9 @@ static coroutine_fn int qcow2_co_pwrite_zeroes(BlockDriverState *bs, <nl>      uint32_t tail = (offset + count) % s->cluster_size; <nl>   <nl>      trace_qcow2_pwrite_zeroes_start_req(qemu_coroutine_self(), offset, count); <nl> +    if (offset + count == bs->total_sectors * BDRV_SECTOR_SIZE) { <nl> +        tail = 0; <nl> +    } <nl>   <nl>      if (head || tail) { <nl>          int64_t cl_start = (offset - head) >> BDRV_SECTOR_BITS;
@@ -54,6 +54,7 @@ int main(int argc, char **argv) <nl>   <nl>          path = g_strdup_printf("eepro100/%s", models[i]); <nl>          qtest_add_data_func(path, models[i], test_device); <nl> +        g_free(path); <nl>      } <nl>   <nl>      return g_test_run();
@@ -208,7 +208,7 @@ static int parse_drive(DeviceState *dev, Property *prop, const char *str) <nl>  static int print_drive(DeviceState *dev, Property *prop, char *dest, size_t len) <nl>  { <nl>      DriveInfo **ptr = qdev_get_prop_ptr(dev, prop); <nl> -    return snprintf(dest, len, "%s", (*ptr)->id); <nl> +    return snprintf(dest, len, "%s", (*ptr) ? (*ptr)->id : "<null>"); <nl>  } <nl>   <nl>  PropertyInfo qdev_prop_drive = {
@@ -293,7 +293,7 @@ static void tmu2_start(MilkymistTMU2State *s) <nl>      cpu_physical_memory_unmap(mesh, mesh_len, 0, mesh_len); <nl>   <nl>      /* Write back the OpenGL framebuffer to the QEMU framebuffer */ <nl> -    fb_len = 2 * s->regs[R_DSTHRES] * s->regs[R_DSTVRES]; <nl> +    fb_len = 2ULL * s->regs[R_DSTHRES] * s->regs[R_DSTVRES]; <nl>      fb = cpu_physical_memory_map(s->regs[R_DSTFBUF], &fb_len, 1); <nl>      if (fb == NULL) { <nl>          glDeleteTextures(1, &texture);
@@ -1374,7 +1374,7 @@ int kvm_init(MachineClass *mc) <nl>   <nl>      ret = kvm_ioctl(s, KVM_GET_API_VERSION, 0); <nl>      if (ret < KVM_API_VERSION) { <nl> -        if (ret > 0) { <nl> +        if (ret >= 0) { <nl>              ret = -EINVAL; <nl>          } <nl>          fprintf(stderr, "kvm version too old\n"); <nl> @@ -1425,6 +1425,7 @@ int kvm_init(MachineClass *mc) <nl>      if (mc->kvm_type) { <nl>          type = mc->kvm_type(kvm_type); <nl>      } else if (kvm_type) { <nl> +        ret = -EINVAL; <nl>          fprintf(stderr, "Invalid argument kvm-type=%s\n", kvm_type); <nl>          goto err; <nl>      } <nl> @@ -1525,6 +1526,7 @@ int kvm_init(MachineClass *mc) <nl>      return 0; <nl>   <nl>  err: <nl> +    assert(ret < 0); <nl>      if (s->vmfd >= 0) { <nl>          close(s->vmfd); <nl>      }
@@ -799,7 +799,7 @@ static int rtl8139_can_receive(VLANClientState *nc) <nl>      } else { <nl>          avail = MOD2(s->RxBufferSize + s->RxBufPtr - s->RxBufAddr, <nl>                       s->RxBufferSize); <nl> -        return (avail == 0 || avail >= 1514); <nl> +        return (avail == 0 || avail >= 1514 || (s->IntrMask & RxOverflow)); <nl>      } <nl>  } <nl>  
@@ -479,7 +479,7 @@ static const QEMUFileOps socket_write_ops = { <nl>   <nl>  QEMUFile *qemu_fopen_socket(int fd, const char *mode) <nl>  { <nl> -    QEMUFileSocket *s = g_malloc0(sizeof(QEMUFileSocket)); <nl> +    QEMUFileSocket *s; <nl>   <nl>      if (mode == NULL || <nl>          (mode[0] != 'r' && mode[0] != 'w') || <nl> @@ -488,6 +488,7 @@ QEMUFile *qemu_fopen_socket(int fd, const char *mode) <nl>          return NULL; <nl>      } <nl>   <nl> +    s = g_malloc0(sizeof(QEMUFileSocket)); <nl>      s->fd = fd; <nl>      if (mode[0] == 'w') { <nl>          qemu_set_block(s->fd);
@@ -56,7 +56,7 @@ static int hda_codec_dev_init(DeviceState *qdev, DeviceInfo *base) <nl>      if (dev->cad == -1) { <nl>          dev->cad = bus->next_cad; <nl>      } <nl> -    if (dev->cad > 15) <nl> +    if (dev->cad >= 15) <nl>          return -1; <nl>      bus->next_cad = dev->cad + 1; <nl>      return info->init(dev); <nl> @@ -643,15 +643,15 @@ static const struct IntelHDAReg regtab[] = { <nl>      [ ICH6_REG_WAKEEN ] = { <nl>          .name     = "WAKEEN", <nl>          .size     = 2, <nl> -        .wmask    = 0x3fff, <nl> +        .wmask    = 0x7fff, <nl>          .offset   = offsetof(IntelHDAState, wake_en), <nl>          .whandler = intel_hda_set_wake_en, <nl>      }, <nl>      [ ICH6_REG_STATESTS ] = { <nl>          .name     = "STATESTS", <nl>          .size     = 2, <nl> -        .wmask    = 0x3fff, <nl> -        .wclear   = 0x3fff, <nl> +        .wmask    = 0x7fff, <nl> +        .wclear   = 0x7fff, <nl>          .offset   = offsetof(IntelHDAState, state_sts), <nl>          .whandler = intel_hda_set_state_sts, <nl>      },
@@ -66,6 +66,12 @@ static QObject *qmp_output_pop(QmpOutputVisitor *qov) <nl>  static QObject *qmp_output_first(QmpOutputVisitor *qov) <nl>  { <nl>      QStackEntry *e = QTAILQ_LAST(&qov->stack, QStack); <nl> + <nl> +    /* FIXME - find a better way to deal with NULL values */ <nl> +    if (!e) { <nl> +        return NULL; <nl> +    } <nl> + <nl>      return e->value; <nl>  } <nl>  
@@ -2968,8 +2968,7 @@ vvfat_co_pwritev(BlockDriverState *bs, uint64_t offset, uint64_t bytes, <nl>  static int64_t coroutine_fn vvfat_co_get_block_status(BlockDriverState *bs, <nl>  	int64_t sector_num, int nb_sectors, int *n, BlockDriverState **file) <nl>  { <nl> -    BDRVVVFATState* s = bs->opaque; <nl> -    *n = s->sector_count - sector_num; <nl> +    *n = bs->total_sectors - sector_num; <nl>      if (*n > nb_sectors) { <nl>          *n = nb_sectors; <nl>      } else if (*n < 0) {
@@ -739,7 +739,12 @@ static int proxy_socket(const char *path, uid_t uid, gid_t gid) <nl>          return -1; <nl>      } <nl>   <nl> -    g_assert(strlen(path) < sizeof(proxy.sun_path)); <nl> +    if (strlen(path) >= sizeof(proxy.sun_path)) { <nl> +        do_log(LOG_CRIT, "UNIX domain socket path exceeds %zu characters\n", <nl> +               sizeof(proxy.sun_path)); <nl> +        return -1; <nl> +    } <nl> + <nl>      sock = socket(AF_UNIX, SOCK_STREAM, 0); <nl>      if (sock < 0) { <nl>          do_perror("socket");
@@ -87,7 +87,7 @@ static void balloon_stats_destroy_timer(VirtIOBalloon *s) <nl>      } <nl>  } <nl>   <nl> -static void balloon_stats_change_timer(VirtIOBalloon *s, int secs) <nl> +static void balloon_stats_change_timer(VirtIOBalloon *s, int64_t secs) <nl>  { <nl>      timer_mod(s->stats_timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL) + secs * 1000); <nl>  } <nl> @@ -170,6 +170,11 @@ static void balloon_stats_set_poll_interval(Object *obj, struct Visitor *v, <nl>          return; <nl>      } <nl>   <nl> +    if (value > UINT_MAX) { <nl> +        error_setg(errp, "timer value is too big"); <nl> +        return; <nl> +    } <nl> + <nl>      if (value == s->stats_poll_interval) { <nl>          return; <nl>      }
@@ -116,7 +116,7 @@ static int lance_init(SysBusDevice *dev) <nl>      SysBusPCNetState *d = FROM_SYSBUS(SysBusPCNetState, dev); <nl>      PCNetState *s = &d->state; <nl>   <nl> -    memory_region_init_io(&s->mmio, &lance_mem_ops, s, "lance-mmio", 4); <nl> +    memory_region_init_io(&s->mmio, &lance_mem_ops, d, "lance-mmio", 4); <nl>   <nl>      qdev_init_gpio_in(&dev->qdev, parent_lance_reset, 1); <nl>  
@@ -3570,7 +3570,7 @@ static int img_bench(int argc, char **argv) <nl>      BlockBackend *blk = NULL; <nl>      BenchData data = {}; <nl>      int flags = 0; <nl> -    bool writethrough; <nl> +    bool writethrough = false; <nl>      struct timeval t1, t2; <nl>      int i; <nl>  
@@ -1871,6 +1871,7 @@ static void gen_rot_rm_im(DisasContext *s, int ot, int op1, int op2, <nl>          if (is_right) { <nl>              tcg_gen_shri_tl(cpu_cc_src2, cpu_T[0], mask - 1); <nl>              tcg_gen_shri_tl(cpu_cc_dst, cpu_T[0], mask); <nl> +            tcg_gen_andi_tl(cpu_cc_dst, cpu_cc_dst, 1); <nl>          } else { <nl>              tcg_gen_shri_tl(cpu_cc_src2, cpu_T[0], mask); <nl>              tcg_gen_andi_tl(cpu_cc_dst, cpu_T[0], 1);
@@ -221,15 +221,17 @@ <nl>  #define CIRRUS_HOOK_NOT_HANDLED 0 <nl>  #define CIRRUS_HOOK_HANDLED 1 <nl>   <nl> +#define ABS(a) ((signed)(a) > 0 ? a : -a) <nl> + <nl>  #define BLTUNSAFE(s) \ <nl>      ( \ <nl>          ( /* check dst is within bounds */ \ <nl> -            (s)->cirrus_blt_height * (s)->cirrus_blt_dstpitch \ <nl> +            (s)->cirrus_blt_height * ABS((s)->cirrus_blt_dstpitch) \ <nl>                  + ((s)->cirrus_blt_dstaddr & (s)->cirrus_addr_mask) > \ <nl>                      (s)->vram_size \ <nl>          ) || \ <nl>          ( /* check src is within bounds */ \ <nl> -            (s)->cirrus_blt_height * (s)->cirrus_blt_srcpitch \ <nl> +            (s)->cirrus_blt_height * ABS((s)->cirrus_blt_srcpitch) \ <nl>                  + ((s)->cirrus_blt_srcaddr & (s)->cirrus_addr_mask) > \ <nl>                      (s)->vram_size \ <nl>          ) \
@@ -1380,6 +1380,7 @@ static TRBCCode xhci_disable_ep(XHCIState *xhci, unsigned int slotid, <nl>  { <nl>      XHCISlot *slot; <nl>      XHCIEPContext *epctx; <nl> +    int i; <nl>   <nl>      trace_usb_xhci_ep_disable(slotid, epid); <nl>      assert(slotid >= 1 && slotid <= xhci->numslots); <nl> @@ -1400,6 +1401,10 @@ static TRBCCode xhci_disable_ep(XHCIState *xhci, unsigned int slotid, <nl>          xhci_free_streams(epctx); <nl>      } <nl>   <nl> +    for (i = 0; i < ARRAY_SIZE(epctx->transfers); i++) { <nl> +        usb_packet_cleanup(&epctx->transfers[i].packet); <nl> +    } <nl> + <nl>      xhci_set_ep_state(xhci, epctx, NULL, EP_DISABLED); <nl>   <nl>      timer_free(epctx->kick_timer);
@@ -80,6 +80,7 @@ static int qemu_egl_rendernode_open(const char *rendernode) <nl>  int egl_rendernode_init(const char *rendernode) <nl>  { <nl>      qemu_egl_rn_fd = -1; <nl> +    int rc; <nl>   <nl>      qemu_egl_rn_fd = qemu_egl_rendernode_open(rendernode); <nl>      if (qemu_egl_rn_fd == -1) { <nl> @@ -93,7 +94,11 @@ int egl_rendernode_init(const char *rendernode) <nl>          goto err; <nl>      } <nl>   <nl> -    qemu_egl_init_dpy_mesa((EGLNativeDisplayType)qemu_egl_rn_gbm_dev); <nl> +    rc = qemu_egl_init_dpy_mesa((EGLNativeDisplayType)qemu_egl_rn_gbm_dev); <nl> +    if (rc != 0) { <nl> +        /* qemu_egl_init_dpy_mesa reports error */ <nl> +        goto err; <nl> +    } <nl>   <nl>      if (!epoxy_has_egl_extension(qemu_egl_display, <nl>                                   "EGL_KHR_surfaceless_context")) {
@@ -100,7 +100,7 @@ struct CompatProperty { <nl>   <nl>  DeviceState *qdev_create(BusState *bus, const char *name); <nl>  DeviceState *qdev_device_add(QemuOpts *opts); <nl> -int qdev_init(DeviceState *dev); <nl> +int qdev_init(DeviceState *dev) __attribute__((warn_unused_result)); <nl>  void qdev_init_nofail(DeviceState *dev); <nl>  int qdev_unplug(DeviceState *dev); <nl>  void qdev_free(DeviceState *dev);
@@ -2207,8 +2207,6 @@ static void gen_add_A0_ds_seg(DisasContext *s) <nl>      if (s->override >= 0) { <nl>          override = s->override; <nl>          must_add_seg = 1; <nl> -    } else { <nl> -        override = R_DS; <nl>      } <nl>      if (must_add_seg) { <nl>  #ifdef TARGET_X86_64
@@ -6203,7 +6203,7 @@ static opcode_t opcodes[] = { <nl>  GEN_HANDLER(invalid, 0x00, 0x00, 0x00, 0xFFFFFFFF, PPC_NONE), <nl>  GEN_HANDLER(cmp, 0x1F, 0x00, 0x00, 0x00400000, PPC_INTEGER), <nl>  GEN_HANDLER(cmpi, 0x0B, 0xFF, 0xFF, 0x00400000, PPC_INTEGER), <nl> -GEN_HANDLER(cmpl, 0x1F, 0x00, 0x01, 0x00400000, PPC_INTEGER), <nl> +GEN_HANDLER(cmpl, 0x1F, 0x00, 0x01, 0x00400001, PPC_INTEGER), <nl>  GEN_HANDLER(cmpli, 0x0A, 0xFF, 0xFF, 0x00400000, PPC_INTEGER), <nl>  #if defined(TARGET_PPC64) <nl>  GEN_HANDLER_E(cmpeqb, 0x1F, 0x00, 0x07, 0x00600000, PPC_NONE, PPC2_ISA300), <nl> @@ -6297,7 +6297,7 @@ GEN_HANDLER(b, 0x12, 0xFF, 0xFF, 0x00000000, PPC_FLOW), <nl>  GEN_HANDLER(bc, 0x10, 0xFF, 0xFF, 0x00000000, PPC_FLOW), <nl>  GEN_HANDLER(bcctr, 0x13, 0x10, 0x10, 0x00000000, PPC_FLOW), <nl>  GEN_HANDLER(bclr, 0x13, 0x10, 0x00, 0x00000000, PPC_FLOW), <nl> -GEN_HANDLER_E(bctar, 0x13, 0x10, 0x11, 0, PPC_NONE, PPC2_BCTAR_ISA207), <nl> +GEN_HANDLER_E(bctar, 0x13, 0x10, 0x11, 0x0000E000, PPC_NONE, PPC2_BCTAR_ISA207), <nl>  GEN_HANDLER(mcrf, 0x13, 0x00, 0xFF, 0x00000001, PPC_INTEGER), <nl>  GEN_HANDLER(rfi, 0x13, 0x12, 0x01, 0x03FF8001, PPC_FLOW), <nl>  #if defined(TARGET_PPC64)
@@ -1464,7 +1464,7 @@ static always_inline int translate_one (DisasContext *ctx, uint32_t insn) <nl>              break; <nl>          case 0x2C: <nl>              /* XXX: incorrect */ <nl> -            if (fn11 == 0x2AC) { <nl> +            if (fn11 == 0x2AC || fn11 == 0x6AC) { <nl>                  /* CVTST */ <nl>                  gen_farith2(&helper_cvtst, rb, rc); <nl>              } else {
@@ -1103,7 +1103,7 @@ const struct SCSISense sense_code_NO_MEDIUM = { <nl>   <nl>  /* LUN not ready, medium removal prevented */ <nl>  const struct SCSISense sense_code_NOT_READY_REMOVAL_PREVENTED = { <nl> -    .key = NOT_READY, .asc = 0x53, .ascq = 0x00 <nl> +    .key = NOT_READY, .asc = 0x53, .ascq = 0x02 <nl>  }; <nl>   <nl>  /* Hardware error, internal target failure */ <nl> @@ -1153,7 +1153,7 @@ const struct SCSISense sense_code_INCOMPATIBLE_FORMAT = { <nl>   <nl>  /* Illegal request, medium removal prevented */ <nl>  const struct SCSISense sense_code_ILLEGAL_REQ_REMOVAL_PREVENTED = { <nl> -    .key = ILLEGAL_REQUEST, .asc = 0x53, .ascq = 0x00 <nl> +    .key = ILLEGAL_REQUEST, .asc = 0x53, .ascq = 0x02 <nl>  }; <nl>   <nl>  /* Command aborted, I/O process terminated */
@@ -865,7 +865,7 @@ static void qemu_cpu_kick_thread(CPUState *cpu) <nl>          CONTEXT tcgContext; <nl>   <nl>          if (SuspendThread(cpu->hThread) == (DWORD)-1) { <nl> -            fprintf(stderr, "qemu:%s: GetLastError:%d\n", __func__, <nl> +            fprintf(stderr, "qemu:%s: GetLastError:%lu\n", __func__, <nl>                      GetLastError()); <nl>              exit(1); <nl>          } <nl> @@ -881,7 +881,7 @@ static void qemu_cpu_kick_thread(CPUState *cpu) <nl>          cpu_signal(0); <nl>   <nl>          if (ResumeThread(cpu->hThread) == (DWORD)-1) { <nl> -            fprintf(stderr, "qemu:%s: GetLastError:%d\n", __func__, <nl> +            fprintf(stderr, "qemu:%s: GetLastError:%lu\n", __func__, <nl>                      GetLastError()); <nl>              exit(1); <nl>          }
@@ -370,11 +370,16 @@ static int net_connect(struct XenDevice *xendev) <nl>                                            netdev->xendev.dom, <nl>                                            netdev->tx_ring_ref, <nl>                                            PROT_READ | PROT_WRITE); <nl> +    if (!netdev->txs) { <nl> +        return -1; <nl> +    } <nl>      netdev->rxs = xc_gnttab_map_grant_ref(netdev->xendev.gnttabdev, <nl>                                            netdev->xendev.dom, <nl>                                            netdev->rx_ring_ref, <nl>                                            PROT_READ | PROT_WRITE); <nl> -    if (!netdev->txs || !netdev->rxs) { <nl> +    if (!netdev->rxs) { <nl> +        xc_gnttab_munmap(netdev->xendev.gnttabdev, netdev->txs, 1); <nl> +        netdev->txs = NULL; <nl>          return -1; <nl>      } <nl>      BACK_RING_INIT(&netdev->tx_ring, netdev->txs, XC_PAGE_SIZE);
@@ -589,6 +589,7 @@ static int blk_send_response_one(struct ioreq *ioreq) <nl>          break; <nl>      default: <nl>          dst = NULL; <nl> +        return 0; <nl>      } <nl>      memcpy(dst, &resp, sizeof(resp)); <nl>      blkdev->rings.common.rsp_prod_pvt++;
@@ -129,7 +129,8 @@ create_iovec(QEMUIOVector *qiov, char **argv, int nr_iov, int pattern) <nl>  { <nl>  	size_t *sizes = calloc(nr_iov, sizeof(size_t)); <nl>  	size_t count = 0; <nl> -	void *buf, *p; <nl> +	void *buf = NULL; <nl> +	void *p; <nl>  	int i; <nl>   <nl>  	for (i = 0; i < nr_iov; i++) { <nl> @@ -139,19 +140,19 @@ create_iovec(QEMUIOVector *qiov, char **argv, int nr_iov, int pattern) <nl>  		len = cvtnum(arg); <nl>  		if (len < 0) { <nl>  			printf("non-numeric length argument -- %s\n", arg); <nl> -			return NULL; <nl> +			goto fail; <nl>  		} <nl>   <nl>  		/* should be SIZE_T_MAX, but that doesn't exist */ <nl>  		if (len > UINT_MAX) { <nl>  			printf("too large length argument -- %s\n", arg); <nl> -			return NULL; <nl> +			goto fail; <nl>  		} <nl>   <nl>  		if (len & 0x1ff) { <nl>  			printf("length argument %lld is not sector aligned\n", <nl>  				len); <nl> -			return NULL; <nl> +			goto fail; <nl>  		} <nl>   <nl>  		sizes[i] = len; <nl> @@ -167,6 +168,7 @@ create_iovec(QEMUIOVector *qiov, char **argv, int nr_iov, int pattern) <nl>  		p += sizes[i]; <nl>  	} <nl>   <nl> +fail: <nl>  	free(sizes); <nl>  	return buf; <nl>  }
@@ -180,7 +180,7 @@ static inline int kvmppc_remove_spapr_tce(void *table, int pfd, <nl>   <nl>  static inline int kvmppc_reset_htab(int shift_hint) <nl>  { <nl> -    return -1; <nl> +    return 0; <nl>  } <nl>   <nl>  static inline uint64_t kvmppc_rma_size(uint64_t current_size,
@@ -637,9 +637,6 @@ static int qcow2_open(BlockDriverState *bs, QDict *options, int flags, <nl>          goto fail; <nl>      } <nl>   <nl> -    s->snapshots_offset = header.snapshots_offset; <nl> -    s->nb_snapshots = header.nb_snapshots; <nl> - <nl>      /* read the level 1 table */ <nl>      if (header.l1_size > 0x2000000) { <nl>          /* 32 MB L1 table is enough for 2 PB images at 64k cluster size <nl> @@ -734,6 +731,10 @@ static int qcow2_open(BlockDriverState *bs, QDict *options, int flags, <nl>          bs->backing_file[len] = '\0'; <nl>      } <nl>   <nl> +    /* Internal snapshots */ <nl> +    s->snapshots_offset = header.snapshots_offset; <nl> +    s->nb_snapshots = header.nb_snapshots; <nl> + <nl>      ret = qcow2_read_snapshots(bs); <nl>      if (ret < 0) { <nl>          error_setg_errno(errp, -ret, "Could not read snapshots");
@@ -1443,15 +1443,17 @@ void gdb_exit(CPUArchState *env, int code) <nl>    if (gdbserver_fd < 0 || s->fd < 0) { <nl>        return; <nl>    } <nl> +#else <nl> +  if (!s->chr) { <nl> +      return; <nl> +  } <nl>  #endif <nl>   <nl>    snprintf(buf, sizeof(buf), "W%02x", (uint8_t)code); <nl>    put_packet(s, buf); <nl>   <nl>  #ifndef CONFIG_USER_ONLY <nl> -  if (s->chr) { <nl> -      qemu_chr_delete(s->chr); <nl> -  } <nl> +  qemu_chr_delete(s->chr); <nl>  #endif <nl>  } <nl>  
@@ -616,7 +616,7 @@ static int kvm_virtio_pci_vq_vector_unmask(VirtIOPCIProxy *proxy, <nl>      VirtQueue *vq = virtio_get_queue(proxy->vdev, queue_no); <nl>      EventNotifier *n = virtio_queue_get_guest_notifier(vq); <nl>      VirtIOIRQFD *irqfd = &proxy->vector_irqfd[vector]; <nl> -    int ret; <nl> +    int ret = 0; <nl>   <nl>      if (irqfd->msg.data != msg.data || irqfd->msg.address != msg.address) { <nl>          ret = kvm_irqchip_update_msi_route(kvm_state, irqfd->virq, msg);
@@ -977,7 +977,7 @@ static uint64_t virtio_pci_common_read(void *opaque, hwaddr addr, <nl>          val = proxy->gfselect; <nl>          break; <nl>      case VIRTIO_PCI_COMMON_GF: <nl> -        if (proxy->gfselect <= ARRAY_SIZE(proxy->guest_features)) { <nl> +        if (proxy->gfselect < ARRAY_SIZE(proxy->guest_features)) { <nl>              val = proxy->guest_features[proxy->gfselect]; <nl>          } <nl>          break; <nl> @@ -1052,7 +1052,7 @@ static void virtio_pci_common_write(void *opaque, hwaddr addr, <nl>          proxy->gfselect = val; <nl>          break; <nl>      case VIRTIO_PCI_COMMON_GF: <nl> -        if (proxy->gfselect <= ARRAY_SIZE(proxy->guest_features)) { <nl> +        if (proxy->gfselect < ARRAY_SIZE(proxy->guest_features)) { <nl>              proxy->guest_features[proxy->gfselect] = val; <nl>              virtio_set_features(vdev, <nl>                                  (((uint64_t)proxy->guest_features[1]) << 32) |
@@ -2266,6 +2266,7 @@ void qmp_block_job_complete(const char *device, Error **errp) <nl>  void qmp_blockdev_add(BlockdevOptions *options, Error **errp) <nl>  { <nl>      QmpOutputVisitor *ov = qmp_output_visitor_new(); <nl> +    DriveInfo *dinfo; <nl>      QObject *obj; <nl>      QDict *qdict; <nl>      Error *local_err = NULL; <nl> @@ -2301,12 +2302,18 @@ void qmp_blockdev_add(BlockdevOptions *options, Error **errp) <nl>   <nl>      qdict_flatten(qdict); <nl>   <nl> -    blockdev_init(NULL, qdict, &local_err); <nl> +    dinfo = blockdev_init(NULL, qdict, &local_err); <nl>      if (local_err) { <nl>          error_propagate(errp, local_err); <nl>          goto fail; <nl>      } <nl>   <nl> +    if (bdrv_key_required(dinfo->bdrv)) { <nl> +        drive_uninit(dinfo); <nl> +        error_setg(errp, "blockdev-add doesn't support encrypted devices"); <nl> +        goto fail; <nl> +    } <nl> + <nl>  fail: <nl>      qmp_output_visitor_cleanup(ov); <nl>  }
@@ -20,9 +20,15 @@ <nl>  #define MAX_TOKEN_COUNT (2ULL << 20) <nl>  #define MAX_NESTING (1ULL << 10) <nl>   <nl> +static void json_message_free_token(void *token, void *opaque) <nl> +{ <nl> +    g_free(token); <nl> +} <nl> + <nl>  static void json_message_free_tokens(JSONMessageParser *parser) <nl>  { <nl>      if (parser->tokens) { <nl> +        g_queue_foreach(parser->tokens, json_message_free_token, NULL); <nl>          g_queue_free(parser->tokens); <nl>          parser->tokens = NULL; <nl>      }
@@ -2701,7 +2701,7 @@ static bool scsi_block_is_passthrough(SCSIDiskState *s, uint8_t *buf) <nl>           * for the number of logical blocks specified in the length <nl>           * field).  For other modes, do not use scatter/gather operation. <nl>           */ <nl> -        if ((buf[1] & 6) != 2) { <nl> +        if ((buf[1] & 6) == 2) { <nl>              return false; <nl>          } <nl>          break;
@@ -87,7 +87,7 @@ typedef struct IVShmemState { <nl>       */ <nl>      MemoryRegion bar; <nl>      MemoryRegion ivshmem; <nl> -    uint64_t ivshmem_size; /* size of shared memory region */ <nl> +    size_t ivshmem_size; /* size of shared memory region */ <nl>      uint32_t ivshmem_64bit; <nl>   <nl>      Peer *peers; <nl> @@ -361,7 +361,7 @@ static int check_shm_size(IVShmemState *s, int fd, Error **errp) <nl>   <nl>      if (s->ivshmem_size > buf.st_size) { <nl>          error_setg(errp, "Requested memory size greater" <nl> -                   " than shared object size (%" PRIu64 " > %" PRIu64")", <nl> +                   " than shared object size (%zu > %" PRIu64")", <nl>                     s->ivshmem_size, (uint64_t)buf.st_size); <nl>          return -1; <nl>      } else { <nl> @@ -865,7 +865,8 @@ static void pci_ivshmem_realize(PCIDevice *dev, Error **errp) <nl>      } else { <nl>          char *end; <nl>          int64_t size = qemu_strtosz(s->sizearg, &end); <nl> -        if (size < 0 || *end != '\0' || !is_power_of_2(size)) { <nl> +        if (size < 0 || (size_t)size != size || *end != '\0' <nl> +            || !is_power_of_2(size)) { <nl>              error_setg(errp, "Invalid size %s", s->sizearg); <nl>              return; <nl>          }
@@ -2918,6 +2918,7 @@ out: <nl>      g_free(dummy); <nl>      if (err) { <nl>          qerror_report_err(err); <nl> +        error_free(err); <nl>          return -1; <nl>      } <nl>      return 0;
@@ -2102,7 +2102,9 @@ typedef struct { <nl>      DebugFrameFDE fde; <nl>  } DebugFrame; <nl>   <nl> -#if TCG_TARGET_REG_BITS == 64 <nl> +#if !defined(__ELF__) <nl> +    /* Host machine without ELF. */ <nl> +#elif TCG_TARGET_REG_BITS == 64 <nl>  #define ELF_HOST_MACHINE EM_X86_64 <nl>  static DebugFrame debug_frame = { <nl>      .cie.len = sizeof(DebugFrameCIE)-4, /* length after .len member */ <nl> @@ -2156,6 +2158,7 @@ static DebugFrame debug_frame = { <nl>  }; <nl>  #endif <nl>   <nl> +#if defined(ELF_HOST_MACHINE) <nl>  void tcg_register_jit(void *buf, size_t buf_size) <nl>  { <nl>      /* We're expecting a 2 byte uleb128 encoded value.  */ <nl> @@ -2166,3 +2169,4 @@ void tcg_register_jit(void *buf, size_t buf_size) <nl>   <nl>      tcg_register_jit_int(buf, buf_size, &debug_frame, sizeof(debug_frame)); <nl>  } <nl> +#endif
@@ -1638,6 +1638,12 @@ static const VMStateDescription *vmstate_get_subsection(const VMStateSubsection <nl>  static int vmstate_subsection_load(QEMUFile *f, const VMStateDescription *vmsd, <nl>                                     void *opaque) <nl>  { <nl> +    const VMStateSubsection *sub = vmsd->subsections; <nl> + <nl> +    if (!sub || !sub->needed) { <nl> +        return 0; <nl> +    } <nl> + <nl>      while (qemu_peek_byte(f) == QEMU_VM_SUBSECTION) { <nl>          char idstr[256]; <nl>          int ret; <nl> @@ -1650,10 +1656,11 @@ static int vmstate_subsection_load(QEMUFile *f, const VMStateDescription *vmsd, <nl>          idstr[len] = 0; <nl>          version_id = qemu_get_be32(f); <nl>   <nl> -        sub_vmsd = vmstate_get_subsection(vmsd->subsections, idstr); <nl> +        sub_vmsd = vmstate_get_subsection(sub, idstr); <nl>          if (sub_vmsd == NULL) { <nl>              return -ENOENT; <nl>          } <nl> +        assert(!sub_vmsd->subsections); <nl>          ret = vmstate_load_state(f, sub_vmsd, opaque, version_id); <nl>          if (ret) { <nl>              return ret; <nl> @@ -1677,6 +1684,7 @@ static void vmstate_subsection_save(QEMUFile *f, const VMStateDescription *vmsd, <nl>              qemu_put_byte(f, len); <nl>              qemu_put_buffer(f, (uint8_t *)vmsd->name, len); <nl>              qemu_put_be32(f, vmsd->version_id); <nl> +            assert(!vmsd->subsections); <nl>              vmstate_save_state(f, vmsd, opaque); <nl>          } <nl>          sub++;
@@ -419,6 +419,11 @@ void qmp_migrate(const char *uri, bool has_blk, bool blk, <nl>          return; <nl>      } <nl>   <nl> +    if (runstate_check(RUN_STATE_INMIGRATE)) { <nl> +        error_setg(errp, "Guest is waiting for an incoming migration"); <nl> +        return; <nl> +    } <nl> + <nl>      if (qemu_savevm_state_blocked(errp)) { <nl>          return; <nl>      }
@@ -124,8 +124,8 @@ static uint64_t xscom_read(void *opaque, hwaddr addr, unsigned width) <nl>          goto complete; <nl>      } <nl>   <nl> -    val = address_space_ldq(&chip->xscom_as, pcba << 3, MEMTXATTRS_UNSPECIFIED, <nl> -                            &result); <nl> +    val = address_space_ldq(&chip->xscom_as, (uint64_t) pcba << 3, <nl> +                            MEMTXATTRS_UNSPECIFIED, &result); <nl>      if (result != MEMTX_OK) { <nl>          qemu_log_mask(LOG_GUEST_ERROR, "XSCOM read failed at @0x%" <nl>                        HWADDR_PRIx " pcba=0x%08x\n", addr, pcba); <nl> @@ -150,8 +150,8 @@ static void xscom_write(void *opaque, hwaddr addr, uint64_t val, <nl>          goto complete; <nl>      } <nl>   <nl> -    address_space_stq(&chip->xscom_as, pcba << 3, val, MEMTXATTRS_UNSPECIFIED, <nl> -                      &result); <nl> +    address_space_stq(&chip->xscom_as, (uint64_t) pcba << 3, val, <nl> +                      MEMTXATTRS_UNSPECIFIED, &result); <nl>      if (result != MEMTX_OK) { <nl>          qemu_log_mask(LOG_GUEST_ERROR, "XSCOM write failed at @0x%" <nl>                        HWADDR_PRIx " pcba=0x%08x data=0x%" PRIx64 "\n",
@@ -100,7 +100,14 @@ static int stdio_put_buffer(void *opaque, const uint8_t *buf, int64_t pos, <nl>                              int size) <nl>  { <nl>      QEMUFileStdio *s = opaque; <nl> -    return fwrite(buf, 1, size, s->stdio_file); <nl> +    int res; <nl> + <nl> +    res = fwrite(buf, 1, size, s->stdio_file); <nl> + <nl> +    if (res != size) { <nl> +        return -EIO;	/* fake errno value */ <nl> +    } <nl> +    return res; <nl>  } <nl>   <nl>  static int stdio_get_buffer(void *opaque, uint8_t *buf, int64_t pos, int size)
@@ -743,6 +743,7 @@ static void assign_failed_examine(AssignedDevice *dev) <nl>          goto fail; <nl>      } <nl>   <nl> +    driver[r] = 0; <nl>      ns = strrchr(driver, '/'); <nl>      if (!ns) { <nl>          goto fail;
@@ -65,10 +65,9 @@ void net_tx_pkt_init(struct NetTxPkt **pkt, PCIDevice *pci_dev, <nl>   <nl>      p->pci_dev = pci_dev; <nl>   <nl> -    p->vec = g_malloc((sizeof *p->vec) * <nl> -        (max_frags + NET_TX_PKT_PL_START_FRAG)); <nl> +    p->vec = g_new(struct iovec, max_frags + NET_TX_PKT_PL_START_FRAG); <nl>   <nl> -    p->raw = g_malloc((sizeof *p->raw) * max_frags); <nl> +    p->raw = g_new(struct iovec, max_frags); <nl>   <nl>      p->max_payload_frags = max_frags; <nl>      p->max_raw_frags = max_frags;
@@ -708,7 +708,7 @@ static ssize_t nc_sendv_compat(NetClientState *nc, const struct iovec *iov, <nl>          offset = iov[0].iov_len; <nl>      } else { <nl>          buffer = buf; <nl> -        offset = iov_to_buf(iov, iovcnt, 0, buffer, sizeof(buffer)); <nl> +        offset = iov_to_buf(iov, iovcnt, 0, buf, sizeof(buf)); <nl>      } <nl>   <nl>      if (flags & QEMU_NET_PACKET_FLAG_RAW && nc->info->receive_raw) {
@@ -233,7 +233,7 @@ static void assign_storage(SCLPDevice *sclp, SCCB *sccb) <nl>          sccb->h.response_code = cpu_to_be16(SCLP_RC_INVALID_SCLP_COMMAND); <nl>          return; <nl>      } <nl> -    assign_addr = (assign_info->rn - 1) * mhd->rzm; <nl> +    assign_addr = (be16_to_cpu(assign_info->rn) - 1) * mhd->rzm; <nl>   <nl>      if ((assign_addr % MEM_SECTION_SIZE == 0) && <nl>          (assign_addr >= mhd->padded_ram_size)) { <nl> @@ -292,7 +292,7 @@ static void unassign_storage(SCLPDevice *sclp, SCCB *sccb) <nl>          sccb->h.response_code = cpu_to_be16(SCLP_RC_INVALID_SCLP_COMMAND); <nl>          return; <nl>      } <nl> -    unassign_addr = (assign_info->rn - 1) * mhd->rzm; <nl> +    unassign_addr = (be16_to_cpu(assign_info->rn) - 1) * mhd->rzm; <nl>   <nl>      /* if the addr is a multiple of 256 MB */ <nl>      if ((unassign_addr % MEM_SECTION_SIZE == 0) &&
@@ -379,7 +379,8 @@ static int coroutine_fn copy_sectors(BlockDriverState *bs, <nl>      BLKDBG_EVENT(bs->file, BLKDBG_COW_READ); <nl>   <nl>      if (!bs->drv) { <nl> -        return -ENOMEDIUM; <nl> +        ret = -ENOMEDIUM; <nl> +        goto out; <nl>      } <nl>   <nl>      /* Call .bdrv_co_readv() directly instead of using the public block-layer
@@ -64,8 +64,7 @@ static void json_message_process_token(JSONLexer *lexer, QString *token, JSONTok <nl>           parser->bracket_count == 0)) { <nl>          goto out_emit; <nl>      } else if (parser->token_size > MAX_TOKEN_SIZE || <nl> -               parser->bracket_count > MAX_NESTING || <nl> -               parser->brace_count > MAX_NESTING) { <nl> +               parser->bracket_count + parser->brace_count > MAX_NESTING) { <nl>          /* Security consideration, we limit total memory allocated per object <nl>           * and the maximum recursion depth that a message can force. <nl>           */
@@ -210,6 +210,7 @@ void aio_set_fd_handler(AioContext *ctx, <nl>  { <nl>      AioHandler *node; <nl>      bool is_new = false; <nl> +    bool deleted = false; <nl>   <nl>      node = find_aio_handler(ctx, fd); <nl>   <nl> @@ -228,7 +229,7 @@ void aio_set_fd_handler(AioContext *ctx, <nl>                   * releasing the walking_handlers lock. <nl>                   */ <nl>                  QLIST_REMOVE(node, node); <nl> -                g_free(node); <nl> +                deleted = true; <nl>              } <nl>          } <nl>      } else { <nl> @@ -253,6 +254,9 @@ void aio_set_fd_handler(AioContext *ctx, <nl>   <nl>      aio_epoll_update(ctx, node, is_new); <nl>      aio_notify(ctx); <nl> +    if (deleted) { <nl> +        g_free(node); <nl> +    } <nl>  } <nl>   <nl>  void aio_set_event_notifier(AioContext *ctx,
@@ -747,9 +747,9 @@ int bdrv_pwrite_sync(BlockDriverState *bs, int64_t offset, <nl>          return ret; <nl>      } <nl>   <nl> -    /* No flush needed for cache modes that already do it */ <nl> -    if (bs->enable_write_cache) { <nl> -        bdrv_flush(bs); <nl> +    ret = bdrv_flush(bs); <nl> +    if (ret < 0) { <nl> +        return ret; <nl>      } <nl>   <nl>      return 0;
@@ -1780,7 +1780,9 @@ static void set_encodings(VncState *vs, int32_t *encodings, size_t n_encodings) <nl>              vs->tight.compression = (enc & 0x0F); <nl>              break; <nl>          case VNC_ENCODING_QUALITYLEVEL0 ... VNC_ENCODING_QUALITYLEVEL0 + 9: <nl> -            vs->tight.quality = (enc & 0x0F); <nl> +            if (vs->vd->lossy) { <nl> +                vs->tight.quality = (enc & 0x0F); <nl> +            } <nl>              break; <nl>          default: <nl>              VNC_DEBUG("Unknown encoding: %d (0x%.8x): %d\n", i, enc, enc);
@@ -200,16 +200,16 @@ static void rxfilter_notify(NetClientState *nc) <nl>      VirtIONet *n = qemu_get_nic_opaque(nc); <nl>   <nl>      if (nc->rxfilter_notify_enabled) { <nl> +        gchar *path = object_get_canonical_path(OBJECT(n->qdev)); <nl>          if (n->netclient_name) { <nl>              event_data = qobject_from_jsonf("{ 'name': %s, 'path': %s }", <nl> -                                    n->netclient_name, <nl> -                                    object_get_canonical_path(OBJECT(n->qdev))); <nl> +                                    n->netclient_name, path); <nl>          } else { <nl> -            event_data = qobject_from_jsonf("{ 'path': %s }", <nl> -                                    object_get_canonical_path(OBJECT(n->qdev))); <nl> +            event_data = qobject_from_jsonf("{ 'path': %s }", path); <nl>          } <nl>          monitor_protocol_event(QEVENT_NIC_RX_FILTER_CHANGED, event_data); <nl>          qobject_decref(event_data); <nl> +        g_free(path); <nl>   <nl>          /* disable event notification to avoid events flooding */ <nl>          nc->rxfilter_notify_enabled = 0;
@@ -147,6 +147,15 @@ static void *virtio_scsi_load_request(QEMUFile *f, SCSIRequest *sreq) <nl>      qemu_get_be32s(f, &n); <nl>      assert(n < vs->conf.num_queues); <nl>      qemu_get_buffer(f, (unsigned char *)&req->elem, sizeof(req->elem)); <nl> +    /* TODO: add a way for SCSIBusInfo's load_request to fail, <nl> +     * and fail migration instead of asserting here. <nl> +     * When we do, we might be able to re-enable NDEBUG below. <nl> +     */ <nl> +#ifdef NDEBUG <nl> +#error building with NDEBUG is not supported <nl> +#endif <nl> +    assert(req->elem.in_num <= ARRAY_SIZE(req->elem.in_sg)); <nl> +    assert(req->elem.out_num <= ARRAY_SIZE(req->elem.out_sg)); <nl>      virtio_scsi_parse_req(s, vs->cmd_vqs[n], req); <nl>   <nl>      scsi_req_ref(sreq);
@@ -143,13 +143,17 @@ static void imx6_defer_clear_reset_bit(int cpuid, <nl>                                         unsigned long reset_shift) <nl>  { <nl>      struct SRCSCRResetInfo *ri; <nl> +    CPUState *cpu = arm_get_cpu_by_id(cpuid); <nl> + <nl> +    if (!cpu) { <nl> +        return; <nl> +    } <nl>   <nl>      ri = g_malloc(sizeof(struct SRCSCRResetInfo)); <nl>      ri->s = s; <nl>      ri->reset_bit = reset_shift; <nl>   <nl> -    async_run_on_cpu(arm_get_cpu_by_id(cpuid), imx6_clear_reset_bit, <nl> -                     RUN_ON_CPU_HOST_PTR(ri)); <nl> +    async_run_on_cpu(cpu, imx6_clear_reset_bit, RUN_ON_CPU_HOST_PTR(ri)); <nl>  } <nl>   <nl>  
@@ -159,7 +159,7 @@ static void shpc_interrupt_update(PCIDevice *d) <nl>      for (slot = 0; slot < shpc->nslots; ++slot) { <nl>          uint8_t event = shpc->config[SHPC_SLOT_EVENT_LATCH(slot)]; <nl>          uint8_t disable = shpc->config[SHPC_SLOT_EVENT_SERR_INT_DIS(d, slot)]; <nl> -        uint32_t mask = 1 << SHPC_IDX_TO_LOGICAL(slot); <nl> +        uint32_t mask = 1U << SHPC_IDX_TO_LOGICAL(slot); <nl>          if (event & ~disable) { <nl>              int_locator |= mask; <nl>          }
@@ -1666,10 +1666,9 @@ static GSList *gd_vc_gfx_init(GtkDisplayState *s, VirtualConsole *vc, <nl>                                QemuConsole *con, int idx, <nl>                                GSList *group, GtkWidget *view_menu) <nl>  { <nl> -    Error *local_err = NULL; <nl>      Object *obj; <nl>   <nl> -    obj = object_property_get_link(OBJECT(con), "device", &local_err); <nl> +    obj = object_property_get_link(OBJECT(con), "device", NULL); <nl>      if (obj) { <nl>          vc->label = g_strdup_printf("%s", object_get_typename(obj)); <nl>      } else {
@@ -639,7 +639,9 @@ END_TEST <nl>   <nl>  START_TEST(empty_input) <nl>  { <nl> -    QObject *obj = qobject_from_json(""); <nl> +    const char *empty = ""; <nl> + <nl> +    QObject *obj = qobject_from_json(empty); <nl>      fail_unless(obj == NULL); <nl>  } <nl>  END_TEST
@@ -174,6 +174,9 @@ Error *error_copy(const Error *err) <nl>      err_new = g_malloc0(sizeof(*err)); <nl>      err_new->msg = g_strdup(err->msg); <nl>      err_new->err_class = err->err_class; <nl> +    err_new->src = err->src; <nl> +    err_new->line = err->line; <nl> +    err_new->func = err->func; <nl>      if (err->hint) { <nl>          err_new->hint = g_string_new(err->hint->str); <nl>      }
@@ -75,6 +75,9 @@ static void iothread_instance_finalize(Object *obj) <nl>      iothread_stop(obj, NULL); <nl>      qemu_cond_destroy(&iothread->init_done_cond); <nl>      qemu_mutex_destroy(&iothread->init_done_lock); <nl> +    if (!iothread->ctx) { <nl> +        return; <nl> +    } <nl>      aio_context_unref(iothread->ctx); <nl>  } <nl>  
@@ -818,7 +818,7 @@ static QTAILQ_HEAD(, Rom) roms = QTAILQ_HEAD_INITIALIZER(roms); <nl>   <nl>  static inline bool rom_order_compare(Rom *rom, Rom *item) <nl>  { <nl> -    return (rom->as > item->as) || <nl> +    return ((uintptr_t)(void *)rom->as > (uintptr_t)(void *)item->as) || <nl>             (rom->as == item->as && rom->addr >= item->addr); <nl>  } <nl>  
@@ -279,6 +279,10 @@ static int qcow2_write_snapshots(BlockDriverState *bs) <nl>      return 0; <nl>   <nl>  fail: <nl> +    if (snapshots_offset > 0) { <nl> +        qcow2_free_clusters(bs, snapshots_offset, snapshots_size, <nl> +                            QCOW2_DISCARD_ALWAYS); <nl> +    } <nl>      return ret; <nl>  } <nl>  
@@ -436,7 +436,9 @@ BlockInfoList *qmp_query_block(Error **errp) <nl>          bdrv_query_info(blk, &info->value, &local_err); <nl>          if (local_err) { <nl>              error_propagate(errp, local_err); <nl> -            goto err; <nl> +            g_free(info); <nl> +            qapi_free_BlockInfoList(head); <nl> +            return NULL; <nl>          } <nl>   <nl>          *p_next = info; <nl> @@ -444,10 +446,6 @@ BlockInfoList *qmp_query_block(Error **errp) <nl>      } <nl>   <nl>      return head; <nl> - <nl> - err: <nl> -    qapi_free_BlockInfoList(head); <nl> -    return NULL; <nl>  } <nl>   <nl>  BlockStatsList *qmp_query_blockstats(bool has_query_nodes,
@@ -7848,6 +7848,12 @@ static void ppc_cpu_realizefn(DeviceState *dev, Error **errp) <nl>                     max_smt, kvm_enabled() ? "KVM" : "TCG"); <nl>          return; <nl>      } <nl> +    if (!is_power_of_2(smp_threads)) { <nl> +        error_setg(errp, "Cannot support %d threads on PPC with %s, " <nl> +                   "threads count must be a power of 2.", <nl> +                   smp_threads, kvm_enabled() ? "KVM" : "TCG"); <nl> +        return; <nl> +    } <nl>   <nl>      cpu->cpu_dt_id = (cs->cpu_index / smp_threads) * max_smt <nl>          + (cs->cpu_index % smp_threads);
@@ -533,6 +533,12 @@ static void ivshmem_read(void *opaque, const uint8_t *buf, int size) <nl>      if (incoming_posn == -1) { <nl>          void * map_ptr; <nl>   <nl> +        if (s->shm_fd >= 0) { <nl> +            error_report("shm already initialized"); <nl> +            close(incoming_fd); <nl> +            return; <nl> +        } <nl> + <nl>          if (check_shm_size(s, incoming_fd, &err) == -1) { <nl>              error_report_err(err); <nl>              close(incoming_fd);
@@ -455,7 +455,10 @@ static void test_flush(void) <nl>      data = inb(IDE_BASE + reg_device); <nl>      g_assert_cmpint(data & DEV, ==, 0); <nl>   <nl> -    data = inb(IDE_BASE + reg_status); <nl> +    do { <nl> +        data = inb(IDE_BASE + reg_status); <nl> +    } while (data & BSY); <nl> + <nl>      assert_bit_set(data, DRDY); <nl>      assert_bit_clear(data, BSY | DF | ERR | DRQ); <nl>  
@@ -23,7 +23,7 @@ <nl>   * Find a nice value for msize <nl>   * XXX if_maxlinkhdr already in mtu <nl>   */ <nl> -#define SLIRP_MSIZE (IF_MTU + IF_MAXLINKHDR + sizeof(struct m_hdr ) + 6) <nl> +#define SLIRP_MSIZE (IF_MTU + IF_MAXLINKHDR + offsetof(struct mbuf, m_dat) + 6) <nl>   <nl>  void <nl>  m_init(Slirp *slirp) <nl> @@ -65,7 +65,7 @@ m_get(Slirp *slirp) <nl>  	m->m_flags = (flags | M_USEDLIST); <nl>   <nl>  	/* Initialise it */ <nl> -	m->m_size = SLIRP_MSIZE - sizeof(struct m_hdr); <nl> +	m->m_size = SLIRP_MSIZE - offsetof(struct m_hdr, m_dat); <nl>  	m->m_data = m->m_dat; <nl>  	m->m_len = 0; <nl>          m->m_nextpkt = NULL;
@@ -1112,6 +1112,7 @@ static int connect_namedsocket(const char *path) <nl>      size = strlen(helper.sun_path) + sizeof(helper.sun_family); <nl>      if (connect(sockfd, (struct sockaddr *)&helper, size) < 0) { <nl>          fprintf(stderr, "socket error\n"); <nl> +        close(sockfd); <nl>          return -1; <nl>      } <nl>  
@@ -267,8 +267,9 @@ static QString *read_line(FILE *file, char *key) <nl>  { <nl>      char value[128]; <nl>   <nl> -    if (fscanf(file, "%s%s", key, value) == EOF) <nl> +    if (fscanf(file, "%127s%127s", key, value) == EOF) { <nl>          return NULL; <nl> +    } <nl>      remove_dots(key); <nl>      return qstring_from_str(value); <nl>  }
@@ -1827,7 +1827,7 @@ static int htab_save_iterate(QEMUFile *f, void *opaque) <nl>      /* Iteration header */ <nl>      if (!spapr->htab_shift) { <nl>          qemu_put_be32(f, -1); <nl> -        return 0; <nl> +        return 1; <nl>      } else { <nl>          qemu_put_be32(f, 0); <nl>      }
@@ -211,7 +211,6 @@ uint64_t pc_dimm_get_free_addr(uint64_t address_space_start, <nl>      uint64_t address_space_end = address_space_start + address_space_size; <nl>   <nl>      g_assert(QEMU_ALIGN_UP(address_space_start, align) == address_space_start); <nl> -    g_assert(QEMU_ALIGN_UP(address_space_size, align) == address_space_size); <nl>   <nl>      if (!address_space_size) { <nl>          error_setg(errp, "memory hotplug is not enabled, "
@@ -405,6 +405,10 @@ static void virtio_scsi_handle_ctrl(VirtIODevice *vdev, VirtQueue *vq) <nl>      } <nl>  } <nl>   <nl> +static void virtio_scsi_handle_event(VirtIODevice *vdev, VirtQueue *vq) <nl> +{ <nl> +} <nl> + <nl>  static void virtio_scsi_command_complete(SCSIRequest *r, uint32_t status, <nl>                                           size_t resid) <nl>  { <nl> @@ -609,7 +613,7 @@ VirtIODevice *virtio_scsi_init(DeviceState *dev, VirtIOSCSIConf *proxyconf) <nl>      s->ctrl_vq = virtio_add_queue(&s->vdev, VIRTIO_SCSI_VQ_SIZE, <nl>                                     virtio_scsi_handle_ctrl); <nl>      s->event_vq = virtio_add_queue(&s->vdev, VIRTIO_SCSI_VQ_SIZE, <nl> -                                   NULL); <nl> +                                   virtio_scsi_handle_event); <nl>      for (i = 0; i < s->conf->num_queues; i++) { <nl>          s->cmd_vqs[i] = virtio_add_queue(&s->vdev, VIRTIO_SCSI_VQ_SIZE, <nl>                                           virtio_scsi_handle_cmd);
@@ -1550,8 +1550,10 @@ static EHCIQueue *ehci_state_fetchqh(EHCIState *ehci, int async) <nl>      endp    = get_field(qh.epchar, QH_EPCHAR_EP); <nl>      if ((devaddr != get_field(q->qh.epchar, QH_EPCHAR_DEVADDR)) || <nl>          (endp    != get_field(q->qh.epchar, QH_EPCHAR_EP)) || <nl> -        (memcmp(&qh.current_qtd, &q->qh.current_qtd, <nl> -                                 9 * sizeof(uint32_t)) != 0) || <nl> +        (qh.current_qtd != q->qh.current_qtd) || <nl> +        (q->async && qh.next_qtd != q->qh.next_qtd) || <nl> +        (memcmp(&qh.altnext_qtd, &q->qh.altnext_qtd, <nl> +                                 7 * sizeof(uint32_t)) != 0) || <nl>          (q->dev != NULL && q->dev->addr != devaddr)) { <nl>          if (ehci_reset_queue(q) > 0) { <nl>              ehci_trace_guest_bug(ehci, "guest updated active QH"); <nl> @@ -1719,7 +1721,8 @@ static int ehci_state_fetchqtd(EHCIQueue *q) <nl>      p = QTAILQ_FIRST(&q->packets); <nl>      if (p != NULL) { <nl>          if (p->qtdaddr != q->qtdaddr || <nl> -            (!NLPTR_TBIT(p->qtd.next) && (p->qtd.next != qtd.next)) || <nl> +            (q->async && !NLPTR_TBIT(p->qtd.next) && <nl> +                (p->qtd.next != qtd.next)) || <nl>              (!NLPTR_TBIT(p->qtd.altnext) && (p->qtd.altnext != qtd.altnext)) || <nl>              p->qtd.bufptr[0] != qtd.bufptr[0]) { <nl>              ehci_cancel_queue(q);
@@ -135,7 +135,7 @@ void replay_add_event(ReplayAsyncEventKind event_kind, <nl>   <nl>  void replay_bh_schedule_event(QEMUBH *bh) <nl>  { <nl> -    if (replay_mode != REPLAY_MODE_NONE) { <nl> +    if (replay_mode != REPLAY_MODE_NONE && events_enabled) { <nl>          uint64_t id = replay_get_current_step(); <nl>          replay_add_event(REPLAY_ASYNC_EVENT_BH, bh, NULL, id); <nl>      } else {
@@ -405,6 +405,7 @@ static int ioreq_map(struct ioreq *ioreq) <nl>                  xen_be_printf(&ioreq->blkdev->xendev, 0, <nl>                                "can't map grant ref %d (%s, %d maps)\n", <nl>                                refs[i], strerror(errno), ioreq->blkdev->cnt_map); <nl> +                ioreq->mapped = 1; <nl>                  ioreq_unmap(ioreq); <nl>                  return -1; <nl>              }
@@ -468,6 +468,12 @@ void s390_cpu_do_interrupt(CPUState *cs) <nl>          do_mchk_interrupt(env); <nl>          break; <nl>      } <nl> + <nl> +    /* WAIT PSW during interrupt injection */ <nl> +    if (cs->exception_index == EXCP_HLT) { <nl> +        /* don't trigger a cpu_loop_exit(), use an interrupt instead */ <nl> +        cpu_interrupt(CPU(cpu), CPU_INTERRUPT_HALT); <nl> +    } <nl>      cs->exception_index = -1; <nl>   <nl>      /* we might still have pending interrupts, but not deliverable */
@@ -3585,10 +3585,13 @@ static void gen_rfi(DisasContext *ctx) <nl>  #if defined(CONFIG_USER_ONLY) <nl>      GEN_PRIV; <nl>  #else <nl> -    /* FIXME: This instruction doesn't exist anymore on 64-bit server <nl> -     * processors compliant with arch 2.x, we should remove it there, <nl> -     * but we need to fix OpenBIOS not to use it on 970 first <nl> +    /* This instruction doesn't exist anymore on 64-bit server <nl> +     * processors compliant with arch 2.x <nl>       */ <nl> +    if (ctx->insns_flags & PPC_SEGMENT_64B) { <nl> +        gen_inval_exception(ctx, POWERPC_EXCP_INVAL_INVAL); <nl> +        return; <nl> +    } <nl>      /* Restore CPU state */ <nl>      CHK_SV; <nl>      gen_update_cfar(ctx, ctx->nip - 4);
@@ -1922,7 +1922,7 @@ static void *subpage_init (target_phys_addr_t base, uint32_t *phys, <nl>                  need_subpage = 1;                                       \ <nl>          }                                                               \ <nl>                                                                          \ <nl> -        if (end_addr - addr > TARGET_PAGE_SIZE)                         \ <nl> +        if ((start_addr + orig_size) - addr >= TARGET_PAGE_SIZE)        \ <nl>              end_addr2 = TARGET_PAGE_SIZE - 1;                           \ <nl>          else {                                                          \ <nl>              end_addr2 = (start_addr + orig_size - 1) & ~TARGET_PAGE_MASK; \ <nl> @@ -1944,9 +1944,9 @@ void cpu_register_physical_memory(target_phys_addr_t start_addr, <nl>      unsigned long orig_size = size; <nl>      void *subpage; <nl>   <nl> -    end_addr = start_addr + (target_phys_addr_t)size; <nl>      size = (size + TARGET_PAGE_SIZE - 1) & TARGET_PAGE_MASK; <nl> -    for(addr = start_addr; addr < end_addr; addr += TARGET_PAGE_SIZE) { <nl> +    end_addr = start_addr + (target_phys_addr_t)size; <nl> +    for(addr = start_addr; addr != end_addr; addr += TARGET_PAGE_SIZE) { <nl>          p = phys_page_find(addr >> TARGET_PAGE_BITS); <nl>          if (p && p->phys_offset != IO_MEM_UNASSIGNED) { <nl>              unsigned long orig_memory = p->phys_offset;
@@ -231,6 +231,9 @@ static void blk_delete(BlockBackend *blk) <nl>      assert(!blk->refcnt); <nl>      assert(!blk->name); <nl>      assert(!blk->dev); <nl> +    if (blk->public.throttle_state) { <nl> +        blk_io_limits_disable(blk); <nl> +    } <nl>      if (blk->root) { <nl>          blk_remove_bs(blk); <nl>      }
@@ -1069,6 +1069,7 @@ static void device_finalize(Object *obj) <nl>      NamedGPIOList *ngl, *next; <nl>   <nl>      DeviceState *dev = DEVICE(obj); <nl> +    qemu_opts_del(dev->opts); <nl>   <nl>      QLIST_FOREACH_SAFE(ngl, &dev->gpios, node, next) { <nl>          QLIST_REMOVE(ngl, node); <nl> @@ -1118,9 +1119,6 @@ static void device_unparent(Object *obj) <nl>          g_free(dev->canonical_path); <nl>          dev->canonical_path = NULL; <nl>      } <nl> - <nl> -    qemu_opts_del(dev->opts); <nl> -    dev->opts = NULL; <nl>  } <nl>   <nl>  static void device_class_init(ObjectClass *class, void *data)
@@ -3150,9 +3150,9 @@ static void spapr_core_pre_plug(HotplugHandler *hotplug_dev, DeviceState *dev, <nl>       * total vcpus not a multiple of threads-per-core. <nl>       */ <nl>      if (mc->has_hotpluggable_cpus && (cc->nr_threads != smp_threads)) { <nl> -        error_setg(errp, "invalid nr-threads %d, must be %d", <nl> +        error_setg(&local_err, "invalid nr-threads %d, must be %d", <nl>                     cc->nr_threads, smp_threads); <nl> -        return; <nl> +        goto out; <nl>      } <nl>   <nl>      core_slot = spapr_find_cpu_slot(MACHINE(hotplug_dev), cc->core_id, &index);
@@ -100,6 +100,7 @@ PCIBus *pci_register_bus(pci_set_irq_fn set_irq, pci_map_irq_fn map_irq, <nl>      bus->irq_opaque = pic; <nl>      bus->devfn_min = devfn_min; <nl>      bus->nirq = nirq; <nl> +    bus->next = first_bus; <nl>      first_bus = bus; <nl>      register_savevm("PCIBUS", nbus++, 1, pcibus_save, pcibus_load, bus); <nl>      return bus;
@@ -94,9 +94,12 @@ static void qemu_laio_process_completion(struct qemu_laiocb *laiocb) <nl>   <nl>      laiocb->ret = ret; <nl>      if (laiocb->co) { <nl> -        /* Jump and continue completion for foreign requests, don't do <nl> -         * anything for current request, it will be completed shortly. */ <nl> -        if (laiocb->co != qemu_coroutine_self()) { <nl> +        /* If the coroutine is already entered it must be in ioq_submit() and <nl> +         * will notice laio->ret has been filled in when it eventually runs <nl> +         * later.  Coroutines cannot be entered recursively so avoid doing <nl> +         * that! <nl> +         */ <nl> +        if (!qemu_coroutine_entered(laiocb->co)) { <nl>              qemu_coroutine_enter(laiocb->co); <nl>          } <nl>      } else {
@@ -399,6 +399,8 @@ static void sch_handle_start_func(SubchDev *sch, ORB *orb) <nl>      path = 0x80; <nl>   <nl>      if (!(s->ctrl & SCSW_ACTL_SUSP)) { <nl> +        s->cstat = 0; <nl> +        s->dstat = 0; <nl>          /* Look at the orb and try to execute the channel program. */ <nl>          assert(orb != NULL); /* resume does not pass an orb */ <nl>          p->intparm = orb->intparm;
@@ -255,7 +255,7 @@ static int vscsi_srp_direct_data(VSCSIState *s, vscsi_req *req, <nl>  { <nl>      struct srp_direct_buf *md = req->cur_desc; <nl>      uint32_t llen; <nl> -    int rc; <nl> +    int rc = 0; <nl>   <nl>      dprintf("VSCSI: direct segment 0x%x bytes, va=0x%llx desc len=0x%x\n", <nl>              len, (unsigned long long)md->va, md->len);
@@ -213,7 +213,7 @@ static void tmu2_start(MilkymistTMU2State *s) <nl>      /* Read the QEMU source framebuffer into an OpenGL texture */ <nl>      glGenTextures(1, &texture); <nl>      glBindTexture(GL_TEXTURE_2D, texture); <nl> -    fb_len = 2*s->regs[R_TEXHRES]*s->regs[R_TEXVRES]; <nl> +    fb_len = 2ULL * s->regs[R_TEXHRES] * s->regs[R_TEXVRES]; <nl>      fb = cpu_physical_memory_map(s->regs[R_TEXFBUF], &fb_len, 0); <nl>      if (fb == NULL) { <nl>          glDeleteTextures(1, &texture);
@@ -114,7 +114,7 @@ static QemuOptsList parallels_runtime_opts = { <nl>              .name = PARALLELS_OPT_PREALLOC_SIZE, <nl>              .type = QEMU_OPT_SIZE, <nl>              .help = "Preallocation size on image expansion", <nl> -            .def_value_str = "128MiB", <nl> +            .def_value_str = "128M", <nl>          }, <nl>          { <nl>              .name = PARALLELS_OPT_PREALLOC_MODE,
@@ -857,6 +857,9 @@ out_noclean: <nl>      qemu_mutex_destroy(&s->mutex); <nl>      g_free(s->cookie); <nl>      g_free(s->url); <nl> +    g_free(s->username); <nl> +    g_free(s->proxyusername); <nl> +    g_free(s->proxypassword); <nl>      qemu_opts_del(opts); <nl>      return -EINVAL; <nl>  } <nl> @@ -955,6 +958,9 @@ static void curl_close(BlockDriverState *bs) <nl>   <nl>      g_free(s->cookie); <nl>      g_free(s->url); <nl> +    g_free(s->username); <nl> +    g_free(s->proxyusername); <nl> +    g_free(s->proxypassword); <nl>  } <nl>   <nl>  static int64_t curl_getlength(BlockDriverState *bs)
@@ -2084,7 +2084,8 @@ static void vfio_listener_region_add(MemoryListener *listener, <nl>      if (vfio_listener_skipped_section(section)) { <nl>          DPRINTF("SKIPPING region_add %"HWADDR_PRIx" - %"PRIx64"\n", <nl>                  section->offset_within_address_space, <nl> -                section->offset_within_address_space + section->size - 1); <nl> +                section->offset_within_address_space + <nl> +                int128_get64(int128_sub(section->size, int128_one()))); <nl>          return; <nl>      } <nl>   <nl> @@ -2129,7 +2130,8 @@ static void vfio_listener_region_del(MemoryListener *listener, <nl>      if (vfio_listener_skipped_section(section)) { <nl>          DPRINTF("SKIPPING region_del %"HWADDR_PRIx" - %"PRIx64"\n", <nl>                  section->offset_within_address_space, <nl> -                section->offset_within_address_space + section->size - 1); <nl> +                section->offset_within_address_space + <nl> +                int128_get64(int128_sub(section->size, int128_one()))); <nl>          return; <nl>      } <nl>  
@@ -607,6 +607,7 @@ static void xilinx_spips_realize(DeviceState *dev, Error **errp) <nl>      XilinxSPIPS *s = XILINX_SPIPS(dev); <nl>      SysBusDevice *sbd = SYS_BUS_DEVICE(dev); <nl>      XilinxSPIPSClass *xsc = XILINX_SPIPS_GET_CLASS(s); <nl> +    qemu_irq *cs; <nl>      int i; <nl>   <nl>      DB_PRINT_L(0, "realized spips\n"); <nl> @@ -619,8 +620,10 @@ static void xilinx_spips_realize(DeviceState *dev, Error **errp) <nl>      } <nl>   <nl>      s->cs_lines = g_new0(qemu_irq, s->num_cs * s->num_busses); <nl> -    ssi_auto_connect_slaves(DEVICE(s), s->cs_lines, s->spi[0]); <nl> -    ssi_auto_connect_slaves(DEVICE(s), s->cs_lines, s->spi[1]); <nl> +    for (i = 0, cs = s->cs_lines; i < s->num_busses; ++i, cs += s->num_cs) { <nl> +        ssi_auto_connect_slaves(DEVICE(s), cs, s->spi[i]); <nl> +    } <nl> + <nl>      sysbus_init_irq(sbd, &s->irq); <nl>      for (i = 0; i < s->num_cs * s->num_busses; ++i) { <nl>          sysbus_init_irq(sbd, &s->cs_lines[i]);
@@ -1739,6 +1739,7 @@ int do_drive_del(Monitor *mon, const QDict *qdict, QObject **ret_data) <nl>  { <nl>      const char *id = qdict_get_str(qdict, "id"); <nl>      BlockDriverState *bs; <nl> +    DriveInfo *dinfo; <nl>      AioContext *aio_context; <nl>      Error *local_err = NULL; <nl>   <nl> @@ -1748,6 +1749,13 @@ int do_drive_del(Monitor *mon, const QDict *qdict, QObject **ret_data) <nl>          return -1; <nl>      } <nl>   <nl> +    dinfo = drive_get_by_blockdev(bs); <nl> +    if (dinfo && !dinfo->enable_auto_del) { <nl> +        error_report("Deleting device added with blockdev-add" <nl> +                     " is not supported"); <nl> +        return -1; <nl> +    } <nl> + <nl>      aio_context = bdrv_get_aio_context(bs); <nl>      aio_context_acquire(aio_context); <nl>   <nl> @@ -1775,7 +1783,7 @@ int do_drive_del(Monitor *mon, const QDict *qdict, QObject **ret_data) <nl>          bdrv_set_on_error(bs, BLOCKDEV_ON_ERROR_REPORT, <nl>                            BLOCKDEV_ON_ERROR_REPORT); <nl>      } else { <nl> -        drive_del(drive_get_by_blockdev(bs)); <nl> +        drive_del(dinfo); <nl>      } <nl>   <nl>      aio_context_release(aio_context);
@@ -615,26 +615,31 @@ static void qdict_crumple_test_recursive(void) <nl>   <nl>      vnc = qdict_get_qdict(dst, "vnc"); <nl>      g_assert(vnc); <nl> +    g_assert_cmpint(qdict_size(vnc), ==, 3); <nl>   <nl>      listen = qdict_get_qdict(vnc, "listen"); <nl>      g_assert(listen); <nl> +    g_assert_cmpint(qdict_size(listen), ==, 2); <nl>      g_assert_cmpstr("127.0.0.1", ==, qdict_get_str(listen, "addr")); <nl>      g_assert_cmpstr("5901", ==, qdict_get_str(listen, "port")); <nl>   <nl>      acl = qdict_get_qdict(vnc, "acl"); <nl>      g_assert(acl); <nl> +    g_assert_cmpint(qdict_size(acl), ==, 3); <nl>   <nl>      rules = qdict_get_qlist(acl, "rules"); <nl>      g_assert(rules); <nl>      g_assert_cmpint(qlist_size(rules), ==, 2); <nl>   <nl>      rule = qobject_to_qdict(qlist_pop(rules)); <nl> +    g_assert(rule); <nl>      g_assert_cmpint(qdict_size(rule), ==, 2); <nl>      g_assert_cmpstr("fred", ==, qdict_get_str(rule, "match")); <nl>      g_assert_cmpstr("allow", ==, qdict_get_str(rule, "policy")); <nl>      QDECREF(rule); <nl>   <nl>      rule = qobject_to_qdict(qlist_pop(rules)); <nl> +    g_assert(rule); <nl>      g_assert_cmpint(qdict_size(rule), ==, 2); <nl>      g_assert_cmpstr("bob", ==, qdict_get_str(rule, "match")); <nl>      g_assert_cmpstr("deny", ==, qdict_get_str(rule, "policy"));
@@ -12,7 +12,11 @@ <nl>  #ifndef BITMAP_H <nl>  #define BITMAP_H <nl>   <nl> -#include "qemu-common.h" <nl> +#include <glib.h> <nl> +#include <string.h> <nl> +#include <stdlib.h> <nl> + <nl> +#include "qemu/osdep.h" <nl>  #include "qemu/bitops.h" <nl>   <nl>  /*
@@ -180,6 +180,7 @@ static int con_init(struct XenDevice *xendev) <nl>  { <nl>      struct XenConsole *con = container_of(xendev, struct XenConsole, xendev); <nl>      char *type, *dom; <nl> +    int ret = 0; <nl>   <nl>      /* setup */ <nl>      dom = xs_get_domain_path(xenstore, con->xendev.dom); <nl> @@ -189,7 +190,8 @@ static int con_init(struct XenDevice *xendev) <nl>      type = xenstore_read_str(con->console, "type"); <nl>      if (!type || strcmp(type, "ioemu") != 0) { <nl>  	xen_be_printf(xendev, 1, "not for me (type=%s)\n", type); <nl> -	return -1; <nl> +        ret = -1; <nl> +        goto out; <nl>      } <nl>   <nl>      if (!serial_hds[con->xendev.dev]) <nl> @@ -198,7 +200,9 @@ static int con_init(struct XenDevice *xendev) <nl>      else <nl>          con->chr = serial_hds[con->xendev.dev]; <nl>   <nl> -    return 0; <nl> +out: <nl> +    qemu_free(type); <nl> +    return ret; <nl>  } <nl>   <nl>  static int con_connect(struct XenDevice *xendev)
@@ -673,9 +673,9 @@ static int cirrus_bitblt_videotovideo_patterncopy(CirrusVGAState * s) <nl>   <nl>  static void cirrus_do_copy(CirrusVGAState *s, int dst, int src, int w, int h) <nl>  { <nl> -    int sx, sy; <nl> -    int dx, dy; <nl> -    int depth; <nl> +    int sx = 0, sy = 0; <nl> +    int dx = 0, dy = 0; <nl> +    int depth = 0; <nl>      int notify = 0; <nl>   <nl>      /* make sure to only copy if it's a plain copy ROP */
@@ -692,7 +692,8 @@ void ide_dma_cb(void *opaque, int ret) <nl>             sector_num, n, s->dma_cmd); <nl>  #endif <nl>   <nl> -    if (!ide_sect_range_ok(s, sector_num, n)) { <nl> +    if ((s->dma_cmd == IDE_DMA_READ || s->dma_cmd == IDE_DMA_WRITE) && <nl> +        !ide_sect_range_ok(s, sector_num, n)) { <nl>          dma_buf_commit(s); <nl>          ide_dma_error(s); <nl>          return;
@@ -317,7 +317,10 @@ static void curses_refresh(DisplayChangeListener *dcl) <nl>                  qemu_input_event_send_key_delay(0); <nl>              } <nl>          } else { <nl> -            keysym = curses2qemu[chr]; <nl> +            keysym = -1; <nl> +            if (chr < CURSES_KEYS) { <nl> +                keysym = curses2qemu[chr]; <nl> +            } <nl>              if (keysym == -1) <nl>                  keysym = chr; <nl>  
@@ -1512,7 +1512,8 @@ void cmos_set_s3_resume(void) <nl>  } <nl>   <nl>  static QEMUMachine pc_machine = { <nl> -    .name = "pc", <nl> +    .name = "pc-0.11", <nl> +    .alias = "pc", <nl>      .desc = "Standard PC", <nl>      .init = pc_init_pci, <nl>      .max_cpus = 255,
@@ -417,7 +417,7 @@ static int kvm_physical_sync_dirty_bitmap(MemoryRegionSection *section) <nl>  { <nl>      KVMState *s = kvm_state; <nl>      unsigned long size, allocated_size = 0; <nl> -    KVMDirtyLog d; <nl> +    KVMDirtyLog d = {}; <nl>      KVMSlot *mem; <nl>      int ret = 0; <nl>      hwaddr start_addr = section->offset_within_address_space;
@@ -615,6 +615,13 @@ static void nvme_write_bar(NvmeCtrl *n, hwaddr offset, uint64_t data, <nl>          n->bar.intmc = n->bar.intms; <nl>          break; <nl>      case 0x14: <nl> +        /* Windows first sends data, then sends enable bit */ <nl> +        if (!NVME_CC_EN(data) && !NVME_CC_EN(n->bar.cc) && <nl> +            !NVME_CC_SHN(data) && !NVME_CC_SHN(n->bar.cc)) <nl> +        { <nl> +            n->bar.cc = data; <nl> +        } <nl> + <nl>          if (NVME_CC_EN(data) && !NVME_CC_EN(n->bar.cc)) { <nl>              n->bar.cc = data; <nl>              if (nvme_start_ctrl(n)) {
@@ -58,7 +58,7 @@ static V9fsSynthNode *v9fs_add_dir_node(V9fsSynthNode *parent, int mode, <nl>          node->attr->read  = NULL; <nl>      } <nl>      node->private = node; <nl> -    strncpy(node->name, name, sizeof(node->name)); <nl> +    pstrcpy(node->name, sizeof(node->name), name); <nl>      QLIST_INSERT_HEAD_RCU(&parent->child, node, sibling); <nl>      return node; <nl>  } <nl> @@ -132,7 +132,7 @@ int qemu_v9fs_synth_add_file(V9fsSynthNode *parent, int mode, <nl>      node->attr->write  = write; <nl>      node->attr->mode   = mode; <nl>      node->private      = arg; <nl> -    strncpy(node->name, name, sizeof(node->name)); <nl> +    pstrcpy(node->name, sizeof(node->name), name); <nl>      QLIST_INSERT_HEAD_RCU(&parent->child, node, sibling); <nl>      ret = 0; <nl>  err_out:
@@ -213,21 +213,22 @@ void HELPER(mvc)(CPUS390XState *env, uint32_t l, uint64_t dest, uint64_t src) <nl>      if (dest == (src + 1)) { <nl>          memset(g2h(dest), cpu_ldub_data(env, src), l + 1); <nl>          return; <nl> -    } else { <nl> +    /* mvc and memmove do not behave the same when areas overlap! */ <nl> +    } else if ((dest < src) || (src + l < dest)) { <nl>          memmove(g2h(dest), g2h(src), l + 1); <nl>          return; <nl>      } <nl>  #endif <nl>   <nl>      /* handle the parts that fit into 8-byte loads/stores */ <nl> -    if (dest != (src + 1)) { <nl> +    if ((dest + 8 <= src) || (src + 8 <= dest)) { <nl>          for (i = 0; i < l_64; i++) { <nl>              cpu_stq_data(env, dest + x, cpu_ldq_data(env, src + x)); <nl>              x += 8; <nl>          } <nl>      } <nl>   <nl> -    /* slow version crossing pages with byte accesses */ <nl> +    /* slow version with byte accesses which always work */ <nl>      for (i = x; i <= l; i++) { <nl>          cpu_stb_data(env, dest + i, cpu_ldub_data(env, src + i)); <nl>      }
@@ -71,7 +71,7 @@ typedef struct QObject { <nl>   <nl>  /* High-level interface for qobject_decref() */ <nl>  #define QDECREF(obj)              \ <nl> -    qobject_decref(QOBJECT(obj)) <nl> +    qobject_decref(obj ? QOBJECT(obj) : NULL) <nl>   <nl>  /* Initialize an object to default values */ <nl>  #define QOBJECT_INIT(obj, qtype_type)   \
@@ -126,8 +126,6 @@ static int announce_self_create(uint8_t *buf, <nl>  static void qemu_announce_self_once(void *opaque) <nl>  { <nl>      int i, len; <nl> -    VLANState *vlan; <nl> -    VLANClientState *vc; <nl>      uint8_t buf[60]; <nl>      static int count = SELF_ANNOUNCE_ROUNDS; <nl>      QEMUTimer *timer = *(QEMUTimer **)opaque; <nl> @@ -136,10 +134,7 @@ static void qemu_announce_self_once(void *opaque) <nl>          if (!nd_table[i].used) <nl>              continue; <nl>          len = announce_self_create(buf, nd_table[i].macaddr); <nl> -        vlan = nd_table[i].vlan; <nl> -        QTAILQ_FOREACH(vc, &vlan->clients, next) { <nl> -            vc->receive(vc, buf, len); <nl> -        } <nl> +        qemu_send_packet_raw(nd_table[i].vc, buf, len); <nl>      } <nl>      if (--count) { <nl>          /* delay 50ms, 150ms, 250ms, ... */
@@ -353,16 +353,18 @@ static void nvdimm_build_nfit(GSList *device_list, GArray *table_offsets, <nl>                                GArray *table_data, GArray *linker) <nl>  { <nl>      GArray *structures = nvdimm_build_device_structure(device_list); <nl> -    void *header; <nl> +    unsigned int header; <nl>   <nl>      acpi_add_table(table_offsets, table_data); <nl>   <nl>      /* NFIT header. */ <nl> -    header = acpi_data_push(table_data, sizeof(NvdimmNfitHeader)); <nl> +    header = table_data->len; <nl> +    acpi_data_push(table_data, sizeof(NvdimmNfitHeader)); <nl>      /* NVDIMM device structures. */ <nl>      g_array_append_vals(table_data, structures->data, structures->len); <nl>   <nl> -    build_header(linker, table_data, header, "NFIT", <nl> +    build_header(linker, table_data, <nl> +                 (void *)(table_data->data + header), "NFIT", <nl>                   sizeof(NvdimmNfitHeader) + structures->len, 1, NULL); <nl>      g_array_free(structures, true); <nl>  }
@@ -435,9 +435,6 @@ static void process_incoming_migration_co(void *opaque) <nl>          qemu_thread_join(&mis->colo_incoming_thread); <nl>      } <nl>   <nl> -    qemu_fclose(f); <nl> -    free_xbzrle_decoded_buf(); <nl> - <nl>      if (ret < 0) { <nl>          migrate_set_state(&mis->state, MIGRATION_STATUS_ACTIVE, <nl>                            MIGRATION_STATUS_FAILED); <nl> @@ -446,6 +443,9 @@ static void process_incoming_migration_co(void *opaque) <nl>          exit(EXIT_FAILURE); <nl>      } <nl>   <nl> +    qemu_fclose(f); <nl> +    free_xbzrle_decoded_buf(); <nl> + <nl>      mis->bh = qemu_bh_new(process_incoming_migration_bh, mis); <nl>      qemu_bh_schedule(mis->bh); <nl>  }
@@ -97,9 +97,12 @@ static void do_sdl_resize(int new_width, int new_height, int bpp) <nl>   <nl>      //    printf("resizing to %d %d\n", w, h); <nl>   <nl> -    flags = SDL_HWSURFACE|SDL_ASYNCBLIT|SDL_HWACCEL|SDL_RESIZABLE; <nl> -    if (gui_fullscreen) <nl> +    flags = SDL_HWSURFACE | SDL_ASYNCBLIT | SDL_HWACCEL; <nl> +    if (gui_fullscreen) { <nl>          flags |= SDL_FULLSCREEN; <nl> +    } else { <nl> +        flags |= SDL_RESIZABLE; <nl> +    } <nl>      if (gui_noframe) <nl>          flags |= SDL_NOFRAME; <nl>  
@@ -130,6 +130,8 @@ int vmstate_load_state(QEMUFile *f, const VMStateDescription *vmsd, <nl>                  } <nl>                  if (ret < 0) { <nl>                      qemu_file_set_error(f, ret); <nl> +                    error_report("Failed to load %s:%s", vmsd->name, <nl> +                                 field->name); <nl>                      trace_vmstate_load_field_error(field->name, ret); <nl>                      return ret; <nl>                  }
@@ -819,6 +819,13 @@ int spapr_h_cas_compose_response(sPAPRMachineState *spapr, <nl>          return 1; <nl>      } <nl>   <nl> +    if (size < sizeof(hdr) || size > FW_MAX_SIZE) { <nl> +        error_report("SLOF provided an unexpected CAS buffer size " <nl> +                     TARGET_FMT_lu " (min: %zu, max: %u)", <nl> +                     size, sizeof(hdr), FW_MAX_SIZE); <nl> +        exit(EXIT_FAILURE); <nl> +    } <nl> + <nl>      size -= sizeof(hdr); <nl>   <nl>      /* Create skeleton */
@@ -93,10 +93,6 @@ static gboolean fd_trampoline(GIOChannel *chan, GIOCondition cond, gpointer opaq <nl>  { <nl>      IOTrampoline *tramp = opaque; <nl>   <nl> -    if (tramp->opaque == NULL) { <nl> -        return FALSE; <nl> -    } <nl> - <nl>      if ((cond & G_IO_IN) && tramp->fd_read) { <nl>          tramp->fd_read(tramp->opaque); <nl>      } <nl> @@ -119,9 +115,10 @@ int qemu_set_fd_handler(int fd, <nl>      if (tramp->tag != 0) { <nl>          g_io_channel_unref(tramp->chan); <nl>          g_source_remove(tramp->tag); <nl> +        tramp->tag = 0; <nl>      } <nl>   <nl> -    if (opaque) { <nl> +    if (fd_read || fd_write || opaque) { <nl>          GIOCondition cond = 0; <nl>   <nl>          tramp->fd_read = fd_read;
@@ -1820,8 +1820,10 @@ static void pc_cpu_plug(HotplugHandler *hotplug_dev, <nl>   <nl>      /* increment the number of CPUs */ <nl>      pcms->boot_cpus++; <nl> -    if (dev->hotplugged) { <nl> +    if (pcms->rtc) { <nl>          rtc_set_cpus_count(pcms->rtc, pcms->boot_cpus); <nl> +    } <nl> +    if (pcms->fw_cfg) { <nl>          fw_cfg_modify_i16(pcms->fw_cfg, FW_CFG_NB_CPUS, pcms->boot_cpus); <nl>      } <nl>  
@@ -706,14 +706,14 @@ void configure_icount(const char *option) <nl>   <nl>  void qemu_run_all_timers(void) <nl>  { <nl> +    alarm_timer->pending = 0; <nl> + <nl>      /* rearm timer, if not periodic */ <nl>      if (alarm_timer->expired) { <nl>          alarm_timer->expired = 0; <nl>          qemu_rearm_alarm_timer(alarm_timer); <nl>      } <nl>   <nl> -    alarm_timer->pending = 0; <nl> - <nl>      /* vm time timers */ <nl>      if (vm_running) { <nl>          qemu_run_timers(vm_clock);
@@ -89,8 +89,8 @@ <nl>   *              TODO lift the restriction <nl>   * 'i'          32 bit integer <nl>   * 'l'          target long (32 or 64 bit) <nl> - * 'M'          just like 'l', except in user mode the value is <nl> - *              multiplied by 2^20 (think Mebibyte) <nl> + * 'M'          Non-negative target long (32 or 64 bit), in user mode the <nl> + *              value is multiplied by 2^20 (think Mebibyte) <nl>   * 'o'          octets (aka bytes) <nl>   *              user mode accepts an optional T, t, G, g, M, m, K, k <nl>   *              suffix, which multiplies the value by 2^40 for <nl> @@ -3622,6 +3622,10 @@ static const mon_cmd_t *monitor_parse_command(Monitor *mon, <nl>                      monitor_printf(mon, "integer is for 32-bit values\n"); <nl>                      goto fail; <nl>                  } else if (c == 'M') { <nl> +                    if (val < 0) { <nl> +                        monitor_printf(mon, "enter a positive value\n"); <nl> +                        goto fail; <nl> +                    } <nl>                      val <<= 20; <nl>                  } <nl>                  qdict_put(qdict, key, qint_from_int(val));
@@ -73,7 +73,14 @@ static const CompatInfo compat_table[] = { <nl>          .pvr = CPU_POWERPC_LOGICAL_3_00, <nl>          .pcr = PCR_COMPAT_3_00, <nl>          .pcr_level = PCR_COMPAT_3_00, <nl> -        .max_threads = 4, <nl> +        /* <nl> +         * POWER9 hardware only supports 4 threads / core, but this <nl> +         * limit is for guests.  We need to support 8 vthreads/vcore <nl> +         * on POWER9 for POWER8 compatibility guests, and it's very <nl> +         * confusing if half of the threads disappear from the guest <nl> +         * if it announces it's POWER9 aware at CAS time. <nl> +         */ <nl> +        .max_threads = 8, <nl>      }, <nl>  }; <nl>  
@@ -697,6 +697,7 @@ int nbd_client_co_pwritev(BlockDriverState *bs, uint64_t offset, <nl>          .len = bytes, <nl>      }; <nl>   <nl> +    assert(!(client->info.flags & NBD_FLAG_READ_ONLY)); <nl>      if (flags & BDRV_REQ_FUA) { <nl>          assert(client->info.flags & NBD_FLAG_SEND_FUA); <nl>          request.flags |= NBD_CMD_FLAG_FUA; <nl> @@ -717,6 +718,7 @@ int nbd_client_co_pwrite_zeroes(BlockDriverState *bs, int64_t offset, <nl>          .len = bytes, <nl>      }; <nl>   <nl> +    assert(!(client->info.flags & NBD_FLAG_READ_ONLY)); <nl>      if (!(client->info.flags & NBD_FLAG_SEND_WRITE_ZEROES)) { <nl>          return -ENOTSUP; <nl>      } <nl> @@ -756,6 +758,7 @@ int nbd_client_co_pdiscard(BlockDriverState *bs, int64_t offset, int bytes) <nl>          .len = bytes, <nl>      }; <nl>   <nl> +    assert(!(client->info.flags & NBD_FLAG_READ_ONLY)); <nl>      if (!(client->info.flags & NBD_FLAG_SEND_TRIM)) { <nl>          return 0; <nl>      } <nl> @@ -814,6 +817,12 @@ int nbd_client_init(BlockDriverState *bs, <nl>          logout("Failed to negotiate with the NBD server\n"); <nl>          return ret; <nl>      } <nl> +    if (client->info.flags & NBD_FLAG_READ_ONLY && <nl> +        !bdrv_is_read_only(bs)) { <nl> +        error_setg(errp, <nl> +                   "request for write access conflicts with read-only export"); <nl> +        return -EACCES; <nl> +    } <nl>      if (client->info.flags & NBD_FLAG_SEND_FUA) { <nl>          bs->supported_write_flags = BDRV_REQ_FUA; <nl>          bs->supported_zero_flags |= BDRV_REQ_FUA;
@@ -243,6 +243,7 @@ static void apic_reset_common(DeviceState *dev) <nl>   <nl>      bsp = s->apicbase & MSR_IA32_APICBASE_BSP; <nl>      s->apicbase = APIC_DEFAULT_ADDRESS | bsp | MSR_IA32_APICBASE_ENABLE; <nl> +    s->id = s->initial_apic_id; <nl>   <nl>      s->vapic_paddr = 0; <nl>      info->vapic_base_update(s);
@@ -746,7 +746,7 @@ static inline void gen_op_arith_compute_ov(DisasContext *ctx, TCGv arg0, <nl>  { <nl>      TCGv t0 = tcg_temp_new(); <nl>   <nl> -    tcg_gen_xor_tl(cpu_ov, arg0, arg1); <nl> +    tcg_gen_xor_tl(cpu_ov, arg0, arg2); <nl>      tcg_gen_xor_tl(t0, arg1, arg2); <nl>      if (sub) { <nl>          tcg_gen_and_tl(cpu_ov, cpu_ov, t0);
@@ -310,5 +310,10 @@ void laio_cleanup(void *s_) <nl>      struct qemu_laio_state *s = s_; <nl>   <nl>      event_notifier_cleanup(&s->e); <nl> + <nl> +    if (io_destroy(s->ctx) != 0) { <nl> +        fprintf(stderr, "%s: destroy AIO context %p failed\n", <nl> +                        __func__, &s->ctx); <nl> +    } <nl>      g_free(s); <nl>  }
@@ -1804,7 +1804,7 @@ static void qxl_hw_text_update(void *opaque, console_ch_t *chardata) <nl>   <nl>  static void qxl_dirty_surfaces(PCIQXLDevice *qxl) <nl>  { <nl> -    intptr_t vram_start; <nl> +    uintptr_t vram_start; <nl>      int i; <nl>   <nl>      if (qxl->mode != QXL_MODE_NATIVE && qxl->mode != QXL_MODE_COMPAT) { <nl> @@ -1815,7 +1815,7 @@ static void qxl_dirty_surfaces(PCIQXLDevice *qxl) <nl>      qxl_set_dirty(&qxl->vga.vram, qxl->shadow_rom.draw_area_offset, <nl>                    qxl->shadow_rom.surface0_area_size); <nl>   <nl> -    vram_start =  (intptr_t)memory_region_get_ram_ptr(&qxl->vram_bar); <nl> +    vram_start = (uintptr_t)memory_region_get_ram_ptr(&qxl->vram_bar); <nl>   <nl>      /* dirty the off-screen surfaces */ <nl>      for (i = 0; i < qxl->ssd.num_surfaces; i++) {
@@ -146,7 +146,13 @@ uint64_t pc_dimm_get_free_addr(uint64_t address_space_start, <nl>      uint64_t new_addr, ret = 0; <nl>      uint64_t address_space_end = address_space_start + address_space_size; <nl>   <nl> -    assert(address_space_end > address_space_size); <nl> +    if (!address_space_size) { <nl> +        error_setg(errp, "memory hotplug is not enabled, " <nl> +                         "please add maxmem option"); <nl> +        goto out; <nl> +    } <nl> + <nl> +    assert(address_space_end > address_space_start); <nl>      object_child_foreach(qdev_get_machine(), pc_dimm_built_list, &list); <nl>   <nl>      if (hint) {
@@ -325,8 +325,8 @@ static void coroutine_fn mirror_run(void *opaque) <nl>   <nl>      s->common.len = bdrv_getlength(bs); <nl>      if (s->common.len <= 0) { <nl> -        block_job_completed(&s->common, s->common.len); <nl> -        return; <nl> +        ret = s->common.len; <nl> +        goto immediate_exit; <nl>      } <nl>   <nl>      length = DIV_ROUND_UP(s->common.len, s->granularity);
@@ -7229,7 +7229,8 @@ gen_intermediate_code_internal (CPUState *env, TranslationBlock *tb, <nl>          fprintf (logfile, "search pc %d\n", search_pc); <nl>   <nl>      pc_start = tb->pc; <nl> -    gen_opc_end = gen_opc_buf + OPC_MAX_SIZE; <nl> +    /* Leave some spare opc slots for branch handling. */ <nl> +    gen_opc_end = gen_opc_buf + OPC_MAX_SIZE - 16; <nl>      ctx.pc = pc_start; <nl>      ctx.saved_pc = -1; <nl>      ctx.tb = tb; <nl> @@ -7254,7 +7255,7 @@ gen_intermediate_code_internal (CPUState *env, TranslationBlock *tb, <nl>          fprintf(logfile, "\ntb %p idx %d hflags %04x\n", <nl>                  tb, ctx.mem_idx, ctx.hflags); <nl>  #endif <nl> -    while (ctx.bstate == BS_NONE && gen_opc_ptr < gen_opc_end) { <nl> +    while (ctx.bstate == BS_NONE) { <nl>          if (env->nb_breakpoints > 0) { <nl>              for(j = 0; j < env->nb_breakpoints; j++) { <nl>                  if (env->breakpoints[j] == ctx.pc) { <nl> @@ -7290,6 +7291,9 @@ gen_intermediate_code_internal (CPUState *env, TranslationBlock *tb, <nl>          if ((ctx.pc & (TARGET_PAGE_SIZE - 1)) == 0) <nl>              break; <nl>   <nl> +        if (gen_opc_ptr >= gen_opc_end) <nl> +            break; <nl> + <nl>  #if defined (MIPS_SINGLE_STEP) <nl>          break; <nl>  #endif
@@ -105,7 +105,8 @@ static void cleanup_infolist(CommandLineParameterInfoList *head) <nl>              if (!strcmp(pre_entry->value->name, cur->next->value->name)) { <nl>                  del_entry = cur->next; <nl>                  cur->next = cur->next->next; <nl> -                g_free(del_entry); <nl> +                del_entry->next = NULL; <nl> +                qapi_free_CommandLineParameterInfoList(del_entry); <nl>                  break; <nl>              } <nl>              pre_entry = pre_entry->next;
@@ -107,6 +107,15 @@ static int cloop_open(BlockDriverState *bs, QDict *options, int flags, <nl>          return -EINVAL; <nl>      } <nl>      offsets_size = s->n_blocks * sizeof(uint64_t); <nl> +    if (offsets_size > 512 * 1024 * 1024) { <nl> +        /* Prevent ridiculous offsets_size which causes memory allocation to <nl> +         * fail or overflows bdrv_pread() size.  In practice the 512 MB <nl> +         * offsets[] limit supports 16 TB images at 256 KB block size. <nl> +         */ <nl> +        error_setg(errp, "image requires too many offsets, " <nl> +                   "try increasing block size"); <nl> +        return -EINVAL; <nl> +    } <nl>      s->offsets = g_malloc(offsets_size); <nl>   <nl>      ret = bdrv_pread(bs->file, 128 + 4 + 4, s->offsets, offsets_size);
@@ -367,6 +367,13 @@ static int alloc_refcount_block(BlockDriverState *bs, <nl>          return new_block; <nl>      } <nl>   <nl> +    /* If we're allocating the block at offset 0 then something is wrong */ <nl> +    if (new_block == 0) { <nl> +        qcow2_signal_corruption(bs, true, -1, -1, "Preventing invalid " <nl> +                                "allocation of refcount block at offset 0"); <nl> +        return -EIO; <nl> +    } <nl> + <nl>  #ifdef DEBUG_ALLOC2 <nl>      fprintf(stderr, "qcow2: Allocate refcount block %d for %" PRIx64 <nl>          " at %" PRIx64 "\n",
@@ -384,9 +384,12 @@ xmit_seg(E1000State *s) <nl>          } else	// UDP <nl>              cpu_to_be16wu((uint16_t *)(tp->data+css+4), len); <nl>          if (tp->sum_needed & E1000_TXD_POPTS_TXSM) { <nl> +            unsigned int phsum; <nl>              // add pseudo-header length before checksum calculation <nl>              sp = (uint16_t *)(tp->data + tp->tucso); <nl> -            cpu_to_be16wu(sp, be16_to_cpup(sp) + len); <nl> +            phsum = be16_to_cpup(sp) + len; <nl> +            phsum = (phsum >> 16) + (phsum & 0xffff); <nl> +            cpu_to_be16wu(sp, phsum); <nl>          } <nl>          tp->tso_frames++; <nl>      }
@@ -363,7 +363,7 @@ static GThread *trace_thread_create(GThreadFunc fn) <nl>      sigfillset(&set); <nl>      pthread_sigmask(SIG_SETMASK, &set, &oldset); <nl>  #endif <nl> -    thread = g_thread_create(writeout_thread, NULL, FALSE, NULL); <nl> +    thread = g_thread_create(fn, NULL, FALSE, NULL); <nl>  #ifndef _WIN32 <nl>      pthread_sigmask(SIG_SETMASK, &oldset, NULL); <nl>  #endif
@@ -2768,12 +2768,12 @@ static int vvfat_is_allocated(BlockDriverState *bs, <nl>   <nl>  static int write_target_commit(BlockDriverState *bs, int64_t sector_num, <nl>  	const uint8_t* buffer, int nb_sectors) { <nl> -    BDRVVVFATState* s = bs->opaque; <nl> +    BDRVVVFATState* s = *((BDRVVVFATState**) bs->opaque); <nl>      return try_commit(s); <nl>  } <nl>   <nl>  static void write_target_close(BlockDriverState *bs) { <nl> -    BDRVVVFATState* s = bs->opaque; <nl> +    BDRVVVFATState* s = *((BDRVVVFATState**) bs->opaque); <nl>      bdrv_delete(s->qcow); <nl>      free(s->qcow_filename); <nl>  } <nl> @@ -2816,7 +2816,8 @@ static int enable_write_target(BDRVVVFATState *s) <nl>   <nl>      s->bs->backing_hd = calloc(sizeof(BlockDriverState), 1); <nl>      s->bs->backing_hd->drv = &vvfat_write_target; <nl> -    s->bs->backing_hd->opaque = s; <nl> +    s->bs->backing_hd->opaque = qemu_malloc(sizeof(void*)); <nl> +    *(void**)s->bs->backing_hd->opaque = s; <nl>   <nl>      return 0; <nl>  }
@@ -888,7 +888,7 @@ static void fdctrl_start_transfer (fdctrl_t *fdctrl, int direction) <nl>          fdctrl->data_len = fdctrl->fifo[8]; <nl>      } else { <nl>  	int tmp; <nl> -        fdctrl->data_len = 128 << fdctrl->fifo[5]; <nl> +        fdctrl->data_len = 128 << (fdctrl->fifo[5] > 7 ? 7 : fdctrl->fifo[5]); <nl>          tmp = (cur_drv->last_sect - ks + 1); <nl>          if (fdctrl->fifo[0] & 0x80) <nl>              tmp += cur_drv->last_sect;
@@ -574,6 +574,7 @@ void usb_desc_create_serial(USBDevice *dev) <nl>      } <nl>      dst += snprintf(serial+dst, sizeof(serial)-dst, "-%s", dev->port->path); <nl>      usb_desc_set_string(dev, index, serial); <nl> +    g_free(path); <nl>  } <nl>   <nl>  const char *usb_desc_get_string(USBDevice *dev, uint8_t index)
@@ -296,6 +296,7 @@ static void aml_free(gpointer data, gpointer user_data) <nl>  { <nl>      Aml *var = data; <nl>      build_free_array(var->buf); <nl> +    g_free(var); <nl>  } <nl>   <nl>  Aml *init_aml_allocator(void)
@@ -341,8 +341,13 @@ static void curses_setup(void) <nl>      nodelay(stdscr, TRUE); nonl(); keypad(stdscr, TRUE); <nl>      start_color(); raw(); scrollok(stdscr, FALSE); <nl>   <nl> -    for (i = 0; i < 64; i ++) <nl> +    for (i = 0; i < 64; i++) { <nl>          init_pair(i, colour_default[i & 7], colour_default[i >> 3]); <nl> +    } <nl> +    /* Set default color for more than 64. (monitor uses 0x74xx for example) */ <nl> +    for (i = 64; i < COLOR_PAIRS; i++) { <nl> +        init_pair(i, COLOR_WHITE, COLOR_BLACK); <nl> +    } <nl>  } <nl>   <nl>  static void curses_keyboard_setup(void)
@@ -312,7 +312,11 @@ static int qcow2_check(BlockDriverState *bs, BdrvCheckResult *result, <nl>      } <nl>   <nl>      if (fix && result->check_errors == 0 && result->corruptions == 0) { <nl> -        return qcow2_mark_clean(bs); <nl> +        ret = qcow2_mark_clean(bs); <nl> +        if (ret < 0) { <nl> +            return ret; <nl> +        } <nl> +        return qcow2_mark_consistent(bs); <nl>      } <nl>      return ret; <nl>  }
@@ -335,7 +335,7 @@ void pc_cmos_init(ram_addr_t ram_size, ram_addr_t above_4g_mem_size, <nl>                    ISADevice *s) <nl>  { <nl>      int val, nb, nb_heads, max_track, last_sect, i; <nl> -    FDriveType fd_type[2]; <nl> +    FDriveType fd_type[2] = { FDRIVE_DRV_NONE, FDRIVE_DRV_NONE }; <nl>      BlockDriverState *fd[MAX_FD]; <nl>      static pc_cmos_init_late_arg arg; <nl>   <nl> @@ -385,8 +385,6 @@ void pc_cmos_init(ram_addr_t ram_size, ram_addr_t above_4g_mem_size, <nl>                  bdrv_get_floppy_geometry_hint(fd[i], &nb_heads, &max_track, <nl>                                                &last_sect, FDRIVE_DRV_NONE, <nl>                                                &fd_type[i]); <nl> -            } else { <nl> -                fd_type[i] = FDRIVE_DRV_NONE; <nl>              } <nl>          } <nl>      }
@@ -795,6 +795,13 @@ static const VMStateDescription vmstate_pcie_aer_err = { <nl>      } <nl>  }; <nl>   <nl> +static bool pcie_aer_state_log_num_valid(void *opaque, int version_id) <nl> +{ <nl> +    PCIEAERLog *s = opaque; <nl> + <nl> +    return s->log_num <= s->log_max; <nl> +} <nl> + <nl>  const VMStateDescription vmstate_pcie_aer_log = { <nl>      .name = "PCIE_AER_ERROR_LOG", <nl>      .version_id = 1, <nl> @@ -802,7 +809,8 @@ const VMStateDescription vmstate_pcie_aer_log = { <nl>      .minimum_version_id_old = 1, <nl>      .fields     = (VMStateField[]) { <nl>          VMSTATE_UINT16(log_num, PCIEAERLog), <nl> -        VMSTATE_UINT16(log_max, PCIEAERLog), <nl> +        VMSTATE_UINT16_EQUAL(log_max, PCIEAERLog), <nl> +        VMSTATE_VALIDATE("log_num <= log_max", pcie_aer_state_log_num_valid), <nl>          VMSTATE_STRUCT_VARRAY_POINTER_UINT16(log, PCIEAERLog, log_num, <nl>                                vmstate_pcie_aer_err, PCIEAERErr), <nl>          VMSTATE_END_OF_LIST()
@@ -2107,7 +2107,7 @@ static void disas_ldst_reg_imm9(DisasContext *s, uint32_t insn) <nl>          } <nl>      } else { <nl>          TCGv_i64 tcg_rt = cpu_reg(s, rt); <nl> -        int memidx = is_unpriv ? 1 : get_mem_index(s); <nl> +        int memidx = is_unpriv ? MMU_USER_IDX : get_mem_index(s); <nl>   <nl>          if (is_store) { <nl>              do_gpr_st_memidx(s, tcg_rt, tcg_addr, size, memidx);
@@ -167,6 +167,14 @@ QTestState *qtest_init_without_qmp_handshake(const char *extra_args) <nl>      socket_path = g_strdup_printf("/tmp/qtest-%d.sock", getpid()); <nl>      qmp_socket_path = g_strdup_printf("/tmp/qtest-%d.qmp", getpid()); <nl>   <nl> +    /* It's possible that if an earlier test run crashed it might <nl> +     * have left a stale unix socket lying around. Delete any <nl> +     * stale old socket to avoid spurious test failures with <nl> +     * tests/libqtest.c:70:init_socket: assertion failed (ret != -1): (-1 != -1) <nl> +     */ <nl> +    unlink(socket_path); <nl> +    unlink(qmp_socket_path); <nl> + <nl>      sock = init_socket(socket_path); <nl>      qmpsock = init_socket(qmp_socket_path); <nl>  
@@ -161,6 +161,7 @@ static void test_uuid_unparse_strdup(void) <nl>          } <nl>          out = qemu_uuid_unparse_strdup(&uuid_test_data[i].uuid); <nl>          g_assert_cmpstr(uuid_test_data[i].uuidstr, ==, out); <nl> +        g_free(out); <nl>      } <nl>  } <nl>  
@@ -164,6 +164,8 @@ static void spapr_rtc_class_init(ObjectClass *oc, void *data) <nl>   <nl>      dc->realize = spapr_rtc_realize; <nl>      dc->vmsd = &vmstate_spapr_rtc; <nl> +    /* Reason: This is an internal device only for handling the hypercalls */ <nl> +    dc->user_creatable = false; <nl>   <nl>      spapr_rtas_register(RTAS_GET_TIME_OF_DAY, "get-time-of-day", <nl>                          rtas_get_time_of_day);
@@ -2081,6 +2081,10 @@ static inline void tcg_gen_deposit_i32(TCGv_i32 ret, TCGv_i32 arg1, <nl>      uint32_t mask; <nl>      TCGv_i32 t1; <nl>   <nl> +    tcg_debug_assert(ofs < 32); <nl> +    tcg_debug_assert(len <= 32); <nl> +    tcg_debug_assert(ofs + len <= 32); <nl> + <nl>      if (ofs == 0 && len == 32) { <nl>          tcg_gen_mov_i32(ret, arg2); <nl>          return; <nl> @@ -2112,6 +2116,10 @@ static inline void tcg_gen_deposit_i64(TCGv_i64 ret, TCGv_i64 arg1, <nl>      uint64_t mask; <nl>      TCGv_i64 t1; <nl>   <nl> +    tcg_debug_assert(ofs < 64); <nl> +    tcg_debug_assert(len <= 64); <nl> +    tcg_debug_assert(ofs + len <= 64); <nl> + <nl>      if (ofs == 0 && len == 64) { <nl>          tcg_gen_mov_i64(ret, arg2); <nl>          return;
@@ -1776,7 +1776,12 @@ static int pci_qdev_init(DeviceState *qdev) <nl>          pci_dev->romfile = g_strdup(pc->romfile); <nl>          is_default_rom = true; <nl>      } <nl> -    pci_add_option_rom(pci_dev, is_default_rom); <nl> + <nl> +    rc = pci_add_option_rom(pci_dev, is_default_rom); <nl> +    if (rc != 0) { <nl> +        pci_unregister_device(DEVICE(pci_dev)); <nl> +        return rc; <nl> +    } <nl>   <nl>      return 0; <nl>  }
@@ -13190,6 +13190,9 @@ static void decode_micromips32_opc (CPUMIPSState *env, DisasContext *ctx, <nl>              gen_logic_imm(ctx, OPC_LUI, rs, -1, imm); <nl>              break; <nl>          case SYNCI: <nl> +            /* Break the TB to be able to sync copied instructions <nl> +               immediately */ <nl> +            ctx->bstate = BS_STOP; <nl>              break; <nl>          case BC2F: <nl>          case BC2T: <nl> @@ -16928,7 +16931,9 @@ static void decode_opc (CPUMIPSState *env, DisasContext *ctx) <nl>              break; <nl>          case OPC_SYNCI: <nl>              check_insn(ctx, ISA_MIPS32R2); <nl> -            /* Treat as NOP. */ <nl> +            /* Break the TB to be able to sync copied instructions <nl> +               immediately */ <nl> +            ctx->bstate = BS_STOP; <nl>              break; <nl>          case OPC_BPOSGE32:    /* MIPS DSP branch */ <nl>  #if defined(TARGET_MIPS64)
@@ -157,7 +157,7 @@ static uint64_t coroutine_fn mirror_iteration(MirrorBlockJob *s) <nl>      BlockDriverState *source = s->common.bs; <nl>      int nb_sectors, sectors_per_chunk, nb_chunks; <nl>      int64_t end, sector_num, next_chunk, next_sector, hbitmap_next_sector; <nl> -    uint64_t delay_ns; <nl> +    uint64_t delay_ns = 0; <nl>      MirrorOp *op; <nl>   <nl>      s->sector_num = hbitmap_iter_next(&s->hbi); <nl> @@ -247,8 +247,6 @@ static uint64_t coroutine_fn mirror_iteration(MirrorBlockJob *s) <nl>          next_chunk += added_chunks; <nl>          if (!s->synced && s->common.speed) { <nl>              delay_ns = ratelimit_calculate_delay(&s->limit, added_sectors); <nl> -        } else { <nl> -            delay_ns = 0; <nl>          } <nl>      } while (delay_ns == 0 && next_sector < end); <nl>  
@@ -1083,8 +1083,6 @@ static void config_parse(GAConfig *config, int argc, char **argv) <nl>          { NULL, 0, NULL, 0 } <nl>      }; <nl>   <nl> -    config->log_level = G_LOG_LEVEL_ERROR | G_LOG_LEVEL_CRITICAL; <nl> - <nl>      while ((ch = getopt_long(argc, argv, sopt, lopt, &opt_ind)) != -1) { <nl>          switch (ch) { <nl>          case 'm': <nl> @@ -1332,6 +1330,8 @@ int main(int argc, char **argv) <nl>      GAState *s = g_new0(GAState, 1); <nl>      GAConfig *config = g_new0(GAConfig, 1); <nl>   <nl> +    config->log_level = G_LOG_LEVEL_ERROR | G_LOG_LEVEL_CRITICAL; <nl> + <nl>      module_call_init(MODULE_INIT_QAPI); <nl>   <nl>      init_dfl_pathnames();
@@ -135,7 +135,7 @@ PCIBus *pci_prep_init(qemu_irq *pic) <nl>      int PPC_io_memory; <nl>   <nl>      s = qemu_mallocz(sizeof(PREPPCIState)); <nl> -    s->bus = pci_register_bus(prep_set_irq, prep_map_irq, pic, 0, 2); <nl> +    s->bus = pci_register_bus(prep_set_irq, prep_map_irq, pic, 0, 4); <nl>   <nl>      register_ioport_write(0xcf8, 4, 4, pci_prep_addr_writel, s); <nl>      register_ioport_read(0xcf8, 4, 4, pci_prep_addr_readl, s);
@@ -1012,6 +1012,7 @@ static int parse_add_fd(QemuOpts *opts, void *opaque) <nl>      int fd, dupfd, flags; <nl>      int64_t fdset_id; <nl>      const char *fd_opaque = NULL; <nl> +    AddfdInfo *fdinfo; <nl>   <nl>      fd = qemu_opt_get_number(opts, "fd", -1); <nl>      fdset_id = qemu_opt_get_number(opts, "set", -1); <nl> @@ -1061,8 +1062,9 @@ static int parse_add_fd(QemuOpts *opts, void *opaque) <nl>      } <nl>   <nl>      /* add the duplicate fd, and optionally the opaque string, to the fd set */ <nl> -    monitor_fdset_add_fd(dupfd, true, fdset_id, fd_opaque ? true : false, <nl> -                         fd_opaque, NULL); <nl> +    fdinfo = monitor_fdset_add_fd(dupfd, true, fdset_id, !!fd_opaque, fd_opaque, <nl> +                                  &error_abort); <nl> +    g_free(fdinfo); <nl>   <nl>      return 0; <nl>  }
@@ -1942,6 +1942,15 @@ static int pci_add_option_rom(PCIDevice *pdev, bool is_default_rom) <nl>           * for 0.11 compatibility. <nl>           */ <nl>          int class = pci_get_word(pdev->config + PCI_CLASS_DEVICE); <nl> + <nl> +        /* <nl> +         * Hot-plugged devices can't use the option ROM <nl> +         * if the rom bar is disabled. <nl> +         */ <nl> +        if (DEVICE(pdev)->hotplugged) { <nl> +            return -1; <nl> +        } <nl> + <nl>          if (class == 0x0300) { <nl>              rom_add_vga(pdev->romfile); <nl>          } else {
@@ -1843,6 +1843,7 @@ static void pci_nic_uninit(PCIDevice *pci_dev) <nl>      EEPRO100State *s = DO_UPCAST(EEPRO100State, dev, pci_dev); <nl>   <nl>      vmstate_unregister(&pci_dev->qdev, s->vmstate, s); <nl> +    g_free(s->vmstate); <nl>      eeprom93xx_free(&pci_dev->qdev, s->eeprom); <nl>      qemu_del_nic(s->nic); <nl>  }
@@ -203,6 +203,15 @@ static bool is_version_0 (void *opaque, int version_id) <nl>      return version_id == 0; <nl>  } <nl>   <nl> +static bool vmstate_scoop_validate(void *opaque, int version_id) <nl> +{ <nl> +    ScoopInfo *s = opaque; <nl> + <nl> +    return !(s->prev_level & 0xffff0000) && <nl> +        !(s->gpio_level & 0xffff0000) && <nl> +        !(s->gpio_dir & 0xffff0000); <nl> +} <nl> + <nl>  static const VMStateDescription vmstate_scoop_regs = { <nl>      .name = "scoop", <nl>      .version_id = 1, <nl> @@ -215,6 +224,7 @@ static const VMStateDescription vmstate_scoop_regs = { <nl>          VMSTATE_UINT32(gpio_level, ScoopInfo), <nl>          VMSTATE_UINT32(gpio_dir, ScoopInfo), <nl>          VMSTATE_UINT32(prev_level, ScoopInfo), <nl> +        VMSTATE_VALIDATE("irq levels are 16 bit", vmstate_scoop_validate), <nl>          VMSTATE_UINT16(mcr, ScoopInfo), <nl>          VMSTATE_UINT16(cdr, ScoopInfo), <nl>          VMSTATE_UINT16(ccr, ScoopInfo),
@@ -818,7 +818,7 @@ static inline void gen_op_arith_compute_ov(DisasContext *ctx, TCGv arg0, <nl>          if (is_isa300(ctx)) { <nl>              tcg_gen_extract_tl(cpu_ov32, cpu_ov, 31, 1); <nl>          } <nl> -        tcg_gen_extract_tl(cpu_ov, cpu_ov, 63, 1); <nl> +        tcg_gen_extract_tl(cpu_ov, cpu_ov, TARGET_LONG_BITS - 1, 1); <nl>      } <nl>      tcg_gen_or_tl(cpu_so, cpu_so, cpu_ov); <nl>  }
@@ -204,7 +204,7 @@ void target_disas(FILE *out, target_ulong code, target_ulong size, int flags) <nl>      return; <nl>  #endif <nl>   <nl> -    for (pc = code; pc < code + size; pc += count) { <nl> +    for (pc = code; size > 0; pc += count, size -= count) { <nl>  	fprintf(out, "0x" TARGET_FMT_lx ":  ", pc); <nl>  	count = print_insn(pc, &disasm_info); <nl>  #if 0 <nl> @@ -276,7 +276,7 @@ void disas(FILE *out, void *code, unsigned long size) <nl>  	    (long) code); <nl>      return; <nl>  #endif <nl> -    for (pc = (unsigned long)code; pc < (unsigned long)code + size; pc += count) { <nl> +    for (pc = (unsigned long)code; size > 0; pc += count, size -= count) { <nl>  	fprintf(out, "0x%08lx:  ", pc); <nl>  #ifdef __arm__ <nl>          /* since data is included in the code, it is better to
@@ -587,6 +587,10 @@ int cpu_exec(CPUState *env) <nl>                  /* reset soft MMU for next block (it can currently <nl>                     only be set by a memory fault) */ <nl>              } /* for(;;) */ <nl> +        } else { <nl> +            /* Reload env after longjmp - the compiler may have smashed all <nl> +             * local variables as longjmp is marked 'noreturn'. */ <nl> +            env = cpu_single_env; <nl>          } <nl>      } /* for(;;) */ <nl>  
@@ -909,7 +909,7 @@ static int scsi_req_length(SCSICommand *cmd, SCSIDevice *dev, uint8_t *buf) <nl>      case VERIFY_16: <nl>          if ((buf[1] & 2) == 0) { <nl>              cmd->xfer = 0; <nl> -        } else if ((buf[1] & 4) == 1) { <nl> +        } else if ((buf[1] & 4) != 0) { <nl>              cmd->xfer = 1; <nl>          } <nl>          cmd->xfer *= dev->blocksize;
@@ -1546,7 +1546,17 @@ static void load_symbols(struct elfhdr *hdr, int fd, abi_ulong load_bias) <nl>          } <nl>      } <nl>   <nl> +    /* Attempt to free the storage associated with the local symbols <nl> +       that we threw away.  Whether or not this has any effect on the <nl> +       memory allocation depends on the malloc implementation and how <nl> +       many symbols we managed to discard.  */ <nl>      syms = realloc(syms, nsyms * sizeof(*syms)); <nl> +    if (syms == NULL) { <nl> +        free(s); <nl> +        free(strings); <nl> +        return; <nl> +    } <nl> + <nl>      qsort(syms, nsyms, sizeof(*syms), symcmp); <nl>   <nl>      s->disas_num_syms = nsyms;
@@ -222,6 +222,7 @@ static void init_blk_migration(Monitor *mon, QEMUFile *f) <nl>  { <nl>      BlkMigDevState *bmds; <nl>      BlockDriverState *bs; <nl> +    int64_t sectors; <nl>   <nl>      block_mig_state.submitted = 0; <nl>      block_mig_state.read_done = 0; <nl> @@ -231,14 +232,19 @@ static void init_blk_migration(Monitor *mon, QEMUFile *f) <nl>   <nl>      for (bs = bdrv_first; bs != NULL; bs = bs->next) { <nl>          if (bs->type == BDRV_TYPE_HD) { <nl> +            sectors = bdrv_getlength(bs) >> BDRV_SECTOR_BITS; <nl> +            if (sectors == 0) { <nl> +                continue; <nl> +            } <nl> + <nl>              bmds = qemu_mallocz(sizeof(BlkMigDevState)); <nl>              bmds->bs = bs; <nl>              bmds->bulk_completed = 0; <nl> -            bmds->total_sectors = bdrv_getlength(bs) >> BDRV_SECTOR_BITS; <nl> +            bmds->total_sectors = sectors; <nl>              bmds->completed_sectors = 0; <nl>              bmds->shared_base = block_mig_state.shared_base; <nl>   <nl> -            block_mig_state.total_sector_sum += bmds->total_sectors; <nl> +            block_mig_state.total_sector_sum += sectors; <nl>   <nl>              if (bmds->shared_base) { <nl>                  monitor_printf(mon, "Start migration for %s with shared base "
@@ -317,7 +317,7 @@ static int dmg_read_resource_fork(BlockDriverState *bs, DmgHeaderState *ds, <nl>          ret = read_uint32(bs, offset, &count); <nl>          if (ret < 0) { <nl>              goto fail; <nl> -        } else if (count == 0) { <nl> +        } else if (count == 0 || count > info_end - offset) { <nl>              ret = -EINVAL; <nl>              goto fail; <nl>          } <nl> @@ -377,6 +377,11 @@ static int dmg_open(BlockDriverState *bs, QDict *options, int flags, <nl>      if (ret < 0) { <nl>          goto fail; <nl>      } <nl> +    if (rsrc_fork_offset >= offset || <nl> +        rsrc_fork_length > offset - rsrc_fork_offset) { <nl> +        ret = -EINVAL; <nl> +        goto fail; <nl> +    } <nl>      if (rsrc_fork_length != 0) { <nl>          ret = dmg_read_resource_fork(bs, &ds, <nl>                                       rsrc_fork_offset, rsrc_fork_length);
@@ -209,6 +209,10 @@ void virtio_queue_set_notification(VirtQueue *vq, int enable) <nl>      } else { <nl>          vring_used_flags_set_bit(vq, VRING_USED_F_NO_NOTIFY); <nl>      } <nl> +    if (enable) { <nl> +        /* Expose avail event/used flags before caller checks the avail idx. */ <nl> +        smp_mb(); <nl> +    } <nl>  } <nl>   <nl>  int virtio_queue_ready(VirtQueue *vq)
@@ -750,7 +750,6 @@ static void vscsi_report_luns(VSCSIState *s, vscsi_req *req) <nl>      len = n+8; <nl>   <nl>      resp_data = g_malloc0(len); <nl> -    memset(resp_data, 0, len); <nl>      stl_be_p(resp_data, n); <nl>      i = found_lun0 ? 8 : 16; <nl>      QTAILQ_FOREACH(kid, &s->bus.qbus.children, sibling) {
@@ -137,7 +137,7 @@ static void do_flush_queued_data(VirtIOSerialPort *port, VirtQueue *vq, <nl>   <nl>  static void flush_queued_data(VirtIOSerialPort *port, bool discard) <nl>  { <nl> -    assert(port || discard); <nl> +    assert(port); <nl>   <nl>      do_flush_queued_data(port, port->ovq, &port->vser->vdev, discard); <nl>  }
@@ -2387,8 +2387,10 @@ static void coroutine_fn v9fs_flush(void *opaque) <nl>           * Wait for pdu to complete. <nl>           */ <nl>          qemu_co_queue_wait(&cancel_pdu->complete, NULL); <nl> -        cancel_pdu->cancelled = 0; <nl> -        pdu_free(cancel_pdu); <nl> +        if (!qemu_co_queue_next(&cancel_pdu->complete)) { <nl> +            cancel_pdu->cancelled = 0; <nl> +            pdu_free(cancel_pdu); <nl> +        } <nl>      } <nl>      pdu_complete(pdu, 7); <nl>  }
@@ -1722,12 +1722,19 @@ void address_space_init(AddressSpace *as, MemoryRegion *root, const char *name) <nl>   <nl>  void address_space_destroy(AddressSpace *as) <nl>  { <nl> +    MemoryListener *listener; <nl> + <nl>      /* Flush out anything from MemoryListeners listening in on this */ <nl>      memory_region_transaction_begin(); <nl>      as->root = NULL; <nl>      memory_region_transaction_commit(); <nl>      QTAILQ_REMOVE(&address_spaces, as, address_spaces_link); <nl>      address_space_destroy_dispatch(as); <nl> + <nl> +    QTAILQ_FOREACH(listener, &memory_listeners, link) { <nl> +        assert(listener->address_space_filter != as); <nl> +    } <nl> + <nl>      flatview_unref(as->current_map); <nl>      g_free(as->name); <nl>      g_free(as->ioeventfds);
@@ -1392,6 +1392,12 @@ static void spapr_phb_realize(DeviceState *dev, Error **errp) <nl>          return; <nl>      } <nl>   <nl> +    if (sphb->numa_node != -1 && <nl> +        (sphb->numa_node >= MAX_NODES || !numa_info[sphb->numa_node].present)) { <nl> +        error_setg(errp, "Invalid NUMA node ID for PCI host bridge"); <nl> +        return; <nl> +    } <nl> + <nl>      sphb->dtbusname = g_strdup_printf("pci@%" PRIx64, sphb->buid); <nl>   <nl>      namebuf = alloca(strlen(sphb->dtbusname) + 32); <nl> @@ -1880,7 +1886,7 @@ int spapr_populate_pci_dt(sPAPRPHBState *phb, <nl>      } <nl>   <nl>      /* Advertise NUMA via ibm,associativity */ <nl> -    if (nb_numa_nodes > 1) { <nl> +    if (phb->numa_node != -1) { <nl>          _FDT(fdt_setprop(fdt, bus_off, "ibm,associativity", associativity, <nl>                           sizeof(associativity))); <nl>      }
@@ -3077,9 +3077,7 @@ static BlockDriverAIOCB *bdrv_aio_rw_vector(BlockDriverState *bs, <nl>      acb->is_write = is_write; <nl>      acb->qiov = qiov; <nl>      acb->bounce = qemu_blockalign(bs, qiov->size); <nl> - <nl> -    if (!acb->bh) <nl> -        acb->bh = qemu_bh_new(bdrv_aio_bh_cb, acb); <nl> +    acb->bh = qemu_bh_new(bdrv_aio_bh_cb, acb); <nl>   <nl>      if (is_write) { <nl>          qemu_iovec_to_buffer(acb->qiov, acb->bounce);
@@ -185,6 +185,9 @@ e1000_link_up(E1000State *s) <nl>  { <nl>      s->mac_reg[STATUS] |= E1000_STATUS_LU; <nl>      s->phy_reg[PHY_STATUS] |= MII_SR_LINK_STATUS; <nl> + <nl> +    /* E1000_STATUS_LU is tested by e1000_can_receive() */ <nl> +    qemu_flush_queued_packets(qemu_get_queue(s->nic)); <nl>  } <nl>   <nl>  static bool
@@ -1410,7 +1410,12 @@ static void schedule_mkdir(BDRVVVFATState* s, uint32_t cluster, char* path) <nl>  } <nl>   <nl>  typedef struct { <nl> -    unsigned char name[1024]; <nl> +    /* <nl> +     * Since the sequence number is at most 0x3f, and the filename <nl> +     * length is at most 13 times the sequence number, the maximal <nl> +     * filename length is 0x3f * 13 bytes. <nl> +     */ <nl> +    unsigned char name[0x3f * 13 + 1]; <nl>      int checksum, len; <nl>      int sequence_number; <nl>  } long_file_name;
@@ -128,11 +128,17 @@ static int qcow_open(BlockDriverState *bs, QDict *options, int flags, <nl>          goto fail; <nl>      } <nl>   <nl> -    if (header.size <= 1 || header.cluster_bits < 9) { <nl> -        error_setg(errp, "invalid value in qcow header"); <nl> +    if (header.size <= 1) { <nl> +        error_setg(errp, "Image size is too small (must be at least 2 bytes)"); <nl>          ret = -EINVAL; <nl>          goto fail; <nl>      } <nl> +    if (header.cluster_bits < 9 || header.cluster_bits > 16) { <nl> +        error_setg(errp, "Cluster size must be between 512 and 64k"); <nl> +        ret = -EINVAL; <nl> +        goto fail; <nl> +    } <nl> + <nl>      if (header.crypt_method > QCOW_CRYPT_AES) { <nl>          error_setg(errp, "invalid encryption method in qcow header"); <nl>          ret = -EINVAL;
@@ -407,6 +407,7 @@ struct omap_gpmc_s *omap_gpmc_init(target_phys_addr_t base, qemu_irq irq) <nl>      memory_region_init_io(&s->iomem, &omap_gpmc_ops, s, "omap-gpmc", 0x1000); <nl>      memory_region_add_subregion(get_system_memory(), base, &s->iomem); <nl>   <nl> +    s->irq = irq; <nl>      omap_gpmc_reset(s); <nl>   <nl>      return s;
@@ -3470,6 +3470,7 @@ int kvm_arch_release_virq_post(int virq) <nl>          if (entry->virq == virq) { <nl>              trace_kvm_x86_remove_msi_route(virq); <nl>              QLIST_REMOVE(entry, list); <nl> +            g_free(entry); <nl>              break; <nl>          } <nl>      }
@@ -1506,7 +1506,7 @@ int bdrv_commit(BlockDriverState *bs) <nl>      int n, ro, open_flags; <nl>      int ret = 0; <nl>      uint8_t *buf; <nl> -    char filename[1024]; <nl> +    char filename[PATH_MAX]; <nl>   <nl>      if (!drv) <nl>          return -ENOMEDIUM; <nl> @@ -1520,7 +1520,8 @@ int bdrv_commit(BlockDriverState *bs) <nl>      } <nl>   <nl>      ro = bs->backing_hd->read_only; <nl> -    strncpy(filename, bs->backing_hd->filename, sizeof(filename)); <nl> +    /* Use pstrcpy (not strncpy): filename must be NUL-terminated. */ <nl> +    pstrcpy(filename, sizeof(filename), bs->backing_hd->filename); <nl>      open_flags =  bs->backing_hd->open_flags; <nl>   <nl>      if (ro) {
@@ -55,7 +55,7 @@ static void clipper_init(MachineState *machine) <nl>      ISABus *isa_bus; <nl>      qemu_irq rtc_irq; <nl>      long size, i; <nl> -    const char *palcode_filename; <nl> +    char *palcode_filename; <nl>      uint64_t palcode_entry, palcode_low, palcode_high; <nl>      uint64_t kernel_entry, kernel_low, kernel_high; <nl>   <nl> @@ -101,8 +101,8 @@ static void clipper_init(MachineState *machine) <nl>      /* Load PALcode.  Given that this is not "real" cpu palcode, <nl>         but one explicitly written for the emulation, we might as <nl>         well load it directly from and ELF image.  */ <nl> -    palcode_filename = (bios_name ? bios_name : "palcode-clipper"); <nl> -    palcode_filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, palcode_filename); <nl> +    palcode_filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, <nl> +                                bios_name ? bios_name : "palcode-clipper"); <nl>      if (palcode_filename == NULL) { <nl>          hw_error("no palcode provided\n"); <nl>          exit(1); <nl> @@ -114,6 +114,7 @@ static void clipper_init(MachineState *machine) <nl>          hw_error("could not load palcode '%s'\n", palcode_filename); <nl>          exit(1); <nl>      } <nl> +    g_free(palcode_filename); <nl>   <nl>      /* Start all cpus at the PALcode RESET entry point.  */ <nl>      for (i = 0; i < smp_cpus; ++i) {
@@ -140,6 +140,7 @@ static int qio_channel_buffer_close(QIOChannel *ioc, <nl>      QIOChannelBuffer *bioc = QIO_CHANNEL_BUFFER(ioc); <nl>   <nl>      g_free(bioc->data); <nl> +    bioc->data = NULL; <nl>      bioc->capacity = bioc->usage = bioc->offset = 0; <nl>   <nl>      return 0;
@@ -9319,6 +9319,8 @@ void cpu_dump_state (CPUPPCState *env, FILE *f, fprintf_function cpu_fprintf, <nl>   <nl>      int i; <nl>   <nl> +    cpu_synchronize_state(env); <nl> + <nl>      cpu_fprintf(f, "NIP " TARGET_FMT_lx "   LR " TARGET_FMT_lx " CTR " <nl>                  TARGET_FMT_lx " XER " TARGET_FMT_lx "\n", <nl>                  env->nip, env->lr, env->ctr, env->xer);
@@ -223,6 +223,11 @@ static void handle_control_message(VirtIOSerial *vser, void *buf) <nl>   <nl>      switch(cpkt.event) { <nl>      case VIRTIO_CONSOLE_DEVICE_READY: <nl> +        if (!cpkt.value) { <nl> +            error_report("virtio-serial-bus: Guest failure in adding device %s\n", <nl> +                         vser->bus->qbus.name); <nl> +            break; <nl> +        } <nl>          /* <nl>           * The device is up, we can now tell the device about all the <nl>           * ports we have here. <nl> @@ -233,6 +238,11 @@ static void handle_control_message(VirtIOSerial *vser, void *buf) <nl>          break; <nl>   <nl>      case VIRTIO_CONSOLE_PORT_READY: <nl> +        if (!cpkt.value) { <nl> +            error_report("virtio-serial-bus: Guest failure in adding port %u for device %s\n", <nl> +                         port->id, vser->bus->qbus.name); <nl> +            break; <nl> +        } <nl>          /* <nl>           * Now that we know the guest asked for the port name, we're <nl>           * sure the guest has initialised whatever state is necessary
@@ -228,6 +228,10 @@ VIOsPAPRDevice *vty_lookup(sPAPRMachineState *spapr, target_ulong reg) <nl>          return spapr_vty_get_default(spapr->vio_bus); <nl>      } <nl>   <nl> +    if (!object_dynamic_cast(OBJECT(sdev), TYPE_VIO_SPAPR_VTY_DEVICE)) { <nl> +        return NULL; <nl> +    } <nl> + <nl>      return sdev; <nl>  } <nl>  
@@ -35,6 +35,7 @@ <nl>  #include "qemu/error-report.h" <nl>  #include "hw/hotplug.h" <nl>  #include "hw/boards.h" <nl> +#include "hw/sysbus.h" <nl>  #include "qapi-event.h" <nl>   <nl>  int qdev_hotplug = 0; <nl> @@ -140,6 +141,12 @@ DeviceState *qdev_try_create(BusState *bus, const char *type) <nl>      } <nl>   <nl>      if (!bus) { <nl> +        /* Assert that the device really is a SysBusDevice before <nl> +         * we put it onto the sysbus. Non-sysbus devices which aren't <nl> +         * being put onto a bus should be created with object_new(TYPE_FOO), <nl> +         * not qdev_create(NULL, TYPE_FOO). <nl> +         */ <nl> +        g_assert(object_dynamic_cast(OBJECT(dev), TYPE_SYS_BUS_DEVICE)); <nl>          bus = sysbus_get_default(); <nl>      } <nl>  
@@ -233,11 +233,11 @@ void qio_channel_test_run_reader(QIOChannelTest *test, <nl>   <nl>  void qio_channel_test_validate(QIOChannelTest *test) <nl>  { <nl> +    g_assert(test->readerr == NULL); <nl> +    g_assert(test->writeerr == NULL); <nl>      g_assert_cmpint(memcmp(test->input, <nl>                             test->output, <nl>                             test->len), ==, 0); <nl> -    g_assert(test->readerr == NULL); <nl> -    g_assert(test->writeerr == NULL); <nl>   <nl>      g_free(test->inputv); <nl>      g_free(test->outputv);
@@ -152,7 +152,7 @@ const char *path(const char *name) <nl>  { <nl>      /* Only do absolute paths: quick and dirty, but should mostly be OK. <nl>         Could do relative by tracking cwd. */ <nl> -    if (!base || name[0] != '/') <nl> +    if (!base || !name || name[0] != '/') <nl>  	return name; <nl>   <nl>      return follow_path(base, name) ?: name;
@@ -3234,7 +3234,7 @@ static void coroutine_fn v9fs_xattrwalk(void *opaque) <nl>          xattr_fidp->fid_type = P9_FID_XATTR; <nl>          xattr_fidp->fs.xattr.xattrwalk_fid = true; <nl>          if (size) { <nl> -            xattr_fidp->fs.xattr.value = g_malloc(size); <nl> +            xattr_fidp->fs.xattr.value = g_malloc0(size); <nl>              err = v9fs_co_llistxattr(pdu, &xattr_fidp->path, <nl>                                       xattr_fidp->fs.xattr.value, <nl>                                       xattr_fidp->fs.xattr.len); <nl> @@ -3267,7 +3267,7 @@ static void coroutine_fn v9fs_xattrwalk(void *opaque) <nl>          xattr_fidp->fid_type = P9_FID_XATTR; <nl>          xattr_fidp->fs.xattr.xattrwalk_fid = true; <nl>          if (size) { <nl> -            xattr_fidp->fs.xattr.value = g_malloc(size); <nl> +            xattr_fidp->fs.xattr.value = g_malloc0(size); <nl>              err = v9fs_co_lgetxattr(pdu, &xattr_fidp->path, <nl>                                      &name, xattr_fidp->fs.xattr.value, <nl>                                      xattr_fidp->fs.xattr.len);
@@ -1875,6 +1875,7 @@ static int pci_add_option_rom(PCIDevice *pdev, bool is_default_rom) <nl>      if (size < 0) { <nl>          error_report("%s: failed to find romfile \"%s\"", <nl>                       __FUNCTION__, pdev->romfile); <nl> +        qemu_free(path); <nl>          return -1; <nl>      } <nl>      if (size & (size - 1)) {
@@ -499,14 +499,18 @@ iscsi_allocmap_update(IscsiLun *iscsilun, int64_t sector_num, <nl>      if (allocated) { <nl>          bitmap_set(iscsilun->allocmap, cl_num_expanded, nb_cls_expanded); <nl>      } else { <nl> -        bitmap_clear(iscsilun->allocmap, cl_num_shrunk, nb_cls_shrunk); <nl> +        if (nb_cls_shrunk > 0) { <nl> +            bitmap_clear(iscsilun->allocmap, cl_num_shrunk, nb_cls_shrunk); <nl> +        } <nl>      } <nl>   <nl>      if (iscsilun->allocmap_valid == NULL) { <nl>          return; <nl>      } <nl>      if (valid) { <nl> -        bitmap_set(iscsilun->allocmap_valid, cl_num_shrunk, nb_cls_shrunk); <nl> +        if (nb_cls_shrunk > 0) { <nl> +            bitmap_set(iscsilun->allocmap_valid, cl_num_shrunk, nb_cls_shrunk); <nl> +        } <nl>      } else { <nl>          bitmap_clear(iscsilun->allocmap_valid, cl_num_expanded, <nl>                       nb_cls_expanded);
@@ -182,13 +182,19 @@ static void virtio_scsi_vring_teardown(VirtIOSCSI *s) <nl>   <nl>      if (s->ctrl_vring) { <nl>          vring_teardown(&s->ctrl_vring->vring, vdev, 0); <nl> +        g_slice_free(VirtIOSCSIVring, s->ctrl_vring); <nl> +        s->ctrl_vring = NULL; <nl>      } <nl>      if (s->event_vring) { <nl>          vring_teardown(&s->event_vring->vring, vdev, 1); <nl> +        g_slice_free(VirtIOSCSIVring, s->event_vring); <nl> +        s->event_vring = NULL; <nl>      } <nl>      if (s->cmd_vrings) { <nl>          for (i = 0; i < vs->conf.num_queues && s->cmd_vrings[i]; i++) { <nl>              vring_teardown(&s->cmd_vrings[i]->vring, vdev, 2 + i); <nl> +            g_slice_free(VirtIOSCSIVring, s->cmd_vrings[i]); <nl> +            s->cmd_vrings[i] = NULL; <nl>          } <nl>          free(s->cmd_vrings); <nl>          s->cmd_vrings = NULL;
@@ -3454,7 +3454,7 @@ int v9fs_device_realize_common(V9fsState *s, Error **errp) <nl>      /* initialize pdu allocator */ <nl>      QLIST_INIT(&s->free_list); <nl>      QLIST_INIT(&s->active_list); <nl> -    for (i = 0; i < (MAX_REQ - 1); i++) { <nl> +    for (i = 0; i < MAX_REQ; i++) { <nl>          QLIST_INSERT_HEAD(&s->free_list, &s->pdus[i], next); <nl>          s->pdus[i].s = s; <nl>          s->pdus[i].idx = i;
@@ -999,7 +999,7 @@ int vhost_dev_enable_notifiers(struct vhost_dev *hdev, VirtIODevice *vdev) <nl>      BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(vdev))); <nl>      VirtioBusState *vbus = VIRTIO_BUS(qbus); <nl>      VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(vbus); <nl> -    int i, r; <nl> +    int i, r, e; <nl>      if (!k->set_host_notifier) { <nl>          fprintf(stderr, "binding does not support host notifiers\n"); <nl>          r = -ENOSYS; <nl> @@ -1017,12 +1017,12 @@ int vhost_dev_enable_notifiers(struct vhost_dev *hdev, VirtIODevice *vdev) <nl>      return 0; <nl>  fail_vq: <nl>      while (--i >= 0) { <nl> -        r = k->set_host_notifier(qbus->parent, hdev->vq_index + i, false); <nl> -        if (r < 0) { <nl> +        e = k->set_host_notifier(qbus->parent, hdev->vq_index + i, false); <nl> +        if (e < 0) { <nl>              fprintf(stderr, "vhost VQ %d notifier cleanup error: %d\n", i, -r); <nl>              fflush(stderr); <nl>          } <nl> -        assert (r >= 0); <nl> +        assert (e >= 0); <nl>      } <nl>  fail: <nl>      return r;
@@ -26,7 +26,7 @@ void *qemu_ram_mmap(int fd, size_t size, size_t align, bool shared) <nl>      void *ptr1; <nl>   <nl>      if (ptr == MAP_FAILED) { <nl> -        return NULL; <nl> +        return MAP_FAILED; <nl>      } <nl>   <nl>      /* Make sure align is a power of 2 */ <nl> @@ -41,7 +41,7 @@ void *qemu_ram_mmap(int fd, size_t size, size_t align, bool shared) <nl>                  fd, 0); <nl>      if (ptr1 == MAP_FAILED) { <nl>          munmap(ptr, total); <nl> -        return NULL; <nl> +        return MAP_FAILED; <nl>      } <nl>   <nl>      ptr += offset;
@@ -203,7 +203,7 @@ size_t mptsas_config_manufacturing_1(MPTSASState *s, uint8_t **data, int address <nl>  { <nl>      /* VPD - all zeros */ <nl>      return MPTSAS_CONFIG_PACK(1, MPI_CONFIG_PAGETYPE_MANUFACTURING, 0x00, <nl> -                              "s256"); <nl> +                              "*s256"); <nl>  } <nl>   <nl>  static <nl> @@ -328,7 +328,7 @@ size_t mptsas_config_ioc_0(MPTSASState *s, uint8_t **data, int address) <nl>      return MPTSAS_CONFIG_PACK(0, MPI_CONFIG_PAGETYPE_IOC, 0x01, <nl>                                "*l*lwwb*b*b*blww", <nl>                                pcic->vendor_id, pcic->device_id, pcic->revision, <nl> -                              pcic->subsystem_vendor_id, <nl> +                              pcic->class_id, pcic->subsystem_vendor_id, <nl>                                pcic->subsystem_id); <nl>  } <nl>  
@@ -2581,7 +2581,7 @@ static void ds_print_op_push_info(RDisasmState *ds){ <nl>  	case R_ANAL_OP_TYPE_PUSH: <nl>  		if (ds->analop.val) { <nl>  			RFlagItem *flag = r_flag_get_i (ds->core->flags, ds->analop.val); <nl> -			if (flag && (!ds->opstr || !strstr(ds->opstr, flag->name))) { <nl> +			if (flag && !strstr (ds->opstr, flag->name)) { <nl>  				r_cons_printf (" ; %s", flag->name); <nl>  			} <nl>  		} <nl> @@ -2659,7 +2659,7 @@ static void ds_print_ptr(RDisasmState *ds, int len, int idx) { <nl>  				} <nl>  				ALIGN; <nl>  				if (!is_lea_str) { <nl> -					if (ds->opstr && *flag && strstr (ds->opstr, flag)) { <nl> +					if (*flag && strstr (ds->opstr, flag)) { <nl>  						ds_comment (ds, true, "%s; 0x%" PFMT64x "%s", esc, refaddr, nl); <nl>  					} else { <nl>  						ds_comment (ds, true, "%s; 0x%" PFMT64x "%s%s%s", esc, refaddr, <nl> @@ -3664,7 +3664,11 @@ toro: <nl>   <nl>  		if (ds->show_comments && !ds->show_comment_right) { <nl>  			ds_show_refs (ds); <nl> +			ds_build_op_str (ds); <nl>  			ds_print_ptr (ds, len + 256, idx); <nl> +			if (!ds->pseudo) { <nl> +				R_FREE (ds->opstr); <nl> +			} <nl>  			ds_print_fcn_name (ds); <nl>  			ds_print_color_reset (ds); <nl>  			if (ds->show_emu) {
@@ -92,6 +92,7 @@ R_API RList *r_io_map_get_maps_in_range(RIO *io, ut64 addr, ut64 endaddr) { <nl>  	RIOMap *map; <nl>  	RListIter *iter; <nl>  	RList *maps = r_list_new (); <nl> +	maps->free = NULL; <nl>  	r_list_foreach (io->maps, iter, map) { <nl>  		if (map->from <= addr && addr < map->to) r_list_append(maps, map); <nl>  		//if (map->from == addr && endaddr == map->to) r_list_append(maps, map);
@@ -700,6 +700,10 @@ static Sdb *store_versioninfo_gnu_verneed(struct Elf_(r_bin_elf_obj_t) *bin, Elf <nl>  			snprintf (key, sizeof (key), "vernaux%d", j); <nl>  			sdb_ns_set (sdb_version, key, sdb_vernaux); <nl>  		} <nl> +		if ((int)entry->vn_next < 0) { <nl> +			eprintf ("Invalid vn_next\n"); <nl> +			break; <nl> +		} <nl>  		i += entry->vn_next; <nl>  		snprintf (key, sizeof (key), "version%d", cnt ); <nl>  		sdb_ns_set (sdb, key, sdb_version);
@@ -285,7 +285,6 @@ static int filter(RParse *p, RFlag *f, char *data, char *str, int len, bool big_ <nl>  						char *ptr_end = str + strlen (data) + flag_len - 1; <nl>  						char *ptr_right = ptr_end + 1, *ptr_left, *ptr_esc; <nl>  						bool ansi_found = false; <nl> -						int copied_len; <nl>  						while (*ptr_right) { <nl>  							if (*ptr_right == 0x1b) { <nl>  								while (*ptr_right && *ptr_right != 'm') ptr_right++; <nl> @@ -311,11 +310,14 @@ static int filter(RParse *p, RFlag *f, char *data, char *str, int len, bool big_ <nl>  								if (ptr_esc < str) { <nl>  									ptr_esc = ptr_end - flag_len + 1; <nl>  								} <nl> -								copied_len = ptr_end - ptr_esc + 1; <nl> +								int copied_len = ptr_end - ptr_esc + 1; <nl> +								if (copied_len < 1) { <nl> +									break; <nl> +								} <nl>  								memmove (ptr_left, ptr_esc, copied_len); <nl>  								sprintf (ptr_left + copied_len, "%s%s", <nl> -									 ansi_found && ptr_right - ptr_end + 1 >= 4 ? "\x1b[0m" : "", <nl> -									 ptr_right + 1); <nl> +										ansi_found && ptr_right - ptr_end + 1 >= 4 ? "\x1b[0m" : "", <nl> +										ptr_right + 1); <nl>  							} <nl>  							break; <nl>  						}
@@ -763,8 +763,9 @@ static int (*first_nibble_decode[])(RAnal*,RAnalOp*,ut16) = { <nl>  static int sh_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) { <nl>  	ut8 op_MSB,op_LSB; <nl>  	int ret; <nl> -	if (!data) <nl> +	if (!data || len < 2) { <nl>  		return 0; <nl> +	} <nl>  	memset (op, '\0', sizeof (RAnalOp)); <nl>  	op->addr = addr; <nl>  	op->type = R_ANAL_OP_TYPE_UNK;
@@ -436,6 +436,7 @@ static int r_core_search_rop(RCore *core, ut64 from, ut64 to, int opt, const cha <nl>  	} <nl>  	if (mode == 'j') <nl>  		r_cons_printf ("]\n"); <nl> +	free (buf); <nl>  	return R_TRUE; <nl>  } <nl>  
@@ -192,7 +192,7 @@ static int cmd_type(void *data, const char *input) { <nl>  					free (fmt); <nl>  				}// else eprintf ("Cannot find '%s' type\n", input+1); <nl>  				r_cons_printf ("}\n"); <nl> -			} else eprintf ("Cant find type at 0x%llx\n", addr); <nl> +			} //else eprintf ("Cant find type at 0x%llx\n", addr); <nl>  		 } <nl>  		break; <nl>  	case '?':
@@ -247,7 +247,7 @@ static int cmd_type(void *data, const char *input) { <nl>  				NULL }; <nl>  			r_core_cmd_help (core, help_message); <nl>  			r_cons_printf ("Note: The td command should be put between double quotes\n" <nl> -				"Exapmle: \" td struct foo {int bar;int cow};\"" <nl> +				"Example: \" td struct foo {int bar;int cow};\"" <nl>  				"\nt"); <nl>   <nl>  		} else if (input[1] == ' ') {
@@ -1968,8 +1968,13 @@ static int opout(RAsm *a, ut8 *data, const Opcode *op) { <nl>  			data[l++] = 0xe7; <nl>  		} else if (op->operands[1].reg == X86R_EAX && op->operands[1].type & OT_DWORD) { <nl>  			data[l++] = 0xe7; <nl> +		} else { <nl> +			// TODO: this is wrong <nl> +			data[l++] = 0xe7; <nl>  		} <nl>  		data[l++] = immediate; <nl> +	} else { <nl> +		return -1; <nl>  	} <nl>  	return l; <nl>  }
@@ -394,8 +394,12 @@ static int cmd_cmp(void *data, const char *input) { <nl>  			strlen (input + 2) + 1, '*'); <nl>  		break; <nl>  	case ' ': <nl> -		val = radare_compare (core, core->block, (ut8*)input+1, <nl> -			strlen (input + 1) + 1, 0); <nl> +		{ <nl> +			char *str = strdup (input + 1); <nl> +			int len = r_str_unescape (str); <nl> +			val = radare_compare (core, core->block, (ut8*)str, len, 0); <nl> +			free (str); <nl> +		} <nl>  		break; <nl>  	case 'x': <nl>  		switch (input[1]) {
@@ -164,7 +164,8 @@ static int r_line_readchar_win(int *vch) { // this function handle the input in <nl>  	if (I.zerosep) { <nl>  		*vch = 0; <nl>  		buf[0] = 0; <nl> -		read (0, buf, 1); <nl> +		if (read (0, buf, 1) != 1) <nl> +			return -1; <nl>  		return buf[0]; <nl>  	} <nl>  
@@ -142,7 +142,7 @@ static int string_scan_range (RList *list, const ut8 *buf, int min, const ut64 f <nl>  		str_start = needle; <nl>   <nl>  		/* Eat a whole C string */ <nl> -		for (rc = i = 0; i < sizeof (tmp) - 1 && needle < to; i += rc) { <nl> +		for (rc = i = 0; i < sizeof (tmp) - 2 && needle < to; i += rc) { <nl>  			RRune r; <nl>   <nl>  			if (str_type == R_STRING_TYPE_WIDE) {
@@ -1739,7 +1739,7 @@ R_API int r_core_anal_fcn_list(RCore *core, const char *input, int rad) { <nl>  	r_list_sort (fcns, &cmpfcn); <nl>  	fcnlist_gather_metadata (fcns); <nl>   <nl> -	if (input) {		// input points to a filter argument <nl> +	if (input && *input) {// input points to a filter argument <nl>  		ut64 addr; <nl>  		addr = core->offset; <nl>  		if (*input) { <nl> @@ -1782,7 +1782,8 @@ R_API int r_core_anal_fcn_list(RCore *core, const char *input, int rad) { <nl>  		fcn_list_default (core, fcns, false); <nl>  		break; <nl>  	} <nl> -	if (input) { <nl> +	//make sure you don't free core->anal->fcns <nl> +	if (input && core->anal->fcns != fcns) { <nl>  		// The list does not own the its members, so don't purge. <nl>  		free (fcns); <nl>  	}
@@ -999,6 +999,9 @@ if ( <nl>  #endif <nl>  					nsym) == -1) { <nl>  				eprintf ("Warning: read (sym)\n"); <nl> +				free (ret); <nl> +				free (sym); <nl> +				free (strtab); <nl>  				return NULL; <nl>  			} <nl>  			for (j = k = ret_ctr = 0; j < bin->shdr[i].sh_size; j += sizeof (Elf_(Sym)), k++) {
@@ -749,7 +749,7 @@ static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz) <nl>  		verdef->vd_aux = READ32 (dfs, j) <nl>  		verdef->vd_next = READ32 (dfs, j) <nl>  		int vdaux = verdef->vd_aux; <nl> -		if (vdaux < 1 || (char *)UINTPTR_MAX - vstart < vdaux) { <nl> +		if (vdaux < 1 || vstart + vdaux < vstart) { <nl>  			sdb_free (sdb_verdef); <nl>  			goto out_error; <nl>  		}
@@ -160,9 +160,13 @@ static int rabin_dump_symbols(int len) { <nl>  		else if (symbol->size == 0 && olen == 0) <nl>  			len = 32; <nl>  		else len = olen; <nl> - <nl> -		if (!(buf = malloc (len)) || !(ret = malloc (len*2+1))) <nl> +		if (!(buf = malloc (len))) { <nl>  			return R_FALSE; <nl> +		} <nl> +		if (!(ret = malloc (len*2+1))) { <nl> +			free (buf); <nl> +			return R_FALSE; <nl> +		} <nl>  		r_buf_read_at (bin->cur.buf, symbol->offset, buf, len); <nl>  		r_hex_bin2str (buf, len, ret); <nl>  		printf ("%s %s\n", symbol->name, ret);
@@ -980,6 +980,8 @@ if ( <nl>   <nl>  			if ((sym = (Elf_(Sym) *)malloc (1+bin->shdr[i].sh_size)) == NULL) { <nl>  				eprintf ("malloc (syms)"); <nl> +				free (ret); <nl> +				free (strtab); <nl>  				return NULL; <nl>  			} <nl>  			nsym = (int)(bin->shdr[i].sh_size/sizeof (Elf_(Sym)));
@@ -35,7 +35,6 @@ <nl>   <nl>  #define MDNS_QU_FLAG 0x8000 <nl>   <nl> - <nl>  struct mdns_header { <nl>      uint16_t id; <nl>      uint16_t flags; <nl> @@ -92,7 +91,6 @@ struct plugin_ops mdns_spoof_ops = { <nl>  /* this function is called on plugin load */ <nl>  int plugin_load(void *handle)  <nl>  { <nl> - <nl>     /* load the database of spoofed replies (etter.dns)  <nl>      * return an error if we could not open the file <nl>      */ <nl> @@ -134,7 +132,6 @@ static int load_db(void) <nl>     char line[128]; <nl>     char *ptr, *ip, *name; <nl>     int lines = 0, type; <nl> - <nl>      <nl>     /* open the file */ <nl>     f = open_data("etc", ETTER_MDNS, FOPEN_READ_TEXT); <nl> @@ -302,7 +299,7 @@ static int parse_line (const char *str, int line, int *type_p, char **ip_p, char <nl>           memcpy(p    , "\x00\x01", 2);                    /* type A */ <nl>           memcpy(p + 2, "\x00\x01", 2);                    /* class */ <nl>           memcpy(p + 4, "\x00\x00\x0e\x10", 4);            /* TTL (1 hour) */ <nl> -         memcpy(p + 8, "\x00\x04", 2);                   /* datalen */ <nl> +         memcpy(p + 8, "\x00\x04", 2);                    /* datalen */ <nl>           ip_addr_cpy(p + 10, reply);                      /* data */ <nl>   <nl>           /*
@@ -102,6 +102,8 @@ vca_write_obj(struct worker *w, struct sess *sp) <nl>  		sp->obj->age + sp->t_req - sp->obj->entered); <nl>  	sbuf_printf(w->sb, "Via: 1.1 varnish\r\n"); <nl>  	sbuf_printf(w->sb, "X-Varnish: xid %u\r\n", sp->obj->xid); <nl> +	if (http_GetProto(sp->http, &r) && strcmp(r, "HTTP/1.1"))  <nl> +		sbuf_printf(w->sb, "Connection: close\r\n"); <nl>  	sbuf_printf(w->sb, "\r\n"); <nl>  	sbuf_finish(w->sb); <nl>  	vca_write(sp, sbuf_data(w->sb), sbuf_len(w->sb));
@@ -66,7 +66,8 @@ static int end_of_file = 0; <nl>   <nl>  struct top { <nl>  	uint8_t			tag; <nl> -	char			*rec_data; <nl> +	const char		*rec_data; <nl> +	char			*rec_buf; <nl>  	int			clen; <nl>  	unsigned		hash; <nl>  	VRB_ENTRY(top)		e_order; <nl> @@ -147,7 +148,7 @@ accumulate(struct VSL_data *vsl, struct VSL_transaction * const pt[], <nl>  			t.hash = u; <nl>  			t.tag = tag; <nl>  			t.clen = len; <nl> -			t.rec_data = (char *)VSL_CDATA(tr->c->rec.ptr); <nl> +			t.rec_data = VSL_CDATA(tr->c->rec.ptr); <nl>   <nl>  			AZ(pthread_mutex_lock(&mtx)); <nl>  			tp = VRB_FIND(t_key, &h_key, &t); <nl> @@ -164,7 +165,8 @@ accumulate(struct VSL_data *vsl, struct VSL_transaction * const pt[], <nl>  				tp->count = 1.0; <nl>  				tp->clen = len; <nl>  				tp->tag = tag; <nl> -				tp->rec_data = strdup(t.rec_data); <nl> +				tp->rec_buf = strdup(t.rec_data); <nl> +				tp->rec_data = tp->rec_buf; <nl>  				AN(tp->rec_data); <nl>  				VRB_INSERT(t_key, &h_key, tp); <nl>  				VRB_INSERT(t_order, &h_order, tp); <nl> @@ -221,7 +223,7 @@ update(int p) <nl>  		if (tp->count * 10 < t || l > LINES * 10) { <nl>  			VRB_REMOVE(t_key, &h_key, tp); <nl>  			VRB_REMOVE(t_order, &h_order, tp); <nl> -			free(tp->rec_data); <nl> +			free(tp->rec_buf); <nl>  			free(tp); <nl>  			ntop--; <nl>  		}
@@ -567,6 +567,8 @@ cnt_miss(struct sess *sp) <nl>  		HSH_Unbusy(sp->obj); <nl>  		HSH_Deref(sp->obj); <nl>  		sp->obj = NULL; <nl> +		vbe_free_bereq(sp->bereq); <nl> +		sp->bereq = NULL; <nl>  		sp->step = STP_ERROR; <nl>  		return (0); <nl>  	}
@@ -899,6 +899,8 @@ vbf_stp_error(struct worker *wrk, struct busyobj *bo) <nl>  		l = ll; <nl>  		if (VFP_GetStorage(bo->vfc, &l, &ptr) != VFP_OK) <nl>  			break; <nl> +		if (l > ll) <nl> +			l = ll; <nl>  		memcpy(ptr, VSB_data(synth_body) + o, l); <nl>  		VFP_Extend(bo->vfc, l); <nl>  		ll -= l;
@@ -155,7 +155,7 @@ trimline(const char *str, const char *end) <nl>  		 /* nothing */ ; <nl>   <nl>  	/* trim trailing space */ <nl> -	while (str[len - 1] == ' ') <nl> +	while (len && str[len - 1] == ' ') <nl>  		--len; <nl>   <nl>  	/* copy and return */
@@ -87,8 +87,8 @@ SES_RefSrcAddr(struct sess *sp) <nl>  			c3 = c; <nl>  			continue; <nl>  		} <nl> -		TAILQ_REMOVE(ch, c2, list); <nl> -		free(c2); <nl> +		TAILQ_REMOVE(ch, c, list); <nl> +		free(c); <nl>  		VSL_stats->n_srcaddr--; <nl>  	} <nl>  	if (c3 == NULL) {
@@ -105,9 +105,6 @@ static void show_usage_and_exit(void) { <nl>      fprintf(stderr, "  -%s %s (default: \"%s\")\n", <nl>              names[i], names[i + 1], names[i + 2] == NULL ? "" : names[i + 2]); <nl>    } <nl> -  fprintf(stderr, "\nSee  http://code.google.com/p/mongoose/wiki/MongooseManual" <nl> -          " for more details.\n"); <nl> -  fprintf(stderr, "Example:\n  mongoose -s cert.pem -p 80,443s -d no\n"); <nl>    exit(EXIT_FAILURE); <nl>  } <nl>  
@@ -1486,6 +1486,7 @@ static struct ssl_func crypto_sw[] = { <nl>  #define SSL_CTX_set_session_id_context                                         \ <nl>  	(*(int (*)(SSL_CTX *, const unsigned char *, unsigned int))ssl_sw[29].ptr) <nl>  #define SSL_CTX_ctrl (*(long (*)(SSL_CTX *, int, long, void *))ssl_sw[30].ptr) <nl> +#define ASN1_INTEGER_to_BN (*(BIGNUM *(*)(const ASN1_INTEGER *ai, BIGNUM *bn))crypto_sw[31].ptr) <nl>   <nl>   <nl>  #define SSL_CTX_set_cipher_list                                                \ <nl> @@ -1531,6 +1532,8 @@ static struct ssl_func crypto_sw[] = { <nl>  	           unsigned char *,                                                \ <nl>  	           unsigned int *))crypto_sw[18].ptr) <nl>  #define i2d_X509 (*(int (*)(X509 *, unsigned char **))crypto_sw[19].ptr) <nl> +#define BN_bn2hex (*(char *(*)(const BIGNUM *a))crypto_sw[20].ptr) <nl> +#define BN_free (*(void(*)(const BIGNUM *a))crypto_sw[21].ptr) <nl>   <nl>   <nl>  /* set_ssl_option() function updates this array. <nl> @@ -1569,6 +1572,7 @@ static struct ssl_func ssl_sw[] = {{"SSL_free", NULL}, <nl>                                     {"SSL_CTX_set_session_id_context", NULL}, <nl>                                     {"SSL_CTX_ctrl", NULL}, <nl>                                     {"SSL_CTX_set_cipher_list", NULL}, <nl> +                                   {"ASN1_INTEGER_to_BN", NULL}, <nl>                                     {NULL, NULL}}; <nl>   <nl>   <nl> @@ -1594,6 +1598,8 @@ static struct ssl_func crypto_sw[] = {{"CRYPTO_num_locks", NULL}, <nl>                                        {"EVP_get_digestbyname", NULL}, <nl>                                        {"ASN1_digest", NULL}, <nl>                                        {"i2d_X509", NULL}, <nl> +                                      {"BN_bn2hex", NULL}, <nl> +                                      {"BN_free", NULL}, <nl>                                        {NULL, NULL}}; <nl>  #endif /* OPENSSL_API_1_1 */ <nl>  #endif /* NO_SSL_DL */
@@ -4103,9 +4103,9 @@ static void read_websocket(struct mg_connection *conn) { <nl>   <nl>        // Exit the loop if callback signalled to exit, <nl>        // or "connection close" opcode received. <nl> -      if ((conn->ctx->callbacks.websocket_data != NULL && <nl> -          !conn->ctx->callbacks.websocket_data(conn, bits, data, data_len)) || <nl> -          (bits & 0xf) == 8) {  // Opcode == 8, connection close <nl> +      if ((bits & WEBSOCKET_OPCODE_CONNECTION_CLOSE) || <nl> +          (conn->ctx->callbacks.websocket_data != NULL && <nl> +           !conn->ctx->callbacks.websocket_data(conn, bits, data, data_len))) { <nl>          stop = 1; <nl>        } <nl>  
@@ -136,6 +136,7 @@ int clock_gettime(int clk_id, struct timespec *t); <nl>  int <nl>  clock_gettime(int clk_id, struct timespec *t) <nl>  { <nl> +    memset(t, 0, sizeof(*t); <nl>  	if (clk_id == CLOCK_REALTIME) { <nl>  		struct timeval now; <nl>  		int rv = gettimeofday(&now, NULL); <nl> @@ -2328,6 +2329,7 @@ clock_gettime(clockid_t clk_id, struct timespec *tp) <nl>  	static double perfcnt_per_sec = 0.0; <nl>   <nl>  	if (tp) { <nl> +		memset(tp, 0, sizeof(*tp)); <nl>  		if (clk_id == CLOCK_REALTIME) { <nl>  			GetSystemTimeAsFileTime(&ft); <nl>  			li.LowPart = ft.dwLowDateTime; <nl> @@ -2770,6 +2772,7 @@ poll(struct pollfd *pfd, unsigned int n, int milliseconds) <nl>  	int result; <nl>  	SOCKET maxfd = 0; <nl>   <nl> +	memset(&tv, 0, sizeof(tv)); <nl>  	tv.tv_sec = milliseconds / 1000; <nl>  	tv.tv_usec = (milliseconds % 1000) * 1000; <nl>  	FD_ZERO(&set); <nl> @@ -6176,13 +6179,15 @@ read_request(FILE *fp, <nl>               int *nread) <nl>  { <nl>  	int request_len, n = 0; <nl> -	struct timespec last_action_time = {0, 0}; <nl> +	struct timespec last_action_time; <nl>  	double request_timeout; <nl>   <nl>  	if (!conn) { <nl>  		return 0; <nl>  	} <nl>   <nl> +	memset(&last_action_time, 0, sizeof(last_action_time)); <nl> + <nl>  	if (conn->ctx->config[REQUEST_TIMEOUT]) { <nl>  		/* value of request_timeout is in seconds, config in milliseconds */ <nl>  		request_timeout = atof(conn->ctx->config[REQUEST_TIMEOUT]) / 1000.0; <nl> @@ -10050,6 +10055,8 @@ set_sock_timeout(SOCKET sock, int milliseconds) <nl>  	unsigned int uto = (unsigned int)milliseconds; <nl>  #endif <nl>  	struct timeval t; <nl> + <nl> +	memset(&tv, 0, sizeof(tv)); <nl>  	t.tv_sec = milliseconds / 1000; <nl>  	t.tv_usec = (milliseconds * 1000) % 1000000; <nl>  
@@ -162,6 +162,7 @@ int uwsgi_calc_cheaper(void) { <nl>  			ignore_algo = 1; <nl>  		} <nl>  		uwsgi.cheaper_fifo_delta = 0; <nl> +		goto safe; <nl>  	} <nl>   <nl>  	// if cheaper limits wants to change worker count, then skip cheaper algo <nl> @@ -172,6 +173,7 @@ int uwsgi_calc_cheaper(void) { <nl>  		needed_workers = 0; <nl>  	} <nl>   <nl> +safe: <nl>  	if (needed_workers > 0) { <nl>  		for (i = 1; i <= uwsgi.numproc; i++) { <nl>  			if (uwsgi.workers[i].cheaped == 1 && uwsgi.workers[i].pid == 0) {
@@ -291,8 +291,8 @@ void logto(char *logfile) { <nl>  		uwsgi.logfile = logfile; <nl>   <nl>  		if (uwsgi.chmod_logfile_value) { <nl> -			if (chmod(uwsgi.logfile, uwsgi.chmod_logfile_value)) { <nl> -				uwsgi_error("chmod()"); <nl> +			if (fchmod(fd, uwsgi.chmod_logfile_value)) { <nl> +				uwsgi_error("fchmod()"); <nl>  			} <nl>  		} <nl>  	}
@@ -422,7 +422,14 @@ static char *uwsgi_scheme_section(char *url, size_t *size, int add_zero) { <nl>  } <nl>   <nl>  struct uwsgi_string_list *uwsgi_register_scheme(char *name, char * (*func)(char *, size_t *, int)) { <nl> -	struct uwsgi_string_list *usl = uwsgi_string_new_list(&uwsgi.schemes, name); 	 <nl> +	struct uwsgi_string_list *usl = NULL; <nl> +	uwsgi_foreach(usl, uwsgi.schemes) { <nl> +		if (!strcmp(usl->value, name)) goto found; <nl> +	} <nl> + <nl> +	usl = uwsgi_string_new_list(&uwsgi.schemes, name); 	 <nl> + <nl> +found: <nl>  	usl->custom_ptr = func; <nl>  	return usl; <nl>  }
@@ -437,6 +437,12 @@ int http_parse(struct http_session *h_session) { <nl>  		hv = hv->next; <nl>  	} <nl>   <nl> +	// security check <nl> +	if (c >= MAX_HTTP_VEC-4) { <nl> +		uwsgi_log("too much headers in request. skipping it.\n"); <nl> +		return 0; <nl> +	} <nl> + <nl>  	return c; <nl>   <nl>  }
@@ -44,6 +44,8 @@ static int uwsgi_routing_func_rewrite(struct wsgi_request *wsgi_req, struct uwsg <nl>  	char *ptr = uwsgi_req_append(wsgi_req, "PATH_INFO", 9, path_info, path_info_len); <nl>          if (!ptr) goto clear; <nl>   <nl> +	free(path_info); <nl> + <nl>  	// set new path_info <nl>  	wsgi_req->path_info = ptr; <nl>  	wsgi_req->path_info_len = path_info_len;
@@ -67,9 +67,10 @@ PyObject *py_uwsgi_gevent_graceful(PyObject *self, PyObject *args) { <nl>   <nl>  void uwsgi_gevent_gbcw() { <nl>  	 <nl> -	uwsgi_log("...The work of process %d is done. Seeya!\n", getpid()); <nl> - <nl>  	py_uwsgi_gevent_graceful(NULL, NULL); <nl> + <nl> +	uwsgi_log("...The work of process %d is done. Seeya!\n", getpid()); <nl> +	exit(0); <nl>  } <nl>   <nl>  struct wsgi_request *uwsgi_gevent_current_wsgi_req(void) {
@@ -1809,7 +1809,7 @@ static int process_command_args(int argc, char** argv) { <nl>  			python_ai::invoke("documentation"); <nl>  			return 0; <nl>          } else if(val == "--python-shell") { <nl> -			int ret = python_ai::run_shell(); <nl> +			python_ai::run_shell(); <nl>              return 0; <nl>  #endif <nl>  		} else if(val == "--config-dir") {
@@ -472,7 +472,7 @@ void ttext::recalculate(const bool force) const <nl>  				<< " result " <<  rect_ <nl>  				<< ".\n"; <nl>   <nl> -		if(rect_.width > maximum_width_) { <nl> +		if(maximum_width_ != -1 && rect_.width > maximum_width_) { <nl>  			ERR_GUI_L << "ttext::" << __func__ <nl>  					<< " text '" << gui2::debug_truncate(text_) <nl>  					<< " ' width " << rect_.width
@@ -456,10 +456,10 @@ Units cannot be killed by poison alone. The poison will not reduce it below 1 HP <nl>   <nl>  		if(flag_icon.empty()) { <nl>  			flag_icon = game_config::flag_icon_image; <nl> -			old_rgb = game_config::flag_rgb; <nl> -			new_rgb = team::get_side_colour_index(playing_side); <nl> -			mods = "~RC(" + old_rgb + ">" + new_rgb + ")"; <nl>  		} <nl> +		old_rgb = game_config::flag_rgb; <nl> +		new_rgb =team::get_side_colour_index(playing_side); <nl> +			mods = "~RC(" + old_rgb + ">" + new_rgb + ")"; <nl>   <nl>  		// remove animation stuff we don't care about <nl>  		//const std::vector<std::string> items = utils::split(flag);
@@ -51,6 +51,8 @@ void textbox::set_text(std::string text) <nl>  { <nl>  	text_ = string_to_wstring(text); <nl>  	cursor_ = text_.size(); <nl> +	selstart_ = -1; <nl> +	selend_ = -1; <nl>  	set_dirty(true); <nl>  	update_text_cache(true); <nl>  } <nl> @@ -61,6 +63,8 @@ void textbox::clear() <nl>  	cursor_ = 0; <nl>  	cursor_pos_ = 0; <nl>  	text_pos_ = 0; <nl> +	selstart_ = -1; <nl> +	selend_ = -1; <nl>  	set_dirty(true); <nl>  	update_text_cache(true); <nl>  }
@@ -19,7 +19,6 @@ <nl>  #include "foreach.hpp" <nl>  #include "game_end_exceptions.hpp" <nl>  #include "game_events.hpp" <nl> -#include "game_preferences.hpp" //FIXME: get rid of this one <nl>  #include "gettext.hpp" <nl>  #include "gui/dialogs/game_save.hpp" <nl>  #include "gui/widgets/window.hpp" <nl> @@ -508,7 +507,7 @@ bool savegame::save_game_interactive(display& gui, const std::string& message, <nl>  			} <nl>   <nl>  			std::string filename = filename_; <nl> -			if (res == gui2::twindow::OK && savegame_manager::save_game_exists(filename, preferences::compress_saves())) { <nl> +			if (res == gui2::twindow::OK && savegame_manager::save_game_exists(filename, compress_saves_)) { <nl>  				std::stringstream s; <nl>  				s << _("Save already exists. Do you want to overwrite it?") <nl>  				  << std::endl << _("Name: ") << filename;
@@ -580,6 +580,11 @@ void addon_manager::apply_filters(window& window) <nl>  template<void(addon_manager::*fptr)(const addon_info& addon, window& window)> <nl>  void addon_manager::execute_action_on_selected_addon(window& window) <nl>  { <nl> +	// Explicitly return to the main page if we're in low-res mode so the list is visible. <nl> +	if(stacked_widget* stk = find_widget<stacked_widget>(&window, "main_stack", false, false)) { <nl> +		stk->select_layer(0); <nl> +	} <nl> + <nl>  	addon_list& addons = find_widget<addon_list>(&window, "addons", false); <nl>  	const addon_info* addon = addons.get_selected_addon(); <nl>  
@@ -69,7 +69,7 @@ void textbox::draw_cursor(int pos) const <nl>   <nl>  void textbox::draw() const <nl>  { <nl> -	if(location().h == 0) <nl> +	if(location().x == 0) <nl>  		return; <nl>   <nl>  	if(buffer_.get() != NULL) { <nl> @@ -113,6 +113,9 @@ void textbox::draw() const <nl>   <nl>  void textbox::handle_event(const SDL_Event& event) <nl>  { <nl> +	if(location().x == 0) <nl> +		return; <nl> + <nl>  	int mousex, mousey; <nl>  	SDL_GetMouseState(&mousex,&mousey); <nl>  
@@ -319,6 +319,9 @@ static int impl_unit_attack_match(lua_State* L) <nl>  { <nl>  	const_attack_ptr atk = luaW_toweapon(L, 1); <nl>  	config cfg = luaW_checkconfig(L, 2); <nl> +	if(!atk) { <nl> +		return luaL_argerror(L, 1, "invalid attack"); <nl> +	} <nl>  	lua_pushboolean(L, atk->matches_filter(cfg)); <nl>  	return 1; <nl>  }
@@ -46,6 +46,7 @@ <nl>  #include "units/drawer.hpp" <nl>  #include "whiteboard/manager.hpp" <nl>  #include "show_dialog.hpp" <nl> +#include "gui/dialogs/loadscreen.hpp" <nl>   <nl>  #include <SDL_image.h> <nl>   <nl> @@ -3782,6 +3783,9 @@ void display::handle_window_event(const SDL_Event& event) { <nl>  } <nl>   <nl>  void display::handle_event(const SDL_Event& event) { <nl> +	if (gui2::tloadscreen::displaying()) { <nl> +		return; <nl> +	} <nl>  	if (event.type == DRAW_ALL_EVENT) { <nl>  		draw(); <nl>  	}
@@ -276,10 +276,14 @@ void play_controller::show_help(){ <nl>  } <nl>   <nl>  void play_controller::undo(){ <nl> +	// deselect unit (only here, not to be done when undoing attack-move) <nl> +	mouse_handler_.deselect_hex(); <nl>  	menu_handler_.undo(player_number_); <nl>  } <nl>   <nl>  void play_controller::redo(){ <nl> +	// deselect unit (only here, not to be done when undoing attack-move) <nl> +	mouse_handler_.deselect_hex(); <nl>  	menu_handler_.redo(player_number_); <nl>  } <nl>   <nl> @@ -416,7 +420,7 @@ void play_controller::init_side(const unsigned int team_index, bool /*is_replay* <nl>  		gui_->invalidate_all(); <nl>  	} <nl>   <nl> -	if (!recorder.is_skipping()){ <nl> +	if (!recorder.is_skipping() && !skip_replay_){ <nl>  		gui_->scroll_to_leader(units_, player_number_); <nl>  	} <nl>  }
@@ -534,6 +534,12 @@ int battle_context::choose_attacker_weapon(const unit &attacker, <nl>  			attacker_combatant_ = new combatant(*attacker_stats_); <nl>  			defender_combatant_ = new combatant(*defender_stats_, prev_def); <nl>  			attacker_combatant_->fight(*defender_combatant_); <nl> +		} else { <nl> +			if (attacker_stats_->disable) { <nl> +				delete attacker_stats_; <nl> +				attacker_stats_ = nullptr; <nl> +				continue; <nl> +			} <nl>  		} <nl>  		if (!best_att_comb || better_combat(*attacker_combatant_, *defender_combatant_, <nl>  					*best_att_comb, *best_def_comb, harm_weight)) {
@@ -473,13 +473,13 @@ static void print_usage(const struct option longopts[]) <nl>  	exit(0); <nl>  } <nl>   <nl> -static void print_version() <nl> +static void print_version(void) <nl>  { <nl>  	printf("%s\n", LXC_VERSION); <nl>  	exit(0); <nl>  } <nl>   <nl> -static void print_help() <nl> +static void print_help(void) <nl>  { <nl>  	fprintf(stderr, "\ <nl>  Usage: lxc-init --name=NAME -- COMMAND\n\
@@ -1025,7 +1025,12 @@ static void do_restore(struct lxc_container *c, int status_pipe, struct migrate_ <nl>  		 * assign the return here to silence potential. <nl>  		 */ <nl>  		ret = snprintf(title, sizeof(title), "[lxc monitor] %s %s", c->config_path, c->name); <nl> +		if (ret < 0 || (size_t)ret >= sizeof(title)) <nl> +			INFO("Setting truncated process name"); <nl> + <nl>  		ret = setproctitle(title); <nl> +		if (ret < 0) <nl> +			INFO("Failed to set process name"); <nl>   <nl>  		ret = lxc_poll(c->name, handler); <nl>  		if (ret)
@@ -1732,6 +1732,8 @@ static int setup_private_host_hw_addr(char *veth1) <nl>  	return 0; <nl>  } <nl>   <nl> +static char *default_rootfs_mount = LXCROOTFSMOUNT; <nl> + <nl>  struct lxc_conf *lxc_conf_init(void) <nl>  { <nl>  	struct lxc_conf *new; <nl> @@ -1750,7 +1752,7 @@ struct lxc_conf *lxc_conf_init(void) <nl>  	new->console.master = -1; <nl>  	new->console.slave = -1; <nl>  	new->console.name[0] = '\0'; <nl> -	new->rootfs.mount = LXCROOTFSMOUNT; <nl> +	new->rootfs.mount = default_rootfs_mount; <nl>  	lxc_list_init(&new->cgroup); <nl>  	lxc_list_init(&new->network); <nl>  	lxc_list_init(&new->mount_list); <nl> @@ -2576,7 +2578,7 @@ void lxc_conf_free(struct lxc_conf *conf) <nl>  		return; <nl>  	if (conf->console.path) <nl>  		free(conf->console.path); <nl> -	if (conf->rootfs.mount != LXCROOTFSMOUNT) <nl> +	if (conf->rootfs.mount != default_rootfs_mount) <nl>  		free(conf->rootfs.mount); <nl>  	lxc_clear_config_network(conf); <nl>  #if HAVE_APPARMOR
@@ -321,7 +321,7 @@ static int get_pty_on_host(struct lxc_container *c, struct wrapargs *wrap, int * <nl>  err3: <nl>  	lxc_mainloop_close(&descr); <nl>  err2: <nl> -	if (ts->sigfd != -1) <nl> +	if (ts && ts->sigfd != -1) <nl>  		lxc_console_sigwinch_fini(ts); <nl>  err1: <nl>  	lxc_console_delete(&conf->console);
@@ -2263,7 +2263,7 @@ int unit_file_get_list( <nl>                  } <nl>          } <nl>   <nl> -        return r; <nl> +        return 0; <nl>  } <nl>   <nl>  static const char* const unit_file_state_table[_UNIT_FILE_STATE_MAX] = {
@@ -1202,7 +1202,7 @@ int main(int argc, char *argv[], char *envp[]) <nl>   <nl>  				reload_config = 1; <nl>  				buf = malloc(nbytes); <nl> -				if (buf != NULL) { <nl> +				if (buf == NULL) { <nl>  					err("error getting buffer for inotify, disable watching"); <nl>  					close(inotify_fd); <nl>  					inotify_fd = -1;
@@ -1189,6 +1189,7 @@ static void item_free(Item *i) { <nl>          free(i->uid_path); <nl>          free(i->gid_path); <nl>          free(i->description); <nl> +        free(i->home); <nl>          free(i); <nl>  } <nl>  
@@ -594,15 +594,16 @@ static int match_rule(struct udevice *udev, struct udev_rule *rule, <nl>  			for (i = 0; i < rule->sysfs_pair_count; i++) { <nl>  				struct key_pair *pair; <nl>  				char value[VALUE_SIZE]; <nl> +				size_t len; <nl>   <nl>  				pair = &rule->sysfs_pair[i]; <nl>  				if (find_sysfs_attribute(class_dev, parent_device, pair->name, value, sizeof(value)) != 0) <nl>  					goto try_parent; <nl>   <nl>  				/* strip trailing whitespace of value, if not asked to match for it */ <nl> -				if (!isspace(pair->value[strlen(pair->value)-1])) { <nl> -					size_t len = strlen(value); <nl> - <nl> +				len = strlen(pair->value); <nl> +				if (len && !isspace(pair->value[len-1])) { <nl> +					len = strlen(value); <nl>  					while (len > 0 && isspace(value[len-1])) <nl>  						value[--len] = '\0'; <nl>  					dbg("removed %i trailing whitespace chars from '%s'", strlen(value)-len, value);
@@ -2543,7 +2543,7 @@ static int change_uid_gid(char **_home) { <nl>          } <nl>   <nl>          r = mkdir_safe(home, 0755, uid, gid); <nl> -        if (r < 0) { <nl> +        if (r < 0 && r != -EEXIST) { <nl>                  log_error("Failed to make home directory: %s", strerror(-r)); <nl>                  return r; <nl>          }
@@ -211,6 +211,8 @@ static int swap_add_device_links(Swap *s) { <nl>  } <nl>   <nl>  static int swap_add_default_dependencies(Swap *s) { <nl> +        int r; <nl> + <nl>          assert(s); <nl>   <nl>          if (!UNIT(s)->default_dependencies) <nl> @@ -222,6 +224,12 @@ static int swap_add_default_dependencies(Swap *s) { <nl>          if (detect_container() > 0) <nl>                  return 0; <nl>   <nl> +        /* swap units generated for the swap dev links are missing the <nl> +         * ordering dep against the swap target. */ <nl> +        r = unit_add_dependency_by_name(UNIT(s), UNIT_BEFORE, SPECIAL_SWAP_TARGET, NULL, true); <nl> +        if (r < 0) <nl> +                return r; <nl> + <nl>          return unit_add_two_dependencies_by_name(UNIT(s), UNIT_BEFORE, UNIT_CONFLICTS, SPECIAL_UMOUNT_TARGET, NULL, true); <nl>  } <nl>  
@@ -490,6 +490,11 @@ int config_parse_exec_nice( <nl>          assert(rvalue); <nl>          assert(data); <nl>   <nl> +        if (isempty(rvalue)) { <nl> +                c->nice_set = false; <nl> +                return 0; <nl> +        } <nl> + <nl>          r = parse_nice(rvalue, &priority); <nl>          if (r < 0) { <nl>                  if (r == -ERANGE)
@@ -1807,6 +1807,13 @@ int main(int argc, char *argv[]) { <nl>                          goto finish; <nl>   <nl>                  case MANAGER_EXIT: <nl> +                        if (m->running_as == MANAGER_USER) { <nl> +                                retval = EXIT_SUCCESS; <nl> +                                log_debug("Exit."); <nl> +                                goto finish; <nl> +                        } <nl> + <nl> +                        /* fallthrough */ <nl>                  case MANAGER_REBOOT: <nl>                  case MANAGER_POWEROFF: <nl>                  case MANAGER_HALT:
@@ -100,8 +100,8 @@ static uint32_t term_color_to_argb32(const term_color *color, const term_attr *a <nl>          case TERM_CCODE_BLACK ... TERM_CCODE_LIGHT_WHITE: <nl>                  t = color->ccode - TERM_CCODE_BLACK; <nl>   <nl> -                /* bold causes light colors */ <nl> -                if (t < 8 && attr->bold) <nl> +                /* bold causes light colors (only for foreground colors) */ <nl> +                if (t < 8 && attr->bold && color == &attr->fg) <nl>                          t += 8; <nl>   <nl>                  r = palette[t * 3 + 0];
@@ -1089,7 +1089,7 @@ struct udev_list_entry *udev_device_add_property(struct udev_device *udev_device <nl>   <nl>  struct udev_list_entry *udev_device_add_property_from_string(struct udev_device *udev_device, const char *property) <nl>  { <nl> -	char name[UTIL_PATH_SIZE]; <nl> +	char name[UTIL_LINE_SIZE]; <nl>  	char *val; <nl>   <nl>  	util_strscpy(name, sizeof(name), property);
@@ -692,8 +692,8 @@ static int netdev_load_one(Manager *manager, const char *filename) { <nl>          LIST_HEAD_INIT(netdev->callbacks); <nl>   <nl>          if(netdev->kind == NETDEV_KIND_VETH) { <nl> -                if (netdev->ifname_peer) { <nl> -                        log_warning("Veth NetDev without Peer Name configured " <nl> +                if (!netdev->ifname_peer) { <nl> +                        log_warning("Veth NetDev without peer name configured " <nl>                                      "in %s. Ignoring", filename); <nl>                          return 0; <nl>                  }
@@ -3662,12 +3662,15 @@ static int enable_unit(DBusConnection *bus, char **args) { <nl>          int r; <nl>          DBusError error; <nl>   <nl> -        dbus_error_init(&error); <nl> - <nl>          r = enable_sysv_units(args); <nl>          if (r < 0) <nl>                  return r; <nl>   <nl> +        if (!args[1]) <nl> +                return 0; <nl> + <nl> +        dbus_error_init(&error); <nl> + <nl>          if (!bus || avoid_bus()) { <nl>                  if (streq(verb, "enable")) { <nl>                          r = unit_file_enable(arg_scope, arg_runtime, arg_root, args+1, arg_force, &changes, &n_changes);
@@ -1416,7 +1416,7 @@ static struct node *bus_node_allocate(sd_bus *bus, const char *path) { <nl>                  e = strrchr(path, '/'); <nl>                  assert(e); <nl>   <nl> -                p = strndupa(path, MAX(1, path - e)); <nl> +                p = strndupa(path, MAX(1, e - path)); <nl>   <nl>                  parent = bus_node_allocate(bus, p); <nl>                  if (!parent)
@@ -1123,7 +1123,9 @@ static DBusHandlerResult locale_message_handler( <nl>                                          "Locale\0"); <nl>                          if (!changed) <nl>                                  goto oom; <nl> -                } <nl> +                } else <nl> +                        strv_free(l); <nl> + <nl>          } else if (dbus_message_is_method_call(message, "org.freedesktop.locale1", "SetVConsoleKeyboard")) { <nl>   <nl>                  const char *keymap, *keymap_toggle;
@@ -462,9 +462,6 @@ int setup_namespace( <nl>          if (mount_flags == 0) <nl>                  mount_flags = MS_SHARED; <nl>   <nl> -        if (unshare(CLONE_NEWNS) < 0) <nl> -                return -errno; <nl> - <nl>          n = !!tmp_dir + !!var_tmp_dir + <nl>                  strv_length(read_write_paths) + <nl>                  strv_length(read_only_paths) + <nl> @@ -606,6 +603,9 @@ int setup_namespace( <nl>                  drop_nop(mounts, &n); <nl>          } <nl>   <nl> +        if (unshare(CLONE_NEWNS) < 0) <nl> +                return -errno; <nl> + <nl>          if (n > 0 || root_directory) { <nl>                  /* Remount / as SLAVE so that nothing now mounted in the namespace <nl>                     shows up in the parent */
@@ -84,7 +84,7 @@ int switch_root(const char *new_root) { <nl>                  snprintf(new_mount, sizeof(new_mount), "%s%s", new_root, i); <nl>                  char_array_0(new_mount); <nl>   <nl> -                mkdir_parents(new_mount, 0755); <nl> +                mkdir_p(new_mount, 0755); <nl>   <nl>                  if ((stat(new_mount, &sb) < 0) || <nl>                      sb.st_dev != new_root_stat.st_dev) {
@@ -1715,7 +1715,7 @@ int main(int argc, char *argv[]) { <nl>                     by PID1. otherwise we are not guaranteed to have a dedicated cgroup */ <nl>                  r = cg_pid_get_path(SYSTEMD_CGROUP_CONTROLLER, 0, &cgroup); <nl>                  if (r < 0) { <nl> -                        if (r == -ENOENT || r == -ENOEXEC) <nl> +                        if (r == -ENOENT || r == -ENOMEDIUM) <nl>                                  log_debug_errno(r, "did not find dedicated cgroup: %m"); <nl>                          else <nl>                                  log_warning_errno(r, "failed to get cgroup: %m");
@@ -74,14 +74,14 @@ inline void *_dlist_mark_move(Dlist *list,int direction) <nl>  { <nl>    if(direction) <nl>      { <nl> -      if( list->marker->next!=NULL) <nl> +      if( list->marker && list->marker->next!=NULL) <nl>  	list->marker=list->marker->next; <nl>        else <nl>  	return(NULL); <nl>      } <nl>    else <nl>      { <nl> -      if( list->marker->prev!=NULL) <nl> +      if( list->marker && list->marker->prev!=NULL) <nl>  	list->marker=list->marker->prev; <nl>        else <nl>  	return(NULL);
@@ -341,7 +341,8 @@ int button_open(Button *b) { <nl>          } <nl>   <nl>          (void) button_set_mask(b); <nl> - <nl> +         <nl> +        b->io_event_source = sd_event_source_unref(b->io_event_source); <nl>          r = sd_event_add_io(b->manager->event, &b->io_event_source, b->fd, EPOLLIN, button_dispatch, b); <nl>          if (r < 0) { <nl>                  log_error_errno(r, "Failed to add button event: %m");
@@ -74,16 +74,17 @@ LIST_HEAD(device_last_list); <nl>  static int device_list_insert(const char *path) <nl>  { <nl>  	struct list_head *device_list = &device_default_list; <nl> +	const char *devpath = &path[strlen(sysfs_path)]; <nl>  	int i; <nl>   <nl>  	for (i = 0; first_list[i] != NULL; i++) { <nl> -		if (strncmp(path, first_list[i], strlen(first_list[i])) == 0) { <nl> +		if (strncmp(devpath, first_list[i], strlen(first_list[i])) == 0) { <nl>  			device_list = &device_first_list; <nl>  			break; <nl>  		} <nl>  	} <nl>  	for (i = 0; last_list[i] != NULL; i++) { <nl> -		if (strncmp(path, last_list[i], strlen(last_list[i])) == 0) { <nl> +		if (strncmp(devpath, last_list[i], strlen(last_list[i])) == 0) { <nl>  			device_list = &device_last_list; <nl>  			break; <nl>  		}
@@ -342,6 +342,7 @@ int udev_monitor_filter_update(struct udev_monitor *udev_monitor) <nl>  	bpf_stmt(ins, &i, BPF_RET|BPF_K, 0xffffffff); <nl>   <nl>  	/* install filter */ <nl> +	memset(&filter, 0x00, sizeof(filter)); <nl>  	filter.len = i; <nl>  	filter.filter = ins; <nl>  	err = setsockopt(udev_monitor->sock, SOL_SOCKET, SO_ATTACH_FILTER, &filter, sizeof(filter));
@@ -46,6 +46,8 @@ static int dns_stream_update_io(DnsStream *s) { <nl>  } <nl>   <nl>  static int dns_stream_complete(DnsStream *s, int error) { <nl> +        _cleanup_(dns_stream_unrefp) _unused_ DnsStream *ref = dns_stream_ref(s); /* Protect stream while we process it */ <nl> + <nl>          assert(s); <nl>   <nl>  #if ENABLE_DNS_OVER_TLS <nl> @@ -273,7 +275,7 @@ static int on_stream_timeout(sd_event_source *es, usec_t usec, void *userdata) { <nl>  } <nl>   <nl>  static int on_stream_io(sd_event_source *es, int fd, uint32_t revents, void *userdata) { <nl> -        DnsStream *s = userdata; <nl> +        _cleanup_(dns_stream_unrefp) DnsStream *s = dns_stream_ref(userdata); /* Protect stream while we process it */ <nl>          int r; <nl>   <nl>          assert(s);
@@ -383,7 +383,7 @@ hexchat_reinit_timers (void) <nl>  		notify_tag = fe_timeout_add_seconds (prefs.hex_notify_timeout, <nl>  						     notify_checklist, NULL); <nl>  	} <nl> -	else if (notify_tag != 0) <nl> +	else if (!prefs.hex_notify_timeout && notify_tag != 0) <nl>  	{ <nl>  		fe_timeout_remove (notify_tag); <nl>  		notify_tag = 0; <nl> @@ -394,7 +394,7 @@ hexchat_reinit_timers (void) <nl>  	{ <nl>  		away_tag = fe_timeout_add_seconds (prefs.hex_away_timeout, away_check, NULL); <nl>  	} <nl> -	else if (away_tag != 0) <nl> +	else if (!prefs.hex_away_track && away_tag != 0) <nl>  	{ <nl>  		fe_timeout_remove (away_tag); <nl>  		away_tag = 0; <nl> @@ -405,7 +405,7 @@ hexchat_reinit_timers (void) <nl>  	{ <nl>  		lag_check_update_tag = fe_timeout_add (500, hexchat_lag_check_update, NULL); <nl>  	} <nl> -	else if (lag_check_update_tag != 0) <nl> +	else if (!prefs.hex_gui_lagometer && lag_check_update_tag != 0) <nl>  	{ <nl>  		fe_timeout_remove (lag_check_update_tag); <nl>  		lag_check_update_tag = 0; <nl> @@ -417,7 +417,8 @@ hexchat_reinit_timers (void) <nl>  	{ <nl>  		lag_check_tag = fe_timeout_add_seconds (30, hexchat_lag_check, NULL); <nl>  	} <nl> -	else if (lag_check_tag != 0) <nl> +	else if ((!prefs.hex_net_ping_timeout && !prefs.hex_gui_lagometer) <nl> +					 && lag_check_tag != 0) <nl>  	{ <nl>  		fe_timeout_remove (lag_check_tag); <nl>  		lag_check_tag = 0;
@@ -518,7 +518,7 @@ gtk_xtext_new (GdkColor palette[], int separator) <nl>  } <nl>   <nl>  static void <nl> -gtk_xtext_destroy (GObject * object) <nl> +gtk_xtext_destroy (GtkObject * object) <nl>  { <nl>  	GtkXText *xtext = GTK_XTEXT (object); <nl>   <nl> @@ -2155,7 +2155,7 @@ gtk_xtext_scroll (GtkWidget *widget, GdkEventScroll *event) <nl>  static void <nl>  gtk_xtext_class_init (GtkXTextClass * class) <nl>  { <nl> -	GObjectClass *object_class; <nl> +	GtkObjectClass *object_class; <nl>  	GtkWidgetClass *widget_class; <nl>  	GtkXTextClass *xtext_class; <nl>   <nl> @@ -2163,7 +2163,7 @@ gtk_xtext_class_init (GtkXTextClass * class) <nl>  	widget_class = (GtkWidgetClass *) class; <nl>  	xtext_class = (GtkXTextClass *) class; <nl>   <nl> -	parent_class = g_type_class_peek (g_object_get_type ()); <nl> +	parent_class = g_type_class_peek (gtk_widget_get_type ()); <nl>   <nl>  	xtext_signals[WORD_CLICK] = <nl>  		g_signal_new ("word_click", <nl> @@ -2174,7 +2174,7 @@ gtk_xtext_class_init (GtkXTextClass * class) <nl>  							gtk_marshal_VOID__POINTER_POINTER, <nl>  							G_TYPE_NONE, <nl>  							2, G_TYPE_POINTER, G_TYPE_POINTER); <nl> -	object_class->dispose = gtk_xtext_destroy; <nl> +	object_class->destroy = gtk_xtext_destroy; <nl>   <nl>  	widget_class->realize = gtk_xtext_realize; <nl>  	widget_class->unrealize = gtk_xtext_unrealize;
@@ -1707,15 +1707,18 @@ inbound_cap_ls (server *serv, char *nick, char *extensions_str, <nl>  		if (!strcmp (extension, "znc.in/server-time-iso")) <nl>  		{ <nl>  			strcat (buffer, "znc.in/server-time-iso "); <nl> +			want_cap = 1; <nl>  		} <nl>  		if (!strcmp (extension, "znc.in/server-time")) <nl>  		{ <nl>  			strcat (buffer, "znc.in/server-time "); <nl> +			want_cap = 1; <nl>  		} <nl>  		if (prefs.hex_irc_cap_server_time <nl>  			 && !strcmp (extension, "server-time")) <nl>  		{ <nl>  			strcat (buffer, "server-time "); <nl> +			want_cap = 1; <nl>  		} <nl>  		 <nl>  		/* if the SASL password is set AND auth mode is set to SASL, request SASL auth */
@@ -617,4 +617,5 @@ void sync_v2_memb_list_determine (const struct memb_ring_id *ring_id) <nl>  void sync_v2_memb_list_abort (void) <nl>  { <nl>  	my_memb_determine_list_entries = 0; <nl> +	memset (&my_memb_determine_ring_id, 0, sizeof (struct memb_ring_id)); <nl>  }
@@ -91,7 +91,7 @@ poll_handle poll_create ( <nl>  	poll_instance->poll_entries = 0; <nl>  	poll_instance->ufds = 0; <nl>  	poll_instance->poll_entry_count = 0; <nl> -	poll_instance->serialize_lock_fn = serialize_unlock_fn; <nl> +	poll_instance->serialize_lock_fn = serialize_lock_fn; <nl>  	poll_instance->serialize_unlock_fn = serialize_unlock_fn; <nl>  	timerlist_init (&poll_instance->timerlist); <nl>  
@@ -3414,7 +3414,10 @@ static unsigned int backlog_get (struct totemsrp_instance *instance) <nl>  	if (instance->memb_state == MEMB_STATE_RECOVERY) { <nl>  		queue_use = &instance->retrans_message_queue; <nl>  	} <nl> -	backlog = cs_queue_used (queue_use); <nl> + <nl> +	if (queue_use != NULL) { <nl> +		backlog = cs_queue_used (queue_use); <nl> +	} <nl>   <nl>  	instance->stats.token[instance->stats.latest_token].backlog_calc = backlog; <nl>  	return (backlog);
@@ -4964,7 +4964,8 @@ ev_view_motion_notify_event (GtkWidget      *widget, <nl>  	} <nl>   <nl>  	if (view->scroll_info.autoscrolling) { <nl> -		view->scroll_info.last_y = y; <nl> +		if (y >= 0) <nl> +			view->scroll_info.last_y = y; <nl>  		return TRUE; <nl>  	} <nl>  
@@ -3996,7 +3996,12 @@ ev_view_button_release_event (GtkWidget      *widget, <nl>  		view->pressed_button = -1; <nl>   <nl>  		return TRUE; <nl> -	}  <nl> +	} <nl> + <nl> +	if (view->pressed_button == 1 && event->state & GDK_CONTROL_MASK) { <nl> +		view->pressed_button = -1; <nl> +		return TRUE; <nl> +	} <nl>   <nl>  	if (view->drag_info.in_drag) { <nl>  		view->drag_info.release_timeout_id =
@@ -34,7 +34,6 @@ gimp_display_shell_pointer_grab (GimpDisplayShell *shell, <nl>  { <nl>    g_return_val_if_fail (GIMP_IS_DISPLAY_SHELL (shell), FALSE); <nl>    g_return_val_if_fail (shell->pointer_grabbed == FALSE, FALSE); <nl> -  g_return_val_if_fail (shell->pointer_grab_time == 0, FALSE); <nl>   <nl>    if (event) <nl>      { <nl> @@ -67,7 +66,6 @@ gimp_display_shell_pointer_ungrab (GimpDisplayShell *shell, <nl>  { <nl>    g_return_if_fail (GIMP_IS_DISPLAY_SHELL (shell)); <nl>    g_return_if_fail (shell->pointer_grabbed == TRUE); <nl> -  g_return_if_fail (event == NULL || shell->pointer_grab_time != 0); <nl>   <nl>    gtk_grab_remove (shell->canvas); <nl>   <nl> @@ -91,7 +89,6 @@ gimp_display_shell_keyboard_grab (GimpDisplayShell *shell, <nl>    g_return_val_if_fail (GIMP_IS_DISPLAY_SHELL (shell), FALSE); <nl>    g_return_val_if_fail (event != NULL, FALSE); <nl>    g_return_val_if_fail (shell->keyboard_grabbed == FALSE, FALSE); <nl> -  g_return_val_if_fail (shell->keyboard_grab_time == 0, FALSE); <nl>   <nl>    status = gdk_keyboard_grab (gtk_widget_get_window (shell->canvas), <nl>                                FALSE, <nl> @@ -117,7 +114,6 @@ gimp_display_shell_keyboard_ungrab (GimpDisplayShell *shell, <nl>    g_return_if_fail (GIMP_IS_DISPLAY_SHELL (shell)); <nl>    g_return_if_fail (event != NULL); <nl>    g_return_if_fail (shell->keyboard_grabbed == TRUE); <nl> -  g_return_if_fail (shell->keyboard_grab_time != 0); <nl>   <nl>    gdk_display_keyboard_ungrab (gtk_widget_get_display (shell->canvas), <nl>                                 shell->keyboard_grab_time);
@@ -32,6 +32,8 @@ <nl>   <nl>  #include "paint-funcs/paint-funcs.h" <nl>   <nl> +#include "gegl/gimp-gegl-utils.h" <nl> + <nl>  #include "vectors/gimpvectors.h" <nl>   <nl>  #include "gimp.h" <nl> @@ -574,12 +576,8 @@ gimp_image_merge_layers (GimpImage     *image, <nl>        gimp_item_set_offset (GIMP_ITEM (merge_layer), x1, y1); <nl>   <nl>        /*  clear the layer  */ <nl> -      pixel_region_init (&src1PR, <nl> -                         gimp_drawable_get_tiles (GIMP_DRAWABLE (merge_layer)), <nl> -                         0, 0, <nl> -                         (x2 - x1), (y2 - y1), <nl> -                         TRUE); <nl> -      clear_region (&src1PR); <nl> +      gegl_buffer_clear (gimp_drawable_get_write_buffer (GIMP_DRAWABLE (merge_layer)), <nl> +                         NULL); <nl>   <nl>        /*  Find the index in the layer list of the bottom layer--we need this <nl>         *  in order to add the final, merged layer to the layer list correctly
@@ -286,6 +286,9 @@ choose_format (GeglBuffer          *buffer, <nl>        break; <nl>   <nl>      case GIMP_SELECT_CRITERION_LCH_L: <nl> +      format = babl_format ("CIE L alpha float"); <nl> +      break; <nl> + <nl>      case GIMP_SELECT_CRITERION_LCH_C: <nl>      case GIMP_SELECT_CRITERION_LCH_H: <nl>        format = babl_format ("CIE LCH(ab) alpha float");
@@ -427,7 +427,7 @@ metadata_message_dialog (GtkMessageType  type, <nl>  { <nl>    GtkWidget *dlg; <nl>   <nl> -  dlg = gtk_message_dialog_new (parent, 0, type, GTK_BUTTONS_OK, message); <nl> +  dlg = gtk_message_dialog_new (parent, 0, type, GTK_BUTTONS_OK, "%s", message); <nl>   <nl>    if (title) <nl>      gtk_window_set_title (GTK_WINDOW (dlg), title);
@@ -506,6 +506,7 @@ neon (GimpDrawable *drawable, <nl>    g_free (val_p); <nl>    g_free (val_m); <nl>    g_free (src); <nl> +  g_free (src2); <nl>    g_free (dest); <nl>  } <nl>  
@@ -97,6 +97,10 @@ gimp_prop_kelvin_presets_new (GObject     *config, <nl>    menu = gtk_menu_new (); <nl>    gtk_menu_attach_to_widget (GTK_MENU (menu), button, NULL); <nl>   <nl> +  gimp_help_set_help_data (button, <nl> +                           _("Choose from a list of common " <nl> +                             "color temperatures"), NULL); <nl> + <nl>    g_signal_connect (button, "button-press-event", <nl>                      G_CALLBACK (gimp_prop_kelvin_presets_button_press), <nl>                      menu);
@@ -295,7 +295,8 @@ gimp_write_and_read_file (Gimp     *gimp, <nl>    GimpImage           *image; <nl>    GimpImage           *loaded_image; <nl>    GimpPlugInProcedure *proc; <nl> -  gchar               *filename; <nl> +  gchar               *filename = NULL; <nl> +  gint                 file_handle; <nl>    GFile               *file; <nl>   <nl>    /* Create the image */ <nl> @@ -311,7 +312,9 @@ gimp_write_and_read_file (Gimp     *gimp, <nl>                           use_gimp_2_8_features); <nl>   <nl>    /* Write to file */ <nl> -  filename = g_build_filename (g_get_tmp_dir (), "gimp-test.xcf", NULL); <nl> +  file_handle = g_file_open_tmp ("gimp-test-XXXXXX.xcf", &filename, NULL); <nl> +  g_assert (file_handle != -1); <nl> +  close (file_handle); <nl>    file = g_file_new_for_path (filename); <nl>    g_free (filename); <nl>  
@@ -348,7 +348,7 @@ borderaverage_dialog (gint32        image_ID, <nl>    GtkSizeGroup *group; <nl>    gboolean      run; <nl>    gdouble       xres, yres; <nl> -  gint          width, height; <nl> +  GeglBuffer   *buffer = NULL; <nl>   <nl>    const gchar *labels[] = <nl>      { "1", "2", "4", "8", "16", "32", "64", "128", "256" }; <nl> @@ -406,8 +406,11 @@ borderaverage_dialog (gint32        image_ID, <nl>    gimp_size_entry_set_resolution (GIMP_SIZE_ENTRY (size_entry), 0, xres, TRUE); <nl>   <nl>    /*  set the size (in pixels) that will be treated as 0% and 100%  */ <nl> -  gimp_size_entry_set_size (GIMP_SIZE_ENTRY (size_entry), 0, 0.0, <nl> -                            MIN (width, height)); <nl> +  buffer = gimp_drawable_get_buffer (drawable_id); <nl> +  if (buffer) <nl> +      gimp_size_entry_set_size (GIMP_SIZE_ENTRY (size_entry), 0, 0.0, <nl> +                                MIN (gegl_buffer_get_width(buffer), <nl> +                                     gegl_buffer_get_height(buffer))); <nl>   <nl>    gimp_size_entry_set_refval_boundaries (GIMP_SIZE_ENTRY (size_entry), 0, <nl>                                           1.0, 256.0);
@@ -178,7 +178,7 @@ hb_icu_unicode_compose (hb_unicode_funcs_t *ufuncs HB_UNUSED, <nl>  { <nl>  #if U_ICU_VERSION_MAJOR_NUM >= 49 <nl>    { <nl> -    UChar32 ret = unorm2_composePair (normalizer.get (), a, b); <nl> +    UChar32 ret = unorm2_composePair (normalizer.get_relaxed (), a, b); <nl>      if (ret < 0) return false; <nl>      *ab = ret; <nl>      return true; <nl> @@ -226,7 +226,7 @@ hb_icu_unicode_decompose (hb_unicode_funcs_t *ufuncs HB_UNUSED, <nl>      UChar decomposed[4]; <nl>      int len; <nl>      UErrorCode icu_err = U_ZERO_ERROR; <nl> -    len = unorm2_getRawDecomposition (normalizer.get (), ab, decomposed, <nl> +    len = unorm2_getRawDecomposition (normalizer.get_relaxed (), ab, decomposed, <nl>  				      ARRAY_LENGTH (decomposed), &icu_err); <nl>      if (U_FAILURE (icu_err) || len < 0) return false; <nl>  
@@ -250,7 +250,8 @@ _hb_ot_shape_normalize (hb_font_t *font, hb_buffer_t *buffer, <nl>      } <nl>   <nl>      hb_codepoint_t composed, glyph; <nl> -    if ((buffer->out_info[buffer->out_len - 1].combining_class() < buffer->info[buffer->idx].combining_class()) && <nl> +    if ((starter == buffer->out_len - 1 || <nl> +	 buffer->out_info[buffer->out_len - 1].combining_class() < buffer->info[buffer->idx].combining_class()) && <nl>  	hb_unicode_compose (buffer->unicode, <nl>  			    buffer->out_info[starter].codepoint, <nl>  			    buffer->info[buffer->idx].codepoint,
@@ -251,7 +251,7 @@ my_bool <nl>  my_net_write(NET *net,const char *packet,ulong len) <nl>  { <nl>    uchar buff[NET_HEADER_SIZE]; <nl> -  if (unlikely(!net->vio)) // nowhere to write <nl> +  if (unlikely(!net->vio))                      /* nowhere to write */ <nl>      return 0; <nl>    /* <nl>      Big packets are handled by splitting them in packets of MAX_PACKET_LENGTH
@@ -1770,7 +1770,7 @@ void Query_tables_list::destroy_query_tables_list() <nl>   <nl>  st_lex::st_lex() <nl>    :result(0), yacc_yyss(0), yacc_yyvs(0), <nl> -   sql_command(SQLCOM_END) <nl> +   sql_command(SQLCOM_END), option_type(OPT_DEFAULT) <nl>  { <nl>    /* Check that plugins_static_buffer is declared immediately after plugins */ <nl>    compile_time_assert((&plugins + 1) == (DYNAMIC_ARRAY*)plugins_static_buffer);
@@ -457,6 +457,7 @@ static int run_query(const char *query, DYNAMIC_STRING *ds_res, <nl>                  NULL); <nl>   <nl>    my_close(fd, MYF(0)); <nl> +  my_delete(query_file_path, MYF(0)); <nl>   <nl>    DBUG_RETURN(ret); <nl>  }
@@ -2166,7 +2166,7 @@ com_go(String *buffer,char *line __attribute__((unused))) <nl>  { <nl>    char		buff[200], time_buff[32], *pos; <nl>    MYSQL_RES	*result; <nl> -  ulong		timer, warnings; <nl> +  ulong		timer, warnings= 0; <nl>    uint		error= 0; <nl>    int           err= 0; <nl>  
@@ -957,6 +957,12 @@ i_s_zip_fill_low( <nl>   <nl>  	DBUG_ENTER("i_s_zip_fill_low"); <nl>   <nl> +	/* deny access to non-superusers */ <nl> +	if (check_global_access(thd, SUPER_ACL)) { <nl> + <nl> +		DBUG_RETURN(0); <nl> +	} <nl> + <nl>  	/* Determine log2(PAGE_ZIP_MIN_SIZE / 2 / BUF_BUDDY_LOW). */ <nl>  	for (uint r = PAGE_ZIP_MIN_SIZE / 2 / BUF_BUDDY_LOW; r >>= 1; y++); <nl>  
@@ -60,7 +60,9 @@ int toku_keycompare (bytevec key1, ITEMLEN key1len, bytevec key2, ITEMLEN key2le <nl>  	    return (int)*k1-(int)*k2; <nl>  	} <nl>      } <nl> -    return key1len-key2len; <nl> +    if (key1len<key2len) return -1; <nl> +    if (key1len>key2len) return 1; <nl> +    return 0; <nl>  } <nl>  #else <nl>  /* unroll that one four times */ <nl> @@ -84,8 +86,9 @@ int toku_keycompare (bytevec key1, ITEMLEN key1len, bytevec key2, ITEMLEN key2le <nl>  	    return (int)*k1-(int)*k2; <nl>  	} <nl>      } <nl> -    //See #1576.  For very large keylengths this is a problem.  Our maximum keysize is << INT_MAX so this is not an issue. <nl> -    return key1len-key2len; <nl> +    if (key1len<key2len) return -1; <nl> +    if (key1len>key2len) return 1; <nl> +    return 0; <nl>  } <nl>   <nl>  #endif
@@ -1149,7 +1149,7 @@ bool check_change_password(THD *thd, const char *host, const char *user, <nl>      return(1); <nl>    } <nl>    uint len=strlen(new_password); <nl> -  if (len != SCRAMBLED_PASSWORD_CHAR_LENGTH && <nl> +  if (len && len != SCRAMBLED_PASSWORD_CHAR_LENGTH && <nl>        len != SCRAMBLED_PASSWORD_CHAR_LENGTH_323) <nl>    { <nl>      net_printf(thd, 0,
@@ -33,7 +33,7 @@ bool rollback_log_node_cache::give_rollback_log_node(TOKUTXN txn, ROLLBACK_LOG_N <nl>      if (m_num_avail < m_max_num_avail) { <nl>          retval = true; <nl>          uint32_t index = m_first + m_num_avail; <nl> -        if (index > m_max_num_avail) { <nl> +        if (index >= m_max_num_avail) { <nl>              index -= m_max_num_avail; <nl>          } <nl>          m_avail_blocknums[index].b = log->blocknum.b;
@@ -6066,6 +6066,9 @@ check_quick_keys(PARAM *param,uint idx,SEL_ARG *key_tree, <nl>      tmp_max_flag=max_key_flag | key_tree->max_flag; <nl>    } <nl>   <nl> +  if (unlikely(param->thd->killed != 0)) <nl> +    return HA_POS_ERROR; <nl> + <nl>    keynr=param->real_keynr[idx]; <nl>    param->range_count++; <nl>    if (!tmp_min_flag && ! tmp_max_flag &&
@@ -1507,7 +1507,6 @@ btr_search_update_hash_on_delete( <nl>  	rec_t*		rec; <nl>  	ulint		fold; <nl>  	index_id_t	index_id; <nl> -	ibool		found; <nl>  	ulint		offsets_[REC_OFFS_NORMAL_SIZE]; <nl>  	mem_heap_t*	heap		= NULL; <nl>  	rec_offs_init(offsets_); <nl> @@ -1540,7 +1539,7 @@ btr_search_update_hash_on_delete( <nl>  	} <nl>  	rw_lock_x_lock(&btr_search_latch); <nl>   <nl> -	found = ha_search_and_delete_if_found(table, fold, rec); <nl> +	ha_search_and_delete_if_found(table, fold, rec); <nl>   <nl>  	rw_lock_x_unlock(&btr_search_latch); <nl>  }
@@ -302,7 +302,8 @@ int select_union_recursive::send_data(List<Item> &values) <nl>  { <nl>    int rc= select_unit::send_data(values); <nl>   <nl> -  if (write_err != HA_ERR_FOUND_DUPP_KEY &&  <nl> +  if (rc == 0 && <nl> +      write_err != HA_ERR_FOUND_DUPP_KEY && <nl>        write_err != HA_ERR_FOUND_DUPP_UNIQUE) <nl>    {  <nl>      int err;
@@ -435,6 +435,13 @@ MI_INFO *mi_open(const char *name, int mode, uint open_flags) <nl>        offset+=share->rec[i].length; <nl>      } <nl>      share->rec[i].type=(int) FIELD_LAST;	/* End marker */ <nl> +    if (offset > share->base.reclength) <nl> +    { <nl> +      /* purecov: begin inspected */ <nl> +      my_errno= HA_ERR_CRASHED; <nl> +      goto err; <nl> +      /* purecov: end */ <nl> +    } <nl>   <nl>      if (! lock_error) <nl>      {
@@ -1806,6 +1806,9 @@ buf_LRU_block_remove_hashed_page( <nl>  			void*	data = bpage->zip.data; <nl>  			bpage->zip.data = NULL; <nl>   <nl> +			ut_ad(!bpage->in_free_list); <nl> +			ut_ad(!bpage->in_flush_list); <nl> +			ut_ad(!bpage->in_LRU_list); <nl>  			mutex_exit(&((buf_block_t*) bpage)->mutex); <nl>  			buf_pool_mutex_exit_forbid(); <nl>  			buf_buddy_free(data, page_zip_get_size(&bpage->zip));
@@ -7851,6 +7851,11 @@ int ha_tokudb::delete_all_rows() { <nl>              txn <nl>              ); <nl>          if (error) { goto cleanup; } <nl> +        error = share->key_file[i]->pre_acquire_table_lock( <nl> +            share->key_file[i],  <nl> +            txn <nl> +            ); <nl> +        if (error) { goto cleanup; } <nl>      } <nl>      for (uint i = 0; i < curr_num_DBs; i++) { <nl>          error = truncate_dictionary(i, txn);
@@ -1460,6 +1460,7 @@ dict_index_add_to_cache( <nl>   <nl>  	if (!dict_index_find_cols(table, index)) { <nl>   <nl> +		dict_mem_index_free(index); <nl>  		return(DB_CORRUPTION); <nl>  	} <nl>  
@@ -7464,6 +7464,13 @@ int ha_rocksdb::calc_eq_cond_len(const Rdb_key_def &kd, <nl>      */ <nl>      return slice.size() - bytes_changed_by_succ; <nl>    } <nl> +  if (find_flag == HA_READ_PREFIX_LAST_OR_PREV) { <nl> +    /* <nl> +      We are interested in records with or without the specified prefix, so <nl> +      the only limit is that records are from this index <nl> +    */ <nl> +    return Rdb_key_def::INDEX_NUMBER_SIZE; <nl> +  } <nl>   <nl>    if (end_key) { <nl>      *end_key_packed_size =
@@ -1627,8 +1627,8 @@ bool dispatch_command(enum enum_server_command command, THD *thd, <nl>  	break; <nl>        mysql_log.write(thd,command,packet); <nl>        bzero(&create_info, sizeof(create_info)); <nl> -      error= mysql_create_db(thd, (lower_case_table_names == 2 ? alias : db), <nl> -                             &create_info, 0); <nl> +      mysql_create_db(thd, (lower_case_table_names == 2 ? alias : db), <nl> +                      &create_info, 0); <nl>        break; <nl>      } <nl>    case COM_DROP_DB:				// QQ: To be removed <nl> @@ -1651,8 +1651,8 @@ bool dispatch_command(enum enum_server_command command, THD *thd, <nl>  	break; <nl>        } <nl>        mysql_log.write(thd,command,db); <nl> -      error= mysql_rm_db(thd, (lower_case_table_names == 2 ? alias : db), <nl> -                         0, 0) ; <nl> +      mysql_rm_db(thd, (lower_case_table_names == 2 ? alias : db), <nl> +                       0, 0); <nl>        break; <nl>      } <nl>  #ifndef EMBEDDED_LIBRARY
@@ -807,13 +807,17 @@ Dbtup::updateFixedSizeTHManyWordNotNULL(Uint32* inBuffer, <nl>        if (charsetFlag) { <nl>          ljam(); <nl>          Tablerec* regTabPtr = tabptr.p; <nl> +	Uint32 typeId = AttributeDescriptor::getType(attrDescriptor); <nl>          Uint32 bytes = AttributeDescriptor::getSizeInBytes(attrDescriptor); <nl>          Uint32 i = AttributeOffset::getCharsetPos(attrDes2); <nl>          ndbrequire(i < regTabPtr->noOfCharsets); <nl>          // not const in MySQL <nl>          CHARSET_INFO* cs = regTabPtr->charsetArray[i]; <nl>          const char* ssrc = (const char*)&inBuffer[tInBufIndex + 1]; <nl> -        if ((*cs->cset->well_formed_len)(cs, ssrc, ssrc + bytes, ZNIL) != bytes) { <nl> +	// fast fix bug#7340 <nl> +        if (typeId != NDB_TYPE_TEXT && <nl> +	    (*cs->cset->well_formed_len)(cs, ssrc, ssrc+bytes, ZNIL) != bytes) <nl> +	{ <nl>            ljam(); <nl>            terrorCode = ZINVALID_CHAR_FORMAT; <nl>            return false;
@@ -3896,7 +3896,7 @@ int ha_tokudb::write_row(uchar * record) { <nl>          } <nl>      } <nl>       <nl> -    txn = create_sub_trans ? sub_trans : transaction;     <nl> +    txn = create_sub_trans ? sub_trans : transaction; <nl>   <nl>      if (tokudb_debug & TOKUDB_DEBUG_CHECK_KEY) { <nl>          test_row_packing(record,&prim_key,&row); <nl> @@ -7484,7 +7484,9 @@ int ha_tokudb::tokudb_add_index( <nl>          error = indexer->build(indexer); <nl>          if (error) { goto cleanup; } <nl>   <nl> +        rw_wrlock(&share->num_DBs_lock); <nl>          error = indexer->close(indexer); <nl> +        rw_unlock(&share->num_DBs_lock); <nl>          if (error) { goto cleanup; } <nl>          indexer = NULL; <nl>      } <nl> @@ -7660,7 +7662,9 @@ int ha_tokudb::tokudb_add_index( <nl>      if (indexer != NULL) { <nl>          sprintf(status_msg, "aborting creation of indexes."); <nl>          thd_proc_info(thd, status_msg); <nl> +        rw_wrlock(&share->num_DBs_lock); <nl>          indexer->abort(indexer); <nl> +        rw_unlock(&share->num_DBs_lock); <nl>      } <nl>      if (error == DB_LOCK_NOTGRANTED && ((tokudb_debug & TOKUDB_DEBUG_HIDE_DDL_LOCK_ERRORS) == 0)) { <nl>          sql_print_error("Could not add indexes to table %s because \
@@ -3236,7 +3236,7 @@ void ha_tokudb::start_bulk_insert(ha_rows rows) { <nl>      lock_count = 0; <nl>       <nl>      if ((rows == 0 || rows > 1) && share->try_table_lock) { <nl> -        if (get_prelock_empty(thd) && may_table_be_empty(transaction)) { <nl> +        if (get_prelock_empty(thd) && may_table_be_empty(transaction) && transaction != NULL) { <nl>              if (using_ignore || is_insert_ignore(thd) || thd->lex->duplicates != DUP_ERROR) { <nl>                  acquire_table_lock(transaction, lock_write); <nl>              }
@@ -368,8 +368,6 @@ row_purge_remove_sec_if_poss_low( <nl>   <nl>  	mtr_start(&mtr); <nl>   <nl> -	btr_cur->thr = que_node_get_parent(node); <nl> - <nl>  	row_search_index_entry(&was_buffered, index, entry, <nl>  			       BTR_MODIFY_LEAF | BTR_DELETE, &pcur, <nl>  			       &mtr);
@@ -247,8 +247,9 @@ buf_shrink_freelists(int free_all) <nl>          --n_to_free; <nl>        } <nl>        tor_assert(!n_to_free); <nl> -      freelists[i].lowest_length = freelists[i].cur_length = n_to_skip; <nl> +      freelists[i].cur_length = n_to_skip; <nl>      } <nl> +    freelists[i].lowest_length = freelists[i].cur_length; <nl>      assert_freelist_ok(&freelists[i]); <nl>    } <nl>  }
@@ -2420,7 +2420,7 @@ entry_guard_encode_for_state(entry_guard_t *guard) <nl>                             fmt_and_decorate_addr(&guard->bridge_addr->addr), <nl>                             guard->bridge_addr->port); <nl>    } <nl> -  if (strlen(guard->nickname)) { <nl> +  if (strlen(guard->nickname) && is_legal_nickname(guard->nickname)) { <nl>      smartlist_add_asprintf(result, "nickname=%s", guard->nickname); <nl>    } <nl>  
@@ -1109,6 +1109,11 @@ hs_circ_send_introduce1(origin_circuit_t *intro_circ, <nl>    /* This takes various objects in order to populate the introduce1 data <nl>     * object which is used to build the content of the cell. */ <nl>    const node_t *exit_node = build_state_get_exit_node(rend_circ->build_state); <nl> +  if (exit_node == NULL) { <nl> +    log_info(LD_REND, "Unable to get rendezvous point for circuit %u. " <nl> +             "Failing.", TO_CIRCUIT(intro_circ)->n_circ_id); <nl> +    goto done; <nl> +  } <nl>    setup_introduce1_data(ip, exit_node, subcredential, &intro1_data); <nl>    /* If we didn't get any link specifiers, it's because our node was <nl>     * bad. */
@@ -177,7 +177,7 @@ memarea_alloc(memarea_t *area, size_t sz) <nl>    char *result; <nl>    tor_assert(chunk); <nl>    if (chunk->next_mem+sz > chunk->u.mem+chunk->mem_size) { <nl> -    if (sz+CHUNK_HEADER_SIZE >= area->chunk_size) { <nl> +    if (sz+CHUNK_HEADER_SIZE >= CHUNK_SIZE) { <nl>        /* This allocation is too big.  Stick it in a special chunk, and put <nl>         * that chunk second in the list. */ <nl>        memarea_chunk_t *new_chunk = alloc_chunk(sz+CHUNK_HEADER_SIZE, 0);
@@ -1037,7 +1037,7 @@ policies_parse_exit_policy_internal(config_line_t *cfg, smartlist_t **dest, <nl>                   "address", fmt_addr(ipv6_local_address)); <nl>        } else { <nl>          char buf6[POLICY_BUF_LEN]; <nl> -        tor_snprintf(buf6, sizeof(buf6), "reject %s:*", <nl> +        tor_snprintf(buf6, sizeof(buf6), "reject [%s]:*", <nl>                       fmt_addr(ipv6_local_address)); <nl>          append_exit_policy_string(dest, buf6); <nl>          log_info(LD_CONFIG, "Adding a reject ExitPolicy '%s' for our " <nl> @@ -1075,7 +1075,7 @@ policies_parse_exit_policy_internal(config_line_t *cfg, smartlist_t **dest, <nl>             * address */ <nl>            if (ipv6_local_address == NULL <nl>                || !tor_addr_eq(ipv6_local_address, a)) { <nl> -            tor_snprintf(bufif, sizeof(bufif), "reject6 %s:*", <nl> +            tor_snprintf(bufif, sizeof(bufif), "reject6 [%s]:*", <nl>                           fmt_addr(a)); <nl>              append_exit_policy_string(dest, bufif); <nl>              log_info(LD_CONFIG, "Adding a reject ExitPolicy '%s' for a local "
@@ -873,6 +873,7 @@ directory_remove_invalid(void) <nl>      directory_set_dirty(); <nl>   <nl>    routerlist_assert_ok(rl); <nl> +  smartlist_free(nodes); <nl>  } <nl>   <nl>  /** Mark the directory as <b>dirty</b> -- when we're next asked for a
@@ -606,8 +606,11 @@ networkstatus_check_consensus_signature(networkstatus_t *consensus, <nl>        char *tmp = smartlist_join_strings(list_good, " ", 0, NULL); <nl>        smartlist_add_asprintf(sl, <nl>                     "A consensus needs %d good signatures from recognized " <nl> -                   "authorities for us to accept it. This one has %d (%s).", <nl> -                   n_required, n_good, tmp); <nl> +                   "authorities for us to accept it. " <nl> +                   "This %s one has %d (%s).", <nl> +                   n_required, <nl> +                   networkstatus_get_flavor_name(consensus->flavor), <nl> +                   n_good, tmp); <nl>        tor_free(tmp); <nl>        if (n_no_signature) { <nl>          tmp = smartlist_join_strings(list_no_signature, " ", 0, NULL);
@@ -1792,7 +1792,8 @@ add_an_entry_guard(routerinfo_t *chosen) <nl>   <nl>  again: <nl>    if (--tries_left <= 0) { <nl> -    log_warn(LD_CIRC, "Tried finding a new entry, but failed. Bad news. XXX."); <nl> +    log_warn(LD_CIRC, "Tried finding a new entry guard, but failed. " <nl> +             "Can you reach the Tor network?"); <nl>      return NULL; <nl>    } <nl>    if (chosen)
@@ -398,6 +398,9 @@ add_an_entry_guard(const node_t *chosen, int reset_status, int prepend, <nl>          entry->can_retry = 1; <nl>        } <nl>        entry->is_dir_cache = node_is_dir(node); <nl> +      if (get_options()->UseBridges && node_is_a_configured_bridge(node)) <nl> +        entry->is_dir_cache = 1; <nl> + <nl>        return NULL; <nl>      } <nl>    } else if (!for_directory) {
@@ -4180,8 +4180,11 @@ tor_spawn_background(const char *const filename, const char **argv, <nl>                       process_environment_t *env, <nl>                       process_handle_t **process_handle_out) <nl>  { <nl> -  if (may_spawn_background_process == 0) <nl> +  if (BUG(may_spawn_background_process == 0)) { <nl> +    /* We should never reach this point if we're forbidden to spawn <nl> +     * processes. Instead we should have caught the attempt earlier. */ <nl>      return PROCESS_STATUS_ERROR; <nl> +  } <nl>   <nl>  #ifdef _WIN32 <nl>    HANDLE stdout_pipe_read = NULL;
@@ -287,7 +287,7 @@ const lword LWORD_MAX = W64LIT(0xffffffffffffffff); <nl>  #else <nl>  	#define CRYPTOPP_NATIVE_DWORD_AVAILABLE 1 <nl>  	#if defined(__alpha__) || defined(__ia64__) || defined(_ARCH_PPC64) || defined(__x86_64__) || defined(__mips64) || defined(__sparc64__) <nl> -#if defined(__GNUC__) && !defined(__INTEL_COMPILER) && !(CRYPTOPP_GCC_VERSION == 40001 && defined(__APPLE__)) && !(defined(__GNUC__) && CRYPTOPP_GCC_VERSION < 50000 && defined(_ARCH_PPC64)) && CRYPTOPP_GCC_VERSION >= 30400 <nl> +		#if ((CRYPTOPP_GCC_VERSION >= 30400) || (CRYPTOPP_LLVM_CLANG_VERSION >= 30000) || (CRYPTOPP_APPLE_CLANG_VERSION >= 40300)) && (__SIZEOF_INT128__ >= 16) <nl>  			// GCC 4.0.1 on MacOS X is missing __umodti3 and __udivti3 <nl>  			// GCC 4.8.3 and bad uint128_t ops on PPC64/POWER7 (Issue 421) <nl>  			// mode(TI) division broken on amd64 with GCC earlier than GCC 3.4
@@ -41,6 +41,7 @@ public: <nl>   <nl>  	inline size_t Put(const byte *begin, size_t length) <nl>  	{ <nl> +		if(!begin || !length) return length; <nl>  		size_t l = STDMIN(length, MaxSize()-m_tail); <nl>  		if (buf+m_tail != begin) <nl>  			memcpy(buf+m_tail, begin, l); <nl> @@ -59,6 +60,7 @@ public: <nl>   <nl>  	inline size_t Peek(byte *target, size_t copyMax) const <nl>  	{ <nl> +		if(!target || !copyMax) return 0; <nl>  		size_t len = STDMIN(copyMax, m_tail-m_head); <nl>  		memcpy(target, buf+m_head, len); <nl>  		return len;
@@ -286,8 +286,9 @@ void telnetSendChar(char ch) { <nl>  bool telnetRecv(JsNetwork *net) { <nl>    if (tnSrv.sock == 0 || tnSrv.cliSock == 0) return false; <nl>   <nl> -  char buff[256]; <nl> -  int r = netRecv(net, ST_NORMAL, tnSrv.cliSock-1, buff, 256); <nl> +  char buff[64]; <nl> +  if (!jshHasEventSpaceForChars(sizeof(buff))) return false; <nl> +  int r = netRecv(net, ST_NORMAL, tnSrv.cliSock-1, buff, sizeof(buff)); <nl>    if (r > 0) { <nl>      jshPushIOCharEvents(EV_TELNET, buff, (unsigned int)r); <nl>    } else if (r < 0) {
@@ -88,6 +88,7 @@ courier_t::read_bytes( char *buf, const size_t size ) <nl>  	ptr = buf; <nl>  	while ( bytes_remaining > 0 ) { <nl>  		bytes_read = read( m_fd, ptr, bytes_remaining ); <nl> +		if ( bytes_read == 0 ) return 0; <nl>  		if ( bytes_read < 0 ) return 0; <nl>  		bytes_remaining -= bytes_read; <nl>  		ptr += bytes_read;
@@ -62,6 +62,8 @@ extern char *wckey_day_table; <nl>  extern char *wckey_hour_table; <nl>  extern char *wckey_month_table; <nl>   <nl> +extern __thread bool drop_priv; <nl> + <nl>  /* <nl>   * We want SLURMDB_MODIFY_ASSOC always to be the last <nl>   */ <nl> @@ -466,6 +468,10 @@ extern bool is_user_min_admin_level(void *db_conn, uid_t uid, <nl>  	 * THERE IS NO AUTHENTICATION WHEN RUNNNING OUT OF THE <nl>  	 * SLURMDBD! <nl>  	 */ <nl> +#ifndef NDEBUG <nl> +	if (drop_priv) <nl> +		return false; <nl> +#endif <nl>  	if (slurmdbd_conf) { <nl>  		/* We have to check the authentication here in the <nl>  		 * plugin since we don't know what accounts are being
@@ -1648,10 +1648,11 @@ static void _set_options(const int argc, char **argv) <nl>  		} <nl>  	} <nl>   <nl> -	/* This means it was read from the environment.  We will <nl> -	 * override it with what the user specified in the hostlist. <nl> -	 */ <nl> -	if (!ntasks_set_opt && (opt.distribution == SLURM_DIST_ARBITRARY)) <nl> +	/* This means --ntasks was read from the environment.  We will override <nl> +	 * it with what the user specified in the hostlist. POE launched <nl> +	 * jobs excluded (they have the SLURM_STARTED_STEP env var set). */ <nl> +	if (!ntasks_set_opt && (opt.distribution == SLURM_DIST_ARBITRARY) && <nl> +	    !getenv("SLURM_STARTED_STEP")) <nl>  		opt.ntasks_set = false; <nl>   <nl>  	spank_option_table_destroy (optz);
@@ -1558,6 +1558,8 @@ static int _get_hash_idx(const char *name) <nl>  	index %= NAME_HASH_LEN; <nl>  	if (index < 0) <nl>  		index += NAME_HASH_LEN; <nl> +	if (index < 0) <nl> +		index = 0 /* Can never happen, but clears a Coverity error */ <nl>   <nl>  	return index; <nl>  }
@@ -1070,7 +1070,7 @@ _process_command (int argc, char *argv[]) <nl>  					fprintf(stderr, "invalid debug " <nl>  						"flag: %s\n", argv[i]); <nl>  				} <nl> -				if ((quiet_flag != 1) &&  (mode = 0)) { <nl> +				if ((quiet_flag != 1) && (mode == 0)) { <nl>  					fprintf(stderr, "Usage: setdebugflags" <nl>  						" [+|-]NAME\n"); <nl>  				}
@@ -1122,14 +1122,14 @@ line15: <nl>  	} <nl>   <nl>  	/****** Line 35 (optional) ******/ <nl> -	if (cpu_freq_debug(NULL, NULL, tmp_line, sizeof(tmp_line), <nl> +	if (cpu_freq_debug(NULL, NULL, tmp1, sizeof(tmp1), <nl>  			   job_ptr->cpu_freq_gov, job_ptr->cpu_freq_min, <nl>  			   job_ptr->cpu_freq_max, NO_VAL) != 0) { <nl> - <nl>  		if (one_liner) <nl>  			xstrcat(out, " "); <nl>  		else <nl> -			xstrcat(out, "\n  "); <nl> +			xstrcat(out, "\n   "); <nl> +		snprintf(tmp_line, sizeof(tmp_line), "CpuFreq=%s", tmp1); <nl>  		xstrcat(out, tmp_line); <nl>  	} <nl>  
@@ -6541,13 +6541,19 @@ extern int validate_job_create_req(job_desc_msg_t * job_desc, uid_t submit_uid, <nl>  	 * Check user permission for negative 'nice' and non-0 priority values <nl>  	 * (restricted to root, SlurmUser, or SLURMDB_ADMIN_OPERATOR) _before_ <nl>  	 * running the job_submit plugin. <nl> +	 * Also prevent unpriviledged users from submitting jobs with an <nl> +	 * AdminComment field set. <nl>  	 */ <nl>  	if (!validate_operator(submit_uid)) { <nl>  		if (job_desc->priority != 0) <nl>  			job_desc->priority = NO_VAL; <nl>  		if (job_desc->nice < NICE_OFFSET) <nl>  			job_desc->nice = NICE_OFFSET; <nl> + <nl> +		if (job_desc->admin_comment) <nl> +			return ESLURM_ACCESS_DENIED; <nl>  	} <nl> + <nl>  	rc = job_submit_plugin_submit(job_desc, (uint32_t) submit_uid, err_msg); <nl>  	if (rc != SLURM_SUCCESS) <nl>  		return rc;
@@ -1312,6 +1312,7 @@ slurm_load_job (job_info_msg_t **resp, uint32_t job_id, uint16_t show_flags) <nl>  	slurm_msg_t_init(&req_msg); <nl>  	slurm_msg_t_init(&resp_msg); <nl>   <nl> +	bzero(&req, sizeof(job_id_msg_t)); <nl>  	req.job_id = job_id; <nl>  	req.show_flags = show_flags; <nl>  	req_msg.msg_type = REQUEST_JOB_INFO_SINGLE; <nl> @@ -1563,9 +1564,10 @@ extern int slurm_job_node_ready(uint32_t job_id) <nl>  	slurm_msg_t_init(&req); <nl>  	slurm_msg_t_init(&resp); <nl>   <nl> +	bzero(&msg, sizeof(job_id_msg_t)); <nl> +	msg.job_id   = job_id; <nl>  	req.msg_type = REQUEST_JOB_READY; <nl>  	req.data     = &msg; <nl> -	msg.job_id   = job_id; <nl>   <nl>  	if (slurm_send_recv_controller_msg(&req, &resp) < 0) <nl>  		return READY_JOB_ERROR;
@@ -3431,6 +3431,9 @@ extern int slurm_free_msg_data(slurm_msg_type_t type, void *data) <nl>  	case RESPONSE_BURST_BUFFER_INFO: <nl>  		slurm_free_burst_buffer_info_msg(data); <nl>  		break; <nl> +	case MESSAGE_COMPOSITE: <nl> +		slurm_free_composite_msg(data); <nl> +		break; <nl>  	default: <nl>  		error("invalid type trying to be freed %u", type); <nl>  		break;
@@ -2634,6 +2634,15 @@ _signal_jobstep(uint32_t jobid, uint32_t stepid, uid_t req_uid, <nl>  	uid_t uid; <nl>  	uint16_t protocol_version; <nl>   <nl> +	/*  There will be no stepd if the prolog is still running <nl> +	 *   Return failure so caller can retry. <nl> +	 */ <nl> +	if (_prolog_is_running (jobid)) { <nl> +		info ("signal %d req for %u.%u while prolog is running." <nl> +		      " Returning failure.", signal, jobid, stepid); <nl> +		return SLURM_FAILURE; <nl> +	} <nl> + <nl>  	fd = stepd_connect(conf->spooldir, conf->node_name, jobid, stepid, <nl>  			   &protocol_version); <nl>  	if (fd == -1) {
@@ -1176,7 +1176,8 @@ extern void create_srun_job(void **p_job, bool *got_alloc, <nl>  								 opt_local); <nl>  				if (!job) <nl>  					exit(error_exit); <nl> -				job->pack_offset = pack_offset; <nl> +				if (max_pack_offset > 0) <nl> +					job->pack_offset = pack_offset; <nl>  				list_append(srun_job_list, job); <nl>  			}	/* While more option structures */ <nl>  			pack_offset++;
@@ -1124,6 +1124,7 @@ static void _slurm_rpc_allocate_resources(slurm_msg_t * msg) <nl>   <nl>  		if (slurm_send_node_msg(msg->conn_fd, &response_msg) < 0) <nl>  			_kill_job_on_msg_fail(job_ptr->job_id); <nl> +		xfree(alloc_msg.account); <nl>  		xfree(alloc_msg.cpu_count_reps); <nl>  		xfree(alloc_msg.cpus_per_node); <nl>  		xfree(alloc_msg.node_list); <nl> @@ -2705,6 +2706,7 @@ static void _slurm_rpc_job_alloc_info_lite(slurm_msg_t * msg) <nl>   <nl>  		xfree(job_info_resp_msg.cpu_count_reps); <nl>  		xfree(job_info_resp_msg.cpus_per_node); <nl> +		xfree(job_info_resp_msg.account); <nl>  		xfree(job_info_resp_msg.alias_list); <nl>  		xfree(job_info_resp_msg.node_list); <nl>  		xfree(job_info_resp_msg.partition);
@@ -353,14 +353,20 @@ extern int configure_small_block(bg_record_t *bg_record) <nl>  	} <nl>   <nl>  	 <nl> +	if(!bp_id) { <nl> +		error("No BP ID was returned from database"); <nl> +		continue; <nl> +	} <nl> + <nl>  	if ((rc = bridge_get_nodecards(bp_id, &ncard_list)) <nl>  	    != STATUS_OK) { <nl>  		error("bridge_get_nodecards(%s): %d", <nl>  		      bp_id, rc); <nl> -		 <nl> +		free(bp_id); <nl>  		return SLURM_ERROR; <nl>  	} <nl> -	 <nl> +	free(bp_id); <nl> +		 <nl>  			 <nl>  	if((rc = bridge_get_data(ncard_list, RM_NodeCardListSize, &num)) <nl>  	   != STATUS_OK) {
@@ -1053,7 +1053,7 @@ static int _load_jobs(slurm_msg_t *req_msg, job_info_msg_t **job_info_msg_pptr, <nl>  	int i, j, rc = SLURM_SUCCESS; <nl>  	int local_job_cnt; <nl>  	slurm_msg_t resp_msg, resp_msg_fed; <nl> -	job_info_msg_t *orig_msg = NULL, *new_msg; <nl> +	job_info_msg_t *orig_msg = NULL, *new_msg = NULL; <nl>  	uint32_t new_rec_cnt; <nl>  	uint32_t hash_inx, *hash_tbl_size = NULL, **hash_job_id = NULL; <nl>  	slurmdb_cluster_rec_t *cluster;
@@ -1085,7 +1085,7 @@ extern char *find_hostname(uint32_t pos, char *hosts) <nl>  	hostlist_t hostlist = NULL; <nl>  	char *temp = NULL, *host = NULL; <nl>   <nl> -	if (!hosts || (pos == NO_VAL)) <nl> +	if (!hosts || (pos == NO_VAL) || (pos == INFINITE)) <nl>  		return NULL; <nl>   <nl>  	hostlist = hostlist_create(hosts);
@@ -1801,7 +1801,7 @@ _run_script_as_user(const char *name, const char *path, slurmd_job_t *job, <nl>  			break; <nl>  		} else if (rc == 0) { <nl>  			sleep(1); <nl> -			if ((--max_wait) == 0) { <nl> +			if ((--max_wait) <= 0) { <nl>  				killpg(cpid, SIGKILL); <nl>  				opt = 0; <nl>  			} <nl> @@ -1810,7 +1810,7 @@ _run_script_as_user(const char *name, const char *path, slurmd_job_t *job, <nl>  			break; <nl>  		} <nl>  	} <nl> -	/* Insure that all child processes get killed */ <nl> +	/* Insure that all child processes get killed, one last time */ <nl>  	killpg(cpid, SIGKILL); <nl>  	slurm_container_signal(job->cont_id, SIGKILL); <nl>  	
@@ -663,11 +663,17 @@ extern void slurmdb_free_assoc_rec_members(slurmdb_assoc_rec_t *assoc) <nl>  		xfree(assoc->acct); <nl>  		xfree(assoc->cluster); <nl>  		xfree(assoc->grp_tres); <nl> +		xfree(assoc->grp_tres_ctld); <nl>  		xfree(assoc->grp_tres_mins); <nl> +		xfree(assoc->grp_tres_mins_ctld); <nl>  		xfree(assoc->grp_tres_run_mins); <nl> +		xfree(assoc->grp_tres_run_mins_ctld); <nl>  		xfree(assoc->max_tres_mins_pj); <nl> +		xfree(assoc->max_tres_mins_ctld); <nl>  		xfree(assoc->max_tres_run_mins); <nl> +		xfree(assoc->max_tres_run_mins_ctld); <nl>  		xfree(assoc->max_tres_pj); <nl> +		xfree(assoc->max_tres_ctld); <nl>  		xfree(assoc->parent_acct); <nl>  		xfree(assoc->partition); <nl>  		FREE_NULL_LIST(assoc->qos_list);
@@ -266,7 +266,8 @@ bool slurm_container_has_pid (uint32_t cont_id, pid_t pid) <nl>   <nl>  int slurm_container_wait (uint32_t id) <nl>  { <nl> -	if (_job_waitjid ((jid_t) id, NULL, 0) == (jid_t)-1) <nl> +	int status; <nl> +	if (_job_waitjid ((jid_t) id, &status, 0) == (jid_t)-1) <nl>  		return SLURM_ERROR; <nl>   <nl>  	return SLURM_SUCCESS;
@@ -189,6 +189,12 @@ static int	_will_run_test(uint32_t jobid, char *hostlist, <nl>  			"SC=1 Job %d runnable later TASKLIST:%s", <nl>  			jobid, picked_node_list); <nl>  		*err_msg = reply_msg; <nl> +	} else if (rc == ESLURM_REQUESTED_PART_CONFIG_UNAVAILABLE) { <nl> +		*err_code = 1; <nl> +		snprintf(reply_msg, sizeof(reply_msg), <nl> +			"SC=1 Job %d not runnable with current configuration", <nl> +			jobid); <nl> +		*err_msg = reply_msg; <nl>  	} else { <nl>  		char *err_str = slurm_strerror(rc); <nl>  		error("wiki: job %d never runnable on hosts=%s %s", 
@@ -27,6 +27,9 @@ <nl>   ****************************************************************************** <nl>   * <nl>   * $Log$ <nl> + * Revision 1.333  2006/10/24 05:08:43  sdlime <nl> + * Fixed one more issue with loadExpressionString... <nl> + * <nl>   * Revision 1.332  2006/10/24 04:40:31  sdlime <nl>   * Fixed a problem in loadExpressionString so that if an expression string is not a logical, regex or case insensitive expression then it is automatically a string expression. This allows more straight forward filter and expression setting from MapScript. <nl>   * <nl> @@ -1710,7 +1713,10 @@ int loadExpressionString(expressionObj *exp, char *value) <nl>    } else { <nl>      msResetErrorList(); /* failure above is not really an error since we'll consider anything not matching (like an unquoted number) as a STRING) */ <nl>      exp->type = MS_STRING; <nl> -    exp->string = strdup(value); /* use the whole value */ <nl> +    if((strlen(value) - strlen(msyytext)) == 2) <nl> +      exp->string = strdup(msyytext); /* value was quoted */ <nl> +    else <nl> +      exp->string = strdup(value); /* use the whole value */ <nl>    } <nl>   <nl>    /* if(exp->type == MS_REGEX) { */
@@ -29,6 +29,9 @@ <nl>   ****************************************************************************** <nl>   * <nl>   * $Log$ <nl> + * Revision 1.31  2004/09/29 17:12:13  frank <nl> + * fixed casting issues to avoid warnings <nl> + * <nl>   * Revision 1.30  2004/09/03 14:24:07  frank <nl>   * %p cannot be encoded and decoded properly on win32 <nl>   * <nl> @@ -1063,7 +1066,7 @@ LoadGDALImage( GDALRasterBandH hBand, int iColorIndex,  layerObj *layer, <nl>   <nl>      for( i = 0; i < nPixelCount; i++ ) <nl>      { <nl> -        float fScaledValue = (pafRawData[i] - dfScaleMin) * dfScaleRatio; <nl> +        float fScaledValue = (float) ((pafRawData[i]-dfScaleMin)*dfScaleRatio); <nl>   <nl>          if( fScaledValue < 0.0 ) <nl>              pabyBuffer[i] = 0; <nl> @@ -1518,7 +1521,7 @@ msDrawRasterLayerGDAL_16BitClassification( <nl>          return -1; <nl>      } <nl>   <nl> -    fNoDataValue = msGetGDALNoDataValue( layer, hBand, &bGotNoData ); <nl> +    fNoDataValue = (float) msGetGDALNoDataValue( layer, hBand, &bGotNoData ); <nl>   <nl>  /* ==================================================================== */ <nl>  /*      Determine scaling.                                              */ <nl> @@ -1658,7 +1661,7 @@ msDrawRasterLayerGDAL_16BitClassification( <nl>   <nl>          dfOriginalValue = (i+0.5) / dfScaleRatio + dfScaleMin; <nl>               <nl> -        c = msGetClass_Float(layer, dfOriginalValue); <nl> +        c = msGetClass_Float(layer, (float) dfOriginalValue); <nl>          if( c != -1 ) <nl>          { <nl>              RESOLVE_PEN_GD(gdImg, layer->class[c].styles[0].color);
@@ -985,7 +985,7 @@ int msRenderSVGToPixmap(symbolObj *symbol, symbolStyleObj *style) { <nl>        b=rb->data.rgba.b+row*rb->data.rgba.row_step; <nl>        a=rb->data.rgba.a+row*rb->data.rgba.row_step; <nl>        for(col=0;col<rb->width;col++) { <nl> -         if(*a < 255) { <nl> +         if(*a && *a < 255) { <nl>              double da = *a/255.0; <nl>              *r/=da; <nl>              *g/=da;
@@ -2534,7 +2534,8 @@ int msOracleSpatialLayerGetAutoProjection( layerObj *layer, projectionObj *proje <nl>                 msDebug("Found WKT projection for table %s: %s\n", table_name, wktext); <nl>   <nl>             if(wktext != NULL && projection != NULL) <nl> -               msOGCWKT2ProjectionObj(wktext, projection, layer->debug); <nl> +               if(msOGCWKT2ProjectionObj(wktext, projection, layer->debug) == MS_FAILURE) <nl> +                   return(MS_FAILURE); <nl>         } <nl>      } while (sthand->rows_fetched > 0); <nl>  
@@ -1119,7 +1119,7 @@ mono_profiler_load (const char *desc) <nl>  		} <nl>  		libname = g_strdup_printf ("mono-profiler-%s", mname); <nl>  		if (!load_profiler_from_directory (NULL, libname, desc)) <nl> -			if (!load_profiler_from_directory (mono_assembly_getrootdir (), libname, desc)) <nl> +			if (!load_profiler_from_directory (MONO_ASSEMBLIES, libname, desc)) <nl>  				g_warning ("Error loading profiler module '%s'", libname); <nl>  			 <nl>  		g_free (libname);
@@ -1134,7 +1134,7 @@ HANDLE ves_icall_System_Threading_Thread_Thread_internal(MonoThread *this, <nl>  		register_thread_start_argument (this, start_info); <nl>  		if (threads_starting_up == NULL) { <nl>  			MONO_GC_REGISTER_ROOT (threads_starting_up); <nl> -			threads_starting_up = mono_g_hash_table_new (NULL, NULL); <nl> +			threads_starting_up = mono_g_hash_table_new_type (NULL, NULL, MONO_HASH_KEY_VALUE_GC); <nl>  		} <nl>  		mono_g_hash_table_insert (threads_starting_up, this, this); <nl>  		mono_threads_unlock ();	
@@ -5890,6 +5890,8 @@ emit_method_info (MonoAotCompile *acfg, MonoCompile *cfg) <nl>   <nl>  	encode_patch_list (acfg, patches, n_patches, cfg->compile_llvm, first_got_offset, p, &p); <nl>   <nl> +	g_ptr_array_free (patches, TRUE); <nl> + <nl>  	acfg->stats.info_size += p - buf; <nl>   <nl>  	g_assert (p - buf < buf_size);
@@ -8035,6 +8035,10 @@ emit_marshal (EmitMarshalContext *m, int argnum, MonoType *t, <nl>  	/* Ensure that we have marshalling info for this param */ <nl>  	mono_marshal_load_type_info (mono_class_from_mono_type (t)); <nl>   <nl> +#ifdef DISABLE_JIT <nl> +	/* Not JIT support, no need to generate correct IL */ <nl> +	return conv_arg; <nl> +#else <nl>  	if (spec && spec->native == MONO_NATIVE_CUSTOM) <nl>  		return emit_marshal_custom (m, argnum, t, spec, conv_arg, conv_arg_type, action); <nl>   <nl> @@ -8099,6 +8103,7 @@ emit_marshal (EmitMarshalContext *m, int argnum, MonoType *t, <nl>  		else <nl>  			return emit_marshal_object (m, argnum, t, spec, conv_arg, conv_arg_type, action); <nl>  	} <nl> +#endif <nl>   <nl>  	return conv_arg; <nl>  }
@@ -1281,10 +1281,14 @@ mono_interp_runtime_invoke (MonoMethod *method, void *obj, void **params, MonoOb <nl>  		break; <nl>  	case MONO_TYPE_VALUETYPE: <nl>  		retval = mono_object_new_checked (context->domain, klass, error); <nl> -		ret = ((char*)retval) + sizeof (MonoObject); <nl> +		ret = mono_object_unbox (retval); <nl>  		if (!sig->ret->data.klass->enumtype) <nl>  			result.data.vt = ret; <nl>  		break; <nl> +	case MONO_TYPE_PTR: <nl> +		retval = mono_object_new_checked (context->domain, mono_defaults.int_class, error); <nl> +		ret = mono_object_unbox (retval); <nl> +		break; <nl>  	default: <nl>  		retval = mono_object_new_checked (context->domain, klass, error); <nl>  		ret = ((char*)retval) + sizeof (MonoObject); <nl> @@ -1338,6 +1342,7 @@ handle_enum: <nl>  			} <nl>  			break; <nl>  		case MONO_TYPE_STRING: <nl> +		case MONO_TYPE_PTR: <nl>  		case MONO_TYPE_CLASS: <nl>  		case MONO_TYPE_ARRAY: <nl>  		case MONO_TYPE_SZARRAY:
@@ -69,6 +69,9 @@ Mono_Posix_Syscall_fcntl_lock (gint32 fd, gint32 cmd, struct Mono_Posix_Flock *l <nl>  	if (Mono_Posix_FromFlock (lock, &_lock) == -1) <nl>  		return -1; <nl>   <nl> +	if (Mono_Posix_FromFcntlCommand (cmd, &cmd) == -1) <nl> +		return -1; <nl> + <nl>  	r = fcntl (fd, cmd, &_lock); <nl>   <nl>  	if (Mono_Posix_ToFlock (&_lock, lock) == -1)
@@ -3558,6 +3558,11 @@ do_newobj (VerifyContext *ctx, int token) <nl>  		return; <nl>  	} <nl>   <nl> +	if (!sig->hasthis) { <nl> +		ADD_VERIFY_ERROR (ctx, g_strdup_printf ("Invalid constructor signature missing hasthis at 0x%04x", ctx->ip_offset)); <nl> +		return; <nl> +	} <nl> + <nl>  	if (!check_underflow (ctx, sig->param_count)) <nl>  		return; <nl>  
@@ -337,5 +337,5 @@ mono_trace_set_printerr_handler (MonoPrintCallback callback) <nl>  { <nl>  	g_assert (callback); <nl>  	printerr_callback = callback; <nl> -	g_set_print_handler (printerr_handler); <nl> +	g_set_printerr_handler (printerr_handler); <nl>  }
@@ -416,7 +416,7 @@ get_pid_status_item (int pid, const char *item, MonoProcessError *error, int mul <nl>  		RET_ERROR (MONO_PROCESS_ERROR_OTHER); <nl>  	} <nl>   <nl> -	if (strcmp (item, "VmRSS") == 0 || strcmp (item, "VmHWM") == 0) <nl> +	if (strcmp (item, "VmRSS") == 0 || strcmp (item, "VmHWM") == 0 || strcmp (item, "VmData") == 0) <nl>  		ret = t_info.resident_size; <nl>  	else if (strcmp (item, "VmSize") == 0 || strcmp (item, "VmPeak") == 0) <nl>  		ret = t_info.virtual_size;
@@ -199,6 +199,7 @@ int main(int argc, char* argv[]) <nl>  	const char* spec = NULL; <nl>  	const char* mount_point = NULL; <nl>  	const char* mount_options = ""; <nl> +	int debug = 0; <nl>  	struct fuse_chan* fc = NULL; <nl>  	struct fuse* fh = NULL; <nl>  	char** pp; <nl> @@ -214,6 +215,8 @@ int main(int argc, char* argv[]) <nl>  				usage(argv[0]); <nl>  			mount_options = *pp; <nl>  		} <nl> +		else if (strcmp(*pp, "-d") == 0) <nl> +			debug = 1; <nl>  		else if (spec == NULL) <nl>  			spec = *pp; <nl>  		else if (mount_point == NULL) <nl> @@ -237,7 +240,8 @@ int main(int argc, char* argv[]) <nl>  		return 1; <nl>   <nl>  	/* create arguments for fuse_new() */ <nl> -	if (fuse_opt_add_arg(&newfs_args, "") != 0) <nl> +	if (fuse_opt_add_arg(&newfs_args, "") != 0 || <nl> +		(debug && fuse_opt_add_arg(&newfs_args, "-d") != 0)) <nl>  	{ <nl>  		fuse_unmount(mount_point, fc); <nl>  		return 1;
@@ -275,8 +275,9 @@ int PacketHandler::doChaosRequest(DNSPacket *p, DNSPacket *r, DNSName &target) <nl>          return 0; <nl>        } <nl>        string tid=id; <nl> -      if(!tid.empty() && tid[0]!='"') // see #6010 however <nl> -	tid = "\"" + tid + "\""; <nl> +      if(!tid.empty() && tid[0]!='"') { // see #6010 however <nl> +        tid = "\"" + tid + "\""; <nl> +      } <nl>        rr.dr.d_content=DNSRecordContent::mastermake(QType::TXT, 1, tid); <nl>      } <nl>      else {
@@ -263,7 +263,7 @@ int main(int argc, char **argv) <nl>              startNewTransaction(); <nl>               <nl>              if(!::arg().mustDo("slave")) { <nl> -              if(g_mode==POSTGRES || g_mode==MYSQL) { <nl> +              if(g_mode==POSTGRES || g_mode==MYSQL || g_mode==SQLITE) { <nl>                  cout<<"insert into domains (name,type) values ("<<toLower(sqlstr(stripDot(i->name)))<<",'NATIVE');"<<endl; <nl>                } <nl>                else if(g_mode==ORACLE) { <nl> @@ -340,8 +340,12 @@ int main(int argc, char **argv) <nl>      exit(0); <nl>    } <nl>     <nl> -  if(::arg().mustDo("transactions") && g_intransaction) <nl> -    cout<<"COMMIT WORK;"<<endl; <nl> +  if(::arg().mustDo("transactions") && g_intransaction) { <nl> +    if(g_mode != SQLITE) <nl> +      cout<<"COMMIT WORK;"<<endl; <nl> +    else <nl> +      cout<<"COMMIT;"<<endl; <nl> +  } <nl>    return 1; <nl>   <nl>  }
@@ -50,6 +50,7 @@ RemoteBackend::RemoteBackend(const std::string &suffix) <nl>  { <nl>        setArgPrefix("remote"+suffix); <nl>        build(getArg("connection-string")); <nl> +      this->d_result = NULL; <nl>        this->d_dnssec = mustDo("dnssec"); <nl>        this->d_index = -1; <nl>        this->d_trxid = 0;
@@ -456,7 +456,7 @@ static M_sql_error_t mysql_bind_params(M_sql_driver_stmt_t *driver_stmt, M_sql_s <nl>  	M_sql_error_t err      = M_SQL_ERROR_SUCCESS; <nl>  	unsigned int  merr; <nl>  	size_t        num_cols = M_sql_driver_stmt_bind_cnt(stmt); <nl> -	size_t        num_rows = mysql_num_process_rows(M_sql_driver_stmt_bind_rows(stmt), num_cols); <nl> +	size_t        num_rows = mysql_num_process_rows(num_cols, M_sql_driver_stmt_bind_rows(stmt)); <nl>  	size_t        row; <nl>  	size_t        i; <nl>   <nl> @@ -775,7 +775,7 @@ static M_sql_error_t mysql_cb_execute(M_sql_conn_t *conn, M_sql_stmt_t *stmt, si <nl>   <nl>  	/* Get number of rows that are processed at once, supports <nl>  	 * comma-delimited values for inserting multiple rows. */ <nl> -	*rows_executed = mysql_num_process_rows(M_sql_driver_stmt_bind_rows(stmt), M_sql_driver_stmt_bind_cnt(stmt)); <nl> +	*rows_executed = mysql_num_process_rows(M_sql_driver_stmt_bind_cnt(stmt), M_sql_driver_stmt_bind_rows(stmt); <nl>   <nl>  	if (mysql_stmt_execute(driver_stmt->stmt) != 0) { <nl>  		unsigned int merr = mysql_stmt_errno(driver_stmt->stmt);
@@ -103,7 +103,7 @@ M_bool M_hash_u64u64_get(const M_hash_u64u64_t *h, M_uint64 key, M_uint64 *value <nl>   <nl>  	retval = M_hashtable_get((const M_hashtable_t *)h, &key, &outval); <nl>   <nl> -	if (value != NULL) <nl> +	if (retval && value != NULL) <nl>  		*value = *(M_uint64 *)outval; <nl>   <nl>  	return retval; <nl> @@ -131,7 +131,7 @@ M_bool M_hash_u64u64_multi_get(const M_hash_u64u64_t *h, M_uint64 key, size_t id <nl>   <nl>  	retval = M_hashtable_multi_get((const M_hashtable_t *)h, &key, idx, &outval); <nl>   <nl> -	if (value != NULL) <nl> +	if (retval && value != NULL) <nl>  		*value = *(M_uint64 *)outval; <nl>   <nl>  	return retval;
@@ -2543,7 +2543,7 @@ void NetworkInterface::periodicStatsUpdate() { <nl>   <nl>  #ifdef NTOPNG_PRO <nl>    if(aggregated_flows_hash) { <nl> -    if(--nextFlowAggregation == 0) { <nl> +    if((getIfType() == interface_type_DUMMY) || (--nextFlowAggregation == 0)) { <nl>        /* Start over */ <nl>        aggregated_flows_hash->cleanup(); <nl>        nextFlowAggregation = FLOW_AGGREGATION_DURATION; <nl> @@ -2554,7 +2554,6 @@ void NetworkInterface::periodicStatsUpdate() { <nl>  				   "Aggregated flows hash cleared. [num_items: %i]", <nl>  				   aggregated_flows_hash->getCurrentSize()); <nl>  #endif <nl> - <nl>      } else <nl>  #ifdef AGGREGATED_FLOW_DEBUG <nl>        ntop->getTrace()->traceEvent(TRACE_NORMAL,
@@ -1633,12 +1633,16 @@ make_button_data (NautilusPathBar *self, <nl>          /* Fall through */ <nl>          default: <nl>          { <nl> +            GtkWidget *separator_label; <nl> + <nl> +            separator_label = gtk_label_new (G_DIR_SEPARATOR_S); <nl> +            gtk_style_context_add_class (gtk_widget_get_style_context (separator_label), "dim-label"); <nl>              button_data->label = gtk_label_new (NULL); <nl>              child = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 2); <nl>              button_data->disclosure_arrow = gtk_image_new_from_icon_name ("pan-down-symbolic", <nl>                                                                            GTK_ICON_SIZE_MENU); <nl>              button_data->container = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 0); <nl> -            gtk_box_pack_start (GTK_BOX (button_data->container), gtk_label_new (G_DIR_SEPARATOR_S), FALSE, FALSE, 0); <nl> +            gtk_box_pack_start (GTK_BOX (button_data->container), separator_label, FALSE, FALSE, 0); <nl>              gtk_box_pack_start (GTK_BOX (button_data->container), button_data->button, FALSE, FALSE, 0); <nl>   <nl>              gtk_box_pack_start (GTK_BOX (child), button_data->label, FALSE, FALSE, 0);
@@ -238,7 +238,7 @@ nautilus_window_slot_content_view_matches (NautilusWindowSlot *self, <nl>  		return FALSE; <nl>  	} <nl>   <nl> -        if (id != NAUTILUS_VIEW_INVALID_ID && NAUTILUS_IS_FILES_VIEW (priv->content_view)){ <nl> +        if (id != NAUTILUS_VIEW_INVALID_ID && NAUTILUS_IS_FILES_VIEW (priv->content_view)) { <nl>                  return nautilus_files_view_get_view_id (NAUTILUS_FILES_VIEW (priv->content_view)) == id; <nl>          } else { <nl>                  return FALSE;
@@ -1121,6 +1121,8 @@ notebook_create_window_cb (GtkNotebook *notebook, <nl>  	g_object_set_data (G_OBJECT (slot), "dnd-window-slot", <nl>  			   GINT_TO_POINTER (TRUE)); <nl>   <nl> +	gtk_window_set_position (GTK_WINDOW (new_window), GTK_WIN_POS_MOUSE); <nl> + <nl>  	return GTK_NOTEBOOK (new_window->details->notebook); <nl>  } <nl>  
@@ -435,8 +435,7 @@ GF_Err gf_isom_nalu_sample_rewrite(GF_MediaBox *mdia, GF_ISOSample *sample, u32 <nl>  	if ( (extractor_mode != GF_ISOM_NALU_EXTRACT_INSPECT) && !(mdia->mediaTrack->extractor_mode & GF_ISOM_NALU_EXTRACT_TILE_ONLY) ) { <nl>  		u32 ref_track, di; <nl>  		//aggregate all sabt samples with the same DTS <nl> - <nl> -		if (entry->lhvc_config && !entry->hevc_config) { <nl> +		if (entry->lhvc_config && !entry->hevc_config && !(mdia->mediaTrack->extractor_mode & GF_ISOM_NALU_EXTRACT_LAYER_ONLY)) { <nl>  			GF_ISOSample *base_samp; <nl>  			if (gf_isom_get_reference_count(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_SCAL) <= 0) { <nl>  				//FIXME - for now we only support two layers (base + enh) in implicit
@@ -280,8 +280,8 @@ static Bool compositor_handle_navigation_3d(GF_Compositor *compositor, GF_Event <nl>  		is_pixel_metrics = compositor->traverse_state->pixel_metrics; <nl>  	} <nl>   <nl> -	if (!cam->navigate_mode) return 0; <nl>  	keys = compositor->key_states; <nl> +	if (!cam->navigate_mode && !(keys & GF_KEY_MOD_ALT) ) return 0; <nl>  	x = y = 0; <nl>  	/*renorm between -1, 1*/ <nl>  	if (ev->type<=GF_EVENT_MOUSEWHEEL) { <nl> @@ -570,7 +570,7 @@ static Bool compositor_handle_navigation_2d(GF_VisualManager *visual, GF_Event * <nl>  	if (visual->type_3d) navigation_mode = visual->camera.navigate_mode; <nl>  #endif <nl>   <nl> -	if (!navigation_mode /*&& !(keys & GF_KEY_MOD_ALT) */) return 0; <nl> +	if (!navigation_mode && !(keys & GF_KEY_MOD_ALT) ) return 0; <nl>   <nl>   <nl>  	x = y = 0;
@@ -7475,6 +7475,11 @@ static Bool hevc_parse_vps_extension(HEVC_VPS *vps, GF_BitStream *bs) <nl>  	} <nl>  	vps->num_output_layer_sets = num_add_olss + NumLayerSets; <nl>   <nl> +	if (vps->num_output_layer_sets > MAX_LHVC_LAYERS) { <nl> +		GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, ("[HEVC] Wrong number of output layer sets in VPS %d, max %d supported\n", vps->num_output_layer_sets, MAX_LHVC_LAYERS)); <nl> +		vps->num_output_layer_sets = 1; <nl> +		return GF_FALSE; <nl> +	} <nl>   <nl>  	layer_set_idx_for_ols_minus1[0] = 1; <nl>  	vps->output_layer_flag[0][0] = 1;
@@ -523,7 +523,10 @@ static GF_Glyph *ft_load_glyph(GF_FontReader *dr, u32 glyph_name) <nl>   <nl>  	glyph_idx = FT_Get_Char_Index(ftpriv->active_face, glyph_name); <nl>  	/*missing glyph*/ <nl> -	if (!glyph_idx) return NULL; <nl> +	if (!glyph_idx) { <nl> +		GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, ("[FreeType] Glyph not found for char %d in font %s (style %s)\n", glyph_name, ftpriv->active_face->family_name, ftpriv->active_face->style_name)); <nl> +		return NULL; <nl> +	} <nl>   <nl>  	/*work in design units*/ <nl>  	FT_Load_Glyph(ftpriv->active_face, glyph_idx, FT_LOAD_NO_SCALE | FT_LOAD_NO_BITMAP);
@@ -661,7 +661,7 @@ GF_Err SDLVid_ResizeWindow(GF_VideoOutput *dr, u32 width, u32 height) <nl>  		u32 flags, nb_bits; <nl>  		const char *opt; <nl>   <nl> -		if ((ctx->width==width) && (ctx->height==height) ) { <nl> +		if (ctx->screen && (ctx->width==width) && (ctx->height==height) ) { <nl>  			gf_mx_v(ctx->evt_mx); <nl>  			return GF_OK; <nl>  		} <nl> @@ -730,8 +730,12 @@ GF_Err SDLVid_ResizeWindow(GF_VideoOutput *dr, u32 width, u32 height) <nl>  #else <nl>  		hw_reset = GF_TRUE; <nl>  		ctx->screen = SDL_SetVideoMode(width, height, 0, flags); <nl> +		if (!ctx->screen) { <nl> +			GF_LOG(GF_LOG_ERROR, GF_LOG_MMIO, ("[SDL] Cannot create window: %s\n", SDL_GetError())); <nl> +			gf_mx_v(ctx->evt_mx); <nl> +			return GF_IO_ERR; <nl> +		} <nl>  #endif <nl> -		assert(ctx->screen); <nl>  		ctx->width = width; <nl>  		ctx->height = height; <nl>  		memset(&evt, 0, sizeof(GF_Event));
@@ -902,7 +902,7 @@ GF_DownloadSession *gf_dm_sess_new_simple(GF_DownloadManager * dm, const char *u <nl>   <nl>      *e = gf_dm_setup_from_url(sess, url); <nl>      if (*e) { <nl> -        GF_LOG(GF_LOG_WARNING, GF_LOG_NETWORK, ("%s:%s gf_dm_sess_new_simple:%d, error=%e at setup\n", __FILE__, __LINE__, e)); <nl> +        GF_LOG(GF_LOG_WARNING, GF_LOG_NETWORK, ("%s:%d gf_dm_sess_new_simple: error=%s at setup for %s\n", __FILE__, __LINE__, gf_error_to_string(*e), url)); <nl>          gf_dm_sess_del(sess); <nl>          return NULL; <nl>      }
@@ -834,7 +834,8 @@ void gf_es_receive_sl_packet(GF_ClientService *serv, GF_Channel *ch, char *paylo <nl>  					ch->net_dts = ch->net_cts = 0; <nl>  					ch->CTS = ch->DTS = gf_clock_time(ch->clock); <nl>  				} else { <nl> -					ch->net_dts -= ch->seed_ts; <nl> +					if (ch->net_dts>ch->seed_ts) ch->net_dts -= ch->seed_ts; <nl> +					else ch->net_dts=0; <nl>  					ch->net_cts -= ch->seed_ts; <nl>  					ch->CTS_past_offset = 0; <nl>   <nl> @@ -1097,6 +1098,8 @@ GF_DBUnit *gf_es_get_au(GF_Channel *ch) <nl>  	/*pull from stream - resume clock if needed*/ <nl>  	ch_buffer_off(ch); <nl>   <nl> +	memset(&slh, 0, sizeof(GF_SLHeader)); <nl> + <nl>  	e = gf_term_channel_get_sl_packet(ch->service, ch, (char **) &ch->AU_buffer_pull->data, &ch->AU_buffer_pull->dataLength, &slh, &comp, &state, &is_new_data); <nl>  	if (e) state = e; <nl>  	switch (state) {
@@ -868,7 +868,7 @@ static void parse_sec_attr_44(sc_file_t *file, const u8 *buf, size_t len) <nl>  			} <nl>   <nl>  			/* Encryption key present ? */ <nl> -			iPinCount = iACLen - 1;		 <nl> +			iPinCount = iACLen > 0 ? iACLen - 1 : 0; <nl>   <nl>  			if (buf[iOffset] & 0x20) { <nl>  				int iSC;
@@ -242,6 +242,8 @@ static int infocamere_1200_init(sc_pkcs15_card_t * p15card) <nl>  	 <nl>  	if (r != SC_SUCCESS || file->size > 255) { <nl>  		/* Not EF.GDO */ <nl> +		if (file) <nl> +			sc_file_free(file); <nl>  		return SC_ERROR_WRONG_CARD; <nl>  	} <nl>   <nl> @@ -249,6 +251,7 @@ static int infocamere_1200_init(sc_pkcs15_card_t * p15card) <nl>   <nl>  	if (ef_gdo[0] != 0x5A || file->size < 3) { <nl>  		/* Not EF.GDO */ <nl> +		sc_file_free(file); <nl>  		return SC_ERROR_WRONG_CARD; <nl>  	} <nl>   <nl> @@ -260,8 +263,10 @@ static int infocamere_1200_init(sc_pkcs15_card_t * p15card) <nl>   <nl>  	if (file->size < (size_t) (len_iccsn + 5)) { <nl>  		/* Not CHN */ <nl> +		sc_file_free(file); <nl>  		return SC_ERROR_WRONG_CARD; <nl>  	} <nl> +	sc_file_free(file); <nl>   <nl>  	if (! <nl>  	    (ef_gdo[len_iccsn + 2] == 0x5F
@@ -2042,6 +2042,8 @@ sign_verify(CK_SLOT_ID slot, CK_SESSION_HANDLE session,	CK_OBJECT_HANDLE priv_ke <nl>  	CK_ULONG signat_len; <nl>  	int j, errors = 0; <nl>   <nl> +    memcpy(buf, "\x00\x01\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x00", 11); <nl> + <nl>  	for (j = 0, mech_type = mech_types; *mech_type != 0xffffff; mech_type++, j++) { <nl>  		CK_MECHANISM mech = {*mech_type, NULL, 0}; <nl>  
@@ -1200,6 +1200,10 @@ sc_pkcs15_free_pubkey_info(sc_pkcs15_pubkey_info_t *info) <nl>  { <nl>  	if (info->subject.value) <nl>  		free(info->subject.value); <nl> +	if (info->direct.spki.value) <nl> +		free(info->direct.spki.value); <nl> +	if (info->direct.raw.value) <nl> +		free(info->direct.raw.value); <nl>  	sc_pkcs15_free_key_params(&info->params); <nl>  	free(info); <nl>  }
@@ -150,8 +150,10 @@ int sc_establish_context(struct sc_context **ctx_out) <nl>  	ctx->log_errors = 1; <nl>  	rv = SCardEstablishContext(SCARD_SCOPE_GLOBAL, "localhost", NULL, <nl>  				   &ctx->pcsc_ctx); <nl> -	if (rv != SCARD_S_SUCCESS) <nl> +	if (rv != SCARD_S_SUCCESS) { <nl> +		free(ctx); <nl>  		return SC_ERROR_CONNECTING_TO_RES_MGR; <nl> +	} <nl>  	SCardListReaders(ctx->pcsc_ctx, NULL, NULL, <nl>  			 (LPDWORD) &reader_buf_size); <nl>  	if (reader_buf_size < 2) {
@@ -772,7 +772,7 @@ static int asn1_encode_path(struct sc_context *ctx, const struct sc_path *path, <nl>   <nl>  static const struct sc_asn1_entry c_asn1_com_obj_attr[6] = { <nl>  	{ "label", SC_ASN1_UTF8STRING, ASN1_UTF8STRING, SC_ASN1_OPTIONAL, NULL }, <nl> -	{ "flags", SC_ASN1_BIT_STRING, ASN1_BIT_STRING, SC_ASN1_OPTIONAL, NULL }, <nl> +	{ "flags", SC_ASN1_BIT_FIELD, ASN1_BIT_STRING, SC_ASN1_OPTIONAL, NULL }, <nl>  	{ "authId", SC_ASN1_PKCS15_ID, ASN1_OCTET_STRING, SC_ASN1_OPTIONAL, NULL }, <nl>  	{ "userConsent", SC_ASN1_INTEGER, ASN1_INTEGER, SC_ASN1_OPTIONAL, NULL }, <nl>  	{ "accessControlRules", SC_ASN1_STRUCT, ASN1_SEQUENCE | SC_ASN1_CONS, SC_ASN1_OPTIONAL, NULL },
@@ -457,10 +457,10 @@ void sc_notify_id(struct sc_context *ctx, struct sc_atr *atr, <nl>   <nl>  	switch (id) { <nl>  		case NOTIFY_CARD_INSERTED: <nl> -			icon = "dialog-information"; <nl> +			icon = "contact-new"; <nl>  			break; <nl>  		case NOTIFY_CARD_REMOVED: <nl> -			icon = "media-removed"; <nl> +			icon = "media-eject"; <nl>  			break; <nl>  		case NOTIFY_PIN_GOOD: <nl>  			icon = "changes-allow";
@@ -503,7 +503,7 @@ static int entersafe_select_fid(sc_card_t *card, <nl>  	path.len=2; <nl>   <nl>  	r = iso_ops->select_file(card,&path,&file); <nl> -	if (r) <nl> +	if (r < 0) <nl>  		sc_file_free(file); <nl>  	SC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, "APDU transmit failed"); <nl>   <nl> @@ -514,7 +514,7 @@ static int entersafe_select_fid(sc_card_t *card, <nl>  		 card->cache.current_path.value[1] = 0x00; <nl>  		 if (id_hi == 0x3f && id_lo == 0x00){ <nl>  			  card->cache.current_path.len = 2; <nl> -		 }else{ <nl> +		 } else { <nl>  			  card->cache.current_path.len = 4; <nl>  			  card->cache.current_path.value[2] = id_hi; <nl>  			  card->cache.current_path.value[3] = id_lo;
@@ -152,6 +152,7 @@ libpqrcv_identify_system(TimeLineID *primary_tli) <nl>  			 GetSystemIdentifier()); <nl>  	if (strcmp(primary_sysid, standby_sysid) != 0) <nl>  	{ <nl> +		primary_sysid = pstrdup(primary_sysid); <nl>  		PQclear(res); <nl>  		ereport(ERROR, <nl>  				(errmsg("database system identifier differs between the primary and standby"),
@@ -3936,6 +3936,7 @@ PLy_add_exceptions(PyObject *plpy) <nl>  #endif <nl>  	if (PyModule_AddObject(plpy, "spiexceptions", excmod) < 0) <nl>  		PLy_elog(ERROR, "failed to add the spiexceptions module"); <nl> +	Py_INCREF(excmod); <nl>   <nl>  	PLy_exc_error = PyErr_NewException("plpy.Error", NULL, NULL); <nl>  	PLy_exc_fatal = PyErr_NewException("plpy.Fatal", NULL, NULL);
@@ -5,7 +5,7 @@ <nl>   * <nl>   *	1998 Jan Wieck <nl>   * <nl> - * $Header: /cvsroot/pgsql/src/backend/utils/adt/numeric.c,v 1.57 2003/03/11 21:01:33 tgl Exp $ <nl> + * $Header: /cvsroot/pgsql/src/backend/utils/adt/numeric.c,v 1.58 2003/03/14 00:15:32 tgl Exp $ <nl>   * <nl>   * ---------- <nl>   */ <nl> @@ -3872,6 +3872,9 @@ ln_var(NumericVar *arg, NumericVar *result) <nl>  			break; <nl>   <nl>  		add_var(result, &elem, result); <nl> + <nl> +		if (elem.weight < (result->weight - 2 * global_rscale)) <nl> +			break; <nl>  	} <nl>   <nl>  	/* Compensate for argument range reduction, round to caller's rscale */
@@ -8,7 +8,7 @@ <nl>   * <nl>   * <nl>   * IDENTIFICATION <nl> - *	  $Header: /cvsroot/pgsql/src/backend/parser/parse_target.c,v 1.70 2001/08/09 18:28:18 petere Exp $ <nl> + *	  $Header: /cvsroot/pgsql/src/backend/parser/parse_target.c,v 1.71 2001/09/10 14:53:10 momjian Exp $ <nl>   * <nl>   *------------------------------------------------------------------------- <nl>   */ <nl> @@ -462,7 +462,10 @@ FigureColname(Node *expr, Node *resval) <nl>  	/* Some of these are easiest to do with the untransformed node */ <nl>  	switch (nodeTag(resval)) <nl>  	{ <nl> -			case T_Ident: <nl> +		case T_TypeCast:  <nl> +			return( ( ((Ident *) ((TypeCast *) resval)->arg)->name)); <nl> +			 <nl> +		case T_Ident: <nl>  			return ((Ident *) resval)->name; <nl>  		case T_Attr: <nl>  			{
@@ -6,7 +6,7 @@ <nl>   * Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group <nl>   * <nl>   * IDENTIFICATION <nl> - *	  $PostgreSQL: pgsql/src/timezone/pgtz.c,v 1.60 2008/07/01 03:40:55 tgl Exp $ <nl> + *	  $PostgreSQL: pgsql/src/timezone/pgtz.c,v 1.61 2008/11/13 20:49:38 tgl Exp $ <nl>   * <nl>   *------------------------------------------------------------------------- <nl>   */ <nl> @@ -1499,6 +1499,12 @@ pg_tzenumerate_next(pg_tzenum *dir) <nl>  			continue; <nl>  		} <nl>   <nl> +		if (!tz_acceptable(&dir->tz)) <nl> +		{ <nl> +			/* Ignore leap-second zones */ <nl> +			continue; <nl> +		} <nl> + <nl>  		/* Timezone loaded OK. */ <nl>  		return &dir->tz; <nl>  	}
@@ -29,7 +29,7 @@ <nl>   * Portions Copyright (c) 1996-2000, PostgreSQL, Inc <nl>   * Portions Copyright (c) 1994, Regents of the University of California <nl>   * <nl> - *	$Id: pqcomm.c,v 1.89 2000/04/14 00:51:58 tgl Exp $ <nl> + *	$Id: pqcomm.c,v 1.90 2000/05/20 13:10:54 ishii Exp $ <nl>   * <nl>   *------------------------------------------------------------------------- <nl>   */ <nl> @@ -375,7 +375,13 @@ StreamConnection(int server_fd, Port *port) <nl>  		if (setsockopt(port->sock, pe->p_proto, TCP_NODELAY, <nl>  					   &on, sizeof(on)) < 0) <nl>  		{ <nl> -			perror("postmaster: StreamConnection: setsockopt"); <nl> +			perror("postmaster: StreamConnection: setsockopt(TCP_NODELAY)"); <nl> +			return STATUS_ERROR; <nl> +		} <nl> +		if (setsockopt(port->sock, SOL_SOCKET, SO_KEEPALIVE, <nl> +					   &on, sizeof(on)) < 0) <nl> +		{ <nl> +			perror("postmaster: StreamConnection: setsockopt(SO_KEEPALIVE)"); <nl>  			return STATUS_ERROR; <nl>  		} <nl>  	}
@@ -97,7 +97,7 @@ void optimize(IRUnit& unit, IRBuilder& irBuilder, TransKind kind) { <nl>    assertx(checkEverything(unit)); <nl>   <nl>    if (RuntimeOption::EvalHHIRTypeCheckHoisting) { <nl> -    doPass(unit, hoistTypeChecks, DCE::None); <nl> +    doPass(unit, hoistTypeChecks, DCE::Minimal); <nl>    } <nl>    doPass(unit, removeExitPlaceholders, DCE::Minimal); <nl>  
@@ -374,9 +374,9 @@ NEVER_INLINE void Marker::sweep() { <nl>    heap_.iterate( <nl>      [&](HeapObject* big, size_t big_size) { // onBig <nl>        if (big->kind() == HeaderKind::BigObj) { <nl> -        big = static_cast<MallocNode*>(big) + 1; <nl> -        if (!marked(big)) { <nl> -          mm.freeBigSize(big); <nl> +        HeapObject* h2 = static_cast<MallocNode*>(big) + 1; <nl> +        if (!marked(h2) && h2->kind() != HeaderKind::SmallMalloc) { <nl> +          mm.freeBigSize(h2); <nl>          } <nl>        } <nl>      },
@@ -72,6 +72,10 @@ struct BackEnd final : jit::BackEnd { <nl>  #if defined(__CYGWIN__) || defined(__MINGW__) <nl>    #define CALLEE_SAVED_BARRIER()                                    \ <nl>        asm volatile("" : : : "rbx", "rsi", "rdi", "r12", "r13", "r14", "r15"); <nl> +#elif defined(_MSC_VER) <nl> +  // Unfortunately, we have no way to tell MSVC to do this, so we'll <nl> +  // probably have to use a pair of assembly stubs to manage this. <nl> +  #define CALLEE_SAVED_BARRIER() always_assert(false); <nl>  #else <nl>    #define CALLEE_SAVED_BARRIER()                                    \ <nl>        asm volatile("" : : : "rbx", "r12", "r13", "r14", "r15");
@@ -626,8 +626,14 @@ String string_chunk_split(const char *src, int srclen, const char *end, <nl>    int chunks = srclen / chunklen; // complete chunks! <nl>    int restlen = srclen - chunks * chunklen; /* srclen % chunklen */ <nl>   <nl> -  int out_len = (chunks + 1) * endlen + srclen; <nl> -  String ret(out_len, ReserveString); <nl> +  String ret( <nl> +    safe_address( <nl> +      chunks + 1, <nl> +      endlen, <nl> +      srclen <nl> +    ), <nl> +    ReserveString <nl> +  ); <nl>    char *dest = ret.bufferSlice().ptr; <nl>   <nl>    const char *p; char *q;
@@ -79,9 +79,13 @@ void AsioContext::runUntil(c_WaitableWaitHandle* wait_handle) { <nl>        auto current = m_queue_ready.front(); <nl>        m_queue_ready.pop(); <nl>        m_current = current; <nl> + <nl> +      auto run_finished_guard = folly::makeGuard([&] { <nl> +        m_current = nullptr; <nl> +        decRefObj(current); <nl> +      }); <nl> + <nl>        m_current->run(); <nl> -      m_current = nullptr; <nl> -      decRefObj(current); <nl>   <nl>        if (wait_handle->isFinished()) { <nl>          return;
@@ -21,6 +21,7 @@ <nl>   <nl>  #include "hphp/util/lock.h" <nl>  #include "hphp/util/overflow.h" <nl> +#include <algorithm> <nl>  #include <cmath> <nl>   <nl>  #ifndef _MSC_VER <nl> @@ -385,13 +386,13 @@ int string_rfind(const char *input, int len, const char *s, int s_len, <nl>      if (pos >= 0) { <nl>        ptr = bstrrstr(input + pos, len - pos, s, s_len); <nl>      } else { <nl> -      ptr = bstrrstr(input, len + pos + s_len, s, s_len); <nl> +      ptr = bstrrstr(input, len + std::min(pos + s_len, 0), s, s_len); <nl>      } <nl>    } else { <nl>      if (pos >= 0) { <nl>        ptr = bstrrcasestr(input + pos, len - pos, s, s_len); <nl>      } else { <nl> -      ptr = bstrrcasestr(input, len + pos + s_len, s, s_len); <nl> +      ptr = bstrrcasestr(input, len + std::min(pos + s_len, 0), s, s_len); <nl>      } <nl>    } <nl>    if (ptr != nullptr) {
@@ -130,6 +130,7 @@ NEVER_INLINE <nl>  void initializeNamedDataMap() { <nl>    NamedEntity::Map::Config config; <nl>    config.growthFactor = 1; <nl> +  config.entryCountThreadCacheSize = 10; <nl>   <nl>    s_namedDataMap = new NamedEntity::Map( <nl>        RuntimeOption::EvalInitialNamedEntityTableSize, config);
@@ -899,6 +899,7 @@ Variant HHVM_FUNCTION(socket_select, <nl>          except = empty_array(); <nl>        } <nl>        read = hasData; <nl> +      free(fds); <nl>        return hasData.size(); <nl>      } <nl>    }
@@ -6964,7 +6964,7 @@ static void exif_process_APP12(image_info_type *ImageInfo, <nl>      exif_iif_add_tag(ImageInfo, SECTION_APP12, "Company", <nl>                       TAG_NONE, TAG_FMT_STRING, l1, buffer+2); <nl>      if (length > 2+l1+1) { <nl> -      l2 = php_strnlen(buffer+2+l1+1, length-2-l1+1); <nl> +      l2 = php_strnlen(buffer+2+l1+1, length-2-l1-1); <nl>        exif_iif_add_tag(ImageInfo, SECTION_APP12, "Info", <nl>                         TAG_NONE, TAG_FMT_STRING, l2, buffer+2+l1+1); <nl>      }
@@ -45,6 +45,10 @@ int emulate_zend(int argc, char** argv){ <nl>    vector<string> newargv; <nl>   <nl>    newargv.push_back(argv[0]); <nl> +#ifdef PHP_DEFAULT_HDF <nl> +  newargv.push_back("-c"); <nl> +  newargv.push_back(PHP_DEFAULT_HDF); <nl> +#endif <nl>   <nl>    bool lint = false; <nl>    bool show = false;
@@ -2646,10 +2646,11 @@ TranslatorX64::emitCheckUnboxedCounted(X64Assembler& a, <nl>  void <nl>  TranslatorX64::emitTypeCheck(X64Assembler& _a, DataType dt, <nl>                               PhysReg base, int offset, <nl> -                             SrcRec* fail) { <nl> +                             SrcRec* fail /* = NULL */) { <nl>    offset += TVOFF(m_type); <nl>    switch (dt) { <nl>      case KindOfAny: <nl> +    case KindOfClass: <nl>        break; <nl>      case KindOfUnboxedUncounted: <nl>        ASSERT(fail);
@@ -1542,7 +1542,7 @@ TranslatorX64::smash(X64Assembler &a, TCA src, TCA dest, bool isCall) { <nl>     */ <nl>    CodeCursor cg(a, src); <nl>    assert(isSmashable(a.code.frontier, kJmpLen)); <nl> -  if (dest > src && dest - src <= 7) { <nl> +  if (dest > src && dest - src <= kJmpLen) { <nl>      assert(!isCall); <nl>      a.    emitNop(dest - src); <nl>    } else if (!isCall) {
@@ -342,8 +342,8 @@ struct SimpleParser { <nl>                         JSONContainerType container_type, bool is_tsimplejson) { <nl>      SimpleParser parser(inp, length, buf, container_type, is_tsimplejson); <nl>      bool ok = parser.parseValue(); <nl> -    parser.skipSpace(); <nl> -    if (!ok || parser.p != inp + length) { <nl> +    if (!ok || <nl> +        (parser.skipSpace(), parser.p != inp + length)) { <nl>        // Unsupported, malformed, or trailing garbage. Release entire stack. <nl>        tvDecRefRange(buf, parser.top); <nl>        return false;
@@ -1482,9 +1482,15 @@ __attribute__ ((visibility("default"))) <nl>  void <nl>  android_main(struct android_app* state) <nl>  { <nl> +    JNIEnv *env; <nl>      struct engine engine; <nl>      Dl_info lo_main_info; <nl>   <nl> +    if (sleep_time != 0) { <nl> +        LOGI("android_main: Sleeping for %d seconds, start ndk-gdb NOW if that is your intention", sleep_time); <nl> +        sleep(sleep_time); <nl> +    } <nl> + <nl>      app = state; <nl>   <nl>      memset(&engine, 0, sizeof(engine)); <nl> @@ -1495,9 +1501,6 @@ android_main(struct android_app* state) <nl>          lo_main_argv[0] = lo_main_info.dli_fname; <nl>      } <nl>   <nl> -    if (sleep_time != 0) <nl> -        sleep(sleep_time); <nl> - <nl>      patch_libgnustl_shared(); <nl>   <nl>      extract_files(UNPACK_TREE);
@@ -65,12 +65,12 @@ provoking error here, because PP ignores #error <nl>  #error "Tested gcc 2 versions are 2.91 and 2.95.  Patch uno/lbnames.h to try your gcc 2 version." <nl>  #elif (__GNUC__ == 3 && __GNUC_MINOR__ <= 4) <nl>  #define __CPPU_ENV gcc3 <nl> -#elif (__GNUC__ == 4 && __GNUC_MINOR__ <= 3) <nl> +#elif (__GNUC__ == 4 && __GNUC_MINOR__ <= 4) <nl>  #define __CPPU_ENV gcc3 <nl>  #elif (__GNUC__ == 3) <nl>  #error "Tested gcc 3 version is <= 3.4.  Patch uno/lbnames.h to try your gcc 3 version." <nl>  #else <nl> -#error "Supported gcc majors are 2 , 3 and 4 <= 4.3.  Unsupported gcc major version." <nl> +#error "Supported gcc majors are 2 , 3 and 4 <= 4.4.  Unsupported gcc major version." <nl>  #endif /* defined (__GNUC__) */ <nl>  #endif /* defined (_MSC_VER) */ <nl>  
@@ -239,11 +239,12 @@ int XrdOuca2x::a2sz(XrdSysError &Eroute, const char *emsg, const char *item, <nl>      else if (*fP == 't' || *fP == 'T') qmult = 1024LL*1024LL*1024LL*1024LL; <nl>      else                              {qmult = 1; fP++;} <nl>      errno = 0; <nl> -    *val  = strtoll(item, &eP, 10) * qmult; <nl> +    double dval  = strtod(item, &eP) * qmult; <nl>      if (errno || eP != fP) <nl>         {Eroute.Emsg("a2x", emsg, item, "is not a number"); <nl>          return -1; <nl>         } <nl> +    *val = (long long)dval; <nl>      if (*val < minv)  <nl>         return Emsg(Eroute, emsg, item, "may not be less than %lld", minv); <nl>      if (maxv >= 0 && *val > maxv)
@@ -144,10 +144,13 @@ int XrdSutGetPass(const char *prompt, XrdOucString &passwd) <nl>   <nl>     char *pw = getpass(prompt); <nl>     if (pw) { <nl> -      if (pw[strlen(pw)-1] == '\n') <nl> -         pw[strlen(pw) - 1] = 0;   // get rid of \n <nl> +      // Get rid of special chars, if any <nl> +      int k = 0, i = 0, len = strlen(pw); <nl> +      for (; i<len ; i++) <nl> +         if (pw[i] > 0x20) pw[k++] = pw[i]; <nl> +      pw[k] = 0; <nl>        passwd = pw; <nl> -      XrdSutMemSet((volatile void *)pw,0,strlen(pw)); <nl> +      XrdSutMemSet((volatile void *)pw,0,len); <nl>     } else { <nl>        DEBUG("error from getpass"); <nl>        return -1;
@@ -328,7 +328,7 @@ static int show_channel(channel_t *chptr, struct alis_query *query) <nl>  	if(query->mode_dir == DIR_SET) <nl>  	{ <nl>  		if(((chptr->modes & query->mode) != query->mode) || <nl> -		   (query->mode_key && chptr->key[0] == '\0') || <nl> +		   (query->mode_key && chptr->key == NULL) || <nl>  		   (query->mode_limit && !chptr->limit)) <nl>  			return 0; <nl>  		for (i = 0; ignore_mode_list[i].mode != '\0'; i++) <nl> @@ -338,7 +338,7 @@ static int show_channel(channel_t *chptr, struct alis_query *query) <nl>  	else if(query->mode_dir == DIR_UNSET) <nl>  	{ <nl>  		if((chptr->modes & query->mode) || <nl> -		   (query->mode_key && chptr->key[0] != '\0') || <nl> +		   (query->mode_key && chptr->key != NULL) || <nl>  		   (query->mode_limit && chptr->limit)) <nl>  			return 0; <nl>  		for (i = 0; ignore_mode_list[i].mode != '\0'; i++) <nl> @@ -347,8 +347,8 @@ static int show_channel(channel_t *chptr, struct alis_query *query) <nl>  	} <nl>  	else if(query->mode_dir == DIR_EQUAL) <nl>  	{ <nl> -		if((chptr->modes != query->mode) || <nl> -		   (query->mode_key && chptr->key[0] == '\0') || <nl> +		if(((chptr->modes & ~(CMODE_LIMIT | CMODE_KEY)) != query->mode) || <nl> +		   (query->mode_key && chptr->key == NULL) || <nl>  		   (query->mode_limit && !chptr->limit)) <nl>  			return 0; <nl>  		for (i = 0; ignore_mode_list[i].mode != '\0'; i++)
@@ -45,6 +45,10 @@ int main(int argc, char *argv[]) <nl>   <nl>  	printf("\n* * *\n\n"); <nl>   <nl> +	printf("sizeof object_t: %zu B\n", sizeof(object_t)); <nl> + <nl> +	printf("\n* * *\n\n"); <nl> + <nl>  	printf("sizeof myentity_t: %zu B --> %zu KB\n", sizeof(myentity_t), (regusercount * sizeof(myentity_t)) / 1024); <nl>  	printf("sizeof myuser_t: %zu B --> %zu KB\n", sizeof(myuser_t), (regusercount * sizeof(myuser_t)) / 1024); <nl>  	printf("sizeof mychan_t: %zu B --> %zu KB\n", sizeof(mychan_t), (regchannelcount * sizeof(mychan_t)) / 1024);
@@ -404,7 +404,7 @@ void swTimer_node_insert(swTimer_node **root, swTimer_node *new_node) <nl>      swTimer_node *tmp = *root; <nl>      while (1) <nl>      { <nl> -        if (tmp->exec_msec >= new_node->exec_msec) <nl> +        if (tmp->exec_msec > new_node->exec_msec) <nl>          { <nl>              new_node->prev = tmp->prev; <nl>              new_node->next = tmp;
@@ -2649,7 +2649,8 @@ static int tls_sni_cb(SSL *ssl, int *alert_desc, void *user_data) { <nl>       } <nl>      } <nl>   <nl> -    if (pr_table_add_dup(session.notes, "mod_tls.sni", server_name, 0) < 0) { <nl> +    if (pr_table_add_dup(session.notes, "mod_tls.sni", <nl> +        (char *) server_name, 0) < 0) { <nl>        pr_trace_msg(trace_channel, 3, <nl>          "error stashing 'mod_tls.sni' in session.notes: %s", strerror(errno)); <nl>      } <nl> @@ -10152,8 +10153,9 @@ static int tls_sess_init(void) { <nl>    if (tmp != NULL && <nl>        *tmp == TRUE) { <nl>      tls_engine = TRUE; <nl> +  } <nl>   <nl> -  } else { <nl> +  if (tls_engine == FALSE) { <nl>      /* If we have no ServerAlias vhosts at all, then it is OK to clean up <nl>       * all of the TLS/OpenSSL-related code from this process.  Otherwise, <nl>       * a client MIGHT send a HOST command for a TLS-enabled vhost; if we <nl> @@ -10161,7 +10163,8 @@ static int tls_sess_init(void) { <nl>       * lead to a problem. <nl>       */ <nl>   <nl> -    if (pr_namebind_count(main_server) == 0) { <nl> +    res = pr_namebind_count(main_server); <nl> +    if (res == 0) { <nl>        /* No need for this modules's control channel NetIO handlers <nl>         * anymore. <nl>         */
@@ -20,7 +20,7 @@ <nl>   <nl>  /* <nl>   * House initialization and main program loop <nl> - * $Id: main.c,v 1.48 2001-02-01 19:52:29 flood Exp $ <nl> + * $Id: main.c,v 1.49 2001-02-20 04:50:38 flood Exp $ <nl>   */ <nl>   <nl>  /* <nl> @@ -950,7 +950,7 @@ static int _idle_timeout(CALLBACK_FRAME) <nl>    send_response_async(R_421,"Idle Timeout (%d seconds): closing control connection.",  <nl>                        TimeoutIdle); <nl>   <nl> -  main_exit((void*)LOG_NOTICE, <nl> +  main_exit((void*)LOG_INFO, <nl>  		  "FTP session idle timeout, disconnected.", <nl>  		  (void*)0,NULL); <nl>   <nl> @@ -1005,7 +1005,7 @@ void cmd_loop(server_rec *server, conn_t *c) <nl>  	continue;		/* Simple interrupted syscall */ <nl>         <nl>        /* Otherwise, EOF */ <nl> -      log_pri(LOG_NOTICE,"FTP session closed."); <nl> +      log_pri(LOG_INFO,"FTP session closed."); <nl>        end_login(0); <nl>      } <nl>  
@@ -6440,15 +6440,15 @@ static int fs_getsize(int fd, char *path, off_t *fs_size) { <nl>     * we'll use typecasting. <nl>     */ <nl>    if (sizeof(fs.f_bavail) > 4 || <nl> -      sizeof(fs.f_frsize) > 4) { <nl> +      sizeof(fs.f_bsize) > 4) { <nl>   <nl>      /* In order to return a size in KB, as get_fs_size() does, we need <nl>       * to divide by 1024. <nl>       */ <nl> -    *fs_size = (((off_t) fs.f_bavail * (off_t) fs.f_frsize) / 1024); <nl> +    *fs_size = (((off_t) fs.f_bavail * (off_t) fs.f_bsize) / 1024); <nl>   <nl>    } else { <nl> -    *fs_size = get_fs_size(fs.f_bavail, fs.f_frsize); <nl> +    *fs_size = get_fs_size(fs.f_bavail, fs.f_bsize); <nl>    } <nl>   <nl>    res = 0; <nl> @@ -6501,7 +6501,7 @@ static int fs_getsize(int fd, char *path, off_t *fs_size) { <nl>      /* In order to return a size in KB, as get_fs_size() does, we need <nl>       * to divide by 1024. <nl>       */ <nl> -    *fs_size = (((off_t) fs.f_bavail * (off_t) fs.f_frsize) / 1024); <nl> +    *fs_size = (((off_t) fs.f_bavail * (off_t) fs.f_bsize) / 1024); <nl>   <nl>    } else { <nl>      *fs_size = get_fs_size(fs.f_bavail, fs.f_bsize); <nl> @@ -6557,7 +6557,7 @@ static int fs_getsize(int fd, char *path, off_t *fs_size) { <nl>      /* In order to return a size in KB, as get_fs_size() does, we need <nl>       * to divide by 1024. <nl>       */ <nl> -    *fs_size = (((off_t) fs.f_bavail * (off_t) fs.f_frsize) / 1024); <nl> +    *fs_size = (((off_t) fs.f_bavail * (off_t) fs.f_bsize) / 1024); <nl>   <nl>    } else { <nl>      *fs_size = get_fs_size(fs.f_bavail, fs.f_bsize);
@@ -3978,7 +3978,7 @@ static int tls_ticket_key_cmp(xasetmember_t *a, xasetmember_t *b) { <nl>   <nl>  static struct tls_ticket_key *create_ticket_key(void) { <nl>    struct tls_ticket_key *k; <nl> -  void *page_ptr; <nl> +  void *page_ptr = NULL; <nl>    size_t pagesz; <nl>    char *ptr; <nl>  # ifdef HAVE_MLOCK <nl> @@ -3988,6 +3988,9 @@ static struct tls_ticket_key *create_ticket_key(void) { <nl>    pagesz = sizeof(struct tls_ticket_key); <nl>    ptr = tls_get_page(pagesz, &page_ptr); <nl>    if (ptr == NULL) { <nl> +    if (page_ptr != NULL) { <nl> +      free(page_ptr); <nl> +    } <nl>      return NULL; <nl>    } <nl>  
@@ -2,7 +2,7 @@ <nl>   * ProFTPD: mod_tls_fscache -- a module which provides a shared OCSP response <nl>   *                              cache using the filesystem <nl>   * <nl> - * Copyright (c) 2015 TJ Saunders <nl> + * Copyright (c) 2015-2016 TJ Saunders <nl>   * <nl>   * This program is free software; you can redistribute it and/or modify <nl>   * it under the terms of the GNU General Public License as published by <nl> @@ -498,10 +498,12 @@ static int ocsp_cache_clear(tls_ocsp_cache_t *cache) { <nl>  static int ocsp_cache_remove(tls_ocsp_cache_t *cache) { <nl>    int res; <nl>   <nl> -  if (cache != NULL) { <nl> -    pr_trace_msg(trace_channel, 9, "removing fscache cache %p", cache);  <nl> +  if (cache == NULL) { <nl> +    errno = EINVAL; <nl> +    return -1; <nl>    } <nl>   <nl> +  pr_trace_msg(trace_channel, 9, "removing fscache cache %p", cache); <nl>    res = ocsp_cache_clear(cache); <nl>    return res; <nl>  }
@@ -512,6 +512,8 @@ static void tls_diags_cb(const SSL *ssl, int where, int ret) { <nl>    const char *str = "(unknown)"; <nl>    int w; <nl>   <nl> +  pr_signals_handle(); <nl> + <nl>    w = where & ~SSL_ST_MASK; <nl>   <nl>    if (w & SSL_ST_CONNECT) {
@@ -585,6 +585,11 @@ bool DoneConnect(ServerConfig *conf, const char*) <nl>  	{ <nl>  		User *u = *n; <nl>   <nl> +		/* <nl> +		 * Make their existing class go away so that SetClass doesn't touch a wild ptr, important! <nl> +		 */ <nl> +		u->MyClass = NULL; <nl> + <nl>  		u->SetClass(); <nl>   <nl>  		/*
@@ -187,7 +187,7 @@ class SilenceMessage : public ClientProtocol::Message <nl>  		: ClientProtocol::Message("SILENCE") <nl>  	{ <nl>  		PushParam(mask); <nl> -		PushParamRef(flags); <nl> +		PushParam(flags); <nl>  	} <nl>  }; <nl>  
@@ -15,7 +15,7 @@ using namespace std; <nl>  class SeeWhois : public ModeHandler <nl>  { <nl>   public: <nl> -	SeeWhois(InspIRCd* Instance) : ModeHandler(Instance, 'W', 0, 0, false, MODETYPE_CHANNEL, false) { } <nl> +	SeeWhois(InspIRCd* Instance) : ModeHandler(Instance, 'W', 0, 0, false, MODETYPE_USER, false) { } <nl>   <nl>  	ModeAction OnModeChange(userrec* source, userrec* dest, chanrec* channel, std::string &parameter, bool adding) <nl>  	{
@@ -59,15 +59,13 @@ class ModuleDenyChannels : public Module <nl>   <nl>          virtual int OnUserPreJoin(userrec* user, chanrec* chan, const char* cname) <nl>          { <nl> -		bool isoper = strchr(user->modes,'o') ? true : false; <nl> - <nl>  		for (int j =0; j < Conf->Enumerate("badchan"); j++) <nl>  		{ <nl>  			irc::string cn = Conf->ReadValue("badchan","name",j).c_str(); <nl>  			irc::string thischan = cname; <nl>  			if (thischan == cn) <nl>  			{ <nl> -				if ((Conf->ReadFlag("badchan","allowopers",j)) && isoper == true) <nl> +				if ((Conf->ReadFlag("badchan","allowopers",j)) && *user->oper) <nl>  				{ <nl>  					return 0; <nl>  				}
@@ -3260,6 +3260,12 @@ bool IsDenied(userrec *user) <nl>   <nl>  void handle_pass(char **parameters, int pcnt, userrec *user) <nl>  { <nl> +	// Check to make sure they havnt registered -- Fix by FCS <nl> +	if (user->registered == 7) <nl> +	{ <nl> +		WriteServ(user->fd,"462 %s :You may not reregister",user->nick); <nl> +		return; <nl> +	} <nl>  	if (!strcasecmp(parameters[0],Passwd(user))) <nl>  	{ <nl>  		user->haspassed = true;
@@ -154,6 +154,7 @@ net::URLRequestContext* URLRequestContextGetter::GetURLRequestContext() { <nl>          end = protocol_handlers_.end(); it != end; ++it) { <nl>        bool set_protocol = job_factory->SetProtocolHandler( <nl>            it->first, it->second.release()); <nl> +      ALLOW_UNUSED(set_protocol); <nl>        DCHECK(set_protocol); <nl>      } <nl>      protocol_handlers_.clear();
@@ -4,15 +4,14 @@ <nl>   <nl>  #include "brightray/browser/browser_main_parts.h" <nl>   <nl> -#include "brightray/browser/browser_context.h" <nl> -#include "brightray/browser/devtools_manager_delegate.h" <nl> -#include "brightray/browser/web_ui_controller_factory.h" <nl> -#include "brightray/common/main_delegate.h" <nl> - <nl>  #include "base/command_line.h" <nl>  #include "base/feature_list.h" <nl>  #include "base/strings/string_number_conversions.h" <nl>  #include "base/strings/utf_string_conversions.h" <nl> +#include "brightray/browser/browser_context.h" <nl> +#include "brightray/browser/devtools_manager_delegate.h" <nl> +#include "brightray/browser/web_ui_controller_factory.h" <nl> +#include "brightray/common/main_delegate.h" <nl>  #include "content/public/browser/browser_thread.h" <nl>  #include "content/public/common/content_switches.h" <nl>  #include "media/base/localized_strings.h"
@@ -224,7 +224,7 @@ NativeWindowWin::NativeWindowWin(content::WebContents* web_contents, <nl>    OnViewWasResized(); <nl>   <nl>    if (g_exe_icon == NULL) <nl> -    g_exe_icon = ::LoadImage(GetModuleHandle(NULL), L"IDR_MAINFRAME", <nl> +    g_exe_icon = ::LoadImage(GetModuleHandle(NULL), MAKEINTRESOURCE(1), <nl>                               IMAGE_ICON, 0, 0, 0); <nl>    ::SendMessage(window_->GetNativeWindow(), <nl>                  WM_SETICON,
@@ -1390,7 +1390,8 @@ bool IsBlacklistedArg(const base::CommandLine::CharType* arg) { <nl>   <nl>    if (prefix_length > 0) { <nl>      a += prefix_length; <nl> -    std::string switch_name(a, strcspn(a, "=")); <nl> +    std::string switch_name = <nl> +        base::ToLowerASCII(base::StringPiece(a, strcspn(a, "="))); <nl>      auto* iter = std::lower_bound(std::begin(kBlacklist), std::end(kBlacklist), <nl>                                    switch_name); <nl>      if (iter != std::end(kBlacklist) && switch_name == *iter) {
@@ -309,11 +309,11 @@ static qboolean Sys_StringToSockaddr(const char *s, struct sockaddr *sadr, int s <nl>   <nl>  		if(search) <nl>  		{ <nl> -			if(res->ai_addrlen > sadr_len) <nl> -				res->ai_addrlen = sadr_len; <nl> +			if(search->ai_addrlen > sadr_len) <nl> +				search->ai_addrlen = sadr_len; <nl>  				 <nl> -			memcpy(sadr, res->ai_addr, res->ai_addrlen); <nl> -			freeaddrinfo(res); <nl> +			memcpy(sadr, search->ai_addr, search->ai_addrlen); <nl> +			freeaddrinfo(search); <nl>  			 <nl>  			return qtrue; <nl>  		}
@@ -1239,6 +1239,11 @@ void CL_KeyDownEvent( int key, unsigned time ) <nl>   <nl>  	if( keys[K_ALT].down && key == K_ENTER ) <nl>  	{ <nl> +		// don't repeat fullscreen toggle when keys are held down <nl> +		if ( keys[K_ENTER].repeats > 1 ) { <nl> +			return; <nl> +		} <nl> + <nl>  		Cvar_SetValue( "r_fullscreen", <nl>  			!Cvar_VariableIntegerValue( "r_fullscreen" ) ); <nl>  		return;
@@ -2236,13 +2236,14 @@ int contains_illegal_object_chars(char *name){ <nl>  char *clean_macro_chars(char *macro,int options){ <nl>  	register int x; <nl>  	register int y; <nl> +	register int z; <nl>  	register int ch; <nl>  	register int len; <nl>   <nl>  	if(macro==NULL) <nl>  		return ""; <nl>   <nl> -	len=(int)strlen(macro)-1; <nl> +	len=(int)strlen(macro); <nl>   <nl>  	/* strip illegal characters out of macro */ <nl>  	if(options & STRIP_ILLEGAL_MACRO_CHARS){ <nl> @@ -2261,8 +2262,8 @@ char *clean_macro_chars(char *macro,int options){ <nl>   <nl>  			/* illegal user-specified characters */ <nl>  			if(illegal_output_chars!=NULL) <nl> -				for(y=0;illegal_output_chars[y];y++) <nl> -					if(macro[x]==illegal_output_chars[y]) <nl> +				for(z=0;illegal_output_chars[z];z++) <nl> +					if(ch==illegal_output_chars[z]) <nl>  						continue; <nl>   <nl>  			macro[y++]=macro[x];
@@ -1955,6 +1955,7 @@ hostescalation *add_hostescalation(char *host_name, int first_notification, int <nl>   <nl>  	/* assign vars. Object names are immutable, so no need to copy */ <nl>  	new_hostescalation->host_name = h->name; <nl> +	new_hostescalation->host_ptr = h; <nl>  	new_hostescalation->escalation_period = tp ? tp->name : NULL; <nl>  	new_hostescalation->escalation_period_ptr = tp; <nl>  	new_hostescalation->first_notification = first_notification;
@@ -213,7 +213,7 @@ static int wproc_is_alive(worker_process *wp) <nl>   <nl>  int wproc_destroy(worker_process *wp, int flags) <nl>  { <nl> -	int i = 0, destroyed = 0, force = 0, self; <nl> +	int i = 0, force = 0, self; <nl>   <nl>  	if (!wp) <nl>  		return 0; <nl> @@ -231,14 +231,11 @@ int wproc_destroy(worker_process *wp, int flags) <nl>  	wp->ioc = NULL; <nl>  	my_free(wp->source_name); <nl>  	if (wp->jobs) { <nl> -		for (i = 0; i < wp->max_jobs; i++) { <nl> +		for (i = 0; i < wp->max_jobs && wp->jobs_running; i++) { <nl>  			if (!wp->jobs[i]) <nl>  				continue; <nl>   <nl>  			destroy_job(wp, wp->jobs[i]); <nl> -			/* we can (often) break out early */ <nl> -			if (++destroyed >= wp->jobs_running) <nl> -				break; <nl>  		} <nl>   <nl>  		free(wp->jobs);
@@ -3986,8 +3986,13 @@ int read_check_output_from_file(char *fname, char **short_output, char **long_ou <nl>   <nl>  	/* open the file for reading */ <nl>  	if((thefile=mmap_fopen(fname))==NULL){ <nl> + <nl>  		if(short_output) <nl>  			*short_output=strdup("(Cannot read check result file (file may be empty) - no plugin output!)"); <nl> + <nl> +		/* try removing the file - zero length files can't be mmap()'ed, so it might exist */ <nl> +		unlink(fname); <nl> + <nl>  		return ERROR; <nl>  	        } <nl>   <nl> @@ -4023,7 +4028,7 @@ int read_check_output_from_file(char *fname, char **short_output, char **long_ou <nl>  	mmap_fclose(thefile); <nl>   <nl>  	/* remove the file */ <nl> -	/*unlink(fname);*/ <nl> +	unlink(fname); <nl>   <nl>  	return OK; <nl>          }
@@ -482,7 +482,7 @@ rtadv_read (struct thread *thread) <nl>    /* Register myself. */ <nl>    rtadv_event (zvrf, RTADV_READ, sock); <nl>   <nl> -  len = rtadv_recv_packet (sock, buf, BUFSIZ, &from, &ifindex, &hoplimit); <nl> +  len = rtadv_recv_packet (sock, buf, sizeof (buf), &from, &ifindex, &hoplimit); <nl>   <nl>    if (len < 0)  <nl>      {
@@ -1333,7 +1333,10 @@ DEFUN (ipv6_ospf6_priority, <nl>   <nl>    oi->priority = strtol (argv[0], NULL, 10); <nl>   <nl> -  if (oi->area) <nl> +  if (oi->area && <nl> +      (oi->state == OSPF6_INTERFACE_DROTHER || <nl> +       oi->state == OSPF6_INTERFACE_BDR || <nl> +       oi->state == OSPF6_INTERFACE_DR)) <nl>      ospf6_interface_state_change (dr_election (oi), oi); <nl>   <nl>    return CMD_SUCCESS;
@@ -60,7 +60,7 @@ <nl>   <nl>  #define STREAM_VERIFY_SANE(S) \ <nl>    do { \ <nl> -    if ( !(GETP_VALID(S, (S)->getp)) && ENDP_VALID(S, (S)->endp) ) \ <nl> +    if ( !(GETP_VALID(S, (S)->getp) && ENDP_VALID(S, (S)->endp)) ) \ <nl>        STREAM_WARN_OFFSETS(S); \ <nl>      assert ( GETP_VALID(S, (S)->getp) ); \ <nl>      assert ( ENDP_VALID(S, (S)->endp) ); \
@@ -604,6 +604,10 @@ bgp_address_del (struct prefix *p) <nl>    tmp.addr = p->u.prefix4; <nl>   <nl>    addr = hash_lookup (bgp_address_hash, &tmp); <nl> +  /* may have been deleted earlier by bgp_interface_down() */ <nl> +  if (addr == NULL) <nl> +    return; <nl> + <nl>    addr->refcnt--; <nl>   <nl>    if (addr->refcnt == 0)
@@ -328,7 +328,7 @@ int regexp_nsub(struct regexp *r) { <nl>  } <nl>   <nl>  void regexp_release(struct regexp *regexp) { <nl> -    if (regexp->re != NULL) { <nl> +    if (regexp != NULL && regexp->re != NULL) { <nl>          regfree(regexp->re); <nl>          FREE(regexp->re); <nl>      }
@@ -943,7 +943,7 @@ static std::vector<comp_t *> mangle_completions( wcstring_list_t &lst, const wch <nl>  			 <nl>  			if( (c == COMPLETE_ITEM_SEP) || (c==COMPLETE_SEP) || !c) <nl>  			{ <nl> -                wcstring start2 = wcstring(start, end - start); <nl> +                wcstring start2 = wcstring(next, start, end - start); <nl>                  wcstring str = escape_string(start2, ESCAPE_ALL | ESCAPE_NO_QUOTED); <nl>  				comp->comp_width += my_wcswidth( str.c_str() ); <nl>  				comp->comp.push_back(str);
@@ -81,6 +81,12 @@ static int builtin_set_color(parser_t &parser, wchar_t **argv) <nl>   <nl>      int argc = builtin_count_args(argv); <nl>   <nl> +    /* Some code passes variables to set_color that don't exist, like $fish_user_whatever. As a hack, quietly return failure. */ <nl> +    if (argc <= 1) <nl> +    { <nl> +        return EXIT_FAILURE; <nl> +    } <nl> + <nl>      const wchar_t *bgcolor = NULL; <nl>      bool bold = false, underline=false; <nl>      int errret;
@@ -58,7 +58,7 @@ <nl>  #include "fish_version.h" <nl>   <nl>  /** Command used to start fishd */ <nl> -#define FISHD_CMD L"fishd ^ /tmp/fishd.log.%s" <nl> +#define FISHD_CMD L"fishd ^ /dev/null" <nl>   <nl>  // Version for easier debugging <nl>  //#define FISHD_CMD L"fishd"
@@ -228,7 +228,7 @@ top_env(mrb_state *mrb, struct RProc *proc) <nl>  #define CI_ACC_DIRECT  -2 <nl>  #define CI_ACC_RESUMED -3 <nl>   <nl> -static mrb_callinfo* <nl> +static inline mrb_callinfo* <nl>  cipush(mrb_state *mrb) <nl>  { <nl>    struct mrb_context *c = mrb->c; <nl> @@ -279,7 +279,7 @@ mrb_env_unshare(mrb_state *mrb, struct REnv *e) <nl>    mrb_write_barrier(mrb, (struct RBasic *)e); <nl>  } <nl>   <nl> -static void <nl> +static inline void <nl>  cipop(mrb_state *mrb) <nl>  { <nl>    struct mrb_context *c = mrb->c;
@@ -266,6 +266,7 @@ ecall(mrb_state *mrb, int i) <nl>    mrb_value *self = mrb->c->stack; <nl>    struct RObject *exc; <nl>   <nl> +  if (i<0) return; <nl>    p = mrb->c->ensure[i]; <nl>    if (!p) return; <nl>    if (mrb->c->ci->eidx > i)
@@ -1981,7 +1981,14 @@ mrb_mod_const_get(mrb_state *mrb, mrb_value mod) <nl>      end = (end == -1) ? len : end; <nl>      id = mrb_intern(mrb, ptr+off, end-off); <nl>      mod = mrb_const_get_sym(mrb, mod, id); <nl> -    off = (end == len) ? end : end+2; <nl> +    if (end == len) <nl> +      off = end; <nl> +    else { <nl> +      off = end + 2; <nl> +      if (off == len) {         /* trailing "::" */ <nl> +        mrb_name_error(mrb, id, "wrong constant name '%S'", path); <nl> +      } <nl> +    } <nl>    } <nl>   <nl>    return mod;
@@ -44,7 +44,7 @@ static mrb_value <nl>  exc_initialize(mrb_state *mrb, mrb_value exc) <nl>  { <nl>    mrb_value mesg; <nl> -  int argc; <nl> +  mrb_int argc; <nl>    mrb_value *argv; <nl>   <nl>    if (mrb_get_args(mrb, "|o*", &mesg, &argv, &argc) >= 1) {
@@ -542,7 +542,14 @@ mrb_get_args(mrb_state *mrb, const char *format, ...) <nl>  	    *p = mrb_fixnum(*sp); <nl>  	    break; <nl>  	  case MRB_TT_FLOAT: <nl> -	    *p = (mrb_int)mrb_float(*sp); <nl> +	    { <nl> +	      mrb_float f = mrb_float(*sp); <nl> + <nl> +	      if (!FIXABLE(f)) { <nl> +		mrb_raise(mrb, E_RANGE_ERROR, "float too big for int"); <nl> +	      } <nl> +	      *p = (mrb_int)f; <nl> +	    } <nl>  	    break; <nl>  	  case MRB_TT_FALSE: <nl>  	    *p = 0;
@@ -110,7 +110,7 @@ typedef unsigned short int IPsecRefTableUnusedCount; <nl>   <nl>  #define IPSEC_SA_REF_MAX         (~IPSEC_SAREF_NULL) <nl>  #define IPSEC_SAREF_FIRST        1 <nl> -#define IPSEC_SA_REF_MASK        (IPSEC_SA_REF_MAX >> (IPSEC_SA_REF_FIELD_WIDTH - IPSEC_SA_REF_TABLE_IDX_WIDTH)) <nl> +// from openswan.h #define IPSEC_SA_REF_MASK        (IPSEC_SA_REF_MAX >> (IPSEC_SA_REF_FIELD_WIDTH - IPSEC_SA_REF_TABLE_IDX_WIDTH)) <nl>  #define IPSEC_SA_REF_TABLE_MASK ((IPSEC_SA_REF_MAX >> (IPSEC_SA_REF_FIELD_WIDTH - IPSEC_SA_REF_MAINTABLE_IDX_WIDTH)) << IPSEC_SA_REF_SUBTABLE_IDX_WIDTH) <nl>  #define IPSEC_SA_REF_ENTRY_MASK  (IPSEC_SA_REF_MAX >> (IPSEC_SA_REF_FIELD_WIDTH - IPSEC_SA_REF_SUBTABLE_IDX_WIDTH)) <nl>  
@@ -725,12 +725,15 @@ static bool spdb_v2_match_parent(struct db_sa *sadb, <nl>  					   statement is dangerous */ <nl>  					char esb[ENUM_SHOW_BUF_LEN]; <nl>   <nl> -					DBG_log("proposal %u %s encr= (policy:%s vs offered:%s)", <nl> +					DBG_log("proposal %u %s encr= (policy:%s(%d) vs offered:%s(%d))", <nl>  						propnum, <nl>  						encr_matched ? "succeeded" : "failed", <nl>  						enum_showb(&ikev2_trans_type_encr_names, encrid, esb, sizeof(esb)), <nl> -						enum_show(&ikev2_trans_type_encr_names, <nl> -							  encr_transform)); <nl> +						encr_keylen, <nl> +						enum_show(&ikev2_trans_type_encr_names, encr_transform), <nl> +						keylen <nl> +						 <nl> +						); <nl>  					/* TODO: We could have no integ with aes_gcm, see how we fixed this for child SA */ <nl>  					DBG_log("            %s integ=(policy:%s vs offered:%s)", <nl>  						integ_matched ? "succeeded" : "failed",
@@ -431,7 +431,8 @@ void restart_connections_by_peer(struct connection *const c) <nl>  		host_addr = c->spd.that.host_addr; <nl>  	} <nl>   <nl> -	if (hp_next == NULL)  { <nl> +	if (c_kind == CK_INSTANCE && hp_next == NULL) { <nl> +		/* in simple cases this is  a dangling hp */ <nl>  		DBG(DBG_CONTROL, <nl>  			DBG_log ("no connection to restart after termination")); <nl>  	} else {
@@ -172,6 +172,9 @@ aggr_inI1_outR1_continue1(struct pluto_crypto_req_cont *pcrc <nl>    /* unpack first calculation */ <nl>    unpack_KE(st, r, &st->st_gr); <nl>   <nl> +  /* unpack nonce too */ <nl> +  unpack_nonce(&st->st_nr, r); <nl> + <nl>    /* NOTE: the "r" reply will get freed by our caller */ <nl>     <nl>    /* set up second calculation */
@@ -142,7 +142,7 @@ static void retransmit_v1_msg(struct state *st) <nl>  		delay_ms = c->r_interval; <nl>  	} <nl>   <nl> -	if (delay_ms != 0) { <nl> +	if (delay_ms != 0) <nl>  		delay_ms =  retrans_delay(st, delay_ms); <nl>   <nl>  	if (delay_ms != 0) {
@@ -269,6 +269,9 @@ load_cert(bool forcedtype, const char *filename, <nl>  	rewind(fd); <nl>  	cert->u.blob.ptr = alloc_bytes(cert->u.blob.len, " cert blob"); <nl>  	bytes = fread(cert->u.blob.ptr, 1, cert->u.blob.len, fd); <nl> +	if(bytes != cert->u.blob.len)	{ <nl> +		openswan_log("  WARNING: could not fully read certificate-blob filename '%s'\n", filename); <nl> +	} <nl>  	fclose(fd); <nl>      } <nl>      return FALSE;
@@ -213,6 +213,7 @@ cherokee_config_node_add (cherokee_config_node_t *conf, const char *key, cheroke <nl>  		} <nl>   <nl>  		if (final) { <nl> +			cherokee_buffer_clean (&child->val); <nl>  			cherokee_buffer_add_buffer (&child->val, val); <nl>  		} <nl>  
@@ -241,8 +241,13 @@ CompileKeymap(XkbFile *file, struct xkb_keymap *keymap, enum merge_mode merge) <nl>           file = (XkbFile *) file->common.next) { <nl>          if (file->file_type < FIRST_KEYMAP_FILE_TYPE || <nl>              file->file_type > LAST_KEYMAP_FILE_TYPE) { <nl> -            log_err(ctx, "Cannot define %s in a keymap file\n", <nl> -                    xkb_file_type_to_string(file->file_type)); <nl> +            if (file->file_type == FILE_TYPE_GEOMETRY) { <nl> +                log_vrb(ctx, 1, <nl> +                        "Geometry sections are not supported; ignoring\n"); <nl> +            } else { <nl> +                log_err(ctx, "Cannot define %s in a keymap file\n", <nl> +                        xkb_file_type_to_string(file->file_type)); <nl> +            } <nl>              continue; <nl>          } <nl>  
@@ -1256,7 +1256,7 @@ TEST(dlfcn, dt_runpath_smoke) { <nl>  // Bionic specific tests <nl>  #if defined(__BIONIC__) <nl>   <nl> -#if defined(__arm__) || defined(__i386__) <nl> +#if defined(__arm__) <nl>  const llvm::ELF::Elf32_Dyn* to_dynamic_table(const char* p) { <nl>    return reinterpret_cast<const llvm::ELF::Elf32_Dyn*>(p); <nl>  } <nl> @@ -1320,7 +1320,7 @@ void validate_compatibility_of_native_library(const char* soname) { <nl>    validate_compatibility_of_native_library(path, elf); <nl>  } <nl>   <nl> -// This is a test for app compatibility workaround for arm and x86 apps <nl> +// This is a test for app compatibility workaround for arm apps <nl>  // affected by http://b/24465209 <nl>  TEST(dlext, compat_elf_hash_and_relocation_tables) { <nl>    validate_compatibility_of_native_library("libc.so"); <nl> @@ -1332,7 +1332,7 @@ TEST(dlext, compat_elf_hash_and_relocation_tables) { <nl>    validate_compatibility_of_native_library("libjnigraphics.so"); <nl>  } <nl>   <nl> -#endif //  defined(__arm__) || defined(__i386__) <nl> +#endif //  defined(__arm__) <nl>   <nl>  TEST(dlfcn, dt_runpath_absolute_path) { <nl>    std::string libpath = get_testlib_root() + "/libtest_dt_runpath_d.so";
@@ -81,7 +81,8 @@ void pthread_exit(void* return_value) { <nl>   <nl>    if (thread->alternate_signal_stack != NULL) { <nl>      // Tell the kernel to stop using the alternate signal stack. <nl> -    stack_t ss = {}; <nl> +    stack_t ss; <nl> +    memset(&ss, 0, sizeof(ss)); <nl>      ss.ss_flags = SS_DISABLE; <nl>      sigaltstack(&ss, NULL); <nl>  
@@ -53,7 +53,7 @@ TEST(linker_memory, test_alloc_0) { <nl>    LinkerMemoryAllocator allocator; <nl>    void* ptr = allocator.alloc(0); <nl>    ASSERT_TRUE(ptr != nullptr); <nl> -  free(ptr); <nl> +  allocator.free(ptr); <nl>  } <nl>   <nl>  TEST(linker_memory, test_free_nullptr) { <nl> @@ -110,7 +110,7 @@ TEST(linker_memory, test_realloc) { <nl>   <nl>    ASSERT_TRUE(memcmp(reallocated_ptr, model, 4000) == 0); <nl>   <nl> -  ASSERT_EQ(nullptr, realloc(reallocated_ptr, 0)); <nl> +  ASSERT_EQ(nullptr, allocator.realloc(reallocated_ptr, 0)); <nl>  } <nl>   <nl>  TEST(linker_memory, test_small_smoke) {
@@ -198,7 +198,7 @@ void get_malloc_leak_info(uint8_t** info, size_t* overallSize, <nl>      // debug_log("info = %p\n", info); <nl>      if (*info == NULL) { <nl>          *overallSize = 0; <nl> -        goto done; <nl> +        goto out_nomem_info; <nl>      } <nl>   <nl>      // debug_log("sorting list...\n"); <nl> @@ -220,6 +220,7 @@ void get_malloc_leak_info(uint8_t** info, size_t* overallSize, <nl>          head += *infoSize; <nl>      } <nl>   <nl> +out_nomem_info: <nl>      dlfree(list); <nl>   <nl>  done:
@@ -193,7 +193,7 @@ void APE::Properties::analyzeCurrent() <nl>    uint blocksPerFrame = header.mid(4, 4).toUInt(false); <nl>    uint finalFrameBlocks = header.mid(8, 4).toUInt(false); <nl>    uint totalBlocks = totalFrames > 0 ? (totalFrames -  1) * blocksPerFrame + finalFrameBlocks : 0; <nl> -  d->length = totalBlocks / d->sampleRate; <nl> +  d->length = d->sampleRate > 0 ? totalBlocks / d->sampleRate : 0; <nl>    d->bitrate = d->length > 0 ? ((d->streamLength * 8L) / d->length) / 1000 : 0; <nl>  } <nl>  
@@ -140,9 +140,9 @@ QString MPDConnectionDetails::description() const <nl>  { <nl>      QString n=name.isEmpty() ? i18n("Default") : name; <nl>      if (hostname.startsWith('/')) { <nl> -        return i18nc("name (host)", "%1 (%2)").arg(n).arg(hostname); <nl> +        return i18nc("name (host)", "\"%1\"").arg(n); <nl>      } else { <nl> -        return i18nc("name (host:port)", "%1 (%2:%3)").arg(n).arg(hostname).arg(port); <nl> +        return i18nc("name (host:port)", "\"%1\" (%2:%3)").arg(n).arg(hostname).arg(port); <nl>      } <nl>  } <nl>  
@@ -94,7 +94,7 @@ raptor_unicode_utf8_string_put_char(raptor_unichar c, <nl>   <nl>    /* when no buffer given, return size */ <nl>    if(!output) <nl> -    return size; <nl> +    return (int)size; /* ok since size is in range 1..6 */ <nl>   <nl>    if(size > length) <nl>      return -1; <nl> @@ -134,7 +134,7 @@ raptor_unicode_utf8_string_put_char(raptor_unichar c, <nl>        output[0] = (unsigned char)c; <nl>    } <nl>   <nl> -  return size; <nl> +  return (int)size; /* ok since size is in range 1..6 */ <nl>  } <nl>   <nl>   <nl> @@ -186,7 +186,7 @@ raptor_unicode_utf8_string_get_char(const unsigned char *input, size_t length, <nl>   <nl>   <nl>    if(!output) <nl> -    return size; <nl> +    return (int)size; /* ok since size is in range 1..6 */ <nl>   <nl>    if(length < size) <nl>      return -1; <nl> @@ -254,7 +254,7 @@ raptor_unicode_utf8_string_get_char(const unsigned char *input, size_t length, <nl>    if(c > raptor_unicode_max_codepoint) <nl>      return -4; <nl>   <nl> -  return size; <nl> +  return (int)size; /* ok since size is in range 1..6 */ <nl>  } <nl>   <nl>  
@@ -1806,6 +1806,7 @@ main(int argc, char *argv[]) <nl>        fprintf(stderr, "raptor_feature_from_uri returned %d expected %d\n", fn, i); <nl>        return 1; <nl>      } <nl> +    raptor_free_uri(feature_uri); <nl>    } <nl>   <nl>    raptor_finish();
@@ -1042,6 +1042,7 @@ raptor_rdfxmla_serialize_terminate(raptor_serializer* serializer) <nl>      context->nodes=NULL; <nl>    } <nl>     <nl> +  /* always free raptor_namespace* before stack */ <nl>    if(context->nstack) { <nl>      if(!context->external_nstack) <nl>        raptor_free_namespaces(context->nstack); <nl> @@ -1174,6 +1175,11 @@ raptor_rdfxmla_serialize_set_xml_writer(raptor_serializer* serializer, <nl>    context->starting_depth= raptor_xml_writer_get_depth(xml_writer) + 1; <nl>    context->external_xml_writer= (xml_writer != NULL); <nl>   <nl> +  if(context->xml_nspace) <nl> +    raptor_free_namespace(context->xml_nspace); <nl> +  if(context->rdf_nspace) <nl> +    raptor_free_namespace(context->rdf_nspace); <nl> +  /* always free raptor_namespace* before stack */ <nl>    if(context->nstack) <nl>      raptor_free_namespaces(context->nstack); <nl>  
@@ -1180,7 +1180,7 @@ static MagickBooleanType ReadPSDChannel(Image *image,const PSDInfo *psd_info, <nl>        Ignore mask that is not a user supplied layer mask, if the mask is <nl>        disabled or if the flags have unsupported values. <nl>      */ <nl> -    if (layer_info->channel_info[channel].type != -2 || <nl> +    if ((layer_info->channel_info[channel].type != -2) || <nl>          (layer_info->mask.flags > 3) || (layer_info->mask.flags & 0x02)) <nl>      { <nl>        SeekBlob(image,layer_info->channel_info[channel].size-2,SEEK_CUR); <nl> @@ -1338,7 +1338,8 @@ static MagickBooleanType ReadPSDLayer(Image *image,const PSDInfo *psd_info, <nl>    if ((status != MagickFalse) && (layer_info->mask.image != (Image *) NULL)) <nl>      { <nl>        status=CompositeImage(layer_info->image,layer_info->mask.image, <nl> -        CopyAlphaCompositeOp,MagickTrue,0,0,exception); <nl> +        CopyAlphaCompositeOp,MagickTrue,layer_info->mask.page.x, <nl> +        layer_info->mask.page.y,exception); <nl>        layer_info->mask.image=DestroyImage(layer_info->mask.image); <nl>      } <nl>  
@@ -173,6 +173,7 @@ static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception) <nl>      map_length, <nl>      number_colormaps, <nl>      number_planes, <nl> +    number_planes_filled, <nl>      one, <nl>      offset, <nl>      pixel_info_length; <nl> @@ -308,9 +309,12 @@ static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception) <nl>      if (image->alpha_trait != UndefinedPixelTrait) <nl>        number_planes++; <nl>      number_pixels=(MagickSizeType) image->columns*image->rows; <nl> -    if ((number_pixels*number_planes) != (size_t) (number_pixels*number_planes)) <nl> +    number_planes_filled=(number_planes % 2 == 0) ? number_planes : <nl> +      number_planes+1; <nl> +    if ((number_pixels*number_planes_filled) != (size_t) (number_pixels* <nl> +         number_planes_filled)) <nl>        ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed"); <nl> -    pixel_info_length=image->columns*image->rows*MagickMax(number_planes,4); <nl> +    pixel_info_length=image->columns*image->rows*number_planes_filled; <nl>      pixel_info=AcquireVirtualMemory(pixel_info_length,sizeof(*pixels)); <nl>      if (pixel_info == (MemoryInfo *) NULL) <nl>        ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
@@ -5960,8 +5960,8 @@ MagickExport Image *WaveletDenoiseImage(const Image *image, <nl>            difference; <nl>   <nl>          difference=pixels[low_pass]-pixels[high_pass]; <nl> -        pixels[i]+=copysignf(fmaxf(fabsf(difference)-magnitude,0.0f), <nl> -          difference); <nl> +        pixels[i]+=copysignf(fmaxf(fabsf(difference)-magnitude- <nl> +          softness*magnitude,0.0f),difference); <nl>        } <nl>      } <nl>      /*
@@ -835,7 +835,8 @@ static MagickBooleanType ReadPSDChannelPixels(Image *image, <nl>                    SetPixelIndex(image,(((unsigned char) pixel) & <nl>                      (0x01 << (7-bit))) != 0 ? 0 : 255,q); <nl>                    SetPixelViaPixelInfo(image,image->colormap+(ssize_t) <nl> -                    GetPixelIndex(image,q),q); <nl> +                    ConstrainColormapIndex(image,GetPixelIndex(image,q), <nl> +                      exception),q); <nl>                    q+=GetPixelChannels(image); <nl>                    x++; <nl>                  }
@@ -3996,10 +3996,11 @@ static Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception) <nl>            (void) RelinquishUniqueFileResource(filename); <nl>          } <nl>          read_info=DestroyImageInfo(read_info); <nl> -        RelinquishDCMMemory(&info,&map,stream_info,stack,data); <nl>          image=DestroyImageList(image); <nl>          if ((status == MagickFalse) && (exception->severity < ErrorException)) <nl>            ThrowDCMException(CorruptImageError,"CorruptImageError") <nl> +        else <nl> +          RelinquishDCMMemory(&info,&map,stream_info,stack,data); <nl>          return(GetFirstImageInList(images)); <nl>        } <nl>      if (info.depth != (1UL*MAGICKCORE_QUANTUM_DEPTH))
@@ -496,6 +496,7 @@ MagickExport Image *ConnectedComponentsImage(const Image *image, <nl>              j=(ssize_t) GetPixelIndex(component_image,p); <nl>              if (j != i) <nl>                object[j].census++; <nl> +            p+=GetPixelChannels(component_image); <nl>            } <nl>          } <nl>          census=0; <nl> @@ -527,7 +528,7 @@ MagickExport Image *ConnectedComponentsImage(const Image *image, <nl>            for (x=0; x < (ssize_t) bounding_box.width; x++) <nl>            { <nl>              if ((ssize_t) GetPixelIndex(component_image,q) == i) <nl> -              SetPixelIndex(image,(Quantum) id,q); <nl> +              SetPixelIndex(component_image,(Quantum) id,q); <nl>              q+=GetPixelChannels(component_image); <nl>            } <nl>            if (SyncCacheViewAuthenticPixels(component_view,exception) == MagickFalse)
@@ -1713,7 +1713,7 @@ server_request_free_answers(struct server_request *req) <nl>  			free(victim->name); <nl>  			if (victim->data) <nl>  				free(victim->data); <nl> -			/* XXXX free(victim?) -NM */ <nl> +			free(victim); <nl>  			victim = next; <nl>  		} <nl>  		*list = NULL;
@@ -976,7 +976,6 @@ name_parse(u8 *packet, int length, int *idx, char *name_out, int name_out_len) { <nl>   <nl>  	for (;;) { <nl>  		u8 label_len; <nl> -		if (j >= length) return -1; <nl>  		GET8(label_len); <nl>  		if (!label_len) break; <nl>  		if (label_len & 0xc0) { <nl> @@ -997,6 +996,7 @@ name_parse(u8 *packet, int length, int *idx, char *name_out, int name_out_len) { <nl>  			*cp++ = '.'; <nl>  		} <nl>  		if (cp + label_len >= end) return -1; <nl> +		if (j + label_len > length) return -1; <nl>  		memcpy(cp, packet + j, label_len); <nl>  		cp += label_len; <nl>  		j += label_len;
@@ -226,6 +226,9 @@ void uv_close(uv_handle_t* handle, uv_close_cb close_cb) { <nl>          uv__close(stream->accepted_fd); <nl>          stream->accepted_fd = -1; <nl>        } <nl> + <nl> +      assert(!ev_is_active(&stream->read_watcher)); <nl> +      assert(!ev_is_active(&stream->write_watcher)); <nl>        break; <nl>   <nl>      case UV_PREPARE: <nl> @@ -824,17 +827,18 @@ static void uv__read(uv_stream_t* stream) { <nl>   <nl>      assert(buf.len > 0); <nl>      assert(buf.base); <nl> +    assert(stream->fd >= 0); <nl>   <nl>      do { <nl>        nread = read(stream->fd, buf.base, buf.len); <nl>      } <nl> -    while (nread == -1 && errno == EINTR); <nl> +    while (nread < 0 && errno == EINTR); <nl>   <nl>      if (nread < 0) { <nl>        /* Error */ <nl>        if (errno == EAGAIN) { <nl>          /* Wait for the next one. */ <nl> -        if (((uv_handle_t*)stream)->flags & UV_READING) { <nl> +        if (stream->flags & UV_READING) { <nl>            ev_io_start(EV_DEFAULT_UC_ &stream->read_watcher); <nl>          } <nl>          uv_err_new((uv_handle_t*)stream, EAGAIN);
@@ -1325,6 +1325,7 @@ int uv_async_init(uv_async_t* async, uv_async_cb async_cb) { <nl>   <nl>  int uv_async_send(uv_async_t* async) { <nl>    ev_async_send(EV_DEFAULT_UC_ &async->async_watcher); <nl> +  return 0; <nl>  } <nl>   <nl>  
@@ -16,6 +16,8 @@ <nl>  #ifndef QUEUE_H_ <nl>  #define QUEUE_H_ <nl>   <nl> +#include <stddef.h> <nl> + <nl>  typedef void *QUEUE[2]; <nl>   <nl>  /* Private macros. */ <nl> @@ -26,7 +28,7 @@ typedef void *QUEUE[2]; <nl>   <nl>  /* Public macros. */ <nl>  #define QUEUE_DATA(ptr, type, field)                                          \ <nl> -  ((type *) ((char *) (ptr) - ((char *) &((type *) 0)->field))) <nl> +  ((type *) ((char *) (ptr) - offsetof(type, field))) <nl>   <nl>  #define QUEUE_FOREACH(q, h)                                                   \ <nl>    for ((q) = QUEUE_NEXT(h); (q) != (h); (q) = QUEUE_NEXT(q))
@@ -1042,6 +1042,8 @@ static void huffman_decode_row(x3f_info_t *I, x3f_directory_entry_t *DE, <nl>    int col; <nl>    bit_state_t BS; <nl>   <nl> +  if (HUF->row_offsets.element[row] > ID->data_size - 1) <nl> +	  throw LIBRAW_EXCEPTION_IO_CORRUPT; <nl>    set_bit_state(&BS, (uint8_t *)ID->data + HUF->row_offsets.element[row]); <nl>   <nl>    for (col = 0; col < ID->columns; col++)
@@ -1122,6 +1122,8 @@ static void simple_decode_row(x3f_info_t *I, x3f_directory_entry_t *DE, <nl>    x3f_image_data_t *ID = &DEH->data_subsection.image_data; <nl>    x3f_huffman_t *HUF = ID->huffman; <nl>   <nl> +  if (row*row_stride > ID->data_size - (ID->columns*sizeof(uint32_t))) <nl> +	  throw LIBRAW_EXCEPTION_IO_CORRUPT; <nl>    uint32_t *data = (uint32_t *)((unsigned char *)ID->data + row * row_stride); <nl>   <nl>    uint16_t c[3] = {0, 0, 0};
@@ -484,6 +484,8 @@ update_focus_app (ShellWindowTracker *self) <nl>      } <nl>   <nl>    set_focus_app (self, new_focus_app); <nl> + <nl> +  g_clear_object (&new_focus_app); <nl>  } <nl>   <nl>  static void
@@ -816,6 +816,11 @@ NPP_GetValue(NPP          instance, <nl>   <nl>      *(NPObject**)value = funcs.createobject (instance, &plugin_class); <nl>      break; <nl> + <nl> +  case NPPVpluginNeedsXEmbed: <nl> +    *(bool *)value = TRUE; <nl> +    break; <nl> + <nl>    default: <nl>      ; <nl>    }
@@ -199,6 +199,7 @@ static inline int SCSigGetFlowintType(Signature *sig) <nl>                  fi->modifier == FLOWINT_MODIFIER_NE || <nl>                  fi->modifier == FLOWINT_MODIFIER_GE || <nl>                  fi->modifier == FLOWINT_MODIFIER_GT || <nl> +                fi->modifier == FLOWINT_MODIFIER_NOTSET || <nl>                  fi->modifier == FLOWINT_MODIFIER_ISSET) { <nl>                  read++; <nl>              } else {
@@ -419,7 +419,7 @@ int DetectEngineInspectHttpStatCode(DetectEngineCtx *de_ctx, <nl>      } <nl>   <nl>  #ifdef DEBUG <nl> -    SigMatch *sm = s->sm_lists[DETECT_SM_LIST_HSMDMATCH]; <nl> +    SigMatch *sm = s->sm_lists[DETECT_SM_LIST_HSCDMATCH]; <nl>      DetectContentData *co = (DetectContentData *)sm->ctx; <nl>      SCLogDebug("co->id %"PRIu32, co->id); <nl>  #endif
@@ -338,6 +338,11 @@ static int DetectFilemagicSetup (DetectEngineCtx *de_ctx, Signature *s, char *st <nl>      DetectFilemagicData *filemagic = NULL; <nl>      SigMatch *sm = NULL; <nl>   <nl> +    if (s->alproto != ALPROTO_HTTP && s->alproto != ALPROTO_SMTP) { <nl> +        SCLogError(SC_ERR_CONFLICTING_RULE_KEYWORDS, "rules with filemagic need to have protocol set to http or smtp."); <nl> +        goto error; <nl> +    } <nl> + <nl>      filemagic = DetectFilemagicParse(str); <nl>      if (filemagic == NULL) <nl>          goto error; <nl> @@ -359,11 +364,6 @@ static int DetectFilemagicSetup (DetectEngineCtx *de_ctx, Signature *s, char *st <nl>   <nl>      SigMatchAppendSMToList(s, sm, DETECT_SM_LIST_FILEMATCH); <nl>   <nl> -    if (s->alproto != ALPROTO_HTTP && s->alproto != ALPROTO_SMTP) { <nl> -        SCLogError(SC_ERR_CONFLICTING_RULE_KEYWORDS, "rule contains conflicting keywords."); <nl> -        goto error; <nl> -    } <nl> - <nl>      if (s->alproto == ALPROTO_HTTP) { <nl>          AppLayerHtpNeedFileInspection(); <nl>      }
@@ -54,6 +54,9 @@ static FpPatternStats fp_pattern_stats[DETECT_SM_LIST_MAX]; <nl>   <nl>  static void FpPatternStatsAdd(int list, uint16_t patlen) <nl>  { <nl> +    if (list < 0 || list >= DETECT_SM_LIST_MAX) <nl> +        return; <nl> + <nl>      FpPatternStats *f = &fp_pattern_stats[list]; <nl>   <nl>      if (f->min == 0)
@@ -1713,7 +1713,6 @@ int HTPParserTest07(void) { <nl>          if (r != 0) { <nl>              printf("toserver chunk %" PRIu32 " returned %" PRId32 ", expected" <nl>                      " 0: ", u, r); <nl> -            result = 0; <nl>              goto end; <nl>          } <nl>      } <nl> @@ -1721,7 +1720,6 @@ int HTPParserTest07(void) { <nl>      htp_state = f.aldata[AlpGetStateIdx(ALPROTO_HTTP)]; <nl>      if (htp_state == NULL) { <nl>          printf("no http state: "); <nl> -        result = 0; <nl>          goto end; <nl>      } <nl>   <nl> @@ -1731,12 +1729,20 @@ int HTPParserTest07(void) { <nl>      htp_tx_t *tx = list_get(htp_state->connp->conn->transactions, 0); <nl>      if (tx != NULL && tx->request_uri_normalized != NULL) { <nl>          if (reflen != bstr_size(tx->request_uri_normalized)) { <nl> +            printf("normalized uri len should be %"PRIuMAX", is %"PRIuMAX, <nl> +                (uintmax_t)reflen, <nl> +                (uintmax_t)bstr_size(tx->request_uri_normalized)); <nl>              goto end; <nl>          } <nl>   <nl>          if (memcmp(bstr_ptr(tx->request_uri_normalized), ref, <nl>                      bstr_size(tx->request_uri_normalized)) != 0) <nl>          { <nl> +            printf("normalized uri \""); <nl> +            PrintRawUriFp(stdout, (uint8_t *)bstr_ptr(tx->request_uri_normalized), bstr_size(tx->request_uri_normalized)); <nl> +            printf("\" != \""); <nl> +            PrintRawUriFp(stdout, ref, reflen); <nl> +            printf("\": "); <nl>              goto end; <nl>          } <nl>      }
@@ -2077,6 +2077,7 @@ static CURLcode Connect(struct UrlData *data, <nl>           <nl>          /* tell ourselves to fetch this range */ <nl>          conn->range = strdup(resumerange); <nl> +        conn->bits.use_range = TRUE;        /* enable range download */ <nl>          conn->bits.rangestringalloc = TRUE; /* mark range string allocated */ <nl>      } <nl>      
@@ -1554,7 +1554,7 @@ static CURLcode pop3_doing(struct connectdata *conn, bool *dophase_done) <nl>    CURLcode result; <nl>    result = pop3_multi_statemach(conn, dophase_done); <nl>   <nl> -  if(*dophase_done) { <nl> +  if(!result && *dophase_done) { <nl>      result = pop3_dophase_done(conn, FALSE /* not connected */); <nl>   <nl>      DEBUGF(infof(conn->data, "DO phase is complete\n"));
@@ -2456,6 +2456,12 @@ static CURLcode ssh_easy_statemach(struct connectdata *conn, <nl>   <nl>      if(Curl_pgrsUpdate(conn)) <nl>        return CURLE_ABORTED_BY_CALLBACK; <nl> +    else { <nl> +      struct timeval now = Curl_tvnow(); <nl> +      result = Curl_speedcheck(data, now); <nl> +      if(result) <nl> +        return result; <nl> +    } <nl>   <nl>      left = Curl_timeleft(data, NULL, duringconnect); <nl>      if(left < 0) {
@@ -320,13 +320,15 @@ _CURL_WARNING(_curl_easy_getinfo_err_curl_slist, <nl>   <nl>  /* evaluates to true if option takes a struct curl_slist * argument */ <nl>  #define _curl_is_slist_option(option)                                         \ <nl> -  ((option) == CURLOPT_HTTPHEADER ||                                          \ <nl> -   (option) == CURLOPT_HTTP200ALIASES ||                                      \ <nl> -   (option) == CURLOPT_QUOTE ||                                               \ <nl> +  ((option) == CURLOPT_HTTP200ALIASES ||                                      \ <nl> +   (option) == CURLOPT_HTTPHEADER ||                                          \ <nl> +   (option) == CURLOPT_MAIL_RCPT ||                                           \ <nl>     (option) == CURLOPT_POSTQUOTE ||                                           \ <nl>     (option) == CURLOPT_PREQUOTE ||                                            \ <nl> +   (option) == CURLOPT_PROXYHEADER ||                                         \ <nl> +   (option) == CURLOPT_QUOTE ||                                               \ <nl> +   (option) == CURLOPT_RESOLVE ||                                             \ <nl>     (option) == CURLOPT_TELNETOPTIONS ||                                       \ <nl> -   (option) == CURLOPT_MAIL_RCPT ||                                           \ <nl>     0) <nl>   <nl>  /* groups of curl_easy_getinfo infos that take the same type of argument */
@@ -1515,9 +1515,9 @@ CURLcode Curl_http_done(struct connectdata *conn, <nl>                        entire operation is complete */ <nl>       !conn->bits.retry && <nl>       !data->set.connect_only && <nl> -     ((http->readbytecount + <nl> -       data->req.headerbytecount - <nl> -       data->req.deductheadercount)) <= 0) { <nl> +     (http->readbytecount + <nl> +      data->req.headerbytecount - <nl> +      data->req.deductheadercount) <= 0) { <nl>      /* If this connection isn't simply closed to be retried, AND nothing was <nl>         read from the HTTP server (that counts), this can't be right so we <nl>         return an error here */
@@ -113,7 +113,7 @@ void ourWriteOut(CURL *curl, struct OutStruct *outs, const char *writeinfo) <nl>    double doubleinfo; <nl>   <nl>    while(ptr && *ptr) { <nl> -    if('%' == *ptr) { <nl> +    if('%' == *ptr && ptr[1]) { <nl>        if('%' == ptr[1]) { <nl>          /* an escaped %-letter */ <nl>          fputc('%', stream);
@@ -922,7 +922,7 @@ static void suboption(struct Curl_easy *data) <nl>          size_t tmplen = (strlen(v->data) + 1); <nl>          /* Add the variable only if it fits */ <nl>          if(len + tmplen < (int)sizeof(temp)-6) { <nl> -          if(sscanf(v->data, "%127[^,],%127s", varname, varval)) { <nl> +          if(sscanf(v->data, "%127[^,],%127s", varname, varval) == 2) { <nl>              msnprintf((char *)&temp[len], sizeof(temp) - len, <nl>                        "%c%s%c%s", CURL_NEW_ENV_VAR, varname, <nl>                        CURL_NEW_ENV_VALUE, varval);
@@ -2080,6 +2080,12 @@ static CURLcode Connect(struct UrlData *data, <nl>          conn->bits.use_range = TRUE;        /* enable range download */ <nl>          conn->bits.rangestringalloc = TRUE; /* mark range string allocated */ <nl>      } <nl> +    else if (data->set_range) { <nl> +      /* There is a range, but is not a resume, useful for random ftp access */ <nl> +      conn->range = strdup(data->set_range); <nl> +      conn->bits.rangestringalloc = TRUE; /* mark range string allocated */ <nl> +      conn->bits.use_range = TRUE;        /* enable range download */ <nl> +    } <nl>       <nl>      *in_connect = conn;      /* return this instead! */ <nl>  
@@ -238,9 +238,11 @@ CURLcode Curl_fillreadbuffer(struct connectdata *conn, int bytes, int *nreadp) <nl>      } <nl>  #endif /* CURL_DOES_CONVERSIONS */ <nl>   <nl> -    if((nread - hexlen) == 0) <nl> +    if((nread - hexlen) == 0) { <nl>        /* mark this as done once this chunk is transferred */ <nl>        data->req.upload_done = TRUE; <nl> +      infof(data, "Signaling end of chunked upload via terminating chunk.\n"); <nl> +    } <nl>   <nl>      nread += (int)strlen(endofline_native); /* for the added end of line */ <nl>    } <nl> @@ -1046,7 +1048,8 @@ static CURLcode readwrite_upload(struct Curl_easy *data, <nl>   <nl>      k->writebytecount += bytes_written; <nl>   <nl> -    if(k->writebytecount == data->state.infilesize) { <nl> +    if((!k->upload_chunky || k->forbidchunk) && <nl> +       (k->writebytecount == data->state.infilesize)) { <nl>        /* we have sent all data we were supposed to */ <nl>        k->upload_done = TRUE; <nl>        infof(data, "We are completely uploaded and fine\n");
@@ -981,6 +981,10 @@ void curl_easy_reset(struct Curl_easy *data) <nl>   <nl>    data->progress.flags |= PGRS_HIDE; <nl>    data->state.current_speed = -1; /* init to negative == impossible */ <nl> + <nl> +  /* zero out authentication data: */ <nl> +  memset(&data->state.authhost, 0, sizeof(struct auth)); <nl> +  memset(&data->state.authproxy, 0, sizeof(struct auth)); <nl>  } <nl>   <nl>  /*
@@ -297,10 +297,10 @@ rb_call0(rb_execution_context_t *ec, <nl>  } <nl>   <nl>  struct rescue_funcall_args { <nl> -    rb_thread_t *th; <nl>      VALUE defined_class; <nl>      VALUE recv; <nl>      ID mid; <nl> +    rb_execution_context_t *ec; <nl>      const rb_method_entry_t *me; <nl>      unsigned int respond: 1; <nl>      unsigned int respond_to_missing: 1; <nl> @@ -311,7 +311,7 @@ struct rescue_funcall_args { <nl>  static VALUE <nl>  check_funcall_exec(struct rescue_funcall_args *args) <nl>  { <nl> -    return call_method_entry(args->th->ec, args->defined_class, <nl> +    return call_method_entry(args->ec, args->defined_class, <nl>  			     args->recv, idMethodMissing, <nl>  			     args->me, args->argc, args->argv); <nl>  } <nl> @@ -372,7 +372,7 @@ check_funcall_missing(rb_execution_context_t *ec, VALUE klass, VALUE recv, ID mi <nl>  	new_args[0] = ID2SYM(mid); <nl>  	MEMCPY(new_args+1, argv, VALUE, argc); <nl>  	ec->method_missing_reason = MISSING_NOENTRY; <nl> -	args.th = rb_ec_thread_ptr(ec); <nl> +	args.ec = ec; <nl>  	args.recv = recv; <nl>  	args.me = me; <nl>  	args.mid = mid;
@@ -6,8 +6,8 @@ <nl>  #define GLOBAL_METHOD_CACHE_SIZE 0x800 <nl>  #endif <nl>  #define LSB_ONLY(x) ((x) & ~((x) - 1)) <nl> -#define POWOR_OF_2_P(x) ((x) == LSB_ONLY(x)) <nl> -#if !POWOR_OF_2_P(GLOBAL_METHOD_CACHE_SIZE) <nl> +#define POWER_OF_2_P(x) ((x) == LSB_ONLY(x)) <nl> +#if !POWER_OF_2_P(GLOBAL_METHOD_CACHE_SIZE) <nl>  # error GLOBAL_METHOD_CACHE_SIZE must be power of 2 <nl>  #endif <nl>  #ifndef GLOBAL_METHOD_CACHE_MASK
@@ -585,8 +585,12 @@ typedef struct rb_vm_struct { <nl>   <nl>  #define RUBY_VM_FIBER_VM_STACK_SIZE           (  16 * 1024 * sizeof(VALUE)) /*   64 KB or  128 KB */ <nl>  #define RUBY_VM_FIBER_VM_STACK_SIZE_MIN       (   2 * 1024 * sizeof(VALUE)) /*    8 KB or   16 KB */ <nl> -#define RUBY_VM_FIBER_MACHINE_STACK_SIZE      (  64 * 1024 * sizeof(VALUE)) /*  256 KB or  512 KB */ <nl> +#define RUBY_VM_FIBER_MACHINE_STACK_SIZE      (  64 * 1024 * sizeof(VALUE)) /*  256 KB or  512 KB */  <nl> +#if defined(__powerpc64__) <nl> +#define RUBY_VM_FIBER_MACHINE_STACK_SIZE_MIN  (  32 * 1024 * sizeof(VALUE)) /*   128 KB or  256 KB */ <nl> +#else <nl>  #define RUBY_VM_FIBER_MACHINE_STACK_SIZE_MIN  (  16 * 1024 * sizeof(VALUE)) /*   64 KB or  128 KB */ <nl> +#endif <nl>   <nl>  /* optimize insn */ <nl>  #define INTEGER_REDEFINED_OP_FLAG (1 << 0)
@@ -2919,8 +2919,8 @@ get_vp_value: <nl>      RB_GC_GUARD(vn) = SSIZET2NUM(n); <nl>      expo = VpExponent10(vx); <nl>      if (expo < 0 || expo >= 3) { <nl> -	char buf[16]; <nl> -	snprintf(buf, 16, "1E%"PRIdVALUE, -expo); <nl> +	char buf[SIZEOF_VALUE * CHAR_BIT / 3 + 4]; <nl> +	snprintf(buf, sizeof(buf), "1E%"PRIdVALUE, -expo); <nl>  	x = BigDecimal_mult2(x, ToValue(VpCreateRbObject(1, buf)), vn); <nl>      } <nl>      else {
@@ -39,7 +39,7 @@ syck_hdlr_add_alias( SyckParser *p, char *a ) <nl>  { <nl>      SyckNode *n; <nl>   <nl> -    if ( st_lookup( p->anchors, (st_data_t)a, &n ) ) <nl> +    if ( st_lookup( p->anchors, (st_data_t)a, (st_data_t *)&n ) ) <nl>      { <nl>          return n; <nl>      }
@@ -8786,7 +8786,7 @@ enum ibf_object_class_index { <nl>  struct ibf_object_string { <nl>      long encindex; <nl>      long len; <nl> -    char ptr[1]; <nl> +    char ptr[FLEX_ARY_LEN]; <nl>  }; <nl>   <nl>  struct ibf_object_regexp { <nl> @@ -8796,12 +8796,12 @@ struct ibf_object_regexp { <nl>   <nl>  struct ibf_object_array { <nl>      long len; <nl> -    long ary[1]; <nl> +    long ary[FLEX_ARY_LEN]; <nl>  }; <nl>   <nl>  struct ibf_object_hash { <nl>      long len; <nl> -    long keyval[1]; <nl> +    long keyval[FLEX_ARY_LEN]; <nl>  }; <nl>   <nl>  struct ibf_object_struct_range { <nl> @@ -8814,7 +8814,7 @@ struct ibf_object_struct_range { <nl>   <nl>  struct ibf_object_bignum { <nl>      ssize_t slen; <nl> -    BDIGIT digits[1]; <nl> +    BDIGIT digits[FLEX_ARY_LEN]; <nl>  }; <nl>   <nl>  enum ibf_object_data_type {
@@ -943,6 +943,8 @@ load_a_module(const char *path, int warn, int core) <nl>  				} <nl>  			} <nl>  		} <nl> + <nl> +		break; <nl>  	default: <nl>  		ilog(L_MAIN, "Module %s has unknown/unsupported MAPI version %d.", <nl>  		     mod_basename, MAPI_VERSION(*mapi_version));
@@ -247,8 +247,8 @@ capability_index_stats(void (*cb)(const char *line, void *privdata), void *privd <nl>  			cb(buf, privdata); <nl>  		} <nl>   <nl> -		rb_snprintf(buf, sizeof buf, "'%s': remaining bits - %ld", idx->name, <nl> -			    (sizeof(unsigned int) * 8) - (idx->highest_bit - 1)); <nl> +		rb_snprintf(buf, sizeof buf, "'%s': remaining bits - %u", idx->name, <nl> +			    (unsigned int)((sizeof(unsigned int) * 8) - (idx->highest_bit - 1))); <nl>  		cb(buf, privdata); <nl>  	} <nl>  
@@ -720,7 +720,8 @@ static INLINE OPJ_BOOL opj_tcd_init_tile(opj_tcd_t *p_tcd, OPJ_UINT32 p_tile_no, <nl>  		 <nl>  		/* compute l_data_size with overflow check */ <nl>  		l_data_size = (OPJ_UINT32)(l_tilec->x1 - l_tilec->x0); <nl> -		if ((((OPJ_UINT32)-1) / l_data_size) < (OPJ_UINT32)(l_tilec->y1 - l_tilec->y0)) { <nl> +		/* issue 733, l_data_size == 0U, probably something wrong should be checked before getting here */ <nl> +		if ((l_data_size > 0U) && ((((OPJ_UINT32)-1) / l_data_size) < (OPJ_UINT32)(l_tilec->y1 - l_tilec->y0))) { <nl>  			opj_event_msg(manager, EVT_ERROR, "Not enough memory for tile data\n"); <nl>  			return OPJ_FALSE; <nl>  		}
@@ -474,7 +474,13 @@ int mbedtls_net_poll( mbedtls_net_context *ctx, uint32_t rw, uint32_t timeout ) <nl>      { <nl>          ret = select( fd + 1, &read_fds, &write_fds, NULL, <nl>                        timeout == (uint32_t) -1 ? NULL : &tv ); <nl> -    } while( ret == EINTR ); <nl> +    } <nl> +#if ( defined(_WIN32) || defined(_WIN32_WCE) ) && !defined(EFIX64) && \ <nl> +    !defined(EFI32) <nl> +    while( ret == WSAEINTR ); <nl> +#else <nl> +    while( ret == EINTR ); <nl> +#endif <nl>   <nl>      if( ret < 0 ) <nl>          return( MBEDTLS_ERR_NET_POLL_FAILED );
@@ -2057,6 +2057,12 @@ static int ssl_parse_server_psk_hint( mbedtls_ssl_context *ssl, <nl>       * <nl>       * opaque psk_identity_hint<0..2^16-1>; <nl>       */ <nl> +    if( (*p) > end - 2 ) <nl> +    { <nl> +        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad server key exchange message " <nl> +                                    "(psk_identity_hint length)" ) ); <nl> +        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE ); <nl> +    } <nl>      len = (*p)[0] << 8 | (*p)[1]; <nl>      *p += 2; <nl>  
@@ -177,7 +177,7 @@ static const char * getPCPOpCodeStr(uint8_t opcode) <nl>   * buffers are same */ <nl>  static void copyIPv6IfDifferent(void * dest, const void * src) <nl>  { <nl> -	if(dest != src) { <nl> +	if(dest != src && src != NULL) { <nl>  		memcpy(dest, src, sizeof(struct in6_addr)); <nl>  	} <nl>  }
@@ -266,7 +266,7 @@ static struct DWAbbrev { <nl>  		DW_TAG_subrange_type, DW_CHILDREN_no, <nl>  		// No name! <nl>  		DW_AT_type,	 DW_FORM_ref_addr, <nl> -		DW_AT_upper_bound, DW_FORM_data1, <nl> +		DW_AT_upper_bound, DW_FORM_udata, <nl>  		0, 0 <nl>  	}, <nl>  
@@ -562,7 +562,7 @@ hostlink(void) <nl>  		p = strchr(p + 1, ' '); <nl>  	} <nl>   <nl> -	argv = malloc((13+nhostobj+nldflag+c)*sizeof argv[0]); <nl> +	argv = malloc((14+nhostobj+nldflag+c)*sizeof argv[0]); <nl>  	argc = 0; <nl>  	if(extld == nil) <nl>  		extld = "gcc"; <nl> @@ -605,6 +605,9 @@ hostlink(void) <nl>  	if(iself) <nl>  		argv[argc++] = "-rdynamic"; <nl>   <nl> +	if(strstr(argv[0], "clang") != nil) <nl> +		argv[argc++] = "-Qunused-arguments"; <nl> + <nl>  	// already wrote main object file <nl>  	// copy host objects to temporary directory <nl>  	for(i=0; i<nhostobj; i++) {
@@ -795,7 +795,7 @@ static const unsigned char *valid_star(const unsigned char *p, size_t len, <nl>           */ <nl>          if (p[i] == '*') { <nl>              int atstart = (state & LABEL_START); <nl> -            int atend = (i == len - 1 || p[i + i] == '.'); <nl> +            int atend = (i == len - 1 || p[i + 1] == '.'); <nl>              /*- <nl>               * At most one wildcard per pattern. <nl>               * No wildcards in IDNA labels.
@@ -589,6 +589,8 @@ unsigned long ossl_statem_client_max_message_size(SSL *s) <nl>              return SERVER_HELLO_DONE_MAX_LENGTH; <nl>   <nl>          case TLS_ST_CR_CHANGE: <nl> +            if (s->version == DTLS1_BAD_VER) <nl> +                return 3; <nl>              return CCS_MAX_LENGTH; <nl>   <nl>          case TLS_ST_CR_SESSION_TICKET:
@@ -537,7 +537,7 @@ int PEM_write_bio(BIO *bp, const char *name, char *header, unsigned char *data, <nl>  	     long len) <nl>  	{ <nl>  	int nlen,n,i,j,outl; <nl> -	unsigned char *buf; <nl> +	unsigned char *buf = NULL; <nl>  	EVP_ENCODE_CTX ctx; <nl>  	int reason=ERR_R_BUF_LIB; <nl>  	 <nl> @@ -557,7 +557,7 @@ int PEM_write_bio(BIO *bp, const char *name, char *header, unsigned char *data, <nl>  			goto err; <nl>  		} <nl>   <nl> -	buf=(unsigned char *)OPENSSL_malloc(PEM_BUFSIZE*8); <nl> +	buf = OPENSSL_malloc(PEM_BUFSIZE*8); <nl>  	if (buf == NULL) <nl>  		{ <nl>  		reason=ERR_R_MALLOC_FAILURE; <nl> @@ -578,12 +578,15 @@ int PEM_write_bio(BIO *bp, const char *name, char *header, unsigned char *data, <nl>  	EVP_EncodeFinal(&ctx,buf,&outl); <nl>  	if ((outl > 0) && (BIO_write(bp,(char *)buf,outl) != outl)) goto err; <nl>  	OPENSSL_free(buf); <nl> +	buf = NULL; <nl>  	if (	(BIO_write(bp,"-----END ",9) != 9) || <nl>  		(BIO_write(bp,name,nlen) != nlen) || <nl>  		(BIO_write(bp,"-----\n",6) != 6)) <nl>  		goto err; <nl>  	return(i+outl); <nl>  err: <nl> +	if (buf) <nl> +		OPENSSL_free(buf); <nl>  	PEMerr(PEM_F_PEM_WRITE_BIO,reason); <nl>  	return(0); <nl>  	}
@@ -76,6 +76,9 @@ int PKCS12_PBE_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass, int passlen, <nl>      unsigned char *salt; <nl>      unsigned char key[EVP_MAX_KEY_LENGTH], iv[EVP_MAX_IV_LENGTH]; <nl>   <nl> +    if (cipher == NULL) <nl> +        return 0; <nl> + <nl>      /* Extract useful info from parameter */ <nl>   <nl>      pbe = ASN1_TYPE_unpack_sequence(ASN1_ITEM_rptr(PBEPARAM), param);
@@ -281,7 +281,6 @@ static int dsa_priv_decode(EVP_PKEY *pkey, PKCS8_PRIV_KEY_INFO *p8) <nl>  	BN_CTX_free (ctx); <nl>  	sk_ASN1_TYPE_pop_free(ndsa, ASN1_TYPE_free); <nl>  	DSA_free(dsa); <nl> -	EVP_PKEY_free(pkey); <nl>  	return 0; <nl>  	} <nl>  
@@ -130,7 +130,8 @@ static int dl_load(DSO *dso) <nl>  		DSOerr(DSO_F_DL_LOAD,DSO_R_NO_FILENAME); <nl>  		goto err; <nl>  		} <nl> -	ptr = shl_load(filename, BIND_IMMEDIATE|DYNAMIC_PATH, 0L); <nl> +	ptr = shl_load(filename, BIND_IMMEDIATE | <nl> +		(dso->flags&DSO_FLAG_NO_NAME_TRANSLATION?0:DYNAMIC_PATH), 0L); <nl>  	if(ptr == NULL) <nl>  		{ <nl>  		DSOerr(DSO_F_DL_LOAD,DSO_R_LOAD_FAILED);
@@ -1394,6 +1394,8 @@ static int check_suiteb_cipher_list(const SSL_METHOD *meth, CERT *c, <nl>  		*prule_str = "ECDHE-ECDSA-AES256-GCM-SHA384"; <nl>  		break; <nl>  		} <nl> +	/* Set auto ECDH parameter determination */ <nl> +	c->ecdh_tmp_auto = 1; <nl>  	return 1; <nl>  	} <nl>  
@@ -1028,6 +1028,8 @@ int BN_mul(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx) <nl>  			assert(j <= al || j <= bl); <nl>  			k = j+j; <nl>  			t = BN_CTX_get(ctx); <nl> +			if (t == NULL) <nl> +				goto err; <nl>  			if (al > j || bl > j) <nl>  				{ <nl>  				bn_wexpand(t,k*4);
@@ -118,7 +118,7 @@ static int tree_init(X509_POLICY_TREE **ptree, STACK_OF(X509) *certs, <nl>          X509_check_purpose(x, -1, 0); <nl>   <nl>          /* If cache is NULL, likely ENOMEM: return immediately */ <nl> -        if ((cache = policy_cache_set(x)) == NULL) <nl> +        if (policy_cache_set(x) == NULL) <nl>              return X509_PCY_TREE_INTERNAL; <nl>      } <nl>  
@@ -356,6 +356,7 @@ static EVP_PKEY *b2i_rsa(const unsigned char **in, <nl>      const unsigned char *pin = *in; <nl>      EVP_PKEY *ret = NULL; <nl>      BIGNUM *e = NULL, *n = NULL, *d = NULL; <nl> +    BIGNUM *p = NULL, *q = NULL, *dmp1 = NULL, *dmq1 = NULL, *iqmp = NULL; <nl>      RSA *rsa = NULL; <nl>      unsigned int nbyte, hnbyte; <nl>      nbyte = (bitlen + 7) >> 3; <nl> @@ -372,7 +373,6 @@ static EVP_PKEY *b2i_rsa(const unsigned char **in, <nl>      if (!read_lebn(&pin, nbyte, &n)) <nl>          goto memerr; <nl>      if (!ispub) { <nl> -        BIGNUM *p = NULL, *q = NULL, *dmp1 = NULL, *dmq1 = NULL, *iqmp = NULL; <nl>          if (!read_lebn(&pin, hnbyte, &p)) <nl>              goto memerr; <nl>          if (!read_lebn(&pin, hnbyte, &q)) <nl> @@ -396,6 +396,14 @@ static EVP_PKEY *b2i_rsa(const unsigned char **in, <nl>      return ret; <nl>   memerr: <nl>      PEMerr(PEM_F_B2I_RSA, ERR_R_MALLOC_FAILURE); <nl> +    BN_free(e); <nl> +    BN_free(n); <nl> +    BN_free(p); <nl> +    BN_free(q); <nl> +    BN_free(dmp1); <nl> +    BN_free(dmq1); <nl> +    BN_free(iqmp); <nl> +    BN_free(d); <nl>      RSA_free(rsa); <nl>      EVP_PKEY_free(ret); <nl>      return NULL;
@@ -649,6 +649,7 @@ int tls1_setup_key_block(SSL *s) <nl>   <nl>      if ((p2 = (unsigned char *)OPENSSL_malloc(num)) == NULL) { <nl>          SSLerr(SSL_F_TLS1_SETUP_KEY_BLOCK, ERR_R_MALLOC_FAILURE); <nl> +        OPENSSL_free(p1); <nl>          goto err; <nl>      } <nl>  #ifdef TLS_DEBUG
@@ -3529,10 +3529,6 @@ GC_INNER void GC_dirty_init(void) <nl>          ABORT("/proc open failed"); <nl>      } <nl>      syscall(SYS_fcntl, GC_proc_fd, F_SETFD, FD_CLOEXEC); <nl> -    if (GC_proc_fd < 0) { <nl> -        WARN("/proc ioctl(PIOCOPENPD) failed", 0); <nl> -        return; <nl> -    } <nl>   <nl>      GC_dirty_maintained = TRUE; <nl>      GC_proc_buf = GC_scratch_alloc(GC_proc_buf_size);
@@ -3689,6 +3689,8 @@ static void restart_threads(void) <nl>  		cgpu = mining_thr[i]->cgpu; <nl>  		if (unlikely(!cgpu)) <nl>  			continue; <nl> +		if (cgpu->deven != DEV_ENABLED) <nl> +			continue; <nl>  		mining_thr[i]->work_restart = true; <nl>  		flush_queue(cgpu); <nl>  		cgpu->drv->flush_work(cgpu);
@@ -5099,6 +5099,8 @@ static void gen_stratum_work(struct pool *pool, struct work *work) <nl>  	alloc_len = pool->swork.cb_len; <nl>  	align_len(&alloc_len); <nl>  	coinbase = calloc(alloc_len, 1); <nl> +	if (unlikely(!coinbase)) <nl> +		quit(1, "Failed to calloc coinbase in gen_stratum_work"); <nl>  	hex2bin(coinbase, pool->swork.coinbase1, pool->swork.cb1_len); <nl>  	hex2bin(coinbase + pool->swork.cb1_len, pool->nonce1, pool->n1_len); <nl>  	hex2bin(coinbase + pool->swork.cb1_len + pool->n1_len, work->nonce2, pool->n2size); <nl> @@ -5123,6 +5125,8 @@ static void gen_stratum_work(struct pool *pool, struct work *work) <nl>  	merkle_hash = bin2hex((const unsigned char *)merkle_root, 32); <nl>   <nl>  	header = calloc(pool->swork.header_len, 1); <nl> +	if (unlikely(!header)) <nl> +		quit(1, "Failed to calloc header in gen_stratum_work"); <nl>  	sprintf(header, "%s%s%s%s%s%s%s", <nl>  		pool->swork.bbversion, <nl>  		pool->swork.prev_hash,
@@ -977,9 +977,12 @@ void AddTimeData(unsigned int ip, int64 nTime) <nl>                  } <nl>              } <nl>          } <nl> -        BOOST_FOREACH(int64 n, vTimeOffsets) <nl> -            printf("%+"PRI64d"  ", n); <nl> -        printf("|  nTimeOffset = %+"PRI64d"  (%+"PRI64d" minutes)\n", nTimeOffset, nTimeOffset/60); <nl> +        if (fDebug) { <nl> +            BOOST_FOREACH(int64 n, vTimeOffsets) <nl> +                printf("%+"PRI64d"  ", n); <nl> +            printf("|  "); <nl> +        } <nl> +        printf("nTimeOffset = %+"PRI64d"  (%+"PRI64d" minutes)\n", nTimeOffset, nTimeOffset/60); <nl>      } <nl>  } <nl>  
@@ -900,6 +900,7 @@ read_gif(Gif_Reader *grr, int read_flags, <nl>    Gif_DeleteArray(gfc.suffix); <nl>    Gif_DeleteArray(gfc.length); <nl>    gfc.gfi = 0; <nl> +  last_name = 0; <nl>   <nl>    if (gfs) <nl>      gfs->errors = gfc.errors[1];
@@ -89,6 +89,7 @@ char *sepol_av_to_string(policydb_t * policydbp, uint32_t tclass, <nl>  	int rc; <nl>  	int avlen = 0, len; <nl>   <nl> +	memset(avbuf, 0, sizeof avbuf); <nl>  	cladatum = policydbp->class_val_to_struct[tclass - 1]; <nl>  	p = avbuf; <nl>  	for (i = 0; i < cladatum->permissions.nprim; i++) {
@@ -521,6 +521,7 @@ int cil_resolve_aliasactual(struct cil_tree_node *current, void *extra_args, enu <nl>  	} <nl>  	if (NODE(alias_datum)->flavor != alias_flavor) { <nl>  		cil_log(CIL_ERR, "%s is not an alias\n",alias_datum->name); <nl> +		rc = SEPOL_ERR; <nl>  		goto exit; <nl>  	} <nl>   <nl> @@ -529,6 +530,12 @@ int cil_resolve_aliasactual(struct cil_tree_node *current, void *extra_args, enu <nl>  		goto exit; <nl>  	} <nl>   <nl> +	if (NODE(actual_datum)->flavor != flavor) { <nl> +		cil_log(CIL_ERR, "%s is a %s, but aliases a %s\n", alias_datum->name, cil_node_to_string(NODE(alias_datum)), cil_node_to_string(NODE(actual_datum))); <nl> +		rc = SEPOL_ERR; <nl> +		goto exit; <nl> +	} <nl> + <nl>  	alias = (struct cil_alias *)alias_datum; <nl>   <nl>  	if (alias->actual != NULL) {
@@ -753,9 +753,11 @@ poll_tree(fs_edge_t *const chld) <nl>  { <nl>  	struct stat fileInfo; <nl>  	glob_t files; <nl> +	int need_globfree = 0; <nl>  	DBGPRINTF("poll_tree: chld %p, name '%s', path: %s\n", chld, chld->name, chld->path); <nl>  	detect_updates(chld); <nl>  	const int ret = glob((char*)chld->path, runModConf->sortFiles|GLOB_BRACE, NULL, &files); <nl> +	need_globfree = 1; <nl>  	DBGPRINTF("poll_tree: glob returned %d\n", ret); <nl>  	if(ret == 0) { <nl>  		DBGPRINTF("poll_tree: processing %d files\n", (int) files.gl_pathc); <nl> @@ -788,12 +790,15 @@ poll_tree(fs_edge_t *const chld) <nl>  			} <nl>  			act_obj_add(chld, file, is_file, fileInfo.st_ino); <nl>  		} <nl> -		globfree(&files); <nl>  	} <nl>   <nl>  	poll_active_files(chld); <nl>   <nl> -done:	return; <nl> +done: <nl> +	if(need_globfree) { <nl> +		globfree(&files); <nl> +	} <nl> +	return; <nl>  } <nl>   <nl>  #ifdef HAVE_INOTIFY_INIT // TODO: shouldn't we use that in polling as well?
@@ -2964,13 +2964,7 @@ get_uncompressed_data(struct archive_read *a, const void **buff, size_t size, <nl>  	if (zip->codec == _7Z_COPY && zip->codec2 == (unsigned long)-1) { <nl>  		/* Copy mode. */ <nl>   <nl> -		/* <nl> -		 * Note: '1' here is a performance optimization. <nl> -		 * Recall that the decompression layer returns a count of <nl> -		 * available bytes; asking for more than that forces the <nl> -		 * decompressor to combine reads by copying data. <nl> -		 */ <nl> -		*buff = __archive_read_ahead(a, 1, &bytes_avail); <nl> +		*buff = __archive_read_ahead(a, minimum, &bytes_avail); <nl>  		if (bytes_avail <= 0) { <nl>  			archive_set_error(&a->archive, <nl>  			    ARCHIVE_ERRNO_FILE_FORMAT,
@@ -905,6 +905,7 @@ zip_read_local_file_header(struct archive_read *a, struct archive_entry *entry, <nl>  				archive_wstrcat(&s, wp); <nl>  				archive_wstrappend_wchar(&s, L'/'); <nl>  				archive_entry_copy_pathname_w(entry, s.s); <nl> +				archive_wstring_free(&s); <nl>  			} <nl>  		} else { <nl>  			cp = archive_entry_pathname(entry); <nl> @@ -915,6 +916,7 @@ zip_read_local_file_header(struct archive_read *a, struct archive_entry *entry, <nl>  				archive_strcat(&s, cp); <nl>  				archive_strappend_char(&s, '/'); <nl>  				archive_entry_set_pathname(entry, s.s); <nl> +				archive_string_free(&s); <nl>  			} <nl>  		} <nl>  	}
@@ -2300,6 +2300,11 @@ parse_codes(struct archive_read *a) <nl>        new_size = DICTIONARY_MAX_SIZE; <nl>      else <nl>        new_size = rar_fls((unsigned int)rar->unp_size) << 1; <nl> +    if (new_size == 0) { <nl> +      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT, <nl> +                        "Zero window size is invalid."); <nl> +      return (ARCHIVE_FATAL); <nl> +    } <nl>      new_window = realloc(rar->lzss.window, new_size); <nl>      if (new_window == NULL) { <nl>        archive_set_error(&a->archive, ENOMEM,
@@ -1030,6 +1030,7 @@ parse_time(const char *p, size_t n) <nl>  	time_t t = 0; <nl>  	int64_t data; <nl>   <nl> +	memset(&tm, 0, sizeof(tm)); <nl>  	if (n != 20) <nl>  		return (t); <nl>  	data = atol10(p, 4);
@@ -2751,7 +2751,7 @@ archive_read_format_zip_cleanup(struct archive_read *a) <nl>  		inflateEnd(&zip->stream); <nl>  #endif <nl>   <nl> -#if HAVA_LZMA_H && HAVE_LIBLZMA <nl> +#if HAVE_LZMA_H && HAVE_LIBLZMA <nl>      if (zip->zipx_lzma_valid) { <nl>  		lzma_end(&zip->zipx_lzma_stream); <nl>  	}
@@ -430,6 +430,7 @@ __archive_read_program(struct archive_read_filter *self, const char *cmd) <nl>  	    &state->child_stdout); <nl>  	if (child == -1) { <nl>  		free(state->out_buf); <nl> +		archive_string_free(&state->description); <nl>  		free(state); <nl>  		archive_set_error(&self->archive->archive, EINVAL, <nl>  		    "Can't initialize filter; unable to run program \"%s\"", <nl> @@ -441,6 +442,7 @@ __archive_read_program(struct archive_read_filter *self, const char *cmd) <nl>  	if (state->child == NULL) { <nl>  		child_stop(self, state); <nl>  		free(state->out_buf); <nl> +		archive_string_free(&state->description); <nl>  		free(state); <nl>  		archive_set_error(&self->archive->archive, EINVAL, <nl>  		    "Can't initialize filter; unable to run program \"%s\"",
@@ -1014,7 +1014,7 @@ setup_current_filesystem(struct archive_read_disk *a) <nl>  	if (!GetVolumePathName(tree_current_access_path(t), vol, sizeof(vol))) { <nl>  		t->current_filesystem->remote = -1; <nl>  		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC, <nl> -			"GetVolumePathName failed: %d", GetLastError()); <nl> +                        "GetVolumePathName failed: %d", (int)GetLastError()); <nl>  		return (ARCHIVE_FAILED); <nl>  	} <nl>  	switch (GetDriveType(vol)) {
@@ -408,7 +408,7 @@ xz_head(xz_statep state) <nl>          state->strm = init; <nl>          state->strm.avail_in = 0; <nl>          state->strm.next_in = NULL; <nl> -        if (lzma_auto_decoder(&state->strm, UINT64_MAX, 0) != LZMA_OK) { <nl> +        if (lzma_auto_decoder(&state->strm, 100000000, 0) != LZMA_OK) { <nl>              xmlFree(state->out); <nl>              xmlFree(state->in); <nl>              state->size = 0;
@@ -6972,6 +6972,14 @@ xmlParseMarkupDecl(xmlParserCtxtPtr ctxt) { <nl>  	    xmlParsePI(ctxt); <nl>  	} <nl>      } <nl> + <nl> +    /* <nl> +     * detect requirement to exit there and act accordingly <nl> +     * and avoid having instate overriden later on <nl> +     */ <nl> +    if (ctxt->instate == XML_PARSER_EOF) <nl> +        return; <nl> + <nl>      /* <nl>       * This is only for internal subset. On external entities, <nl>       * the replacement is done before parsing stage
@@ -541,7 +541,8 @@ erts_port_task_schedule(Eterm id, <nl>  #endif <nl>      } <nl>   <nl> -    ASSERT(!enq_port || !(runq->flags & ERTS_RUNQ_FLG_SUSPENDED)); <nl> +    ASSERT(!enq_port <nl> +	   || !(ERTS_RUNQ_FLGS_GET_NOB(runq) & ERTS_RUNQ_FLG_SUSPENDED)); <nl>   <nl>      if (!pp->sched.taskq) <nl>  	pp->sched.taskq = port_taskq_init(port_taskq_alloc(), pp);
@@ -3569,6 +3569,9 @@ static EC_KEY* ec_key_new(ErlNifEnv* env, ERL_NIF_TERM curve_arg) <nl>  	} else <nl>  	    goto out_err; <nl>   <nl> +        if (!group) <nl> +            goto out_err; <nl> + <nl>  	if (enif_inspect_binary(env, prime[2], &seed)) { <nl>  	    EC_GROUP_set_seed(group, seed.data, seed.size); <nl>  	}
@@ -5248,7 +5248,10 @@ Port *erts_get_heart_port() { <nl>   <nl>      for(ix = 0; ix < erts_max_ports; ix++) { <nl>  	port = &erts_port[ix]; <nl> -	/* immediate compare */ <nl> +	/* only examine undead or alive ports */ <nl> +	if (port->status & ERTS_PORT_SFLGS_DEAD) <nl> +	    continue; <nl> +	/* immediate atom compare */ <nl>  	if (port->reg && port->reg->name == am_heart_port) { <nl>  	    return port; <nl>  	}
@@ -1302,6 +1302,7 @@ int mutt_pattern_func (int op, char *prompt) <nl>    simple = safe_strdup (buf); <nl>    mutt_check_simple (buf, sizeof (buf), NONULL (SimpleSearch)); <nl>   <nl> +  memset (&err, 0, sizeof(err)); <nl>    err.data = error; <nl>    err.dsize = sizeof (error); <nl>    if ((pat = mutt_pattern_comp (buf, M_FULL_MSG, &err)) == NULL)
@@ -202,6 +202,10 @@ static int fetch_uidl(char *line, void *data) <nl>      endp++; <nl>    memmove(line, endp, strlen(endp) + 1); <nl>   <nl> +  /* uid must be at least be 1 byte */ <nl> +  if (strlen(line) == 0) <nl> +    return -1; <nl> + <nl>    for (i = 0; i < ctx->msgcount; i++) <nl>      if (mutt_str_strcmp(line, ctx->hdrs[i]->data) == 0) <nl>        break;
@@ -592,7 +592,7 @@ int nntp_add_group(char *line, void *data) <nl>  { <nl>    struct NntpServer *nserv = data; <nl>    struct NntpData *nntp_data = NULL; <nl> -  char group[LONG_STRING]; <nl> +  char group[LONG_STRING] = ""; <nl>    char desc[HUGE_STRING] = ""; <nl>    char mod; <nl>    anum_t first, last; <nl> @@ -600,8 +600,12 @@ int nntp_add_group(char *line, void *data) <nl>    if (!nserv || !line) <nl>      return 0; <nl>   <nl> -  if (sscanf(line, "%s " ANUM " " ANUM " %c %[^\n]", group, &last, &first, &mod, desc) < 4) <nl> +  /* These sscanf limits must match the sizes of the group and desc arrays */ <nl> +  if (sscanf(line, "%1023s " ANUM " " ANUM " %c %8191[^\n]", group, &last, &first, &mod, desc) < 4) <nl> +  { <nl> +    mutt_debug(4, "Cannot parse server line: %s\n", line); <nl>      return 0; <nl> +  } <nl>   <nl>    nntp_data = nntp_data_find(nserv, group); <nl>    nntp_data->deleted = false;
@@ -439,7 +439,7 @@ int mutt_index_menu (void) <nl>        imap_allow_reopen (Context); <nl>  #endif <nl>       <nl> -      index_hint = (Context->vcount && menu->current < Context->vcount) ? CURHDR->index : 0; <nl> +      index_hint = (Context->vcount && menu->current >= 0 && menu->current < Context->vcount) ? CURHDR->index : 0; <nl>   <nl>        if ((check = mx_check_mailbox (Context, &index_hint, 0)) < 0) <nl>        {
@@ -909,8 +909,13 @@ void _mutt_select_file (char *f, size_t flen, int flags, char ***files, int *num <nl>  	  char msg[SHORT_STRING]; <nl>  	  IMAP_MBOX mx; <nl>  	  int nentry = menu->current; <nl> -	   <nl> + <nl>  	  imap_parse_path (state.entry[nentry].name, &mx); <nl> +	  if (!mx.mbox) <nl> +	  { <nl> +	    mutt_error _("Cannot delete root folder"); <nl> +	    break; <nl> +	  } <nl>  	  snprintf (msg, sizeof (msg), _("Really delete mailbox \"%s\"?"), <nl>              mx.mbox); <nl>  	  if (mutt_yesorno (msg, M_NO) == M_YES)
@@ -48,6 +48,9 @@ static pop_auth_res_t pop_auth_sasl (POP_DATA *pop_data) <nl>    if (!pop_data->auth_list) <nl>      return POP_A_UNAVAIL; <nl>   <nl> +  if (mutt_sasl_start () != SASL_OK) <nl> +    return POP_A_FAILURE; <nl> + <nl>    if (mutt_sasl_client_new (pop_data->conn, &saslconn) < 0) <nl>    { <nl>      dprint (1, (debugfile, "pop_auth_sasl: Error allocating SASL connection.\n"));
@@ -1174,6 +1174,15 @@ static void avalon4_update(struct cgpu_info *avalon4) <nl>  			if (info->set_voltage[i] == info->set_voltage[0]) <nl>  				continue; <nl>   <nl> +			avalon4_stratum_set(avalon4, pool, i, 0); <nl> +		} <nl> +	} else { <nl> +		for (i = 1; i < AVA4_DEFAULT_MODULARS; i++) { <nl> +			if (!info->enable[i]) <nl> +				continue; <nl> +			if (info->mod_type[i] == AVA4_TYPE_MM40) <nl> +				continue; <nl> + <nl>  			avalon4_stratum_set(avalon4, pool, i, 0); <nl>  		} <nl>  	}
@@ -1504,7 +1504,6 @@ static void gen_gbt_work(struct pool *pool, struct work *work) <nl>  	work->work_block = work_block; <nl>  	calc_diff(work, 0); <nl>  	gettimeofday(&work->tv_staged, NULL); <nl> - <nl>  } <nl>   <nl>  static bool gbt_decode(struct pool *pool, json_t *res_val) <nl> @@ -4778,7 +4777,7 @@ retry_stratum: <nl>  		} <nl>  		json_decref(val); <nl>   <nl> -		if (pool->lp_url) <nl> +		if (pool->lp_url || pool->has_gbt) <nl>  			goto out; <nl>   <nl>  		/* Decipher the longpoll URL, if any, and store it in ->lp_url */
@@ -899,7 +899,7 @@ static inline void cg_runlock(cglock_t *lock) <nl>   <nl>  static inline void cg_wunlock(cglock_t *lock) <nl>  { <nl> -	wr_unlock(&lock->rwlock); <nl> +	wr_unlock_noyield(&lock->rwlock); <nl>  	mutex_unlock(&lock->mutex); <nl>  } <nl>  
@@ -4278,7 +4278,7 @@ static void mcast() <nl>   <nl>  		count++; <nl>  		came_from_siz = sizeof(came_from); <nl> -		if (SOCKETFAIL(rep = recvfrom(mcast_sock, buf, sizeof(buf), <nl> +		if (SOCKETFAIL(rep = recvfrom(mcast_sock, buf, sizeof(buf) - 1, <nl>  						0, (struct sockaddr *)(&came_from), &came_from_siz))) { <nl>  			applog(LOG_DEBUG, "API mcast failed count=%d (%s) (%d)", <nl>  					count, SOCKERRMSG, (int)mcast_sock);
@@ -91,7 +91,7 @@ void _simplelog(int prio, const char *str, bool force) <nl>  { <nl>  #ifdef HAVE_SYSLOG_H <nl>  	if (use_syslog) { <nl> -		syslog(prio, "%s", str); <nl> +		syslog(LOG_LOCAL0 | prio, "%s", str); <nl>  	} <nl>  #else <nl>  	if (0) {}
@@ -20,6 +20,8 @@ <nl>  void <nl>  explicit_bzero(void *p, size_t n) <nl>  { <nl> +	if (n == 0) <nl> +		return; <nl>  	(void)memset_s(p, n, 0, n); <nl>  } <nl>   <nl> @@ -34,6 +36,8 @@ static void (* volatile ssh_bzero)(void *, size_t) = bzero; <nl>  void <nl>  explicit_bzero(void *p, size_t n) <nl>  { <nl> +	if (n == 0) <nl> +		return; <nl>  	/* <nl>  	 * clang -fsanitize=memory needs to intercept memset-like functions <nl>  	 * to correctly detect memory initialisation. Make sure one is called
@@ -1,4 +1,4 @@ <nl> -/* $OpenBSD: scp.c,v 1.209 2020/05/01 06:31:42 djm Exp $ */ <nl> +/* $OpenBSD: scp.c,v 1.210 2020/05/06 20:57:38 djm Exp $ */ <nl>  /* <nl>   * scp - secure remote copy.  This is basically patched BSD rcp which <nl>   * uses ssh to do the data transfer (instead of using rcmd). <nl> @@ -1427,9 +1427,7 @@ sink(int argc, char **argv, const char *src) <nl>  			sink(1, vect, src); <nl>  			if (setimes) { <nl>  				setimes = 0; <nl> -				if (utimes(vect[0], tv) == -1) <nl> -					run_err("%s: set times: %s", <nl> -					    vect[0], strerror(errno)); <nl> +				(void) utimes(vect[0], tv); <nl>  			} <nl>  			if (mod_flag) <nl>  				(void) chmod(vect[0], mode);
@@ -479,6 +479,12 @@ void Client::setDisconnectedFromCore() <nl>          _ignoreListManager->deleteLater(); <nl>          _ignoreListManager = 0; <nl>      } <nl> + <nl> +    if (_transferManager) { <nl> +        _transferManager->deleteLater(); <nl> +        _transferManager = 0; <nl> +    } <nl> + <nl>      // we probably don't want to save pending input for reconnect <nl>      _userInputBuffer.clear(); <nl>  
@@ -865,6 +865,7 @@ ServerEditDlg::ServerEditDlg(const Network::Server &server, QWidget *parent) : Q <nl>      ui.setupUi(this); <nl>      ui.useSSL->setIcon(SmallIcon("document-encrypt")); <nl>      ui.host->setText(server.host); <nl> +    ui.host->setFocus(); <nl>      ui.port->setValue(server.port); <nl>      ui.password->setText(server.password); <nl>      ui.useSSL->setChecked(server.useSsl);
@@ -1,4 +1,4 @@ <nl> -/* $Id: replay_live.c,v 1.4 2003/12/16 03:58:37 aturner Exp $ */ <nl> +/* $Id: replay_live.c,v 1.5 2004/01/15 07:29:45 aturner Exp $ */ <nl>   <nl>  /* <nl>   * Copyright (c) 2003 Aaron Turner. <nl> @@ -36,7 +36,11 @@ <nl>  #include "config.h" <nl>   <nl>  #include <libnet.h> <nl> +#ifdef HAVE_PCAPNAV <nl>  #include <pcapnav.h> <nl> +#else <nl> +#include "fakepcapnav.h" <nl> +#endif <nl>  #include <sys/time.h> <nl>  #include <signal.h> <nl>  #include <string.h>
@@ -2000,6 +2000,8 @@ exif_subchunk_parse (SF_PRIVATE *psf, uint32_t length) <nl>  			case olym_MARKER : <nl>  				bytesread += psf_binheader_readf (psf, "4", &dword) ; <nl>  				psf_log_printf (psf, "%M : %u\n", marker, dword) ; <nl> +				if (bytesread + dword > length) <nl> +					break ; <nl>  				dword += (dword & 1) ; <nl>  				bytesread += psf_binheader_readf (psf, "j", dword) ; <nl>  				break ;
@@ -891,6 +891,12 @@ aiff_read_header (SF_PRIVATE *psf, COMM_CHUNK *comm_fmt) <nl>  			} ; <nl>  		} ; <nl>   <nl> +	if (psf->sf.channels < 1) <nl> +		return SFE_CHANNEL_COUNT_ZERO ; <nl> + <nl> +	if (psf->sf.channels >= SF_MAX_CHANNELS) <nl> +		return SFE_CHANNEL_COUNT ; <nl> + <nl>  	if (! (found_chunk & HAVE_FORM)) <nl>  		return SFE_AIFF_NO_FORM ; <nl>  
@@ -1467,7 +1467,7 @@ static const char *parse_scheme(struct parse_state *state) <nl>  		case '7': case '8': case '9': <nl>  		case '+': case '-': case '.': <nl>  			if (state->ptr == tmp) { <nl> -				return tmp; <nl> +				goto softfail; <nl>  			} <nl>  			/* no break */ <nl>  		case 'A': case 'B': case 'C': case 'D': case 'E': case 'F': case 'G': <nl> @@ -1484,19 +1484,20 @@ static const char *parse_scheme(struct parse_state *state) <nl>   <nl>  		default: <nl>  			if (!(mb = parse_mb(state, PARSE_SCHEME, state->ptr, state->end, tmp, 1))) { <nl> -				/* soft fail; parse path next */ <nl> -				return tmp; <nl> +				goto softfail; <nl>  			} <nl>  			state->ptr += mb - 1; <nl>  		} <nl>  	} while (++state->ptr != state->end); <nl>   <nl> +softfail: <nl> +	state->offset = 0; <nl>  	return state->ptr = tmp; <nl>  } <nl>   <nl>  php_http_url_t *php_http_url_parse(const char *str, size_t len, unsigned flags TSRMLS_DC) <nl>  { <nl> -	size_t maxlen = 3 * len; <nl> +	size_t maxlen = 3 * len + 8 /* null bytes for all components */; <nl>  	struct parse_state *state = ecalloc(1, sizeof(*state) + maxlen); <nl>   <nl>  	state->end = str + len;
@@ -133,7 +133,7 @@ PHP_HTTP_API php_http_message_t *php_http_message_parse(php_http_message_t *msg, <nl>  	if (greedy) { <nl>  		flags |= PHP_HTTP_MESSAGE_PARSER_GREEDY; <nl>  	} <nl> -	if (FAILURE == php_http_message_parser_parse(&p, &buf, flags, &msg)) { <nl> +	if (PHP_HTTP_MESSAGE_PARSER_STATE_FAILURE == php_http_message_parser_parse(&p, &buf, flags, &msg)) { <nl>  		if (free_msg) { <nl>  			php_http_message_free(&msg); <nl>  		}
@@ -22,10 +22,7 @@ ImagingPcxDecode(Imaging im, ImagingCodecState state, UINT8* buf, Py_ssize_t byt <nl>      UINT8 n; <nl>      UINT8* ptr; <nl>   <nl> -    if (strcmp(im->mode, "1") == 0 && state->xsize > state->bytes * 8) { <nl> -        state->errcode = IMAGING_CODEC_OVERRUN; <nl> -        return -1; <nl> -    } else if (strcmp(im->mode, "P") == 0 && state->xsize > state->bytes) { <nl> +    if ((state->xsize * state->bits + 7) / 8 > state->bytes) { <nl>          state->errcode = IMAGING_CODEC_OVERRUN; <nl>          return -1; <nl>      }
@@ -250,6 +250,16 @@ int ContentLine_Analyzer::DoDeliverOnce(int len, const u_char* data) <nl>  		case '\n': <nl>  			if ( last_char == '\r' ) <nl>  				{ <nl> +				// Weird corner-case: <nl> +				// this can happen if we see a \r at the end of a packet where crlf is <nl> +				// set to CR_as_EOL | LF_as_EOL, with the packet causing crlf to be set to <nl> +				// 0 and the next packet beginning with a \n. In this case we just swallow <nl> +				// the character and re-set last_char. <nl> +				if ( offset == 0 ) <nl> +					{ <nl> +					last_char = c; <nl> +					break; <nl> +					} <nl>  				--offset; // remove '\r' <nl>  				EMIT_LINE <nl>  				}
@@ -1053,7 +1053,7 @@ int main(int argc, char** argv) <nl>   <nl>  	io_sources.Register(thread_mgr, true); <nl>   <nl> -	if ( io_sources.Size() > 0 || have_pending_timers ) <nl> +	if ( io_sources.Size() > 0 || have_pending_timers || BifConst::exit_only_after_terminate ) <nl>  		{ <nl>  		if ( profiling_logger ) <nl>  			profiling_logger->Log();
@@ -166,6 +166,9 @@ void h2o_http2_scheduler_rebind(h2o_http2_scheduler_node_t *parent, h2o_http2_sc <nl>          decr_active_cnt(ref->super._parent); <nl>          incr_active_cnt(parent); <nl>      } <nl> +    /* update the backlinks */ <nl> +    ref->super._parent = parent; <nl> +    ref->super._slot = new_slot; <nl>   <nl>      if (exclusive) <nl>          convert_to_exclusive(parent, ref);
@@ -624,6 +624,7 @@ static int multipart_process_boundary(modsec_rec *msr, int last_part, char **err <nl>              &&(msr->mpd->mpp->tmp_file_fd != 0)) <nl>          { <nl>              close(msr->mpd->mpp->tmp_file_fd); <nl> +            msr->mpd->mpp->tmp_file_fd = -1; <nl>          } <nl>   <nl>          if (msr->mpd->mpp->type != MULTIPART_FILE) {
@@ -751,7 +751,7 @@ static void tv_details_row_activated( <nl>          gtk_widget_set_size_request(scrolled, 640, 480); <nl>          gtk_widget_show(scrolled); <nl>   <nl> -#if (GTK_MAJOR_VERSION == 3 && GTK_MINOR_VERSION < 8) <nl> +#if ((GTK_MAJOR_VERSION == 3 && GTK_MINOR_VERSION < 7) || (GTK_MAJOR_VERSION == 3 && GTK_MINOR_VERSION == 7 && GTK_MICRO_VERSION < 8)) <nl>          /* http://developer.gnome.org/gtk3/unstable/GtkScrolledWindow.html#gtk-scrolled-window-add-with-viewport */ <nl>          /* gtk_scrolled_window_add_with_viewport has been deprecated since version 3.8 and should not be used in newly-written code. */ <nl>          gtk_scrolled_window_add_with_viewport(GTK_SCROLLED_WINDOW(scrolled), textview);
@@ -139,7 +139,7 @@ static bool ureport_add_type(struct json_object *ur, problem_data_t *pd) <nl>          ureport_add_str(ur, "type", "USERSPACE"); <nl>      else if (strcmp(pd_item, "Python") == 0) <nl>          ureport_add_str(ur, "type", "PYTHON"); <nl> -    else if (strcmp(pd_item, "Kerneloops") == 0) <nl> +    else if (strcmp(pd_item, "Kerneloops") == 0 || strcmp(pd_item, "vmcore") == 0) <nl>          ureport_add_str(ur, "type", "KERNELOOPS"); <nl>      else <nl>      {
@@ -129,6 +129,12 @@ int main(int argc, char *argv[]) <nl>      } <nl>   <nl>      stat(options->in_file, &filestats); <nl> + <nl> +    if (filestats.st_size < 8) { <nl> +        printf("ERROR: Input file is too small to contain valid plist data.\n"); <nl> +        return -1; <nl> +    } <nl> + <nl>      plist_entire = (char *) malloc(sizeof(char) * (filestats.st_size + 1)); <nl>      read_size = fread(plist_entire, sizeof(char), filestats.st_size, iplist); <nl>      fclose(iplist);
@@ -615,6 +615,10 @@ static void translateE(edge_t * e, pointf offset) <nl>  	ED_label(e)->pos.x -= offset.x; <nl>  	ED_label(e)->pos.y -= offset.y; <nl>      } <nl> +    if (ED_xlabel(e) && ED_xlabel(e)->set) { <nl> +	ED_xlabel(e)->pos.x -= offset.x; <nl> +	ED_xlabel(e)->pos.y -= offset.y; <nl> +    } <nl>      if (ED_head_label(e) && ED_head_label(e)->set) { <nl>  	ED_head_label(e)->pos.x -= offset.x; <nl>  	ED_head_label(e)->pos.y -= offset.y;
@@ -249,11 +249,11 @@ static WINDOW_REC *window_highest_activity(WINDOW_REC *window) <nl>  { <nl>  	WINDOW_REC *rec, *max_win; <nl>  	GSList *tmp; <nl> -	int max_act, through; <nl> +	int max_act, max_ref, through; <nl>   <nl>  	g_return_val_if_fail(window != NULL, NULL); <nl>   <nl> -	max_win = NULL; max_act = 0; through = FALSE; <nl> +	max_win = NULL; max_act = 0; max_ref = 0; through = FALSE; <nl>   <nl>  	tmp = g_slist_find(windows, window); <nl>  	for (;; tmp = tmp->next) { <nl> @@ -267,9 +267,12 @@ static WINDOW_REC *window_highest_activity(WINDOW_REC *window) <nl>   <nl>  		rec = tmp->data; <nl>   <nl> -		if (rec->data_level > 0 && max_act < rec->data_level) { <nl> +		if (rec->data_level > 0 && <nl> +		    (rec->data_level > max_act || <nl> +		     (rec->data_level == max_act && rec->refnum < max_ref))) { <nl>  			max_act = rec->data_level; <nl>  			max_win = rec; <nl> +			max_ref = rec->refnum; <nl>  		} <nl>  	} <nl>  
@@ -120,7 +120,8 @@ static void cmd_server_add_modify(const char *data, gboolean add) <nl>   <nl>  	value = g_hash_table_lookup(optlist, "port"); <nl>  	port = *portstr == '\0' ? <nl> -		(value != NULL && *value != '\0' ? atoi(value) : DEFAULT_SERVER_ADD_PORT) <nl> +			(value != NULL && *value != '\0' ? <nl> +			atoi(value) : DEFAULT_SERVER_ADD_PORT) <nl>  		: atoi(portstr); <nl>   <nl>  	chatnet = g_hash_table_lookup(optlist, "network"); <nl> @@ -141,7 +142,11 @@ static void cmd_server_add_modify(const char *data, gboolean add) <nl>  			return; <nl>  		} <nl>  		rec->address = g_strdup(addr); <nl> +		rec->port = port; <nl>  	} else { <nl> +		if (*portstr != '\0' || g_hash_table_lookup(optlist, "port")) <nl> +			rec->port = port; <nl> + <nl>  		if (*password != '\0') g_free_and_null(rec->password); <nl>  		if (g_hash_table_lookup(optlist, "host")) { <nl>  			g_free_and_null(rec->own_host); <nl> @@ -149,8 +154,6 @@ static void cmd_server_add_modify(const char *data, gboolean add) <nl>  		} <nl>  	} <nl>   <nl> -	rec->port = port; <nl> - <nl>  	if (g_hash_table_lookup(optlist, "6")) <nl>  		rec->family = AF_INET6; <nl>          else if (g_hash_table_lookup(optlist, "4"))
@@ -2577,7 +2577,8 @@ multi_process_incoming_link(struct multi_context *m, struct multi_instance *inst <nl>              orig_buf = c->c2.buf.data; <nl>              if (process_incoming_link_part1(c, lsi, floated)) <nl>              { <nl> -                if (floated) <nl> +                /* nonzero length means that we have a valid, decrypted packed */ <nl> +                if (floated && c->c2.buf.len > 0) <nl>                  { <nl>                      multi_process_float(m, m->pending); <nl>                  }
@@ -27,7 +27,7 @@ <nl>  #include "file.h" <nl>   <nl>  #ifndef lint <nl> -FILE_RCSID("@(#)$File: readelf.c,v 1.102 2014/03/11 21:00:13 christos Exp $") <nl> +FILE_RCSID("@(#)$File: readelf.c,v 1.103 2014/05/02 02:25:10 christos Exp $") <nl>  #endif <nl>   <nl>  #ifdef BUILTIN_ELF <nl> @@ -477,6 +477,13 @@ donote(struct magic_set *ms, void *vbuf, size_t offset, size_t size, <nl>  	uint32_t namesz, descsz; <nl>  	unsigned char *nbuf = CAST(unsigned char *, vbuf); <nl>   <nl> +	if (xnh_sizeof + offset > size) { <nl> +		/* <nl> +		 * We're out of note headers. <nl> +		 */ <nl> +		return xnh_sizeof + offset; <nl> +	} <nl> + <nl>  	(void)memcpy(xnh_addr, &nbuf[offset], xnh_sizeof); <nl>  	offset += xnh_sizeof; <nl>  
@@ -150,6 +150,7 @@ mobility_opt_print(netdissect_options *ndo, <nl>  				goto trunc; <nl>  			} <nl>  			/* units of 4 secs */ <nl> +			ND_TCHECK_16BITS(&bp[i+2]); <nl>  			ND_PRINT((ndo, "(refresh: %u)", <nl>  				EXTRACT_16BITS(&bp[i+2]) << 2)); <nl>  			break;
@@ -811,6 +811,15 @@ handle_mlppp(netdissect_options *ndo, <nl>      if (!ndo->ndo_eflag) <nl>          ND_PRINT((ndo, "MLPPP, ")); <nl>   <nl> +    if (length < 2) { <nl> +        ND_PRINT((ndo, "[|mlppp]")); <nl> +        return; <nl> +    } <nl> +    if (!ND_TTEST_16BITS(p)) { <nl> +        ND_PRINT((ndo, "[|mlppp]")); <nl> +        return; <nl> +    } <nl> + <nl>      ND_PRINT((ndo, "seq 0x%03x, Flags [%s], length %u", <nl>             (EXTRACT_16BITS(p))&0x0fff, /* only support 12-Bit sequence space for now */ <nl>             bittok2str(ppp_ml_flag_values, "none", *p & 0xc0),
@@ -2045,6 +2045,10 @@ ieee802_11_print(netdissect_options *ndo, <nl>  		hdrlen = roundup2(hdrlen, 4); <nl>  	if (ndo->ndo_Hflag && FC_TYPE(fc) == T_DATA && <nl>  	    DATA_FRAME_IS_QOS(FC_SUBTYPE(fc))) { <nl> +		if(!ND_TTEST_1(p + hdrlen)) { <nl> +			nd_print_trunc(ndo); <nl> +			return hdrlen; <nl> +		} <nl>  		meshdrlen = extract_mesh_header_length(p+hdrlen); <nl>  		hdrlen += meshdrlen; <nl>  	} else
@@ -130,7 +130,7 @@ signature_verify(netdissect_options *ndo, const u_char *pptr, u_int plen, <nl>      /* <nl>       * Do we have all the packet data to be checked? <nl>       */ <nl> -    if (!ND_TTEST2(pptr, plen)) { <nl> +    if (!ND_TTEST2(*pptr, plen)) { <nl>          /* No. */ <nl>          return (CANT_CHECK_SIGNATURE); <nl>      } <nl> @@ -138,7 +138,7 @@ signature_verify(netdissect_options *ndo, const u_char *pptr, u_int plen, <nl>      /* <nl>       * Do we have the entire signature to check? <nl>       */ <nl> -    if (!ND_TTEST2(sig_ptr, sizeof(sig))) { <nl> +    if (!ND_TTEST2(*sig_ptr, sizeof(sig))) { <nl>          /* No. */ <nl>          return (CANT_CHECK_SIGNATURE); <nl>      }
@@ -270,6 +270,8 @@ dhcpv4_print(netdissect_options *ndo, <nl>   <nl>      i = 0; <nl>      while (i < length) { <nl> +        if (i + 2 > length) <nl> +            return -1; <nl>          tlv = cp + i; <nl>          type = (uint8_t)tlv[0]; <nl>          optlen = (uint8_t)tlv[1]; <nl> @@ -281,6 +283,8 @@ dhcpv4_print(netdissect_options *ndo, <nl>   <nl>          ND_PRINT((ndo, "%s", tok2str(dh4opt_str, "Unknown", type))); <nl>          ND_PRINT((ndo," (%u)", optlen + 2 )); <nl> +        if (i + 2 + optlen > length) <nl> +            return -1; <nl>   <nl>          switch (type) { <nl>          case DH4OPT_DNS_SERVERS:
@@ -694,7 +694,7 @@ rx_cache_insert(netdissect_options *ndo, <nl>  	UNALIGNED_MEMCPY(&rxent->client, &ip->ip_src, sizeof(uint32_t)); <nl>  	UNALIGNED_MEMCPY(&rxent->server, &ip->ip_dst, sizeof(uint32_t)); <nl>  	rxent->dport = dport; <nl> -	rxent->serviceId = EXTRACT_32BITS(&rxh->serviceId); <nl> +	rxent->serviceId = EXTRACT_16BITS(&rxh->serviceId); <nl>  	rxent->opcode = EXTRACT_32BITS(bp + sizeof(struct rx_header)); <nl>  } <nl>   <nl> @@ -725,7 +725,7 @@ rx_cache_find(const struct rx_header *rxh, const struct ip *ip, int sport, <nl>  		if (rxent->callnum == EXTRACT_32BITS(&rxh->callNumber) && <nl>  		    rxent->client.s_addr == clip && <nl>  		    rxent->server.s_addr == sip && <nl> -		    rxent->serviceId == EXTRACT_32BITS(&rxh->serviceId) && <nl> +		    rxent->serviceId == EXTRACT_16BITS(&rxh->serviceId) && <nl>  		    rxent->dport == sport) { <nl>   <nl>  			/* We got a match! */
@@ -542,6 +542,7 @@ decnet_print(netdissect_options *ndo, <nl>  	    length -= padlen; <nl>  	    caplen -= padlen; <nl>  	    rhp = (const union routehdr *)&(ap[sizeof(short)]); <nl> +	    ND_TCHECK(rhp->rh_short.sh_flags); <nl>  	    mflags = EXTRACT_LE_8BITS(rhp->rh_short.sh_flags); <nl>  	} <nl>   <nl> @@ -613,6 +614,7 @@ print_decnet_ctlmsg(netdissect_options *ndo, <nl>                      register const union routehdr *rhp, u_int length, <nl>                      u_int caplen) <nl>  { <nl> +	/* Our caller has already checked for mflags */ <nl>  	int mflags = EXTRACT_LE_8BITS(rhp->rh_short.sh_flags); <nl>  	register const union controlmsg *cmp = (const union controlmsg *)rhp; <nl>  	int src, dst, info, blksize, eco, ueco, hello, other, vers;
@@ -807,11 +807,15 @@ nfs_printfh(netdissect_options *ndo, <nl>   <nl>  	if (sfsname) { <nl>  		/* file system ID is ASCII, not numeric, for this server OS */ <nl> -		static char temp[NFSX_V3FHMAX+1]; <nl> +		char temp[NFSX_V3FHMAX+1]; <nl> +		u_int stringlen; <nl>   <nl>  		/* Make sure string is null-terminated */ <nl> -		strncpy(temp, sfsname, NFSX_V3FHMAX); <nl> -		temp[sizeof(temp) - 1] = '\0'; <nl> +		stringlen = len; <nl> +		if (stringlen > NFSX_V3FHMAX) <nl> +			stringlen = NFSX_V3FHMAX; <nl> +		strncpy(temp, sfsname, stringlen); <nl> +		temp[stringlen] = '\0'; <nl>  		/* Remove trailing spaces */ <nl>  		spacep = strchr(temp, ' '); <nl>  		if (spacep)
@@ -1726,7 +1726,7 @@ bgp_attr_print(netdissect_options *ndo, <nl>  			ND_PRINT((ndo, ", no SNPA")); <nl>                  } <nl>   <nl> -		while (len - (tptr - pptr) > 0) { <nl> +		while (tptr < pptr + len) { <nl>                      switch (af<<8 | safi) { <nl>                      case (AFNUM_INET<<8 | SAFNUM_UNICAST): <nl>                      case (AFNUM_INET<<8 | SAFNUM_MULTICAST): <nl> @@ -1894,7 +1894,7 @@ bgp_attr_print(netdissect_options *ndo, <nl>   <nl>  		tptr += 3; <nl>   <nl> -		while (len - (tptr - pptr) > 0) { <nl> +		while (tptr < pptr + len) { <nl>                      switch (af<<8 | safi) { <nl>                      case (AFNUM_INET<<8 | SAFNUM_UNICAST): <nl>                      case (AFNUM_INET<<8 | SAFNUM_MULTICAST):
@@ -480,7 +480,7 @@ babel_print_v2(netdissect_options *ndo, <nl>          case MESSAGE_UPDATE: { <nl>              if (!ndo->ndo_vflag) { <nl>                  ND_PRINT((ndo, " update")); <nl> -                if(len < 1) <nl> +                if(len < 10) <nl>                      ND_PRINT((ndo, "/truncated")); <nl>                  else <nl>                      ND_PRINT((ndo, "%s%s%s",
@@ -105,8 +105,8 @@ const char* <nl>  AP4_HevcParser::SliceTypeName(unsigned int slice_type) <nl>  { <nl>  	switch (slice_type) { <nl> -        case 0: return "P"; <nl> -        case 1: return "B"; <nl> +        case 0: return "B"; <nl> +        case 1: return "P"; <nl>          case 2: return "I"; <nl>          default: return NULL; <nl>      }
@@ -1041,6 +1041,8 @@ request_starting_cb (WebKitWebView *view, WebKitWebFrame *frame, WebKitWebResour <nl>   <nl>      g_object_ref (decision->request); <nl>      request_decision (uri, decision); <nl> + <nl> +    g_free (decision); <nl>  } <nl>   <nl>  void
@@ -1289,9 +1289,10 @@ getword(f, word, newlinep, filename) <nl>  	    /* <nl>  	     * Store the resulting character for the escape sequence. <nl>  	     */ <nl> -	    if (len < MAXWORDLEN-1) <nl> +	    if (len < MAXWORDLEN) { <nl>  		word[len] = value; <nl> -	    ++len; <nl> +		++len; <nl> +	    } <nl>   <nl>  	    if (!got) <nl>  		c = getc(f); <nl> @@ -1329,9 +1330,10 @@ getword(f, word, newlinep, filename) <nl>  	/* <nl>  	 * An ordinary character: store it in the word and get another. <nl>  	 */ <nl> -	if (len < MAXWORDLEN-1) <nl> +	if (len < MAXWORDLEN) { <nl>  	    word[len] = c; <nl> -	++len; <nl> +	    ++len; <nl> +	} <nl>   <nl>  	c = getc(f); <nl>      }
@@ -4227,11 +4227,9 @@ static struct mg_http_proto_data *mg_http_get_proto_data( <nl>  static void mg_http_free_proto_data_mp_stream( <nl>      struct mg_http_multipart_stream *mp) { <nl>    free((void *) mp->boundary); <nl> -  mp->boundary = NULL; <nl>    free((void *) mp->var_name); <nl> -  mp->var_name = NULL; <nl>    free((void *) mp->file_name); <nl> -  mp->file_name = NULL; <nl> +  memset(mp, 0, sizeof(*mp)); <nl>  } <nl>  #endif <nl>   <nl> @@ -5267,6 +5265,7 @@ static void mg_http_multipart_begin(struct mg_connection *nc, <nl>       */ <nl>      nc->flags |= MG_F_CLOSE_IMMEDIATELY; <nl>    } else { <nl> +    pd->mp_stream.state = MPS_BEGIN; <nl>      pd->mp_stream.boundary = strdup(boundary); <nl>      pd->mp_stream.boundary_len = strlen(boundary); <nl>      pd->mp_stream.var_name = pd->mp_stream.file_name = NULL;
@@ -1137,7 +1137,7 @@ inf_text_fixline_buffer_buffer_insert_text(InfTextBuffer* buffer, <nl>   <nl>      priv->keep = g_realloc( <nl>        priv->keep, <nl> -      priv->n_keep + inf_text_chunk_get_length(chunk) <nl> +      (priv->n_keep + inf_text_chunk_get_length(chunk)) * sizeof(guint) <nl>      ); <nl>   <nl>      if(pos - buf_len < priv->n_keep)
@@ -1085,7 +1085,8 @@ int router_mio_callback(mio_t m, mio_action_t a, mio_fd_t fd, void *data, void * <nl>          case action_ACCEPT: <nl>              log_debug(ZONE, "accept action on fd %d", fd->fd); <nl>   <nl> -            getpeername(fd->fd, (struct sockaddr *) &sa, &namelen); <nl> +            if(getpeername(fd->fd, (struct sockaddr *) &sa, &namelen) < 0) <nl> +                return 1; <nl>              port = j_inet_getport(&sa); <nl>   <nl>              log_write(r->log, LOG_NOTICE, "[%s, port=%d] connect", (char *) data, port);
@@ -344,7 +344,8 @@ ImagingNewBlock(const char *mode, int xsize, int ysize) <nl>      if (im->linesize && <nl>          im->ysize > INT_MAX / im->linesize) { <nl>          /* punt if we're going to overflow */ <nl> -        return NULL; <nl> +        ImagingDelete(im); <nl> +        return (Imaging) ImagingError_MemoryError(); <nl>      } <nl>   <nl>      if (im->ysize * im->linesize <= 0) {
@@ -80,7 +80,7 @@ ImagingFind(const char* name) <nl>   <nl>  static int <nl>  PyImagingPhotoPut(ClientData clientdata, Tcl_Interp* interp, <nl> -               int argc, char **argv) <nl> +               int argc, const char **argv) <nl>  { <nl>      Imaging im; <nl>      Tk_PhotoHandle photo; <nl> @@ -172,7 +172,7 @@ PyImagingPhotoPut(ClientData clientdata, Tcl_Interp* interp, <nl>   <nl>  static int <nl>  PyImagingPhotoGet(ClientData clientdata, Tcl_Interp* interp, <nl> -               int argc, char **argv) <nl> +               int argc, const char **argv) <nl>  { <nl>      Tk_PhotoHandle photo; <nl>      Tk_PhotoImageBlock block;
@@ -738,6 +738,7 @@ idevice_error_t idevice_connection_enable_ssl(idevice_connection_t connection) <nl>  	return_me = SSL_do_handshake(ssl); <nl>  	if (return_me != 1) { <nl>  		debug_info("ERROR in SSL_do_handshake: %s", errorstring(SSL_get_error(ssl, return_me))); <nl> +		SSL_free(ssl); <nl>  		SSL_CTX_free(ssl_ctx); <nl>  	} else { <nl>  		ssl_data_t ssl_data_loc = (ssl_data_t)malloc(sizeof(struct ssl_data_private));
@@ -1195,6 +1195,7 @@ static int jpc_dec_process_siz(jpc_dec_t *dec, jpc_ms_t *ms) <nl>  	int htileno; <nl>  	int vtileno; <nl>  	jpc_dec_cmpt_t *cmpt; <nl> +	size_t size; <nl>   <nl>  	dec->xstart = siz->xoff; <nl>  	dec->ystart = siz->yoff; <nl> @@ -1231,7 +1232,10 @@ static int jpc_dec_process_siz(jpc_dec_t *dec, jpc_ms_t *ms) <nl>   <nl>  	dec->numhtiles = JPC_CEILDIV(dec->xend - dec->tilexoff, dec->tilewidth); <nl>  	dec->numvtiles = JPC_CEILDIV(dec->yend - dec->tileyoff, dec->tileheight); <nl> -	dec->numtiles = dec->numhtiles * dec->numvtiles; <nl> +	if (!jas_safe_size_mul(dec->numhtiles, dec->numvtiles, &size)) { <nl> +		return -1; <nl> +	} <nl> +	dec->numtiles = size; <nl>  	JAS_DBGLOG(10, ("numtiles = %d; numhtiles = %d; numvtiles = %d;\n", <nl>  	  dec->numtiles, dec->numhtiles, dec->numvtiles)); <nl>  	if (!(dec->tiles = jas_alloc2(dec->numtiles, sizeof(jpc_dec_tile_t)))) {
@@ -125,7 +125,10 @@ fortran_doc (FortranDataDef def) { <nl>      if (def.doc!=NULL) <nl>          size += strlen(def.doc); <nl>      p = (char*)malloc (size); <nl> -    if (p==NULL) goto fail; <nl> +    if (p==NULL) { <nl> +        /* No need to call free() because p is NULL */ <nl> +        return PyErr_NoMemory(); <nl> +    } <nl>      p[0] = '\0'; /* make sure that the buffer has zero length */ <nl>      if (def.rank==-1) { <nl>          if (def.doc==NULL) {
@@ -76,6 +76,11 @@ _error_handler(int method, PyObject *errobj, char *errtype, int retstatus, int * <nl>   <nl>      NPY_ALLOW_C_API_DEF <nl>   <nl> +    /* don't need C API for a simple ignore */ <nl> +    if (method == UFUNC_ERR_IGNORE) { <nl> +        return 0; <nl> +    } <nl> + <nl>      /* don't need C API for a simple print */ <nl>      if (method == UFUNC_ERR_PRINT) { <nl>          if (*first) {
@@ -2742,7 +2742,7 @@ PyUFunc_Accumulate(PyUFuncObject *self, PyArrayObject *arr, PyArrayObject *out, <nl>          while(loop->index < loop->size) { <nl>              if (loop->obj) <nl>                  Py_INCREF(*((PyObject **)loop->it->dataptr)); <nl> -            memcpy(loop->bufptr[0], loop->it->dataptr, <nl> +            memmove(loop->bufptr[0], loop->it->dataptr, <nl>                     loop->outsize); <nl>              PyArray_ITER_NEXT(loop->it); <nl>              loop->bufptr[0] += loop->outsize; <nl> @@ -2755,7 +2755,7 @@ PyUFunc_Accumulate(PyUFuncObject *self, PyArrayObject *arr, PyArrayObject *out, <nl>              /* Copy first element to output */ <nl>              if (loop->obj) <nl>                  Py_INCREF(*((PyObject **)loop->it->dataptr)); <nl> -            memcpy(loop->bufptr[0], loop->it->dataptr, <nl> +            memmove(loop->bufptr[0], loop->it->dataptr, <nl>                     loop->outsize); <nl>              /* Adjust input pointer */ <nl>              loop->bufptr[1] = loop->it->dataptr+loop->steps[1];
@@ -235,6 +235,12 @@ int createEKHandle(TSS2_SYS_CONTEXT *sapi_context) <nl>      LOG_INFO("EK create succ.. Handle: 0x%8.8x", handle2048ek); <nl>   <nl>      if (!ctx.non_persistent_read) { <nl> + <nl> +        if (!ctx.persistent_handle) { <nl> +            LOG_ERR("Persistent handle for EK was not provided"); <nl> +            return 1; <nl> +        } <nl> + <nl>           /* <nl>            * To make EK persistent, use own auth <nl>            */
@@ -44,6 +44,10 @@ <nl>   <nl>  static bool ITStatus_push_back(ARM_ITStatus *it, char v) <nl>  { <nl> +	if (it->size >= sizeof(it->ITStates)) { <nl> +		// TODO: consider warning user. <nl> +		it->size = 0; <nl> +	} <nl>  	it->ITStates[it->size] = v; <nl>  	it->size++; <nl>   <nl> @@ -751,8 +755,7 @@ static DecodeStatus _Thumb_getInstruction(cs_struct *ud, MCInst *MI, const uint8 <nl>  		// Nested IT blocks are UNPREDICTABLE.  Must be checked before we add <nl>  		// the Thumb predicate. <nl>  		if (MCInst_getOpcode(MI) == ARM_t2IT && ITStatus_instrInITBlock(&(ud->ITBlock))) <nl> -			result = MCDisassembler_SoftFail; <nl> - <nl> +			return MCDisassembler_SoftFail; <nl>  		Check(&result, AddThumbPredicate(ud, MI)); <nl>   <nl>  		// If we find an IT instruction, we need to parse its condition
@@ -75,9 +75,9 @@ static inline void drop_trailing_newlines(char *s) <nl>  static void dorealloc(char **mem, size_t oldlen, size_t newlen) <nl>  { <nl>  	int batches; <nl> -	if (newlen % BATCH_SIZE <= oldlen % BATCH_SIZE) <nl> +	if (newlen <= oldlen) <nl>  		return; <nl> -	batches = (newlen % BATCH_SIZE) + 1; <nl> +	batches = (newlen / BATCH_SIZE) + 1; <nl>  	if (!*mem) { <nl>  		do { <nl>  			*mem = malloc(batches * BATCH_SIZE);
@@ -228,6 +228,7 @@ static void BotImport_Trace(bsp_trace_t *bsptrace, vec3_t start, vec3_t mins, ve <nl>  	bsptrace->plane.type = trace.plane.type; <nl>  	bsptrace->surface.value = 0; <nl>  	bsptrace->surface.flags = trace.surfaceFlags; <nl> +	bsptrace->ent = trace.entityNum; <nl>  	bsptrace->exp_dist = 0; <nl>  	bsptrace->sidenum = 0; <nl>  	bsptrace->contents = 0;
@@ -173,6 +173,8 @@ struct http_packet_t *packet_new(struct http_message_t *parent_msg) <nl>   <nl>  void free_packet(struct http_packet_t *pkt) <nl>  { <nl> -	free(pkt->buffer); <nl> -	free(pkt); <nl> +    if (pkt) { <nl> +        free(pkt->buffer); <nl> +        free(pkt); <nl> +    } <nl>  }
@@ -1947,7 +1947,7 @@ YEBuiltin::toStream (std::ostream & str) const <nl>  std::ostream & <nl>  YEBuiltin::toXml( std::ostream & str, int indent ) const <nl>  { <nl> -    str << "<builtin name=\"" << m_decl->name << "\""; <nl> +    str << "<builtin name=\"" << StaticDeclaration::Decl2String(m_decl) << "\""; <nl>   <nl>      if (m_parameterblock != 0) <nl>      {
@@ -196,6 +196,9 @@ static char * ac_session_getline(FILE * f) <nl>  } <nl>   <nl>  /* <nl> + * MT-Unsafe: Caller must not permit multiple threads to call  <nl> + * the function with the same session object. <nl> + *  <nl>   * File format: <nl>   * Line 1: Working directory <nl>   * Line 2: BSSID <nl> @@ -381,6 +384,10 @@ struct session * ac_session_from_argv(const int argc, char ** argv, const char * <nl>      return ret; <nl>  } <nl>   <nl> +/*  <nl> + * MT-Unsafe: Caller must not permit multiple threads to call  <nl> + * the function with the same session object. <nl> + */ <nl>  int ac_session_save(struct session * s, long long int nb_keys_tried) <nl>  { <nl>      if (s == NULL || s->filename == NULL || s->working_dir == NULL
@@ -5398,6 +5398,8 @@ int tcp_test(const char* ip_str, const short port) <nl>          if( (unsigned)caplen == sizeof(nh)) <nl>          { <nl>              len = ntohl(nh.nh_len); <nl> +            if (len > 1024 || len < 0) <nl> +                continue; <nl>              if( nh.nh_type == 1 && i==0 ) <nl>              { <nl>                  i=1;
@@ -1369,9 +1369,13 @@ static int http_RecvPostMessage( <nl>  		if (Fp == NULL) <nl>  			return HTTP_INTERNAL_SERVER_ERROR; <nl>  	} else { <nl> +#ifdef UPNP_ENABLE_POST_WRITE <nl>  		Fp = fopen(filename, "wb"); <nl>  		if (Fp == NULL) <nl>  			return HTTP_UNAUTHORIZED; <nl> +#else <nl> +		return HTTP_NOT_FOUND; <nl> +#endif <nl>  	} <nl>  	parser->position = POS_ENTITY; <nl>  	do {
@@ -3616,7 +3616,7 @@ static int rgw_reshard_remove(cls_method_context_t hctx, bufferlist *in, bufferl <nl>   <nl>  const string resharding_attr = "resharding"; <nl>   <nl> -static int cls_rgw_set_bucket_resharding(cls_method_context_t hctx, bufferlist *in,  bufferlist *out) <nl> +static int rgw_set_bucket_resharding(cls_method_context_t hctx, bufferlist *in,  bufferlist *out) <nl>  { <nl>    cls_rgw_set_bucket_resharding_op op; <nl>   <nl> @@ -3645,7 +3645,7 @@ static int cls_rgw_set_bucket_resharding(cls_method_context_t hctx, bufferlist * <nl>    return 0; <nl>  } <nl>   <nl> -static int cls_rgw_clear_bucket_resharding(cls_method_context_t hctx, bufferlist *in,  bufferlist *out) <nl> +static int rgw_clear_bucket_resharding(cls_method_context_t hctx, bufferlist *in,  bufferlist *out) <nl>  { <nl>    cls_rgw_set_bucket_resharding_op op; <nl>   <nl> @@ -3674,7 +3674,6 @@ static int cls_rgw_clear_bucket_resharding(cls_method_context_t hctx, bufferlist <nl>    return 0; <nl>  } <nl>   <nl> - <nl>  CLS_INIT(rgw) <nl>  { <nl>    CLS_LOG(1, "Loaded rgw class!"); <nl> @@ -3776,6 +3775,10 @@ CLS_INIT(rgw) <nl>    cls_register_cxx_method(h_class, "reshard_get", CLS_METHOD_RD,rgw_reshard_get, &h_rgw_reshard_get); <nl>    cls_register_cxx_method(h_class, "reshard_get_head", CLS_METHOD_RD, rgw_reshard_get_head, &h_rgw_reshard_get_head); <nl>    cls_register_cxx_method(h_class, "reshard_remove", CLS_METHOD_RD | CLS_METHOD_WR, rgw_reshard_remove, &h_rgw_reshard_remove); <nl> +  cls_register_cxx_method(h_class, "set_bucket_resharding", CLS_METHOD_RD | CLS_METHOD_WR, <nl> +			  rgw_set_bucket_resharding, &h_rgw_set_bucket_resharding); <nl> +  cls_register_cxx_method(h_class, "clear_bucket_resharding", CLS_METHOD_RD | CLS_METHOD_WR, <nl> +			  rgw_clear_bucket_resharding, &h_rgw_clear_bucket_resharding); <nl>    return; <nl>  } <nl>  
@@ -3091,8 +3091,12 @@ int image_set(cls_method_context_t hctx, const string &image_id, <nl>      std::string global_id_key = global_key(mirror_image.global_image_id); <nl>      std::string image_id; <nl>      r = read_key(hctx, global_id_key, &image_id); <nl> -    if (r != -ENOENT) { <nl> +    if (r >= 0) { <nl>        return -EEXIST; <nl> +    } else if (r != -ENOENT) { <nl> +      CLS_ERR("error reading global image id: '%s': '%s'", image_id.c_str(), <nl> +              cpp_strerror(r).c_str()); <nl> +      return r; <nl>      } <nl>    } else if (r < 0) { <nl>      CLS_ERR("error reading mirrored image '%s': '%s'", image_id.c_str(),
@@ -596,6 +596,9 @@ public: <nl>    uint64_t get_required_features() const { <nl>      return required_features; <nl>    } <nl> +  mon_feature_t get_required_mon_features() const { <nl> +    return monmap->get_required_features(); <nl> +  } <nl>    void apply_quorum_to_compatset_features(); <nl>    void apply_compatset_features_to_quorum_requirements(); <nl>  
@@ -1952,10 +1952,6 @@ int RGW_Auth_S3::authorize(RGWRados *store, struct req_state *s) <nl>      return -EPERM; <nl>    } <nl>   <nl> -  // populate the owner info <nl> -  s->owner.set_id(s->user.user_id); <nl> -  s->owner.set_name(s->user.display_name); <nl> - <nl>    /* now verify signature */ <nl>      <nl>    string auth_hdr; <nl> @@ -2019,6 +2015,11 @@ int RGW_Auth_S3::authorize(RGWRados *store, struct req_state *s) <nl>      } <nl>    } <nl>   <nl> +  // populate the owner info <nl> +  s->owner.set_id(s->user.user_id); <nl> +  s->owner.set_name(s->user.display_name); <nl> + <nl> + <nl>    return  0; <nl>  } <nl>  
@@ -29,6 +29,7 @@ class SharedLRU { <nl>    Mutex lock; <nl>    size_t max_size; <nl>    Cond cond; <nl> +  unsigned size; <nl>   <nl>    map<K, typename list<pair<K, VPtr> >::iterator > contents; <nl>    list<pair<K, VPtr> > lru; <nl> @@ -36,7 +37,7 @@ class SharedLRU { <nl>    map<K, WeakVPtr> weak_refs; <nl>   <nl>    void trim_cache(list<VPtr> *to_release) { <nl> -    while (lru.size() > max_size) { <nl> +    while (size > max_size) { <nl>        to_release->push_back(lru.back().second); <nl>        lru_remove(lru.back().first); <nl>      } <nl> @@ -46,6 +47,7 @@ class SharedLRU { <nl>      if (!contents.count(key)) <nl>        return; <nl>      lru.erase(contents[key]); <nl> +    --size; <nl>      contents.erase(key); <nl>    } <nl>   <nl> @@ -53,6 +55,7 @@ class SharedLRU { <nl>      if (contents.count(key)) { <nl>        lru.splice(lru.begin(), lru, contents[key]); <nl>      } else { <nl> +      ++size; <nl>        lru.push_front(make_pair(key, val)); <nl>        contents[key] = lru.begin(); <nl>        trim_cache(to_release); <nl> @@ -77,7 +80,8 @@ class SharedLRU { <nl>    }; <nl>   <nl>  public: <nl> -  SharedLRU(size_t max_size = 20) : lock("SharedLRU::lock"), max_size(max_size) {} <nl> +  SharedLRU(size_t max_size = 20) <nl> +    : lock("SharedLRU::lock"), max_size(max_size), size(0) {} <nl>     <nl>    ~SharedLRU() { <nl>      contents.clear();
@@ -96,6 +96,7 @@ void handle_observe(MMonObserve *observe) <nl>    lock.Lock(); <nl>    registered.insert(observe->machine_id);   <nl>    lock.Unlock(); <nl> +  delete observe; <nl>  } <nl>   <nl>  void handle_notify(MMonObserveNotify *notify) <nl> @@ -223,6 +224,8 @@ void handle_notify(MMonObserveNotify *notify) <nl>    } <nl>   <nl>    map_ver[notify->machine_id] = notify->ver; <nl> + <nl> +  delete notify; <nl>  } <nl>   <nl>  static void send_observe_requests(); <nl> @@ -299,7 +302,7 @@ void handle_ack(MMonCommandAck *ack) <nl>      which++; <nl>      which = which % LAST; <nl>   <nl> -    if(ack->version > last_seen_version) <nl> +    if (ack->version > last_seen_version) <nl>        last_seen_version = ack->version; <nl>   <nl>      string w = ack->cmd[0]; <nl> @@ -336,6 +339,7 @@ void handle_ack(MMonCommandAck *ack) <nl>      } <nl>      lock.Unlock(); <nl>    } <nl> +  delete ack; <nl>  } <nl>   <nl>  void send_command()
@@ -1024,9 +1024,9 @@ int MemStore::_remove(coll_t cid, const ghobject_t& oid) <nl>    auto i = c->object_hash.find(oid); <nl>    if (i == c->object_hash.end()) <nl>      return -ENOENT; <nl> +  used_bytes -= i->second->get_size(); <nl>    c->object_hash.erase(i); <nl>    c->object_map.erase(oid); <nl> -  used_bytes -= i->second->get_size(); <nl>   <nl>    return 0; <nl>  }
@@ -483,6 +483,10 @@ void MgrMonitor::drop_active() <nl>    pending_map.active_gid = 0; <nl>    pending_map.available = false; <nl>    pending_map.active_addr = entity_addr_t(); <nl> + <nl> +  // So that when new active mgr subscribes to mgrdigest, it will <nl> +  // get an immediate response instead of waiting for next timer <nl> +  cancel_timer(); <nl>  } <nl>   <nl>  void MgrMonitor::drop_standby(uint64_t gid)
@@ -368,7 +368,7 @@ static char *parse_options(const char *data, int *filesys_flags) <nl>  		} <nl>  		serial = add_key("ceph", name, payload, sizeof(payload), KEY_SPEC_USER_KEYRING); <nl>  		if (serial < 0) { <nl> -			if (errno == ENODEV) { <nl> +			if (errno == ENODEV || errno == ENOSYS) { <nl>  				/* running against older kernel; fall back to secret= in options */ <nl>  				if (pos) <nl>  					pos = safe_cat(&out, &out_len, pos, ",");
@@ -4644,7 +4644,7 @@ void PG::start_peering_interval( <nl>      state_clear(PG_STATE_REMAPPED); <nl>   <nl>    int role = osdmap->calc_pg_role(osd->whoami, acting, acting.size()); <nl> -  if (role == pg_whoami.shard) <nl> +  if (pool.info.is_replicated() || role == pg_whoami.shard) <nl>      set_role(role); <nl>    else <nl>      set_role(-1);
@@ -2695,7 +2695,15 @@ const std::vector<Option> ceph_options = { <nl>    .set_description(""), <nl>   <nl>    Option("osd_recovery_sleep", Option::TYPE_FLOAT, Option::LEVEL_ADVANCED) <nl> -  .set_default(0.01) <nl> +  .set_default(0)                                                               <nl> +  .set_description(""),                                                         <nl> +                                                                                <nl> +  Option("osd_recovery_sleep_hdd", Option::TYPE_FLOAT, Option::LEVEL_ADVANCED)  <nl> +  .set_default(0.1)                                                             <nl> +  .set_description(""),                                                         <nl> +                                                                                <nl> +  Option("osd_recovery_sleep_ssd", Option::TYPE_FLOAT, Option::LEVEL_ADVANCED)  <nl> +  .set_default(0)    <nl>    .set_description(""), <nl>   <nl>    Option("osd_snap_trim_sleep", Option::TYPE_FLOAT, Option::LEVEL_ADVANCED)
@@ -255,6 +255,7 @@ public: <nl>      on_readable(0), on_write_error(NULL), <nl>      expire_pos(0), trimming_pos(0), trimmed_pos(0)  <nl>    { <nl> +    memset(&layout, 0, sizeof(layout)); <nl>    } <nl>   <nl>    void reset() {
@@ -2345,6 +2345,10 @@ const std::vector<Option> ceph_options = { <nl>    .set_default(true) <nl>    .set_description(""), <nl>   <nl> +  Option("osd_class_update_on_start", Option::TYPE_BOOL, Option::LEVEL_ADVANCED) <nl> +  .set_default(true) <nl> +  .set_description(""), <nl> + <nl>    Option("osd_crush_initial_weight", Option::TYPE_FLOAT, Option::LEVEL_ADVANCED) <nl>    .set_default(-1) <nl>    .set_description(""),
@@ -594,8 +594,8 @@ void RGWZoneParams::decode_json(JSONObj *obj) <nl>    ::decode_json("usage_log_pool", usage_log_pool, obj); <nl>    ::decode_json("user_keys_pool", user_keys_pool, obj); <nl>    ::decode_json("user_email_pool", user_email_pool, obj); <nl> +  ::decode_json("user_uid_pool", user_uid_pool, obj); <nl>    ::decode_json("user_swift_pool", user_swift_pool, obj); <nl> -  ::decode_json("user_uid_pool ", user_uid_pool, obj); <nl>    JSONDecoder::decode_json("system_key", system_key, obj); <nl>    JSONDecoder::decode_json("placement_pools", placement_pools, obj); <nl>  }
@@ -75,12 +75,8 @@ CephContext *common_preinit(const CephInitParameters &iparams, <nl>   <nl>    if ((flags & CINIT_FLAG_UNPRIVILEGED_DAEMON_DEFAULTS) || <nl>        code_env != CODE_ENVIRONMENT_DAEMON) { <nl> -    // no default log, pid_file, admin_socket <nl> -    conf->set_val_or_die("pid_file", ""); <nl> -    conf->set_val_or_die("admin_socket", ""); <nl> -    conf->set_val_or_die("log_file", ""); <nl> -    // use less memory for logs <nl> -    conf->set_val_or_die("log_max_recent", "500"); <nl> +    // do nothing special!  we used to do no default log, pid_file, <nl> +    // admin_socket, but changed our minds. <nl>    } <nl>   <nl>    return cct;
@@ -1939,6 +1939,10 @@ bool Client::ms_dispatch(Message *m) <nl>      handle_client_session(static_cast<MClientSession*>(m)); <nl>      break; <nl>   <nl> +  case CEPH_MSG_OSD_MAP: <nl> +    m->put(); <nl> +    break; <nl> + <nl>      // requests <nl>    case CEPH_MSG_CLIENT_REQUEST_FORWARD: <nl>      handle_client_request_forward(static_cast<MClientRequestForward*>(m));
@@ -4893,11 +4893,11 @@ void OSD::start_recovery_op(PG *pg, const hobject_t& soid) <nl>   <nl>  void OSD::finish_recovery_op(PG *pg, const hobject_t& soid, bool dequeue) <nl>  { <nl> +  recovery_wq.lock(); <nl>    dout(10) << "finish_recovery_op " << *pg << " " << soid <nl>  	   << " dequeue=" << dequeue <nl>  	   << " (" << recovery_ops_active << "/" << g_conf->osd_recovery_max_active << " rops)" <nl>  	   << dendl; <nl> -  recovery_wq.lock(); <nl>   <nl>    // adjust count <nl>    recovery_ops_active--;
@@ -3222,7 +3222,10 @@ void OSD::load_pgs() <nl>        up_primary, <nl>        primary); <nl>      int role = OSDMap::calc_pg_role(whoami, pg->acting); <nl> -    pg->set_role(role); <nl> +    if (pg->pool.info.is_replicated() || role == pg->pg_whoami.shard) <nl> +      pg->set_role(role); <nl> +    else <nl> +      pg->set_role(-1); <nl>   <nl>      pg->reg_next_scrub(); <nl>  
@@ -758,7 +758,7 @@ Dentry *Client::insert_dentry_inode(Dir *dir, const string& dname, LeaseStat *dl <nl>     <nl>    if (!dn || dn->inode == 0) { <nl>      in->get(); <nl> -    if (old_dentry) <nl> +    if (old_dentry && old_dentry->dir) <nl>        unlink(old_dentry, dir == old_dentry->dir);  // keep dir open if its the same dir <nl>      dn = link(dir, dname, in, dn); <nl>      put_inode(in);
@@ -107,6 +107,7 @@ OutputDataSocket::OutputDataSocket(CephContext *cct, uint64_t _backlog) <nl>      m_shutdown_rd_fd(-1), <nl>      m_shutdown_wr_fd(-1), <nl>      going_down(false), <nl> +    data_size(0), <nl>      m_lock("OutputDataSocket::m_lock") <nl>  { <nl>  }
@@ -4964,9 +4964,9 @@ void OSD::requeue_failures() <nl>    unsigned old_pending = failure_pending.size(); <nl>    for (map<int,pair<utime_t,entity_inst_t> >::iterator p = <nl>  	 failure_pending.begin(); <nl> -       p != failure_pending.end(); <nl> -       ++p) { <nl> +       p != failure_pending.end(); ) { <nl>      failure_queue[p->first] = p->second.first; <nl> +    failure_pending.erase(p++); <nl>    } <nl>    dout(10) << __func__ << " " << old_queue << " + " << old_pending << " -> " <nl>  	   << failure_queue.size() << dendl;
@@ -38,7 +38,10 @@ class MHeartbeat : public Message { <nl>      this->load = load; <nl>      this->beat = beat; <nl>    } <nl> +private: <nl> +  ~MHeartbeat() {} <nl>   <nl> +public: <nl>    const char *get_type_name() { return "HB"; } <nl>   <nl>    void encode_payload() {
@@ -2011,7 +2011,6 @@ void PGMap::dump_filtered_pg_stats(ostream& ss, set<pg_t>& pgs) const <nl>    tab.define_column("UNFOUND", TextTable::LEFT, TextTable::RIGHT); <nl>    tab.define_column("BYTES", TextTable::LEFT, TextTable::RIGHT); <nl>    tab.define_column("LOG", TextTable::LEFT, TextTable::RIGHT); <nl> -  tab.define_column("DISK_LOG", TextTable::LEFT, TextTable::RIGHT); <nl>    tab.define_column("STATE", TextTable::LEFT, TextTable::RIGHT); <nl>    tab.define_column("STATE_STAMP", TextTable::LEFT, TextTable::RIGHT); <nl>    tab.define_column("VERSION", TextTable::LEFT, TextTable::RIGHT); <nl> @@ -2039,7 +2038,6 @@ void PGMap::dump_filtered_pg_stats(ostream& ss, set<pg_t>& pgs) const <nl>          << st.stats.sum.num_objects_unfound <nl>          << st.stats.sum.num_bytes <nl>          << st.log_size <nl> -        << st.ondisk_log_size <nl>          << pg_state_string(st.state) <nl>          << st.last_change <nl>          << st.version
@@ -54,6 +54,7 @@ const char *ceph_osd_flag_name(unsigned flag) <nl>    case CEPH_OSD_FLAG_KNOWN_REDIR: return "known_if_redirected"; <nl>    case CEPH_OSD_FLAG_FULL_TRY: return "full_try"; <nl>    case CEPH_OSD_FLAG_FULL_FORCE: return "full_force"; <nl> +  case CEPH_OSD_FLAG_IGNORE_REDIRECT: return "ignore_redirect"; <nl>    default: return "???"; <nl>    } <nl>  }
@@ -503,6 +503,11 @@ bool RGWOp::generate_cors_headers(string& origin, string& method, string& header <nl>      dout(2) << "No CORS configuration set yet for this bucket" << dendl; <nl>      return false; <nl>    } <nl> + <nl> +  RGWCORSRule *rule = bucket_cors.host_name_rule(orig); <nl> +  if (!rule) <nl> +    return false; <nl> + <nl>    const char *req_meth = s->info.env->get("HTTP_ACCESS_CONTROL_REQUEST_METHOD"); <nl>    if (!req_meth) { <nl>      req_meth = s->info.method; <nl> @@ -511,7 +516,6 @@ bool RGWOp::generate_cors_headers(string& origin, string& method, string& header <nl>    if (req_meth) <nl>      method = req_meth; <nl>   <nl> -  RGWCORSRule *rule = bucket_cors.host_name_rule(orig); <nl>    if (!validate_cors_rule_method(rule, req_meth)) { <nl>      return false; <nl>    }
@@ -343,6 +343,7 @@ void OSDMonitor::update_from_paxos(bool *need_bootstrap) <nl>      get_version_full(latest_full, latest_bl); <nl>      assert(latest_bl.length() != 0); <nl>      dout(7) << __func__ << " loading latest full map e" << latest_full << dendl; <nl> +    osdmap = OSDMap(); <nl>      osdmap.decode(latest_bl); <nl>    } <nl>  
@@ -43,7 +43,6 @@ void BackTrace::print(std::ostream& out) <nl>  	function[sz-1] = 0; <nl>        } <nl>        out << " " << (i-skip+1) << ": (" << function << end << std::endl; <nl> -      free(foo); <nl>        //fprintf(out, "    %s:%s\n", stack.strings[i], function); <nl>      } else { <nl>        // didn't find the mangled name, just print the whole line
@@ -40,8 +40,9 @@ static int run_command(const char *command) <nl>   <nl>  	if (status < 0) { <nl>  		char error_buf[80]; <nl> +		strerror_r(errno, error_buf, sizeof(error_buf)); <nl>  		fprintf(stderr, "couldn't run '%s': %s\n", command, <nl> -			strerror_r(errno, error_buf, sizeof(error_buf))); <nl> +			error_buf); <nl>  	} else if (WIFSIGNALED(status)) { <nl>  		fprintf(stderr, "'%s' killed by signal %d\n", command, <nl>  			WTERMSIG(status));
@@ -147,7 +147,9 @@ class FileLock : public SimpleLock { <nl>    } <nl>    bool can_rdlock_soon() { <nl>      if (parent->is_auth()) <nl> -      return (state == LOCK_GLOCKL); <nl> +      return <nl> +	(state == LOCK_GLOCKL) || <nl> +	(state == LOCK_LOCK && xlock_by); <nl>      else <nl>        return false; <nl>    }
@@ -1900,7 +1900,7 @@ void OSD::dump_ops_in_flight(ostream& ss) <nl>      m->print(name); <nl>      jf.open_object_section("op"); <nl>      jf.dump_string("description", name.str().c_str()); // this OpRequest <nl> -    jf.dump_float("received_at", (*p)->received_time); <nl> +    jf.dump_stream("received_at") << (*p)->received_time; <nl>      jf.dump_float("age", now - (*p)->received_time); <nl>      jf.dump_string("flag_point", (*p)->state_string()); <nl>      if (m->get_orig_source().is_client()) {
@@ -12377,6 +12377,9 @@ int RGWRados::bi_list(rgw_bucket& bucket, const string& obj_name, const string& <nl>    } <nl>   <nl>    ret = cls_rgw_bi_list(bs.index_ctx, bs.bucket_obj, obj_name, marker, max, entries, is_truncated); <nl> +  if (ret == -ENOENT) { <nl> +    *is_truncated = false; <nl> +  } <nl>    if (ret < 0) <nl>      return ret; <nl>  
@@ -2356,6 +2356,11 @@ void FileStore::_set_replay_guard(int fd, const SequencerPosition& spos) <nl>    // first make sure the previous operation commits <nl>    ::fsync(fd); <nl>   <nl> +  // sync object_map too.  even if this object has a header or keys, <nl> +  // it have had them in the past and then removed them, so always <nl> +  // sync. <nl> +  object_map->sync(); <nl> + <nl>    // then record that we did it <nl>    bufferlist v(40); <nl>    ::encode(spos, v);
@@ -549,7 +549,7 @@ int crush_bucket_add_item(struct crush_bucket *b, int item, int weight) <nl>   <nl>  int crush_remove_uniform_bucket_item(struct crush_bucket_uniform *bucket, int item) <nl>  { <nl> -	int i, j; <nl> +	unsigned i, j; <nl>  	int newsize; <nl>  	 <nl>  	for (i = 0; i < bucket->h.size; i++) <nl> @@ -570,7 +570,7 @@ int crush_remove_uniform_bucket_item(struct crush_bucket_uniform *bucket, int it <nl>   <nl>  int crush_remove_list_bucket_item(struct crush_bucket_list *bucket, int item) <nl>  { <nl> -	int i, j; <nl> +	unsigned i, j; <nl>  	int newsize; <nl>  	int weight; <nl>   <nl> @@ -598,8 +598,8 @@ int crush_remove_list_bucket_item(struct crush_bucket_list *bucket, int item) <nl>   <nl>  int crush_remove_tree_bucket_item(struct crush_bucket_tree *bucket, int item) <nl>  { <nl> -	int i; <nl> -	int newsize; <nl> +	unsigned i; <nl> +	unsigned newsize; <nl>   <nl>  	for (i = 0; i < bucket->h.size; i++) { <nl>  		int node; <nl> @@ -655,7 +655,7 @@ int crush_remove_tree_bucket_item(struct crush_bucket_tree *bucket, int item) <nl>  int crush_remove_straw_bucket_item(struct crush_bucket_straw *bucket, int item) <nl>  { <nl>  	int newsize = bucket->h.size - 1; <nl> -	int i, j; <nl> +	unsigned i, j; <nl>   <nl>  	for (i = 0; i < bucket->h.size; i++) { <nl>  		if (bucket->h.items[i] == item) {
@@ -231,7 +231,7 @@ struct pg_t { <nl>    int32_t m_preferred; <nl>   <nl>    pg_t() : m_pool(0), m_seed(0), m_preferred(-1) {} <nl> -  pg_t(ps_t seed, uint64_t pool, int pref) { <nl> +  pg_t(ps_t seed, uint64_t pool, int pref=-1) { <nl>      m_seed = seed; <nl>      m_pool = pool; <nl>      m_preferred = pref;
@@ -4436,6 +4436,10 @@ void OSD::build_initial_pg_history( <nl>        h->last_epoch_split = e; <nl>      } <nl>      lastmap = osdmap; <nl> +    up_primary = new_up_primary; <nl> +    acting_primary = new_acting_primary; <nl> +    up = new_up; <nl> +    acting = new_acting; <nl>    } <nl>    dout(20) << __func__ << " " << debug.str() << dendl; <nl>    dout(10) << __func__ << " " << *h << " " << *pi
@@ -601,7 +601,13 @@ static int process_request(RGWRados *store, RGWREST *rest, RGWRequest *req, RGWC <nl>      goto done; <nl>    } <nl>   <nl> -  if (op->supports_website()) { <nl> +  /** <nl> +   * Only some accesses support website mode, and website mode does NOT apply <nl> +   * if you are using the REST endpoint either (ergo, no authenticated access) <nl> +   */ <nl> +  dout(20) << "retarget uid=" << s->user.user_id << dendl; <nl> +  if (op->supports_website() && !rgw_user_is_authenticated(s->user)) { <nl> +  //if (op->supports_website()) { <nl>      req->log(s, "recalculating target"); <nl>      ret = handler->retarget(op, &op); <nl>      if (ret < 0) {
@@ -6844,6 +6844,10 @@ int OSDMonitor::prepare_command_pool_set(const cmdmap_t& cmdmap, <nl>           << " (you may adjust 'mon max pool pg num' for higher values)"; <nl>        return -ERANGE; <nl>      } <nl> +    if (p.has_flag(pg_pool_t::FLAG_CREATING)) { <nl> +      ss << "cannot adjust pg_num while initial PGs are being created"; <nl> +      return -EBUSY; <nl> +    } <nl>      if (n > (int)p.get_pg_num()) { <nl>        p.set_pg_num(n); <nl>      } else {
@@ -3837,6 +3837,10 @@ int ReplicatedPG::do_osd_ops(OpContext *ctx, vector<OSDOp>& ops) <nl>      case CEPH_OSD_OP_WATCH: <nl>        ++ctx->num_write; <nl>        { <nl> +	if (!obs.exists) { <nl> +	  result = -ENOENT; <nl> +	  break; <nl> +	} <nl>          uint64_t cookie = op.watch.cookie; <nl>  	bool do_watch = op.watch.flag & 1; <nl>          entity_name_t entity = ctx->reqid.name;
@@ -1483,6 +1483,9 @@ extern "C" int rados_pool_list(rados_t cluster, char *buf, size_t len) <nl>    std::list<std::string> pools; <nl>    client->pool_list(pools); <nl>   <nl> +  if (!buf) <nl> +    return -EINVAL; <nl> + <nl>    char *b = buf; <nl>    if (b) <nl>      memset(b, 0, len);
@@ -599,10 +599,13 @@ int SyntheticClient::run() <nl>          int iarg1 = iargs.front();  iargs.pop_front(); <nl>          string prefix = get_sarg(0); <nl>   <nl> +	char realtfile[100]; <nl> +	sprintf(realtfile, tfile.c_str(), client->get_nodeid()); <nl> + <nl>          if (run_me()) { <nl>            dout(2) << "trace " << tfile << " prefix " << prefix << " ... " << iarg1 << " times" << dendl; <nl>             <nl> -          Trace t(tfile.c_str()); <nl> +          Trace t(realtfile); <nl>             <nl>            client->mkdir(prefix.c_str(), 0755); <nl>            
@@ -1,5 +1,5 @@ <nl>  // JPEGsnoop - JPEG Image Decoder & Analysis Utility <nl> -// Copyright (C) 2015 - Calvin Hass <nl> +// Copyright (C) 2017 - Calvin Hass <nl>  // http://www.impulseadventure.com/photo/jpeg-snoop.html <nl>  // <nl>  //    This program is free software: you can redistribute it and/or modify <nl> @@ -4903,8 +4903,8 @@ unsigned CjfifDecode::DecodeMarker() <nl>  			// possibility of div by 0). <nl>  			m_anSofHorzSampFact_Hi[nCompIdent] = (anSofSampFact[nCompIdent] & 0xF0) >> 4;	// Hi, range 1..4 <nl>  			m_anSofVertSampFact_Vi[nCompIdent] = (anSofSampFact[nCompIdent] & 0x0F);		// Vi, range 1..4 <nl> -			//if (!ValidateValue(m_anSofHorzSampFact_Hi[nCompIdent],1,4,_T("Horizontal Sampling Factor <Hi>"),true,1)) return DECMARK_ERR; <nl> -			//if (!ValidateValue(m_anSofVertSampFact_Vi[nCompIdent],1,4,_T("Vertical Sampling Factor <Vi>"),true,1)) return DECMARK_ERR; <nl> +			if (!ValidateValue(m_anSofHorzSampFact_Hi[nCompIdent],1,4,_T("Horizontal Sampling Factor <Hi>"),true,1)) return DECMARK_ERR; <nl> +			if (!ValidateValue(m_anSofVertSampFact_Vi[nCompIdent],1,4,_T("Vertical Sampling Factor <Vi>"),true,1)) return DECMARK_ERR; <nl>   <nl>  		} <nl>  
@@ -213,7 +213,7 @@ void SaveVCalendar(TNEFStruct TNEF, int isMtgReq) { <nl>    if(isMtgReq) { <nl>      CreateUniqueFilename(ifilename, MAX_FILENAME_SIZE, "MtgReq", "ics", filepath); <nl>    } else { <nl> -    CreateUniqueFilename(ifilename, MAX_FILENAME_SIZE, "calendar", "vcf", filepath); <nl> +    CreateUniqueFilename(ifilename, MAX_FILENAME_SIZE, "calendar", "ics", filepath); <nl>    } <nl>   <nl>    printf("%s\n", ifilename);
@@ -328,7 +328,11 @@ static FORCEINLINE NEDMALLOCNOALIASATTR NEDMALLOCPTRATTR void *CallMalloc(void * <nl>  #if USE_MAGIC_HEADERS <nl>  	size_t _alignment=alignment; <nl>  	size_t *_ret=0; <nl> -	size+=alignment+3*sizeof(size_t); <nl> +	size_t bytes=size+alignment+3*sizeof(size_t); <nl> +	/* Avoid addition overflow. */ <nl> +	if(bytes<size) <nl> +		return 0; <nl> +	size=bytes; <nl>  	_alignment=0; <nl>  #endif <nl>  #if USE_ALLOCATOR==0
@@ -77,7 +77,7 @@ int der_decode_raw_bit_string(const unsigned char *in,  unsigned long inlen, <nl>     blen = ((dlen - 1) << 3) - (in[x++] & 7); <nl>   <nl>     /* too many bits? */ <nl> -   if (blen > *outlen) { <nl> +   if (blen/8 > *outlen) { <nl>        *outlen = blen; <nl>        return CRYPT_BUFFER_OVERFLOW; <nl>     }
@@ -3154,6 +3154,8 @@ forward_search_range(regex_t* reg, const UChar* str, const UChar* end, UChar* s, <nl>      } <nl>      else { <nl>        UChar *q = p + reg->dmin; <nl> + <nl> +      if (q >= end) return 0; /* fail */ <nl>        while (p < q) p += enclen(reg->enc, p); <nl>      } <nl>    }
@@ -1473,14 +1473,9 @@ match_at(regex_t* reg, const UChar* str, const UChar* end, <nl>        break; <nl>   <nl>      case OP_EXACT1:  MOP_IN(OP_EXACT1); <nl> -#if 0 <nl>        DATA_ENSURE(1); <nl>        if (*p != *s) goto fail; <nl>        p++; s++; <nl> -#endif <nl> -      if (*p != *s++) goto fail; <nl> -      DATA_ENSURE(0); <nl> -      p++; <nl>        MOP_OUT; <nl>        break; <nl>  
@@ -2850,7 +2850,7 @@ unicode_unfold_key(OnigCodePoint code) <nl>          { <nl>            OnigCodePoint gcode = wordlist[key].code; <nl>   <nl> -          if (code == gcode) <nl> +          if (code == gcode && wordlist[key].index >= 0) <nl>              return &wordlist[key]; <nl>          } <nl>      }
@@ -404,12 +404,14 @@ EbmlElement * EbmlElement::FindNextElement(IOCallback & DataStream, const EbmlSe <nl>          memmove(&PossibleIdNSize[0],&PossibleIdNSize[1], --ReadIndex); <nl>        } <nl>   <nl> +      if (MaxDataSize <= ReadSize) <nl> +        break; <nl>        if (DataStream.read(&PossibleIdNSize[ReadIndex++], 1) == 0) { <nl>          return NULL; // no more data ? <nl>        } <nl>        ReadSize++; <nl>   <nl> -    } while (!bFound && MaxDataSize > ReadSize); <nl> +    } while (!bFound); <nl>   <nl>      if (!bFound) <nl>        // we reached the maximum we could read without a proper ID <nl> @@ -432,6 +434,10 @@ EbmlElement * EbmlElement::FindNextElement(IOCallback & DataStream, const EbmlSe <nl>          bFound = false; <nl>          break; <nl>        } <nl> +      if (MaxDataSize <= ReadSize) { <nl> +        bFound = false; <nl> +        break; <nl> +      } <nl>        if( DataStream.read( &PossibleIdNSize[SizeIdx++], 1 ) == 0 ) { <nl>          return NULL; // no more data ? <nl>        }
@@ -150,6 +150,11 @@ uint64 ReadCodedSizeValue(const binary * InBuffer, uint32 & BufferSize, uint64 & <nl>        // ID found <nl>        PossibleSizeLength = SizeIdx + 1; <nl>        SizeBitMask >>= SizeIdx; <nl> + <nl> +      // Guard against invalid memory accesses with incomplete IDs. <nl> +      if (PossibleSizeLength > BufferSize) <nl> +        break; <nl> + <nl>        for (SizeIdx = 0; SizeIdx < PossibleSizeLength; SizeIdx++) { <nl>          PossibleSize[SizeIdx] = InBuffer[SizeIdx]; <nl>        }
@@ -1080,6 +1080,8 @@ l_uint32  *line; <nl>          pos = (qpos + i) % 8; <nl>          npx = px + xpostab[pos]; <nl>          npy = py + ypostab[pos]; <nl> +        if (npx < 0 || npx >= w || npy < 0 || npy >= h) <nl> +            continue; <nl>          line = data + npy * wpl; <nl>          val = GET_DATA_BIT(line, npx); <nl>          if (val) {
@@ -1069,7 +1069,7 @@ int main(int argc, char **argv) { <nl>  				return 1; <nl>  			} <nl>   <nl> -			if (sscanf(argv[i] + 6, "%d", &br->mtu) != 1 || br->mtu < 68 || br->mtu > 9198) { <nl> +			if (sscanf(argv[i] + 6, "%d", &br->mtu) != 1 || br->mtu < 576 || br->mtu > 9198) { <nl>  				fprintf(stderr, "Error: invalid mtu value\n"); <nl>  				return 1; <nl>  			}
@@ -965,6 +965,8 @@ rsvg_characters_impl (RsvgHandle * ctx, const xmlChar * ch, int len) <nl>   <nl>      if (ctx->priv->currentnode) <nl>          rsvg_node_add_child (ctx->priv->currentnode, node); <nl> + <nl> +    node = rsvg_node_unref (node); <nl>  } <nl>   <nl>  static void
@@ -28,7 +28,7 @@ typedef int int32_t; <nl>   <nl>  #endif /* HAVE_CONFIG_H */ <nl>   <nl> -int utf8_encode(int codepoint, char *buffer, size_t *size); <nl> +int utf8_encode(int32_t codepoint, char *buffer, size_t *size); <nl>   <nl>  size_t utf8_check_first(char byte); <nl>  size_t utf8_check_full(const char *buffer, size_t size, int32_t *codepoint);
@@ -763,9 +763,10 @@ int flush; <nl>                  copy = state->length; <nl>                  if (copy > have) copy = have; <nl>                  if (copy) { <nl> +                    len = state->head->extra_len - state->length; <nl>                      if (state->head != Z_NULL && <nl> -                        state->head->extra != Z_NULL) { <nl> -                        len = state->head->extra_len - state->length; <nl> +                        state->head->extra != Z_NULL && <nl> +                        len < state->head->extra_max) { <nl>                          zmemcpy(state->head->extra + len, next, <nl>                                  len + copy > state->head->extra_max ? <nl>                                  state->head->extra_max - len : copy);
@@ -7762,6 +7762,13 @@ Perl_re_op_compile(pTHX_ SV ** const patternp, int pat_count, <nl>   <nl>          /* We have that number in RExC_npar */ <nl>          RExC_total_parens = RExC_npar; <nl> + <nl> +        /* XXX For backporting, use long jumps if there is any possibility of <nl> +         * overflow */ <nl> +        if (RExC_size > U16_MAX && ! RExC_use_BRANCHJ) { <nl> +            RExC_use_BRANCHJ = TRUE; <nl> +            flags |= RESTART_PARSE; <nl> +        } <nl>      } <nl>      else if (! MUST_RESTART(flags)) { <nl>  	ReREFCNT_dec(Rx);
@@ -5489,6 +5489,12 @@ S_study_chunk(pTHX_ RExC_state_t *pRExC_state, regnode **scanp, <nl>  				  RExC_precomp))); <nl>                  } <nl>   <nl> +                if ( ( minnext > 0 && mincount >= SSize_t_MAX / minnext ) <nl> +                    || min >= SSize_t_MAX - minnext * mincount ) <nl> +                { <nl> +                    FAIL("Regexp out of space"); <nl> +                } <nl> + <nl>  		min += minnext * mincount; <nl>  		is_inf_internal |= deltanext == SSize_t_MAX <nl>                           || (maxcount == REG_INFTY && minnext + deltanext > 0);
@@ -1798,7 +1798,7 @@ static Image *ReadTIFFImage(const ImageInfo *image_info, <nl>          /* <nl>            Convert stripped TIFF image. <nl>          */ <nl> -        extent=4*(samples_per_pixel+1)*TIFFStripSize(tiff); <nl> +        extent=4*((image->depth+7)/8)*(samples_per_pixel+1)*TIFFStripSize(tiff); <nl>          strip_pixels=(unsigned char *) AcquireQuantumMemory(extent, <nl>            sizeof(*strip_pixels)); <nl>          if (strip_pixels == (unsigned char *) NULL)
@@ -1811,8 +1811,8 @@ static Image *ReadTIFFImage(const ImageInfo *image_info, <nl>          /* <nl>            Convert stripped TIFF image. <nl>          */ <nl> -        extent=4*MagickMax(image->columns*(samples_per_pixel+extra_samples)* <nl> -          (image->depth+7)/8,TIFFStripSize(tiff)); <nl> +        extent=MagickMax(sizeof(uint32),(samples_per_pixel+extra_samples)* <nl> +          (image->depth+7)/8)*image->columns*rows_per_strip; <nl>          strip_pixels=(unsigned char *) AcquireQuantumMemory(extent, <nl>            sizeof(*strip_pixels)); <nl>          if (strip_pixels == (unsigned char *) NULL)
@@ -482,6 +482,8 @@ formUpdateBuffer(Anchor *a, Buffer *buf, FormItemList *form) <nl>  	rows = form->rows ? form->rows : 1; <nl>  	col = COLPOS(l, a->start.pos); <nl>  	for (c_rows = 0; c_rows < rows; c_rows++, l = l->next) { <nl> +	    if (l == NULL) <nl> +		break; <nl>  	    if (rows > 1) { <nl>  		pos = columnPos(l, col); <nl>  		a = retrieveAnchor(buf->formitem, l->linenumber, pos);
@@ -1023,6 +1023,7 @@ static void ctrycatchfinally(JF, js_Ast *trystm, js_Ast *catchvar, js_Ast *catch <nl>  		emitstring(J, F, OP_CATCH, catchvar->string); <nl>  		cstm(J, F, catchstm); <nl>  		emit(J, F, OP_ENDCATCH); <nl> +		emit(J, F, OP_ENDTRY); <nl>  		L3 = emitjump(J, F, OP_JUMP); /* skip past the try block to the finally block */ <nl>  	} <nl>  	label(J, F, L1);
@@ -254,7 +254,7 @@ static void cleanup_shm_refs(const uint64_t *saved_attr, <nl>  { <nl>  	size_t n; <nl>   <nl> -	for (n = 0; n < num_params; n++) { <nl> +	for (n = 0; n < MIN((unsigned int)TEE_NUM_PARAMS, num_params); n++) { <nl>  		switch (saved_attr[n]) { <nl>  		case OPTEE_MSG_ATTR_TYPE_TMEM_INPUT: <nl>  		case OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT:
@@ -1392,14 +1392,9 @@ class StackLimitCheck BASE_EMBEDDED { <nl>   public: <nl>    explicit StackLimitCheck(Isolate* isolate) : isolate_(isolate) { } <nl>   <nl> -  bool HasOverflowed() const { <nl> +  inline bool HasOverflowed() const { <nl>      StackGuard* stack_guard = isolate_->stack_guard(); <nl> -    // Stack has overflowed in C++ code only if stack pointer exceeds the C++ <nl> -    // stack guard and the limits are not set to interrupt values. <nl> -    // TODO(214): Stack overflows are ignored if a interrupt is pending. This <nl> -    // code should probably always use the initial C++ limit. <nl> -    return (reinterpret_cast<uintptr_t>(this) < stack_guard->climit()) && <nl> -           stack_guard->IsStackOverflow(); <nl> +    return reinterpret_cast<uintptr_t>(this) < stack_guard->real_climit(); <nl>    } <nl>   private: <nl>    Isolate* isolate_;
@@ -30,6 +30,7 @@ <nl>   <nl>  @property (nonatomic, retain) CDVInAppBrowserViewController* inAppBrowserViewController; <nl>  @property (nonatomic, copy) NSString* callbackId; <nl> +@property (nonatomic, copy) NSRegularExpression *callbackIdPattern; <nl>   <nl>  - (void)open:(CDVInvokedUrlCommand*)command; <nl>  - (void)close:(CDVInvokedUrlCommand*)command;
@@ -10772,7 +10772,7 @@ namespace http { <nl>  				return; <nl>  			} <nl>  			std::vector<std::vector<std::string> > result; <nl> -			result = m_sql.safe_queryBlob("SELECT Image FROM Floorplans WHERE ID=%s", idx.c_str()); <nl> +			result = m_sql.safe_queryBlob("SELECT Image FROM Floorplans WHERE ID=%d", atol(idx.c_str())); <nl>  			if (result.empty()) <nl>  				return; <nl>  			reply::set_content(&rep, result[0][0].begin(), result[0][0].end());
@@ -394,16 +394,24 @@ void sj_clubby_send_hello(struct clubby *clubby) { <nl>  } <nl>   <nl>  static void clubby_send_labels(struct clubby *clubby) { <nl> +  LOG(LL_DEBUG, ("Senging labels:")); <nl>    struct ub_ctx *ctx = ub_ctx_new(); <nl>   <nl> +  ub_val_t args = ub_create_object(ctx); <nl>    ub_val_t labels = ub_create_object(ctx); <nl>    struct ro_var *rv; <nl>    for (rv = g_ro_vars; rv != NULL; rv = rv->next) { <nl>      ub_add_prop(ctx, labels, rv->name, ub_create_string(ctx, *rv->ptr)); <nl> +    LOG(LL_DEBUG, ("%s: %s", rv->name, *rv->ptr)); <nl>    } <nl> -  ub_val_t args = ub_create_object(ctx); <nl> + <nl>    ub_add_prop(ctx, args, "labels", labels); <nl>   <nl> +  ub_val_t ids = ub_create_array(ctx); <nl> +  ub_array_push(ctx, ids, ub_create_string(ctx, clubby->cfg.device_id)); <nl> + <nl> +  ub_add_prop(ctx, args, "ids", ids); <nl> + <nl>    int64_t id = clubby_proto_get_new_id(); <nl>    ub_val_t frame = clubby_proto_create_frame( <nl>        ctx, id, clubby->cfg.device_id, clubby->cfg.device_psk, NULL,
@@ -251,6 +251,7 @@ int fs_mount(spiffs *spf, uint32_t addr, uint32_t size, uint8_t *workbuf, <nl>    cfg.hal_erase_f = esp_spiffs_erase; <nl>   <nl>    if (SPIFFS_mount(spf, &cfg, workbuf, fds, fds_size, 0, 0, 0) != SPIFFS_OK) { <nl> +    LOG(LL_ERROR, ("SPIFFS_mount failed: %d", SPIFFS_errno(spf))); <nl>      return SPIFFS_errno(spf); <nl>    } <nl>  
@@ -3382,7 +3382,7 @@ static void stbvox_make_mesh_for_block_with_geo(stbvox_mesh_maker *mm, stbvox_po <nl>   <nl>  static void stbvox_make_mesh_for_column(stbvox_mesh_maker *mm, int x, int y, int z0) <nl>  { <nl> -   stbvox_pos pos = { x,y,0 }; <nl> +   stbvox_pos pos; pos.x = x; pos.y = y; pos.z = 0; <nl>     int v_off = x * mm->x_stride_in_bytes + y * mm->y_stride_in_bytes; <nl>     int ns_off = mm->y_stride_in_bytes; <nl>     int ew_off = mm->x_stride_in_bytes;
@@ -3933,6 +3933,12 @@ void parse_wkb_data(Geometry *geom, const char *p, size_t num_geoms) <nl>          ent.set_nbytes(nbytes); <nl>          ent.set_owner(geom); <nl>          geom->shallow_push(&ent); <nl> +        /* <nl> +          The inner rings object isn't adopted by others in shallow_push, <nl> +          so we must delete it here before donating. <nl> +         */ <nl> +        if (ent.inner_rings()) <nl> +          delete ent.inner_rings(); <nl>          // The object 'ent' doesn't have any data of its own. <nl>          ent.donate_data(); <nl>          bo= plgn_step.get_current_byte_order();
@@ -1797,9 +1797,9 @@ struct buf_pool_t{ <nl>   <nl>  	/** @name General fields */ <nl>  	/* @{ */ <nl> -	ib_mutex_t		mutex;		/*!< Buffer pool mutex of this <nl> +	ib_mutex_t	mutex;		/*!< Buffer pool mutex of this <nl>  					instance */ <nl> -	ib_mutex_t		zip_mutex;	/*!< Zip mutex of this buffer <nl> +	ib_mutex_t	zip_mutex;	/*!< Zip mutex of this buffer <nl>  					pool instance, protects compressed <nl>  					only pages (of type buf_page_t, not <nl>  					buf_block_t */
@@ -8600,6 +8600,9 @@ ha_innobase::check( <nl>  					    (ulong) n_rows, <nl>  					    (ulong) n_rows_in_table); <nl>  			is_ok = FALSE; <nl> +			row_mysql_lock_data_dictionary(prebuilt->trx); <nl> +			dict_set_corrupted(index); <nl> +			row_mysql_unlock_data_dictionary(prebuilt->trx); <nl>  		} <nl>  	} <nl>  
@@ -5053,7 +5053,7 @@ trx_rollback: <nl>  			} <nl>  		} <nl>   <nl> -		if (ctx) { <nl> +		if (ctx && !dict_table_is_discarded(prebuilt->table)) { <nl>  			bool	stats_init_called = false; <nl>   <nl>  			for (uint i = 0; i < ctx->num_to_add; i++) {
@@ -550,7 +550,7 @@ Event_scheduler::start(int *err_no) <nl>      scheduler_thd= NULL; <nl>      delete new_thd; <nl>   <nl> -    delete scheduler_param_value; <nl> +    my_free(scheduler_param_value); <nl>      ret= true; <nl>    } <nl>  
@@ -3038,6 +3038,7 @@ MgmtSrvr::dumpStateSelf(const Uint32 args[], Uint32 no) <nl>    if (no < 1) <nl>      return -1; <nl>   <nl> +#ifdef ERROR_INSERT <nl>    switch(args[0]) <nl>    { <nl>    case 9994: <nl> @@ -3067,7 +3068,6 @@ MgmtSrvr::dumpStateSelf(const Uint32 args[], Uint32 no) <nl>      break; <nl>    } <nl>   <nl> -#ifdef ERROR_INSERT <nl>    case 9996: <nl>    { <nl>      /* Sendbuffer consumption */
@@ -4687,7 +4687,10 @@ CLI_MYSQL_REAL_CONNECT(MYSQL *mysql,const char *host, const char *user, <nl>      goto error; <nl>   <nl>    if (scramble_buffer_allocated == TRUE) <nl> +  { <nl> +    scramble_buffer_allocated= FALSE; <nl>      my_free(scramble_buffer); <nl> +  } <nl>   <nl>    MYSQL_TRACE_STAGE(mysql, READY_FOR_COMMAND); <nl>   <nl> @@ -4764,6 +4767,8 @@ error: <nl>      mysql_close_free(mysql); <nl>      if (!(client_flag & CLIENT_REMEMBER_OPTIONS)) <nl>        mysql_close_free_options(mysql); <nl> +    if (scramble_buffer_allocated) <nl> +      my_free(scramble_buffer); <nl>    } <nl>    DBUG_RETURN(0); <nl>  }
@@ -174,7 +174,7 @@ byte ft_simple_get_word(CHARSET_INFO *cs, byte **start, byte *end, <nl>                          FT_WORD *word) <nl>  { <nl>    byte *doc= *start; <nl> -  uint mwc, length; <nl> +  uint mwc, length, mbl; <nl>    DBUG_ENTER("ft_simple_get_word"); <nl>   <nl>    while (doc<end) <nl> @@ -185,7 +185,7 @@ byte ft_simple_get_word(CHARSET_INFO *cs, byte **start, byte *end, <nl>      } <nl>   <nl>      mwc= length= 0; <nl> -    for (word->pos=doc; doc<end; length++, doc+=my_mbcharlen(cs, *(uchar *)doc)) <nl> +    for (word->pos=doc; doc<end; length++, mbl=my_mbcharlen(cs, *(uchar *)doc), doc+=(mbl ? mbl : 1)) <nl>        if (true_word_char(cs,*doc)) <nl>          mwc= 0; <nl>        else if (!misc_word_char(*doc) || mwc++)
@@ -257,6 +257,7 @@ public: <nl>                  } <nl>                } <nl>              } <nl> +            mysql_free_result(result); <nl>            } <nl>          } <nl>  
@@ -96,6 +96,7 @@ ClusterConnectionPool::ClusterConnectionPool(const char *s) : <nl>  Ndb_cluster_connection * ClusterConnectionPool::connect(const char *connectstring) { <nl>    DEBUG_ENTER_METHOD("ClusterConnectionPool::connect"); <nl>    int conn_retries = 0; <nl> +  if(connectstring == 0) connectstring = ""; <nl>    Ndb_cluster_connection *c = new Ndb_cluster_connection(connectstring); <nl>     <nl>    /* Set name that appears in the cluster log file */
@@ -9063,6 +9063,7 @@ static int fix_paths(void) <nl>    { <nl>      if (*opt_secure_file_priv == 0) <nl>      { <nl> +      my_free(opt_secure_file_priv, MYF(0)); <nl>        opt_secure_file_priv= 0; <nl>      } <nl>      else
@@ -2728,6 +2728,7 @@ lock_grant_vats( <nl>   <nl>  	if (waiting.empty() && granted.empty()) { <nl>  		/* Nothing to grant. */ <nl> +		mem_heap_free(heap); <nl>  		return; <nl>  	} <nl>  
@@ -378,7 +378,7 @@ int mysql_create_function(THD *thd,udf_func *udf) <nl>    } <nl>   <nl>    rw_wrlock(&THR_LOCK_udf); <nl> -  if ((hash_search(&udf_hash,(byte*) &udf->name.str, udf->name.length))) <nl> +  if ((hash_search(&udf_hash,(byte*) udf->name.str, udf->name.length))) <nl>    { <nl>      net_printf(thd, ER_UDF_EXISTS, udf->name); <nl>      goto err;
@@ -4522,7 +4522,6 @@ int SetCipherList(Suites* s, const char* list) <nl>          byte b; <nl>          byte compression; <nl>          ProtocolVersion pv; <nl> -        word16 extSz; <nl>          word32 i = *inOutIdx; <nl>          word32 begin = i; <nl>  
@@ -14279,7 +14279,7 @@ int DoSessionTicket(WOLFSSL* ssl, <nl>  #ifdef WOLFSSL_DTLS <nl>          Hmac            cookieHmac; <nl>          byte            peerCookie[MAX_COOKIE_LEN]; <nl> -        byte            peerCookieSz; <nl> +        byte            peerCookieSz = 0; <nl>          byte            cookieType; <nl>          byte            cookieSz; <nl>  #endif /* WOLFSSL_DTLS */
@@ -1368,7 +1368,7 @@ void AesCtrEncrypt(Aes* aes, byte* out, const byte* in, word32 sz) <nl>      word32 blocks = sz / AES_BLOCK_SIZE; <nl>   <nl>      while (blocks--) { <nl> -        AesEncrypt(aes, aes->reg, out); <nl> +        AesEncrypt(aes, (byte*)aes->reg, out); <nl>          IncrementAesCounter((byte*)aes->reg); <nl>          xorbuf(out, in, AES_BLOCK_SIZE); <nl>  
@@ -332,8 +332,8 @@ <nl>          #include "mutex.h" <nl>      #endif <nl>   <nl> -    #define XMALLOC(s, h, type) (void *)_mem_alloc_system((s)) <nl> -    #define XFREE(p, h, type)   _mem_free(p) <nl> +    #define XMALLOC(s, h, t)    (void *)_mem_alloc_system((s)) <nl> +    #define XFREE(p, h, t)      {void* xp = (p); if ((xp)) _mem_free((xp));} <nl>      /* Note: MQX has no realloc, using fastmath above */ <nl>  #endif <nl>  
@@ -1658,7 +1658,7 @@ void bench_chacha(void) <nl>  void bench_chacha20_poly1305_aead(void) <nl>  { <nl>      double start; <nl> -    int    ret, i, count; <nl> +    int    ret = 0, i, count; <nl>   <nl>      byte authTag[CHACHA20_POLY1305_AEAD_AUTHTAG_SIZE]; <nl>      XMEMSET(authTag, 0, sizeof(authTag));
@@ -580,6 +580,11 @@ int wc_AddErrorNode(int error, int line, char* buf, char* file) <nl>              if (wc_errors != NULL) { <nl>                  /* check for unexpected case before over writing wc_errors */ <nl>                  WOLFSSL_MSG("ERROR in adding new node to logging queue!!\n"); <nl> +                /* In the event both wc_last_node and wc_errors are NULL, err <nl> +                 * goes unassigned to external wc_errors, wc_last_node. Free <nl> +                 * err in this instance since wc_ClearErrorNodes will not <nl> +                 */ <nl> +                XFREE(err, wc_error_heap, DYNAMIC_TYPE_LOG); <nl>              } <nl>              else { <nl>                  wc_errors    = err;
@@ -142,6 +142,7 @@ int activate_fd(int irq, int fd, int type, void *dev_id) <nl>  				     .events 		= events, <nl>  				     .current_events 	= 0 } ); <nl>   <nl> +	err = -EBUSY; <nl>  	spin_lock_irqsave(&irq_lock, flags); <nl>  	for (irq_fd = active_fds; irq_fd != NULL; irq_fd = irq_fd->next) { <nl>  		if ((irq_fd->fd == fd) && (irq_fd->type == type)) {
@@ -80,13 +80,17 @@ void bacct_add_tsk(struct taskstats *stats, struct task_struct *tsk) <nl>   */ <nl>  void xacct_add_tsk(struct taskstats *stats, struct task_struct *p) <nl>  { <nl> +	struct mm_struct *mm; <nl> + <nl>  	/* convert pages-jiffies to Mbyte-usec */ <nl>  	stats->coremem = jiffies_to_usecs(p->acct_rss_mem1) * PAGE_SIZE / MB; <nl>  	stats->virtmem = jiffies_to_usecs(p->acct_vm_mem1) * PAGE_SIZE / MB; <nl> -	if (p->mm) { <nl> +	mm = get_task_mm(p); <nl> +	if (mm) { <nl>  		/* adjust to KB unit */ <nl> -		stats->hiwater_rss   = p->mm->hiwater_rss * PAGE_SIZE / KB; <nl> -		stats->hiwater_vm    = p->mm->hiwater_vm * PAGE_SIZE / KB; <nl> +		stats->hiwater_rss   = mm->hiwater_rss * PAGE_SIZE / KB; <nl> +		stats->hiwater_vm    = mm->hiwater_vm * PAGE_SIZE / KB; <nl> +		mmput(mm); <nl>  	} <nl>  	stats->read_char	= p->rchar; <nl>  	stats->write_char	= p->wchar;
@@ -580,7 +580,7 @@ static int ivtv_getsda_old(void *data) <nl>  /* template for i2c-bit-algo */ <nl>  static struct i2c_adapter ivtv_i2c_adap_template = { <nl>  	.name = "ivtv i2c driver", <nl> -	.id = I2C_HW_B_CX2341X,  	/* algo-bit is OR'd with this */ <nl> +	.id = I2C_HW_B_CX2341X, <nl>  	.algo = NULL,                   /* set by i2c-algo-bit */ <nl>  	.algo_data = NULL,              /* filled from template */ <nl>  	.client_register = attach_inform,
@@ -3192,8 +3192,13 @@ again: <nl>   <nl>  #ifdef CONFIG_MODULE_SIG <nl>  	mod->sig_ok = info->sig_ok; <nl> -	if (!mod->sig_ok) <nl> +	if (!mod->sig_ok) { <nl> +		printk_once(KERN_NOTICE <nl> +			    "%s: module verification failed: signature and/or" <nl> +			    " required key missing - tainting kernel\n", <nl> +			    mod->name); <nl>  		add_taint_module(mod, TAINT_FORCED_MODULE); <nl> +	} <nl>  #endif <nl>   <nl>  	/* Now module is in final location, initialize linked lists, etc. */
@@ -1343,6 +1343,8 @@ static int mptsas_smp_handler(struct Scsi_Host *shost, struct sas_rphy *rphy, <nl>  		smprep = (SmpPassthroughReply_t *)ioc->sas_mgmt.reply; <nl>  		memcpy(req->sense, smprep, sizeof(*smprep)); <nl>  		req->sense_len = sizeof(*smprep); <nl> +		req->data_len = 0; <nl> +		rsp->data_len -= smprep->ResponseDataLength; <nl>  	} else { <nl>  		printk(MYIOC_s_ERR_FMT "%s: smp passthru reply failed to be returned\n", <nl>  		    ioc->name, __FUNCTION__);
@@ -347,7 +347,7 @@ e1000_set_tso(struct net_device *netdev, u32 data) <nl>  	else <nl>  		netdev->features &= ~NETIF_F_TSO; <nl>   <nl> -	if (data) <nl> +	if (data && (adapter->hw.mac_type > e1000_82547_rev_2)) <nl>  		netdev->features |= NETIF_F_TSO6; <nl>  	else <nl>  		netdev->features &= ~NETIF_F_TSO6;
@@ -200,7 +200,6 @@ show_regs(struct pt_regs *regs) <nl>  void <nl>  start_thread(struct pt_regs * regs, unsigned long pc, unsigned long sp) <nl>  { <nl> -	set_fs(USER_DS); <nl>  	regs->pc = pc; <nl>  	regs->ps = 8; <nl>  	wrusp(sp);
@@ -33,7 +33,7 @@ <nl>  int do_signal(struct pt_regs *, sigset_t *); <nl>   <nl>  asmlinkage int <nl> -sys_rt_sigsuspend(sigset_t *unewset, size_t sigsetsize, <nl> +sys_rt_sigsuspend(sigset_t __user *unewset, size_t sigsetsize, <nl>  		  unsigned long r2, unsigned long r3, unsigned long r4, <nl>  		  unsigned long r5, unsigned long r6, struct pt_regs *regs) <nl>  { <nl> @@ -78,8 +78,8 @@ sys_sigaltstack(const stack_t __user *uss, stack_t __user *uoss, <nl>  struct rt_sigframe <nl>  { <nl>  	int sig; <nl> -	struct siginfo *pinfo; <nl> -	void *puc; <nl> +	struct siginfo __user *pinfo; <nl> +	void __user *puc; <nl>  	struct siginfo info; <nl>  	struct ucontext uc; <nl>  //	struct _fpstate fpstate;
@@ -81,6 +81,7 @@ void free_user_ns(struct kref *kref) <nl>  	struct user_namespace *ns; <nl>   <nl>  	ns = container_of(kref, struct user_namespace, kref); <nl> +	free_uid(ns->root_user); <nl>  	kfree(ns); <nl>  } <nl>  
@@ -323,6 +323,7 @@ static struct omap2_hsmmc_info mmc[] = { <nl>  	{ <nl>  		.mmc		= 1, <nl>  		.caps		= MMC_CAP_4_BIT_DATA | MMC_CAP_8_BIT_DATA, <nl> +		.gpio_cd	= -EINVAL, <nl>  		.gpio_wp	= -EINVAL, <nl>  	}, <nl>  	{}	/* Terminator */
@@ -3320,8 +3320,8 @@ int ext4_ext_map_blocks(handle_t *handle, struct inode *inode, <nl>  	trace_ext4_ext_map_blocks_enter(inode, map->m_lblk, map->m_len, flags); <nl>   <nl>  	/* check in cache */ <nl> -	if (ext4_ext_in_cache(inode, map->m_lblk, &newex) && <nl> -		((flags & EXT4_GET_BLOCKS_PUNCH_OUT_EXT) == 0)) { <nl> +	if (!(flags & EXT4_GET_BLOCKS_PUNCH_OUT_EXT) && <nl> +		ext4_ext_in_cache(inode, map->m_lblk, &newex)) { <nl>  		if (!newex.ee_start_lo && !newex.ee_start_hi) { <nl>  			if ((flags & EXT4_GET_BLOCKS_CREATE) == 0) { <nl>  				/*
@@ -626,8 +626,6 @@ static void radeon_cp_init_ring_buffer(struct drm_device * dev, <nl>  		     dev_priv->ring.size_l2qw); <nl>  #endif <nl>   <nl> -	/* Start with assuming that writeback doesn't work */ <nl> -	dev_priv->writeback_works = 0; <nl>   <nl>  	/* Initialize the scratch register pointer.  This will cause <nl>  	 * the scratch register values to be written out to memory <nl> @@ -674,6 +672,9 @@ static void radeon_test_writeback(drm_radeon_private_t * dev_priv) <nl>  { <nl>  	u32 tmp; <nl>   <nl> +	/* Start with assuming that writeback doesn't work */ <nl> +	dev_priv->writeback_works = 0; <nl> + <nl>  	/* Writeback doesn't seem to work everywhere, test it here and possibly <nl>  	 * enable it if it appears to work <nl>  	 */
@@ -429,6 +429,7 @@ static int exynos5_busfreq_int_remove(struct platform_device *pdev) <nl>  	return 0; <nl>  } <nl>   <nl> +#ifdef CONFIG_PM_SLEEP <nl>  static int exynos5_busfreq_int_resume(struct device *dev) <nl>  { <nl>  	struct platform_device *pdev = container_of(dev, struct platform_device, <nl> @@ -438,10 +439,12 @@ static int exynos5_busfreq_int_resume(struct device *dev) <nl>  	busfreq_mon_reset(data); <nl>  	return 0; <nl>  } <nl> - <nl>  static const struct dev_pm_ops exynos5_busfreq_int_pm = { <nl>  	.resume	= exynos5_busfreq_int_resume, <nl>  }; <nl> +#endif <nl> +static SIMPLE_DEV_PM_OPS(exynos5_busfreq_int_pm_ops, NULL, <nl> +			 exynos5_busfreq_int_resume); <nl>   <nl>  /* platform device pointer for exynos5 devfreq device. */ <nl>  static struct platform_device *exynos5_devfreq_pdev; <nl> @@ -452,7 +455,7 @@ static struct platform_driver exynos5_busfreq_int_driver = { <nl>  	.driver		= { <nl>  		.name		= "exynos5-bus-int", <nl>  		.owner		= THIS_MODULE, <nl> -		.pm		= &exynos5_busfreq_int_pm, <nl> +		.pm		= &exynos5_busfreq_int_pm_ops, <nl>  	}, <nl>  }; <nl>  
@@ -174,6 +174,7 @@ cio_start_key (struct subchannel *sch,	/* subchannel structure */ <nl>  	CIO_TRACE_EVENT(4, sch->dev.bus_id); <nl>   <nl>  	orb = &to_io_private(sch)->orb; <nl> +	memset(orb, 0, sizeof(union orb)); <nl>  	/* sch is always under 2G. */ <nl>  	orb->cmd.intparm = (u32)(addr_t)sch; <nl>  	orb->cmd.fmt = 1;
@@ -924,7 +924,8 @@ extern void __rta_fill(struct sk_buff *skb, int attrtype, int attrlen, const voi <nl>  	(skb)->len; }) <nl>   <nl>  #define RTA_NEST_CANCEL(skb, start) \ <nl> -({	skb_trim(skb, (unsigned char *) (start) - (skb)->data); \ <nl> +({	if (start) \ <nl> +		skb_trim(skb, (unsigned char *) (start) - (skb)->data); \ <nl>  	-1; }) <nl>   <nl>  #define RTA_GET_U32(rta) \
@@ -898,10 +898,13 @@ int pwc_isoc_init(struct pwc_device *pdev) <nl>  	/* link */ <nl>  	for (i = 0; i < MAX_ISO_BUFS; i++) { <nl>  		ret = usb_submit_urb(pdev->sbuf[i].urb, GFP_KERNEL); <nl> -		if (ret) <nl> +		if (ret) { <nl>  			PWC_ERROR("isoc_init() submit_urb %d failed with error %d\n", i, ret); <nl> -		else <nl> -			PWC_DEBUG_MEMORY("URB 0x%p submitted.\n", pdev->sbuf[i].urb); <nl> +			pdev->iso_init = 1; <nl> +			pwc_isoc_cleanup(pdev); <nl> +			return ret; <nl> +		} <nl> +		PWC_DEBUG_MEMORY("URB 0x%p submitted.\n", pdev->sbuf[i].urb); <nl>  	} <nl>   <nl>  	/* All is done... */
@@ -138,6 +138,14 @@ acpi_ex_load_table_op(struct acpi_walk_state *walk_state, <nl>   <nl>  	ACPI_FUNCTION_TRACE(ex_load_table_op); <nl>   <nl> +	/* Validate lengths for the signature_string, OEMIDString, OEMtable_iD */ <nl> + <nl> +	if ((operand[0]->string.length > ACPI_NAME_SIZE) || <nl> +	    (operand[1]->string.length > ACPI_OEM_ID_SIZE) || <nl> +	    (operand[2]->string.length > ACPI_OEM_TABLE_ID_SIZE)) { <nl> +		return_ACPI_STATUS(AE_BAD_PARAMETER); <nl> +	} <nl> + <nl>  	/* Find the ACPI table in the RSDT/XSDT */ <nl>   <nl>  	status = acpi_tb_find_table(operand[0]->string.pointer,
@@ -2543,6 +2543,7 @@ static void *ptype_get_idx(loff_t pos) <nl>  } <nl>   <nl>  static void *ptype_seq_start(struct seq_file *seq, loff_t *pos) <nl> +	__acquires(RCU) <nl>  { <nl>  	rcu_read_lock(); <nl>  	return *pos ? ptype_get_idx(*pos - 1) : SEQ_START_TOKEN; <nl> @@ -2578,6 +2579,7 @@ found: <nl>  } <nl>   <nl>  static void ptype_seq_stop(struct seq_file *seq, void *v) <nl> +	__releases(RCU) <nl>  { <nl>  	rcu_read_unlock(); <nl>  }
@@ -2854,6 +2854,9 @@ int dwc2_hcd_init(struct dwc2_hsotg *hsotg, int irq, <nl>  	if (!hcd) <nl>  		goto error1; <nl>   <nl> +	if (hsotg->core_params->dma_enable <= 0) <nl> +		hcd->self.uses_dma = 0; <nl> + <nl>  	hcd->has_tt = 1; <nl>   <nl>  	spin_lock_init(&hsotg->lock);
@@ -1236,6 +1236,8 @@ static void zfcp_erp_rports_del(struct zfcp_adapter *adapter) <nl>  { <nl>  	struct zfcp_port *port; <nl>  	list_for_each_entry(port, &adapter->port_list_head, list) { <nl> +		if (!port->rport) <nl> +			continue; <nl>  		fc_remote_port_delete(port->rport); <nl>  		port->rport = NULL; <nl>  	}
@@ -319,15 +319,17 @@ static int __devinit tsc2007_probe(struct i2c_client *client, <nl>  		goto err_free_mem; <nl>  	} <nl>   <nl> +	/* Prepare for touch readings - power down ADC and enable PENIRQ */ <nl> +	err = tsc2007_xfer(ts, PWRDOWN); <nl> +	if (err < 0) <nl> +		goto err_free_irq; <nl> + <nl>  	err = input_register_device(input_dev); <nl>  	if (err) <nl>  		goto err_free_irq; <nl>   <nl>  	i2c_set_clientdata(client, ts); <nl>   <nl> -	/* Prepare for touch readings - power down ADC and enable PENIRQ */ <nl> -	tsc2007_xfer(ts, PWRDOWN); <nl> - <nl>  	return 0; <nl>   <nl>   err_free_irq:
@@ -106,6 +106,7 @@ static void um_new_card(DESCRIPTOR * d) <nl>  	} else { <nl>  		DBG_ERR(("could not create user mode idi card %d", <nl>  			 adapter_nr)); <nl> +		diva_os_free(0, card); <nl>  	} <nl>  } <nl>  
@@ -2785,8 +2785,6 @@ void __devinit bttv_init_card2(struct bttv *btv) <nl>          } <nl>  	btv->pll.pll_current = -1; <nl>   <nl> -	bttv_reset_audio(btv); <nl> - <nl>  	/* tuner configuration (from card list / autodetect / insmod option) */ <nl>   	if (UNSET != bttv_tvcards[btv->c.type].tuner_type) <nl>  		if(UNSET == btv->tuner_type)
@@ -5106,6 +5106,7 @@ static int _nfs4_proc_getlk(struct nfs4_state *state, int cmd, struct file_lock <nl>  			status = 0; <nl>  	} <nl>  	request->fl_ops->fl_release_private(request); <nl> +	request->fl_ops = NULL; <nl>  out: <nl>  	return status; <nl>  }
@@ -380,6 +380,7 @@ enum node_states { <nl>  #else <nl>  	N_HIGH_MEMORY = N_NORMAL_MEMORY, <nl>  #endif <nl> +	N_MEMORY = N_HIGH_MEMORY, <nl>  	N_CPU,		/* The node has one or more cpus */ <nl>  	NR_NODE_STATES <nl>  };
@@ -1575,8 +1575,10 @@ static int cpuset_write_resmask(struct cgroup *cgrp, struct cftype *cft, <nl>  		return -ENODEV; <nl>   <nl>  	trialcs = alloc_trial_cpuset(cs); <nl> -	if (!trialcs) <nl> -		return -ENOMEM; <nl> +	if (!trialcs) { <nl> +		retval = -ENOMEM; <nl> +		goto out; <nl> +	} <nl>   <nl>  	switch (cft->private) { <nl>  	case FILE_CPULIST: <nl> @@ -1591,6 +1593,7 @@ static int cpuset_write_resmask(struct cgroup *cgrp, struct cftype *cft, <nl>  	} <nl>   <nl>  	free_trial_cpuset(trialcs); <nl> +out: <nl>  	cgroup_unlock(); <nl>  	return retval; <nl>  }
@@ -180,6 +180,7 @@ setup_efi_state(struct boot_params *params, unsigned long params_load_addr, <nl>  	if (efi_enabled(EFI_OLD_MEMMAP)) <nl>  		return 0; <nl>   <nl> +	params->secure_boot = boot_params.secure_boot; <nl>  	ei->efi_loader_signature = current_ei->efi_loader_signature; <nl>  	ei->efi_systab = current_ei->efi_systab; <nl>  	ei->efi_systab_hi = current_ei->efi_systab_hi;
@@ -639,7 +639,7 @@ static int iwl_set_wep_dynamic_key_info(struct iwl_priv *priv, <nl>  	 * in uCode. */ <nl>   <nl>  	WARN(priv->stations[sta_id].sta.key.key_offset == WEP_INVALID_OFFSET, <nl> -		"no space for new kew"); <nl> +		"no space for a new key"); <nl>   <nl>  	priv->stations[sta_id].sta.key.key_flags = key_flags; <nl>  	priv->stations[sta_id].sta.sta.modify_mask = STA_MODIFY_KEY_MASK; <nl> @@ -687,7 +687,7 @@ static int iwl_set_ccmp_dynamic_key_info(struct iwl_priv *priv, <nl>  	 * in uCode. */ <nl>   <nl>  	WARN(priv->stations[sta_id].sta.key.key_offset == WEP_INVALID_OFFSET, <nl> -		"no space for new kew"); <nl> +		"no space for a new key"); <nl>   <nl>  	priv->stations[sta_id].sta.key.key_flags = key_flags; <nl>  	priv->stations[sta_id].sta.sta.modify_mask = STA_MODIFY_KEY_MASK; <nl> @@ -723,7 +723,7 @@ static int iwl_set_tkip_dynamic_key_info(struct iwl_priv *priv, <nl>  	 * in uCode. */ <nl>   <nl>  	WARN(priv->stations[sta_id].sta.key.key_offset == WEP_INVALID_OFFSET, <nl> -		"no space for new kew"); <nl> +		"no space for a new key"); <nl>   <nl>  	/* This copy is acutally not needed: we get the key with each TX */ <nl>  	memcpy(priv->stations[sta_id].keyinfo.key, keyconf->key, 16);
@@ -124,6 +124,7 @@ static unsigned long __meminit compute_pernodesize(int node) <nl>  	pernodesize += node * L1_CACHE_BYTES; <nl>  	pernodesize += L1_CACHE_ALIGN(sizeof(pg_data_t)); <nl>  	pernodesize += L1_CACHE_ALIGN(sizeof(struct ia64_node_data)); <nl> +	pernodesize += L1_CACHE_ALIGN(sizeof(pg_data_t)); <nl>  	pernodesize = PAGE_ALIGN(pernodesize); <nl>  	return pernodesize; <nl>  }
@@ -5180,6 +5180,7 @@ struct inode *btrfs_alloc_inode(struct super_block *sb) <nl>  	ei->logged_trans = 0; <nl>  	ei->outstanding_extents = 0; <nl>  	ei->reserved_extents = 0; <nl> +	ei->root = NULL; <nl>  	spin_lock_init(&ei->accounting_lock); <nl>  	btrfs_ordered_inode_tree_init(&ei->ordered_tree); <nl>  	INIT_LIST_HEAD(&ei->i_orphan); <nl> @@ -5195,6 +5196,14 @@ void btrfs_destroy_inode(struct inode *inode) <nl>  	WARN_ON(!list_empty(&inode->i_dentry)); <nl>  	WARN_ON(inode->i_data.nrpages); <nl>   <nl> +	/* <nl> +	 * This can happen where we create an inode, but somebody else also <nl> +	 * created the same inode and we need to destroy the one we already <nl> +	 * created. <nl> +	 */ <nl> +	if (!root) <nl> +		goto free; <nl> + <nl>  	/* <nl>  	 * Make sure we're properly removed from the ordered operation <nl>  	 * lists. <nl> @@ -5230,6 +5239,7 @@ void btrfs_destroy_inode(struct inode *inode) <nl>  	} <nl>  	inode_tree_del(inode); <nl>  	btrfs_drop_extent_cache(inode, 0, (u64)-1, 0); <nl> +free: <nl>  	kmem_cache_free(btrfs_inode_cachep, BTRFS_I(inode)); <nl>  } <nl>  
@@ -85,23 +85,20 @@ static struct nvec_chip *nvec_power_handle; <nl>  static const struct mfd_cell nvec_devices[] = { <nl>  	{ <nl>  		.name = "nvec-kbd", <nl> -		.id = 1, <nl>  	}, <nl>  	{ <nl>  		.name = "nvec-mouse", <nl> -		.id = 1, <nl>  	}, <nl>  	{ <nl>  		.name = "nvec-power", <nl> -		.id = 1, <nl> +		.id = 0, <nl>  	}, <nl>  	{ <nl>  		.name = "nvec-power", <nl> -		.id = 2, <nl> +		.id = 1, <nl>  	}, <nl>  	{ <nl>  		.name = "nvec-paz00", <nl> -		.id = 1, <nl>  	}, <nl>  }; <nl>   <nl> @@ -891,7 +888,7 @@ static int tegra_nvec_probe(struct platform_device *pdev) <nl>  		nvec_msg_free(nvec, msg); <nl>  	} <nl>   <nl> -	ret = mfd_add_devices(nvec->dev, -1, nvec_devices, <nl> +	ret = mfd_add_devices(nvec->dev, 0, nvec_devices, <nl>  			      ARRAY_SIZE(nvec_devices), NULL, 0, NULL); <nl>  	if (ret) <nl>  		dev_err(nvec->dev, "error adding subdevices\n");
@@ -575,9 +575,9 @@ static int ks8695_poll(struct napi_struct *napi, int budget) <nl>  	if (work_done < budget) { <nl>  		unsigned long flags; <nl>  		spin_lock_irqsave(&ksp->rx_lock, flags); <nl> +		__napi_complete(napi); <nl>  		/*enable rx interrupt*/ <nl>  		writel(isr | mask_bit, KS8695_IRQ_VA + KS8695_INTEN); <nl> -		__napi_complete(napi); <nl>  		spin_unlock_irqrestore(&ksp->rx_lock, flags); <nl>  	} <nl>  	return work_done;
@@ -1044,6 +1044,7 @@ static int mthca_alloc_qp_common(struct mthca_dev *dev, <nl>  	int i; <nl>   <nl>  	atomic_set(&qp->refcount, 1); <nl> +	init_waitqueue_head(&qp->wait); <nl>  	qp->state    	 = IB_QPS_RESET; <nl>  	qp->atomic_rd_en = 0; <nl>  	qp->resp_depth   = 0;
@@ -406,6 +406,13 @@ static int sb_finish_set_opts(struct super_block *sb) <nl>  	if (strncmp(sb->s_type->name, "sysfs", sizeof("sysfs")) == 0) <nl>  		sbsec->flags |= SE_SBLABELSUPP; <nl>   <nl> +	/* <nl> +	 * Special handling for rootfs. Is genfs but supports <nl> +	 * setting SELinux context on in-core inodes. <nl> +	 */ <nl> +	if (strncmp(sb->s_type->name, "rootfs", sizeof("rootfs")) == 0) <nl> +		sbsec->flags |= SE_SBLABELSUPP; <nl> + <nl>  	/* Initialize the root inode. */ <nl>  	rc = inode_doinit_with_dentry(root_inode, root); <nl>  
@@ -784,6 +784,8 @@ static void vmid_reference(struct snd_soc_codec *codec) <nl>  				    WM8994_LINEOUT2_DISCH, <nl>  				    WM8994_LINEOUT_VMID_BUF_ENA); <nl>   <nl> +		wm_hubs_vmid_ena(codec); <nl> + <nl>  		/* Startup bias, VMID ramp & buffer */ <nl>  		snd_soc_update_bits(codec, WM8994_ANTIPOP_2, <nl>  				    WM8994_BIAS_SRC | <nl> @@ -796,8 +798,6 @@ static void vmid_reference(struct snd_soc_codec *codec) <nl>  				    WM8994_VMID_BUF_ENA | <nl>  				    (0x2 << WM8994_VMID_RAMP_SHIFT)); <nl>   <nl> -		wm_hubs_vmid_ena(codec); <nl> - <nl>  		/* Main bias enable, VMID=2x40k */ <nl>  		snd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_1, <nl>  				    WM8994_BIAS_ENA |
@@ -153,7 +153,7 @@ static int __devinit gen_74x164_probe(struct spi_device *spi) <nl>  	} <nl>   <nl>  	chip->gpio_chip.ngpio = GEN_74X164_NUMBER_GPIOS * chip->registers; <nl> -	chip->buffer = devm_kzalloc(&spi->dev, chip->gpio_chip.ngpio, GFP_KERNEL); <nl> +	chip->buffer = devm_kzalloc(&spi->dev, chip->registers, GFP_KERNEL); <nl>  	if (!chip->buffer) { <nl>  		ret = -ENOMEM; <nl>  		goto exit_destroy;
@@ -583,6 +583,7 @@ static void __free_pages_ok(struct page *page, unsigned int order) <nl>  	int bad = 0; <nl>  	int wasMlocked = __TestClearPageMlocked(page); <nl>   <nl> +	trace_mm_page_free_direct(page, order); <nl>  	kmemcheck_free_shadow(page, order); <nl>   <nl>  	for (i = 0 ; i < (1 << order) ; ++i) <nl> @@ -2008,7 +2009,6 @@ void __pagevec_free(struct pagevec *pvec) <nl>  void __free_pages(struct page *page, unsigned int order) <nl>  { <nl>  	if (put_page_testzero(page)) { <nl> -		trace_mm_page_free_direct(page, order); <nl>  		if (order == 0) <nl>  			free_hot_page(page); <nl>  		else
@@ -2159,6 +2159,13 @@ static void reg_process_pending_hints(void) <nl>  	} <nl>   <nl>  	reg_process_hint(reg_request); <nl> + <nl> +	lr = get_last_request(); <nl> + <nl> +	spin_lock(&reg_requests_lock); <nl> +	if (!list_empty(&reg_requests_list) && lr && lr->processed) <nl> +		schedule_work(&reg_work); <nl> +	spin_unlock(&reg_requests_lock); <nl>  } <nl>   <nl>  /* Processes beacon hints -- this has nothing to do with country IEs */
@@ -1295,7 +1295,12 @@ static void security_timeout(struct work_struct *work) <nl>  	struct l2cap_conn *conn = container_of(work, struct l2cap_conn, <nl>  						security_timer.work); <nl>   <nl> -	l2cap_conn_del(conn->hcon, ETIMEDOUT); <nl> +	BT_DBG("conn %p", conn); <nl> + <nl> +	if (test_and_clear_bit(HCI_CONN_LE_SMP_PEND, &conn->hcon->flags)) { <nl> +		smp_chan_destroy(conn); <nl> +		l2cap_conn_del(conn->hcon, ETIMEDOUT); <nl> +	} <nl>  } <nl>   <nl>  static struct l2cap_conn *l2cap_conn_add(struct hci_conn *hcon, u8 status)
@@ -268,6 +268,11 @@ static void cdc_ncm_update_rxtx_max(struct usbnet *dev, u32 new_rx, u32 new_tx) <nl>  	if (netif_running(dev->net) && val > ctx->tx_max) { <nl>  		netif_tx_lock_bh(dev->net); <nl>  		usbnet_start_xmit(NULL, dev->net); <nl> +		/* make sure tx_curr_skb is reallocated if it was empty */ <nl> +		if (ctx->tx_curr_skb) { <nl> +			dev_kfree_skb_any(ctx->tx_curr_skb); <nl> +			ctx->tx_curr_skb = NULL; <nl> +		} <nl>  		ctx->tx_max = val; <nl>  		netif_tx_unlock_bh(dev->net); <nl>  	} else {
@@ -416,7 +416,7 @@ static int imx6ul_tsc_probe(struct platform_device *pdev) <nl>  	} <nl>   <nl>  	adc_irq = platform_get_irq(pdev, 1); <nl> -	if (adc_irq <= 0) { <nl> +	if (adc_irq < 0) { <nl>  		dev_err(&pdev->dev, "no adc irq resource?\n"); <nl>  		return adc_irq; <nl>  	}
@@ -1258,8 +1258,10 @@ xfs_file_last_byte( <nl>  	 * necessary. <nl>  	 */ <nl>  	if (ip->i_df.if_flags & XFS_IFEXTENTS) { <nl> +		xfs_ilock(ip, XFS_ILOCK_SHARED); <nl>  		error = xfs_bmap_last_offset(NULL, ip, &last_block, <nl>  			XFS_DATA_FORK); <nl> +		xfs_iunlock(ip, XFS_ILOCK_SHARED); <nl>  		if (error) { <nl>  			last_block = 0; <nl>  		}
@@ -712,8 +712,10 @@ static int fuse_rename(struct inode *olddir, struct dentry *oldent, <nl>  			fuse_invalidate_attr(newdir); <nl>   <nl>  		/* newent will end up negative */ <nl> -		if (newent->d_inode) <nl> +		if (newent->d_inode) { <nl> +			fuse_invalidate_attr(newent->d_inode); <nl>  			fuse_invalidate_entry_cache(newent); <nl> +		} <nl>  	} else if (err == -EINTR) { <nl>  		/* If request was interrupted, DEITY only knows if the <nl>  		   rename actually took place.  If the invalidation
@@ -559,6 +559,8 @@ static struct net_device *setup_pre_routing(struct sk_buff *skb) <nl>  	else if (skb->protocol == htons(ETH_P_PPP_SES)) <nl>  		nf_bridge->mask |= BRNF_PPPoE; <nl>   <nl> +	/* Must drop socket now because of tproxy. */ <nl> +	skb_orphan(skb); <nl>  	return skb->dev; <nl>  } <nl>  
@@ -471,6 +471,7 @@ int drm_crtc_helper_set_config(struct drm_mode_set *set) <nl>  	int count = 0, ro, fail = 0; <nl>  	struct drm_crtc_helper_funcs *crtc_funcs; <nl>  	int ret = 0; <nl> +	int i; <nl>   <nl>  	DRM_DEBUG_KMS("\n"); <nl>   <nl> @@ -666,6 +667,12 @@ int drm_crtc_helper_set_config(struct drm_mode_set *set) <nl>  		if (ret != 0) <nl>  			goto fail; <nl>  	} <nl> +	DRM_DEBUG_KMS("Setting connector DPMS state to on\n"); <nl> +	for (i = 0; i < set->num_connectors; i++) { <nl> +		DRM_DEBUG_KMS("\t[CONNECTOR:%d:%s] set DPMS on\n", set->connectors[i]->base.id, <nl> +			      drm_get_connector_name(set->connectors[i])); <nl> +		set->connectors[i]->dpms = DRM_MODE_DPMS_ON; <nl> +	} <nl>   <nl>  	kfree(save_connectors); <nl>  	kfree(save_encoders);
@@ -1233,6 +1233,9 @@ uint brcms_reset(struct brcms_info *wl) <nl>  	/* dpc will not be rescheduled */ <nl>  	wl->resched = false; <nl>   <nl> +	/* inform publicly that interface is down */ <nl> +	wl->pub->up = false; <nl> + <nl>  	return 0; <nl>  } <nl>  
@@ -47,6 +47,9 @@ static int ion_chunk_heap_allocate(struct ion_heap *heap, <nl>  	unsigned long num_chunks; <nl>  	unsigned long allocated_size; <nl>   <nl> +	if (align > chunk_heap->chunk_size) <nl> +		return -EINVAL; <nl> + <nl>  	allocated_size = ALIGN(size, chunk_heap->chunk_size); <nl>  	num_chunks = allocated_size / chunk_heap->chunk_size; <nl>  
@@ -324,7 +324,7 @@ static inline int fls64(unsigned long x) <nl>  { <nl>  	unsigned long t, a, r; <nl>   <nl> -	t = __kernel_cmpbge (x, 0x0101010101010101); <nl> +	t = __kernel_cmpbge (x, 0x0101010101010101UL); <nl>  	a = __flsm1_tab[t]; <nl>  	t = __kernel_extbl (x, a); <nl>  	r = a*8 + __flsm1_tab[t] + (x != 0);
@@ -119,7 +119,8 @@ unlock: <nl>   <nl>  	for (skb = segs; skb; skb = skb->next) { <nl>  		ipv6h = skb->nh.ipv6h; <nl> -		ipv6h->payload_len = htons(skb->len - skb->mac_len); <nl> +		ipv6h->payload_len = htons(skb->len - skb->mac_len - <nl> +					   sizeof(*ipv6h)); <nl>  	} <nl>   <nl>  out:
@@ -878,7 +878,7 @@ static unsigned int bsg_poll(struct file *file, poll_table *wait) <nl>  	spin_lock_irq(&bd->lock); <nl>  	if (!list_empty(&bd->done_list)) <nl>  		mask |= POLLIN | POLLRDNORM; <nl> -	if (bd->queued_cmds >= bd->max_queue) <nl> +	if (bd->queued_cmds < bd->max_queue) <nl>  		mask |= POLLOUT; <nl>  	spin_unlock_irq(&bd->lock); <nl>  
@@ -1192,7 +1192,7 @@ c4_add_dev (hdw_info_t * hi, int brdno, unsigned long f0, unsigned long f1, <nl>                  hi->devname, irq1); <nl>          unregister_netdev (ndev); <nl>          free_irq (irq0, ndev); <nl> -        OS_kfree (ndev->priv); <nl> +        OS_kfree (netdev_priv(ndev)); <nl>          OS_kfree (ndev); <nl>          error_flag = EIO; <nl>          return 0;
@@ -844,9 +844,11 @@ static void nvme_set_queue_limits(struct nvme_ctrl *ctrl, <nl>  		struct request_queue *q) <nl>  { <nl>  	if (ctrl->max_hw_sectors) { <nl> +		u32 max_segments = <nl> +			(ctrl->max_hw_sectors / (ctrl->page_size >> 9)) + 1; <nl> + <nl>  		blk_queue_max_hw_sectors(q, ctrl->max_hw_sectors); <nl> -		blk_queue_max_segments(q, <nl> -			(ctrl->max_hw_sectors / (ctrl->page_size >> 9)) + 1); <nl> +		blk_queue_max_segments(q, min_t(u32, max_segments, USHRT_MAX)); <nl>  	} <nl>  	if (ctrl->stripe_size) <nl>  		blk_queue_chunk_sectors(q, ctrl->stripe_size >> 9);
@@ -376,7 +376,7 @@ MODULE_DEVICE_TABLE(pnp, smsc_ircc_pnp_table); <nl>  static int pnp_driver_registered; <nl>   <nl>  #ifdef CONFIG_PNP <nl> -static int __init smsc_ircc_pnp_probe(struct pnp_dev *dev, <nl> +static int __devinit smsc_ircc_pnp_probe(struct pnp_dev *dev, <nl>  				      const struct pnp_device_id *dev_id) <nl>  { <nl>  	unsigned int firbase, sirbase;
@@ -92,6 +92,8 @@ void __init spear13xx_l2x0_init(void) <nl>  	 * write alloc and 'Full line of zero' options <nl>  	 * <nl>  	 */ <nl> +	if (!IS_ENABLED(CONFIG_CACHE_L2X0)) <nl> +		return; <nl>   <nl>  	writel_relaxed(0x06, VA_L2CC_BASE + L2X0_PREFETCH_CTRL); <nl>  
@@ -3173,6 +3173,13 @@ retry: <nl>  		printk(" locked it.\n"); <nl>   <nl>  	do_each_thread(g, p) { <nl> +		/* <nl> +		 * It's not reliable to print a task's held locks <nl> +		 * if it's not sleeping (or if it's not the current <nl> +		 * task): <nl> +		 */ <nl> +		if (p->state == TASK_RUNNING && p != current) <nl> +			continue; <nl>  		if (p->lockdep_depth) <nl>  			lockdep_print_held_locks(p); <nl>  		if (!unlock)
@@ -392,6 +392,7 @@ int cris_request_io_interface(enum cris_io_interface ioif, const char *device_id <nl>  	if (((interfaces[ioif].gpio_g_in & gpio_in_pins) != interfaces[ioif].gpio_g_in) || <nl>  	    ((interfaces[ioif].gpio_g_out & gpio_out_pins) != interfaces[ioif].gpio_g_out) || <nl>  	    ((interfaces[ioif].gpio_b & gpio_pb_pins) != interfaces[ioif].gpio_b)) { <nl> +		local_irq_restore(flags); <nl>  		printk(KERN_CRIT "cris_request_io_interface: Could not get required pins for interface %u\n", <nl>  		       ioif); <nl>  		return -EBUSY;
@@ -238,6 +238,9 @@ static int hih6130_probe(struct i2c_client *client, <nl>  	hih6130->client = client; <nl>  	mutex_init(&hih6130->lock); <nl>   <nl> +	if (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_QUICK)) <nl> +		hih6130->write_length = 1; <nl> + <nl>  	hwmon_dev = devm_hwmon_device_register_with_groups(dev, client->name, <nl>  							   hih6130, <nl>  							   hih6130_groups);
@@ -262,7 +262,7 @@ found: <nl>   <nl>  static int openpromfs_readdir(struct file * filp, void * dirent, filldir_t filldir) <nl>  { <nl> -	struct inode *inode = filp->f_dentry->d_inode; <nl> +	struct inode *inode = filp->f_path.dentry->d_inode; <nl>  	struct op_inode_info *oi = OP_I(inode); <nl>  	struct device_node *dp = oi->u.node; <nl>  	struct device_node *child;
@@ -133,6 +133,12 @@ void mmc_request_done(struct mmc_host *host, struct mmc_request *mrq) <nl>  	struct mmc_command *cmd = mrq->cmd; <nl>  	int err = cmd->error; <nl>   <nl> +	/* Flag re-tuning needed on CRC errors */ <nl> +	if (err == -EILSEQ || (mrq->sbc && mrq->sbc->error == -EILSEQ) || <nl> +	    (mrq->data && mrq->data->error == -EILSEQ) || <nl> +	    (mrq->stop && mrq->stop->error == -EILSEQ)) <nl> +		mmc_retune_needed(host); <nl> + <nl>  	if (err && cmd->retries && mmc_host_is_spi(host)) { <nl>  		if (cmd->resp[0] & R1_SPI_ILLEGAL_COMMAND) <nl>  			cmd->retries = 0;
@@ -1196,7 +1196,6 @@ void uf_send_pkt_to_encrypt(struct work_struct *work) <nl>   <nl>          if (pktBulkDataLength > 0) { <nl>  		    pktBulkData = kmalloc(pktBulkDataLength, GFP_KERNEL); <nl> -		    memset(pktBulkData, 0, pktBulkDataLength); <nl>  	    } else { <nl>  		    unifi_error(priv, "uf_send_pkt_to_encrypt() : invalid buffer\n"); <nl>  		    return;
@@ -127,13 +127,15 @@ u32 omap_prcm_get_reset_sources(void) <nl>  		return prm_read_mod_reg(WKUP_MOD, OMAP2_RM_RSTST) & 0x7f; <nl>  	if (cpu_is_omap44xx()) <nl>  		return prm_read_mod_reg(WKUP_MOD, OMAP4_RM_RSTST) & 0x7f; <nl> + <nl> +	return 0; <nl>  } <nl>  EXPORT_SYMBOL(omap_prcm_get_reset_sources); <nl>   <nl>  /* Resets clock rates and reboots the system. Only called from system.h */ <nl>  void omap_prcm_arch_reset(char mode) <nl>  { <nl> -	s16 prcm_offs; <nl> +	s16 prcm_offs = 0; <nl>   <nl>  	if (cpu_is_omap24xx()) { <nl>  		omap2xxx_clk_prepare_for_reboot();
@@ -195,7 +195,7 @@ static void disable_lapic_nmi_watchdog(void) <nl>  			wrmsr(MSR_P6_EVNTSEL0, 0, 0); <nl>  			break; <nl>  		case 15: <nl> -			if (boot_cpu_data.x86_model > 0x3) <nl> +			if (boot_cpu_data.x86_model > 0x4) <nl>  				break; <nl>   <nl>  			wrmsr(MSR_P4_IQ_CCCR0, 0, 0); <nl> @@ -432,7 +432,7 @@ void setup_apic_nmi_watchdog (void) <nl>  			setup_p6_watchdog(); <nl>  			break; <nl>  		case 15: <nl> -			if (boot_cpu_data.x86_model > 0x3) <nl> +			if (boot_cpu_data.x86_model > 0x4) <nl>  				return; <nl>   <nl>  			if (!setup_p4_watchdog())
@@ -101,6 +101,11 @@ static int amd_create_gatt_pages(int nr_tables) <nl>  	for (i = 0; i < nr_tables; i++) { <nl>  		entry = kzalloc(sizeof(struct amd_page_map), GFP_KERNEL); <nl>  		if (entry == NULL) { <nl> +			while (i > 0) { <nl> +				kfree(tables[i-1]); <nl> +				i--; <nl> +			} <nl> +			kfree(tables); <nl>  			retval = -ENOMEM; <nl>  			break; <nl>  		}
@@ -43,7 +43,8 @@ <nl>  #define NFULNL_NLBUFSIZ_DEFAULT	NLMSG_GOODSIZE <nl>  #define NFULNL_TIMEOUT_DEFAULT 	100	/* every second */ <nl>  #define NFULNL_QTHRESH_DEFAULT 	100	/* 100 packets */ <nl> -#define NFULNL_COPY_RANGE_MAX	0xFFFF	/* max packet size is limited by 16-bit struct nfattr nfa_len field */ <nl> +/* max packet size is limited by 16-bit struct nfattr nfa_len field */ <nl> +#define NFULNL_COPY_RANGE_MAX	(0xFFFF - NLA_HDRLEN) <nl>   <nl>  #define PRINTR(x, args...)	do { if (net_ratelimit()) \ <nl>  				     printk(x, ## args); } while (0); <nl> @@ -252,6 +253,8 @@ nfulnl_set_mode(struct nfulnl_instance *inst, u_int8_t mode, <nl>   <nl>  	case NFULNL_COPY_PACKET: <nl>  		inst->copy_mode = mode; <nl> +		if (range == 0) <nl> +			range = NFULNL_COPY_RANGE_MAX; <nl>  		inst->copy_range = min_t(unsigned int, <nl>  					 range, NFULNL_COPY_RANGE_MAX); <nl>  		break; <nl> @@ -679,8 +682,7 @@ nfulnl_log_packet(struct net *net, <nl>  		break; <nl>   <nl>  	case NFULNL_COPY_PACKET: <nl> -		if (inst->copy_range == 0 <nl> -		    || inst->copy_range > skb->len) <nl> +		if (inst->copy_range > skb->len) <nl>  			data_len = skb->len; <nl>  		else <nl>  			data_len = inst->copy_range;
@@ -1688,15 +1688,19 @@ int vmw_du_page_flip(struct drm_crtc *crtc, <nl>  	struct vmw_private *dev_priv = vmw_priv(crtc->dev); <nl>  	struct drm_framebuffer *old_fb = crtc->fb; <nl>  	struct vmw_framebuffer *vfb = vmw_framebuffer_to_vfb(fb); <nl> -	struct drm_file *file_priv = event->base.file_priv; <nl> +	struct drm_file *file_priv ; <nl>  	struct vmw_fence_obj *fence = NULL; <nl>  	struct drm_clip_rect clips; <nl>  	int ret; <nl>   <nl> +	if (event == NULL) <nl> +		return -EINVAL; <nl> + <nl>  	/* require ScreenObject support for page flipping */ <nl>  	if (!dev_priv->sou_priv) <nl>  		return -ENOSYS; <nl>   <nl> +	file_priv = event->base.file_priv; <nl>  	if (!vmw_kms_screen_object_flippable(dev_priv, crtc)) <nl>  		return -EINVAL; <nl>  
@@ -29,6 +29,7 @@ <nl>  #include <linux/nmi.h> <nl>  #include <linux/delay.h> <nl>  #include <linux/mm.h> <nl> +#include <linux/security.h> <nl>  #include <asm/unaligned.h> <nl>   <nl>  #include "apei-internal.h" <nl> @@ -521,6 +522,9 @@ static int einj_error_inject(u32 type, u32 flags, u64 param1, u64 param2, <nl>  	int rc; <nl>  	u64 base_addr, size; <nl>   <nl> +	if (get_securelevel() > 0) <nl> +		return -EPERM; <nl> + <nl>  	/* If user manually set "flags", make sure it is legal */ <nl>  	if (flags && (flags & <nl>  		~(SETWA_FLAGS_APICID|SETWA_FLAGS_MEM|SETWA_FLAGS_PCIE_SBDF)))
@@ -506,6 +506,8 @@ static void perf_syscall_enter(void *ignore, struct pt_regs *regs, long id) <nl>  	int size; <nl>   <nl>  	syscall_nr = syscall_get_nr(current, regs); <nl> +	if (syscall_nr < 0) <nl> +		return; <nl>  	if (!test_bit(syscall_nr, enabled_perf_enter_syscalls)) <nl>  		return; <nl>   <nl> @@ -580,6 +582,8 @@ static void perf_syscall_exit(void *ignore, struct pt_regs *regs, long ret) <nl>  	int size; <nl>   <nl>  	syscall_nr = syscall_get_nr(current, regs); <nl> +	if (syscall_nr < 0) <nl> +		return; <nl>  	if (!test_bit(syscall_nr, enabled_perf_exit_syscalls)) <nl>  		return; <nl>  
@@ -2824,6 +2824,7 @@ disable_sriov: <nl>  free_mem: <nl>  	dev->persist->num_vfs = 0; <nl>  	kfree(dev->dev_vfs); <nl> +        dev->dev_vfs = NULL; <nl>  	return dev_flags & ~MLX4_FLAG_MASTER; <nl>  } <nl>  
@@ -1475,7 +1475,7 @@ static int br_multicast_ipv6_rcv(struct net_bridge *br, <nl>  	    ip6h->payload_len == 0) <nl>  		return 0; <nl>   <nl> -	len = ntohs(ip6h->payload_len); <nl> +	len = ntohs(ip6h->payload_len) + sizeof(*ip6h); <nl>  	if (skb->len < len) <nl>  		return -EINVAL; <nl>  
@@ -1075,8 +1075,8 @@ static int bm_rw(struct drbd_conf *mdev, int rw, unsigned flags, unsigned lazy_w <nl>   <nl>  	if (!get_ldev_if_state(mdev, D_ATTACHING)) {  /* put is in bm_aio_ctx_destroy() */ <nl>  		dev_err(DEV, "ASSERT FAILED: get_ldev_if_state() == 1 in bm_rw()\n"); <nl> -		err = -ENODEV; <nl> -		goto out; <nl> +		kfree(ctx); <nl> +		return -ENODEV; <nl>  	} <nl>   <nl>  	if (!ctx->flags) <nl> @@ -1156,7 +1156,6 @@ static int bm_rw(struct drbd_conf *mdev, int rw, unsigned flags, unsigned lazy_w <nl>  		dev_info(DEV, "%s (%lu bits) marked out-of-sync by on disk bit-map.\n", <nl>  		     ppsize(ppb, now << (BM_BLOCK_SHIFT-10)), now); <nl>   <nl> -out: <nl>  	kref_put(&ctx->kref, &bm_aio_ctx_destroy); <nl>  	return err; <nl>  } <nl> @@ -1237,8 +1236,8 @@ int drbd_bm_write_page(struct drbd_conf *mdev, unsigned int idx) __must_hold(loc <nl>   <nl>  	if (!get_ldev_if_state(mdev, D_ATTACHING)) {  /* put is in bm_aio_ctx_destroy() */ <nl>  		dev_err(DEV, "ASSERT FAILED: get_ldev_if_state() == 1 in drbd_bm_write_page()\n"); <nl> -		err = -ENODEV; <nl> -		goto out; <nl> +		kfree(ctx); <nl> +		return -ENODEV; <nl>  	} <nl>   <nl>  	bm_page_io_async(ctx, idx, WRITE_SYNC); <nl> @@ -1251,7 +1250,6 @@ int drbd_bm_write_page(struct drbd_conf *mdev, unsigned int idx) __must_hold(loc <nl>   <nl>  	mdev->bm_writ_cnt++; <nl>  	err = atomic_read(&ctx->in_flight) ? -EIO : ctx->error; <nl> - out: <nl>  	kref_put(&ctx->kref, &bm_aio_ctx_destroy); <nl>  	return err; <nl>  }
@@ -154,6 +154,11 @@ u16 ieee80211_select_queue(struct ieee80211_sub_if_data *sdata, <nl>  		return IEEE80211_AC_BE; <nl>  	} <nl>   <nl> +	if (skb->protocol == sdata->control_port_protocol) { <nl> +		skb->priority = 7; <nl> +		return ieee80211_downgrade_queue(sdata, skb); <nl> +	} <nl> + <nl>  	/* use the data classifier to determine what 802.1d tag the <nl>  	 * data frame has */ <nl>  	rcu_read_lock();
@@ -131,7 +131,7 @@ static bool tcp_fastopen_create_child(struct sock *sk, <nl>  				      struct dst_entry *dst, <nl>  				      struct request_sock *req) <nl>  { <nl> -	struct tcp_sock *tp = tcp_sk(sk); <nl> +	struct tcp_sock *tp; <nl>  	struct request_sock_queue *queue = &inet_csk(sk)->icsk_accept_queue; <nl>  	struct sock *child; <nl>  
@@ -5914,6 +5914,8 @@ allocate_trace_buffer(struct trace_array *tr, struct trace_buffer *buf, int size <nl>   <nl>  	rb_flags = trace_flags & TRACE_ITER_OVERWRITE ? RB_FL_OVERWRITE : 0; <nl>   <nl> +	buf->tr = tr; <nl> + <nl>  	buf->buffer = ring_buffer_alloc(size, rb_flags); <nl>  	if (!buf->buffer) <nl>  		return -ENOMEM;
@@ -52,7 +52,7 @@ static void qube_raq_via_bmIDE_fixup(struct pci_dev *dev) <nl>  	pci_read_config_byte(dev, PCI_LATENCY_TIMER, &lt); <nl>  	if (lt < 64) <nl>  		pci_write_config_byte(dev, PCI_LATENCY_TIMER, 64); <nl> -	pci_write_config_byte(dev, PCI_CACHE_LINE_SIZE, 7); <nl> +	pci_write_config_byte(dev, PCI_CACHE_LINE_SIZE, 8); <nl>  } <nl>   <nl>  DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_82C586_1, <nl> @@ -69,7 +69,7 @@ static void qube_raq_galileo_fixup(struct pci_dev *dev) <nl>  	 * host bridge. <nl>  	 */ <nl>  	pci_write_config_byte(dev, PCI_LATENCY_TIMER, 64); <nl> -	pci_write_config_byte(dev, PCI_CACHE_LINE_SIZE, 7); <nl> +	pci_write_config_byte(dev, PCI_CACHE_LINE_SIZE, 8); <nl>   <nl>  	/* <nl>  	 * The code described by the comment below has been removed
@@ -1590,10 +1590,12 @@ static int ath9k_sta_state(struct ieee80211_hw *hw, <nl>  	} <nl>   <nl>  	if (ath9k_is_chanctx_enabled()) { <nl> -		if (old_state == IEEE80211_STA_ASSOC && <nl> -		    new_state == IEEE80211_STA_AUTHORIZED) <nl> -			ath_chanctx_event(sc, vif, <nl> -					  ATH_CHANCTX_EVENT_AUTHORIZED); <nl> +		if (vif->type == NL80211_IFTYPE_STATION) { <nl> +			if (old_state == IEEE80211_STA_ASSOC && <nl> +			    new_state == IEEE80211_STA_AUTHORIZED) <nl> +				ath_chanctx_event(sc, vif, <nl> +						  ATH_CHANCTX_EVENT_AUTHORIZED); <nl> +		} <nl>  	} <nl>   <nl>  	return ret;
@@ -2310,6 +2310,7 @@ static int hpsa_ioctl32_passthru(struct scsi_device *dev, int cmd, void *arg) <nl>  	int err; <nl>  	u32 cp; <nl>   <nl> +	memset(&arg64, 0, sizeof(arg64)); <nl>  	err = 0; <nl>  	err |= copy_from_user(&arg64.LUN_info, &arg32->LUN_info, <nl>  			   sizeof(arg64.LUN_info)); <nl> @@ -2346,6 +2347,7 @@ static int hpsa_ioctl32_big_passthru(struct scsi_device *dev, <nl>  	int err; <nl>  	u32 cp; <nl>   <nl> +	memset(&arg64, 0, sizeof(arg64)); <nl>  	err = 0; <nl>  	err |= copy_from_user(&arg64.LUN_info, &arg32->LUN_info, <nl>  			   sizeof(arg64.LUN_info));
@@ -555,6 +555,8 @@ static int eql_g_master_cfg(struct net_device *dev, master_config_t __user *mcp) <nl>  	equalizer_t *eql; <nl>  	master_config_t mc; <nl>   <nl> +	memset(&mc, 0, sizeof(master_config_t)); <nl> + <nl>  	if (eql_is_master(dev)) { <nl>  		eql = netdev_priv(dev); <nl>  		mc.max_slaves = eql->max_slaves;
@@ -43,7 +43,7 @@ static cycle_t sb1250_hpt_read(void) <nl>  } <nl>   <nl>  struct clocksource bcm1250_clocksource = { <nl> -	.name	= "MIPS", <nl> +	.name	= "bcm1250-counter-3", <nl>  	.rating	= 200, <nl>  	.read	= sb1250_hpt_read, <nl>  	.mask	= CLOCKSOURCE_MASK(23),
@@ -84,13 +84,9 @@ static int dev_whitelist_copy(struct list_head *dest, struct list_head *orig) <nl>  	struct dev_whitelist_item *wh, *tmp, *new; <nl>   <nl>  	list_for_each_entry(wh, orig, list) { <nl> -		new = kmalloc(sizeof(*wh), GFP_KERNEL); <nl> +		new = kmemdup(wh, sizeof(*wh), GFP_KERNEL); <nl>  		if (!new) <nl>  			goto free_and_exit; <nl> -		new->major = wh->major; <nl> -		new->minor = wh->minor; <nl> -		new->type = wh->type; <nl> -		new->access = wh->access; <nl>  		list_add_tail(&new->list, dest); <nl>  	} <nl>   <nl> @@ -114,11 +110,10 @@ static int dev_whitelist_add(struct dev_cgroup *dev_cgroup, <nl>  { <nl>  	struct dev_whitelist_item *whcopy, *walk; <nl>   <nl> -	whcopy = kmalloc(sizeof(*whcopy), GFP_KERNEL); <nl> +	whcopy = kmemdup(wh, sizeof(*wh), GFP_KERNEL); <nl>  	if (!whcopy) <nl>  		return -ENOMEM; <nl>   <nl> -	memcpy(whcopy, wh, sizeof(*whcopy)); <nl>  	spin_lock(&dev_cgroup->lock); <nl>  	list_for_each_entry(walk, &dev_cgroup->whitelist, list) { <nl>  		if (walk->type != wh->type)
@@ -2228,7 +2228,7 @@ static int match_session(struct cifs_ses *ses, struct smb_vol *vol) <nl>  			    vol->username ? vol->username : "", <nl>  			    CIFS_MAX_USERNAME_LEN)) <nl>  			return 0; <nl> -		if (strlen(vol->username) != 0 && <nl> +		if ((vol->username && strlen(vol->username) != 0) && <nl>  		    ses->password != NULL && <nl>  		    strncmp(ses->password, <nl>  			    vol->password ? vol->password : "",
@@ -221,6 +221,7 @@ static int act8865_pdata_from_dt(struct device *dev, <nl>   <nl>  	matched = of_regulator_match(dev, np, <nl>  				act8865_matches, ARRAY_SIZE(act8865_matches)); <nl> +	of_node_put(np); <nl>  	if (matched <= 0) <nl>  		return matched; <nl>  
@@ -702,7 +702,7 @@ static int ni_660x_request_mite_channel(struct comedi_device *dev, <nl>  	BUG_ON(counter->mite_chan); <nl>  	mite_chan = mite_request_channel(devpriv->mite, <nl>  					 mite_ring(devpriv, counter)); <nl> -	if (mite_chan == NULL) { <nl> +	if (!mite_chan) { <nl>  		spin_unlock_irqrestore(&devpriv->mite_channel_lock, flags); <nl>  		dev_err(dev->class_dev, <nl>  			"failed to reserve mite dma channel for counter\n"); <nl> @@ -861,7 +861,7 @@ static int ni_660x_alloc_mite_rings(struct comedi_device *dev) <nl>  		for (j = 0; j < counters_per_chip; ++j) { <nl>  			devpriv->mite_rings[i][j] = <nl>  			    mite_alloc_ring(devpriv->mite); <nl> -			if (devpriv->mite_rings[i][j] == NULL) <nl> +			if (!devpriv->mite_rings[i][j]) <nl>  				return -ENOMEM; <nl>  		} <nl>  	} <nl> @@ -1107,7 +1107,7 @@ static int ni_660x_auto_attach(struct comedi_device *dev, <nl>  						     ni_gpct_variant_660x, <nl>  						     ni_660x_num_counters <nl>  						     (dev)); <nl> -	if (devpriv->counter_dev == NULL) <nl> +	if (!devpriv->counter_dev) <nl>  		return -ENOMEM; <nl>  	for (i = 0; i < NI_660X_MAX_NUM_COUNTERS; ++i) { <nl>  		s = &dev->subdevices[NI_660X_GPCT_SUBDEV(i)];
@@ -2956,6 +2956,9 @@ int i915_vma_unbind(struct i915_vma *vma) <nl>  	 * cause memory corruption through use-after-free. <nl>  	 */ <nl>   <nl> +	/* Throw away the active reference before moving to the unbound list */ <nl> +	i915_gem_object_retire(obj); <nl> + <nl>  	if (i915_is_ggtt(vma->vm)) { <nl>  		i915_gem_object_finish_gtt(obj); <nl>  
@@ -169,7 +169,7 @@ static int map_lookup_elem(union bpf_attr *attr) <nl>  	if (copy_from_user(key, ukey, map->key_size) != 0) <nl>  		goto free_key; <nl>   <nl> -	err = -ESRCH; <nl> +	err = -ENOENT; <nl>  	rcu_read_lock(); <nl>  	value = map->ops->map_lookup_elem(map, key); <nl>  	if (!value)
@@ -2057,8 +2057,10 @@ static int __exit usba_udc_remove(struct platform_device *pdev) <nl>  		usba_ep_cleanup_debugfs(&usba_ep[i]); <nl>  	usba_cleanup_debugfs(udc); <nl>   <nl> -	if (gpio_is_valid(udc->vbus_pin)) <nl> +	if (gpio_is_valid(udc->vbus_pin)) { <nl> +		free_irq(gpio_to_irq(udc->vbus_pin), udc); <nl>  		gpio_free(udc->vbus_pin); <nl> +	} <nl>   <nl>  	free_irq(udc->irq, udc); <nl>  	kfree(usba_ep);
@@ -36,6 +36,7 @@ <nl>  #include <linux/init.h> <nl>  #include <linux/kmod.h> <nl>  #include <linux/slab.h> <nl> +#include <linux/smp_lock.h> <nl>  #include <asm/uaccess.h> <nl>  #include <asm/system.h> <nl>   <nl> @@ -496,6 +497,7 @@ static int video_open(struct inode *inode, struct file *file) <nl>   <nl>  	if(minor>=VIDEO_NUM_DEVICES) <nl>  		return -ENODEV; <nl> +	lock_kernel(); <nl>  	mutex_lock(&videodev_lock); <nl>  	vfl=video_device[minor]; <nl>  	if(vfl==NULL) { <nl> @@ -505,6 +507,7 @@ static int video_open(struct inode *inode, struct file *file) <nl>  		vfl=video_device[minor]; <nl>  		if (vfl==NULL) { <nl>  			mutex_unlock(&videodev_lock); <nl> +			unlock_kernel(); <nl>  			return -ENODEV; <nl>  		} <nl>  	} <nl> @@ -518,6 +521,7 @@ static int video_open(struct inode *inode, struct file *file) <nl>  	} <nl>  	fops_put(old_fops); <nl>  	mutex_unlock(&videodev_lock); <nl> +	unlock_kernel(); <nl>  	return err; <nl>  } <nl>  
@@ -1934,8 +1934,7 @@ static int reiserfs_fill_super(struct super_block *s, void *data, int silent) <nl>  			if (SB_AP_BITMAP(s)) <nl>  				brelse(SB_AP_BITMAP(s)[j].bh); <nl>  		} <nl> -		if (SB_AP_BITMAP(s)) <nl> -			vfree(SB_AP_BITMAP(s)); <nl> +		vfree(SB_AP_BITMAP(s)); <nl>  	} <nl>  	if (SB_BUFFER_WITH_SB(s)) <nl>  		brelse(SB_BUFFER_WITH_SB(s));
@@ -606,11 +606,14 @@ static int el3_start_xmit(struct sk_buff *skb, struct net_device *dev) <nl>  { <nl>      kio_addr_t ioaddr = dev->base_addr; <nl>      struct el3_private *priv = netdev_priv(dev); <nl> +    unsigned long flags; <nl>   <nl>      DEBUG(3, "%s: el3_start_xmit(length = %ld) called, " <nl>  	  "status %4.4x.\n", dev->name, (long)skb->len, <nl>  	  inw(ioaddr + EL3_STATUS)); <nl>   <nl> +    spin_lock_irqsave(&priv->lock, flags);     <nl> + <nl>      priv->stats.tx_bytes += skb->len; <nl>   <nl>      /* Put out the doubleword header... */ <nl> @@ -628,6 +631,7 @@ static int el3_start_xmit(struct sk_buff *skb, struct net_device *dev) <nl>   <nl>      dev_kfree_skb(skb); <nl>      pop_tx_status(dev); <nl> +    spin_unlock_irqrestore(&priv->lock, flags);     <nl>       <nl>      return 0; <nl>  } <nl> @@ -729,14 +733,13 @@ static void media_check(unsigned long arg) <nl>   <nl>      if (!netif_device_present(dev)) goto reschedule; <nl>   <nl> -    EL3WINDOW(1); <nl>      /* Check for pending interrupt with expired latency timer: with <nl>         this, we can limp along even if the interrupt is blocked */ <nl>      if ((inw(ioaddr + EL3_STATUS) & IntLatch) && <nl>  	(inb(ioaddr + EL3_TIMER) == 0xff)) { <nl>  	if (!lp->fast_poll) <nl>  	    printk(KERN_WARNING "%s: interrupt(s) dropped!\n", dev->name); <nl> -	el3_interrupt(dev->irq, lp); <nl> +	el3_interrupt(dev->irq, dev); <nl>  	lp->fast_poll = HZ; <nl>      } <nl>      if (lp->fast_poll) {
@@ -1348,7 +1348,9 @@ static int btusb_setup_csr(struct hci_dev *hdev) <nl>   <nl>  	rp = (struct hci_rp_read_local_version *)skb->data; <nl>   <nl> -	if (le16_to_cpu(rp->manufacturer) != 10) { <nl> +	/* Detect controllers which aren't real CSR ones. */ <nl> +	if (le16_to_cpu(rp->manufacturer) != 10 || <nl> +	    le16_to_cpu(rp->lmp_subver) == 0x0c5c) { <nl>  		/* Clear the reset quirk since this is not an actual <nl>  		 * early Bluetooth 1.1 device from CSR. <nl>  		 */ <nl> @@ -2782,7 +2784,7 @@ static int btusb_probe(struct usb_interface *intf, <nl>  			set_bit(HCI_QUIRK_RESET_ON_CLOSE, &hdev->quirks); <nl>   <nl>  		/* Fake CSR devices with broken commands */ <nl> -		if (bcdDevice <= 0x100) <nl> +		if (bcdDevice <= 0x100 || bcdDevice == 0x134) <nl>  			hdev->setup = btusb_setup_csr; <nl>   <nl>  		set_bit(HCI_QUIRK_SIMULTANEOUS_DISCOVERY, &hdev->quirks);
@@ -28,6 +28,7 @@ void *consistent_alloc(gfp_t gfp, size_t size, dma_addr_t *handle) <nl>  	split_page(page, order); <nl>   <nl>  	ret = page_address(page); <nl> +	memset(ret, 0, size); <nl>  	*handle = virt_to_phys(ret); <nl>   <nl>  	/*
@@ -274,7 +274,7 @@ static int FNAME(fix_write_pf)(struct kvm_vcpu *vcpu, <nl>  	struct kvm_mmu_page *page; <nl>   <nl>  	if (is_writeble_pte(*shadow_ent)) <nl> -		return 0; <nl> +		return !user || (*shadow_ent & PT_USER_MASK); <nl>   <nl>  	writable_shadow = *shadow_ent & PT_SHADOW_WRITABLE_MASK; <nl>  	if (user) {
@@ -128,6 +128,7 @@ nouveau_cli_destroy(struct nouveau_cli *cli) <nl>  	nvkm_vm_ref(NULL, &nvxx_client(&cli->base)->vm, NULL); <nl>  	nvif_client_fini(&cli->base); <nl>  	usif_client_fini(cli); <nl> +	kfree(cli); <nl>  } <nl>   <nl>  static void
@@ -479,6 +479,9 @@ static int _search_rsb(struct dlm_ls *ls, char *name, int len, int b, <nl>  		kref_get(&r->res_ref); <nl>  		goto out; <nl>  	} <nl> +	if (error == -ENOTBLK) <nl> +		goto out; <nl> + <nl>  	error = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].toss, name, len, flags, &r); <nl>  	if (error) <nl>  		goto out;
@@ -426,7 +426,7 @@ static int snd_usb_cm106_boot_quirk(struct usb_device *dev) <nl>   */ <nl>  static int snd_usb_cm6206_boot_quirk(struct usb_device *dev) <nl>  { <nl> -	int err, reg; <nl> +	int err  = 0, reg; <nl>  	int val[] = {0x2004, 0x3000, 0xf800, 0x143f, 0x0000, 0x3000}; <nl>   <nl>  	for (reg = 0; reg < ARRAY_SIZE(val); reg++) {
@@ -111,6 +111,7 @@ struct mxs_dma_chan { <nl>  	int				chan_irq; <nl>  	struct mxs_dma_ccw		*ccw; <nl>  	dma_addr_t			ccw_phys; <nl> +	int				desc_count; <nl>  	dma_cookie_t			last_completed; <nl>  	enum dma_status			status; <nl>  	unsigned int			flags; <nl> @@ -386,7 +387,7 @@ static struct dma_async_tx_descriptor *mxs_dma_prep_slave_sg( <nl>  	struct scatterlist *sg; <nl>  	int i, j; <nl>  	u32 *pio; <nl> -	static int idx; <nl> +	int idx = append ? mxs_chan->desc_count : 0; <nl>   <nl>  	if (mxs_chan->status == DMA_IN_PROGRESS && !append) <nl>  		return NULL; <nl> @@ -462,6 +463,7 @@ static struct dma_async_tx_descriptor *mxs_dma_prep_slave_sg( <nl>  			} <nl>  		} <nl>  	} <nl> +	mxs_chan->desc_count = idx; <nl>   <nl>  	return &mxs_chan->desc; <nl>   <nl> @@ -523,6 +525,7 @@ static struct dma_async_tx_descriptor *mxs_dma_prep_dma_cyclic( <nl>   <nl>  		i++; <nl>  	} <nl> +	mxs_chan->desc_count = i; <nl>   <nl>  	return &mxs_chan->desc; <nl>  
@@ -167,7 +167,8 @@ static struct nlm_host *nlm_lookup_host(struct nlm_lookup_host_info *ni) <nl>  			continue; <nl>  		if (host->h_server != ni->server) <nl>  			continue; <nl> -		if (!nlm_cmp_addr(nlm_srcaddr(host), ni->src_sap)) <nl> +		if (ni->server && <nl> +		    !nlm_cmp_addr(nlm_srcaddr(host), ni->src_sap)) <nl>  			continue; <nl>   <nl>  		/* Move to head of hash chain. */
@@ -911,8 +911,10 @@ static void iwl_ucode_callback(const struct firmware *ucode_raw, void *context) <nl>  		const struct iwl_op_mode_ops *ops = op->ops; <nl>  		drv->op_mode = ops->start(drv->trans, drv->cfg, &drv->fw); <nl>   <nl> -		if (!drv->op_mode) <nl> +		if (!drv->op_mode) { <nl> +			mutex_unlock(&iwlwifi_opmode_table_mtx); <nl>  			goto out_unbind; <nl> +		} <nl>  	} else { <nl>  		load_module = true; <nl>  	}
@@ -2960,6 +2960,7 @@ ath5k_deinit_softc(struct ath5k_softc *sc) <nl>  	 * state and potentially want to use them. <nl>  	 */ <nl>  	ath5k_hw_deinit(sc->ah); <nl> +	kfree(sc->ah); <nl>  	free_irq(sc->irq, sc); <nl>  } <nl>  
@@ -1208,6 +1208,14 @@ static int udf_load_partdesc(struct super_block *sb, sector_t block) <nl>  	ret = udf_fill_partdesc_info(sb, p, i); <nl>  	if (ret) <nl>  		goto out_bh; <nl> +	/* <nl> +	 * Mark filesystem read-only if we have a partition with virtual map <nl> +	 * since we don't handle writing to it (we overwrite blocks instead of <nl> +	 * relocating them). <nl> +	 */ <nl> +	sb->s_flags |= MS_RDONLY; <nl> +	printk(KERN_NOTICE "UDF-fs: Filesystem marked read-only because " <nl> +		"writing to pseudooverwrite partition is not implemented.\n"); <nl>   <nl>  	ret = udf_load_vat(sb, i, type1_idx); <nl>  out_bh:
@@ -1872,6 +1872,8 @@ static int fec_enet_mii_probe(struct net_device *ndev) <nl>  		phy_dev = of_phy_connect(ndev, fep->phy_node, <nl>  					 &fec_enet_adjust_link, 0, <nl>  					 fep->phy_interface); <nl> +		if (!phy_dev) <nl> +			return -ENODEV; <nl>  	} else { <nl>  		/* check for attached phy */ <nl>  		for (phy_id = 0; (phy_id < PHY_MAX_ADDR); phy_id++) {
@@ -980,7 +980,7 @@ int tpm_open(struct inode *inode, struct file *file) <nl>  		return -EBUSY; <nl>  	} <nl>   <nl> -	chip->data_buffer = kmalloc(TPM_BUFSIZE * sizeof(u8), GFP_KERNEL); <nl> +	chip->data_buffer = kzalloc(TPM_BUFSIZE, GFP_KERNEL); <nl>  	if (chip->data_buffer == NULL) { <nl>  		clear_bit(0, &chip->is_open); <nl>  		put_device(chip->dev);
@@ -185,7 +185,7 @@ static int __do_index(struct sw842_param *p, u8 size, u8 bits, u64 fsize) <nl>  		/* this is where the current fifo is */ <nl>  		u64 section = round_down(total, fsize); <nl>  		/* the current pos in the fifo */ <nl> -		u64 pos = total % fsize; <nl> +		u64 pos = total - section; <nl>   <nl>  		/* if the offset is past/at the pos, we need to <nl>  		 * go back to the last fifo section
@@ -340,7 +340,7 @@ static void line6_data_received(struct urb *urb) <nl>  		line6->message_length = done; <nl>  		line6_midi_receive(line6, line6->buffer_message, done); <nl>   <nl> -		switch (line6->usbdev->descriptor.idProduct) { <nl> +		switch (le16_to_cpu(line6->usbdev->descriptor.idProduct)) { <nl>  		case LINE6_DEVID_BASSPODXT: <nl>  		case LINE6_DEVID_BASSPODXTLIVE: <nl>  		case LINE6_DEVID_BASSPODXTPRO: <nl> @@ -1010,7 +1010,7 @@ static void line6_disconnect(struct usb_interface *interface) <nl>  			dev_err(line6->ifcdev, <nl>  				"driver bug: inconsistent usb device\n"); <nl>   <nl> -		switch (line6->usbdev->descriptor.idProduct) { <nl> +		switch (le16_to_cpu(line6->usbdev->descriptor.idProduct)) { <nl>  		case LINE6_DEVID_BASSPODXT: <nl>  		case LINE6_DEVID_BASSPODXTLIVE: <nl>  		case LINE6_DEVID_BASSPODXTPRO: <nl> @@ -1114,7 +1114,7 @@ static int line6_reset_resume(struct usb_interface *interface) <nl>  { <nl>  	struct usb_line6 *line6 = usb_get_intfdata(interface); <nl>   <nl> -	switch (line6->usbdev->descriptor.idProduct) { <nl> +	switch (le16_to_cpu(line6->usbdev->descriptor.idProduct)) { <nl>  	case LINE6_DEVID_PODSTUDIO_GX: <nl>  	case LINE6_DEVID_PODSTUDIO_UX1: <nl>  	case LINE6_DEVID_PODSTUDIO_UX2:
@@ -487,6 +487,9 @@ omap2_mcspi_txrx_pio(struct spi_device *spi, struct spi_transfer *xfer) <nl>  	rx_reg		= base + OMAP2_MCSPI_RX0; <nl>  	chstat_reg	= base + OMAP2_MCSPI_CHSTAT0; <nl>   <nl> +	if (c < (word_len>>3)) <nl> +		return 0; <nl> + <nl>  	if (word_len <= 8) { <nl>  		u8		*rx; <nl>  		const u8	*tx; <nl> @@ -534,7 +537,7 @@ omap2_mcspi_txrx_pio(struct spi_device *spi, struct spi_transfer *xfer) <nl>  				dev_vdbg(&spi->dev, "read-%d %02x\n", <nl>  						word_len, *(rx - 1)); <nl>  			} <nl> -		} while (c); <nl> +		} while (c > (word_len>>3)); <nl>  	} else if (word_len <= 16) { <nl>  		u16		*rx; <nl>  		const u16	*tx; <nl> @@ -581,7 +584,7 @@ omap2_mcspi_txrx_pio(struct spi_device *spi, struct spi_transfer *xfer) <nl>  				dev_vdbg(&spi->dev, "read-%d %04x\n", <nl>  						word_len, *(rx - 1)); <nl>  			} <nl> -		} while (c); <nl> +		} while (c > (word_len>>3)); <nl>  	} else if (word_len <= 32) { <nl>  		u32		*rx; <nl>  		const u32	*tx; <nl> @@ -628,7 +631,7 @@ omap2_mcspi_txrx_pio(struct spi_device *spi, struct spi_transfer *xfer) <nl>  				dev_vdbg(&spi->dev, "read-%d %08x\n", <nl>  						word_len, *(rx - 1)); <nl>  			} <nl> -		} while (c); <nl> +		} while (c > (word_len>>3)); <nl>  	} <nl>   <nl>  	/* for TX_ONLY mode, be sure all words have shifted out */
@@ -549,7 +549,6 @@ static unsigned char swap_entry_free(struct swap_info_struct *p, <nl>   <nl>  	/* free if no reference */ <nl>  	if (!usage) { <nl> -		struct gendisk *disk = p->bdev->bd_disk; <nl>  		if (offset < p->lowest_bit) <nl>  			p->lowest_bit = offset; <nl>  		if (offset > p->highest_bit) <nl> @@ -560,9 +559,12 @@ static unsigned char swap_entry_free(struct swap_info_struct *p, <nl>  		nr_swap_pages++; <nl>  		p->inuse_pages--; <nl>  		frontswap_invalidate_page(p->type, offset); <nl> -		if ((p->flags & SWP_BLKDEV) && <nl> -				disk->fops->swap_slot_free_notify) <nl> -			disk->fops->swap_slot_free_notify(p->bdev, offset); <nl> +		if (p->flags & SWP_BLKDEV) { <nl> +			struct gendisk *disk = p->bdev->bd_disk; <nl> +			if (disk->fops->swap_slot_free_notify) <nl> +				disk->fops->swap_slot_free_notify(p->bdev, <nl> +								  offset); <nl> +		} <nl>  	} <nl>   <nl>  	return usage;
@@ -532,9 +532,8 @@ void zd_mac_tx_failed(struct urb *urb) <nl>  		tx_hdr = (struct ieee80211_hdr *)skb->data; <nl>   <nl>  		/* we skip all frames not matching the reported destination */ <nl> -		if (unlikely(memcmp(tx_hdr->addr1, tx_status->mac, ETH_ALEN))) { <nl> +		if (unlikely(!ether_addr_equal(tx_hdr->addr1, tx_status->mac))) <nl>  			continue; <nl> -		} <nl>   <nl>  		/* we skip all frames not matching the reported final rate */ <nl>   <nl> @@ -997,7 +996,7 @@ static int filter_ack(struct ieee80211_hw *hw, struct ieee80211_hdr *rx_hdr, <nl>  		    continue; <nl>   <nl>  		tx_hdr = (struct ieee80211_hdr *)skb->data; <nl> -		if (likely(!memcmp(tx_hdr->addr2, rx_hdr->addr1, ETH_ALEN))) <nl> +		if (likely(ether_addr_equal(tx_hdr->addr2, rx_hdr->addr1))) <nl>  		{ <nl>  			found = 1; <nl>  			break;
@@ -1943,7 +1943,7 @@ static struct imon_context *imon_init_intf0(struct usb_interface *intf) <nl>  	return ictx; <nl>   <nl>  urb_submit_failed: <nl> -	input_unregister_device(ictx->idev); <nl> +	ir_input_unregister(ictx->idev); <nl>  	input_free_device(ictx->idev); <nl>  idev_setup_failed: <nl>  find_endpoint_failed: <nl> @@ -2306,7 +2306,7 @@ static void __devexit imon_disconnect(struct usb_interface *interface) <nl>  	if (ifnum == 0) { <nl>  		ictx->dev_present_intf0 = false; <nl>  		usb_kill_urb(ictx->rx_urb_intf0); <nl> -		input_unregister_device(ictx->idev); <nl> +		ir_input_unregister(ictx->idev); <nl>  		if (ictx->display_supported) { <nl>  			if (ictx->display_type == IMON_DISPLAY_TYPE_LCD) <nl>  				usb_deregister_dev(interface, &imon_lcd_class);
@@ -1294,7 +1294,7 @@ static int __devinit sdhci_probe_slot(struct pci_dev *pdev, int slot) <nl>   <nl>  	version = readw(host->ioaddr + SDHCI_HOST_VERSION); <nl>  	version = (version & SDHCI_SPEC_VER_MASK) >> SDHCI_SPEC_VER_SHIFT; <nl> -	if (version != 0) { <nl> +	if (version > 1) { <nl>  		printk(KERN_ERR "%s: Unknown controller version (%d). " <nl>  			"You may experience problems.\n", host->slot_descr, <nl>  			version);
@@ -379,7 +379,7 @@ static struct rtllib_qos_parameters def_qos_parameters = { <nl>  	{0, 0, 0, 0} <nl>  }; <nl>   <nl> -static void rtl8192_update_beacon(void *data) <nl> +static void _rtl92e_update_beacon(void *data) <nl>  { <nl>  	struct r8192_priv *priv = container_of_work_rsl(data, struct r8192_priv, <nl>  				  update_beacon_wq.work); <nl> @@ -1017,7 +1017,7 @@ static void _rtl92e_init_priv_task(struct net_device *dev) <nl>  	INIT_DELAYED_WORK_RSL(&priv->rfpath_check_wq, <nl>  			      (void *)rtl92e_dm_rf_pathcheck_wq, dev); <nl>  	INIT_DELAYED_WORK_RSL(&priv->update_beacon_wq, <nl> -			      (void *)rtl8192_update_beacon, dev); <nl> +			      (void *)_rtl92e_update_beacon, dev); <nl>  	INIT_WORK_RSL(&priv->qos_activate, (void *)_rtl92e_qos_activate, dev); <nl>  	INIT_DELAYED_WORK_RSL(&priv->rtllib->hw_wakeup_wq, <nl>  			      (void *) rtl92e_hw_wakeup_wq, dev);
@@ -279,7 +279,7 @@ static struct ath_buf* ath_clone_txbuf(struct ath_softc *sc, struct ath_buf *bf) <nl>  	tbf->aphy = bf->aphy; <nl>  	tbf->bf_mpdu = bf->bf_mpdu; <nl>  	tbf->bf_buf_addr = bf->bf_buf_addr; <nl> -	*(tbf->bf_desc) = *(bf->bf_desc); <nl> +	memcpy(tbf->bf_desc, bf->bf_desc, sc->sc_ah->caps.tx_desc_len); <nl>  	tbf->bf_state = bf->bf_state; <nl>  	tbf->bf_dmacontext = bf->bf_dmacontext; <nl>  
@@ -1225,7 +1225,7 @@ static int ravb_open(struct net_device *ndev) <nl>  	/* Device init */ <nl>  	error = ravb_dmac_init(ndev); <nl>  	if (error) <nl> -		goto out_free_irq; <nl> +		goto out_free_irq2; <nl>  	ravb_emac_init(ndev); <nl>   <nl>  	/* Initialise PTP Clock driver */ <nl> @@ -1243,9 +1243,11 @@ static int ravb_open(struct net_device *ndev) <nl>  out_ptp_stop: <nl>  	/* Stop PTP Clock driver */ <nl>  	ravb_ptp_stop(ndev); <nl> +out_free_irq2: <nl> +	if (priv->chip_id == RCAR_GEN3) <nl> +		free_irq(priv->emac_irq, ndev); <nl>  out_free_irq: <nl>  	free_irq(ndev->irq, ndev); <nl> -	free_irq(priv->emac_irq, ndev); <nl>  out_napi_off: <nl>  	napi_disable(&priv->napi[RAVB_NC]); <nl>  	napi_disable(&priv->napi[RAVB_BE]);
@@ -3705,8 +3705,10 @@ static int nct6775_probe(struct platform_device *pdev) <nl>  			data->have_temp |= 1 << i; <nl>  			data->have_temp_fixed |= 1 << i; <nl>  			data->reg_temp[0][i] = reg_temp_alternate[i]; <nl> -			data->reg_temp[1][i] = reg_temp_over[i]; <nl> -			data->reg_temp[2][i] = reg_temp_hyst[i]; <nl> +			if (i < num_reg_temp) { <nl> +				data->reg_temp[1][i] = reg_temp_over[i]; <nl> +				data->reg_temp[2][i] = reg_temp_hyst[i]; <nl> +			} <nl>  			data->temp_src[i] = i + 1; <nl>  			continue; <nl>  		}
@@ -263,14 +263,14 @@ static int get_victim_by_default(struct f2fs_sb_info *sbi, <nl>  	unsigned int secno, max_cost; <nl>  	int nsearched = 0; <nl>   <nl> +	mutex_lock(&dirty_i->seglist_lock); <nl> + <nl>  	p.alloc_mode = alloc_mode; <nl>  	select_policy(sbi, gc_type, type, &p); <nl>   <nl>  	p.min_segno = NULL_SEGNO; <nl>  	p.min_cost = max_cost = get_max_cost(sbi, &p); <nl>   <nl> -	mutex_lock(&dirty_i->seglist_lock); <nl> - <nl>  	if (p.alloc_mode == LFS && gc_type == FG_GC) { <nl>  		p.min_segno = check_bg_victims(sbi); <nl>  		if (p.min_segno != NULL_SEGNO)
@@ -2266,7 +2266,7 @@ static struct snd_pci_quirk stac927x_cfg_tbl[] = { <nl>  	SND_PCI_QUIRK(PCI_VENDOR_ID_DELL,  0x01f3, "Dell Inspiron 1420", STAC_DELL_BIOS), <nl>  	SND_PCI_QUIRK(PCI_VENDOR_ID_DELL,  0x0227, "Dell Vostro 1400  ", STAC_DELL_BIOS), <nl>  	SND_PCI_QUIRK(PCI_VENDOR_ID_DELL,  0x022e, "Dell     ", STAC_DELL_BIOS), <nl> -	SND_PCI_QUIRK(PCI_VENDOR_ID_DELL,  0x022f, "Dell Inspiron 1525", STAC_DELL_3ST), <nl> +	SND_PCI_QUIRK(PCI_VENDOR_ID_DELL,  0x022f, "Dell Inspiron 1525", STAC_DELL_BIOS), <nl>  	SND_PCI_QUIRK(PCI_VENDOR_ID_DELL,  0x0242, "Dell     ", STAC_DELL_BIOS), <nl>  	SND_PCI_QUIRK(PCI_VENDOR_ID_DELL,  0x0243, "Dell     ", STAC_DELL_BIOS), <nl>  	SND_PCI_QUIRK(PCI_VENDOR_ID_DELL,  0x02ff, "Dell     ", STAC_DELL_BIOS), <nl> @@ -5645,6 +5645,13 @@ static int patch_stac927x(struct hda_codec *codec) <nl>  		/* GPIO2 High = Enable EAPD */ <nl>  		spec->eapd_mask = spec->gpio_mask = spec->gpio_dir = 0x04; <nl>  		spec->gpio_data = 0x04; <nl> +		switch (codec->subsystem_id) { <nl> +		case 0x1028022f: <nl> +			/* correct EAPD to be GPIO0 */ <nl> +			spec->eapd_mask = spec->gpio_mask = 0x01; <nl> +			spec->gpio_dir = spec->gpio_data = 0x01; <nl> +			break; <nl> +		}; <nl>  		spec->dmic_nids = stac927x_dmic_nids; <nl>  		spec->num_dmics = STAC927X_NUM_DMICS; <nl>  
@@ -393,8 +393,10 @@ struct cpu_vfs_cap_data { <nl>  # define CAP_FULL_SET     ((kernel_cap_t){{ ~0, ~0 }}) <nl>  # define CAP_INIT_EFF_SET ((kernel_cap_t){{ ~CAP_TO_MASK(CAP_SETPCAP), ~0 }}) <nl>  # define CAP_FS_SET       ((kernel_cap_t){{ CAP_FS_MASK_B0, CAP_FS_MASK_B1 } }) <nl> -# define CAP_NFSD_SET     ((kernel_cap_t){{ CAP_FS_MASK_B0|CAP_TO_MASK(CAP_SYS_RESOURCE), \ <nl> -					CAP_FS_MASK_B1 } }) <nl> +# define CAP_NFSD_SET     ((kernel_cap_t){{ CAP_FS_MASK_B0 \ <nl> +					    | CAP_TO_MASK(CAP_SYS_RESOURCE) \ <nl> +					    | CAP_TO_MASK(CAP_MKNOD), \ <nl> +					    CAP_FS_MASK_B1 } }) <nl>   <nl>  #endif /* _KERNEL_CAPABILITY_U32S != 2 */ <nl>  
@@ -5616,8 +5616,13 @@ SYSCALL_DEFINE5(perf_event_open, <nl>  		} <nl>  	} <nl>   <nl> -	if (pid != -1) <nl> +	if (pid != -1) { <nl>  		task = find_lively_task_by_vpid(pid); <nl> +		if (IS_ERR(task)) { <nl> +			err = PTR_ERR(task); <nl> +			goto err_group_fd; <nl> +		} <nl> +	} <nl>   <nl>  	/* <nl>  	 * Get the target context (task or percpu):
@@ -163,9 +163,9 @@ static int twlreg_disable(struct regulator_dev *rdev) <nl>  		return grp; <nl>   <nl>  	if (twl_class_is_4030()) <nl> -		grp &= ~P1_GRP_4030; <nl> +		grp &= ~(P1_GRP_4030 | P2_GRP_4030 | P3_GRP_4030); <nl>  	else <nl> -		grp &= ~P1_GRP_6030; <nl> +		grp &= ~(P1_GRP_6030 | P2_GRP_6030 | P3_GRP_6030); <nl>   <nl>  	return twlreg_write(info, TWL_MODULE_PM_RECEIVER, VREG_GRP, grp); <nl>  }
@@ -442,14 +442,6 @@ static long psb_unlocked_ioctl(struct file *filp, unsigned int cmd, <nl>  	/* FIXME: do we need to wrap the other side of this */ <nl>  } <nl>   <nl> -/* <nl> - * When a client dies: <nl> - *    - Check for and clean up flipped page state <nl> - */ <nl> -static void psb_driver_preclose(struct drm_device *dev, struct drm_file *priv) <nl> -{ <nl> -} <nl> - <nl>  static int psb_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent) <nl>  { <nl>  	return drm_get_pci_dev(pdev, ent, &driver); <nl> @@ -495,7 +487,6 @@ static struct drm_driver driver = { <nl>  	.load = psb_driver_load, <nl>  	.unload = psb_driver_unload, <nl>  	.lastclose = psb_driver_lastclose, <nl> -	.preclose = psb_driver_preclose, <nl>  	.set_busid = drm_pci_set_busid, <nl>   <nl>  	.num_ioctls = ARRAY_SIZE(psb_ioctls),
@@ -835,7 +835,7 @@ static int omap_sham_finup(struct ahash_request *req) <nl>  	ctx->flags |= FLAGS_FINUP; <nl>   <nl>  	err1 = omap_sham_update(req); <nl> -	if (err1 == -EINPROGRESS) <nl> +	if (err1 == -EINPROGRESS || err1 == -EBUSY) <nl>  		return err1; <nl>  	/* <nl>  	 * final() has to be always called to cleanup resources
@@ -136,7 +136,11 @@ int __init brcmstb_l2_intc_of_init(struct device_node *np, <nl>   <nl>  	/* Disable all interrupts by default */ <nl>  	writel(0xffffffff, data->base + CPU_MASK_SET); <nl> -	writel(0xffffffff, data->base + CPU_CLEAR); <nl> + <nl> +	/* Wakeup interrupts may be retained from S5 (cold boot) */ <nl> +	data->can_wake = of_property_read_bool(np, "brcm,irq-can-wake"); <nl> +	if (!data->can_wake) <nl> +		writel(0xffffffff, data->base + CPU_CLEAR); <nl>   <nl>  	data->parent_irq = irq_of_parse_and_map(np, 0); <nl>  	if (!data->parent_irq) { <nl> @@ -188,8 +192,7 @@ int __init brcmstb_l2_intc_of_init(struct device_node *np, <nl>  	ct->chip.irq_suspend = brcmstb_l2_intc_suspend; <nl>  	ct->chip.irq_resume = brcmstb_l2_intc_resume; <nl>   <nl> -	if (of_property_read_bool(np, "brcm,irq-can-wake")) { <nl> -		data->can_wake = true; <nl> +	if (data->can_wake) { <nl>  		/* This IRQ chip can wake the system, set all child interrupts <nl>  		 * in wake_enabled mask <nl>  		 */
@@ -527,11 +527,12 @@ void batadv_gw_node_update(struct batadv_priv *bat_priv, <nl>  		 * gets dereferenced. <nl>  		 */ <nl>  		spin_lock_bh(&bat_priv->gw.list_lock); <nl> -		hlist_del_init_rcu(&gw_node->list); <nl> +		if (!hlist_unhashed(&gw_node->list)) { <nl> +			hlist_del_init_rcu(&gw_node->list); <nl> +			batadv_gw_node_free_ref(gw_node); <nl> +		} <nl>  		spin_unlock_bh(&bat_priv->gw.list_lock); <nl>   <nl> -		batadv_gw_node_free_ref(gw_node); <nl> - <nl>  		curr_gw = batadv_gw_get_selected_gw_node(bat_priv); <nl>  		if (gw_node == curr_gw) <nl>  			batadv_gw_reselect(bat_priv);
@@ -310,7 +310,7 @@ static int fsl_dma_new(struct snd_card *card, struct snd_soc_dai *dai, <nl>  	 * should allocate a DMA buffer only for the streams that are valid. <nl>  	 */ <nl>   <nl> -	if (dai->driver->playback.channels_min) { <nl> +	if (pcm->streams[0].substream) { <nl>  		ret = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, card->dev, <nl>  			fsl_dma_hardware.buffer_bytes_max, <nl>  			&pcm->streams[0].substream->dma_buffer); <nl> @@ -320,13 +320,13 @@ static int fsl_dma_new(struct snd_card *card, struct snd_soc_dai *dai, <nl>  		} <nl>  	} <nl>   <nl> -	if (dai->driver->capture.channels_min) { <nl> +	if (pcm->streams[1].substream) { <nl>  		ret = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, card->dev, <nl>  			fsl_dma_hardware.buffer_bytes_max, <nl>  			&pcm->streams[1].substream->dma_buffer); <nl>  		if (ret) { <nl> -			snd_dma_free_pages(&pcm->streams[0].substream->dma_buffer); <nl>  			dev_err(card->dev, "can't alloc capture dma buffer\n"); <nl> +			snd_dma_free_pages(&pcm->streams[0].substream->dma_buffer); <nl>  			return ret; <nl>  		} <nl>  	} <nl> @@ -449,7 +449,8 @@ static int fsl_dma_open(struct snd_pcm_substream *substream) <nl>  	dma_private->ld_buf_phys = ld_buf_phys; <nl>  	dma_private->dma_buf_phys = substream->dma_buffer.addr; <nl>   <nl> -	ret = request_irq(dma_private->irq, fsl_dma_isr, 0, "DMA", dma_private); <nl> +	ret = request_irq(dma_private->irq, fsl_dma_isr, 0, "fsldma-audio", <nl> +			  dma_private); <nl>  	if (ret) { <nl>  		dev_err(dev, "can't register ISR for IRQ %u (ret=%i)\n", <nl>  			dma_private->irq, ret);
@@ -561,9 +561,9 @@ static __kprobes void kprobe_optimizer(struct work_struct *work) <nl>  { <nl>  	LIST_HEAD(free_list); <nl>   <nl> +	mutex_lock(&kprobe_mutex); <nl>  	/* Lock modules while optimizing kprobes */ <nl>  	mutex_lock(&module_mutex); <nl> -	mutex_lock(&kprobe_mutex); <nl>   <nl>  	/* <nl>  	 * Step 1: Unoptimize kprobes and collect cleaned (unused and disarmed) <nl> @@ -586,8 +586,8 @@ static __kprobes void kprobe_optimizer(struct work_struct *work) <nl>  	/* Step 4: Free cleaned kprobes after quiesence period */ <nl>  	do_free_cleaned_kprobes(&free_list); <nl>   <nl> -	mutex_unlock(&kprobe_mutex); <nl>  	mutex_unlock(&module_mutex); <nl> +	mutex_unlock(&kprobe_mutex); <nl>   <nl>  	/* Step 5: Kick optimizer again if needed */ <nl>  	if (!list_empty(&optimizing_list) || !list_empty(&unoptimizing_list))
@@ -1563,6 +1563,7 @@ int ceph_osdc_create_event(struct ceph_osd_client *osdc, <nl>  	event->data = data; <nl>  	event->osdc = osdc; <nl>  	INIT_LIST_HEAD(&event->osd_node); <nl> +	RB_CLEAR_NODE(&event->node); <nl>  	kref_init(&event->kref);   /* one ref for us */ <nl>  	kref_get(&event->kref);    /* one ref for the caller */ <nl>  	init_completion(&event->completion);
@@ -209,7 +209,7 @@ static int preallocate_pmds(pmd_t *pmds[]) <nl>  		if (!pmd) <nl>  			failed = true; <nl>  		if (pmd && !pgtable_pmd_page_ctor(virt_to_page(pmd))) { <nl> -			free_page((unsigned long)pmds[i]); <nl> +			free_page((unsigned long)pmd); <nl>  			pmd = NULL; <nl>  			failed = true; <nl>  		}
@@ -1107,6 +1107,13 @@ UNUSUAL_DEV( 0x090a, 0x1200, 0x0000, 0x9999, <nl>  		USB_SC_RBC, USB_PR_BULK, NULL, <nl>  		0 ), <nl>   <nl> +/* Feiya QDI U2 DISK, reported by Hans de Goede <hdegoede@redhat.com> */ <nl> +UNUSUAL_DEV( 0x090c, 0x1000, 0x0000, 0xffff, <nl> +		"Feiya", <nl> +		"QDI U2 DISK", <nl> +		USB_SC_DEVICE, USB_PR_DEVICE, NULL, <nl> +		US_FL_NO_READ_CAPACITY_16 ), <nl> + <nl>  /* aeb */ <nl>  UNUSUAL_DEV( 0x090c, 0x1132, 0x0000, 0xffff, <nl>  		"Feiya",
@@ -95,7 +95,7 @@ <nl>  * slc_tac register definitions <nl>  **********************************************************************/ <nl>  /* Computation of clock cycles on basis of controller and device clock rates */ <nl> -#define SLCTAC_CLOCKS(c, n, s)	(min_t(u32, 1 + (c / n), 0xF) << s) <nl> +#define SLCTAC_CLOCKS(c, n, s)	(min_t(u32, DIV_ROUND_UP(c, n) - 1, 0xF) << s) <nl>   <nl>  /* Clock setting for RDY write sample wait time in 2*n clocks */ <nl>  #define SLCTAC_WDR(n)		(((n) & 0xF) << 28)
@@ -567,8 +567,11 @@ static int __cpuinit iucv_cpu_notify(struct notifier_block *self, <nl>  			return NOTIFY_BAD; <nl>  		iucv_param[cpu] = kmalloc_node(sizeof(union iucv_param), <nl>  				     GFP_KERNEL|GFP_DMA, cpu_to_node(cpu)); <nl> -		if (!iucv_param[cpu]) <nl> +		if (!iucv_param[cpu]) { <nl> +			kfree(iucv_irq_data[cpu]); <nl> +			iucv_irq_data[cpu] = NULL; <nl>  			return NOTIFY_BAD; <nl> +		} <nl>  		break; <nl>  	case CPU_UP_CANCELED: <nl>  	case CPU_UP_CANCELED_FROZEN:
@@ -2844,7 +2844,7 @@ static int tcam_wait_bit(struct niu *np, u64 bit) <nl>  			break; <nl>  		udelay(1); <nl>  	} <nl> -	if (limit < 0) <nl> +	if (limit <= 0) <nl>  		return -ENODEV; <nl>   <nl>  	return 0;
@@ -287,6 +287,7 @@ static void vmbus_process_offer(struct work_struct *work) <nl>  		spin_lock_irqsave(&vmbus_connection.channel_lock, flags); <nl>  		list_del(&newchannel->listentry); <nl>  		spin_unlock_irqrestore(&vmbus_connection.channel_lock, flags); <nl> +		kfree(newchannel->device_obj); <nl>   <nl>  		free_channel(newchannel); <nl>  	} else {
@@ -134,19 +134,21 @@ static __cpuinit int thermal_throttle_cpu_callback(struct notifier_block *nfb, <nl>  	int err; <nl>   <nl>  	sys_dev = get_cpu_sysdev(cpu); <nl> -	mutex_lock(&therm_cpu_lock); <nl>  	switch (action) { <nl>  	case CPU_ONLINE: <nl>  	case CPU_ONLINE_FROZEN: <nl> +		mutex_lock(&therm_cpu_lock); <nl>  		err = thermal_throttle_add_dev(sys_dev); <nl> +		mutex_unlock(&therm_cpu_lock); <nl>  		WARN_ON(err); <nl>  		break; <nl>  	case CPU_DEAD: <nl>  	case CPU_DEAD_FROZEN: <nl> +		mutex_lock(&therm_cpu_lock); <nl>  		thermal_throttle_remove_dev(sys_dev); <nl> +		mutex_unlock(&therm_cpu_lock); <nl>  		break; <nl>  	} <nl> -	mutex_unlock(&therm_cpu_lock); <nl>  	return NOTIFY_OK; <nl>  } <nl>  
@@ -447,9 +447,8 @@ retry: <nl>  	 * can remove the event safely, if the call above did not <nl>  	 * succeed. <nl>  	 */ <nl> -	if (!list_empty(&event->group_entry)) { <nl> +	if (!list_empty(&event->group_entry)) <nl>  		list_del_event(event, ctx); <nl> -	} <nl>  	spin_unlock_irq(&ctx->lock); <nl>  } <nl>   <nl> @@ -1033,10 +1032,10 @@ void __perf_event_sched_out(struct perf_event_context *ctx, <nl>  	update_context_time(ctx); <nl>   <nl>  	perf_disable(); <nl> -	if (ctx->nr_active) <nl> +	if (ctx->nr_active) { <nl>  		list_for_each_entry(event, &ctx->group_list, group_entry) <nl>  			group_sched_out(event, cpuctx, ctx); <nl> - <nl> +	} <nl>  	perf_enable(); <nl>   out: <nl>  	spin_unlock(&ctx->lock);
@@ -219,12 +219,14 @@ restart: <nl>  		if (radix_tree_deref_retry(entry)) <nl>  			goto restart; <nl>   <nl> -		irq = create_irq(); <nl> +		irq = irq_alloc_desc(numa_node_id()); <nl>  		if (unlikely(irq < 0)) { <nl>  			pr_err("no more free IRQs, bailing..\n"); <nl>  			break; <nl>  		} <nl>   <nl> +		activate_irq(irq); <nl> + <nl>  		pr_info("Setting up a chained VIRQ from %d -> %d\n", <nl>  			irq, entry->pirq); <nl>  
@@ -1122,8 +1122,6 @@ static void atom_execute_table_locked(struct atom_context *ctx, int index, uint3 <nl>   <nl>  	SDEBUG(">> execute %04X (len %d, WS %d, PS %d)\n", base, len, ws, ps); <nl>   <nl> -	/* reset reg block */ <nl> -	ctx->reg_block = 0; <nl>  	ectx.ctx = ctx; <nl>  	ectx.ps_shift = ps / 4; <nl>  	ectx.start = base; <nl> @@ -1160,6 +1158,12 @@ static void atom_execute_table_locked(struct atom_context *ctx, int index, uint3 <nl>  void atom_execute_table(struct atom_context *ctx, int index, uint32_t * params) <nl>  { <nl>  	mutex_lock(&ctx->mutex); <nl> +	/* reset reg block */ <nl> +	ctx->reg_block = 0; <nl> +	/* reset fb window */ <nl> +	ctx->fb_base = 0; <nl> +	/* reset io mode */ <nl> +	ctx->io_mode = ATOM_IO_MM; <nl>  	atom_execute_table_locked(ctx, index, params); <nl>  	mutex_unlock(&ctx->mutex); <nl>  }
@@ -452,7 +452,7 @@ void radeon_audio_enable(struct radeon_device *rdev, <nl>  } <nl>   <nl>  void radeon_audio_detect(struct drm_connector *connector, <nl> -	enum drm_connector_status status) <nl> +			 enum drm_connector_status status) <nl>  { <nl>  	struct radeon_device *rdev; <nl>  	struct radeon_encoder *radeon_encoder; <nl> @@ -483,6 +483,7 @@ void radeon_audio_detect(struct drm_connector *connector, <nl>  		else <nl>  			radeon_encoder->audio = rdev->audio.hdmi_funcs; <nl>   <nl> +		dig->afmt->pin = radeon_audio_get_pin(connector->encoder); <nl>  		radeon_audio_write_speaker_allocation(connector->encoder); <nl>  		radeon_audio_write_sad_regs(connector->encoder); <nl>  		if (connector->encoder->crtc) <nl> @@ -491,6 +492,7 @@ void radeon_audio_detect(struct drm_connector *connector, <nl>  		radeon_audio_enable(rdev, dig->afmt->pin, 0xf); <nl>  	} else { <nl>  		radeon_audio_enable(rdev, dig->afmt->pin, 0); <nl> +		dig->afmt->pin = NULL; <nl>  	} <nl>  } <nl>   <nl> @@ -704,7 +706,6 @@ static void radeon_audio_hdmi_mode_set(struct drm_encoder *encoder, <nl>  		return; <nl>   <nl>  	/* disable audio prior to setting up hw */ <nl> -	dig->afmt->pin = radeon_audio_get_pin(encoder); <nl>  	radeon_audio_enable(rdev, dig->afmt->pin, 0); <nl>   <nl>  	radeon_audio_set_dto(encoder, mode->clock); <nl> @@ -734,7 +735,6 @@ static void radeon_audio_dp_mode_set(struct drm_encoder *encoder, <nl>  		return; <nl>   <nl>  	/* disable audio prior to setting up hw */ <nl> -	dig->afmt->pin = radeon_audio_get_pin(encoder); <nl>  	radeon_audio_enable(rdev, dig->afmt->pin, 0); <nl>   <nl>  	radeon_audio_set_dto(encoder, rdev->clock.default_dispclk * 10);
@@ -2779,6 +2779,7 @@ destroy_wq: <nl>  error: <nl>  	usb_free_urb(dev->in_urb); <nl>  	usb_free_urb(dev->out_urb); <nl> +	usb_put_dev(dev->udev); <nl>  	kfree(dev); <nl>  	return rc; <nl>  }
@@ -593,7 +593,7 @@ static int __fimc_md_create_flite_source_links(struct fimc_md *fmd) <nl>  { <nl>  	struct media_entity *source, *sink; <nl>  	unsigned int flags = MEDIA_LNK_FL_ENABLED; <nl> -	int i, ret; <nl> +	int i, ret = 0; <nl>   <nl>  	for (i = 0; i < FIMC_LITE_MAX_DEVS; i++) { <nl>  		struct fimc_lite *fimc = fmd->fimc_lite[i];
@@ -379,7 +379,7 @@ int usb_sg_init(struct usb_sg_request *io, struct usb_device *dev, <nl>  	} <nl>   <nl>  	/* initialize all the urbs we'll use */ <nl> -	io->urbs = kmalloc(io->entries * sizeof *io->urbs, mem_flags); <nl> +	io->urbs = kmalloc(io->entries * sizeof(*io->urbs), mem_flags); <nl>  	if (!io->urbs) <nl>  		goto nomem; <nl>  
@@ -660,6 +660,7 @@ void xenbus_dev_changed(const char *node, struct xen_bus_type *bus) <nl>   <nl>  	kfree(root); <nl>  } <nl> +EXPORT_SYMBOL_GPL(xenbus_dev_changed); <nl>   <nl>  static void frontend_changed(struct xenbus_watch *watch, <nl>  			     const char **vec, unsigned int len)
@@ -158,7 +158,7 @@ static int fuse_dentry_revalidate(struct dentry *entry, struct nameidata *nd) <nl>  { <nl>  	struct inode *inode; <nl>   <nl> -	if (nd->flags & LOOKUP_RCU) <nl> +	if (nd && nd->flags & LOOKUP_RCU) <nl>  		return -ECHILD; <nl>   <nl>  	inode = entry->d_inode;
@@ -5494,7 +5494,7 @@ tracing_buffers_splice_read(struct file *file, loff_t *ppos, <nl>  	}; <nl>  	struct buffer_ref *ref; <nl>  	int entries, size, i; <nl> -	ssize_t ret; <nl> +	ssize_t ret = 0; <nl>   <nl>  	mutex_lock(&trace_types_lock); <nl>   <nl> @@ -5532,13 +5532,16 @@ tracing_buffers_splice_read(struct file *file, loff_t *ppos, <nl>  		int r; <nl>   <nl>  		ref = kzalloc(sizeof(*ref), GFP_KERNEL); <nl> -		if (!ref) <nl> +		if (!ref) { <nl> +			ret = -ENOMEM; <nl>  			break; <nl> +		} <nl>   <nl>  		ref->ref = 1; <nl>  		ref->buffer = iter->trace_buffer->buffer; <nl>  		ref->page = ring_buffer_alloc_read_page(ref->buffer, iter->cpu_file); <nl>  		if (!ref->page) { <nl> +			ret = -ENOMEM; <nl>  			kfree(ref); <nl>  			break; <nl>  		} <nl> @@ -5576,6 +5579,9 @@ tracing_buffers_splice_read(struct file *file, loff_t *ppos, <nl>   <nl>  	/* did we read anything? */ <nl>  	if (!spd.nr_pages) { <nl> +		if (ret) <nl> +			goto out; <nl> + <nl>  		if ((file->f_flags & O_NONBLOCK) || (flags & SPLICE_F_NONBLOCK)) { <nl>  			ret = -EAGAIN; <nl>  			goto out;
@@ -2291,6 +2291,9 @@ static int kdb_ll(int argc, const char **argv) <nl>  	while (va) { <nl>  		char buf[80]; <nl>   <nl> +		if (KDB_FLAG(CMD_INTERRUPT)) <nl> +			return 0; <nl> + <nl>  		sprintf(buf, "%s " kdb_machreg_fmt "\n", command, va); <nl>  		diag = kdb_parse(buf); <nl>  		if (diag)
@@ -85,7 +85,7 @@ int zft_vmalloc_once(void *new, size_t size) <nl>  		peak_memory = used_memory; <nl>  	} <nl>  	TRACE_ABORT(0, ft_t_noise, <nl> -		    "allocated buffer @ %p, %d bytes", *(void **)new, size); <nl> +		    "allocated buffer @ %p, %zd bytes", *(void **)new, size); <nl>  } <nl>  int zft_vmalloc_always(void *new, size_t size) <nl>  { <nl> @@ -101,7 +101,7 @@ void zft_vfree(void *old, size_t size) <nl>  	if (*(void **)old) { <nl>  		vfree(*(void **)old); <nl>  		used_memory -= size; <nl> -		TRACE(ft_t_noise, "released buffer @ %p, %d bytes", <nl> +		TRACE(ft_t_noise, "released buffer @ %p, %zd bytes", <nl>  		      *(void **)old, size); <nl>  		*(void **)old = NULL; <nl>  	}
@@ -596,11 +596,10 @@ hpet_ioctl_common(struct hpet_dev *devp, int cmd, unsigned long arg, <nl>  		break; <nl>  	case HPET_INFO: <nl>  		{ <nl> +			memset(info, 0, sizeof(*info)); <nl>  			if (devp->hd_ireqfreq) <nl>  				info->hi_ireqfreq = <nl>  					hpet_time_div(hpetp, devp->hd_ireqfreq); <nl> -			else <nl> -				info->hi_ireqfreq = 0; <nl>  			info->hi_flags = <nl>  			    readq(&timer->hpet_config) & Tn_PER_INT_CAP_MASK; <nl>  			info->hi_hpet = hpetp->hp_which;
@@ -476,13 +476,13 @@ irqreturn_t dwc2_handle_common_intr(int irq, void *dev) <nl>  	u32 gintsts; <nl>  	irqreturn_t retval = IRQ_NONE; <nl>   <nl> +	spin_lock(&hsotg->lock); <nl> + <nl>  	if (!dwc2_is_controller_alive(hsotg)) { <nl>  		dev_warn(hsotg->dev, "Controller is dead\n"); <nl>  		goto out; <nl>  	} <nl>   <nl> -	spin_lock(&hsotg->lock); <nl> - <nl>  	gintsts = dwc2_read_common_intr(hsotg); <nl>  	if (gintsts & ~GINTSTS_PRTINT) <nl>  		retval = IRQ_HANDLED; <nl> @@ -515,8 +515,8 @@ irqreturn_t dwc2_handle_common_intr(int irq, void *dev) <nl>  		} <nl>  	} <nl>   <nl> -	spin_unlock(&hsotg->lock); <nl>  out: <nl> +	spin_unlock(&hsotg->lock); <nl>  	return retval; <nl>  } <nl>  EXPORT_SYMBOL_GPL(dwc2_handle_common_intr);
@@ -845,6 +845,9 @@ static struct ib_ucontext *mlx5_ib_alloc_ucontext(struct ib_device *ibdev, <nl>  	if (!dev->ib_active) <nl>  		return ERR_PTR(-EAGAIN); <nl>   <nl> +	if (udata->inlen < sizeof(struct ib_uverbs_cmd_hdr)) <nl> +		return ERR_PTR(-EINVAL); <nl> + <nl>  	reqlen = udata->inlen - sizeof(struct ib_uverbs_cmd_hdr); <nl>  	if (reqlen == sizeof(struct mlx5_ib_alloc_ucontext_req)) <nl>  		ver = 0; <nl> @@ -871,7 +874,7 @@ static struct ib_ucontext *mlx5_ib_alloc_ucontext(struct ib_device *ibdev, <nl>   <nl>  	if (reqlen > sizeof(req) && <nl>  	    !ib_is_udata_cleared(udata, sizeof(req), <nl> -				 udata->inlen - sizeof(req))) <nl> +				 reqlen - sizeof(req))) <nl>  		return ERR_PTR(-EOPNOTSUPP); <nl>   <nl>  	req.total_num_uuars = ALIGN(req.total_num_uuars,
@@ -2631,6 +2631,8 @@ static const char *alc_get_line_out_pfx(struct alc_spec *spec, int ch, <nl>  	case AUTO_PIN_SPEAKER_OUT: <nl>  		if (cfg->line_outs == 1) <nl>  			return "Speaker"; <nl> +		if (cfg->line_outs == 2) <nl> +			return ch ? "Bass Speaker" : "Speaker"; <nl>  		break; <nl>  	case AUTO_PIN_HP_OUT: <nl>  		/* for multi-io case, only the primary out */
@@ -58,7 +58,7 @@ static inline int get_prev_map_irq(int cb_no) <nl>  { <nl>  	int i; <nl>   <nl> -	for (i = 0; i < cb->int_max; i++) <nl> +	for (i = cb->int_max - 1; i >= 0; i--) <nl>  		if (cb->irq_map[i] == cb_no) <nl>  			return i; <nl>   <nl> @@ -69,7 +69,7 @@ static inline int allocate_free_irq(int cb_no) <nl>  { <nl>  	int i; <nl>   <nl> -	for (i = 0; i < cb->int_max; i++) { <nl> +	for (i = cb->int_max - 1; i >= 0; i--) { <nl>  		if (cb->irq_map[i] == IRQ_FREE) { <nl>  			cb->irq_map[i] = cb_no; <nl>  			return i;
@@ -3679,7 +3679,7 @@ static int wl1271_bss_beacon_info_changed(struct wl1271 *wl, <nl>  	bool is_ap = (wlvif->bss_type == BSS_TYPE_AP_BSS); <nl>  	int ret = 0; <nl>   <nl> -	if ((changed & BSS_CHANGED_BEACON_INT)) { <nl> +	if (changed & BSS_CHANGED_BEACON_INT) { <nl>  		wl1271_debug(DEBUG_MASTER, "beacon interval updated: %d", <nl>  			bss_conf->beacon_int); <nl>   <nl> @@ -3692,7 +3692,7 @@ static int wl1271_bss_beacon_info_changed(struct wl1271 *wl, <nl>  		wl1271_ap_set_probe_resp_tmpl(wl, rate, vif); <nl>  	} <nl>   <nl> -	if ((changed & BSS_CHANGED_BEACON)) { <nl> +	if (changed & BSS_CHANGED_BEACON) { <nl>  		ret = wlcore_set_beacon_template(wl, vif, is_ap); <nl>  		if (ret < 0) <nl>  			goto out; <nl> @@ -3744,7 +3744,7 @@ static void wl1271_bss_info_changed_ap(struct wl1271 *wl, <nl>  	if (ret < 0) <nl>  		goto out; <nl>   <nl> -	if ((changed & BSS_CHANGED_BEACON_ENABLED)) { <nl> +	if (changed & BSS_CHANGED_BEACON_ENABLED) { <nl>  		if (bss_conf->enable_beacon) { <nl>  			if (!test_bit(WLVIF_FLAG_AP_STARTED, &wlvif->flags)) { <nl>  				ret = wl12xx_cmd_role_start_ap(wl, wlvif); <nl> @@ -3913,7 +3913,7 @@ static void wl1271_bss_info_changed_sta(struct wl1271 *wl, <nl>  		do_join = true; <nl>  	} <nl>   <nl> -	if ((changed & BSS_CHANGED_CQM)) { <nl> +	if (changed & BSS_CHANGED_CQM) { <nl>  		bool enable = false; <nl>  		if (bss_conf->cqm_rssi_thold) <nl>  			enable = true;
@@ -70,6 +70,9 @@ static ssize_t bin_attr_nvmem_read(struct file *filp, struct kobject *kobj, <nl>  	if (pos >= nvmem->size) <nl>  		return 0; <nl>   <nl> +	if (count < nvmem->word_size) <nl> +		return -EINVAL; <nl> + <nl>  	if (pos + count > nvmem->size) <nl>  		count = nvmem->size - pos; <nl>   <nl> @@ -95,6 +98,9 @@ static ssize_t bin_attr_nvmem_write(struct file *filp, struct kobject *kobj, <nl>  	if (pos >= nvmem->size) <nl>  		return 0; <nl>   <nl> +	if (count < nvmem->word_size) <nl> +		return -EINVAL; <nl> + <nl>  	if (pos + count > nvmem->size) <nl>  		count = nvmem->size - pos; <nl>  
@@ -602,7 +602,8 @@ static int do_setlk(struct file *filp, int cmd, struct file_lock *fl) <nl>  	 * This makes locking act as a cache coherency point. <nl>  	 */ <nl>  	nfs_sync_mapping(filp->f_mapping); <nl> -	nfs_zap_caches(inode); <nl> +	if (!nfs_have_delegation(inode, FMODE_READ)) <nl> +		nfs_zap_caches(inode); <nl>  out: <nl>  	return status; <nl>  }
@@ -247,14 +247,18 @@ unsigned long shrink_slab(struct shrink_control *shrink, <nl>   <nl>  	list_for_each_entry(shrinker, &shrinker_list, list) { <nl>  		unsigned long long delta; <nl> -		unsigned long total_scan; <nl> -		unsigned long max_pass; <nl> +		long total_scan; <nl> +		long max_pass; <nl>  		int shrink_ret = 0; <nl>  		long nr; <nl>  		long new_nr; <nl>  		long batch_size = shrinker->batch ? shrinker->batch <nl>  						  : SHRINK_BATCH; <nl>   <nl> +		max_pass = do_shrinker_shrink(shrinker, shrink, 0); <nl> +		if (max_pass <= 0) <nl> +			continue; <nl> + <nl>  		/* <nl>  		 * copy the current shrinker scan count into a local variable <nl>  		 * and zero it so that other concurrent shrinker invocations <nl> @@ -265,7 +269,6 @@ unsigned long shrink_slab(struct shrink_control *shrink, <nl>  		} while (cmpxchg(&shrinker->nr, nr, 0) != nr); <nl>   <nl>  		total_scan = nr; <nl> -		max_pass = do_shrinker_shrink(shrinker, shrink, 0); <nl>  		delta = (4 * nr_pages_scanned) / shrinker->seeks; <nl>  		delta *= max_pass; <nl>  		do_div(delta, lru_pages + 1);
@@ -3118,7 +3118,13 @@ static void acpi_set_WOL(struct net_device *dev) <nl>  		iowrite16(SetRxFilter|RxStation|RxMulticast|RxBroadcast, ioaddr + EL3_CMD); <nl>  		iowrite16(RxEnable, ioaddr + EL3_CMD); <nl>   <nl> -		pci_enable_wake(VORTEX_PCI(vp), 0, 1); <nl> +		if (pci_enable_wake(VORTEX_PCI(vp), PCI_D3hot, 1)) { <nl> +			printk(KERN_INFO "%s: WOL not supported.\n", <nl> +					pci_name(VORTEX_PCI(vp))); <nl> + <nl> +			vp->enable_wol = 0; <nl> +			return; <nl> +		} <nl>   <nl>  		/* Change the power state to D3; RxEnable doesn't take effect. */ <nl>  		pci_set_power_state(VORTEX_PCI(vp), PCI_D3hot);
@@ -384,7 +384,7 @@ static int mmc_blk_ioctl_cmd(struct block_device *bdev, <nl>  	md = mmc_blk_get(bdev->bd_disk); <nl>  	if (!md) { <nl>  		err = -EINVAL; <nl> -		goto cmd_done; <nl> +		goto cmd_err; <nl>  	} <nl>   <nl>  	card = md->queue.card; <nl> @@ -483,6 +483,7 @@ cmd_rel_host: <nl>   <nl>  cmd_done: <nl>  	mmc_blk_put(md); <nl> +cmd_err: <nl>  	kfree(idata->buf); <nl>  	kfree(idata); <nl>  	return err;
@@ -448,6 +448,8 @@ int rt2800_load_firmware(struct rt2x00_dev *rt2x00dev, <nl>  	 */ <nl>  	rt2800_register_write(rt2x00dev, H2M_BBP_AGENT, 0); <nl>  	rt2800_register_write(rt2x00dev, H2M_MAILBOX_CSR, 0); <nl> +	if (rt2x00_is_usb(rt2x00dev)) <nl> +		rt2800_register_write(rt2x00dev, H2M_INT_SRC, 0); <nl>  	msleep(1); <nl>   <nl>  	return 0;
@@ -1789,10 +1789,10 @@ xfs_fs_fill_super( <nl>  	 */ <nl>  	error = xfs_start_flags(args, mp); <nl>  	if (error) <nl> -		goto error1; <nl> +		goto out_destroy_counters; <nl>  	error = xfs_readsb(mp, flags); <nl>  	if (error) <nl> -		goto error1; <nl> +		goto out_destroy_counters; <nl>  	error = xfs_finish_flags(args, mp); <nl>  	if (error) <nl>  		goto error2; <nl> @@ -1853,12 +1853,6 @@ xfs_fs_fill_super( <nl>   error2: <nl>  	if (mp->m_sb_bp) <nl>  		xfs_freesb(mp); <nl> - error1: <nl> -	xfs_binval(mp->m_ddev_targp); <nl> -	if (mp->m_logdev_targp && mp->m_logdev_targp != mp->m_ddev_targp) <nl> -		xfs_binval(mp->m_logdev_targp); <nl> -	if (mp->m_rtdev_targp) <nl> -		xfs_binval(mp->m_rtdev_targp); <nl>   out_destroy_counters: <nl>  	xfs_icsb_destroy_counters(mp); <nl>  	xfs_close_devices(mp);
@@ -229,6 +229,13 @@ static void __init MP_bus_info (struct mpc_config_bus *m) <nl>   <nl>  	mpc_oem_bus_info(m, str, translation_table[mpc_record]); <nl>   <nl> +	if (m->mpc_busid >= MAX_MP_BUSSES) { <nl> +		printk(KERN_WARNING "MP table busid value (%d) for bustype %s " <nl> +			" is too large, max. supported is %d\n", <nl> +			m->mpc_busid, str, MAX_MP_BUSSES - 1); <nl> +		return; <nl> +	} <nl> + <nl>  	if (strncmp(str, BUSTYPE_ISA, sizeof(BUSTYPE_ISA)-1) == 0) { <nl>  		mp_bus_id_to_type[m->mpc_busid] = MP_BUS_ISA; <nl>  	} else if (strncmp(str, BUSTYPE_EISA, sizeof(BUSTYPE_EISA)-1) == 0) {
@@ -66,6 +66,8 @@ static void __init bmips_smp_setup(void) <nl>  	int i, cpu = 1, boot_cpu = 0; <nl>   <nl>  #if defined(CONFIG_CPU_BMIPS4350) || defined(CONFIG_CPU_BMIPS4380) <nl> +	int cpu_hw_intr; <nl> + <nl>  	/* arbitration priority */ <nl>  	clear_c0_brcm_cmt_ctrl(0x30); <nl>   <nl> @@ -80,8 +82,12 @@ static void __init bmips_smp_setup(void) <nl>  	 * MIPS interrupt 2 (HW INT 0) is the CPU0 L1 controller output <nl>  	 * MIPS interrupt 3 (HW INT 1) is the CPU1 L1 controller output <nl>  	 */ <nl> -	change_c0_brcm_cmt_intr(0xf8018000, <nl> -					(0x02 << 27) | (0x03 << 15)); <nl> +	if (boot_cpu == 0) <nl> +		cpu_hw_intr = 0x02; <nl> +	else <nl> +		cpu_hw_intr = 0x1d; <nl> + <nl> +	change_c0_brcm_cmt_intr(0xf8018000, (cpu_hw_intr << 27) | (0x03 << 15)); <nl>   <nl>  	/* single core, 2 threads (2 pipelines) */ <nl>  	max_cpus = 2;
@@ -310,8 +310,9 @@ static int usblp_check_status(struct usblp *usblp, int err) <nl>   <nl>  	error = usblp_read_status (usblp, usblp->statusbuf); <nl>  	if (error < 0) { <nl> -		err("usblp%d: error %d reading printer status", <nl> -			usblp->minor, error); <nl> +		if (printk_ratelimit()) <nl> +			err("usblp%d: error %d reading printer status", <nl> +				usblp->minor, error); <nl>  		return 0; <nl>  	} <nl>   <nl> @@ -604,7 +605,9 @@ static int usblp_ioctl(struct inode *inode, struct file *file, unsigned int cmd, <nl>   <nl>  			case LPGETSTATUS: <nl>  				if (usblp_read_status(usblp, usblp->statusbuf)) { <nl> -					err("usblp%d: failed reading printer status", usblp->minor); <nl> +					if (printk_ratelimit()) <nl> +						err("usblp%d: failed reading printer status", <nl> +							usblp->minor); <nl>  					retval = -EIO; <nl>  					goto done; <nl>  				}
@@ -2486,6 +2486,9 @@ static __init int samsung_gpiolib_init(void) <nl>  		s5p_register_gpioint_bank(IRQ_GPIO_XA, 0, IRQ_GPIO1_NR_GROUPS); <nl>  		s5p_register_gpioint_bank(IRQ_GPIO_XB, IRQ_GPIO1_NR_GROUPS, IRQ_GPIO2_NR_GROUPS); <nl>  #endif <nl> +	} else { <nl> +		WARN(1, "Unknown SoC in gpio-samsung, no GPIOs added\n"); <nl> +		return -ENODEV; <nl>  	} <nl>   <nl>  	return 0;
@@ -2398,10 +2398,11 @@ void drbd_bcast_ee(struct drbd_conf *mdev, <nl>  	tl = tl_add_int(tl, T_ee_sector, &e->sector); <nl>  	tl = tl_add_int(tl, T_ee_block_id, &e->block_id); <nl>   <nl> +	/* dump the first 32k */ <nl> +	len = min_t(unsigned, e->size, 32 << 10); <nl>  	put_unaligned(T_ee_data, tl++); <nl> -	put_unaligned(e->size, tl++); <nl> +	put_unaligned(len, tl++); <nl>   <nl> -	len = e->size; <nl>  	page = e->pages; <nl>  	page_chain_for_each(page) { <nl>  		void *d = kmap_atomic(page, KM_USER0); <nl> @@ -2410,6 +2411,8 @@ void drbd_bcast_ee(struct drbd_conf *mdev, <nl>  		kunmap_atomic(d, KM_USER0); <nl>  		tl = (unsigned short*)((char*)tl + l); <nl>  		len -= l; <nl> +		if (len == 0) <nl> +			break; <nl>  	} <nl>  	put_unaligned(TT_END, tl++); /* Close the tag list */ <nl>  
@@ -1913,7 +1913,7 @@ asmlinkage long compat_sys_ppoll(struct pollfd __user *ufds, <nl>  	} <nl>   <nl>  	if (sigmask) { <nl> -		if (sigsetsize |= sizeof(compat_sigset_t)) <nl> +		if (sigsetsize != sizeof(compat_sigset_t)) <nl>  			return -EINVAL; <nl>  		if (copy_from_user(&ss32, sigmask, sizeof(ss32))) <nl>  			return -EFAULT;
@@ -1801,7 +1801,7 @@ return_host_buffers: <nl>  next_rbrq_entry: <nl>  		he_dev->rbrq_head = (struct he_rbrq *) <nl>  				((unsigned long) he_dev->rbrq_base | <nl> -					RBRQ_MASK(++he_dev->rbrq_head)); <nl> +					RBRQ_MASK(he_dev->rbrq_head + 1)); <nl>   <nl>  	} <nl>  	read_unlock(&vcc_sklist_lock); <nl> @@ -1884,7 +1884,7 @@ next_tbrq_entry: <nl>  			pci_pool_free(he_dev->tpd_pool, tpd, TPD_ADDR(tpd->status)); <nl>  		he_dev->tbrq_head = (struct he_tbrq *) <nl>  				((unsigned long) he_dev->tbrq_base | <nl> -					TBRQ_MASK(++he_dev->tbrq_head)); <nl> +					TBRQ_MASK(he_dev->tbrq_head + 1)); <nl>  	} <nl>   <nl>  	if (updated) {
@@ -4967,6 +4967,11 @@ static void *raid5_takeover(mddev_t *mddev) <nl>   <nl>  	if (mddev->level == 1) <nl>  		return raid5_takeover_raid1(mddev); <nl> +	if (mddev->level == 4) { <nl> +		mddev->new_layout = ALGORITHM_PARITY_N; <nl> +		mddev->new_level = 5; <nl> +		return setup_conf(mddev); <nl> +	} <nl>   <nl>  	return ERR_PTR(-EINVAL); <nl>  }
@@ -4105,7 +4105,7 @@ drm_property_create_blob(struct drm_device *dev, size_t length, <nl>  	struct drm_property_blob *blob; <nl>  	int ret; <nl>   <nl> -	if (!length) <nl> +	if (!length || length > ULONG_MAX - sizeof(struct drm_property_blob)) <nl>  		return ERR_PTR(-EINVAL); <nl>   <nl>  	blob = kzalloc(sizeof(struct drm_property_blob)+length, GFP_KERNEL);
@@ -493,6 +493,7 @@ again: <nl>  	smp_mb(); <nl>  	if (cur_trans->state >= TRANS_STATE_BLOCKED && <nl>  	    may_wait_transaction(root, type)) { <nl> +		current->journal_info = h; <nl>  		btrfs_commit_transaction(h, root); <nl>  		goto again; <nl>  	}
@@ -509,3 +509,4 @@ void local_touch_nmi(void) <nl>  { <nl>  	__this_cpu_write(last_nmi_rip, 0); <nl>  } <nl> +EXPORT_SYMBOL_GPL(local_touch_nmi);
@@ -276,8 +276,6 @@ int __init dc21285_setup(int nr, struct pci_sys_data *sys) <nl>   <nl>  	sys->mem_offset  = DC21285_PCI_MEM; <nl>   <nl> -	pci_ioremap_io(0, DC21285_PCI_IO); <nl> - <nl>  	pci_add_resource_offset(&sys->resources, &res[0], sys->mem_offset); <nl>  	pci_add_resource_offset(&sys->resources, &res[1], sys->mem_offset); <nl>  
@@ -11060,6 +11060,9 @@ static int bnx2x_get_hwinfo(struct bnx2x *bp) <nl>  				} else <nl>  					BNX2X_DEV_INFO("illegal OV for SD\n"); <nl>  				break; <nl> +			case SHARED_FEAT_CFG_FORCE_SF_MODE_FORCED_SF: <nl> +				bp->mf_config[vn] = 0; <nl> +				break; <nl>  			default: <nl>  				/* Unknown configuration: reset mf_config */ <nl>  				bp->mf_config[vn] = 0;
@@ -876,6 +876,7 @@ static int audit_receive_msg(struct sk_buff *skb, struct nlmsghdr *nlh) <nl>  				if (err) <nl>  					break; <nl>  			} <nl> +			mutex_unlock(&audit_cmd_mutex); <nl>  			audit_log_common_recv_msg(&ab, msg_type); <nl>  			if (msg_type != AUDIT_USER_TTY) <nl>  				audit_log_format(ab, " msg='%.*s'", <nl> @@ -893,6 +894,7 @@ static int audit_receive_msg(struct sk_buff *skb, struct nlmsghdr *nlh) <nl>  			} <nl>  			audit_set_portid(ab, NETLINK_CB(skb).portid); <nl>  			audit_log_end(ab); <nl> +			mutex_lock(&audit_cmd_mutex); <nl>  		} <nl>  		break; <nl>  	case AUDIT_ADD_RULE:
@@ -83,6 +83,7 @@ static int rt2x00mac_tx_rts_cts(struct rt2x00_dev *rt2x00dev, <nl>  				  (struct ieee80211_rts *)(skb->data)); <nl>   <nl>  	if (rt2x00queue_write_tx_frame(queue, skb)) { <nl> +		dev_kfree_skb_any(skb); <nl>  		WARNING(rt2x00dev, "Failed to send RTS/CTS frame.\n"); <nl>  		return NETDEV_TX_BUSY; <nl>  	}
@@ -3668,7 +3668,7 @@ static inline void update_sd_power_savings_stats(struct sched_group *group, <nl>  	 * capacity but still has some space to pick up some load <nl>  	 * from other group and save more power <nl>  	 */ <nl> -	if (sgs->sum_nr_running > sgs->group_capacity - 1) <nl> +	if (sgs->sum_nr_running + 1 > sgs->group_capacity) <nl>  		return; <nl>   <nl>  	if (sgs->sum_nr_running > sds->leader_nr_running ||
@@ -398,9 +398,9 @@ int cx25821_openfile_audio(struct cx25821_dev *dev, <nl>  				vfs_read_retval = <nl>  				    vfs_read(myfile, mybuf, line_size, &pos); <nl>   <nl> -				if (vfs_read_retval > 0 <nl> -				    && vfs_read_retval == line_size <nl> -				    && dev->_audiodata_buf_virt_addr != NULL) { <nl> +				if (vfs_read_retval > 0 && <nl> +				    vfs_read_retval == line_size && <nl> +				    dev->_audiodata_buf_virt_addr != NULL) { <nl>  					memcpy((void *)(dev-> <nl>  							_audiodata_buf_virt_addr <nl>  							+ offset / 4), mybuf,
@@ -2177,6 +2177,14 @@ static int addrconf_notify(struct notifier_block *this, unsigned long event, <nl>  	int run_pending = 0; <nl>   <nl>  	switch(event) { <nl> +	case NETDEV_REGISTER: <nl> +		if (!idev) { <nl> +			idev = ipv6_add_dev(dev); <nl> +			if (!idev) <nl> +				printk(KERN_WARNING "IPv6: add_dev failed for %s\n", <nl> +					dev->name); <nl> +		} <nl> +		break; <nl>  	case NETDEV_UP: <nl>  	case NETDEV_CHANGE: <nl>  		if (event == NETDEV_UP) {
@@ -150,6 +150,7 @@ msi_irq_allocated: <nl>  		msg.address_lo = <nl>  			((128ul << 20) + CVMX_PCI_MSI_RCV) & 0xffffffff; <nl>  		msg.address_hi = ((128ul << 20) + CVMX_PCI_MSI_RCV) >> 32; <nl> +		break; <nl>  	case OCTEON_DMA_BAR_TYPE_BIG: <nl>  		/* When using big bar, Bar 0 is based at 0 */ <nl>  		msg.address_lo = (0 + CVMX_PCI_MSI_RCV) & 0xffffffff;
@@ -983,8 +983,11 @@ void radeon_update_display_priority(struct radeon_device *rdev) <nl>  		/* set display priority to high for r3xx, rv515 chips <nl>  		 * this avoids flickering due to underflow to the <nl>  		 * display controllers during heavy acceleration. <nl> +		 * Don't force high on rs4xx igp chips as it seems to <nl> +		 * affect the sound card.  See kernel bug 15982. <nl>  		 */ <nl> -		if (ASIC_IS_R300(rdev) || (rdev->family == CHIP_RV515)) <nl> +		if ((ASIC_IS_R300(rdev) || (rdev->family == CHIP_RV515)) && <nl> +		    !(rdev->flags & RADEON_IS_IGP)) <nl>  			rdev->disp_priority = 2; <nl>  		else <nl>  			rdev->disp_priority = 0;
@@ -62,6 +62,8 @@ struct scan_control { <nl>  	int swap_cluster_max; <nl>   <nl>  	int swappiness; <nl> + <nl> +	int all_unreclaimable; <nl>  }; <nl>   <nl>  /* <nl> @@ -925,6 +927,7 @@ static unsigned long shrink_zones(int priority, struct zone **zones, <nl>  	unsigned long nr_reclaimed = 0; <nl>  	int i; <nl>   <nl> +	sc->all_unreclaimable = 1; <nl>  	for (i = 0; zones[i] != NULL; i++) { <nl>  		struct zone *zone = zones[i]; <nl>   <nl> @@ -941,6 +944,8 @@ static unsigned long shrink_zones(int priority, struct zone **zones, <nl>  		if (zone->all_unreclaimable && priority != DEF_PRIORITY) <nl>  			continue;	/* Let kswapd poll it */ <nl>   <nl> +		sc->all_unreclaimable = 0; <nl> + <nl>  		nr_reclaimed += shrink_zone(priority, zone, sc); <nl>  	} <nl>  	return nr_reclaimed; <nl> @@ -1021,6 +1026,9 @@ unsigned long try_to_free_pages(struct zone **zones, gfp_t gfp_mask) <nl>  		if (sc.nr_scanned && priority < DEF_PRIORITY - 2) <nl>  			blk_congestion_wait(WRITE, HZ/10); <nl>  	} <nl> +	/* top priority shrink_caches still had more to do? don't OOM, then */ <nl> +	if (!sc.all_unreclaimable) <nl> +		ret = 1; <nl>  out: <nl>  	for (i = 0; zones[i] != 0; i++) { <nl>  		struct zone *zone = zones[i];
@@ -1057,6 +1057,7 @@ static int buffer_prepare(struct videobuf_queue *q, <nl>  		buf->vb.field  = field; <nl>  		buf->fmt       = fh->fmt; <nl>  		buf->pt        = &fh->pt_cap; <nl> +		dev->video_q.curr = NULL; <nl>   <nl>  		err = videobuf_iolock(q,&buf->vb,&dev->ovbuf); <nl>  		if (err)
@@ -518,7 +518,7 @@ int decode_seq(bitstr_t * bs, field_t * f, char *base, int level) <nl>  			CHECK_BOUND(bs, 2); <nl>  			len = get_len(bs); <nl>  			CHECK_BOUND(bs, len); <nl> -			if (!base) { <nl> +			if (!base || !(son->attr & DECODE)) { <nl>  				PRINT("%*.s%s\n", (level + 1) * TAB_SIZE, <nl>  				      " ", son->name); <nl>  				bs->cur += len; <nl> @@ -704,6 +704,8 @@ int decode_choice(bitstr_t * bs, field_t * f, char *base, int level) <nl>  	} else { <nl>  		ext = 0; <nl>  		type = get_bits(bs, f->sz); <nl> +		if (type >= f->lb) <nl> +			return H323_ERROR_RANGE; <nl>  	} <nl>   <nl>  	/* Write Type */
@@ -211,8 +211,12 @@ static ssize_t adp5520_bl_daylight_max_store(struct device *dev, <nl>  			const char *buf, size_t count) <nl>  { <nl>  	struct adp5520_bl *data = dev_get_drvdata(dev); <nl> +	int ret; <nl> + <nl> +	ret = strict_strtoul(buf, 10, &data->cached_daylight_max); <nl> +	if (ret < 0) <nl> +		return ret; <nl>   <nl> -	strict_strtoul(buf, 10, &data->cached_daylight_max); <nl>  	return adp5520_store(dev, buf, count, ADP5520_DAYLIGHT_MAX); <nl>  } <nl>  static DEVICE_ATTR(daylight_max, 0664, adp5520_bl_daylight_max_show,
@@ -1771,6 +1771,9 @@ static int i915_pipe_crc_open(struct inode *inode, struct file *filep) <nl>  	struct drm_i915_private *dev_priv = info->dev->dev_private; <nl>  	struct intel_pipe_crc *pipe_crc = &dev_priv->pipe_crc[info->pipe]; <nl>   <nl> +	if (info->pipe >= INTEL_INFO(info->dev)->num_pipes) <nl> +		return -ENODEV; <nl> + <nl>  	spin_lock_irq(&pipe_crc->lock); <nl>   <nl>  	if (pipe_crc->opened) {
@@ -105,7 +105,7 @@ static unsigned int qnap_ts41x_mpp_config[] __initdata = { <nl>  	MPP37_GPIO,		/* Reset button */ <nl>  	MPP43_GPIO,		/* USB Copy button */ <nl>  	MPP44_GPIO,		/* Board ID: 0: TS-419U, 1: TS-419 */ <nl> -	MPP45_GPIO,		/* JP1: 0: console, 1: LCD */ <nl> +	MPP45_GPIO,		/* JP1: 0: LCD, 1: serial console */ <nl>  	MPP46_GPIO,		/* External SATA HDD1 error indicator */ <nl>  	MPP47_GPIO,		/* External SATA HDD2 error indicator */ <nl>  	MPP48_GPIO,		/* External SATA HDD3 error indicator */
@@ -1650,6 +1650,8 @@ static int dwc3_gadget_init_hw_endpoints(struct dwc3 *dwc, <nl>   <nl>  		dep->endpoint.name = dep->name; <nl>   <nl> +		dev_vdbg(dwc->dev, "initializing %s\n", dep->name); <nl> + <nl>  		if (epnum == 0 || epnum == 1) { <nl>  			dep->endpoint.maxpacket = 512; <nl>  			dep->endpoint.maxburst = 1;
@@ -460,7 +460,7 @@ int perf_event__parse_sample(const union perf_event *event, u64 type, <nl>  		u32 val32[2]; <nl>  	} u; <nl>   <nl> - <nl> +	memset(data, 0, sizeof(*data)); <nl>  	data->cpu = data->pid = data->tid = -1; <nl>  	data->stream_id = data->id = data->time = -1ULL; <nl>  
@@ -196,7 +196,7 @@ static struct tgfx __init *tgfx_probe(int parport, int *n_buttons, int n_devs) <nl>  		if (n_buttons[i] < 1) <nl>  			continue; <nl>   <nl> -		if (n_buttons[i] > 6) { <nl> +		if (n_buttons[i] > ARRAY_SIZE(tgfx_buttons)) { <nl>  			printk(KERN_ERR "turbografx.c: Invalid number of buttons %d\n", n_buttons[i]); <nl>  			err = -EINVAL; <nl>  			goto err_unreg_devs;
@@ -129,17 +129,17 @@ static int da9052_dcdc_set_current_limit(struct regulator_dev *rdev, int min_uA, <nl>  	else if (offset == 0) <nl>  		row = 1; <nl>   <nl> -	if (min_uA > da9052_current_limits[row][DA9052_MAX_UA] || <nl> -	    max_uA < da9052_current_limits[row][DA9052_MIN_UA]) <nl> -		return -EINVAL; <nl> - <nl>  	for (i = DA9052_CURRENT_RANGE - 1; i >= 0; i--) { <nl> -		if (da9052_current_limits[row][i] <= max_uA) { <nl> +		if ((min_uA <= da9052_current_limits[row][i]) && <nl> +		    (da9052_current_limits[row][i] <= max_uA)) { <nl>  			reg_val = i; <nl>  			break; <nl>  		} <nl>  	} <nl>   <nl> +	if (i < 0) <nl> +		return -EINVAL; <nl> + <nl>  	/* Determine the even or odd position of the buck current limit <nl>  	 * register field <nl>  	*/
@@ -1113,6 +1113,9 @@ int dev_change_name(struct net_device *dev, const char *newname) <nl>  		return err; <nl>  	} <nl>   <nl> +	if (oldname[0] && !strchr(oldname, '%')) <nl> +		netdev_info(dev, "renamed from %s\n", oldname); <nl> + <nl>  	old_assign_type = dev->name_assign_type; <nl>  	dev->name_assign_type = NET_NAME_RENAMED; <nl>  
@@ -106,7 +106,7 @@ ieee80211_rx_h_michael_mic_verify(struct ieee80211_rx_data *rx) <nl>  		if (status->flag & RX_FLAG_MMIC_ERROR) <nl>  			goto mic_fail; <nl>   <nl> -		if (!(status->flag & RX_FLAG_IV_STRIPPED)) <nl> +		if (!(status->flag & RX_FLAG_IV_STRIPPED) && rx->key) <nl>  			goto update_iv; <nl>   <nl>  		return RX_CONTINUE;
@@ -50,7 +50,6 @@ static int rbtx4939_flash_remove(struct platform_device *dev) <nl>  } <nl>   <nl>  static const char *rom_probe_types[] = { "cfi_probe", "jedec_probe", NULL }; <nl> -static const char *part_probe_types[] = { "cmdlinepart", NULL }; <nl>   <nl>  static int rbtx4939_flash_probe(struct platform_device *dev) <nl>  { <nl> @@ -107,9 +106,7 @@ static int rbtx4939_flash_probe(struct platform_device *dev) <nl>  	info->mtd->owner = THIS_MODULE; <nl>  	if (err) <nl>  		goto err_out; <nl> - <nl> -	err = parse_mtd_partitions(info->mtd, part_probe_types, <nl> -				&info->parts, 0); <nl> +	err = parse_mtd_partitions(info->mtd, NULL, &info->parts, 0); <nl>  	if (err > 0) { <nl>  		mtd_device_register(info->mtd, info->parts, err); <nl>  		info->nr_parts = err;
@@ -385,6 +385,7 @@ int msp_pcibios_config_access(unsigned char access_type, <nl>  	unsigned long intr; <nl>  	unsigned long value; <nl>  	static char pciirqflag; <nl> +	int ret; <nl>  #if defined(CONFIG_PMC_MSP7120_GW) || defined(CONFIG_PMC_MSP7120_EVAL) <nl>  	unsigned int	vpe_status; <nl>  #endif <nl> @@ -402,11 +403,13 @@ int msp_pcibios_config_access(unsigned char access_type, <nl>  	 * allocation assigns an interrupt handler to the interrupt. <nl>  	 */ <nl>  	if (pciirqflag == 0) { <nl> -		request_irq(MSP_INT_PCI,/* Hardcoded internal MSP7120 wiring */ <nl> +		ret = request_irq(MSP_INT_PCI,/* Hardcoded internal MSP7120 wiring */ <nl>  				bpci_interrupt, <nl>  				IRQF_SHARED | IRQF_DISABLED, <nl>  				"PMC MSP PCI Host", <nl>  				preg); <nl> +		if (ret != 0) <nl> +			return ret; <nl>  		pciirqflag = ~0; <nl>  	} <nl>  
@@ -80,7 +80,6 @@ nsm_monitor(struct nlm_host *host) <nl>  	int		status; <nl>   <nl>  	dprintk("lockd: nsm_monitor(%s)\n", nsm->sm_name); <nl> -	BUG_ON(nsm == NULL); <nl>   <nl>  	if (nsm->sm_monitored) <nl>  		return 0;
@@ -1796,11 +1796,12 @@ static long __video_do_ioctl(struct file *file, <nl>  static unsigned long cmd_input_size(unsigned int cmd) <nl>  { <nl>  	/* Size of structure up to and including 'field' */ <nl> -#define CMDINSIZE(cmd, type, field) case _IOC_NR(VIDIOC_##cmd): return \ <nl> -		offsetof(struct v4l2_##type, field) + \ <nl> -		sizeof(((struct v4l2_##type *)0)->field); <nl> +#define CMDINSIZE(cmd, type, field) 				\ <nl> +	case VIDIOC_##cmd: 					\ <nl> +		return offsetof(struct v4l2_##type, field) + 	\ <nl> +			sizeof(((struct v4l2_##type *)0)->field); <nl>   <nl> -	switch (_IOC_NR(cmd)) { <nl> +	switch (cmd) { <nl>  		CMDINSIZE(ENUM_FMT,		fmtdesc,	type); <nl>  		CMDINSIZE(G_FMT,		format,		type); <nl>  		CMDINSIZE(QUERYBUF,		buffer,		type);
@@ -261,7 +261,7 @@ static void __init create_mapping(phys_addr_t phys, unsigned long virt, <nl>  void __iomem * __init early_io_map(phys_addr_t phys, unsigned long virt) <nl>  { <nl>  	unsigned long size, mask; <nl> -	bool page64k = IS_ENABLED(ARM64_64K_PAGES); <nl> +	bool page64k = IS_ENABLED(CONFIG_ARM64_64K_PAGES); <nl>  	pgd_t *pgd; <nl>  	pud_t *pud; <nl>  	pmd_t *pmd;
@@ -322,6 +322,7 @@ static int nvme_submit_bio_queue(struct nvme_queue *nvmeq, struct nvme_ns *ns, <nl>  	spin_lock_irqsave(&nvmeq->q_lock, flags); <nl>  	cmnd = &nvmeq->sq_cmds[nvmeq->sq_tail]; <nl>   <nl> +	memset(cmnd, 0, sizeof(*cmnd)); <nl>  	if (bio_data_dir(bio)) { <nl>  		cmnd->rw.opcode = nvme_cmd_write; <nl>  		dma_dir = DMA_TO_DEVICE;
@@ -822,7 +822,7 @@ struct bio *bio_copy_user_iov(struct request_queue *q, <nl>  		return ERR_PTR(-ENOMEM); <nl>   <nl>  	ret = -ENOMEM; <nl> -	bio = bio_alloc(gfp_mask, nr_pages); <nl> +	bio = bio_kmalloc(gfp_mask, nr_pages); <nl>  	if (!bio) <nl>  		goto out_bmd; <nl>   <nl> @@ -946,7 +946,7 @@ static struct bio *__bio_map_user_iov(struct request_queue *q, <nl>  	if (!nr_pages) <nl>  		return ERR_PTR(-EINVAL); <nl>   <nl> -	bio = bio_alloc(gfp_mask, nr_pages); <nl> +	bio = bio_kmalloc(gfp_mask, nr_pages); <nl>  	if (!bio) <nl>  		return ERR_PTR(-ENOMEM); <nl>   <nl> @@ -1130,7 +1130,7 @@ static struct bio *__bio_map_kern(struct request_queue *q, void *data, <nl>  	int offset, i; <nl>  	struct bio *bio; <nl>   <nl> -	bio = bio_alloc(gfp_mask, nr_pages); <nl> +	bio = bio_kmalloc(gfp_mask, nr_pages); <nl>  	if (!bio) <nl>  		return ERR_PTR(-ENOMEM); <nl>  
@@ -556,7 +556,7 @@ static void dwc2_hsotg_start_req(struct dwc2_hsotg *hsotg, <nl>  	/* If endpoint is stalled, we will restart request later */ <nl>  	ctrl = dwc2_readl(hsotg->regs + epctrl_reg); <nl>   <nl> -	if (ctrl & DXEPCTL_STALL) { <nl> +	if (index && ctrl & DXEPCTL_STALL) { <nl>  		dev_warn(hsotg->dev, "%s: ep%d is stalled\n", __func__, index); <nl>  		return; <nl>  	}
@@ -963,7 +963,8 @@ static struct mount *clone_mnt(struct mount *old, struct dentry *root, <nl>  	} <nl>   <nl>  	/* Don't allow unprivileged users to reveal what is under a mount */ <nl> -	if ((flag & CL_UNPRIVILEGED) && list_empty(&old->mnt_expire)) <nl> +	if ((flag & CL_UNPRIVILEGED) && <nl> +	    (!(flag & CL_EXPIRE) || list_empty(&old->mnt_expire))) <nl>  		mnt->mnt.mnt_flags |= MNT_LOCKED; <nl>   <nl>  	atomic_inc(&sb->s_active);
@@ -2526,7 +2526,9 @@ static ssize_t rs_sta_dbgfs_scale_table_read(struct file *file, <nl>  	ssize_t ret; <nl>   <nl>  	struct iwl_lq_sta *lq_sta = file->private_data; <nl> +	struct iwl_priv *priv; <nl>   <nl> +	priv = lq_sta->drv; <nl>  	buff = kmalloc(1024, GFP_KERNEL); <nl>  	if (!buff) <nl>  		return -ENOMEM; <nl> @@ -2537,6 +2539,10 @@ static ssize_t rs_sta_dbgfs_scale_table_read(struct file *file, <nl>  			lq_sta->active_legacy_rate); <nl>  	desc += sprintf(buff+desc, "fixed rate 0x%X\n", <nl>  			lq_sta->dbg_fixed_rate); <nl> +	desc += sprintf(buff+desc, "valid_tx_ant %s%s%s\n", <nl> +	    (priv->hw_params.valid_tx_ant & ANT_A) ? "ANT_A," : "", <nl> +	    (priv->hw_params.valid_tx_ant & ANT_B) ? "ANT_B," : "", <nl> +	    (priv->hw_params.valid_tx_ant & ANT_C) ? "ANT_C" : ""); <nl>  	desc += sprintf(buff+desc, "general:" <nl>  		"flags=0x%X mimo-d=%d s-ant0x%x d-ant=0x%x\n", <nl>  		lq_sta->lq.general_params.flags,
@@ -641,7 +641,7 @@ lookup_out: <nl>  static int <nl>  cifs_d_revalidate(struct dentry *direntry, struct nameidata *nd) <nl>  { <nl> -	if (nd->flags & LOOKUP_RCU) <nl> +	if (nd && (nd->flags & LOOKUP_RCU)) <nl>  		return -ECHILD; <nl>   <nl>  	if (direntry->d_inode) {
@@ -1250,6 +1250,8 @@ static unsigned int xhci_microframes_to_exponent(struct usb_device *udev, <nl>  static unsigned int xhci_parse_microframe_interval(struct usb_device *udev, <nl>  		struct usb_host_endpoint *ep) <nl>  { <nl> +	if (ep->desc.bInterval == 0) <nl> +		return 0; <nl>  	return xhci_microframes_to_exponent(udev, ep, <nl>  			ep->desc.bInterval, 0, 15); <nl>  }
@@ -2023,6 +2023,8 @@ static void __init atmci_get_cap(struct atmel_mci *host) <nl>  	/* keep only major version number */ <nl>  	switch (version & 0xf00) { <nl>  	case 0x100: <nl> +		host->caps.has_pdc = 1; <nl> +		break; <nl>  	case 0x200: <nl>  		host->caps.has_pdc = 1; <nl>  		host->caps.has_rwproof = 1;
@@ -1452,12 +1452,10 @@ s_bPacketToWirelessUsb( <nl>   <nl>   <nl>      pvRrvTime = pMICHDR = pvRTS = pvCTS = pvTxDataHd = NULL; <nl> -    if ((bNeedEncryption) && (pTransmitKey != NULL))  { <nl> -        if (((PSKeyTable) (pTransmitKey->pvKeyTable))->bSoftWEP == TRUE) { <nl> -            // WEP 256 <nl> -            bSoftWEP = TRUE; <nl> -        } <nl> -    } <nl> +	if (bNeedEncryption && pTransmitKey->pvKeyTable) { <nl> +		if (((PSKeyTable)&pTransmitKey->pvKeyTable)->bSoftWEP == TRUE) <nl> +			bSoftWEP = TRUE; /* WEP 256 */ <nl> +	} <nl>   <nl>      pTxBufHead = (PTX_BUFFER) usbPacketBuf; <nl>      memset(pTxBufHead, 0, sizeof(TX_BUFFER));
@@ -1785,8 +1785,9 @@ retry: <nl>  		handle = ext3_journal_start(inode, 2); <nl>  		if (IS_ERR(handle)) { <nl>  			/* This is really bad luck. We've written the data <nl> -			 * but cannot extend i_size. Bail out and pretend <nl> -			 * the write failed... */ <nl> +			 * but cannot extend i_size. Truncate allocated blocks <nl> +			 * and pretend the write failed... */ <nl> +			ext3_truncate(inode); <nl>  			ret = PTR_ERR(handle); <nl>  			goto out; <nl>  		}
@@ -657,7 +657,7 @@ _base_sas_log_info(struct MPT2SAS_ADAPTER *ioc , u32 log_info) <nl>  		return; <nl>   <nl>  	/* eat the loginfos associated with task aborts */ <nl> -	if (ioc->ignore_loginfos && (log_info == 30050000 || log_info == <nl> +	if (ioc->ignore_loginfos && (log_info == 0x30050000 || log_info == <nl>  	    0x31140000 || log_info == 0x31130000)) <nl>  		return; <nl>  
@@ -1385,7 +1385,7 @@ iscsi_sendpage(struct iscsi_conn *conn, struct iscsi_buf *buf, <nl>  	BUG_ON(buf->sent + size > buf->sg.length); <nl>  	if (size > *count) <nl>  		size = *count; <nl> -	if (buf->sent + size != buf->sg.length) <nl> +	if (buf->sent + size != buf->sg.length || *count != size) <nl>  		flags |= MSG_MORE; <nl>   <nl>  	res = iscsi_send(sk, buf, size, flags);
@@ -680,13 +680,12 @@ static int kvmppc_handle_exit(struct kvm_run *run, struct kvm_vcpu *vcpu, <nl>  } <nl>   <nl>  int kvm_arch_vcpu_ioctl_get_sregs(struct kvm_vcpu *vcpu, <nl> -                                  struct kvm_sregs *sregs) <nl> +				  struct kvm_sregs *sregs) <nl>  { <nl>  	int i; <nl>   <nl> -	sregs->pvr = vcpu->arch.pvr; <nl> - <nl>  	memset(sregs, 0, sizeof(struct kvm_sregs)); <nl> +	sregs->pvr = vcpu->arch.pvr; <nl>  	for (i = 0; i < vcpu->arch.slb_max; i++) { <nl>  		sregs->u.s.ppc64.slb[i].slbe = vcpu->arch.slb[i].orige; <nl>  		sregs->u.s.ppc64.slb[i].slbv = vcpu->arch.slb[i].origv; <nl> @@ -696,7 +695,7 @@ int kvm_arch_vcpu_ioctl_get_sregs(struct kvm_vcpu *vcpu, <nl>  } <nl>   <nl>  int kvm_arch_vcpu_ioctl_set_sregs(struct kvm_vcpu *vcpu, <nl> -                                  struct kvm_sregs *sregs) <nl> +				  struct kvm_sregs *sregs) <nl>  { <nl>  	int i, j; <nl>  
@@ -1322,7 +1322,7 @@ static bool e1000_clean_jumbo_rx_irq(struct e1000_adapter *adapter, <nl>  				/* an error means any chain goes out the window <nl>  				 * too */ <nl>  				if (rx_ring->rx_skb_top) <nl> -					dev_kfree_skb(rx_ring->rx_skb_top); <nl> +					dev_kfree_skb_irq(rx_ring->rx_skb_top); <nl>  				rx_ring->rx_skb_top = NULL; <nl>  				goto next_desc; <nl>  		} <nl> @@ -1395,7 +1395,7 @@ static bool e1000_clean_jumbo_rx_irq(struct e1000_adapter *adapter, <nl>  		/* eth type trans needs skb->data to point to something */ <nl>  		if (!pskb_may_pull(skb, ETH_HLEN)) { <nl>  			e_err("pskb_may_pull failed.\n"); <nl> -			dev_kfree_skb(skb); <nl> +			dev_kfree_skb_irq(skb); <nl>  			goto next_desc; <nl>  		} <nl>  
@@ -1649,6 +1649,8 @@ int MoxaDriverIoctl(unsigned int cmd, unsigned long arg, int port) <nl>  	case MOXA_FIND_BOARD: <nl>  	case MOXA_LOAD_C320B: <nl>  	case MOXA_LOAD_CODE: <nl> +		if (!capable(CAP_SYS_RAWIO)) <nl> +			return -EPERM; <nl>  		break; <nl>  	} <nl>  
@@ -419,7 +419,7 @@ static void sport_shutdown(struct uart_port *port) <nl>  } <nl>   <nl>  static void sport_set_termios(struct uart_port *port, <nl> -		struct termios *termios, struct termios *old) <nl> +		struct ktermios *termios, struct ktermios *old) <nl>  { <nl>  	pr_debug("%s enter, c_cflag:%08x\n", __func__, termios->c_cflag); <nl>  	uart_update_timeout(port, CS8 ,port->uartclk);
@@ -1133,7 +1133,7 @@ int btrfs_sync_file(struct file *file, struct dentry *dentry, int datasync) <nl>  	} <nl>  	mutex_lock(&dentry->d_inode->i_mutex); <nl>  out: <nl> -	return ret > 0 ? EIO : ret; <nl> +	return ret > 0 ? -EIO : ret; <nl>  } <nl>   <nl>  static const struct vm_operations_struct btrfs_file_vm_ops = {
@@ -4213,6 +4213,7 @@ skip_create_disk: <nl>  	blk_queue_max_hw_sectors(dd->queue, 0xffff); <nl>  	blk_queue_max_segment_size(dd->queue, 0x400000); <nl>  	blk_queue_io_min(dd->queue, 4096); <nl> +	blk_queue_bounce_limit(dd->queue, dd->pdev->dma_mask); <nl>   <nl>  	/* <nl>  	 * write back cache is not supported in the device. FUA depends on
@@ -1261,6 +1261,9 @@ int ixgbe_ndo_set_vf_spoofchk(struct net_device *netdev, int vf, bool setting) <nl>  	struct ixgbe_hw *hw = &adapter->hw; <nl>  	u32 regval; <nl>   <nl> +	if (vf >= adapter->num_vfs) <nl> +		return -EINVAL; <nl> + <nl>  	adapter->vfinfo[vf].spoofchk_enabled = setting; <nl>   <nl>  	regval = IXGBE_READ_REG(hw, IXGBE_PFVFSPOOF(vf_target_reg));
@@ -2030,7 +2030,7 @@ static void ftdi_process_read(struct work_struct *work) <nl>  			spin_unlock_irqrestore(&priv->rx_lock, flags); <nl>  			dbg("%s - deferring remainder until unthrottled", <nl>  					__func__); <nl> -			return; <nl> +			goto out; <nl>  		} <nl>  		spin_unlock_irqrestore(&priv->rx_lock, flags); <nl>  		/* if the port is closed stop trying to read */
@@ -76,7 +76,7 @@ static struct collection collections[] = { <nl>   <nl>  /* Iterate over all benchmarks within a collection: */ <nl>  #define for_each_bench(coll, bench) \ <nl> -	for (bench = coll->benchmarks; bench->name; bench++) <nl> +	for (bench = coll->benchmarks; bench && bench->name; bench++) <nl>   <nl>  static void dump_benchmarks(struct collection *coll) <nl>  {
@@ -808,7 +808,8 @@ static int hyp_init_cpu_notify(struct notifier_block *self, <nl>  	switch (action) { <nl>  	case CPU_STARTING: <nl>  	case CPU_STARTING_FROZEN: <nl> -		cpu_init_hyp_mode(NULL); <nl> +		if (__hyp_get_vectors() == hyp_default_vectors) <nl> +			cpu_init_hyp_mode(NULL); <nl>  		break; <nl>  	} <nl>  
@@ -2113,7 +2113,8 @@ static int set_connectable(struct sock *sk, struct hci_dev *hdev, void *data, <nl>   <nl>  no_scan_update: <nl>  	/* Update the advertising parameters if necessary */ <nl> -	if (hci_dev_test_flag(hdev, HCI_ADVERTISING)) <nl> +	if (hci_dev_test_flag(hdev, HCI_ADVERTISING) || <nl> +	    hci_dev_test_flag(hdev, HCI_ADVERTISING_INSTANCE)) <nl>  		enable_advertising(&req); <nl>   <nl>  	err = hci_req_run(&req, set_connectable_complete);
@@ -487,6 +487,8 @@ int rt2x00mac_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd, <nl>  	crypto.cipher = rt2x00crypto_key_to_cipher(key); <nl>  	if (crypto.cipher == CIPHER_NONE) <nl>  		return -EOPNOTSUPP; <nl> +	if (crypto.cipher == CIPHER_TKIP && rt2x00_is_usb(rt2x00dev)) <nl> +		return -EOPNOTSUPP; <nl>   <nl>  	crypto.cmd = cmd; <nl>  
@@ -213,6 +213,10 @@ static struct miscdevice erst_dbg_dev = { <nl>   <nl>  static __init int erst_dbg_init(void) <nl>  { <nl> +	if (erst_disable) { <nl> +		pr_info(ERST_DBG_PFX "ERST support is disabled.\n"); <nl> +		return -ENODEV; <nl> +	} <nl>  	return misc_register(&erst_dbg_dev); <nl>  } <nl>  
@@ -45,7 +45,8 @@ struct xc5000_config { <nl>  /* xc5000 callback command */ <nl>  #define XC5000_TUNER_RESET		0 <nl>   <nl> -#if defined(CONFIG_DVB_TUNER_XC5000) || defined(CONFIG_DVB_TUNER_XC5000_MODULE) <nl> +#if defined(CONFIG_DVB_TUNER_XC5000) || \ <nl> +    (defined(CONFIG_DVB_TUNER_XC5000_MODULE) && defined(MODULE)) <nl>  extern struct dvb_frontend* xc5000_attach(struct dvb_frontend *fe, <nl>  					  struct i2c_adapter *i2c, <nl>  					  struct xc5000_config *cfg);
@@ -963,6 +963,7 @@ vt6656_probe(struct usb_interface *intf, const struct usb_device_id *id) <nl>  	hw = ieee80211_alloc_hw(sizeof(struct vnt_private), &vnt_mac_ops); <nl>  	if (!hw) { <nl>  		dev_err(&udev->dev, "could not register ieee80211_hw\n"); <nl> +		rc = -ENOMEM; <nl>  		goto err_nomem; <nl>  	} <nl>  
@@ -93,6 +93,7 @@ static long media_device_enum_entities(struct media_device *mdev, <nl>  	struct media_entity *ent; <nl>  	struct media_entity_desc u_ent; <nl>   <nl> +	memset(&u_ent, 0, sizeof(u_ent)); <nl>  	if (copy_from_user(&u_ent.id, &uent->id, sizeof(u_ent.id))) <nl>  		return -EFAULT; <nl>  
@@ -79,8 +79,8 @@ void debug_mutex_unlock(struct mutex *lock) <nl>  	if (unlikely(!debug_locks)) <nl>  		return; <nl>   <nl> -	DEBUG_LOCKS_WARN_ON(lock->owner != current_thread_info()); <nl>  	DEBUG_LOCKS_WARN_ON(lock->magic != lock); <nl> +	DEBUG_LOCKS_WARN_ON(lock->owner != current_thread_info()); <nl>  	DEBUG_LOCKS_WARN_ON(!lock->wait_list.prev && !lock->wait_list.next); <nl>  	DEBUG_LOCKS_WARN_ON(lock->owner != current_thread_info()); <nl>  }
@@ -971,7 +971,7 @@ void radeon_compute_pll_legacy(struct radeon_pll *pll, <nl>  		max_fractional_feed_div = pll->max_frac_feedback_div; <nl>  	} <nl>   <nl> -	for (post_div = min_post_div; post_div <= max_post_div; ++post_div) { <nl> +	for (post_div = max_post_div; post_div >= min_post_div; --post_div) { <nl>  		uint32_t ref_div; <nl>   <nl>  		if ((pll->flags & RADEON_PLL_NO_ODD_POST_DIV) && (post_div & 1))
@@ -189,7 +189,7 @@ void kvm_ioapic_calculate_eoi_exitmap(struct kvm_vcpu *vcpu, <nl>  		if (!e->fields.mask && <nl>  			(e->fields.trig_mode == IOAPIC_LEVEL_TRIG || <nl>  			 kvm_irq_has_notifier(ioapic->kvm, KVM_IRQCHIP_IOAPIC, <nl> -				 index))) { <nl> +				 index) || index == RTC_GSI)) { <nl>  			if (kvm_apic_match_dest(vcpu, NULL, 0, <nl>  				e->fields.dest_id, e->fields.dest_mode)) <nl>  				__set_bit(e->fields.vector, (unsigned long *)eoi_exit_bitmap);
@@ -6138,7 +6138,8 @@ void md_check_recovery(mddev_t *mddev) <nl>  			/* resync has finished, collect result */ <nl>  			md_unregister_thread(mddev->sync_thread); <nl>  			mddev->sync_thread = NULL; <nl> -			if (!test_bit(MD_RECOVERY_INTR, &mddev->recovery)) { <nl> +			if (!test_bit(MD_RECOVERY_INTR, &mddev->recovery) && <nl> +			    !test_bit(MD_RECOVERY_REQUESTED, &mddev->recovery)) { <nl>  				/* success...*/ <nl>  				/* activate any spares */ <nl>  				if (mddev->pers->spare_active(mddev)) <nl> @@ -6190,6 +6191,7 @@ void md_check_recovery(mddev_t *mddev) <nl>  		} else if ((spares = remove_and_add_spares(mddev))) { <nl>  			clear_bit(MD_RECOVERY_SYNC, &mddev->recovery); <nl>  			clear_bit(MD_RECOVERY_CHECK, &mddev->recovery); <nl> +			clear_bit(MD_RECOVERY_REQUESTED, &mddev->recovery); <nl>  			set_bit(MD_RECOVERY_RECOVER, &mddev->recovery); <nl>  		} else if (mddev->recovery_cp < MaxSector) { <nl>  			set_bit(MD_RECOVERY_SYNC, &mddev->recovery);
@@ -123,6 +123,7 @@ static int exynos_drm_fbdev_update(struct drm_fb_helper *helper, <nl>   <nl>  	fbi->screen_base = buffer->kvaddr + offset; <nl>  	fbi->screen_size = size; <nl> +	fbi->fix.smem_len = size; <nl>   <nl>  	return 0; <nl>  }
@@ -23,7 +23,7 @@ int eprintf(int level, const char *fmt, ...) <nl>   <nl>  	if (verbose >= level) { <nl>  		va_start(args, fmt); <nl> -		if (use_browser > 1) <nl> +		if (use_browser >= 1) <nl>  			ui_helpline__vshow(fmt, args); <nl>  		else <nl>  			ret = vfprintf(stderr, fmt, args);
@@ -67,6 +67,7 @@ static struct sms_board sms_boards[] = { <nl>  		.board_cfg.leds_power = 26, <nl>  		.board_cfg.led0 = 27, <nl>  		.board_cfg.led1 = 28, <nl> +		.board_cfg.ir = 9, <nl>  		.led_power = 26, <nl>  		.led_lo    = 27, <nl>  		.led_hi    = 28,
@@ -1669,10 +1669,10 @@ static int gfar_get_cls_all(struct gfar_private *priv, <nl>  	u32 i = 0; <nl>   <nl>  	list_for_each_entry(comp, &priv->rx_list.list, list) { <nl> -		if (i <= cmd->rule_cnt) { <nl> -			rule_locs[i] = comp->fs.location; <nl> -			i++; <nl> -		} <nl> +		if (i == cmd->rule_cnt) <nl> +			return -EMSGSIZE; <nl> +		rule_locs[i] = comp->fs.location; <nl> +		i++; <nl>  	} <nl>   <nl>  	cmd->data = MAX_FILER_IDX;
@@ -1645,6 +1645,8 @@ int scsi_error_handler(void *data) <nl>  		set_current_state(TASK_INTERRUPTIBLE); <nl>  	} <nl>   <nl> +	__set_current_state(TASK_RUNNING); <nl> + <nl>  	SCSI_LOG_ERROR_RECOVERY(1, printk("Error handler scsi_eh_%d" <nl>  					  " exiting\n",shost->host_no)); <nl>  
@@ -102,8 +102,6 @@ DEFINE_PER_CPU_READ_MOSTLY(cpumask_var_t, cpu_llc_shared_map); <nl>  DEFINE_PER_CPU_SHARED_ALIGNED(struct cpuinfo_x86, cpu_info); <nl>  EXPORT_PER_CPU_SYMBOL(cpu_info); <nl>   <nl> -static DEFINE_PER_CPU(struct completion, die_complete); <nl> - <nl>  atomic_t init_deasserted; <nl>   <nl>  /* <nl> @@ -1318,6 +1316,8 @@ void cpu_disable_common(void) <nl>  	fixup_irqs(); <nl>  } <nl>   <nl> +static DEFINE_PER_CPU(struct completion, die_complete); <nl> + <nl>  int native_cpu_disable(void) <nl>  { <nl>  	int ret;
@@ -7862,7 +7862,8 @@ static void tg3_timer(unsigned long __opaque) <nl>  	 * resets. <nl>  	 */ <nl>  	if (!--tp->asf_counter) { <nl> -		if (tp->tg3_flags & TG3_FLAG_ENABLE_ASF) { <nl> +		if ((tp->tg3_flags & TG3_FLAG_ENABLE_ASF) && <nl> +		    !(tp->tg3_flags3 & TG3_FLG3_ENABLE_APE)) { <nl>  			u32 val; <nl>   <nl>  			tg3_wait_for_event_ack(tp);
@@ -175,6 +175,7 @@ __xfrm4_bundle_create(struct xfrm_policy *policy, struct xfrm_state **xfrm, int <nl>  		afinfo = xfrm_state_get_afinfo(dst_prev->xfrm->props.family); <nl>  		if (!afinfo) { <nl>  			dst = *dst_p; <nl> +			err = -EAFNOSUPPORT; <nl>  			goto error; <nl>  		} <nl>  		dst_prev->output = afinfo->output;
@@ -135,6 +135,7 @@ int ping_v6_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg, <nl>  	fl6.flowi6_proto = IPPROTO_ICMPV6; <nl>  	fl6.saddr = np->saddr; <nl>  	fl6.daddr = *daddr; <nl> +	fl6.flowi6_mark = sk->sk_mark; <nl>  	fl6.fl6_icmp_type = user_icmph.icmp6_type; <nl>  	fl6.fl6_icmp_code = user_icmph.icmp6_code; <nl>  	security_sk_classify_flow(sk, flowi6_to_flowi(&fl6));
@@ -447,6 +447,10 @@ int sctp_sysctl_net_register(struct net *net) <nl>  		table[i].data += (char *)(&net->sctp) - (char *)&init_net.sctp; <nl>   <nl>  	net->sctp.sysctl_header = register_net_sysctl(net, "net/sctp", table); <nl> +	if (net->sctp.sysctl_header == NULL) { <nl> +		kfree(table); <nl> +		return -ENOMEM; <nl> +	} <nl>  	return 0; <nl>  } <nl>  
@@ -1579,6 +1579,7 @@ struct ion_device *ion_device_create(long (*custom_ioctl) <nl>  	ret = misc_register(&idev->dev); <nl>  	if (ret) { <nl>  		pr_err("ion: failed to register misc device.\n"); <nl> +		kfree(idev); <nl>  		return ERR_PTR(ret); <nl>  	} <nl>  
@@ -724,7 +724,7 @@ static int m5mols_s_stream(struct v4l2_subdev *sd, int enable) <nl>  	if (enable) { <nl>  		if (is_code(code, M5MOLS_RESTYPE_MONITOR)) <nl>  			ret = m5mols_start_monitor(info); <nl> -		if (is_code(code, M5MOLS_RESTYPE_CAPTURE)) <nl> +		else if (is_code(code, M5MOLS_RESTYPE_CAPTURE)) <nl>  			ret = m5mols_start_capture(info); <nl>  		else <nl>  			ret = -EINVAL;
@@ -391,19 +391,19 @@ kvm_irqfd_assign(struct kvm *kvm, struct kvm_irqfd *args) <nl>  					   lockdep_is_held(&kvm->irqfds.lock)); <nl>  	irqfd_update(kvm, irqfd, irq_rt); <nl>   <nl> -	events = f.file->f_op->poll(f.file, &irqfd->pt); <nl> - <nl>  	list_add_tail(&irqfd->list, &kvm->irqfds.items); <nl>   <nl> +	spin_unlock_irq(&kvm->irqfds.lock); <nl> + <nl>  	/* <nl>  	 * Check if there was an event already pending on the eventfd <nl>  	 * before we registered, and trigger it as if we didn't miss it. <nl>  	 */ <nl> +	events = f.file->f_op->poll(f.file, &irqfd->pt); <nl> + <nl>  	if (events & POLLIN) <nl>  		schedule_work(&irqfd->inject); <nl>   <nl> -	spin_unlock_irq(&kvm->irqfds.lock); <nl> - <nl>  	/* <nl>  	 * do not drop the file until the irqfd is fully initialized, otherwise <nl>  	 * we might race against the POLLHUP
@@ -1365,11 +1365,6 @@ static int init_fb_chan(struct mx3fb_data *mx3fb, struct idmac_channel *ichan) <nl>  	init_completion(&mx3fbi->flip_cmpl); <nl>  	disable_irq(ichan->eof_irq); <nl>  	dev_dbg(mx3fb->dev, "disabling irq %d\n", ichan->eof_irq); <nl> -	ret = mx3fb_set_par(fbi); <nl> -	if (ret < 0) <nl> -		goto esetpar; <nl> - <nl> -	mx3fb_blank(FB_BLANK_UNBLANK, fbi); <nl>   <nl>  	dev_info(dev, "registered, using mode %s\n", fb_mode); <nl>  
@@ -105,7 +105,7 @@ static struct platform_device *ssb_hcd_create_pdev(struct ssb_device *dev, bool <nl>  { <nl>  	struct platform_device *hci_dev; <nl>  	struct resource hci_res[2]; <nl> -	int ret = -ENOMEM; <nl> +	int ret; <nl>   <nl>  	memset(hci_res, 0, sizeof(hci_res)); <nl>   <nl> @@ -119,7 +119,7 @@ static struct platform_device *ssb_hcd_create_pdev(struct ssb_device *dev, bool <nl>  	hci_dev = platform_device_alloc(ohci ? "ohci-platform" : <nl>  					"ehci-platform" , 0); <nl>  	if (!hci_dev) <nl> -		return NULL; <nl> +		return ERR_PTR(-ENOMEM); <nl>   <nl>  	hci_dev->dev.parent = dev->dev; <nl>  	hci_dev->dev.dma_mask = &hci_dev->dev.coherent_dma_mask;
@@ -2990,7 +2990,7 @@ void kvm_mmu_slot_remove_write_access(struct kvm *kvm, int slot) <nl>  		pt = sp->spt; <nl>  		for (i = 0; i < PT64_ENT_PER_PAGE; ++i) <nl>  			/* avoid RMW */ <nl> -			if (pt[i] & PT_WRITABLE_MASK) <nl> +			if (is_writable_pte(pt[i])) <nl>  				pt[i] &= ~PT_WRITABLE_MASK; <nl>  	} <nl>  	kvm_flush_remote_tlbs(kvm); <nl> @@ -3425,7 +3425,7 @@ void inspect_spte_has_rmap(struct kvm *kvm, u64 *sptep) <nl>  	struct kvm_mmu_page *rev_sp; <nl>  	gfn_t gfn; <nl>   <nl> -	if (*sptep & PT_WRITABLE_MASK) { <nl> +	if (is_writable_pte(*sptep)) { <nl>  		rev_sp = page_header(__pa(sptep)); <nl>  		gfn = kvm_mmu_page_get_gfn(rev_sp, sptep - rev_sp->spt); <nl>   <nl> @@ -3474,7 +3474,7 @@ static void check_writable_mappings_rmap(struct kvm_vcpu *vcpu) <nl>   <nl>  			if (!(ent & PT_PRESENT_MASK)) <nl>  				continue; <nl> -			if (!(ent & PT_WRITABLE_MASK)) <nl> +			if (!is_writable_pte(ent)) <nl>  				continue; <nl>  			inspect_spte_has_rmap(vcpu->kvm, &pt[i]); <nl>  		} <nl> @@ -3508,7 +3508,7 @@ static void audit_write_protection(struct kvm_vcpu *vcpu) <nl>   <nl>  		spte = rmap_next(vcpu->kvm, rmapp, NULL); <nl>  		while (spte) { <nl> -			if (*spte & PT_WRITABLE_MASK) <nl> +			if (is_writable_pte(*spte)) <nl>  				printk(KERN_ERR "%s: (%s) shadow page has " <nl>  				"writable mappings: gfn %lx role %x\n", <nl>  			       __func__, audit_msg, sp->gfn,
@@ -34,7 +34,7 @@ <nl>   <nl>  #define __pfn_to_page(pfn)			\ <nl>  ({	unsigned long __pfn = (pfn);		\ <nl> -	unsigned long __nid = arch_pfn_to_nid(pfn);  \ <nl> +	unsigned long __nid = arch_pfn_to_nid(__pfn);  \ <nl>  	NODE_DATA(__nid)->node_mem_map + arch_local_page_offset(__pfn, __nid);\ <nl>  }) <nl>  
@@ -2092,8 +2092,9 @@ static void bnx2x_cmng_fns_init(struct bnx2x *bp, u8 read_cfg, u8 cmng_type) <nl>  		bnx2x_calc_vn_weight_sum(bp); <nl>   <nl>  		/* calculate and set min-max rate for each vn */ <nl> -		for (vn = VN_0; vn < E1HVN_MAX; vn++) <nl> -			bnx2x_init_vn_minmax(bp, vn); <nl> +		if (bp->port.pmf) <nl> +			for (vn = VN_0; vn < E1HVN_MAX; vn++) <nl> +				bnx2x_init_vn_minmax(bp, vn); <nl>   <nl>  		/* always enable rate shaping and fairness */ <nl>  		bp->cmng.flags.cmng_enables |=
@@ -4532,6 +4532,7 @@ static int __devinit rtl8192_pci_probe(struct pci_dev *pdev, <nl>  	u8 unit = 0; <nl>  	int ret = -ENODEV; <nl>  	unsigned long pmem_start, pmem_len, pmem_flags; <nl> +	u8 revisionid; <nl>   <nl>  	RT_TRACE(COMP_INIT,"Configuring chip resources\n"); <nl>   <nl> @@ -4592,6 +4593,11 @@ static int __devinit rtl8192_pci_probe(struct pci_dev *pdev, <nl>           pci_write_config_byte(pdev, 0x41, 0x00); <nl>   <nl>   <nl> +	pci_read_config_byte(pdev, 0x08, &revisionid); <nl> +	/* If the revisionid is 0x10, the device uses rtl8192se. */ <nl> +	if (pdev->device == 0x8192 && revisionid == 0x10) <nl> +		goto fail1; <nl> + <nl>  	pci_read_config_byte(pdev, 0x05, &unit); <nl>  	pci_write_config_byte(pdev, 0x05, unit & (~0x04)); <nl>  
@@ -421,7 +421,8 @@ static long rtc_dev_ioctl(struct file *file, <nl>  			err = ops->ioctl(rtc->dev.parent, cmd, arg); <nl>  			if (err == -ENOIOCTLCMD) <nl>  				err = -ENOTTY; <nl> -		} <nl> +		} else <nl> +			err = -ENOTTY; <nl>  		break; <nl>  	} <nl>  
@@ -4391,6 +4391,7 @@ tracing_mark_write(struct file *filp, const char __user *ubuf, <nl>  					size_t cnt, loff_t *fpos) <nl>  { <nl>  	unsigned long addr = (unsigned long)ubuf; <nl> +	struct trace_array *tr = filp->private_data; <nl>  	struct ring_buffer_event *event; <nl>  	struct ring_buffer *buffer; <nl>  	struct print_entry *entry; <nl> @@ -4450,7 +4451,7 @@ tracing_mark_write(struct file *filp, const char __user *ubuf, <nl>   <nl>  	local_save_flags(irq_flags); <nl>  	size = sizeof(*entry) + cnt + 2; /* possible \n added */ <nl> -	buffer = global_trace.trace_buffer.buffer; <nl> +	buffer = tr->trace_buffer.buffer; <nl>  	event = trace_buffer_lock_reserve(buffer, TRACE_PRINT, size, <nl>  					  irq_flags, preempt_count()); <nl>  	if (!event) {
@@ -380,6 +380,7 @@ static int uevent_net_init(struct net *net) <nl>  	if (!ue_sk->sk) { <nl>  		printk(KERN_ERR <nl>  		       "kobject_uevent: unable to create netlink socket!\n"); <nl> +		kfree(ue_sk); <nl>  		return -ENODEV; <nl>  	} <nl>  	mutex_lock(&uevent_sock_mutex);
@@ -1026,8 +1026,10 @@ int iop13xx_pci_setup(int nr, struct pci_sys_data *sys) <nl>  		which_atu = 0; <nl>  	} <nl>   <nl> -	if (!which_atu) <nl> +	if (!which_atu) { <nl> +		kfree(res); <nl>  		return 0; <nl> +	} <nl>   <nl>  	switch(which_atu) { <nl>  	case IOP13XX_INIT_ATU_ATUX: <nl> @@ -1074,6 +1076,7 @@ int iop13xx_pci_setup(int nr, struct pci_sys_data *sys) <nl>  		sys->map_irq = iop13xx_pcie_map_irq; <nl>  		break; <nl>  	default: <nl> +		kfree(res); <nl>  		return 0; <nl>  	} <nl>  
@@ -1158,6 +1158,10 @@ static unsigned int <nl>  mpeg_poll(struct file *file, struct poll_table_struct *wait) <nl>  { <nl>  	struct cx8802_fh *fh = file->private_data; <nl> +	struct cx8802_dev *dev = fh->dev; <nl> + <nl> +	if (!dev->mpeg_active) <nl> +		blackbird_start_codec(file, fh); <nl>   <nl>  	return videobuf_poll_stream(file, &fh->mpegq, wait); <nl>  }
@@ -508,6 +508,12 @@ sbc_compare_and_write(struct se_cmd *cmd) <nl>  		cmd->transport_complete_callback = NULL; <nl>  		return TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE; <nl>  	} <nl> +	/* <nl> +	 * Reset cmd->data_length to individual block_size in order to not <nl> +	 * confuse backend drivers that depend on this value matching the <nl> +	 * size of the I/O being submitted. <nl> +	 */ <nl> +	cmd->data_length = cmd->t_task_nolb * dev->dev_attrib.block_size; <nl>   <nl>  	ret = cmd->execute_rw(cmd, cmd->t_bidi_data_sg, cmd->t_bidi_data_nents, <nl>  			      DMA_FROM_DEVICE);
@@ -162,10 +162,11 @@ static void mv_chan_set_mode(struct mv_xor_chan *chan, <nl>  	config &= ~0x7; <nl>  	config |= op_mode; <nl>   <nl> -	if (IS_ENABLED(__BIG_ENDIAN)) <nl> -		config |= XOR_DESCRIPTOR_SWAP; <nl> -	else <nl> -		config &= ~XOR_DESCRIPTOR_SWAP; <nl> +#if defined(__BIG_ENDIAN) <nl> +	config |= XOR_DESCRIPTOR_SWAP; <nl> +#else <nl> +	config &= ~XOR_DESCRIPTOR_SWAP; <nl> +#endif <nl>   <nl>  	writel_relaxed(config, XOR_CONFIG(chan)); <nl>  	chan->current_type = type;
@@ -1193,7 +1193,7 @@ static int max77693_muic_probe(struct platform_device *pdev) <nl>   <nl>   <nl>  	/* Initialize MUIC register by using platform data or default data */ <nl> -	if (pdata->muic_data) { <nl> +	if (pdata && pdata->muic_data) { <nl>  		init_data = pdata->muic_data->init_data; <nl>  		num_init_data = pdata->muic_data->num_init_data; <nl>  	} else { <nl> @@ -1226,7 +1226,7 @@ static int max77693_muic_probe(struct platform_device *pdev) <nl>  				= init_data[i].data; <nl>  	} <nl>   <nl> -	if (pdata->muic_data) { <nl> +	if (pdata && pdata->muic_data) { <nl>  		struct max77693_muic_platform_data *muic_pdata <nl>  						   = pdata->muic_data; <nl>  
@@ -705,7 +705,9 @@ static int bcm_acpi_probe(struct bcm_device *dev) <nl>  	if (!adev) <nl>  		return 0; <nl>   <nl> -	acpi_dev_get_resources(adev, &resources, bcm_resource, dev); <nl> +	ret = acpi_dev_get_resources(adev, &resources, bcm_resource, dev); <nl> +	if (ret < 0) <nl> +		return ret; <nl>  	acpi_dev_free_resource_list(&resources); <nl>   <nl>  	dmi_id = dmi_first_match(bcm_wrong_irq_dmi_table);
@@ -2478,6 +2478,7 @@ static void btrfs_qgroup_rescan_worker(struct btrfs_work *work) <nl>  out: <nl>  	kfree(scratch_leaf); <nl>  	ulist_free(qgroups); <nl> +	ulist_free(tmp); <nl>  	btrfs_free_path(path); <nl>   <nl>  	mutex_lock(&fs_info->qgroup_rescan_lock);
@@ -258,6 +258,7 @@ int radeonfb_create(struct drm_device *dev, <nl>  		goto out_unref; <nl>  	} <nl>   <nl> +	rdev->fbdev_info = info; <nl>  	rfbdev = info->par; <nl>  	rfbdev->helper.funcs = &radeon_fb_helper_funcs; <nl>  	rfbdev->helper.dev = dev;
@@ -739,8 +739,12 @@ static void conn_action_txdone(fsm_instance *fi, int event, void *arg) <nl>   <nl>  	IUCV_DBF_TEXT(trace, 4, __func__); <nl>   <nl> -	if (conn && conn->netdev) <nl> -		privptr = netdev_priv(conn->netdev); <nl> +	if (!conn || !conn->netdev) { <nl> +		IUCV_DBF_TEXT(data, 2, <nl> +			      "Send confirmation for unlinked connection\n"); <nl> +		return; <nl> +	} <nl> +	privptr = netdev_priv(conn->netdev); <nl>  	conn->prof.tx_pending--; <nl>  	if (single_flag) { <nl>  		if ((skb = skb_dequeue(&conn->commit_queue))) {
@@ -3040,6 +3040,10 @@ static noinline int setup_leaf_for_split(struct btrfs_trans_handle *trans, <nl>  	if (ret > 0 || item_size != btrfs_item_size_nr(leaf, path->slots[0])) <nl>  		goto err; <nl>   <nl> +	/* the leaf has  changed, it now has room.  return now */ <nl> +	if (btrfs_leaf_free_space(root, path->nodes[0]) >= ins_len) <nl> +		goto err; <nl> + <nl>  	if (key.type == BTRFS_EXTENT_DATA_KEY) { <nl>  		fi = btrfs_item_ptr(leaf, path->slots[0], <nl>  				    struct btrfs_file_extent_item);
@@ -744,11 +744,11 @@ conf_software: <nl>  					if (dsp->pcm_slot_rx >= 0 && <nl>  					    dsp->pcm_slot_rx < <nl>  					    sizeof(freeslots)) <nl> -						freeslots[dsp->pcm_slot_tx] = 0; <nl> +						freeslots[dsp->pcm_slot_rx] = 0; <nl>  					if (dsp->pcm_slot_tx >= 0 && <nl>  					    dsp->pcm_slot_tx < <nl>  					    sizeof(freeslots)) <nl> -						freeslots[dsp->pcm_slot_rx] = 0; <nl> +						freeslots[dsp->pcm_slot_tx] = 0; <nl>  				} <nl>  			} <nl>  			i = 0; <nl> @@ -836,11 +836,11 @@ conf_software: <nl>  					if (dsp->pcm_slot_rx >= 0 && <nl>  					    dsp->pcm_slot_rx < <nl>  					    sizeof(freeslots)) <nl> -						freeslots[dsp->pcm_slot_tx] = 0; <nl> +						freeslots[dsp->pcm_slot_rx] = 0; <nl>  					if (dsp->pcm_slot_tx >= 0 && <nl>  					    dsp->pcm_slot_tx < <nl>  					    sizeof(freeslots)) <nl> -						freeslots[dsp->pcm_slot_rx] = 0; <nl> +						freeslots[dsp->pcm_slot_tx] = 0; <nl>  				} <nl>  			} <nl>  			i1 = 0;
@@ -175,7 +175,7 @@ static int pmic8xxx_pwrkey_probe(struct platform_device *pdev) <nl>  	return 0; <nl>   <nl>  free_press_irq: <nl> -	free_irq(key_press_irq, NULL); <nl> +	free_irq(key_press_irq, pwrkey); <nl>  unreg_input_dev: <nl>  	input_unregister_device(pwr); <nl>  	pwr = NULL;
@@ -36,7 +36,9 @@ int abx500_register_ops(struct device *dev, struct abx500_ops *ops) <nl>  { <nl>  	struct abx500_device_entry *dev_entry; <nl>   <nl> -	dev_entry = kzalloc(sizeof(struct abx500_device_entry), GFP_KERNEL); <nl> +	dev_entry = devm_kzalloc(dev, <nl> +				 sizeof(struct abx500_device_entry), <nl> +				 GFP_KERNEL); <nl>  	if (!dev_entry) { <nl>  		dev_err(dev, "register_ops kzalloc failed"); <nl>  		return -ENOMEM; <nl> @@ -54,12 +56,8 @@ void abx500_remove_ops(struct device *dev) <nl>  	struct abx500_device_entry *dev_entry, *tmp; <nl>   <nl>  	list_for_each_entry_safe(dev_entry, tmp, &abx500_list, list) <nl> -	{ <nl> -		if (dev_entry->dev == dev) { <nl> +		if (dev_entry->dev == dev) <nl>  			list_del(&dev_entry->list); <nl> -			kfree(dev_entry); <nl> -		} <nl> -	} <nl>  } <nl>  EXPORT_SYMBOL(abx500_remove_ops); <nl>  
@@ -127,6 +127,7 @@ struct zx_dma_dev { <nl>  	struct dma_pool		*pool; <nl>  	u32			dma_channels; <nl>  	u32			dma_requests; <nl> +	int 			irq; <nl>  }; <nl>   <nl>  #define to_zx_dma(dmadev) container_of(dmadev, struct zx_dma_dev, slave) <nl> @@ -683,7 +684,7 @@ static int zx_dma_probe(struct platform_device *op) <nl>  { <nl>  	struct zx_dma_dev *d; <nl>  	struct resource *iores; <nl> -	int i, ret = 0, irq = 0; <nl> +	int i, ret = 0; <nl>   <nl>  	iores = platform_get_resource(op, IORESOURCE_MEM, 0); <nl>  	if (!iores) <nl> @@ -710,8 +711,8 @@ static int zx_dma_probe(struct platform_device *op) <nl>  		return PTR_ERR(d->clk); <nl>  	} <nl>   <nl> -	irq = platform_get_irq(op, 0); <nl> -	ret = devm_request_irq(&op->dev, irq, zx_dma_int_handler, <nl> +	d->irq = platform_get_irq(op, 0); <nl> +	ret = devm_request_irq(&op->dev, d->irq, zx_dma_int_handler, <nl>  			       0, DRIVER_NAME, d); <nl>  	if (ret) <nl>  		return ret; <nl> @@ -807,6 +808,9 @@ static int zx_dma_remove(struct platform_device *op) <nl>  	struct zx_dma_chan *c, *cn; <nl>  	struct zx_dma_dev *d = platform_get_drvdata(op); <nl>   <nl> +	/* explictly free the irq */ <nl> +	devm_free_irq(&op->dev, d->irq, d); <nl> + <nl>  	dma_async_device_unregister(&d->slave); <nl>  	of_dma_controller_free((&op->dev)->of_node); <nl>  
@@ -1597,7 +1597,7 @@ unsigned slab_node(struct mempolicy *policy) <nl>  		(void)first_zones_zonelist(zonelist, highest_zoneidx, <nl>  							&policy->v.nodes, <nl>  							&zone); <nl> -		return zone->node; <nl> +		return zone ? zone->node : numa_node_id(); <nl>  	} <nl>   <nl>  	default:
@@ -805,6 +805,8 @@ static int tpm_tis_init(struct device *dev, struct tpm_info *tpm_info, <nl>  			iowrite32(intmask, <nl>  				  chip->vendor.iobase + <nl>  				  TPM_INT_ENABLE(chip->vendor.locality)); <nl> + <nl> +			devm_free_irq(dev, i, chip); <nl>  		} <nl>  	} <nl>  	if (chip->vendor.irq) {
@@ -381,7 +381,7 @@ static ssize_t <nl>  v9fs_file_read_iter(struct kiocb *iocb, struct iov_iter *to) <nl>  { <nl>  	struct p9_fid *fid = iocb->ki_filp->private_data; <nl> -	int ret, err; <nl> +	int ret, err = 0; <nl>   <nl>  	p9_debug(P9_DEBUG_VFS, "count %zu offset %lld\n", <nl>  		 iov_iter_count(to), iocb->ki_pos);
@@ -383,11 +383,13 @@ static int at91_rtc_resume(struct device *dev) <nl>   <nl>  static SIMPLE_DEV_PM_OPS(at91_rtc_pm_ops, at91_rtc_suspend, at91_rtc_resume); <nl>   <nl> +#ifdef CONFIG_OF <nl>  static const struct of_device_id at91_rtc_dt_ids[] = { <nl>  	{ .compatible = "atmel,at91rm9200-rtc" }, <nl>  	{ /* sentinel */ } <nl>  }; <nl>  MODULE_DEVICE_TABLE(of, at91_rtc_dt_ids); <nl> +#endif <nl>   <nl>  static struct platform_driver at91_rtc_driver = { <nl>  	.remove		= __exit_p(at91_rtc_remove),
@@ -1421,7 +1421,8 @@ ofail:	mutex_unlock(&cp->mutex); <nl>   <nl>   <nl>  /* IOCTL functions */ <nl> -static int auerchar_ioctl (struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg) <nl> +static long auerchar_ioctl(struct file *file, unsigned int cmd, <nl> +							unsigned long arg) <nl>  { <nl>  	pauerchar_t ccp = (pauerchar_t) file->private_data; <nl>  	int ret = 0; <nl> @@ -1452,7 +1453,7 @@ static int auerchar_ioctl (struct inode *inode, struct file *file, unsigned int <nl>  		mutex_unlock(&ccp->mutex); <nl>                  return -ENODEV; <nl>  	} <nl> - <nl> +	lock_kernel(); <nl>  	switch (cmd) { <nl>   <nl>  	/* return != 0 if Transmitt channel ready to send */ <nl> @@ -1547,9 +1548,10 @@ static int auerchar_ioctl (struct inode *inode, struct file *file, unsigned int <nl>   <nl>  	default: <nl>  		dbg ("IOCTL_AU_UNKNOWN"); <nl> -		ret = -ENOIOCTLCMD; <nl> +		ret = -ENOTTY; <nl>  		break; <nl>          } <nl> +        unlock_kernel(); <nl>  	/* release the mutexes */ <nl>  	mutex_unlock(&cp->mutex); <nl>  	mutex_unlock(&ccp->mutex); <nl> @@ -1860,7 +1862,7 @@ static const struct file_operations auerswald_fops = <nl>  	.llseek =	no_llseek, <nl>  	.read =		auerchar_read, <nl>  	.write =        auerchar_write, <nl> -	.ioctl =	auerchar_ioctl, <nl> +	.unlocked_ioctl = auerchar_ioctl, <nl>  	.open =		auerchar_open, <nl>  	.release =	auerchar_release, <nl>  };
@@ -10,7 +10,11 @@ static inline void smpboot_clear_io_apic_irqs(void) <nl>   <nl>  static inline void smpboot_setup_warm_reset_vector(unsigned long start_eip) <nl>  { <nl> +	unsigned long flags; <nl> + <nl> +	spin_lock_irqsave(&rtc_lock, flags); <nl>  	CMOS_WRITE(0xa, 0xf); <nl> +	spin_unlock_irqrestore(&rtc_lock, flags); <nl>  	local_flush_tlb(); <nl>  	pr_debug("1.\n"); <nl>  	*((volatile unsigned short *)phys_to_virt(apic->trampoline_phys_high)) = <nl> @@ -23,6 +27,8 @@ static inline void smpboot_setup_warm_reset_vector(unsigned long start_eip) <nl>   <nl>  static inline void smpboot_restore_warm_reset_vector(void) <nl>  { <nl> +	unsigned long flags; <nl> + <nl>  	/* <nl>  	 * Install writable page 0 entry to set BIOS data area. <nl>  	 */ <nl> @@ -32,7 +38,9 @@ static inline void smpboot_restore_warm_reset_vector(void) <nl>  	 * Paranoid:  Set warm reset code and vector here back <nl>  	 * to default values. <nl>  	 */ <nl> +	spin_lock_irqsave(&rtc_lock, flags); <nl>  	CMOS_WRITE(0, 0xf); <nl> +	spin_unlock_irqrestore(&rtc_lock, flags); <nl>   <nl>  	*((volatile u32 *)phys_to_virt(apic->trampoline_phys_low)) = 0; <nl>  }
@@ -388,7 +388,7 @@ static int arizona_hpdet_read(struct arizona_extcon_info *info) <nl>  			   >> ARIZONA_HP_IMPEDANCE_RANGE_SHIFT; <nl>   <nl>  		if (range < ARRAY_SIZE(arizona_hpdet_b_ranges) - 1 && <nl> -		    (val < 100 || val > 0x3fb)) { <nl> +		    (val < 100 || val >= 0x3fb)) { <nl>  			range++; <nl>  			dev_dbg(arizona->dev, "Moving to HPDET range %d\n", <nl>  				range); <nl> @@ -401,7 +401,7 @@ static int arizona_hpdet_read(struct arizona_extcon_info *info) <nl>  		} <nl>   <nl>  		/* If we go out of range report top of range */ <nl> -		if (val < 100 || val > 0x3fb) { <nl> +		if (val < 100 || val >= 0x3fb) { <nl>  			dev_dbg(arizona->dev, "Measurement out of range\n"); <nl>  			return ARIZONA_HPDET_MAX; <nl>  		}
@@ -965,7 +965,7 @@ error: <nl>  } <nl>  #endif <nl>   <nl> -#ifdef CONFIG_PM <nl> +#ifdef CONFIG_PM_SLEEP <nl>  static int omap_dmm_resume(struct device *dev) <nl>  { <nl>  	struct tcm_area area; <nl> @@ -989,12 +989,10 @@ static int omap_dmm_resume(struct device *dev) <nl>   <nl>  	return 0; <nl>  } <nl> - <nl> -static const struct dev_pm_ops omap_dmm_pm_ops = { <nl> -	.resume = omap_dmm_resume, <nl> -}; <nl>  #endif <nl>   <nl> +static SIMPLE_DEV_PM_OPS(omap_dmm_pm_ops, NULL, omap_dmm_resume); <nl> + <nl>  #if defined(CONFIG_OF) <nl>  static const struct dmm_platform_data dmm_omap4_platform_data = { <nl>  	.cpu_cache_flags = OMAP_BO_WC, <nl> @@ -1024,9 +1022,7 @@ struct platform_driver omap_dmm_driver = { <nl>  		.owner = THIS_MODULE, <nl>  		.name = DMM_DRIVER_NAME, <nl>  		.of_match_table = of_match_ptr(dmm_of_match), <nl> -#ifdef CONFIG_PM <nl>  		.pm = &omap_dmm_pm_ops, <nl> -#endif <nl>  	}, <nl>  }; <nl>  
@@ -424,8 +424,8 @@ u32 ath_calcrxfilter(struct ath_softc *sc) <nl>  		rfilt |= ATH9K_RX_FILTER_COMP_BAR; <nl>   <nl>  	if (sc->nvifs > 1 || (sc->rx.rxfilter & FIF_OTHER_BSS)) { <nl> -		/* The following may also be needed for other older chips */ <nl> -		if (sc->sc_ah->hw_version.macVersion == AR_SREV_VERSION_9160) <nl> +		/* This is needed for older chips */ <nl> +		if (sc->sc_ah->hw_version.macVersion <= AR_SREV_VERSION_9160) <nl>  			rfilt |= ATH9K_RX_FILTER_PROM; <nl>  		rfilt |= ATH9K_RX_FILTER_MCAST_BCAST_ALL; <nl>  	}
@@ -1583,11 +1583,10 @@ static int gfar_write_filer_table(struct gfar_private *priv, <nl>  		return -EBUSY; <nl>   <nl>  	/* Fill regular entries */ <nl> -	for (; i < MAX_FILER_IDX - 1 && (tab->fe[i].ctrl | tab->fe[i].prop); <nl> -	     i++) <nl> +	for (; i < MAX_FILER_IDX && (tab->fe[i].ctrl | tab->fe[i].prop); i++) <nl>  		gfar_write_filer(priv, i, tab->fe[i].ctrl, tab->fe[i].prop); <nl>  	/* Fill the rest with fall-troughs */ <nl> -	for (; i < MAX_FILER_IDX - 1; i++) <nl> +	for (; i < MAX_FILER_IDX; i++) <nl>  		gfar_write_filer(priv, i, 0x60, 0xFFFFFFFF); <nl>  	/* Last entry must be default accept <nl>  	 * because that's what people expect
@@ -520,6 +520,15 @@ static struct dmi_system_id acer_quirks[] = { <nl>  		}, <nl>  		.driver_data = &quirk_lenovo_ideapad_s205, <nl>  	}, <nl> +	{ <nl> +		.callback = dmi_matched, <nl> +		.ident = "Lenovo Ideapad S205-1038DPG", <nl> +		.matches = { <nl> +			DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"), <nl> +			DMI_MATCH(DMI_PRODUCT_NAME, "1038DPG"), <nl> +		}, <nl> +		.driver_data = &quirk_lenovo_ideapad_s205, <nl> +	}, <nl>  	{} <nl>  }; <nl>  
@@ -496,7 +496,7 @@ acpi_ds_build_internal_package_obj(struct acpi_walk_state *walk_state, <nl>  			arg = arg->common.next; <nl>  		} <nl>   <nl> -		ACPI_ERROR((AE_INFO, <nl> +		ACPI_WARNING((AE_INFO, <nl>  			    "Package List length (%X) larger than NumElements count (%X), truncated\n", <nl>  			    i, element_count)); <nl>  	} else if (i < element_count) {
@@ -1070,12 +1070,14 @@ static void handle_reg_beacon(struct wiphy *wiphy, <nl>  	if (likely(chan->center_freq != reg_beacon->chan.center_freq)) <nl>  		return; <nl>   <nl> -	if (chan->flags & IEEE80211_CHAN_PASSIVE_SCAN) { <nl> +	if ((chan->flags & IEEE80211_CHAN_PASSIVE_SCAN) && <nl> +	    !(chan->orig_flags & IEEE80211_CHAN_PASSIVE_SCAN)) { <nl>  		chan->flags &= ~IEEE80211_CHAN_PASSIVE_SCAN; <nl>  		REG_DEBUG_BEACON_FLAG("active scanning"); <nl>  	} <nl>   <nl> -	if (chan->flags & IEEE80211_CHAN_NO_IBSS) { <nl> +	if ((chan->flags & IEEE80211_CHAN_NO_IBSS) && <nl> +	    !(chan->orig_flags & IEEE80211_CHAN_NO_IBSS)) { <nl>  		chan->flags &= ~IEEE80211_CHAN_NO_IBSS; <nl>  		REG_DEBUG_BEACON_FLAG("beaconing"); <nl>  	}
@@ -2668,8 +2668,9 @@ static int bcmgenet_probe(struct platform_device *pdev) <nl>  	struct resource *r; <nl>  	int err = -EIO; <nl>   <nl> -	/* Up to GENET_MAX_MQ_CNT + 1 TX queues and a single RX queue */ <nl> -	dev = alloc_etherdev_mqs(sizeof(*priv), GENET_MAX_MQ_CNT + 1, 1); <nl> +	/* Up to GENET_MAX_MQ_CNT + 1 TX queues and RX queues */ <nl> +	dev = alloc_etherdev_mqs(sizeof(*priv), GENET_MAX_MQ_CNT + 1, <nl> +				 GENET_MAX_MQ_CNT + 1); <nl>  	if (!dev) { <nl>  		dev_err(&pdev->dev, "can't allocate net device\n"); <nl>  		return -ENOMEM;
@@ -2520,6 +2520,13 @@ twobyte_insn: <nl>  		c->dst.type = OP_NONE; <nl>  		break; <nl>  	case 0x20: /* mov cr, reg */ <nl> +		switch (c->modrm_reg) { <nl> +		case 1: <nl> +		case 5 ... 7: <nl> +		case 9 ... 15: <nl> +			kvm_queue_exception(ctxt->vcpu, UD_VECTOR); <nl> +			goto done; <nl> +		} <nl>  		c->regs[c->modrm_rm] = ops->get_cr(c->modrm_reg, ctxt->vcpu); <nl>  		c->dst.type = OP_NONE;	/* no writeback */ <nl>  		break;
@@ -76,6 +76,7 @@ void dynamic_irq_cleanup(unsigned int irq) <nl>  	desc->chip_data = NULL; <nl>  	desc->handle_irq = handle_bad_irq; <nl>  	desc->chip = &no_irq_chip; <nl> +	desc->name = NULL; <nl>  	spin_unlock_irqrestore(&desc->lock, flags); <nl>  } <nl>  
@@ -99,7 +99,7 @@ struct gen_estimator_head <nl>   <nl>  static struct gen_estimator_head elist[EST_MAX_INTERVAL+1]; <nl>   <nl> -/* Protects against NULL dereference */ <nl> +/* Protects against NULL dereference and RCU write-side */ <nl>  static DEFINE_RWLOCK(est_lock); <nl>   <nl>  static void est_timer(unsigned long arg) <nl> @@ -185,6 +185,7 @@ int gen_new_estimator(struct gnet_stats_basic *bstats, <nl>  	est->last_packets = bstats->packets; <nl>  	est->avpps = rate_est->pps<<10; <nl>   <nl> +	write_lock_bh(&est_lock); <nl>  	if (!elist[idx].timer.function) { <nl>  		INIT_LIST_HEAD(&elist[idx].list); <nl>  		setup_timer(&elist[idx].timer, est_timer, idx); <nl> @@ -194,6 +195,7 @@ int gen_new_estimator(struct gnet_stats_basic *bstats, <nl>  		mod_timer(&elist[idx].timer, jiffies + ((HZ/4) << idx)); <nl>   <nl>  	list_add_rcu(&est->list, &elist[idx].list); <nl> +	write_unlock_bh(&est_lock); <nl>  	return 0; <nl>  } <nl>   <nl> @@ -212,7 +214,6 @@ static void __gen_kill_estimator(struct rcu_head *head) <nl>   * Removes the rate estimator specified by &bstats and &rate_est <nl>   * and deletes the timer. <nl>   * <nl> - * NOTE: Called under rtnl_mutex <nl>   */ <nl>  void gen_kill_estimator(struct gnet_stats_basic *bstats, <nl>  	struct gnet_stats_rate_est *rate_est) <nl> @@ -226,17 +227,17 @@ void gen_kill_estimator(struct gnet_stats_basic *bstats, <nl>  		if (!elist[idx].timer.function) <nl>  			continue; <nl>   <nl> +		write_lock_bh(&est_lock); <nl>  		list_for_each_entry_safe(e, n, &elist[idx].list, list) { <nl>  			if (e->rate_est != rate_est || e->bstats != bstats) <nl>  				continue; <nl>   <nl> -			write_lock_bh(&est_lock); <nl>  			e->bstats = NULL; <nl> -			write_unlock_bh(&est_lock); <nl>   <nl>  			list_del_rcu(&e->list); <nl>  			call_rcu(&e->e_rcu, __gen_kill_estimator); <nl>  		} <nl> +		write_unlock_bh(&est_lock); <nl>  	} <nl>  } <nl>  
@@ -493,7 +493,7 @@ int twl4030_remove_script(u8 flags) <nl>  	return err; <nl>  } <nl>   <nl> -int twl4030_power_configure_scripts(struct twl4030_power_data *pdata) <nl> +static int twl4030_power_configure_scripts(struct twl4030_power_data *pdata) <nl>  { <nl>  	int err; <nl>  	int i; <nl> @@ -509,7 +509,7 @@ int twl4030_power_configure_scripts(struct twl4030_power_data *pdata) <nl>  	return 0; <nl>  } <nl>   <nl> -int twl4030_power_configure_resources(struct twl4030_power_data *pdata) <nl> +static int twl4030_power_configure_resources(struct twl4030_power_data *pdata) <nl>  { <nl>  	struct twl4030_resconfig *resconfig = pdata->resource_config; <nl>  	int err; <nl> @@ -553,7 +553,7 @@ static bool twl4030_power_use_poweroff(struct twl4030_power_data *pdata, <nl>  	return false; <nl>  } <nl>   <nl> -int twl4030_power_probe(struct platform_device *pdev) <nl> +static int twl4030_power_probe(struct platform_device *pdev) <nl>  { <nl>  	struct twl4030_power_data *pdata = dev_get_platdata(&pdev->dev); <nl>  	struct device_node *node = pdev->dev.of_node;
@@ -439,6 +439,7 @@ int videobuf_reqbufs(struct videobuf_queue *q, <nl>  	} <nl>   <nl>  	req->count = retval; <nl> +	retval = 0; <nl>   <nl>   done: <nl>  	mutex_unlock(&q->vb_lock);
@@ -1934,6 +1934,7 @@ static int musb_gadget_stop(struct usb_gadget *g, <nl>  	dev_dbg(musb->controller, "unregistering driver %s\n", driver->function); <nl>   <nl>  	musb->is_active = 0; <nl> +	musb->gadget_driver = NULL; <nl>  	musb_platform_try_idle(musb, 0); <nl>  	spin_unlock_irqrestore(&musb->lock, flags); <nl>  
@@ -98,7 +98,6 @@ static int ci_hdrc_imx_probe(struct platform_device *pdev) <nl>  	}; <nl>  	struct resource *res; <nl>  	int ret; <nl> -	struct usb_phy *phy; <nl>   <nl>  	if (of_find_property(pdev->dev.of_node, "fsl,usbmisc", NULL) <nl>  		&& !usbmisc_ops) <nl> @@ -130,14 +129,14 @@ static int ci_hdrc_imx_probe(struct platform_device *pdev) <nl>  		return ret; <nl>  	} <nl>   <nl> -	phy = devm_usb_get_phy_by_phandle(&pdev->dev, "fsl,usbphy", 0); <nl> -	if (!IS_ERR(phy)) { <nl> -		ret = usb_phy_init(phy); <nl> +	data->phy = devm_usb_get_phy_by_phandle(&pdev->dev, "fsl,usbphy", 0); <nl> +	if (!IS_ERR(data->phy)) { <nl> +		ret = usb_phy_init(data->phy); <nl>  		if (ret) { <nl>  			dev_err(&pdev->dev, "unable to init phy: %d\n", ret); <nl>  			goto err_clk; <nl>  		} <nl> -	} else if (PTR_ERR(phy) == -EPROBE_DEFER) { <nl> +	} else if (PTR_ERR(data->phy) == -EPROBE_DEFER) { <nl>  		ret = -EPROBE_DEFER; <nl>  		goto err_clk; <nl>  	}
@@ -419,8 +419,6 @@ static void sh_mmcif_request_dma(struct sh_mmcif_host *host, <nl>  	if (ret < 0) <nl>  		goto ecfgrx; <nl>   <nl> -	init_completion(&host->dma_complete); <nl> - <nl>  	return; <nl>   <nl>  ecfgrx: <nl> @@ -1061,6 +1059,12 @@ static bool sh_mmcif_end_cmd(struct sh_mmcif_host *host) <nl>  	if (!data) <nl>  		return false; <nl>   <nl> +	/* <nl> +	 * Completion can be signalled from DMA callback and error, so, have to <nl> +	 * reset here, before setting .dma_active <nl> +	 */ <nl> +	init_completion(&host->dma_complete); <nl> + <nl>  	if (data->flags & MMC_DATA_READ) { <nl>  		if (host->chan_rx) <nl>  			sh_mmcif_start_dma_rx(host);
@@ -516,6 +516,13 @@ static void do_fault(struct work_struct *work) <nl>  		goto out; <nl>  	} <nl>   <nl> +	if (!(vma->vm_flags & (VM_READ | VM_EXEC | VM_WRITE))) { <nl> +		/* handle_mm_fault would BUG_ON() */ <nl> +		up_read(&mm->mmap_sem); <nl> +		handle_fault_error(fault); <nl> +		goto out; <nl> +	} <nl> + <nl>  	ret = handle_mm_fault(mm, vma, address, write); <nl>  	if (ret & VM_FAULT_ERROR) { <nl>  		/* failed to service fault */
@@ -194,7 +194,7 @@ static struct hw_breakpoint { <nl>  	unsigned long		addr; <nl>  	int			len; <nl>  	int			type; <nl> -	struct perf_event	**pev; <nl> +	struct perf_event	* __percpu *pev; <nl>  } breakinfo[HBP_NUM]; <nl>   <nl>  static unsigned long early_dr7;
@@ -211,7 +211,10 @@ try_again_CIFSSMBUnixQPathInfo: <nl>  	if (rc) { <nl>  		if (rc == -EREMOTE && !is_dfs_referral) { <nl>  			is_dfs_referral = true; <nl> -			full_path = search_path; <nl> +			if (full_path != search_path) { <nl> +				kfree(full_path); <nl> +				full_path = search_path; <nl> +			} <nl>  			goto try_again_CIFSSMBUnixQPathInfo; <nl>  		} <nl>  		goto cgiiu_exit; <nl> @@ -422,7 +425,10 @@ try_again_CIFSSMBQPathInfo: <nl>  	if (rc) { <nl>  		if (rc == -EREMOTE && !is_dfs_referral) { <nl>  			is_dfs_referral = true; <nl> -			full_path = search_path; <nl> +			if (full_path != search_path) { <nl> +				kfree(full_path); <nl> +				full_path = search_path; <nl> +			} <nl>  			goto try_again_CIFSSMBQPathInfo; <nl>  		} <nl>  		goto cgii_exit;
@@ -645,7 +645,11 @@ static int s5p_aes_probe(struct platform_device *pdev) <nl>  		return -ENOENT; <nl>  	} <nl>   <nl> -	clk_enable(pdata->clk); <nl> +	err = clk_prepare_enable(pdata->clk); <nl> +	if (err < 0) { <nl> +		dev_err(dev, "Enabling SSS clk failed, err %d\n", err); <nl> +		return err; <nl> +	} <nl>   <nl>  	spin_lock_init(&pdata->lock); <nl>   <nl> @@ -706,7 +710,7 @@ static int s5p_aes_probe(struct platform_device *pdev) <nl>  	tasklet_kill(&pdata->tasklet); <nl>   <nl>   err_irq: <nl> -	clk_disable(pdata->clk); <nl> +	clk_disable_unprepare(pdata->clk); <nl>   <nl>  	s5p_dev = NULL; <nl>   <nl> @@ -726,7 +730,7 @@ static int s5p_aes_remove(struct platform_device *pdev) <nl>   <nl>  	tasklet_kill(&pdata->tasklet); <nl>   <nl> -	clk_disable(pdata->clk); <nl> +	clk_disable_unprepare(pdata->clk); <nl>   <nl>  	s5p_dev = NULL; <nl>  
@@ -881,20 +881,20 @@ void dgap_input(struct channel_t *ch) <nl>  		if (I_PARMRK(tp) || I_BRKINT(tp) || I_INPCK(tp)) { <nl>  			dgap_parity_scan(ch, ch->ch_bd->flipbuf, ch->ch_bd->flipflagbuf, &len); <nl>   <nl> -			len = tty_buffer_request_room(tp, len); <nl> -			tty_insert_flip_string_flags(tp, ch->ch_bd->flipbuf, <nl> +			len = tty_buffer_request_room(tp->port, len); <nl> +			tty_insert_flip_string_flags(tp->port, ch->ch_bd->flipbuf, <nl>  				ch->ch_bd->flipflagbuf, len); <nl>  		} <nl>  		else { <nl> -			len = tty_buffer_request_room(tp, len); <nl> -			tty_insert_flip_string(tp, ch->ch_bd->flipbuf, len); <nl> +			len = tty_buffer_request_room(tp->port, len); <nl> +			tty_insert_flip_string(tp->port, ch->ch_bd->flipbuf, len); <nl>  		} <nl>   <nl>  		DGAP_UNLOCK(ch->ch_lock, lock_flags2); <nl>  		DGAP_UNLOCK(bd->bd_lock, lock_flags); <nl>   <nl>  		/* Tell the tty layer its okay to "eat" the data now */ <nl> -		tty_flip_buffer_push(tp); <nl> +		tty_flip_buffer_push(tp->port); <nl>  	} <nl>   <nl>  	if (ld)
@@ -2978,8 +2978,11 @@ int sdhci_add_host(struct sdhci_host *host) <nl>  						      GFP_KERNEL); <nl>  		host->align_buffer = kmalloc(host->align_buffer_sz, GFP_KERNEL); <nl>  		if (!host->adma_table || !host->align_buffer) { <nl> -			dma_free_coherent(mmc_dev(mmc), host->adma_table_sz, <nl> -					  host->adma_table, host->adma_addr); <nl> +			if (host->adma_table) <nl> +				dma_free_coherent(mmc_dev(mmc), <nl> +						  host->adma_table_sz, <nl> +						  host->adma_table, <nl> +						  host->adma_addr); <nl>  			kfree(host->align_buffer); <nl>  			pr_warn("%s: Unable to allocate ADMA buffers - falling back to standard DMA\n", <nl>  				mmc_hostname(mmc));
@@ -846,7 +846,8 @@ static ctl_table vm_table[] = { <nl>  		.extra2		= &one_hundred, <nl>  	}, <nl>  #endif <nl> -#ifdef CONFIG_X86_32 <nl> +#if defined(CONFIG_X86_32) || \ <nl> +   (defined(CONFIG_SUPERH) && defined(CONFIG_VSYSCALL)) <nl>  	{ <nl>  		.ctl_name	= VM_VDSO_ENABLED, <nl>  		.procname	= "vdso_enabled",
@@ -678,6 +678,9 @@ static void css_set_move_task(struct task_struct *task, <nl>  { <nl>  	lockdep_assert_held(&css_set_lock); <nl>   <nl> +	if (to_cset && !css_set_populated(to_cset)) <nl> +		css_set_update_populated(to_cset, true); <nl> + <nl>  	if (from_cset) { <nl>  		struct css_task_iter *it, *pos; <nl>   <nl> @@ -711,8 +714,6 @@ static void css_set_move_task(struct task_struct *task, <nl>  		 */ <nl>  		WARN_ON_ONCE(task->flags & PF_EXITING); <nl>   <nl> -		if (!css_set_populated(to_cset)) <nl> -			css_set_update_populated(to_cset, true); <nl>  		rcu_assign_pointer(task->cgroups, to_cset); <nl>  		list_add_tail(&task->cg_list, use_mg_tasks ? &to_cset->mg_tasks : <nl>  							     &to_cset->tasks);
@@ -59,6 +59,13 @@ static inline void of_pci_check_probe_only(void) { } <nl>  int of_pci_get_host_bridge_resources(struct device_node *dev, <nl>  			unsigned char busno, unsigned char bus_max, <nl>  			struct list_head *resources, resource_size_t *io_base); <nl> +#else <nl> +static inline int of_pci_get_host_bridge_resources(struct device_node *dev, <nl> +			unsigned char busno, unsigned char bus_max, <nl> +			struct list_head *resources, resource_size_t *io_base) <nl> +{ <nl> +	return -EINVAL; <nl> +} <nl>  #endif <nl>   <nl>  #if defined(CONFIG_OF) && defined(CONFIG_PCI_MSI)
@@ -490,7 +490,7 @@ void bfin_serial_rx_dma_timeout(struct bfin_serial_port *uart) <nl>  	uart->rx_dma_nrows = get_dma_curr_ycount(uart->rx_dma_channel); <nl>  	x_pos = get_dma_curr_xcount(uart->rx_dma_channel); <nl>  	uart->rx_dma_nrows = DMA_RX_YCOUNT - uart->rx_dma_nrows; <nl> -	if (uart->rx_dma_nrows == DMA_RX_YCOUNT) <nl> +	if (uart->rx_dma_nrows == DMA_RX_YCOUNT || x_pos == 0) <nl>  		uart->rx_dma_nrows = 0; <nl>  	x_pos = DMA_RX_XCOUNT - x_pos; <nl>  	if (x_pos == DMA_RX_XCOUNT) <nl> @@ -546,15 +546,16 @@ static irqreturn_t bfin_serial_dma_rx_int(int irq, void *dev_id) <nl>  { <nl>  	struct bfin_serial_port *uart = dev_id; <nl>  	unsigned short irqstat; <nl> -	int pos; <nl> +	int x_pos, pos; <nl>   <nl>  	spin_lock(&uart->port.lock); <nl>  	irqstat = get_dma_curr_irqstat(uart->rx_dma_channel); <nl>  	clear_dma_irqstat(uart->rx_dma_channel); <nl>   <nl>  	uart->rx_dma_nrows = get_dma_curr_ycount(uart->rx_dma_channel); <nl> +	x_pos = get_dma_curr_xcount(uart->rx_dma_channel); <nl>  	uart->rx_dma_nrows = DMA_RX_YCOUNT - uart->rx_dma_nrows; <nl> -	if (uart->rx_dma_nrows == DMA_RX_YCOUNT) <nl> +	if (uart->rx_dma_nrows == DMA_RX_YCOUNT || x_pos == 0) <nl>  		uart->rx_dma_nrows = 0; <nl>   <nl>  	pos = uart->rx_dma_nrows * DMA_RX_XCOUNT;
@@ -37,6 +37,7 @@ <nl>  #define OP_31_XOP_SLBIA		498 <nl>  #define OP_31_XOP_MFSR		595 <nl>  #define OP_31_XOP_MFSRIN	659 <nl> +#define OP_31_XOP_DCBA		758 <nl>  #define OP_31_XOP_SLBMFEV	851 <nl>  #define OP_31_XOP_EIOIO		854 <nl>  #define OP_31_XOP_SLBMFEE	915 <nl> @@ -183,6 +184,9 @@ int kvmppc_core_emulate_op(struct kvm_run *run, struct kvm_vcpu *vcpu, <nl>  				kvmppc_set_gpr(vcpu, get_rt(inst), t); <nl>  			} <nl>  			break; <nl> +		case OP_31_XOP_DCBA: <nl> +			/* Gets treated as NOP */ <nl> +			break; <nl>  		case OP_31_XOP_DCBZ: <nl>  		{ <nl>  			ulong rb = kvmppc_get_gpr(vcpu, get_rb(inst));
@@ -2039,11 +2039,13 @@ static void sxgbe_get_ops(struct sxgbe_ops * const ops_ptr) <nl>   *  Description: this function checks the HW capability <nl>   *  (if supported) and sets the driver's features. <nl>   */ <nl> -static void sxgbe_hw_init(struct sxgbe_priv_data * const priv) <nl> +static int sxgbe_hw_init(struct sxgbe_priv_data * const priv) <nl>  { <nl>  	u32 ctrl_ids; <nl>   <nl>  	priv->hw = kmalloc(sizeof(*priv->hw), GFP_KERNEL); <nl> +	if(!priv->hw) <nl> +		return -ENOMEM; <nl>   <nl>  	/* get the hardware ops */ <nl>  	sxgbe_get_ops(priv->hw); <nl> @@ -2064,6 +2066,8 @@ static void sxgbe_hw_init(struct sxgbe_priv_data * const priv) <nl>   <nl>  	if (priv->hw_cap.rx_csum_offload) <nl>  		pr_info("RX Checksum offload supported\n"); <nl> + <nl> +	return 0; <nl>  } <nl>   <nl>  /** <nl> @@ -2102,7 +2106,9 @@ struct sxgbe_priv_data *sxgbe_drv_probe(struct device *device, <nl>  	sxgbe_verify_args(); <nl>   <nl>  	/* Init MAC and get the capabilities */ <nl> -	sxgbe_hw_init(priv); <nl> +	ret = sxgbe_hw_init(priv); <nl> +	if (ret) <nl> +		goto error_free_netdev; <nl>   <nl>  	/* allocate memory resources for Descriptor rings */ <nl>  	ret = txring_mem_alloc(priv);
@@ -1018,8 +1018,8 @@ done: <nl>  		atomic_dec (&urb->use_count); <nl>  		if (urb->reject) <nl>  			wake_up (&usb_kill_urb_queue); <nl> -		usb_put_urb (urb); <nl>  		usbmon_urb_submit_error(&hcd->self, urb, status); <nl> +		usb_put_urb (urb); <nl>  	} <nl>  	return status; <nl>  }
@@ -2148,10 +2148,6 @@ struct vm_struct *alloc_vm_area(size_t size) <nl>  		return NULL; <nl>  	} <nl>   <nl> -	/* Make sure the pagetables are constructed in process kernel <nl> -	   mappings */ <nl> -	vmalloc_sync_all(); <nl> - <nl>  	return area; <nl>  } <nl>  EXPORT_SYMBOL_GPL(alloc_vm_area);
@@ -1160,6 +1160,7 @@ static void wiimote_destroy(struct wiimote_data *wdata) <nl>  	wiimote_leds_destroy(wdata); <nl>   <nl>  	power_supply_unregister(&wdata->battery); <nl> +	kfree(wdata->battery.name); <nl>  	input_unregister_device(wdata->accel); <nl>  	input_unregister_device(wdata->ir); <nl>  	input_unregister_device(wdata->input); <nl> @@ -1216,9 +1217,14 @@ static int wiimote_hid_probe(struct hid_device *hdev, <nl>  	wdata->battery.properties = wiimote_battery_props; <nl>  	wdata->battery.num_properties = ARRAY_SIZE(wiimote_battery_props); <nl>  	wdata->battery.get_property = wiimote_battery_get_property; <nl> -	wdata->battery.name = "wiimote_battery"; <nl>  	wdata->battery.type = POWER_SUPPLY_TYPE_BATTERY; <nl>  	wdata->battery.use_for_apm = 0; <nl> +	wdata->battery.name = kasprintf(GFP_KERNEL, "wiimote_battery_%s", <nl> +					wdata->hdev->uniq); <nl> +	if (!wdata->battery.name) { <nl> +		ret = -ENOMEM; <nl> +		goto err_battery_name; <nl> +	} <nl>   <nl>  	ret = power_supply_register(&wdata->hdev->dev, &wdata->battery); <nl>  	if (ret) { <nl> @@ -1254,6 +1260,8 @@ err_free: <nl>  	return ret; <nl>   <nl>  err_battery: <nl> +	kfree(wdata->battery.name); <nl> +err_battery_name: <nl>  	input_unregister_device(wdata->input); <nl>  	wdata->input = NULL; <nl>  err_input:
@@ -1094,7 +1094,7 @@ static bool ixgbe_clean_tx_irq(struct ixgbe_q_vector *q_vector, <nl>  		total_packets += tx_buffer->gso_segs; <nl>   <nl>  		/* free the skb */ <nl> -		dev_kfree_skb_any(tx_buffer->skb); <nl> +		dev_consume_skb_any(tx_buffer->skb); <nl>   <nl>  		/* unmap skb header data */ <nl>  		dma_unmap_single(tx_ring->dev,
@@ -381,7 +381,7 @@ static void mousevsc_on_channel_callback(void *context) <nl>  static int mousevsc_connect_to_vsp(struct hv_device *device) <nl>  { <nl>  	int ret = 0; <nl> -	int t; <nl> +	unsigned long t; <nl>  	struct mousevsc_dev *input_dev = hv_get_drvdata(device); <nl>  	struct mousevsc_prt_msg *request; <nl>  	struct mousevsc_prt_msg *response;
@@ -1129,6 +1129,9 @@ static int do_ip_getsockopt(struct sock *sk, int level, int optname, <nl>  	case IP_HDRINCL: <nl>  		val = inet->hdrincl; <nl>  		break; <nl> +	case IP_NODEFRAG: <nl> +		val = inet->nodefrag; <nl> +		break; <nl>  	case IP_MTU_DISCOVER: <nl>  		val = inet->pmtudisc; <nl>  		break;
@@ -6048,7 +6048,7 @@ static void saa7134_tuner_setup(struct saa7134_dev *dev) <nl>  		struct v4l2_priv_tun_config  xc2028_cfg; <nl>  		struct xc2028_ctrl           ctl; <nl>   <nl> -		memset(&xc2028_cfg, 0, sizeof(ctl)); <nl> +		memset(&xc2028_cfg, 0, sizeof(xc2028_cfg)); <nl>  		memset(&ctl, 0, sizeof(ctl)); <nl>   <nl>  		ctl.fname   = XC2028_DEFAULT_FIRMWARE;
@@ -31,6 +31,7 @@ <nl>  #include <linux/module.h>	/* Modules 			*/ <nl>  #include <linux/init.h>		/* Initdata			*/ <nl>  #include <linux/ioport.h>	/* request_region		*/ <nl> +#include <linux/delay.h>	/* msleep			*/ <nl>  #include <linux/videodev2.h>	/* kernel radio structs		*/ <nl>  #include <linux/version.h>	/* for KERNEL_VERSION MACRO	*/ <nl>  #include <linux/io.h>		/* outb, outb_p			*/
@@ -741,14 +741,15 @@ static void usa49wg_indat_callback(struct urb *urb) <nl>  		if ((data[i] & 0x80) == 0) { <nl>  			/* no error on any byte */ <nl>  			i++; <nl> -			for (x = 1; x < len ; ++x) <nl> +			for (x = 1; x < len && i < urb->actual_length; ++x) <nl>  				tty_insert_flip_char(&port->port, <nl>  						data[i++], 0); <nl>  		} else { <nl>  			/* <nl>  			 * some bytes had errors, every byte has status <nl>  			 */ <nl> -			for (x = 0; x + 1 < len; x += 2) { <nl> +			for (x = 0; x + 1 < len && <nl> +				    i + 1 < urb->actual_length; x += 2) { <nl>  				int stat = data[i], flag = 0; <nl>   <nl>  				if (stat & RXERROR_OVERRUN)
@@ -467,6 +467,9 @@ static int pit_ioport_read(struct kvm_io_device *this, <nl>  		return -EOPNOTSUPP; <nl>   <nl>  	addr &= KVM_PIT_CHANNEL_MASK; <nl> +	if (addr == 3) <nl> +		return 0; <nl> + <nl>  	s = &pit_state->channels[addr]; <nl>   <nl>  	mutex_lock(&pit_state->lock);
@@ -308,9 +308,9 @@ static enum BC_STATUS bc_cproc_download_fw(struct crystalhd_cmd *ctx, <nl>  	sts = crystalhd_download_fw(ctx->adp, (uint8_t *)idata->add_cdata, <nl>  				  idata->add_cdata_sz); <nl>   <nl> -	if (sts != BC_STS_SUCCESS) { <nl> +	if (sts != BC_STS_SUCCESS) <nl>  		BCMLOG_ERR("Firmware Download Failure!! - %d\n", sts); <nl> -	} else <nl> +	else <nl>  		ctx->state |= BC_LINK_INIT; <nl>   <nl>  	return sts;
@@ -1268,6 +1268,7 @@ static int ufs_statfs(struct dentry *dentry, struct kstatfs *buf) <nl>  	struct ufs_super_block_first *usb1; <nl>  	struct ufs_super_block_second *usb2; <nl>  	struct ufs_super_block_third *usb3; <nl> +	u64 id = huge_encode_dev(sb->s_bdev->bd_dev); <nl>   <nl>  	lock_kernel(); <nl>   <nl> @@ -1290,6 +1291,8 @@ static int ufs_statfs(struct dentry *dentry, struct kstatfs *buf) <nl>  		? (buf->f_bfree - (((long)buf->f_blocks / 100) * uspi->s_minfree)) : 0; <nl>  	buf->f_files = uspi->s_ncg * uspi->s_ipg; <nl>  	buf->f_namelen = UFS_MAXNAMLEN; <nl> +	buf->f_fsid.val[0] = (u32)id; <nl> +	buf->f_fsid.val[1] = (u32)(id >> 32); <nl>   <nl>  	unlock_kernel(); <nl>  
@@ -626,7 +626,7 @@ static int __devinit tc35815_read_plat_dev_addr(struct net_device *dev) <nl>  	return -ENODEV; <nl>  } <nl>  #else <nl> -static int __devinit tc35815_read_plat_dev_addr(struct device *dev) <nl> +static int __devinit tc35815_read_plat_dev_addr(struct net_device *dev) <nl>  { <nl>  	return -ENODEV; <nl>  }
@@ -71,6 +71,9 @@ struct microcode_amd { <nl>   <nl>  static struct equiv_cpu_entry *equiv_cpu_table; <nl>   <nl> +/* page-sized ucode patch buffer */ <nl> +void *patch; <nl> + <nl>  static int collect_cpu_info_amd(int cpu, struct cpu_signature *csig) <nl>  { <nl>  	struct cpuinfo_x86 *c = &cpu_data(cpu); <nl> @@ -351,9 +354,14 @@ static struct microcode_ops microcode_amd_ops = { <nl>   <nl>  struct microcode_ops * __init init_amd_microcode(void) <nl>  { <nl> +	patch = (void *)get_zeroed_page(GFP_KERNEL); <nl> +	if (!patch) <nl> +		return NULL; <nl> + <nl>  	return &microcode_amd_ops; <nl>  } <nl>   <nl>  void __exit exit_amd_microcode(void) <nl>  { <nl> +	free_page((unsigned long)patch); <nl>  }
@@ -84,9 +84,11 @@ static int br_mdb_fill_info(struct sk_buff *skb, struct netlink_callback *cb, <nl>  					struct br_mdb_entry e; <nl>  					e.ifindex = port->dev->ifindex; <nl>  					e.state = p->state; <nl> -					e.addr.u.ip4 = p->addr.u.ip4; <nl> +					if (p->addr.proto == htons(ETH_P_IP)) <nl> +						e.addr.u.ip4 = p->addr.u.ip4; <nl>  #if IS_ENABLED(CONFIG_IPV6) <nl> -					e.addr.u.ip6 = p->addr.u.ip6; <nl> +					if (p->addr.proto == htons(ETH_P_IPV6)) <nl> +						e.addr.u.ip6 = p->addr.u.ip6; <nl>  #endif <nl>  					e.addr.proto = p->addr.proto; <nl>  					if (nla_put(skb, MDBA_MDB_ENTRY_INFO, sizeof(e), &e)) {
@@ -6890,14 +6890,14 @@ static int ironlake_crtc_mode_set(struct drm_crtc *crtc, <nl>  	} else <nl>  		intel_put_shared_dpll(intel_crtc); <nl>   <nl> -	if (intel_crtc->config.has_dp_encoder) <nl> -		intel_dp_set_m_n(intel_crtc); <nl> - <nl>  	if (is_lvds && has_reduced_clock && i915.powersave) <nl>  		intel_crtc->lowfreq_avail = true; <nl>  	else <nl>  		intel_crtc->lowfreq_avail = false; <nl>   <nl> +	if (intel_crtc->config.has_dp_encoder) <nl> +		intel_dp_set_m_n(intel_crtc); <nl> + <nl>  	intel_set_pipe_timings(intel_crtc); <nl>   <nl>  	if (intel_crtc->config.has_pch_encoder) { <nl> @@ -7388,11 +7388,11 @@ static int haswell_crtc_mode_set(struct drm_crtc *crtc, <nl>  		return -EINVAL; <nl>  	intel_ddi_pll_enable(intel_crtc); <nl>   <nl> +	intel_crtc->lowfreq_avail = false; <nl> + <nl>  	if (intel_crtc->config.has_dp_encoder) <nl>  		intel_dp_set_m_n(intel_crtc); <nl>   <nl> -	intel_crtc->lowfreq_avail = false; <nl> - <nl>  	intel_set_pipe_timings(intel_crtc); <nl>   <nl>  	if (intel_crtc->config.has_pch_encoder) {
@@ -273,6 +273,7 @@ static void parse_system_parameter_string(struct seq_file *m) <nl>  		if (!workbuffer) { <nl>  			printk(KERN_ERR "%s %s kmalloc failure at line %d \n", <nl>  			       __FILE__, __FUNCTION__, __LINE__); <nl> +			kfree(local_buffer);			 <nl>  			return; <nl>  		} <nl>  #ifdef LPARCFG_DEBUG
@@ -55,7 +55,7 @@ static ssize_t eisa_eeprom_read(struct file * file, <nl>  	ssize_t ret; <nl>  	int i; <nl>  	 <nl> -	if (*ppos >= HPEE_MAX_LENGTH) <nl> +	if (*ppos < 0 || *ppos >= HPEE_MAX_LENGTH) <nl>  		return 0; <nl>  	 <nl>  	count = *ppos + count < HPEE_MAX_LENGTH ? count : HPEE_MAX_LENGTH - *ppos;
@@ -283,6 +283,7 @@ hfcsusb_ph_info(struct hfcsusb *hw) <nl>  	_queue_data(&dch->dev.D, MPH_INFORMATION_IND, MISDN_ID_ANY, <nl>  		sizeof(struct ph_info_dch) + dch->dev.nrbchan * <nl>  		sizeof(struct ph_info_ch), phi, GFP_ATOMIC); <nl> +	kfree(phi); <nl>  } <nl>   <nl>  /*
@@ -159,6 +159,13 @@ int _process_sigma_firmware(struct device *dev, <nl>  		goto done; <nl>  	} <nl>   <nl> +	if (ssfw_head->version != 1) { <nl> +		dev_err(dev, <nl> +			"Failed to load firmware: Invalid version %d. Supported firmware versions: 1\n", <nl> +			ssfw_head->version); <nl> +		goto done; <nl> +	} <nl> + <nl>  	crc = crc32(0, fw->data + sizeof(*ssfw_head), <nl>  			fw->size - sizeof(*ssfw_head)); <nl>  	pr_debug("%s: crc=%x\n", __func__, crc);
@@ -633,14 +633,14 @@ int intel_logical_ring_alloc_request_extras(struct drm_i915_gem_request *request <nl>  { <nl>  	int ret; <nl>   <nl> +	request->ringbuf = request->ctx->engine[request->ring->id].ringbuf; <nl> + <nl>  	if (request->ctx != request->ring->default_context) { <nl>  		ret = intel_lr_context_pin(request->ring, request->ctx); <nl>  		if (ret) <nl>  			return ret; <nl>  	} <nl>   <nl> -	request->ringbuf = request->ctx->engine[request->ring->id].ringbuf; <nl> - <nl>  	return 0; <nl>  } <nl>  
@@ -310,8 +310,16 @@ int btrfs_find_orphan_roots(struct btrfs_root *tree_root) <nl>  		set_bit(BTRFS_ROOT_ORPHAN_ITEM_INSERTED, &root->state); <nl>   <nl>  		err = btrfs_insert_fs_root(root->fs_info, root); <nl> +		/* <nl> +		 * The root might have been inserted already, as before we look <nl> +		 * for orphan roots, log replay might have happened, which <nl> +		 * triggers a transaction commit and qgroup accounting, which <nl> +		 * in turn reads and inserts fs roots while doing backref <nl> +		 * walking. <nl> +		 */ <nl> +		if (err == -EEXIST) <nl> +			err = 0; <nl>  		if (err) { <nl> -			BUG_ON(err == -EEXIST); <nl>  			btrfs_free_fs_root(root); <nl>  			break; <nl>  		}
@@ -3499,8 +3499,8 @@ xfs_log_force_umount( <nl>  	 * before we mark the filesystem SHUTDOWN and wake <nl>  	 * everybody up to tell the bad news. <nl>  	 */ <nl> -	spin_lock(&log->l_grant_lock); <nl>  	spin_lock(&log->l_icloglock); <nl> +	spin_lock(&log->l_grant_lock); <nl>  	mp->m_flags |= XFS_MOUNT_FS_SHUTDOWN; <nl>  	XFS_BUF_DONE(mp->m_sb_bp); <nl>  	/*
@@ -52,6 +52,7 @@ MODULE_LICENSE("GPL"); <nl>  #define MT_QUIRK_VALID_IS_CONFIDENCE	(1 << 6) <nl>  #define MT_QUIRK_SLOT_IS_CONTACTID_MINUS_ONE	(1 << 8) <nl>  #define MT_QUIRK_NO_AREA		(1 << 9) <nl> +#define MT_QUIRK_IGNORE_DUPLICATES	(1 << 10) <nl>   <nl>  struct mt_slot { <nl>  	__s32 x, y, cx, cy, p, w, h; <nl> @@ -505,10 +506,18 @@ static void mt_complete_slot(struct mt_device *td, struct input_dev *input) <nl>  	if (td->curvalid || (td->mtclass.quirks & MT_QUIRK_ALWAYS_VALID)) { <nl>  		int slotnum = mt_compute_slot(td, input); <nl>  		struct mt_slot *s = &td->curdata; <nl> +		struct input_mt *mt = input->mt; <nl>   <nl>  		if (slotnum < 0 || slotnum >= td->maxcontacts) <nl>  			return; <nl>   <nl> +		if ((td->mtclass.quirks & MT_QUIRK_IGNORE_DUPLICATES) && mt) { <nl> +			struct input_mt_slot *slot = &mt->slots[slotnum]; <nl> +			if (input_mt_is_active(slot) && <nl> +			    input_mt_is_used(mt, slot)) <nl> +				return; <nl> +		} <nl> + <nl>  		input_mt_slot(input, slotnum); <nl>  		input_mt_report_slot_state(input, MT_TOOL_FINGER, <nl>  			s->touch_state);
@@ -2792,7 +2792,7 @@ static int rtl8169_rx_interrupt(struct net_device *dev, <nl>  					pkt_size, PCI_DMA_FROMDEVICE); <nl>  				rtl8169_mark_to_asic(desc, tp->rx_buf_sz); <nl>  			} else { <nl> -				pci_unmap_single(pdev, addr, pkt_size, <nl> +				pci_unmap_single(pdev, addr, tp->rx_buf_sz, <nl>  						 PCI_DMA_FROMDEVICE); <nl>  				tp->Rx_skbuff[entry] = NULL; <nl>  			}
@@ -135,6 +135,7 @@ static void unmap_switcher(void) <nl>  	/* Now we just need to free the pages we copied the switcher into */ <nl>  	for (i = 0; i < TOTAL_SWITCHER_PAGES; i++) <nl>  		__free_pages(switcher_page[i], 0); <nl> +	kfree(switcher_page); <nl>  } <nl>   <nl>  /*H:032
@@ -732,6 +732,7 @@ static int reiserfs_mkdir(struct inode *dir, struct dentry *dentry, int mode) <nl>  	struct inode *inode; <nl>  	struct reiserfs_transaction_handle th; <nl>  	struct reiserfs_security_handle security; <nl> +	int lock_depth; <nl>  	/* We need blocks for transaction + (user+group)*(quotas for new inode + update of quota for directory owner) */ <nl>  	int jbegin_count = <nl>  	    JOURNAL_PER_BALANCE_CNT * 3 + <nl> @@ -755,7 +756,7 @@ static int reiserfs_mkdir(struct inode *dir, struct dentry *dentry, int mode) <nl>  		return retval; <nl>  	} <nl>  	jbegin_count += retval; <nl> -	reiserfs_write_lock(dir->i_sb); <nl> +	lock_depth = reiserfs_write_lock_once(dir->i_sb); <nl>   <nl>  	retval = journal_begin(&th, dir->i_sb, jbegin_count); <nl>  	if (retval) { <nl> @@ -805,8 +806,8 @@ static int reiserfs_mkdir(struct inode *dir, struct dentry *dentry, int mode) <nl>  	d_instantiate(dentry, inode); <nl>  	unlock_new_inode(inode); <nl>  	retval = journal_end(&th, dir->i_sb, jbegin_count); <nl> -      out_failed: <nl> -	reiserfs_write_unlock(dir->i_sb); <nl> +out_failed: <nl> +	reiserfs_write_unlock_once(dir->i_sb, lock_depth); <nl>  	return retval; <nl>  } <nl>  
@@ -591,6 +591,9 @@ static unsigned int br_nf_pre_routing(unsigned int hook, struct sk_buff *skb, <nl>   <nl>  	pskb_trim_rcsum(skb, len); <nl>   <nl> +	/* BUG: Should really parse the IP options here. */ <nl> +	memset(IPCB(skb), 0, sizeof(struct inet_skb_parm)); <nl> + <nl>  	nf_bridge_put(skb->nf_bridge); <nl>  	if (!nf_bridge_alloc(skb)) <nl>  		return NF_DROP;
@@ -345,7 +345,9 @@ static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream, <nl>  		new_hw_ptr = hw_base + pos; <nl>  	} <nl>        __delta: <nl> -	delta = (new_hw_ptr - old_hw_ptr) % runtime->boundary; <nl> +	delta = new_hw_ptr - old_hw_ptr; <nl> +	if (delta < 0) <nl> +		delta += runtime->boundary; <nl>  	if (xrun_debug(substream, in_interrupt ? <nl>  			XRUN_DEBUG_PERIODUPDATE : XRUN_DEBUG_HWPTRUPDATE)) { <nl>  		char name[16];
@@ -594,6 +594,11 @@ int setup_arg_pages(struct linux_binprm *bprm, <nl>  #else <nl>  	stack_top = arch_align_stack(stack_top); <nl>  	stack_top = PAGE_ALIGN(stack_top); <nl> + <nl> +	if (unlikely(stack_top < mmap_min_addr) || <nl> +	    unlikely(vma->vm_end - vma->vm_start >= stack_top - mmap_min_addr)) <nl> +		return -ENOMEM; <nl> + <nl>  	stack_shift = vma->vm_end - stack_top; <nl>   <nl>  	bprm->p -= stack_shift;
@@ -208,6 +208,8 @@ static inline struct proc_dir_entry *proc_symlink(const char *name, <nl>  		struct proc_dir_entry *parent,const char *dest) {return NULL;} <nl>  static inline struct proc_dir_entry *proc_mkdir(const char *name, <nl>  	struct proc_dir_entry *parent) {return NULL;} <nl> +static inline struct proc_dir_entry *proc_mkdir_mode(const char *name, <nl> +	mode_t mode, struct proc_dir_entry *parent) { return NULL; } <nl>   <nl>  static inline struct proc_dir_entry *create_proc_read_entry(const char *name, <nl>  	mode_t mode, struct proc_dir_entry *base, 
@@ -55,7 +55,8 @@ static void netlink_rcv_cb(struct sk_buff *skb) <nl>  	if (skb->len >= NLMSG_HDRLEN) { <nl>  		nlh = (struct nlmsghdr *)skb->data; <nl>   <nl> -		if (skb->len < nlh->nlmsg_len || <nl> +		if (nlh->nlmsg_len < ND_IFINDEX_LEN || <nl> +		    nlh->nlmsg_len > skb->len || <nl>  		    nlh->nlmsg_len > ND_MAX_MSG_LEN) { <nl>  			netdev_err(skb->dev, "Invalid length (%d,%d)\n", <nl>  				   skb->len, nlh->nlmsg_len);
@@ -877,7 +877,8 @@ int ieee80211_request_sched_scan_start(struct ieee80211_sub_if_data *sdata, <nl>  	for (i = 0; i < IEEE80211_NUM_BANDS; i++) { <nl>  		local->sched_scan_ies.ie[i] = kzalloc(2 + <nl>  						      IEEE80211_MAX_SSID_LEN + <nl> -						      local->scan_ies_len, <nl> +						      local->scan_ies_len + <nl> +						      req->ie_len, <nl>  						      GFP_KERNEL); <nl>  		if (!local->sched_scan_ies.ie[i]) { <nl>  			ret = -ENOMEM;
@@ -1094,6 +1094,10 @@ void omap_gem_init(struct drm_device *dev) <nl>  	} <nl>   <nl>  	usergart = kzalloc(3 * sizeof(*usergart), GFP_KERNEL); <nl> +	if (!usergart) { <nl> +		dev_warn(dev->dev, "could not allocate usergart\n"); <nl> +		return; <nl> +	} <nl>   <nl>  	/* reserve 4k aligned/wide regions for userspace mappings: */ <nl>  	for (i = 0; i < ARRAY_SIZE(fmts); i++) {
@@ -650,6 +650,7 @@ static int aac_send_raw_srb(struct aac_dev* dev, void __user * arg) <nl>  				     AAC_OPT_NEW_COMM) ? <nl>  				      (dev->scsi_host_ptr->max_sectors << 9) : <nl>  				      65536)) { <nl> +					kfree(usg); <nl>  					rcode = -EINVAL; <nl>  					goto cleanup; <nl>  				}
@@ -1702,7 +1702,7 @@ static struct net_device_stats *qlcnic_get_stats(struct net_device *netdev) <nl>   <nl>  	stats->rx_packets = adapter->stats.rx_pkts + adapter->stats.lro_pkts; <nl>  	stats->tx_packets = adapter->stats.xmitfinished; <nl> -	stats->rx_bytes = adapter->stats.rxbytes; <nl> +	stats->rx_bytes = adapter->stats.rxbytes + adapter->stats.lrobytes; <nl>  	stats->tx_bytes = adapter->stats.txbytes; <nl>  	stats->rx_dropped = adapter->stats.rxdropped; <nl>  	stats->tx_dropped = adapter->stats.txdropped;
@@ -49,6 +49,8 @@ nfnl_acct_new(struct sock *nfnl, struct sk_buff *skb, <nl>  		return -EINVAL; <nl>   <nl>  	acct_name = nla_data(tb[NFACCT_NAME]); <nl> +	if (strlen(acct_name) == 0) <nl> +		return -EINVAL; <nl>   <nl>  	list_for_each_entry(nfacct, &nfnl_acct_list, head) { <nl>  		if (strncmp(nfacct->name, acct_name, NFACCT_NAME_MAX) != 0)
@@ -1017,7 +1017,7 @@ static int snd_rme32_capture_close(struct snd_pcm_substream *substream) <nl>  	spin_lock_irq(&rme32->lock); <nl>  	rme32->capture_substream = NULL; <nl>  	rme32->capture_periodsize = 0; <nl> -	spin_unlock(&rme32->lock); <nl> +	spin_unlock_irq(&rme32->lock); <nl>  	return 0; <nl>  } <nl>  
@@ -3788,6 +3788,9 @@ static int xhci_setup_device(struct usb_hcd *hcd, struct usb_device *udev, <nl>   <nl>  	mutex_lock(&xhci->mutex); <nl>   <nl> +	if (xhci->xhc_state)	/* dying or halted */ <nl> +		goto out; <nl> + <nl>  	if (!udev->slot_id) { <nl>  		xhci_dbg_trace(xhci, trace_xhci_dbg_address, <nl>  				"Bad Slot ID %d", udev->slot_id);
@@ -541,9 +541,15 @@ static int ov772x_mask_set(struct i2c_client *client, u8  command, u8  mask, <nl>   <nl>  static int ov772x_reset(struct i2c_client *client) <nl>  { <nl> -	int ret = ov772x_write(client, COM7, SCCB_RESET); <nl> +	int ret; <nl> + <nl> +	ret = ov772x_write(client, COM7, SCCB_RESET); <nl> +	if (ret < 0) <nl> +		return ret; <nl> + <nl>  	msleep(1); <nl> -	return ret; <nl> + <nl> +	return ov772x_mask_set(client, COM2, SOFT_SLEEP_MODE, SOFT_SLEEP_MODE); <nl>  } <nl>   <nl>  /*
@@ -27,6 +27,7 @@ <nl>  #include <linux/types.h> <nl>  #include <linux/kernel.h> <nl>  #include <linux/spinlock.h> <nl> +#include <linux/smp.h> <nl>  #include <asm/bootinfo.h> <nl>  #include <asm/fw/cfe/cfe_api.h> <nl>  #include <asm/fw/cfe/cfe_error.h> <nl> @@ -127,6 +128,7 @@ static __init void prom_init_mem(void) <nl>  { <nl>  	unsigned long mem; <nl>  	unsigned long max; <nl> +	struct cpuinfo_mips *c = &current_cpu_data; <nl>   <nl>  	/* Figure out memory size by finding aliases. <nl>  	 * <nl> @@ -155,6 +157,14 @@ static __init void prom_init_mem(void) <nl>  			break; <nl>  	} <nl>   <nl> +	/* Ignoring the last page when ddr size is 128M. Cached <nl> +	 * accesses to last page is causing the processor to prefetch <nl> +	 * using address above 128M stepping out of the ddr address <nl> +	 * space. <nl> +	 */ <nl> +	if (c->cputype == CPU_74K && (mem == (128  << 20))) <nl> +		mem -= 0x1000; <nl> + <nl>  	add_memory_region(0, mem, BOOT_MEM_RAM); <nl>  } <nl>  
@@ -550,10 +550,13 @@ static int pl2303_tiocmset(struct tty_struct *tty, <nl>  	spin_unlock_irqrestore(&priv->lock, flags); <nl>   <nl>  	mutex_lock(&serial->disc_mutex); <nl> -	if (!serial->disconnected) <nl> +	if (!serial->disconnected) { <nl>  		ret = pl2303_set_control_lines(port, control); <nl> -	else <nl> +		if (ret) <nl> +			ret = usb_translate_errors(ret); <nl> +	} else { <nl>  		ret = -ENODEV; <nl> +	} <nl>  	mutex_unlock(&serial->disc_mutex); <nl>   <nl>  	return ret;
@@ -2440,7 +2440,8 @@ slave_start: <nl>  	 * No return code for this call, just warn the user in case of PCI <nl>  	 * express device capabilities are under-satisfied by the bus. <nl>  	 */ <nl> -	mlx4_check_pcie_caps(dev); <nl> +	if (!mlx4_is_slave(dev)) <nl> +		mlx4_check_pcie_caps(dev); <nl>   <nl>  	/* In master functions, the communication channel must be initialized <nl>  	 * after obtaining its address from fw */
@@ -2315,7 +2315,8 @@ static int perf_mmap(struct file *file, struct vm_area_struct *vma) <nl>  	lock_limit >>= PAGE_SHIFT; <nl>  	locked = vma->vm_mm->locked_vm + extra; <nl>   <nl> -	if ((locked > lock_limit) && !capable(CAP_IPC_LOCK)) { <nl> +	if ((locked > lock_limit) && perf_paranoid_tracepoint_raw() && <nl> +		!capable(CAP_IPC_LOCK)) { <nl>  		ret = -EPERM; <nl>  		goto unlock; <nl>  	}
@@ -614,6 +614,12 @@ int lapic_watchdog_init(unsigned nmi_hz) <nl>  		probe_nmi_watchdog(); <nl>  		if (!wd_ops) <nl>  			return -1; <nl> + <nl> +		if (!wd_ops->reserve()) { <nl> +			printk(KERN_ERR <nl> +				"NMI watchdog: cannot reserve perfctrs\n"); <nl> +			return -1; <nl> +		} <nl>  	} <nl>   <nl>  	if (!(wd_ops->setup(nmi_hz))) {
@@ -1354,7 +1354,7 @@ static int fuse_retrieve(struct fuse_conn *fc, struct inode *inode, <nl>  	loff_t file_size; <nl>  	unsigned int num; <nl>  	unsigned int offset; <nl> -	size_t total_len; <nl> +	size_t total_len = 0; <nl>   <nl>  	req = fuse_get_req(fc); <nl>  	if (IS_ERR(req))
@@ -42,6 +42,9 @@ struct intel_uncore_box *uncore_pmu_to_box(struct intel_uncore_pmu *pmu, int cpu <nl>  		return box; <nl>   <nl>  	raw_spin_lock(&uncore_box_lock); <nl> +	/* Recheck in lock to handle races. */ <nl> +	if (*per_cpu_ptr(pmu->box, cpu)) <nl> +		goto out; <nl>  	list_for_each_entry(box, &pmu->box_list, list) { <nl>  		if (box->phys_id == topology_physical_package_id(cpu)) { <nl>  			atomic_inc(&box->refcnt); <nl> @@ -49,6 +52,7 @@ struct intel_uncore_box *uncore_pmu_to_box(struct intel_uncore_pmu *pmu, int cpu <nl>  			break; <nl>  		} <nl>  	} <nl> +out: <nl>  	raw_spin_unlock(&uncore_box_lock); <nl>   <nl>  	return *per_cpu_ptr(pmu->box, cpu);
@@ -264,7 +264,8 @@ __visible void prepare_exit_to_usermode(struct pt_regs *regs) <nl>  			READ_ONCE(pt_regs_to_thread_info(regs)->flags); <nl>   <nl>  		if (!(cached_flags & (_TIF_SIGPENDING | _TIF_NOTIFY_RESUME | <nl> -				      _TIF_UPROBE | _TIF_NEED_RESCHED))) <nl> +				      _TIF_UPROBE | _TIF_NEED_RESCHED | <nl> +				      _TIF_USER_RETURN_NOTIFY))) <nl>  			break; <nl>   <nl>  		/* We have work to do. */
@@ -4989,7 +4989,7 @@ again: <nl>  	case STAC_DELL_M4_3: <nl>  		spec->num_dmics = 1; <nl>  		spec->num_smuxes = 0; <nl> -		spec->num_dmuxes = 0; <nl> +		spec->num_dmuxes = 1; <nl>  		break; <nl>  	default: <nl>  		spec->num_dmics = STAC92HD71BXX_NUM_DMICS;
@@ -423,6 +423,7 @@ again: <nl>  	} <nl>  	spin_unlock(&fs_info->reada_lock); <nl>   <nl> +	kfree(multi); <nl>  	return re; <nl>   <nl>  error: <nl> @@ -447,6 +448,7 @@ error: <nl>  		kref_put(&zone->refcnt, reada_zone_release); <nl>  		spin_unlock(&fs_info->reada_lock); <nl>  	} <nl> +	kfree(multi); <nl>  	kfree(re); <nl>  	if (looped) <nl>  		goto again;
@@ -228,7 +228,7 @@ static __inline__ int rt6_check_expired(const struct rt6_info *rt) <nl>  static inline int rt6_need_strict(struct in6_addr *daddr) <nl>  { <nl>  	return (ipv6_addr_type(daddr) & <nl> -		(IPV6_ADDR_MULTICAST | IPV6_ADDR_LINKLOCAL)); <nl> +		(IPV6_ADDR_MULTICAST | IPV6_ADDR_LINKLOCAL | IPV6_ADDR_LOOPBACK)); <nl>  } <nl>   <nl>  /*
@@ -166,7 +166,7 @@ static u64 bpf_get_current_comm(u64 r1, u64 size, u64 r3, u64 r4, u64 r5) <nl>  	if (!task) <nl>  		return -EINVAL; <nl>   <nl> -	memcpy(buf, task->comm, min_t(size_t, size, sizeof(task->comm))); <nl> +	strlcpy(buf, task->comm, min_t(size_t, size, sizeof(task->comm))); <nl>  	return 0; <nl>  } <nl>  
@@ -737,7 +737,7 @@ static unsigned int br_nf_forward_ip(unsigned int hook, struct sk_buff *skb, <nl>  		nf_bridge->mask |= BRNF_PKT_TYPE; <nl>  	} <nl>   <nl> -	if (br_parse_ip_options(skb)) <nl> +	if (pf == PF_INET && br_parse_ip_options(skb)) <nl>  		return NF_DROP; <nl>   <nl>  	/* The physdev module checks on this */
@@ -1605,9 +1605,6 @@ static int vmx_vcpu_setup(struct vcpu_vmx *vmx) <nl>  	vmcs_writel(CR0_GUEST_HOST_MASK, ~0UL); <nl>  	vmcs_writel(CR4_GUEST_HOST_MASK, KVM_GUEST_CR4_MASK); <nl>   <nl> -	if (vm_need_virtualize_apic_accesses(vmx->vcpu.kvm)) <nl> -		if (alloc_apic_access_page(vmx->vcpu.kvm) != 0) <nl> -			return -ENOMEM; <nl>   <nl>  	return 0; <nl>  } <nl> @@ -2537,6 +2534,9 @@ static struct kvm_vcpu *vmx_create_vcpu(struct kvm *kvm, unsigned int id) <nl>  	put_cpu(); <nl>  	if (err) <nl>  		goto free_vmcs; <nl> +	if (vm_need_virtualize_apic_accesses(kvm)) <nl> +		if (alloc_apic_access_page(kvm) != 0) <nl> +			goto free_vmcs; <nl>   <nl>  	return &vmx->vcpu; <nl>  
@@ -376,6 +376,11 @@ int lustre_start_mgc(struct super_block *sb) <nl>   <nl>  	/* Random uuid for MGC allows easier reconnects */ <nl>  	OBD_ALLOC_PTR(uuid); <nl> +	if (!uuid) { <nl> +		rc = -ENOMEM; <nl> +		goto out_free; <nl> +	} <nl> + <nl>  	ll_generate_random_uuid(uuidc); <nl>  	class_uuid_unparse(uuidc, uuid); <nl>  
@@ -867,7 +867,7 @@ static void mac80211_hwsim_tx(struct ieee80211_hw *hw, <nl>   <nl>  	if (WARN_ON(skb->len < 10)) { <nl>  		/* Should not happen; just a sanity check for addr1 use */ <nl> -		dev_kfree_skb(skb); <nl> +		ieee80211_free_txskb(hw, skb); <nl>  		return; <nl>  	} <nl>   <nl> @@ -884,13 +884,13 @@ static void mac80211_hwsim_tx(struct ieee80211_hw *hw, <nl>  	} <nl>   <nl>  	if (WARN(!channel, "TX w/o channel - queue = %d\n", txi->hw_queue)) { <nl> -		dev_kfree_skb(skb); <nl> +		ieee80211_free_txskb(hw, skb); <nl>  		return; <nl>  	} <nl>   <nl>  	if (data->idle && !data->tmp_chan) { <nl>  		wiphy_debug(hw->wiphy, "Trying to TX when idle - reject\n"); <nl> -		dev_kfree_skb(skb); <nl> +		ieee80211_free_txskb(hw, skb); <nl>  		return; <nl>  	} <nl>  
@@ -187,7 +187,7 @@ void __init lpc32xx_serial_init(void) <nl>   <nl>  	/* This needs to be done after all UART clocks are setup */ <nl>  	__raw_writel(clkmodes, LPC32XX_UARTCTL_CLKMODE); <nl> -	for (i = 0; i < ARRAY_SIZE(uartinit_data) - 1; i++) { <nl> +	for (i = 0; i < ARRAY_SIZE(uartinit_data); i++) { <nl>  		/* Force a flush of the RX FIFOs to work around a HW bug */ <nl>  		puart = serial_std_platform_data[i].mapbase; <nl>  		__raw_writel(0xC1, LPC32XX_UART_IIR_FCR(puart));
@@ -863,6 +863,7 @@ static void _rtl_usb_tx_preprocess(struct ieee80211_hw *hw, struct sk_buff *skb, <nl>  	u8 tid = 0; <nl>  	u16 seq_number = 0; <nl>   <nl> +	memset(&tcb_desc, 0, sizeof(struct rtl_tcb_desc)); <nl>  	if (ieee80211_is_auth(fc)) { <nl>  		RT_TRACE(rtlpriv, COMP_SEND, DBG_DMESG, ("MAC80211_LINKING\n")); <nl>  		rtl_ips_nic_on(hw);
@@ -43,7 +43,7 @@ static struct plat_sci_port sci_platform_data = { <nl>  	.scscr		= SCSCR_TE | SCSCR_RE, <nl>  	.scbrr_algo_id	= SCBRR_ALGO_2, <nl>  	.type		= PORT_SCI, <nl> -	.irqs		= { 23, 23, 23, 0 }, <nl> +	.irqs		= SCIx_IRQ_MUXED(evt2irq(0xE40)), <nl>  	.regshift	= 2, <nl>  }; <nl>   <nl> @@ -61,7 +61,7 @@ static struct plat_sci_port scif_platform_data = { <nl>  	.scscr		= SCSCR_TE | SCSCR_RE | SCSCR_REIE, <nl>  	.scbrr_algo_id	= SCBRR_ALGO_2, <nl>  	.type		= PORT_SCIF, <nl> -	.irqs		= { 40, 40, 40, 40 }, <nl> +	.irqs		= SCIx_IRQ_MUXED(evt2irq(0x700)), <nl>  }; <nl>   <nl>  static struct platform_device scif_device = {
@@ -289,6 +289,8 @@ static int ivtv_video_command(struct ivtv *itv, struct ivtv_open_id *id, <nl>  	case V4L2_DEC_CMD_PAUSE: <nl>  		dc->flags &= V4L2_DEC_CMD_PAUSE_TO_BLACK; <nl>  		if (try) break; <nl> +		if (!atomic_read(&itv->decoding)) <nl> +			return -EPERM; <nl>  		if (itv->output_mode != OUT_MPG) <nl>  			return -EBUSY; <nl>  		if (atomic_read(&itv->decoding) > 0) { <nl> @@ -301,6 +303,8 @@ static int ivtv_video_command(struct ivtv *itv, struct ivtv_open_id *id, <nl>  	case V4L2_DEC_CMD_RESUME: <nl>  		dc->flags = 0; <nl>  		if (try) break; <nl> +		if (!atomic_read(&itv->decoding)) <nl> +			return -EPERM; <nl>  		if (itv->output_mode != OUT_MPG) <nl>  			return -EBUSY; <nl>  		if (test_and_clear_bit(IVTV_F_I_DEC_PAUSED, &itv->i_flags)) { <nl> @@ -1250,6 +1254,9 @@ static int ivtv_g_enc_index(struct file *file, void *fh, struct v4l2_enc_idx *id <nl>  	if (entries > V4L2_ENC_IDX_ENTRIES) <nl>  		entries = V4L2_ENC_IDX_ENTRIES; <nl>  	idx->entries = 0; <nl> +	idx->entries_cap = IVTV_MAX_PGM_INDEX; <nl> +	if (!atomic_read(&itv->capturing)) <nl> +		return 0; <nl>  	for (i = 0; i < entries; i++) { <nl>  		*e = itv->pgm_info[(itv->pgm_info_read_idx + i) % IVTV_MAX_PGM_INDEX]; <nl>  		if ((e->flags & V4L2_ENC_IDX_FRAME_MASK) <= V4L2_ENC_IDX_FRAME_B) {
@@ -1552,7 +1552,7 @@ static void __devinit uvesafb_init_info(struct fb_info *info, <nl>  	} <nl>   <nl>  	info->flags = FBINFO_FLAG_DEFAULT | <nl> -			(par->ypan) ? FBINFO_HWACCEL_YPAN : 0; <nl> +			(par->ypan ? FBINFO_HWACCEL_YPAN : 0); <nl>   <nl>  	if (!par->ypan) <nl>  		info->fbops->fb_pan_display = NULL;
@@ -243,6 +243,7 @@ struct sta_info *sta_info_alloc(struct ieee80211_sub_if_data *sdata, <nl>  	memcpy(sta->sta.addr, addr, ETH_ALEN); <nl>  	sta->local = local; <nl>  	sta->sdata = sdata; <nl> +	sta->last_rx = jiffies; <nl>   <nl>  	ewma_init(&sta->avg_signal, 1024, 8); <nl>  
@@ -975,7 +975,7 @@ static int r820t_set_tv_standard(struct r820t_priv *priv, <nl>  			return rc; <nl>  		msleep(1); <nl>  	} <nl> -	priv->int_freq = if_khz; <nl> +	priv->int_freq = if_khz * 1000; <nl>   <nl>  	/* Check if standard changed. If so, filter calibration is needed */ <nl>  	if (type != priv->type)
@@ -2667,6 +2667,9 @@ static noinline int copy_items(struct btrfs_trans_handle *trans, <nl>  			extent = btrfs_item_ptr(src, start_slot + i, <nl>  						struct btrfs_file_extent_item); <nl>   <nl> +			if (btrfs_file_extent_generation(src, extent) < trans->transid) <nl> +				continue; <nl> + <nl>  			found_type = btrfs_file_extent_type(src, extent); <nl>  			if (found_type == BTRFS_FILE_EXTENT_REG || <nl>  			    found_type == BTRFS_FILE_EXTENT_PREALLOC) {
@@ -1074,7 +1074,7 @@ static ssize_t tun_get_user(struct tun_struct *tun, struct tun_file *tfile, <nl>  	u32 rxhash; <nl>   <nl>  	if (!(tun->flags & TUN_NO_PI)) { <nl> -		if ((len -= sizeof(pi)) > total_len) <nl> +		if ((len -= sizeof(pi)) < 0) <nl>  			return -EINVAL; <nl>   <nl>  		if (memcpy_fromiovecend((void *)&pi, iv, 0, sizeof(pi))) <nl> @@ -1083,7 +1083,7 @@ static ssize_t tun_get_user(struct tun_struct *tun, struct tun_file *tfile, <nl>  	} <nl>   <nl>  	if (tun->flags & TUN_VNET_HDR) { <nl> -		if ((len -= tun->vnet_hdr_sz) > total_len) <nl> +		if ((len -= tun->vnet_hdr_sz) < 0) <nl>  			return -EINVAL; <nl>   <nl>  		if (memcpy_fromiovecend((void *)&gso, iv, offset, sizeof(gso)))
@@ -84,8 +84,10 @@ nouveau_gem_object_open(struct drm_gem_object *gem, struct drm_file *file_priv) <nl>  		} <nl>   <nl>  		ret = pm_runtime_get_sync(dev); <nl> -		if (ret < 0 && ret != -EACCES) <nl> +		if (ret < 0 && ret != -EACCES) { <nl> +			kfree(vma); <nl>  			goto out; <nl> +		} <nl>   <nl>  		ret = nouveau_bo_vma_add(nvbo, cli->vm, vma); <nl>  		if (ret)
@@ -925,10 +925,13 @@ static void setup_hw_stats(struct ib_device *device, struct ib_port *port, <nl>  		hsag->attrs[i] = alloc_hsa(i, port_num, stats->names[i]); <nl>  		if (!hsag->attrs[i]) <nl>  			goto err; <nl> +		sysfs_attr_init(hsag->attrs[i]); <nl>  	} <nl>   <nl>  	/* treat an error here as non-fatal */ <nl>  	hsag->attrs[i] = alloc_hsa_lifespan("lifespan", port_num); <nl> +	if (hsag->attrs[i]) <nl> +		sysfs_attr_init(hsag->attrs[i]); <nl>   <nl>  	if (port) { <nl>  		struct kobject *kobj = &port->kobj;
@@ -649,7 +649,7 @@ static const struct file_operations bm_register_operations = { <nl>  static ssize_t <nl>  bm_status_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos) <nl>  { <nl> -	char *s = enabled ? "enabled" : "disabled"; <nl> +	char *s = enabled ? "enabled\n" : "disabled\n"; <nl>   <nl>  	return simple_read_from_buffer(buf, nbytes, ppos, s, strlen(s)); <nl>  }
@@ -105,7 +105,7 @@ struct pt_watch_regs { <nl>  	enum pt_watch_style style; <nl>  	union { <nl>  		struct mips32_watch_regs mips32; <nl> -		struct mips32_watch_regs mips64; <nl> +		struct mips64_watch_regs mips64; <nl>  	}; <nl>  }; <nl>  
@@ -117,8 +117,10 @@ void rtl92e_set_key(struct net_device *dev, u8 EntryNo, u8 KeyIndex, <nl>  		} <nl>  	} <nl>  	priv->rtllib->is_set_key = true; <nl> -	if (EntryNo >= TOTAL_CAM_ENTRY) <nl> +	if (EntryNo >= TOTAL_CAM_ENTRY) { <nl>  		netdev_info(dev, "%s(): Invalid CAM entry\n", __func__); <nl> +		return; <nl> +	} <nl>   <nl>  	RT_TRACE(COMP_SEC, <nl>  		 "====>to rtl92e_set_key(), dev:%p, EntryNo:%d, KeyIndex:%d,KeyType:%d, MacAddr %pM\n",
@@ -1473,7 +1473,8 @@ static int vb2_internal_qbuf(struct vb2_queue *q, struct v4l2_buffer *b) <nl>  		 * For output buffers copy the timestamp if needed, <nl>  		 * and the timecode field and flag if needed. <nl>  		 */ <nl> -		if (q->timestamp_flags == V4L2_BUF_FLAG_TIMESTAMP_COPY) <nl> +		if ((q->timestamp_flags & V4L2_BUF_FLAG_TIMESTAMP_MASK) == <nl> +		    V4L2_BUF_FLAG_TIMESTAMP_COPY) <nl>  			vb->v4l2_buf.timestamp = b->timestamp; <nl>  		vb->v4l2_buf.flags |= b->flags & V4L2_BUF_FLAG_TIMECODE; <nl>  		if (b->flags & V4L2_BUF_FLAG_TIMECODE) <nl> @@ -2230,7 +2231,8 @@ int vb2_queue_init(struct vb2_queue *q) <nl>  		return -EINVAL; <nl>   <nl>  	/* Warn that the driver should choose an appropriate timestamp type */ <nl> -	WARN_ON(q->timestamp_flags == V4L2_BUF_FLAG_TIMESTAMP_UNKNOWN); <nl> +	WARN_ON((q->timestamp_flags & V4L2_BUF_FLAG_TIMESTAMP_MASK) == <nl> +		V4L2_BUF_FLAG_TIMESTAMP_UNKNOWN); <nl>   <nl>  	INIT_LIST_HEAD(&q->queued_list); <nl>  	INIT_LIST_HEAD(&q->done_list);
@@ -245,8 +245,7 @@ static s16 *read_rds_samples(struct cx88_core *core, u32 *N) <nl>  		current_address, <nl>  		current_address - srch->fifo_start, sample_count, <nl>  		cx_read(MO_AUD_INTSTAT)); <nl> - <nl> -	samples = kmalloc(sizeof(s16)*sample_count, GFP_KERNEL); <nl> +	samples = kmalloc_array(sample_count, sizeof(*samples), GFP_KERNEL); <nl>  	if (!samples) <nl>  		return NULL; <nl>  
@@ -2228,6 +2228,8 @@ static int snd_pcm_oss_open_file(struct file *file, <nl>  	for (idx = 0; idx < 2; idx++) { <nl>  		if (setup[idx].disable) <nl>  			continue; <nl> +		if (! pcm->streams[idx].substream_count) <nl> +			continue; /* no matching substream */ <nl>  		if (idx == SNDRV_PCM_STREAM_PLAYBACK) { <nl>  			if (! (f_mode & FMODE_WRITE)) <nl>  				continue;
@@ -322,6 +322,7 @@ out_device_destroy: <nl>  	scsi_device_set_state(sdev, SDEV_DEL); <nl>  	transport_destroy_device(&sdev->sdev_gendev); <nl>  	put_device(&sdev->sdev_dev); <nl> +	scsi_free_queue(sdev->request_queue); <nl>  	put_device(&sdev->sdev_gendev); <nl>  out: <nl>  	if (display_failure_msg)
@@ -962,6 +962,11 @@ ssize_t sdma_set_cpu_to_sde_map(struct sdma_engine *sde, const char *buf, <nl>  			continue; <nl>  		} <nl>   <nl> +		if (vl >= ARRAY_SIZE(rht_node->map)) { <nl> +			ret = -EINVAL; <nl> +			goto out; <nl> +		} <nl> + <nl>  		rht_node = rhashtable_lookup_fast(dd->sdma_rht, &cpu, <nl>  						  sdma_rht_params); <nl>  		if (!rht_node) {
@@ -924,7 +924,8 @@ extern void __rta_fill(struct sk_buff *skb, int attrtype, int attrlen, const voi <nl>  	(skb)->len; }) <nl>   <nl>  #define RTA_NEST_CANCEL(skb, start) \ <nl> -({	skb_trim(skb, (unsigned char *) (start) - (skb)->data); \ <nl> +({	if (start) \ <nl> +		skb_trim(skb, (unsigned char *) (start) - (skb)->data); \ <nl>  	-1; }) <nl>   <nl>  #define RTA_GET_U32(rta) \
@@ -823,7 +823,13 @@ resend: <nl>  		/* For flock requests we immediatelly return without further <nl>  		   delay and let caller deal with the rest, since rest of <nl>  		   this function metadata processing makes no sense for flock <nl> -		   requests anyway */ <nl> +		   requests anyway. But in case of problem during comms with <nl> +		   Server (ETIMEDOUT) or any signal/kill attempt (EINTR), we <nl> +		   can not rely on caller and this mainly for F_UNLCKs <nl> +		   (explicits or automatically generated by Kernel to clean <nl> +		   current FLocks upon exit) that can't be trashed */ <nl> +		if ((rc == -EINTR) || (rc == -ETIMEDOUT)) <nl> +			goto resend; <nl>  		RETURN(rc); <nl>  	} <nl>  
@@ -841,7 +841,7 @@ struct fimc_fmt *find_format(struct v4l2_format *f, unsigned int mask) <nl>   <nl>  	for (i = 0; i < ARRAY_SIZE(fimc_formats); ++i) { <nl>  		fmt = &fimc_formats[i]; <nl> -		if (fmt->fourcc == f->fmt.pix.pixelformat && <nl> +		if (fmt->fourcc == f->fmt.pix_mp.pixelformat && <nl>  		   (fmt->flags & mask)) <nl>  			break; <nl>  	}
@@ -475,7 +475,7 @@ static int fuse_get_user_pages(struct fuse_req *req, const char __user *buf, <nl>   <nl>  	nbytes = min(nbytes, (unsigned) FUSE_MAX_PAGES_PER_REQ << PAGE_SHIFT); <nl>  	npages = (nbytes + offset + PAGE_SIZE - 1) >> PAGE_SHIFT; <nl> -	npages = min(npages, FUSE_MAX_PAGES_PER_REQ); <nl> +	npages = min(max(npages, 1), FUSE_MAX_PAGES_PER_REQ); <nl>  	down_read(&current->mm->mmap_sem); <nl>  	npages = get_user_pages(current, current->mm, user_addr, npages, write, <nl>  				0, req->pages, NULL); <nl> @@ -506,7 +506,6 @@ static ssize_t fuse_direct_io(struct file *file, const char __user *buf, <nl>  		return -EINTR; <nl>   <nl>  	while (count) { <nl> -		size_t tmp; <nl>  		size_t nres; <nl>  		size_t nbytes = min(count, nmax); <nl>  		int err = fuse_get_user_pages(req, buf, nbytes, !write); <nl> @@ -514,8 +513,8 @@ static ssize_t fuse_direct_io(struct file *file, const char __user *buf, <nl>  			res = err; <nl>  			break; <nl>  		} <nl> -		tmp = (req->num_pages << PAGE_SHIFT) - req->page_offset; <nl> -		nbytes = min(nbytes, tmp); <nl> +		nbytes = (req->num_pages << PAGE_SHIFT) - req->page_offset; <nl> +		nbytes = min(count, nbytes); <nl>  		if (write) <nl>  			nres = fuse_send_write(req, file, inode, pos, nbytes); <nl>  		else
@@ -1638,7 +1638,7 @@ void bcm43xx_phy_set_baseband_attenuation(struct bcm43xx_private *bcm, <nl>  		return; <nl>  	} <nl>   <nl> -	if (phy->analog == 1) { <nl> +	if (phy->analog > 1) { <nl>  		value = bcm43xx_phy_read(bcm, 0x0060) & ~0x003C; <nl>  		value |= (baseband_attenuation << 2) & 0x003C; <nl>  	} else {
@@ -819,7 +819,7 @@ static bool new_idmap_permitted(const struct file *file, <nl>  		u32 id = new_map->extent[0].lower_first; <nl>  		if (cap_setid == CAP_SETUID) { <nl>  			kuid_t uid = make_kuid(ns->parent, id); <nl> -			if (uid_eq(uid, file->f_cred->fsuid)) <nl> +			if (uid_eq(uid, file->f_cred->euid)) <nl>  				return true; <nl>  		} <nl>  	}
@@ -2973,6 +2973,10 @@ static int kvm_vcpu_ioctl_x86_set_vcpu_events(struct kvm_vcpu *vcpu, <nl>  			      | KVM_VCPUEVENT_VALID_SMM)) <nl>  		return -EINVAL; <nl>   <nl> +	if (events->exception.injected && <nl> +	    (events->exception.nr > 31 || events->exception.nr == NMI_VECTOR)) <nl> +		return -EINVAL; <nl> + <nl>  	process_nmi(vcpu); <nl>  	vcpu->arch.exception.pending = events->exception.injected; <nl>  	vcpu->arch.exception.nr = events->exception.nr;
@@ -957,9 +957,6 @@ static int br_multicast_ipv4_rcv(struct net_bridge *br, <nl>  	unsigned offset; <nl>  	int err; <nl>   <nl> -	BR_INPUT_SKB_CB(skb)->igmp = 0; <nl> -	BR_INPUT_SKB_CB(skb)->mrouters_only = 0; <nl> - <nl>  	/* We treat OOM as packet loss for now. */ <nl>  	if (!pskb_may_pull(skb, sizeof(*iph))) <nl>  		return -EINVAL; <nl> @@ -1049,6 +1046,9 @@ err_out: <nl>  int br_multicast_rcv(struct net_bridge *br, struct net_bridge_port *port, <nl>  		     struct sk_buff *skb) <nl>  { <nl> +	BR_INPUT_SKB_CB(skb)->igmp = 0; <nl> +	BR_INPUT_SKB_CB(skb)->mrouters_only = 0; <nl> + <nl>  	if (br->multicast_disabled) <nl>  		return 0; <nl>  
@@ -847,6 +847,8 @@ static u8 parse_subframe(struct sk_buff *skb, <nl>  #else <nl>  			/* Allocate new skb for releasing to upper layer */ <nl>  			sub_skb = dev_alloc_skb(nSubframe_Length + 12); <nl> +			if (!sub_skb) <nl> +				return 0; <nl>  			skb_reserve(sub_skb, 12); <nl>  			data_ptr = (u8 *)skb_put(sub_skb, nSubframe_Length); <nl>  			memcpy(data_ptr, skb->data, nSubframe_Length);
@@ -609,7 +609,7 @@ static netdev_tx_t start_xmit(struct sk_buff *skb, struct net_device *dev) <nl>  	 * before it gets out of hand.  Naturally, this wastes entries. */ <nl>  	if (capacity < 2+MAX_SKB_FRAGS) { <nl>  		netif_stop_queue(dev); <nl> -		if (unlikely(!virtqueue_enable_cb(vi->svq))) { <nl> +		if (unlikely(!virtqueue_enable_cb_delayed(vi->svq))) { <nl>  			/* More just got used, free them then recheck. */ <nl>  			capacity += free_old_xmit_skbs(vi); <nl>  			if (capacity >= 2+MAX_SKB_FRAGS) {
@@ -108,13 +108,13 @@ static int check_offs_len(struct mtd_info *mtd, <nl>  	int ret = 0; <nl>   <nl>  	/* Start address must align on block boundary */ <nl> -	if (ofs & ((1 << chip->phys_erase_shift) - 1)) { <nl> +	if (ofs & ((1ULL << chip->phys_erase_shift) - 1)) { <nl>  		pr_debug("%s: unaligned address\n", __func__); <nl>  		ret = -EINVAL; <nl>  	} <nl>   <nl>  	/* Length must align on block boundary */ <nl> -	if (len & ((1 << chip->phys_erase_shift) - 1)) { <nl> +	if (len & ((1ULL << chip->phys_erase_shift) - 1)) { <nl>  		pr_debug("%s: length not block aligned\n", __func__); <nl>  		ret = -EINVAL; <nl>  	} <nl> @@ -394,7 +394,7 @@ static int nand_block_markbad_lowlevel(struct mtd_info *mtd, loff_t ofs) <nl>  		memset(&einfo, 0, sizeof(einfo)); <nl>  		einfo.mtd = mtd; <nl>  		einfo.addr = ofs; <nl> -		einfo.len = 1 << chip->phys_erase_shift; <nl> +		einfo.len = 1ULL << chip->phys_erase_shift; <nl>  		nand_erase_nand(mtd, &einfo, 0); <nl>   <nl>  		/* Write bad block marker to OOB */ <nl> @@ -2630,7 +2630,7 @@ int nand_erase_nand(struct mtd_info *mtd, struct erase_info *instr, <nl>  		} <nl>   <nl>  		/* Increment page address and decrement length */ <nl> -		len -= (1 << chip->phys_erase_shift); <nl> +		len -= (1ULL << chip->phys_erase_shift); <nl>  		page += pages_per_block; <nl>   <nl>  		/* Check, if we cross a chip boundary */
@@ -17,13 +17,13 @@ <nl>  void __attribute__((weak)) bust_spinlocks(int yes) <nl>  { <nl>  	if (yes) { <nl> -		oops_in_progress = 1; <nl> +		++oops_in_progress; <nl>  	} else { <nl>  #ifdef CONFIG_VT <nl>  		unblank_screen(); <nl>  #endif <nl> -		oops_in_progress = 0; <nl> -		wake_up_klogd(); <nl> +		if (--oops_in_progress == 0) <nl> +			wake_up_klogd(); <nl>  	} <nl>  } <nl>  
@@ -45,7 +45,7 @@ <nl>  #define SQ_SIZE(depth)		(depth * sizeof(struct nvme_command)) <nl>  #define CQ_SIZE(depth)		(depth * sizeof(struct nvme_completion)) <nl>  #define NVME_MINORS 64 <nl> -#define IO_TIMEOUT	(5 * HZ) <nl> +#define NVME_IO_TIMEOUT	(5 * HZ) <nl>  #define ADMIN_TIMEOUT	(60 * HZ) <nl>   <nl>  static int nvme_major; <nl> @@ -524,7 +524,7 @@ static int nvme_submit_flush(struct nvme_queue *nvmeq, struct nvme_ns *ns, <nl>  static int nvme_submit_flush_data(struct nvme_queue *nvmeq, struct nvme_ns *ns) <nl>  { <nl>  	int cmdid = alloc_cmdid(nvmeq, (void *)CMD_CTX_FLUSH, <nl> -						special_completion, IO_TIMEOUT); <nl> +					special_completion, NVME_IO_TIMEOUT); <nl>  	if (unlikely(cmdid < 0)) <nl>  		return cmdid; <nl>   <nl> @@ -557,7 +557,7 @@ static int nvme_submit_bio_queue(struct nvme_queue *nvmeq, struct nvme_ns *ns, <nl>  	iod->private = bio; <nl>   <nl>  	result = -EBUSY; <nl> -	cmdid = alloc_cmdid(nvmeq, iod, bio_completion, IO_TIMEOUT); <nl> +	cmdid = alloc_cmdid(nvmeq, iod, bio_completion, NVME_IO_TIMEOUT); <nl>  	if (unlikely(cmdid < 0)) <nl>  		goto free_iod; <nl>   <nl> @@ -1129,7 +1129,7 @@ static int nvme_submit_io(struct nvme_ns *ns, struct nvme_user_io __user *uio) <nl>  	if (length != (io.nblocks + 1) << ns->lba_shift) <nl>  		status = -ENOMEM; <nl>  	else <nl> -		status = nvme_submit_sync_cmd(nvmeq, &c, NULL, IO_TIMEOUT); <nl> +		status = nvme_submit_sync_cmd(nvmeq, &c, NULL, NVME_IO_TIMEOUT); <nl>   <nl>  	nvme_unmap_user_pages(dev, io.opcode & 1, io.addr, length, iod); <nl>  	nvme_free_iod(dev, iod);
@@ -396,8 +396,6 @@ static void __exit cleanup_nsc(void) <nl>  	if (pdev) { <nl>  		tpm_nsc_remove(&pdev->dev); <nl>  		platform_device_unregister(pdev); <nl> -		kfree(pdev); <nl> -		pdev = NULL; <nl>  	} <nl>   <nl>  	platform_driver_unregister(&nsc_drv);
@@ -16,9 +16,17 @@ <nl>  #include <linux/mtd/partitions.h> <nl>  #include <linux/mtd/physmap.h> <nl>  #include <linux/mtd/map.h> <nl> +#include <linux/regulator/fixed.h> <nl> +#include <linux/regulator/machine.h> <nl>  #include <asm/machvec.h> <nl>  #include <asm/io.h> <nl>   <nl> +/* Dummy supplies, where voltage doesn't matter */ <nl> +static struct regulator_consumer_supply dummy_supplies[] = { <nl> +	REGULATOR_SUPPLY("vddvario", "smsc911x"), <nl> +	REGULATOR_SUPPLY("vdd33a", "smsc911x"), <nl> +}; <nl> + <nl>  static const char *part_probes[] = { "cmdlinepart", NULL }; <nl>   <nl>  static struct mtd_partition rsk_partitions[] = { <nl> @@ -67,6 +75,8 @@ static struct platform_device *rsk_devices[] __initdata = { <nl>   <nl>  static int __init rsk_devices_setup(void) <nl>  { <nl> +	regulator_register_fixed(0, dummy_supplies, ARRAY_SIZE(dummy_supplies)); <nl> + <nl>  	return platform_add_devices(rsk_devices, <nl>  				    ARRAY_SIZE(rsk_devices)); <nl>  }
@@ -561,11 +561,10 @@ static int w5300_hw_probe(struct platform_device *pdev) <nl>  	if (!mem) <nl>  		return -ENXIO; <nl>  	mem_size = resource_size(mem); <nl> -	if (!devm_request_mem_region(&pdev->dev, mem->start, mem_size, name)) <nl> -		return -EBUSY; <nl> -	priv->base = devm_ioremap(&pdev->dev, mem->start, mem_size); <nl> -	if (!priv->base) <nl> -		return -EBUSY; <nl> + <nl> +	priv->base = devm_ioremap_resource(&pdev->dev, mem); <nl> +	if (IS_ERR(priv->base)) <nl> +		return PTR_ERR(priv->base); <nl>   <nl>  	spin_lock_init(&priv->reg_lock); <nl>  	priv->indirect = mem_size < W5300_BUS_DIRECT_SIZE;
@@ -1977,7 +1977,8 @@ static int __split_vma(struct mm_struct * mm, struct vm_area_struct * vma, <nl>  		return 0; <nl>   <nl>  	/* Clean everything up if vma_adjust failed. */ <nl> -	new->vm_ops->close(new); <nl> +	if (new->vm_ops && new->vm_ops->close) <nl> +		new->vm_ops->close(new); <nl>  	if (new->vm_file) { <nl>  		if (vma->vm_flags & VM_EXECUTABLE) <nl>  			removed_exe_file_vma(mm);
@@ -700,7 +700,7 @@ static int i2o_iop_systab_set(struct i2o_controller *c) <nl>  		root = pci_find_parent_resource(c->pdev, res); <nl>  		if (root == NULL) <nl>  			osm_warn("%s: Can't find parent resource!\n", c->name); <nl> -		if (root && allocate_resource(root, res, sb->desired_io_size, sb->desired_io_size, sb->desired_io_size, 1 << 20,	/* Unspecified, so use 1Mb and play safe */ <nl> +		if (root && allocate_resource(root, res, sb->desired_io_size, sb->desired_io_size, sb->desired_io_size, 1 << 12,	/* Unspecified, so use 4Kb and play safe */ <nl>  					      NULL, NULL) >= 0) { <nl>  			c->io_alloc = 1; <nl>  			sb->current_io_size = resource_size(res);
@@ -5887,7 +5887,7 @@ static int selinux_setprocattr(struct task_struct *p, <nl>  		return error; <nl>   <nl>  	/* Obtain a SID for the context, if one was specified. */ <nl> -	if (size && str[1] && str[1] != '\n') { <nl> +	if (size && str[0] && str[0] != '\n') { <nl>  		if (str[size-1] == '\n') { <nl>  			str[size-1] = 0; <nl>  			size--;
@@ -1357,8 +1357,14 @@ static int zcache_cpu_notifier(struct notifier_block *nb, <nl>  			kp->objnodes[kp->nr - 1] = NULL; <nl>  			kp->nr--; <nl>  		} <nl> -		kmem_cache_free(zcache_obj_cache, kp->obj); <nl> -		free_page((unsigned long)kp->page); <nl> +		if (kp->obj) { <nl> +			kmem_cache_free(zcache_obj_cache, kp->obj); <nl> +			kp->obj = NULL; <nl> +		} <nl> +		if (kp->page) { <nl> +			free_page((unsigned long)kp->page); <nl> +			kp->page = NULL; <nl> +		} <nl>  		break; <nl>  	default: <nl>  		break;
@@ -422,6 +422,7 @@ acpi_db_walk_for_execute(acpi_handle obj_handle, <nl>   <nl>  	status = acpi_get_object_info(obj_handle, &obj_info); <nl>  	if (ACPI_FAILURE(status)) { <nl> +		ACPI_FREE(pathname); <nl>  		return (status); <nl>  	} <nl>  
@@ -342,6 +342,8 @@ static int ml26124_hw_params(struct snd_pcm_substream *substream, <nl>  	struct ml26124_priv *priv = snd_soc_codec_get_drvdata(codec); <nl>  	int i = get_coeff(priv->mclk, params_rate(hw_params)); <nl>   <nl> +	if (i < 0) <nl> +		return i; <nl>  	priv->substream = substream; <nl>  	priv->rate = params_rate(hw_params); <nl>  
@@ -28,6 +28,7 @@ <nl>   <nl>  #include <plat/mailbox.h> <nl>   <nl> +static struct workqueue_struct *mboxd; <nl>  static struct omap_mbox *mboxes; <nl>  static DEFINE_RWLOCK(mboxes_lock); <nl>   <nl> @@ -188,7 +189,7 @@ static void __mbox_rx_interrupt(struct omap_mbox *mbox) <nl>  	/* no more messages in the fifo. clear IRQ source. */ <nl>  	ack_mbox_irq(mbox, IRQ_RX); <nl>  nomem: <nl> -	schedule_work(&mbox->rxq->work); <nl> +	queue_work(mboxd, &mbox->rxq->work); <nl>  } <nl>   <nl>  static irqreturn_t mbox_interrupt(int irq, void *p) <nl> @@ -401,12 +402,17 @@ EXPORT_SYMBOL(omap_mbox_unregister); <nl>   <nl>  static int __init omap_mbox_init(void) <nl>  { <nl> +	mboxd = create_workqueue("mboxd"); <nl> +	if (!mboxd) <nl> +		return -ENOMEM; <nl> + <nl>  	return 0; <nl>  } <nl>  module_init(omap_mbox_init); <nl>   <nl>  static void __exit omap_mbox_exit(void) <nl>  { <nl> +	destroy_workqueue(mboxd); <nl>  } <nl>  module_exit(omap_mbox_exit); <nl>  
@@ -15,9 +15,10 @@ nft_set_pktinfo_ipv6(struct nft_pktinfo *pkt, <nl>  	nft_set_pktinfo(pkt, skb, state); <nl>   <nl>  	protohdr = ipv6_find_hdr(pkt->skb, &thoff, -1, &frag_off, NULL); <nl> -	/* If malformed, drop it */ <nl> -	if (protohdr < 0) <nl> +	if (protohdr < 0) { <nl> +		nft_set_pktinfo_proto_unspec(pkt, skb); <nl>  		return -1; <nl> +	} <nl>   <nl>  	pkt->tprot_set = true; <nl>  	pkt->tprot = protohdr;
@@ -1514,14 +1514,16 @@ static int cz_dpm_set_powergating_state(void *handle, <nl>  	return 0; <nl>  } <nl>   <nl> -/* borrowed from KV, need future unify */ <nl>  static int cz_dpm_get_temperature(struct amdgpu_device *adev) <nl>  { <nl>  	int actual_temp = 0; <nl> -	uint32_t temp = RREG32_SMC(0xC0300E0C); <nl> +	uint32_t val = RREG32_SMC(ixTHM_TCON_CUR_TMP); <nl> +	uint32_t temp = REG_GET_FIELD(val, THM_TCON_CUR_TMP, CUR_TEMP); <nl>   <nl> -	if (temp) <nl> +	if (REG_GET_FIELD(val, THM_TCON_CUR_TMP, CUR_TEMP_RANGE_SEL)) <nl>  		actual_temp = 1000 * ((temp / 8) - 49); <nl> +	else <nl> +		actual_temp = 1000 * (temp / 8); <nl>   <nl>  	return actual_temp; <nl>  }
@@ -2458,7 +2458,7 @@ static void b43_request_firmware(struct work_struct *work) <nl>  	for (i = 0; i < B43_NR_FWTYPES; i++) { <nl>  		errmsg = ctx->errors[i]; <nl>  		if (strlen(errmsg)) <nl> -			b43err(dev->wl, errmsg); <nl> +			b43err(dev->wl, "%s", errmsg); <nl>  	} <nl>  	b43_print_fw_helptext(dev->wl, 1); <nl>  	goto out;
@@ -227,6 +227,8 @@ int __init omap2_clk_provider_init(struct device_node *parent, int index, <nl>  	clocks_node_ptr[index] = clocks; <nl>   <nl>  	io = kzalloc(sizeof(*io), GFP_KERNEL); <nl> +	if (!io) <nl> +		return -ENOMEM; <nl>   <nl>  	io->regmap = syscon; <nl>  	io->mem = mem;
@@ -1520,13 +1520,15 @@ static noinline long btrfs_ioctl_clone(struct file *file, unsigned long srcfd, <nl>  	while (1) { <nl>  		struct btrfs_ordered_extent *ordered; <nl>  		lock_extent(&BTRFS_I(src)->io_tree, off, off+len, GFP_NOFS); <nl> -		ordered = btrfs_lookup_first_ordered_extent(inode, off+len); <nl> -		if (BTRFS_I(src)->delalloc_bytes == 0 && !ordered) <nl> +		ordered = btrfs_lookup_first_ordered_extent(src, off+len); <nl> +		if (!ordered && <nl> +		    !test_range_bit(&BTRFS_I(src)->io_tree, off, off+len, <nl> +				   EXTENT_DELALLOC, 0, NULL)) <nl>  			break; <nl>  		unlock_extent(&BTRFS_I(src)->io_tree, off, off+len, GFP_NOFS); <nl>  		if (ordered) <nl>  			btrfs_put_ordered_extent(ordered); <nl> -		btrfs_wait_ordered_range(src, off, off+len); <nl> +		btrfs_wait_ordered_range(src, off, len); <nl>  	} <nl>   <nl>  	/* clone data */
@@ -115,7 +115,8 @@ nfsd_cross_mnt(struct svc_rqst *rqstp, struct dentry **dpp, <nl>   <nl>  	exp2 = rqst_exp_get_by_name(rqstp, mnt, mounts); <nl>  	if (IS_ERR(exp2)) { <nl> -		err = PTR_ERR(exp2); <nl> +		if (PTR_ERR(exp2) != -ENOENT) <nl> +			err = PTR_ERR(exp2); <nl>  		dput(mounts); <nl>  		mntput(mnt); <nl>  		goto out;
@@ -902,6 +902,7 @@ read_rtc: <nl>  		} <nl>  		ds1307->nvram->attr.name = "nvram"; <nl>  		ds1307->nvram->attr.mode = S_IRUGO | S_IWUSR; <nl> +		sysfs_bin_attr_init(ds1307->nvram); <nl>  		ds1307->nvram->read = ds1307_nvram_read, <nl>  		ds1307->nvram->write = ds1307_nvram_write, <nl>  		ds1307->nvram->size = chip->nvram_size;
@@ -702,8 +702,10 @@ static struct pxamci_platform_data magician_mci_info = { <nl>   <nl>  static struct pxaohci_platform_data magician_ohci_info = { <nl>  	.port_mode	= PMM_PERPORT_MODE, <nl> -	.flags		= ENABLE_PORT1 | ENABLE_PORT3 | POWER_CONTROL_LOW, <nl> +	/* port1: CSR Bluetooth, port2: OTG with UDC */ <nl> +	.flags		= ENABLE_PORT1 | ENABLE_PORT2 | POWER_CONTROL_LOW, <nl>  	.power_budget	= 0, <nl> +	.power_on_delay = 100, <nl>  }; <nl>   <nl>  /*
@@ -1838,7 +1838,7 @@ int bond_enslave(struct net_device *bond_dev, struct net_device *slave_dev) <nl>  		 * anyway (it holds no special properties of the bond device), <nl>  		 * so we can change it without calling change_active_interface() <nl>  		 */ <nl> -		if (!bond->curr_active_slave) <nl> +		if (!bond->curr_active_slave && new_slave->link == BOND_LINK_UP) <nl>  			bond->curr_active_slave = new_slave; <nl>   <nl>  		break;
@@ -306,6 +306,7 @@ int pcmcia_modify_configuration(struct pcmcia_device *p_dev, <nl>  		int i; <nl>   <nl>  		io_on.speed = io_speed; <nl> +		mutex_lock(&s->ops_mutex); <nl>  		for (i = 0; i < MAX_IO_WIN; i++) { <nl>  			if (!s->io[i].res) <nl>  				continue; <nl> @@ -320,6 +321,7 @@ int pcmcia_modify_configuration(struct pcmcia_device *p_dev, <nl>  			mdelay(40); <nl>  			s->ops->set_io_map(s, &io_on); <nl>  		} <nl> +		mutex_unlock(&s->ops_mutex); <nl>  	} <nl>   <nl>  	return 0; <nl> @@ -345,6 +347,7 @@ int pcmcia_release_configuration(struct pcmcia_device *p_dev) <nl>  	} <nl>  	if (c->state & CONFIG_LOCKED) { <nl>  		c->state &= ~CONFIG_LOCKED; <nl> +		mutex_lock(&s->ops_mutex); <nl>  		if (c->state & CONFIG_IO_REQ) <nl>  			for (i = 0; i < MAX_IO_WIN; i++) { <nl>  				if (!s->io[i].res) <nl> @@ -355,6 +358,7 @@ int pcmcia_release_configuration(struct pcmcia_device *p_dev) <nl>  				io.map = i; <nl>  				s->ops->set_io_map(s, &io); <nl>  			} <nl> +		mutex_unlock(&s->ops_mutex); <nl>  	} <nl>   <nl>  	return 0; <nl> @@ -562,6 +566,7 @@ int pcmcia_request_configuration(struct pcmcia_device *p_dev, <nl>   <nl>  	/* Configure I/O windows */ <nl>  	if (c->state & CONFIG_IO_REQ) { <nl> +		mutex_lock(&s->ops_mutex); <nl>  		iomap.speed = io_speed; <nl>  		for (i = 0; i < MAX_IO_WIN; i++) <nl>  			if (s->io[i].res) { <nl> @@ -580,6 +585,7 @@ int pcmcia_request_configuration(struct pcmcia_device *p_dev, <nl>  				s->ops->set_io_map(s, &iomap); <nl>  				s->io[i].Config++; <nl>  			} <nl> +		mutex_unlock(&s->ops_mutex); <nl>  	} <nl>   <nl>  	c->state |= CONFIG_LOCKED; <nl> @@ -625,10 +631,12 @@ int pcmcia_request_io(struct pcmcia_device *p_dev, io_req_t *req) <nl>  		return -EINVAL; <nl>  	} <nl>   <nl> +	mutex_lock(&s->ops_mutex); <nl>  	dev_dbg(&s->dev, "trying to allocate resource 1\n"); <nl>  	if (alloc_io_space(s, req->Attributes1, &req->BasePort1, <nl>  			   req->NumPorts1, req->IOAddrLines)) { <nl>  		dev_dbg(&s->dev, "allocation of resource 1 failed\n"); <nl> +		mutex_unlock(&s->ops_mutex); <nl>  		return -EBUSY; <nl>  	} <nl>   <nl> @@ -638,9 +646,11 @@ int pcmcia_request_io(struct pcmcia_device *p_dev, io_req_t *req) <nl>  				   req->NumPorts2, req->IOAddrLines)) { <nl>  			dev_dbg(&s->dev, "allocation of resource 2 failed\n"); <nl>  			release_io_space(s, req->BasePort1, req->NumPorts1); <nl> +			mutex_unlock(&s->ops_mutex); <nl>  			return -EBUSY; <nl>  		} <nl>  	} <nl> +	mutex_unlock(&s->ops_mutex); <nl>   <nl>  	c->io = *req; <nl>  	c->state |= CONFIG_IO_REQ;
@@ -870,8 +870,10 @@ static struct p9_req *p9_send_request(struct p9_conn *m, <nl>  	else <nl>  		n = p9_mux_get_tag(m); <nl>   <nl> -	if (n < 0) <nl> +	if (n < 0) { <nl> +		kfree(req); <nl>  		return ERR_PTR(-ENOMEM); <nl> +	} <nl>   <nl>  	p9_set_tag(tc, n); <nl>  
@@ -172,8 +172,6 @@ struct uts_namespace; <nl>   <nl>  extern cpumask_var_t cpu_isolated_map; <nl>   <nl> -extern int runqueue_is_locked(int cpu); <nl> - <nl>  extern void scheduler_tick(void); <nl>   <nl>  #define	MAX_SCHEDULE_TIMEOUT	LONG_MAX
@@ -8,7 +8,7 @@ <nl>  #define PAGE_SIZE	(_AC(1,UL) << PAGE_SHIFT) <nl>  #define PAGE_MASK	(~(PAGE_SIZE-1)) <nl>   <nl> -#define __PHYSICAL_MASK		((phys_addr_t)(1ULL << __PHYSICAL_MASK_SHIFT) - 1) <nl> +#define __PHYSICAL_MASK		((phys_addr_t)((1ULL << __PHYSICAL_MASK_SHIFT) - 1)) <nl>  #define __VIRTUAL_MASK		((1UL << __VIRTUAL_MASK_SHIFT) - 1) <nl>   <nl>  /* Cast PAGE_MASK to a signed type so that it is sign-extended if
@@ -396,6 +396,11 @@ static void mt_feature_mapping(struct hid_device *hdev, <nl>  			td->is_buttonpad = true; <nl>   <nl>  		break; <nl> +	case 0xff0000c5: <nl> +		/* Retrieve the Win8 blob once to enable some devices */ <nl> +		if (usage->usage_index == 0) <nl> +			mt_get_feature(hdev, field->report); <nl> +		break; <nl>  	} <nl>  } <nl>  
@@ -2975,6 +2975,7 @@ static void fsg_unbind(struct usb_configuration *c, struct usb_function *f) <nl>  	fsg_common_put(common); <nl>  	usb_free_descriptors(fsg->function.descriptors); <nl>  	usb_free_descriptors(fsg->function.hs_descriptors); <nl> +	usb_free_descriptors(fsg->function.ss_descriptors); <nl>  	kfree(fsg); <nl>  } <nl>  
@@ -12,6 +12,8 @@ <nl>  #include <linux/io.h> <nl>  #include <linux/leds.h> <nl>   <nl> +#include <asm/processor.h> <nl> + <nl>  #include <cobalt.h> <nl>   <nl>  #define RESET_PORT	((void __iomem *)CKSEG1ADDR(0x1c000000)) <nl> @@ -34,7 +36,10 @@ void cobalt_machine_halt(void) <nl>  	led_trigger_event(power_off_led_trigger, LED_FULL); <nl>   <nl>  	local_irq_disable(); <nl> -	while (1) ; <nl> +	while (1) { <nl> +		if (cpu_wait) <nl> +			cpu_wait(); <nl> +	} <nl>  } <nl>   <nl>  void cobalt_machine_restart(char *command)
@@ -1166,7 +1166,8 @@ static int pcs_parse_one_pinctrl_entry(struct pcs_device *pcs, <nl>  	(*map)->data.mux.function = np->name; <nl>   <nl>  	if (pcs->is_pinconf) { <nl> -		if (pcs_parse_pinconf(pcs, np, function, map)) <nl> +		res = pcs_parse_pinconf(pcs, np, function, map); <nl> +		if (res) <nl>  			goto free_pingroups; <nl>  		*num_maps = 2; <nl>  	} else {
@@ -3069,8 +3069,11 @@ static long kvm_vm_ioctl(struct file *filp, <nl>  					   routing.nr * sizeof(*entries))) <nl>  				goto out_free_irq_routing; <nl>  		} <nl> +		/* avoid races with KVM_CREATE_IRQCHIP on x86 */ <nl> +		mutex_lock(&kvm->lock); <nl>  		r = kvm_set_irq_routing(kvm, entries, routing.nr, <nl>  					routing.flags); <nl> +		mutex_unlock(&kvm->lock); <nl>  out_free_irq_routing: <nl>  		vfree(entries); <nl>  		break;
@@ -285,9 +285,8 @@ static int legacy_set_geometry(struct gpmi_nand_data *this) <nl>  	geo->ecc_strength = get_ecc_strength(this); <nl>  	if (!gpmi_check_ecc(this)) { <nl>  		dev_err(this->dev, <nl> -			"We can not support this nand chip." <nl> -			" Its required ecc strength(%d) is beyond our" <nl> -			" capability(%d).\n", geo->ecc_strength, <nl> +			"required ecc strength of the NAND chip: %d is not supported by the GPMI controller (%d)\n", <nl> +			geo->ecc_strength, <nl>  			this->devdata->bch_max_ecc_strength); <nl>  		return -EINVAL; <nl>  	} <nl> @@ -1597,8 +1596,9 @@ static int mx23_boot_init(struct gpmi_nand_data  *this) <nl>  			dev_dbg(dev, "Transcribing mark in block %u\n", block); <nl>  			ret = chip->block_markbad(mtd, byte); <nl>  			if (ret) <nl> -				dev_err(dev, "Failed to mark block bad with " <nl> -							"ret %d\n", ret); <nl> +				dev_err(dev, <nl> +					"Failed to mark block bad with ret %d\n", <nl> +					ret); <nl>  		} <nl>  	} <nl>  
@@ -2435,6 +2435,9 @@ static int rndis_set_default_key(struct wiphy *wiphy, struct net_device *netdev, <nl>   <nl>  	priv->encr_tx_key_index = key_index; <nl>   <nl> +	if (is_wpa_key(priv, key_index)) <nl> +		return 0; <nl> + <nl>  	key = priv->encr_keys[key_index]; <nl>   <nl>  	return add_wep_key(usbdev, key.material, key.len, key_index);
@@ -38,6 +38,15 @@ static inline void iounmap(volatile void __iomem *addr) <nl>  { <nl>  } <nl>   <nl> +static inline void __iomem *ioport_map(unsigned long port, unsigned int nr) <nl> +{ <nl> +	return NULL; <nl> +} <nl> + <nl> +static inline void ioport_unmap(void __iomem *p) <nl> +{ <nl> +} <nl> + <nl>  /* <nl>   * s390 needs a private implementation of pci_iomap since ioremap with its <nl>   * offset parameter isn't sufficient. That's because BAR spaces are not
@@ -282,7 +282,7 @@ static short rtl8192_check_nic_enough_desc(struct net_device *dev, int prio) <nl>  	return 0; <nl>  } <nl>   <nl> -static void rtl8192_tx_timeout(struct net_device *dev) <nl> +static void _rtl92e_tx_timeout(struct net_device *dev) <nl>  { <nl>  	struct r8192_priv *priv = rtllib_priv(dev); <nl>   <nl> @@ -2554,7 +2554,7 @@ done: <nl>  static const struct net_device_ops rtl8192_netdev_ops = { <nl>  	.ndo_open = _rtl92e_open, <nl>  	.ndo_stop = _rtl92e_close, <nl> -	.ndo_tx_timeout = rtl8192_tx_timeout, <nl> +	.ndo_tx_timeout = _rtl92e_tx_timeout, <nl>  	.ndo_do_ioctl = _rtl92e_ioctl, <nl>  	.ndo_set_rx_mode = r8192_set_multicast, <nl>  	.ndo_set_mac_address = r8192_set_mac_adr,
@@ -1114,8 +1114,10 @@ int memory_failure(unsigned long pfn, int trapno, int flags) <nl>  			 * shake_page could have turned it free. <nl>  			 */ <nl>  			if (is_free_buddy_page(p)) { <nl> -				action_result(pfn, "free buddy, 2nd try", <nl> -						DELAYED); <nl> +				if (flags & MF_COUNT_INCREASED) <nl> +					action_result(pfn, "free buddy", DELAYED); <nl> +				else <nl> +					action_result(pfn, "free buddy, 2nd try", DELAYED); <nl>  				return 0; <nl>  			} <nl>  			action_result(pfn, "non LRU", IGNORED);
@@ -76,11 +76,11 @@ static uint wapf = 1; <nl>  module_param(wapf, uint, 0644); <nl>  MODULE_PARM_DESC(wapf, "WAPF value"); <nl>   <nl> -static uint wireless_status = 1; <nl> +static uint wlan_status = 1; <nl>  static uint bluetooth_status = 1; <nl>   <nl> -module_param(wireless_status, uint, 0644); <nl> -MODULE_PARM_DESC(wireless_status, "Set the wireless status on boot " <nl> +module_param(wlan_status, uint, 0644); <nl> +MODULE_PARM_DESC(wlan_status, "Set the wireless status on boot " <nl>  		 "(0 = disabled, 1 = enabled, -1 = don't do anything). " <nl>  		 "default is 1"); <nl>   <nl> @@ -1446,8 +1446,8 @@ static int __devinit asus_acpi_init(struct asus_laptop *asus) <nl>  	if (bluetooth_status >= 0) <nl>  		asus_bluetooth_set(asus, !!bluetooth_status); <nl>   <nl> -	if (wireless_status >= 0) <nl> -		asus_wlan_set(asus, !!wireless_status); <nl> +	if (wlan_status >= 0) <nl> +		asus_wlan_set(asus, !!wlan_status); <nl>   <nl>  	/* Keyboard Backlight is on by default */ <nl>  	if (!acpi_check_handle(asus->handle, METHOD_KBD_LIGHT_SET, NULL))
@@ -23,6 +23,7 @@ <nl>  #include <linux/pm_runtime.h> <nl>  #include <linux/of.h> <nl>  #include <linux/platform_data/sc18is602.h> <nl> +#include <linux/gpio/consumer.h> <nl>   <nl>  enum chips { sc18is602, sc18is602b, sc18is603 }; <nl>   <nl> @@ -50,6 +51,8 @@ struct sc18is602 { <nl>  	u8			buffer[SC18IS602_BUFSIZ + 1]; <nl>  	int			tlen;	/* Data queued for tx in buffer */ <nl>  	int			rindex;	/* Receive data index in buffer */ <nl> + <nl> +	struct gpio_desc	*reset; <nl>  }; <nl>   <nl>  static int sc18is602_wait_ready(struct sc18is602 *hw, int len) <nl> @@ -257,6 +260,12 @@ static int sc18is602_probe(struct i2c_client *client, <nl>  	hw = spi_master_get_devdata(master); <nl>  	i2c_set_clientdata(client, hw); <nl>   <nl> +	/* assert reset and then release */ <nl> +	hw->reset = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_HIGH); <nl> +	if (IS_ERR(hw->reset)) <nl> +		return PTR_ERR(hw->reset); <nl> +	gpiod_set_value(hw->reset, 0); <nl> + <nl>  	hw->master = master; <nl>  	hw->client = client; <nl>  	hw->dev = dev;
@@ -1143,7 +1143,7 @@ static void serial_console_write(struct console *co, const char *s, <nl>  	while ((sci_in(port, SCxSR) & bits) != bits) <nl>  		cpu_relax(); <nl>   <nl> -	if (sci_port->disable); <nl> +	if (sci_port->disable) <nl>  		sci_port->disable(port); <nl>  } <nl>  
@@ -39,6 +39,7 @@ void flush_thread(void) <nl>   <nl>  void start_thread(struct pt_regs *regs, unsigned long eip, unsigned long esp) <nl>  { <nl> +	get_safe_registers(regs->regs.gp, regs->regs.fp); <nl>  	PT_REGS_IP(regs) = eip; <nl>  	PT_REGS_SP(regs) = esp; <nl>  	current->ptrace &= ~PT_DTRACE;
@@ -80,9 +80,12 @@ static inline struct page *pte_alloc_one(struct mm_struct *mm, <nl>  	struct page *pte; <nl>   <nl>  	pte = alloc_pages(GFP_KERNEL | __GFP_REPEAT, PTE_ORDER); <nl> -	if (pte) { <nl> -		clear_highpage(pte); <nl> -		pgtable_page_ctor(pte); <nl> +	if (!pte) <nl> +		return NULL; <nl> +	clear_highpage(pte); <nl> +	if (!pgtable_page_ctor(pte)) { <nl> +		__free_page(pte); <nl> +		return NULL; <nl>  	} <nl>  	return pte; <nl>  }
@@ -1594,7 +1594,8 @@ void kvm_lapic_reset(struct kvm_vcpu *vcpu, bool init_event) <nl>  	apic_set_reg(apic, APIC_DFR, 0xffffffffU); <nl>  	apic_set_spiv(apic, 0xff); <nl>  	apic_set_reg(apic, APIC_TASKPRI, 0); <nl> -	kvm_apic_set_ldr(apic, 0); <nl> +	if (!apic_x2apic_mode(apic)) <nl> +		kvm_apic_set_ldr(apic, 0); <nl>  	apic_set_reg(apic, APIC_ESR, 0); <nl>  	apic_set_reg(apic, APIC_ICR, 0); <nl>  	apic_set_reg(apic, APIC_ICR2, 0);
@@ -302,7 +302,9 @@ static int da9055_rtc_probe(struct platform_device *pdev) <nl>  	} <nl>   <nl>  	alm_irq = platform_get_irq_byname(pdev, "ALM"); <nl> -	alm_irq = regmap_irq_get_virq(rtc->da9055->irq_data, alm_irq); <nl> +	if (alm_irq < 0) <nl> +		return alm_irq; <nl> + <nl>  	ret = devm_request_threaded_irq(&pdev->dev, alm_irq, NULL, <nl>  					da9055_rtc_alm_irq, <nl>  					IRQF_TRIGGER_HIGH | IRQF_ONESHOT,
@@ -793,11 +793,11 @@ static int wm0010_set_sysclk(struct snd_soc_codec *codec, int source, <nl>  		wm0010->max_spi_freq = 0; <nl>  	} else { <nl>  		for (i = 0; i < ARRAY_SIZE(pll_clock_map); i++) <nl> -			if (freq >= pll_clock_map[i].max_sysclk) <nl> +			if (freq >= pll_clock_map[i].max_sysclk) { <nl> +				wm0010->max_spi_freq = pll_clock_map[i].max_pll_spi_speed; <nl> +				wm0010->pll_clkctrl1 = pll_clock_map[i].pll_clkctrl1; <nl>  				break; <nl> - <nl> -		wm0010->max_spi_freq = pll_clock_map[i].max_pll_spi_speed; <nl> -		wm0010->pll_clkctrl1 = pll_clock_map[i].pll_clkctrl1; <nl> +			} <nl>  	} <nl>   <nl>  	return 0;
@@ -419,6 +419,7 @@ use_default_name: <nl>  	device_initialize(&rdev->wiphy.dev); <nl>  	rdev->wiphy.dev.class = &ieee80211_class; <nl>  	rdev->wiphy.dev.platform_data = rdev; <nl> +	device_enable_async_suspend(&rdev->wiphy.dev); <nl>   <nl>  	INIT_LIST_HEAD(&rdev->destroy_list); <nl>  	spin_lock_init(&rdev->destroy_list_lock);
@@ -84,6 +84,10 @@ MODULE_DEVICE_TABLE(usb, pn533_table); <nl>  #define PN533_LISTEN_TIME 2 <nl>   <nl>  /* frame definitions */ <nl> +#define PN533_NORMAL_FRAME_MAX_LEN 262  /* 6   (PREAMBLE, SOF, LEN, LCS, TFI) <nl> +					   254 (DATA) <nl> +					   2   (DCS, postamble) */ <nl> + <nl>  #define PN533_FRAME_TAIL_SIZE 2 <nl>  #define PN533_FRAME_SIZE(f) (sizeof(struct pn533_frame) + f->datalen + \ <nl>  				PN533_FRAME_TAIL_SIZE) <nl> @@ -2373,9 +2377,9 @@ static int pn533_probe(struct usb_interface *interface, <nl>  		goto error; <nl>  	} <nl>   <nl> -	dev->in_frame = kmalloc(dev->in_maxlen, GFP_KERNEL); <nl> +	dev->in_frame = kmalloc(PN533_NORMAL_FRAME_MAX_LEN, GFP_KERNEL); <nl>  	dev->in_urb = usb_alloc_urb(0, GFP_KERNEL); <nl> -	dev->out_frame = kmalloc(dev->out_maxlen, GFP_KERNEL); <nl> +	dev->out_frame = kmalloc(PN533_NORMAL_FRAME_MAX_LEN, GFP_KERNEL); <nl>  	dev->out_urb = usb_alloc_urb(0, GFP_KERNEL); <nl>   <nl>  	if (!dev->in_frame || !dev->out_frame ||
@@ -847,15 +847,10 @@ static int mousevsc_probe(struct hv_device *dev) <nl>   <nl>  static int mousevsc_remove(struct hv_device *dev) <nl>  { <nl> -	int ret = 0; <nl> - <nl>  	struct input_device_context *input_dev_ctx; <nl> +	int ret; <nl>   <nl> -	input_dev_ctx = kmalloc(sizeof(struct input_device_context), <nl> -				GFP_KERNEL); <nl> - <nl> -	dev_set_drvdata(&dev->device, input_dev_ctx); <nl> - <nl> +	input_dev_ctx = dev_get_drvdata(&dev->device); <nl>  	if (input_dev_ctx->connected) { <nl>  		hidinput_disconnect(input_dev_ctx->hid_device); <nl>  		input_dev_ctx->connected = 0; <nl> @@ -866,7 +861,6 @@ static int mousevsc_remove(struct hv_device *dev) <nl>  	 * is being removed <nl>  	 */ <nl>  	ret = mousevsc_on_device_remove(dev); <nl> - <nl>  	if (ret != 0) { <nl>  		DPRINT_ERR(INPUTVSC_DRV, <nl>  			   "unable to remove vsc device (ret %d)", ret);
@@ -2620,7 +2620,7 @@ int osc_queue_sync_pages(const struct lu_env *env, struct osc_object *obj, <nl>  { <nl>  	struct client_obd     *cli = osc_cli(obj); <nl>  	struct osc_extent     *ext; <nl> -	struct osc_async_page *oap; <nl> +	struct osc_async_page *oap, *tmp; <nl>  	int     page_count = 0; <nl>  	int     mppr       = cli->cl_max_pages_per_rpc; <nl>  	pgoff_t start      = CL_PAGE_EOF; <nl> @@ -2639,7 +2639,7 @@ int osc_queue_sync_pages(const struct lu_env *env, struct osc_object *obj, <nl>   <nl>  	ext = osc_extent_alloc(obj); <nl>  	if (ext == NULL) { <nl> -		list_for_each_entry(oap, list, oap_pending_item) { <nl> +		list_for_each_entry_safe(oap, tmp, list, oap_pending_item) { <nl>  			list_del_init(&oap->oap_pending_item); <nl>  			osc_ap_completion(env, cli, oap, 0, -ENOMEM); <nl>  		}
@@ -3379,7 +3379,7 @@ int usb_disable_lpm(struct usb_device *udev) <nl>  		return 0; <nl>   <nl>  	udev->lpm_disable_count++; <nl> -	if ((udev->u1_params.timeout == 0 && udev->u1_params.timeout == 0)) <nl> +	if ((udev->u1_params.timeout == 0 && udev->u2_params.timeout == 0)) <nl>  		return 0; <nl>   <nl>  	/* If LPM is enabled, attempt to disable it. */
@@ -594,8 +594,8 @@ struct radeon_device { <nl>  	struct radeon_object		*fbdev_robj; <nl>  	struct radeon_framebuffer	*fbdev_rfb; <nl>  	/* Register mmio */ <nl> -	unsigned long			rmmio_base; <nl> -	unsigned long			rmmio_size; <nl> +	resource_size_t			rmmio_base; <nl> +	resource_size_t			rmmio_size; <nl>  	void				*rmmio; <nl>  	radeon_rreg_t			mm_rreg; <nl>  	radeon_wreg_t			mm_wreg;
@@ -706,6 +706,7 @@ static struct priority_group *parse_priority_group(struct arg_set *as, <nl>   <nl>  		if (as->argc < nr_params) { <nl>  			ti->error = "not enough path parameters"; <nl> +			r = -EINVAL; <nl>  			goto bad; <nl>  		} <nl>  
@@ -144,7 +144,7 @@ void ceph_osdc_release_request(struct kref *kref) <nl>  		     req->r_pages, req->r_con_filling_msg); <nl>  		ceph_con_revoke_message(req->r_con_filling_msg, <nl>  				      req->r_reply); <nl> -		ceph_con_put(req->r_con_filling_msg); <nl> +		req->r_con_filling_msg->ops->put(req->r_con_filling_msg); <nl>  	} <nl>  	if (req->r_reply) <nl>  		ceph_msg_put(req->r_reply); <nl> @@ -1216,7 +1216,7 @@ static void handle_reply(struct ceph_osd_client *osdc, struct ceph_msg *msg, <nl>  	if (req->r_con_filling_msg == con && req->r_reply == msg) { <nl>  		dout(" dropping con_filling_msg ref %p\n", con); <nl>  		req->r_con_filling_msg = NULL; <nl> -		ceph_con_put(con); <nl> +		con->ops->put(con); <nl>  	} <nl>   <nl>  	if (!req->r_got_reply) { <nl> @@ -2028,7 +2028,7 @@ static struct ceph_msg *get_reply(struct ceph_connection *con, <nl>  		dout("get_reply revoking msg %p from old con %p\n", <nl>  		     req->r_reply, req->r_con_filling_msg); <nl>  		ceph_con_revoke_message(req->r_con_filling_msg, req->r_reply); <nl> -		ceph_con_put(req->r_con_filling_msg); <nl> +		req->r_con_filling_msg->ops->put(req->r_con_filling_msg); <nl>  		req->r_con_filling_msg = NULL; <nl>  	} <nl>   <nl> @@ -2063,7 +2063,7 @@ static struct ceph_msg *get_reply(struct ceph_connection *con, <nl>  #endif <nl>  	} <nl>  	*skip = 0; <nl> -	req->r_con_filling_msg = ceph_con_get(con); <nl> +	req->r_con_filling_msg = con->ops->get(con); <nl>  	dout("get_reply tid %lld %p\n", tid, m); <nl>   <nl>  out:
@@ -456,6 +456,9 @@ static int qat_hal_init_esram(struct icp_qat_fw_loader_handle *handle) <nl>  	unsigned int csr_val; <nl>  	int times = 30; <nl>   <nl> +	if (handle->pci_dev->device == ADF_C3XXX_PCI_DEVICE_ID) <nl> +		return 0; <nl> + <nl>  	csr_val = ADF_CSR_RD(csr_addr, 0); <nl>  	if ((csr_val & ESRAM_AUTO_TINIT) && (csr_val & ESRAM_AUTO_TINIT_DONE)) <nl>  		return 0;
@@ -2083,6 +2083,7 @@ static int __devinit w83627ehf_probe(struct platform_device *pdev) <nl>  	mutex_init(&data->lock); <nl>  	mutex_init(&data->update_lock); <nl>  	data->name = w83627ehf_device_names[sio_data->kind]; <nl> +	data->bank = 0xff;		/* Force initial bank selection */ <nl>  	platform_set_drvdata(pdev, data); <nl>   <nl>  	/* 627EHG and 627EHF have 10 voltage inputs; 627DHG and 667HG have 9 */
@@ -487,6 +487,9 @@ omap2_mcspi_txrx_pio(struct spi_device *spi, struct spi_transfer *xfer) <nl>  	rx_reg		= base + OMAP2_MCSPI_RX0; <nl>  	chstat_reg	= base + OMAP2_MCSPI_CHSTAT0; <nl>   <nl> +	if (c < (word_len>>3)) <nl> +		return 0; <nl> + <nl>  	if (word_len <= 8) { <nl>  		u8		*rx; <nl>  		const u8	*tx; <nl> @@ -534,7 +537,7 @@ omap2_mcspi_txrx_pio(struct spi_device *spi, struct spi_transfer *xfer) <nl>  				dev_vdbg(&spi->dev, "read-%d %02x\n", <nl>  						word_len, *(rx - 1)); <nl>  			} <nl> -		} while (c); <nl> +		} while (c > (word_len>>3)); <nl>  	} else if (word_len <= 16) { <nl>  		u16		*rx; <nl>  		const u16	*tx; <nl> @@ -581,7 +584,7 @@ omap2_mcspi_txrx_pio(struct spi_device *spi, struct spi_transfer *xfer) <nl>  				dev_vdbg(&spi->dev, "read-%d %04x\n", <nl>  						word_len, *(rx - 1)); <nl>  			} <nl> -		} while (c); <nl> +		} while (c > (word_len>>3)); <nl>  	} else if (word_len <= 32) { <nl>  		u32		*rx; <nl>  		const u32	*tx; <nl> @@ -628,7 +631,7 @@ omap2_mcspi_txrx_pio(struct spi_device *spi, struct spi_transfer *xfer) <nl>  				dev_vdbg(&spi->dev, "read-%d %08x\n", <nl>  						word_len, *(rx - 1)); <nl>  			} <nl> -		} while (c); <nl> +		} while (c > (word_len>>3)); <nl>  	} <nl>   <nl>  	/* for TX_ONLY mode, be sure all words have shifted out */
@@ -1521,16 +1521,14 @@ rcu_start_gp(struct rcu_state *rsp, unsigned long flags) <nl>  		raw_spin_unlock_irqrestore(&rnp->lock, flags); <nl>  		return; <nl>  	} <nl> - <nl>  	rsp->gp_flags = RCU_GP_FLAG_INIT; <nl> -	raw_spin_unlock(&rnp->lock); /* Interrupts remain disabled. */ <nl>   <nl>  	/* Ensure that CPU is aware of completion of last grace period. */ <nl> -	rcu_process_gp_end(rsp, rdp); <nl> -	local_irq_restore(flags); <nl> +	__rcu_process_gp_end(rsp, rdp->mynode, rdp); <nl>   <nl>  	/* Wake up rcu_gp_kthread() to start the grace period. */ <nl>  	wake_up(&rsp->gp_wq); <nl> +	raw_spin_unlock_irqrestore(&rnp->lock, flags); <nl>  } <nl>   <nl>  /*
@@ -3974,11 +3974,15 @@ static int gfx_v8_0_cp_gfx_start(struct amdgpu_device *adev) <nl>  		amdgpu_ring_write(ring, 0x3a00161a); <nl>  		amdgpu_ring_write(ring, 0x0000002e); <nl>  		break; <nl> -	case CHIP_TOPAZ: <nl>  	case CHIP_CARRIZO: <nl>  		amdgpu_ring_write(ring, 0x00000002); <nl>  		amdgpu_ring_write(ring, 0x00000000); <nl>  		break; <nl> +	case CHIP_TOPAZ: <nl> +		amdgpu_ring_write(ring, adev->gfx.config.num_rbs == 1 ? <nl> +				0x00000000 : 0x00000002); <nl> +		amdgpu_ring_write(ring, 0x00000000); <nl> +		break; <nl>  	case CHIP_STONEY: <nl>  		amdgpu_ring_write(ring, 0x00000000); <nl>  		amdgpu_ring_write(ring, 0x00000000);
@@ -1506,6 +1506,8 @@ static int r820t_signal(struct dvb_frontend *fe, u16 *strength) <nl>   <nl>  		/* A higher gain at LNA means a lower signal strength */ <nl>  		*strength = (45 - rc) << 4 | 0xff; <nl> +		if (*strength == 0xff) <nl> +			*strength = 0; <nl>  	} else { <nl>  		*strength = 0; <nl>  	}
@@ -870,7 +870,7 @@ static int mtk_poll_rx(struct napi_struct *napi, int budget, <nl>  		/* receive data */ <nl>  		skb = build_skb(data, ring->frag_size); <nl>  		if (unlikely(!skb)) { <nl> -			put_page(virt_to_head_page(new_data)); <nl> +			skb_free_frag(new_data); <nl>  			netdev->stats.rx_dropped++; <nl>  			goto release_desc; <nl>  		}
@@ -155,7 +155,7 @@ static void gfs2_write_super(struct super_block *sb) <nl>  static int gfs2_sync_fs(struct super_block *sb, int wait) <nl>  { <nl>  	sb->s_dirt = 0; <nl> -	if (wait) <nl> +	if (wait && sb->s_fs_info) <nl>  		gfs2_log_flush(sb->s_fs_info, NULL); <nl>  	return 0; <nl>  }
@@ -1608,7 +1608,7 @@ static void fc_exch_rrq_resp(struct fc_seq *sp, struct fc_frame *fp, void *arg) <nl>  	if (IS_ERR(fp)) { <nl>  		int err = PTR_ERR(fp); <nl>   <nl> -		if (err == -FC_EX_CLOSED) <nl> +		if (err == -FC_EX_CLOSED || err == -FC_EX_TIMEOUT) <nl>  			goto cleanup; <nl>  		FC_DBG("Cannot process RRQ, because of frame error %d\n", err); <nl>  		return;
@@ -779,7 +779,7 @@ int kvm_vcpu_ioctl_config_tlb(struct kvm_vcpu *vcpu, <nl>   <nl>  	num_pages = DIV_ROUND_UP(cfg->array + array_len - 1, PAGE_SIZE) - <nl>  		    cfg->array / PAGE_SIZE; <nl> -	pages = kmalloc(sizeof(struct page *) * num_pages, GFP_KERNEL); <nl> +	pages = kmalloc_array(num_pages, sizeof(*pages), GFP_KERNEL); <nl>  	if (!pages) <nl>  		return -ENOMEM; <nl>  
@@ -1408,6 +1408,10 @@ static int f2fs_write_data_pages(struct address_space *mapping, <nl>  			available_free_memory(sbi, DIRTY_DENTS)) <nl>  		goto skip_write; <nl>   <nl> +	/* during POR, we don't need to trigger writepage at all. */ <nl> +	if (unlikely(is_sbi_flag_set(sbi, SBI_POR_DOING))) <nl> +		goto skip_write; <nl> + <nl>  	diff = nr_pages_to_write(sbi, DATA, wbc); <nl>   <nl>  	if (!S_ISDIR(inode->i_mode)) {
@@ -323,6 +323,7 @@ static struct vmap_area *alloc_vmap_area(unsigned long size, <nl>  	unsigned long addr; <nl>  	int purged = 0; <nl>   <nl> +	BUG_ON(!size); <nl>  	BUG_ON(size & ~PAGE_MASK); <nl>   <nl>  	va = kmalloc_node(sizeof(struct vmap_area), <nl> @@ -334,6 +335,9 @@ retry: <nl>  	addr = ALIGN(vstart, align); <nl>   <nl>  	spin_lock(&vmap_area_lock); <nl> +	if (addr + size - 1 < addr) <nl> +		goto overflow; <nl> + <nl>  	/* XXX: could have a last_hole cache */ <nl>  	n = vmap_area_root.rb_node; <nl>  	if (n) { <nl> @@ -365,6 +369,8 @@ retry: <nl>   <nl>  		while (addr + size > first->va_start && addr + size <= vend) { <nl>  			addr = ALIGN(first->va_end + PAGE_SIZE, align); <nl> +			if (addr + size - 1 < addr) <nl> +				goto overflow; <nl>   <nl>  			n = rb_next(&first->rb_node); <nl>  			if (n) <nl> @@ -375,6 +381,7 @@ retry: <nl>  	} <nl>  found: <nl>  	if (addr + size > vend) { <nl> +overflow: <nl>  		spin_unlock(&vmap_area_lock); <nl>  		if (!purged) { <nl>  			purge_vmap_area_lazy();
@@ -1296,11 +1296,15 @@ static int set_ssp(struct sock *sk, struct hci_dev *hdev, void *data, u16 len) <nl>  { <nl>  	struct mgmt_mode *cp = data; <nl>  	struct pending_cmd *cmd; <nl> -	u8 val; <nl> +	u8 val, status; <nl>  	int err; <nl>   <nl>  	BT_DBG("request for %s", hdev->name); <nl>   <nl> +	status = mgmt_bredr_support(hdev); <nl> +	if (status) <nl> +		return cmd_status(sk, hdev->id, MGMT_OP_SET_SSP, status); <nl> + <nl>  	if (!lmp_ssp_capable(hdev)) <nl>  		return cmd_status(sk, hdev->id, MGMT_OP_SET_SSP, <nl>  				  MGMT_STATUS_NOT_SUPPORTED);
@@ -62,10 +62,14 @@ static void <nl>  activate_substream(struct snd_usb_caiaqdev *dev, <nl>  	           struct snd_pcm_substream *sub) <nl>  { <nl> +	spin_lock(&dev->spinlock); <nl> + <nl>  	if (sub->stream == SNDRV_PCM_STREAM_PLAYBACK) <nl>  		dev->sub_playback[sub->number] = sub; <nl>  	else <nl>  		dev->sub_capture[sub->number] = sub; <nl> + <nl> +	spin_unlock(&dev->spinlock); <nl>  } <nl>   <nl>  static void
@@ -433,8 +433,9 @@ static int corgi_bl_update_status(struct backlight_device *bd) <nl>   <nl>  	if (corgibl_flags & CORGIBL_SUSPENDED) <nl>  		intensity = 0; <nl> -	if (corgibl_flags & CORGIBL_BATTLOW) <nl> -		intensity &= lcd->limit_mask; <nl> + <nl> +	if ((corgibl_flags & CORGIBL_BATTLOW) && intensity > lcd->limit_mask) <nl> +		intensity = lcd->limit_mask; <nl>   <nl>  	return corgi_bl_set_intensity(lcd, intensity); <nl>  }
@@ -1551,7 +1551,7 @@ int dmar_set_interrupt(struct intel_iommu *iommu) <nl>  		return 0; <nl>   <nl>  	irq = create_irq(); <nl> -	if (!irq) { <nl> +	if (irq <= 0) { <nl>  		pr_err("IOMMU: no free vectors\n"); <nl>  		return -EINVAL; <nl>  	}
@@ -698,6 +698,14 @@ static void uvc_set_le_value(struct uvc_control_mapping *mapping, <nl>  	int offset = mapping->offset; <nl>  	__u8 mask; <nl>   <nl> +	/* According to the v4l2 spec, writing any value to a button control <nl> +	 * should result in the action belonging to the button control being <nl> +	 * triggered. UVC devices however want to see a 1 written -> override <nl> +	 * value. <nl> +	 */ <nl> +	if (mapping->v4l2_type == V4L2_CTRL_TYPE_BUTTON) <nl> +		value = -1; <nl> + <nl>  	data += offset / 8; <nl>  	offset &= 7; <nl>  
@@ -222,8 +222,10 @@ static int p9_mux_poll_start(struct p9_conn *m) <nl>  	} <nl>   <nl>  	if (i >= ARRAY_SIZE(p9_mux_poll_tasks)) { <nl> -		if (vptlast == NULL) <nl> +		if (vptlast == NULL) { <nl> +			mutex_unlock(&p9_mux_task_lock); <nl>  			return -ENOMEM; <nl> +		} <nl>   <nl>  		P9_DPRINTK(P9_DEBUG_MUX, "put in proc %d\n", i); <nl>  		list_add(&m->mux_list, &vptlast->mux_list);
@@ -3243,9 +3243,9 @@ int i915_ggtt_init_hw(struct drm_i915_private *dev_priv) <nl>  	 * shrink the range used by drm_mm. <nl>  	 */ <nl>  	mutex_lock(&dev_priv->drm.struct_mutex); <nl> -	ggtt->base.total -= PAGE_SIZE; <nl> +	ggtt->base.total -= I915_GTT_PAGE_SIZE; <nl>  	i915_address_space_init(&ggtt->base, dev_priv, "[global]"); <nl> -	ggtt->base.total += PAGE_SIZE; <nl> +	ggtt->base.total += I915_GTT_PAGE_SIZE; <nl>  	if (!HAS_LLC(dev_priv)) <nl>  		ggtt->base.mm.color_adjust = i915_gtt_color_adjust; <nl>  	mutex_unlock(&dev_priv->drm.struct_mutex);
@@ -1170,6 +1170,7 @@ void blk_mq_delay_queue(struct blk_mq_hw_ctx *hctx, unsigned long msecs) <nl>  	if (unlikely(!blk_mq_hw_queue_mapped(hctx))) <nl>  		return; <nl>   <nl> +	blk_mq_stop_hw_queue(hctx); <nl>  	kblockd_schedule_delayed_work_on(blk_mq_hctx_next_cpu(hctx), <nl>  			&hctx->delay_work, msecs_to_jiffies(msecs)); <nl>  }
@@ -370,7 +370,7 @@ static irqreturn_t interrupt_pcl816(int irq, void *d) <nl>  	} <nl>   <nl>  	outb(0, dev->iobase + PCL816_CLRINT);	/* clear INT request */ <nl> -	if (!dev->irq || !devpriv->ai_cmd_running || !devpriv->int816_mode) { <nl> +	if (!devpriv->ai_cmd_running || !devpriv->int816_mode) { <nl>  		if (devpriv->irq_was_now_closed) { <nl>  			devpriv->irq_was_now_closed = 0; <nl>  			/*  comedi_error(dev,"last IRQ.."); */
@@ -1077,6 +1077,7 @@ err_out_unregister: <nl>   <nl>  err_unlock_policy: <nl>  	unlock_policy_rwsem_write(cpu); <nl> +	free_cpumask_var(policy->related_cpus); <nl>  err_free_cpumask: <nl>  	free_cpumask_var(policy->cpus); <nl>  err_free_policy:
@@ -822,8 +822,8 @@ loff_t mem_lseek(struct file *file, loff_t offset, int orig) <nl>  static int mem_release(struct inode *inode, struct file *file) <nl>  { <nl>  	struct mm_struct *mm = file->private_data; <nl> - <nl> -	mmput(mm); <nl> +	if (mm) <nl> +		mmput(mm); <nl>  	return 0; <nl>  } <nl>  
@@ -543,9 +543,11 @@ static int i915_audio_component_bind(struct device *i915_dev, <nl>  	if (WARN_ON(acomp->ops || acomp->dev)) <nl>  		return -EEXIST; <nl>   <nl> +	drm_modeset_lock_all(dev_priv->dev); <nl>  	acomp->ops = &i915_audio_component_ops; <nl>  	acomp->dev = i915_dev; <nl>  	dev_priv->audio_component = acomp; <nl> +	drm_modeset_unlock_all(dev_priv->dev); <nl>   <nl>  	return 0; <nl>  } <nl> @@ -556,9 +558,11 @@ static void i915_audio_component_unbind(struct device *i915_dev, <nl>  	struct i915_audio_component *acomp = data; <nl>  	struct drm_i915_private *dev_priv = dev_to_i915(i915_dev); <nl>   <nl> +	drm_modeset_lock_all(dev_priv->dev); <nl>  	acomp->ops = NULL; <nl>  	acomp->dev = NULL; <nl>  	dev_priv->audio_component = NULL; <nl> +	drm_modeset_unlock_all(dev_priv->dev); <nl>  } <nl>   <nl>  static const struct component_ops i915_audio_component_bind_ops = {
@@ -697,6 +697,7 @@ static void __copy_skb_header(struct sk_buff *new, const struct sk_buff *old) <nl>  	new->transport_header	= old->transport_header; <nl>  	new->network_header	= old->network_header; <nl>  	new->mac_header		= old->mac_header; <nl> +	new->inner_protocol	= old->inner_protocol; <nl>  	new->inner_transport_header = old->inner_transport_header; <nl>  	new->inner_network_header = old->inner_network_header; <nl>  	new->inner_mac_header = old->inner_mac_header;
@@ -577,6 +577,13 @@ static void ath_beacon_config_sta(struct ath_softc *sc, <nl>  	u64 tsf; <nl>  	int num_beacons, offset, dtim_dec_count, cfp_dec_count; <nl>   <nl> +	/* No need to configure beacon if we are not associated */ <nl> +	if (!common->curaid) { <nl> +		ath_print(common, ATH_DBG_BEACON, <nl> +			 "STA is not yet associated..skipping beacon config\n"); <nl> +		return; <nl> +	} <nl> + <nl>  	memset(&bs, 0, sizeof(bs)); <nl>  	intval = conf->beacon_interval & ATH9K_BEACON_PERIOD; <nl>   <nl> @@ -739,7 +746,6 @@ void ath_beacon_config(struct ath_softc *sc, struct ieee80211_vif *vif) <nl>  	enum nl80211_iftype iftype; <nl>   <nl>  	/* Setup the beacon configuration parameters */ <nl> - <nl>  	if (vif) { <nl>  		struct ieee80211_bss_conf *bss_conf = &vif->bss_conf; <nl>  
@@ -31,10 +31,15 @@ <nl>  #include <linux/init.h> <nl>  #include <linux/delay.h> <nl>  #include <linux/slab.h> <nl> +#include <linux/moduleparam.h> <nl>  #include <sound/core.h> <nl>  #include "hda_codec.h" <nl>  #include "hda_local.h" <nl>   <nl> +static bool static_hdmi_pcm; <nl> +module_param(static_hdmi_pcm, bool, 0644); <nl> +MODULE_PARM_DESC(static_hdmi_pcm, "Don't restrict PCM parameters per ELD info"); <nl> + <nl>  /* <nl>   * The HDMI/DisplayPort configuration can be highly dynamic. A graphics device <nl>   * could support two independent pipes, each of them can be connected to one or <nl> @@ -827,7 +832,7 @@ static int hdmi_pcm_open(struct hda_pcm_stream *hinfo, <nl>  		*codec_pars = *hinfo; <nl>   <nl>  	eld = &spec->sink_eld[idx]; <nl> -	if (eld->eld_valid && eld->sad_count > 0) { <nl> +	if (!static_hdmi_pcm && eld->eld_valid && eld->sad_count > 0) { <nl>  		hdmi_eld_update_pcm_info(eld, hinfo, codec_pars); <nl>  		if (hinfo->channels_min > hinfo->channels_max || <nl>  		    !hinfo->rates || !hinfo->formats)
@@ -161,9 +161,11 @@ EXPORT_SYMBOL(clk_add_alias); <nl>   */ <nl>  void clkdev_drop(struct clk_lookup *cl) <nl>  { <nl> +	struct clk_lookup_alloc *cla = container_of(cl, struct clk_lookup_alloc, cl); <nl> + <nl>  	mutex_lock(&clocks_mutex); <nl>  	list_del(&cl->node); <nl>  	mutex_unlock(&clocks_mutex); <nl> -	kfree(cl); <nl> +	kfree(cla); <nl>  } <nl>  EXPORT_SYMBOL(clkdev_drop);
@@ -320,7 +320,7 @@ static int lm3630_backlight_register(struct lm3630_chip_data *pchip, <nl>  		    backlight_device_register(name, pchip->dev, pchip, <nl>  					      &lm3630_bank_a_ops, &props); <nl>  		if (IS_ERR(pchip->bled1)) <nl> -			return -EIO; <nl> +			return PTR_ERR(pchip->bled1); <nl>  		break; <nl>  	case BLED_2: <nl>  		props.brightness = pdata->init_brt_led2; <nl> @@ -329,7 +329,7 @@ static int lm3630_backlight_register(struct lm3630_chip_data *pchip, <nl>  		    backlight_device_register(name, pchip->dev, pchip, <nl>  					      &lm3630_bank_b_ops, &props); <nl>  		if (IS_ERR(pchip->bled2)) <nl> -			return -EIO; <nl> +			return PTR_ERR(pchip->bled2); <nl>  		break; <nl>  	} <nl>  	return 0;
@@ -1569,6 +1569,11 @@ static int bq2415x_probe(struct i2c_client *client, <nl>  		acpi_id = <nl>  			acpi_match_device(client->dev.driver->acpi_match_table, <nl>  					  &client->dev); <nl> +		if (!acpi_id) { <nl> +			dev_err(&client->dev, "failed to match device name\n"); <nl> +			ret = -ENODEV; <nl> +			goto error_1; <nl> +		} <nl>  		name = kasprintf(GFP_KERNEL, "%s-%d", acpi_id->id, num); <nl>  	} <nl>  	if (!name) {
@@ -113,6 +113,11 @@ int iwl_eeprom_check_sku(struct iwl_priv *priv) <nl>  	if (!priv->cfg->sku) { <nl>  		/* not using sku overwrite */ <nl>  		priv->cfg->sku = iwl_eeprom_query16(priv, EEPROM_SKU_CAP); <nl> +		if (priv->cfg->sku & EEPROM_SKU_CAP_11N_ENABLE && <nl> +		    !priv->cfg->ht_params) { <nl> +			IWL_ERR(priv, "Invalid 11n configuration\n"); <nl> +			return -EINVAL; <nl> +		} <nl>  	} <nl>  	if (!priv->cfg->sku) { <nl>  		IWL_ERR(priv, "Invalid device sku\n");
@@ -378,6 +378,8 @@ static int malidp_bind(struct device *dev) <nl>  	if (ret < 0) <nl>  		goto irq_init_fail; <nl>   <nl> +	drm->irq_enabled = true; <nl> + <nl>  	ret = drm_vblank_init(drm, drm->mode_config.num_crtc); <nl>  	if (ret < 0) { <nl>  		DRM_ERROR("failed to initialise vblank\n"); <nl> @@ -403,6 +405,7 @@ fbdev_fail: <nl>  vblank_fail: <nl>  	malidp_se_irq_fini(drm); <nl>  	malidp_de_irq_fini(drm); <nl> +	drm->irq_enabled = false; <nl>  irq_init_fail: <nl>  	component_unbind_all(dev, drm); <nl>  bind_fail:
@@ -2082,6 +2082,9 @@ new_slab: <nl>  		stat(s, ALLOC_SLAB); <nl>  		c->node = page_to_nid(page); <nl>  		c->page = page; <nl> + <nl> +		if (kmem_cache_debug(s)) <nl> +			goto debug; <nl>  		goto load_freelist; <nl>  	} <nl>  	if (!(gfpflags & __GFP_NOWARN) && printk_ratelimit())
@@ -45,6 +45,9 @@ static int blkpg_ioctl(struct block_device *bdev, struct blkpg_ioctl_arg __user <nl>  				    || pstart < 0 || plength < 0 || partno > 65535) <nl>  					return -EINVAL; <nl>  			} <nl> +			/* check if partition is aligned to blocksize */ <nl> +			if (p.start & (bdev_logical_block_size(bdev) - 1)) <nl> +				return -EINVAL; <nl>   <nl>  			mutex_lock(&bdev->bd_mutex); <nl>  
@@ -528,7 +528,7 @@ affs_remount(struct super_block *sb, int *flags, char *data) <nl>  	char			*prefix = NULL; <nl>   <nl>  	new_opts = kstrdup(data, GFP_KERNEL); <nl> -	if (!new_opts) <nl> +	if (data && !new_opts) <nl>  		return -ENOMEM; <nl>   <nl>  	pr_debug("%s(flags=0x%x,opts=\"%s\")\n", __func__, *flags, data); <nl> @@ -546,7 +546,8 @@ affs_remount(struct super_block *sb, int *flags, char *data) <nl>  	} <nl>   <nl>  	flush_delayed_work(&sbi->sb_work); <nl> -	replace_mount_options(sb, new_opts); <nl> +	if (new_opts) <nl> +		replace_mount_options(sb, new_opts); <nl>   <nl>  	sbi->s_flags = mount_flags; <nl>  	sbi->s_mode  = mode;
@@ -63,6 +63,12 @@ static int sanitize_enable_ppgtt(struct drm_device *dev, int enable_ppgtt) <nl>  	} <nl>  #endif <nl>   <nl> +	/* Early VLV doesn't have this */ <nl> +	if (IS_VALLEYVIEW(dev) && dev->pdev->revision < 0xb) { <nl> +		DRM_DEBUG_DRIVER("disabling PPGTT on pre-B3 step VLV\n"); <nl> +		return 0; <nl> +	} <nl> + <nl>  	return HAS_ALIASING_PPGTT(dev) ? 1 : 0; <nl>  } <nl>  
@@ -1461,14 +1461,16 @@ static int init_sub_crq_irqs(struct ibmvnic_adapter *adapter) <nl>  	return rc; <nl>   <nl>  req_rx_irq_failed: <nl> -	for (j = 0; j < i; j++) <nl> +	for (j = 0; j < i; j++) { <nl>  		free_irq(adapter->rx_scrq[j]->irq, adapter->rx_scrq[j]); <nl>  		irq_dispose_mapping(adapter->rx_scrq[j]->irq); <nl> +	} <nl>  	i = adapter->req_tx_queues; <nl>  req_tx_irq_failed: <nl> -	for (j = 0; j < i; j++) <nl> +	for (j = 0; j < i; j++) { <nl>  		free_irq(adapter->tx_scrq[j]->irq, adapter->tx_scrq[j]); <nl>  		irq_dispose_mapping(adapter->rx_scrq[j]->irq); <nl> +	} <nl>  	release_sub_crqs_no_irqs(adapter); <nl>  	return rc; <nl>  }
@@ -909,6 +909,7 @@ static noinline size_t if_nlmsg_size(const struct net_device *dev, <nl>  	       + rtnl_link_get_af_size(dev, ext_filter_mask) /* IFLA_AF_SPEC */ <nl>  	       + nla_total_size(MAX_PHYS_ITEM_ID_LEN) /* IFLA_PHYS_PORT_ID */ <nl>  	       + nla_total_size(MAX_PHYS_ITEM_ID_LEN) /* IFLA_PHYS_SWITCH_ID */ <nl> +	       + nla_total_size(IFNAMSIZ) /* IFLA_PHYS_PORT_NAME */ <nl>  	       + nla_total_size(1); /* IFLA_PROTO_DOWN */ <nl>   <nl>  }
@@ -944,7 +944,7 @@ static bool have_cpu_die(void) <nl>  #ifdef CONFIG_HOTPLUG_CPU <nl>  	int any_cpu = raw_smp_processor_id(); <nl>   <nl> -	if (cpu_ops[any_cpu]->cpu_die) <nl> +	if (cpu_ops[any_cpu] && cpu_ops[any_cpu]->cpu_die) <nl>  		return true; <nl>  #endif <nl>  	return false;
@@ -189,7 +189,7 @@ static void radeon_cs_parser_fini(struct radeon_cs_parser *parser, int error) <nl>  { <nl>  	unsigned i; <nl>   <nl> -	if (error) { <nl> +	if (error && parser->ib) { <nl>  		radeon_bo_list_unvalidate(&parser->validated, <nl>  						parser->ib->fence); <nl>  	} else {
@@ -493,6 +493,8 @@ static int dest_name_check(struct sockaddr_tipc *dest, struct msghdr *m) <nl>  	if (likely(dest->addr.name.name.type != TIPC_CFG_SRV)) <nl>  		return -EACCES; <nl>   <nl> +	if (!m->msg_iovlen || (m->msg_iov[0].iov_len < sizeof(hdr))) <nl> +		return -EMSGSIZE; <nl>  	if (copy_from_user(&hdr, m->msg_iov[0].iov_base, sizeof(hdr))) <nl>  		return -EFAULT; <nl>  	if ((ntohs(hdr.tcm_type) & 0xC000) && (!capable(CAP_NET_ADMIN)))
@@ -766,10 +766,9 @@ int uncached_readdir(nfs_readdir_descriptor_t *desc, void *dirent, <nl>  	desc->page_index = 0; <nl>  	desc->page = page; <nl>   <nl> -	if (nfs_readdir_xdr_to_array(desc, page, inode) == -1) { <nl> -		status = -EIO; <nl> +	status = nfs_readdir_xdr_to_array(desc, page, inode); <nl> +	if (status < 0) <nl>  		goto out_release; <nl> -	} <nl>   <nl>  	status = nfs_do_filldir(desc, dirent, filldir); <nl>  
@@ -767,7 +767,7 @@ qla24xx_pci_config(scsi_qla_host_t *vha) <nl>   <nl>  	/* PCIe -- adjust Maximum Read Request Size (2048). */ <nl>  	if (pci_is_pcie(ha->pdev)) <nl> -		pcie_set_readrq(ha->pdev, 2048); <nl> +		pcie_set_readrq(ha->pdev, 4096); <nl>   <nl>  	pci_disable_rom(ha->pdev); <nl>   <nl> @@ -803,7 +803,7 @@ qla25xx_pci_config(scsi_qla_host_t *vha) <nl>   <nl>  	/* PCIe -- adjust Maximum Read Request Size (2048). */ <nl>  	if (pci_is_pcie(ha->pdev)) <nl> -		pcie_set_readrq(ha->pdev, 2048); <nl> +		pcie_set_readrq(ha->pdev, 4096); <nl>   <nl>  	pci_disable_rom(ha->pdev); <nl>  
@@ -98,6 +98,15 @@ int arch_decode_instruction(struct elf *elf, struct section *sec, <nl>  			*type = INSN_FP_SETUP; <nl>  		break; <nl>   <nl> +	case 0x8d: <nl> +		if (insn.rex_prefix.bytes && <nl> +		    insn.rex_prefix.bytes[0] == 0x48 && <nl> +		    insn.modrm.nbytes && insn.modrm.bytes[0] == 0x2c && <nl> +		    insn.sib.nbytes && insn.sib.bytes[0] == 0x24) <nl> +			/* lea %(rsp), %rbp */ <nl> +			*type = INSN_FP_SETUP; <nl> +		break; <nl> + <nl>  	case 0x90: <nl>  		*type = INSN_NOP; <nl>  		break;
@@ -1750,7 +1750,7 @@ netdev_tx_t ieee80211_subif_start_xmit(struct sk_buff *skb, <nl>  	__le16 fc; <nl>  	struct ieee80211_hdr hdr; <nl>  	struct ieee80211s_hdr mesh_hdr __maybe_unused; <nl> -	struct mesh_path *mppath = NULL; <nl> +	struct mesh_path __maybe_unused *mppath = NULL; <nl>  	const u8 *encaps_data; <nl>  	int encaps_len, skip_header_bytes; <nl>  	int nh_pos, h_pos;
@@ -1200,7 +1200,7 @@ static struct ip_conntrack_expect *find_expect(struct ip_conntrack *ct, <nl>  	tuple.dst.protonum = IPPROTO_TCP; <nl>   <nl>  	exp = __ip_conntrack_expect_find(&tuple); <nl> -	if (exp->master == ct) <nl> +	if (exp && exp->master == ct) <nl>  		return exp; <nl>  	return NULL; <nl>  }
@@ -210,7 +210,7 @@ out: <nl>  static int si476x_codec_probe(struct snd_soc_codec *codec) <nl>  { <nl>  	codec->control_data = dev_get_regmap(codec->dev->parent, NULL); <nl> -	return 0; <nl> +	return snd_soc_codec_set_cache_io(codec, 0, 0, SND_SOC_REGMAP); <nl>  } <nl>   <nl>  static struct snd_soc_dai_ops si476x_dai_ops = {
@@ -299,7 +299,7 @@ void __init create_boot_cache(struct kmem_cache *s, const char *name, size_t siz <nl>  	err = __kmem_cache_create(s, flags); <nl>   <nl>  	if (err) <nl> -		panic("Creation of kmalloc slab %s size=%zd failed. Reason %d\n", <nl> +		panic("Creation of kmalloc slab %s size=%zu failed. Reason %d\n", <nl>  					name, size, err); <nl>   <nl>  	s->refcount = -1;	/* Exempt from merging for now */
@@ -6017,7 +6017,8 @@ static ssize_t dgap_driver_pollrate_show(struct device_driver *ddp, char *buf) <nl>   <nl>  static ssize_t dgap_driver_pollrate_store(struct device_driver *ddp, const char *buf, size_t count) <nl>  { <nl> -	sscanf(buf, "%d\n", &dgap_poll_tick); <nl> +	if (sscanf(buf, "%d\n", &dgap_poll_tick) != 1) <nl> +		return -EINVAL; <nl>  	return count; <nl>  } <nl>  static DRIVER_ATTR(pollrate, (S_IRUSR | S_IWUSR), dgap_driver_pollrate_show, dgap_driver_pollrate_store);
@@ -422,7 +422,7 @@ struct sctp_cookie { <nl>  	__u32 adaptation_ind; <nl>   <nl>  	__u8 auth_random[sizeof(sctp_paramhdr_t) + SCTP_AUTH_RANDOM_LENGTH]; <nl> -	__u8 auth_hmacs[SCTP_AUTH_NUM_HMACS + 2]; <nl> +	__u8 auth_hmacs[SCTP_AUTH_NUM_HMACS * sizeof(__u16) + 2]; <nl>  	__u8 auth_chunks[sizeof(sctp_paramhdr_t) + SCTP_AUTH_MAX_CHUNKS]; <nl>   <nl>  	/* This is a shim for my peer's INIT packet, followed by
@@ -1854,6 +1854,7 @@ static int __block_prepare_write(struct inode *inode, struct page *page, <nl>  			clear_buffer_new(bh); <nl>  			kaddr = kmap_atomic(page, KM_USER0); <nl>  			memset(kaddr+block_start, 0, bh->b_size); <nl> +			flush_dcache_page(page); <nl>  			kunmap_atomic(kaddr, KM_USER0); <nl>  			set_buffer_uptodate(bh); <nl>  			mark_buffer_dirty(bh); <nl> @@ -2360,6 +2361,7 @@ failed: <nl>  	 */ <nl>  	kaddr = kmap_atomic(page, KM_USER0); <nl>  	memset(kaddr, 0, PAGE_CACHE_SIZE); <nl> +	flush_dcache_page(page); <nl>  	kunmap_atomic(kaddr, KM_USER0); <nl>  	SetPageUptodate(page); <nl>  	set_page_dirty(page);
@@ -1004,8 +1004,12 @@ static int sierra_resume(struct usb_serial *serial) <nl>  			if (err < 0) { <nl>  				intfdata->in_flight--; <nl>  				usb_unanchor_urb(urb); <nl> -				usb_scuttle_anchored_urbs(&portdata->delayed); <nl> -				break; <nl> +				kfree(urb->transfer_buffer); <nl> +				usb_free_urb(urb); <nl> +				spin_lock(&portdata->lock); <nl> +				portdata->outstanding_urbs--; <nl> +				spin_unlock(&portdata->lock); <nl> +				continue; <nl>  			} <nl>  		} <nl>  
@@ -1149,7 +1149,6 @@ static void skl_wrpll_try_divider(struct skl_wrpll_context *ctx, <nl>  		ctx->dco_freq = dco_freq; <nl>  		ctx->p = divider; <nl>  	} <nl> - <nl>  } <nl>   <nl>  static void skl_wrpll_get_multipliers(unsigned int p, <nl> @@ -1315,9 +1314,17 @@ skl_ddi_calculate_wrpll(int clock /* in Hz */, <nl>  						      dco_central_freq[dco], <nl>  						      dco_freq, <nl>  						      p); <nl> +				/* <nl> +				 * Skip the remaining dividers if we're sure to <nl> +				 * have found the definitive divider, we can't <nl> +				 * improve a 0 deviation. <nl> +				 */ <nl> +				if (ctx.min_deviation == 0) <nl> +					goto skip_remaining_dividers; <nl>  			} <nl>  		} <nl>   <nl> +skip_remaining_dividers: <nl>  		/* <nl>  		 * If a solution is found with an even divider, prefer <nl>  		 * this one.
@@ -124,18 +124,18 @@ static int ati_create_gatt_pages(int nr_tables) <nl>  	for (i = 0; i < nr_tables; i++) { <nl>  		entry = kzalloc(sizeof(struct ati_page_map), GFP_KERNEL); <nl>  		if (entry == NULL) { <nl> -			while (i>0) { <nl> -				kfree (tables[i-1]); <nl> +			while (i > 0) { <nl> +				kfree(tables[i-1]); <nl>  				i--; <nl>  			} <nl> -			kfree (tables); <nl> -			tables = NULL; <nl> +			kfree(tables); <nl>  			retval = -ENOMEM; <nl>  			break; <nl>  		} <nl>  		tables[i] = entry; <nl>  		retval = ati_create_page_map(entry); <nl> -		if (retval != 0) break; <nl> +		if (retval != 0) <nl> +			break; <nl>  	} <nl>  	ati_generic_private.num_tables = nr_tables; <nl>  	ati_generic_private.gatt_pages = tables;
@@ -708,11 +708,12 @@ static void __init opal_irq_init(struct device_node *dn) <nl>   <nl>  	/* Get interrupt property */ <nl>  	irqs = of_get_property(opal_node, "opal-interrupts", &irqlen); <nl> -	pr_debug("Found %d interrupts reserved for OPAL\n", <nl> -		 irqs ? (irqlen / 4) : 0); <nl> +	opal_irq_count = irqs ? (irqlen / 4) : 0; <nl> +	pr_debug("Found %d interrupts reserved for OPAL\n", opal_irq_count); <nl> +	if (!opal_irq_count) <nl> +		return; <nl>   <nl>  	/* Install interrupt handlers */ <nl> -	opal_irq_count = irqlen / 4; <nl>  	opal_irqs = kzalloc(opal_irq_count * sizeof(unsigned int), GFP_KERNEL); <nl>  	for (i = 0; irqs && i < opal_irq_count; i++, irqs++) { <nl>  		unsigned int irq, virq;
@@ -70,6 +70,7 @@ void perf_evsel__config(struct perf_evsel *evsel, struct perf_record_opts *opts, <nl>  	struct perf_event_attr *attr = &evsel->attr; <nl>  	int track = !evsel->idx; /* only the first counter needs these */ <nl>   <nl> +	attr->disabled = 1; <nl>  	attr->sample_id_all = opts->sample_id_all_missing ? 0 : 1; <nl>  	attr->inherit	    = !opts->no_inherit; <nl>  	attr->read_format   = PERF_FORMAT_TOTAL_TIME_ENABLED | <nl> @@ -138,7 +139,6 @@ void perf_evsel__config(struct perf_evsel *evsel, struct perf_record_opts *opts, <nl>   <nl>  	if (perf_target__none(&opts->target) && <nl>  	    (!opts->group || evsel == first)) { <nl> -		attr->disabled = 1; <nl>  		attr->enable_on_exec = 1; <nl>  	} <nl>  }
@@ -442,8 +442,10 @@ static int xenbus_write_transaction(unsigned msg_type, <nl>  		return xenbus_command_reply(u, XS_ERROR, "ENOENT"); <nl>   <nl>  	rc = xenbus_dev_request_and_reply(&u->u.msg, u); <nl> -	if (rc) <nl> +	if (rc && trans) { <nl> +		list_del(&trans->list); <nl>  		kfree(trans); <nl> +	} <nl>   <nl>  out: <nl>  	return rc;
@@ -2661,6 +2661,10 @@ static int ext4_mb_init_per_dev_proc(struct super_block *sb) <nl>  	struct proc_dir_entry *proc; <nl>  	char devname[64]; <nl>   <nl> +	if (proc_root_ext4 == NULL) { <nl> +		sbi->s_mb_proc = NULL; <nl> +		return -EINVAL; <nl> +	} <nl>  	bdevname(sb->s_bdev, devname); <nl>  	sbi->s_mb_proc = proc_mkdir(devname, proc_root_ext4); <nl>  
@@ -472,7 +472,7 @@ static const struct comedi_lrange *dac_range_table[] = { <nl>   <nl>  static const struct comedi_lrange *dac_range_lkup(int opt) <nl>  { <nl> -	if (opt < 0 || opt > 5) <nl> +	if (opt < 0 || opt >= 5) <nl>  		return &range_unknown; <nl>  	return dac_range_table[opt]; <nl>  }
@@ -764,6 +764,7 @@ static int mtk_pmx_gpio_request_enable(struct pinctrl_dev *pctldev, <nl>  	} <nl>   <nl>  	mtk_pmx_set_mode(pctldev, offset, muxval); <nl> +	mtk_pconf_set_ies_smt(pctl, offset, 1, PIN_CONFIG_INPUT_ENABLE); <nl>   <nl>  	return 0; <nl>  }
@@ -404,7 +404,7 @@ static void path_rec_completion(int status, <nl>  	struct net_device *dev = path->dev; <nl>  	struct ipoib_dev_priv *priv = netdev_priv(dev); <nl>  	struct ipoib_ah *ah = NULL; <nl> -	struct ipoib_ah *old_ah; <nl> +	struct ipoib_ah *old_ah = NULL; <nl>  	struct ipoib_neigh *neigh, *tn; <nl>  	struct sk_buff_head skqueue; <nl>  	struct sk_buff *skb; <nl> @@ -428,12 +428,12 @@ static void path_rec_completion(int status, <nl>   <nl>  	spin_lock_irqsave(&priv->lock, flags); <nl>   <nl> -	old_ah   = path->ah; <nl> -	path->ah = ah; <nl> - <nl>  	if (ah) { <nl>  		path->pathrec = *pathrec; <nl>   <nl> +		old_ah   = path->ah; <nl> +		path->ah = ah; <nl> + <nl>  		ipoib_dbg(priv, "created address handle %p for LID 0x%04x, SL %d\n", <nl>  			  ah, be16_to_cpu(pathrec->dlid), pathrec->sl); <nl>  
@@ -594,10 +594,7 @@ static int bq24257_power_supply_init(struct bq24257_device *bq) <nl>  						 &bq24257_power_supply_desc, <nl>  						 &psy_cfg); <nl>   <nl> -	if (IS_ERR(bq->charger)) <nl> -		return PTR_ERR(bq->charger); <nl> - <nl> -	return 0; <nl> +	return PTR_ERR_OR_ZERO(bq->charger); <nl>  } <nl>   <nl>  static int bq24257_pg_gpio_probe(struct bq24257_device *bq)
@@ -131,9 +131,9 @@ static int __init gt641xx_timer0_clockevent_init(void) <nl>   <nl>  	cd = &gt641xx_timer0_clockevent; <nl>  	cd->rating = 200 + gt641xx_base_clock / 10000000; <nl> +	clockevent_set_clock(cd, gt641xx_base_clock); <nl>  	cd->max_delta_ns = clockevent_delta2ns(0x7fffffff, cd); <nl>  	cd->min_delta_ns = clockevent_delta2ns(0x300, cd); <nl> -	clockevent_set_clock(cd, gt641xx_base_clock); <nl>   <nl>  	clockevents_register_device(&gt641xx_timer0_clockevent); <nl>  
@@ -3196,7 +3196,7 @@ zoran_do_ioctl (struct inode *inode, <nl>  			"%s: VIDIOC_QUERYBUF - index=%d, type=%d\n", <nl>  			ZR_DEVNAME(zr), buf->index, buf->type); <nl>   <nl> -		memset(buf, 0, sizeof(buf)); <nl> +		memset(buf, 0, sizeof(*buf)); <nl>  		buf->type = type; <nl>  		buf->index = index; <nl>  
@@ -213,7 +213,7 @@ int btrfs_check_trunc_cache_free_space(struct btrfs_root *root, <nl>  	else <nl>  		ret = 0; <nl>  	spin_unlock(&rsv->lock); <nl> -	return 0; <nl> +	return ret; <nl>  } <nl>   <nl>  int btrfs_truncate_free_space_cache(struct btrfs_root *root,
@@ -225,9 +225,9 @@ snd_emux_load_patch_seq_oss(struct snd_seq_oss_arg *arg, int format, <nl>  	else if (format == SNDRV_OSS_SOUNDFONT_PATCH) { <nl>  		struct soundfont_patch_info patch; <nl>  		if (count < (int)sizeof(patch)) <nl> -			rc = -EINVAL; <nl> +			return -EINVAL; <nl>  		if (copy_from_user(&patch, buf, sizeof(patch))) <nl> -			rc = -EFAULT; <nl> +			return -EFAULT; <nl>  		if (patch.type >= SNDRV_SFNT_LOAD_INFO && <nl>  		    patch.type <= SNDRV_SFNT_PROBE_DATA) <nl>  			rc = snd_soundfont_load(emu->sflist, buf, count, SF_CLIENT_NO(p->chset.port));
@@ -116,7 +116,7 @@ static int _sp2d_alloc(unsigned pages_in_unit, unsigned group_width, <nl>  			num_a1pa = min_t(unsigned, PAGE_SIZE / sizeof__a1pa, <nl>  							pages_in_unit - i); <nl>   <nl> -			__a1pa = kzalloc(num_a1pa * sizeof__a1pa, GFP_KERNEL); <nl> +			__a1pa = kcalloc(num_a1pa, sizeof__a1pa, GFP_KERNEL); <nl>  			if (unlikely(!__a1pa)) { <nl>  				ORE_DBGMSG("!! Failed to _alloc_1p_arrays=%d\n", <nl>  					   num_a1pa);
@@ -450,5 +450,5 @@ static struct comedi_driver pcl726_driver = { <nl>  module_comedi_driver(pcl726_driver); <nl>   <nl>  MODULE_AUTHOR("Comedi http://www.comedi.org"); <nl> -MODULE_DESCRIPTION("Comedi low-level driver"); <nl> +MODULE_DESCRIPTION("Comedi driver for Advantech PCL-726 & compatibles"); <nl>  MODULE_LICENSE("GPL");
@@ -797,7 +797,7 @@ static int gb_camera_op_configure_streams(void *priv, unsigned int *nstreams, <nl>  	if (gb_nstreams > GB_CAMERA_MAX_STREAMS) <nl>  		return -EINVAL; <nl>   <nl> -	gb_streams = kzalloc(gb_nstreams * sizeof(*gb_streams), GFP_KERNEL); <nl> +	gb_streams = kcalloc(gb_nstreams, sizeof(*gb_streams), GFP_KERNEL); <nl>  	if (!gb_streams) <nl>  		return -ENOMEM; <nl>   <nl> @@ -938,7 +938,7 @@ static ssize_t gb_camera_debugfs_configure_streams(struct gb_camera *gcam, <nl>  		return ret; <nl>   <nl>  	/* For each stream to configure parse width, height and format */ <nl> -	streams = kzalloc(nstreams * sizeof(*streams), GFP_KERNEL); <nl> +	streams = kcalloc(nstreams, sizeof(*streams), GFP_KERNEL); <nl>  	if (!streams) <nl>  		return -ENOMEM; <nl>  
@@ -142,10 +142,10 @@ static int omap_mcbsp_dai_startup(struct snd_pcm_substream *substream, <nl>  		* smaller buffer than the FIFO size to avoid underruns <nl>  		*/ <nl>  		snd_pcm_hw_rule_add(substream->runtime, 0, <nl> -				    SNDRV_PCM_HW_PARAM_CHANNELS, <nl> +				    SNDRV_PCM_HW_PARAM_BUFFER_SIZE, <nl>  				    omap_mcbsp_hwrule_min_buffersize, <nl>  				    mcbsp, <nl> -				    SNDRV_PCM_HW_PARAM_BUFFER_SIZE, -1); <nl> +				    SNDRV_PCM_HW_PARAM_CHANNELS, -1); <nl>   <nl>  		/* Make sure, that the period size is always even */ <nl>  		snd_pcm_hw_constraint_step(substream->runtime, 0,
@@ -333,8 +333,6 @@ static int pcan_usb_pro_send_req(struct peak_usb_device *dev, int req_id, <nl>  	if (!(dev->state & PCAN_USB_STATE_CONNECTED)) <nl>  		return 0; <nl>   <nl> -	memset(req_addr, '\0', req_size); <nl> - <nl>  	req_type = USB_TYPE_VENDOR | USB_RECIP_OTHER; <nl>   <nl>  	switch (req_id) { <nl> @@ -345,6 +343,7 @@ static int pcan_usb_pro_send_req(struct peak_usb_device *dev, int req_id, <nl>  	default: <nl>  		p = usb_rcvctrlpipe(dev->udev, 0); <nl>  		req_type |= USB_DIR_IN; <nl> +		memset(req_addr, '\0', req_size); <nl>  		break; <nl>  	} <nl>  
@@ -1391,6 +1391,7 @@ static void discard_cap_releases(struct ceph_mds_client *mdsc, <nl>  	num = le32_to_cpu(head->num); <nl>  	dout("discard_cap_releases mds%d %p %u\n", session->s_mds, msg, num); <nl>  	head->num = cpu_to_le32(0); <nl> +	msg->front.iov_len = sizeof(*head); <nl>  	session->s_num_cap_releases += num; <nl>   <nl>  	/* requeue completed messages */
@@ -4243,13 +4243,13 @@ static int iwl4965_pci_probe(struct pci_dev *pdev, const struct pci_device_id *e <nl>   <nl>  	pci_set_master(pdev); <nl>   <nl> -	err = pci_set_dma_mask(pdev, DMA_64BIT_MASK); <nl> +	err = pci_set_dma_mask(pdev, DMA_BIT_MASK(36)); <nl>  	if (!err) <nl> -		err = pci_set_consistent_dma_mask(pdev, DMA_64BIT_MASK); <nl> +		err = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(36)); <nl>  	if (err) { <nl> -		err = pci_set_dma_mask(pdev, DMA_32BIT_MASK); <nl> +		err = pci_set_dma_mask(pdev, DMA_BIT_MASK(32)); <nl>  		if (!err) <nl> -			err = pci_set_consistent_dma_mask(pdev, DMA_32BIT_MASK); <nl> +			err = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32)); <nl>  		/* both attempts failed: */ <nl>  		if (err) { <nl>  			printk(KERN_WARNING "%s: No suitable DMA available.\n",
@@ -4025,13 +4025,12 @@ static int sysfs_slab_add(struct kmem_cache *s) <nl>  		name = create_unique_id(s); <nl>  	} <nl>   <nl> -	kobject_set_name(&s->kobj, name); <nl>  	s->kobj.kset = slab_kset; <nl> -	s->kobj.ktype = &slab_ktype; <nl> -	kobject_init(&s->kobj); <nl> -	err = kobject_add(&s->kobj); <nl> -	if (err) <nl> +	err = kobject_init_and_add(&s->kobj, &slab_ktype, NULL, name); <nl> +	if (err) { <nl> +		kobject_put(&s->kobj); <nl>  		return err; <nl> +	} <nl>   <nl>  	err = sysfs_create_group(&s->kobj, &slab_attr_group); <nl>  	if (err)
@@ -59,6 +59,12 @@ static int nft_range_init(const struct nft_ctx *ctx, const struct nft_expr *expr <nl>  	int err; <nl>  	u32 op; <nl>   <nl> +	if (!tb[NFTA_RANGE_SREG]      || <nl> +	    !tb[NFTA_RANGE_OP]	      || <nl> +	    !tb[NFTA_RANGE_FROM_DATA] || <nl> +	    !tb[NFTA_RANGE_TO_DATA]) <nl> +		return -EINVAL; <nl> + <nl>  	err = nft_data_init(NULL, &priv->data_from, sizeof(priv->data_from), <nl>  			    &desc_from, tb[NFTA_RANGE_FROM_DATA]); <nl>  	if (err < 0)
@@ -258,7 +258,7 @@ EXPORT_SYMBOL_GPL(omap_dm_timer_enable); <nl>   <nl>  void omap_dm_timer_disable(struct omap_dm_timer *timer) <nl>  { <nl> -	pm_runtime_put(&timer->pdev->dev); <nl> +	pm_runtime_put_sync(&timer->pdev->dev); <nl>  } <nl>  EXPORT_SYMBOL_GPL(omap_dm_timer_disable); <nl>  
@@ -797,6 +797,8 @@ static ssize_t macvtap_put_user(struct macvtap_queue *q, <nl>  		if (copy_to_iter(&vnet_hdr, sizeof(vnet_hdr), iter) != <nl>  		    sizeof(vnet_hdr)) <nl>  			return -EFAULT; <nl> + <nl> +		iov_iter_advance(iter, vnet_hdr_len - sizeof(vnet_hdr)); <nl>  	} <nl>  	total = vnet_hdr_len; <nl>  	total += skb->len;
@@ -69,7 +69,7 @@ static struct resource wdt_sch_resource = { <nl>   <nl>  static struct mfd_cell tunnelcreek_cells[] = { <nl>  	{ <nl> -		.name = "tunnelcreek_wdt", <nl> +		.name = "ie6xx_wdt", <nl>  		.num_resources = 1, <nl>  		.resources = &wdt_sch_resource, <nl>  	},
@@ -1519,6 +1519,9 @@ int snd_hda_codec_reset(struct hda_codec *codec) <nl>  	codec->num_pcms = 0; <nl>  	codec->pcm_info = NULL; <nl>  	codec->preset = NULL; <nl> +	memset(&codec->patch_ops, 0, sizeof(codec->patch_ops)); <nl> +	codec->slave_dig_outs = NULL; <nl> +	codec->spdif_status_reset = 0; <nl>  	module_put(codec->owner); <nl>  	codec->owner = NULL; <nl>  
@@ -1268,6 +1268,7 @@ static int si_common_early_init(void *handle) <nl>  			AMD_CG_SUPPORT_HDP_LS | <nl>  			AMD_CG_SUPPORT_HDP_MGCG; <nl>  		adev->pg_flags = 0; <nl> +		adev->external_rev_id = 60; <nl>  		break; <nl>  	case CHIP_HAINAN: <nl>  		adev->cg_flags =
@@ -274,7 +274,7 @@ int walk_system_ram_range(unsigned long start_pfn, unsigned long nr_pages, <nl>  		void *arg, int (*func)(unsigned long, unsigned long, void *)) <nl>  { <nl>  	struct resource res; <nl> -	unsigned long pfn, len; <nl> +	unsigned long pfn, end_pfn; <nl>  	u64 orig_end; <nl>  	int ret = -1; <nl>   <nl> @@ -284,9 +284,10 @@ int walk_system_ram_range(unsigned long start_pfn, unsigned long nr_pages, <nl>  	orig_end = res.end; <nl>  	while ((res.start < res.end) && <nl>  		(find_next_system_ram(&res, "System RAM") >= 0)) { <nl> -		pfn = (unsigned long)(res.start >> PAGE_SHIFT); <nl> -		len = (unsigned long)((res.end + 1 - res.start) >> PAGE_SHIFT); <nl> -		ret = (*func)(pfn, len, arg); <nl> +		pfn = (res.start + PAGE_SIZE - 1) >> PAGE_SHIFT; <nl> +		end_pfn = (res.end + 1) >> PAGE_SHIFT; <nl> +		if (end_pfn > pfn) <nl> +		    ret = (*func)(pfn, end_pfn - pfn, arg); <nl>  		if (ret) <nl>  			break; <nl>  		res.start = res.end + 1;
@@ -782,6 +782,14 @@ tda998x_encoder_mode_set(struct drm_encoder *encoder, <nl>  	de_pix_s     = mode->htotal - mode->hdisplay; <nl>  	ref_pix      = 3 + hs_pix_s; <nl>   <nl> +	/* <nl> +	 * Attached LCD controllers may generate broken sync. Allow <nl> +	 * those to adjust the position of the rising VS edge by adding <nl> +	 * HSKEW to ref_pix. <nl> +	 */ <nl> +	if (adjusted_mode->flags & DRM_MODE_FLAG_HSKEW) <nl> +		ref_pix += adjusted_mode->hskew; <nl> + <nl>  	if ((mode->flags & DRM_MODE_FLAG_INTERLACE) == 0) { <nl>  		ref_line     = 1 + mode->vsync_start - mode->vdisplay; <nl>  		vwin1_line_s = mode->vtotal - mode->vdisplay - 1;
@@ -687,9 +687,10 @@ int sirfsoc_uart_probe(struct platform_device *pdev) <nl>   <nl>  	if (sirfport->hw_flow_ctrl) { <nl>  		sirfport->p = pinctrl_get_select_default(&pdev->dev); <nl> -		ret = IS_ERR(sirfport->p); <nl> -		if (ret) <nl> +		if (IS_ERR(sirfport->p)) { <nl> +			ret = PTR_ERR(sirfport->p); <nl>  			goto err; <nl> +		} <nl>  	} <nl>   <nl>  	sirfport->clk = clk_get(&pdev->dev, NULL);
@@ -816,7 +816,7 @@ static int pk_probe(struct hid_device *hdev, const struct hid_device_id *id) <nl>  	if (pm == NULL) { <nl>  		hid_err(hdev, "can't alloc descriptor\n"); <nl>  		ret = -ENOMEM; <nl> -		goto err_free; <nl> +		goto err_free_pk; <nl>  	} <nl>   <nl>  	pm->pk = pk; <nl> @@ -849,10 +849,10 @@ static int pk_probe(struct hid_device *hdev, const struct hid_device_id *id) <nl>  err_stop: <nl>  	hid_hw_stop(hdev); <nl>  err_free: <nl> -	if (pm != NULL) <nl> -		kfree(pm); <nl> - <nl> +	kfree(pm); <nl> +err_free_pk: <nl>  	kfree(pk); <nl> + <nl>  	return ret; <nl>  } <nl>  
@@ -142,11 +142,11 @@ static void ntp_update_offset(long offset) <nl>  	 * Select how the frequency is to be controlled <nl>  	 * and in which mode (PLL or FLL). <nl>  	 */ <nl> -	secs = xtime.tv_sec - time_reftime; <nl> +	secs = get_seconds() - time_reftime; <nl>  	if (unlikely(time_status & STA_FREQHOLD)) <nl>  		secs = 0; <nl>   <nl> -	time_reftime = xtime.tv_sec; <nl> +	time_reftime = get_seconds(); <nl>   <nl>  	offset64    = offset; <nl>  	freq_adj    = (offset64 * secs) << <nl> @@ -368,7 +368,7 @@ static inline void process_adj_status(struct timex *txc, struct timespec *ts) <nl>  	 * reference time to current time. <nl>  	 */ <nl>  	if (!(time_status & STA_PLL) && (txc->status & STA_PLL)) <nl> -		time_reftime = xtime.tv_sec; <nl> +		time_reftime = get_seconds(); <nl>   <nl>  	/* only set allowed bits */ <nl>  	time_status &= STA_RONLY;
@@ -3355,6 +3355,9 @@ static int mwifiex_cfg80211_resume(struct wiphy *wiphy) <nl>  		} <nl>  	} <nl>   <nl> +	if (!wiphy->wowlan_config) <nl> +		goto done; <nl> + <nl>  	priv = mwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_STA); <nl>  	mwifiex_get_wakeup_reason(priv, HostCmd_ACT_GEN_GET, MWIFIEX_SYNC_CMD, <nl>  				  &wakeup_reason); <nl> @@ -3400,6 +3403,7 @@ static int mwifiex_cfg80211_resume(struct wiphy *wiphy) <nl>  		cfg80211_report_wowlan_wakeup(&priv->wdev, &wakeup_report, <nl>  					      GFP_KERNEL); <nl>   <nl> +done: <nl>  	if (adapter->nd_info) { <nl>  		for (i = 0 ; i < adapter->nd_info->n_matches ; i++) <nl>  			kfree(adapter->nd_info->matches[i]);
@@ -401,10 +401,6 @@ extern void intel_enable_clock_gating(struct drm_device *dev); <nl>  extern void ironlake_disable_rc6(struct drm_device *dev); <nl>  extern void ironlake_enable_drps(struct drm_device *dev); <nl>  extern void ironlake_disable_drps(struct drm_device *dev); <nl> -extern void gen6_enable_rps(struct drm_i915_private *dev_priv); <nl> -extern void gen6_update_ring_freq(struct drm_i915_private *dev_priv); <nl> -extern void gen6_disable_rps(struct drm_device *dev); <nl> -extern void intel_init_emon(struct drm_device *dev); <nl>   <nl>  extern int intel_pin_and_fence_fb_obj(struct drm_device *dev, <nl>  				      struct drm_i915_gem_object *obj, <nl> @@ -466,4 +462,9 @@ extern void intel_update_fbc(struct drm_device *dev); <nl>  extern void intel_gpu_ips_init(struct drm_i915_private *dev_priv); <nl>  extern void intel_gpu_ips_teardown(void); <nl>   <nl> +extern void gen6_enable_rps(struct drm_i915_private *dev_priv); <nl> +extern void gen6_update_ring_freq(struct drm_i915_private *dev_priv); <nl> +extern void gen6_disable_rps(struct drm_device *dev); <nl> +extern void intel_init_emon(struct drm_device *dev); <nl> + <nl>  #endif /* __INTEL_DRV_H__ */
@@ -1388,6 +1388,7 @@ static int et131x_phy_mii_read(struct et131x_adapter *adapter, u8 addr, <nl>  			    mii_indicator); <nl>   <nl>  		status = -EIO; <nl> +		goto out; <nl>  	} <nl>   <nl>  	/* If we hit here we were able to read the register and we need to <nl> @@ -1395,6 +1396,7 @@ static int et131x_phy_mii_read(struct et131x_adapter *adapter, u8 addr, <nl>  	 */ <nl>  	*value = readl(&mac->mii_mgmt_stat) & ET_MAC_MIIMGMT_STAT_PHYCRTL_MASK; <nl>   <nl> +out: <nl>  	/* Stop the read operation */ <nl>  	writel(0, &mac->mii_mgmt_cmd); <nl>  
@@ -500,6 +500,7 @@ static void sas_revalidate_domain(struct work_struct *work) <nl>  	struct sas_discovery_event *ev = to_sas_discovery_event(work); <nl>  	struct asd_sas_port *port = ev->port; <nl>  	struct sas_ha_struct *ha = port->ha; <nl> +	struct domain_device *ddev = port->port_dev; <nl>   <nl>  	/* prevent revalidation from finding sata links in recovery */ <nl>  	mutex_lock(&ha->disco_mutex); <nl> @@ -514,8 +515,9 @@ static void sas_revalidate_domain(struct work_struct *work) <nl>  	SAS_DPRINTK("REVALIDATING DOMAIN on port %d, pid:%d\n", port->id, <nl>  		    task_pid_nr(current)); <nl>   <nl> -	if (port->port_dev) <nl> -		res = sas_ex_revalidate_domain(port->port_dev); <nl> +	if (ddev && (ddev->dev_type == SAS_FANOUT_EXPANDER_DEVICE || <nl> +		     ddev->dev_type == SAS_EDGE_EXPANDER_DEVICE)) <nl> +		res = sas_ex_revalidate_domain(ddev); <nl>   <nl>  	SAS_DPRINTK("done REVALIDATING DOMAIN on port %d, pid:%d, res 0x%x\n", <nl>  		    port->id, task_pid_nr(current), res);
@@ -2417,8 +2417,10 @@ static void security_netlbl_cache_add(struct netlbl_lsm_secattr *secattr, <nl>   <nl>  	cache->type = NETLBL_CACHE_T_MLS; <nl>  	if (ebitmap_cpy(&cache->data.mls_label.level[0].cat, <nl> -			&ctx->range.level[0].cat) != 0) <nl> +			&ctx->range.level[0].cat) != 0) { <nl> +		kfree(cache); <nl>  		return; <nl> +	} <nl>  	cache->data.mls_label.level[1].cat.highbit = <nl>  		cache->data.mls_label.level[0].cat.highbit; <nl>  	cache->data.mls_label.level[1].cat.node =
@@ -24,6 +24,12 @@ static int x2apic_acpi_madt_oem_check(char *oem_id, char *oem_table_id) <nl>  { <nl>  	if (x2apic_phys) <nl>  		return x2apic_enabled(); <nl> +	else if ((acpi_gbl_FADT.header.revision >= FADT2_REVISION_ID) && <nl> +		(acpi_gbl_FADT.flags & ACPI_FADT_APIC_PHYSICAL) && <nl> +		x2apic_enabled()) { <nl> +		printk(KERN_DEBUG "System requires x2apic physical mode\n"); <nl> +		return 1; <nl> +	} <nl>  	else <nl>  		return 0; <nl>  }
@@ -966,7 +966,7 @@ void pcmcia_disable_device(struct pcmcia_device *p_dev) { <nl>  	pcmcia_release_configuration(p_dev); <nl>  	pcmcia_release_io(p_dev, &p_dev->io); <nl>  	pcmcia_release_irq(p_dev, &p_dev->irq); <nl> -	if (&p_dev->win) <nl> +	if (p_dev->win) <nl>  		pcmcia_release_window(p_dev->win); <nl>  } <nl>  EXPORT_SYMBOL(pcmcia_disable_device);
@@ -6,7 +6,7 @@ <nl>   * XXX We need to find a better place for these things... <nl>   */ <nl>  bool perf_host  = true; <nl> -bool perf_guest = true; <nl> +bool perf_guest = false; <nl>   <nl>  void event_attr_init(struct perf_event_attr *attr) <nl>  {
@@ -52,6 +52,7 @@ static const struct syscfg_reset_channel_data stih407_powerdowns[] = { <nl>  }; <nl>   <nl>  /* Reset Generator control 0/1 */ <nl> +#define SYSCFG_5128	0x200 <nl>  #define SYSCFG_5131	0x20c <nl>  #define SYSCFG_5132	0x210 <nl>   <nl> @@ -96,6 +97,10 @@ static const struct syscfg_reset_channel_data stih407_softresets[] = { <nl>  	[STIH407_ERAM_HVA_SOFTRESET] = STIH407_SRST_CORE(SYSCFG_5132, 1), <nl>  	[STIH407_LPM_SOFTRESET] = STIH407_SRST_SBC(SYSCFG_4002, 2), <nl>  	[STIH407_KEYSCAN_SOFTRESET] = STIH407_SRST_LPM(LPM_SYSCFG_1, 8), <nl> +	[STIH407_ST231_AUD_SOFTRESET] = STIH407_SRST_CORE(SYSCFG_5131, 26), <nl> +	[STIH407_ST231_DMU_SOFTRESET] = STIH407_SRST_CORE(SYSCFG_5131, 27), <nl> +	[STIH407_ST231_GP0_SOFTRESET] = STIH407_SRST_CORE(SYSCFG_5131, 28), <nl> +	[STIH407_ST231_GP1_SOFTRESET] = STIH407_SRST_CORE(SYSCFG_5128, 2), <nl>  }; <nl>   <nl>  /* PicoPHY reset/control */
@@ -336,7 +336,7 @@ i915_gem_set_tiling(struct drm_device *dev, void *data, <nl>  	} <nl>   <nl>  	mutex_lock(&dev->struct_mutex); <nl> -	if (i915_gem_obj_is_pinned(obj) || obj->framebuffer_references) { <nl> +	if (obj->pin_display || obj->framebuffer_references) { <nl>  		ret = -EBUSY; <nl>  		goto err; <nl>  	}
@@ -2279,7 +2279,9 @@ void wiphy_regulatory_deregister(struct wiphy *wiphy) <nl>  static void reg_timeout_work(struct work_struct *work) <nl>  { <nl>  	REG_DBG_PRINT("Timeout while waiting for CRDA to reply, restoring regulatory settings\n"); <nl> +	rtnl_lock(); <nl>  	restore_regulatory_settings(true); <nl> +	rtnl_unlock(); <nl>  } <nl>   <nl>  int __init regulatory_init(void)
@@ -270,6 +270,8 @@ err_exit: <nl>   <nl>  int aq_ring_rx_fill(struct aq_ring_s *self) <nl>  { <nl> +	unsigned int pages_order = fls(AQ_CFG_RX_FRAME_MAX / PAGE_SIZE + <nl> +		(AQ_CFG_RX_FRAME_MAX % PAGE_SIZE ? 1 : 0)) - 1; <nl>  	struct aq_ring_buff_s *buff = NULL; <nl>  	int err = 0; <nl>  	int i = 0; <nl> @@ -282,7 +284,7 @@ int aq_ring_rx_fill(struct aq_ring_s *self) <nl>  		buff->len = AQ_CFG_RX_FRAME_MAX; <nl>   <nl>  		buff->page = alloc_pages(GFP_ATOMIC | __GFP_COLD | <nl> -					 __GFP_COMP, 0); <nl> +					 __GFP_COMP, pages_order); <nl>  		if (!buff->page) { <nl>  			err = -ENOMEM; <nl>  			goto err_exit;
@@ -434,8 +434,12 @@ static int exec_permission_lite(struct inode *inode) <nl>  { <nl>  	umode_t	mode = inode->i_mode; <nl>   <nl> -	if (inode->i_op->permission) <nl> -		return inode_permission(inode, MAY_EXEC); <nl> +	if (inode->i_op->permission) { <nl> +		int ret = inode->i_op->permission(inode, MAY_EXEC); <nl> +		if (!ret) <nl> +			goto ok; <nl> +		return ret; <nl> +	} <nl>   <nl>  	if (current_fsuid() == inode->i_uid) <nl>  		mode >>= 6;
@@ -229,7 +229,7 @@ static void clk_pllv2_unprepare(struct clk_hw *hw) <nl>  	__raw_writel(reg, pllbase + MXC_PLL_DP_CTL); <nl>  } <nl>   <nl> -struct clk_ops clk_pllv2_ops = { <nl> +static struct clk_ops clk_pllv2_ops = { <nl>  	.prepare = clk_pllv2_prepare, <nl>  	.unprepare = clk_pllv2_unprepare, <nl>  	.recalc_rate = clk_pllv2_recalc_rate,
@@ -20,6 +20,7 @@ <nl>  #include <linux/pci.h> <nl>  #include <linux/acpi.h> <nl>  #include <linux/list.h> <nl> +#include <linux/bitmap.h> <nl>  #include <linux/slab.h> <nl>  #include <linux/syscore_ops.h> <nl>  #include <linux/interrupt.h> <nl> @@ -2285,7 +2286,7 @@ static int __init early_amd_iommu_init(void) <nl>  	 * never allocate domain 0 because its used as the non-allocated and <nl>  	 * error value placeholder <nl>  	 */ <nl> -	amd_iommu_pd_alloc_bitmap[0] = 1; <nl> +	__set_bit(0, amd_iommu_pd_alloc_bitmap); <nl>   <nl>  	spin_lock_init(&amd_iommu_pd_lock); <nl>  
@@ -253,6 +253,13 @@ static inline int phy_set_mode(struct phy *phy, enum phy_mode mode) <nl>  	return -ENOSYS; <nl>  } <nl>   <nl> +static inline int phy_reset(struct phy *phy) <nl> +{ <nl> +	if (!phy) <nl> +		return 0; <nl> +	return -ENOSYS; <nl> +} <nl> + <nl>  static inline int phy_get_bus_width(struct phy *phy) <nl>  { <nl>  	return -ENOSYS;
@@ -281,7 +281,6 @@ static int hdm_add_padding(struct most_dev *mdev, int channel, struct mbo *mbo) <nl>  	struct most_channel_config *conf = &mdev->conf[channel]; <nl>  	unsigned int frame_size = get_stream_frame_size(conf); <nl>  	unsigned int j, num_frames; <nl> -	u16 rd_addr, wr_addr; <nl>   <nl>  	if (!frame_size) <nl>  		return -EIO; <nl> @@ -293,13 +292,10 @@ static int hdm_add_padding(struct most_dev *mdev, int channel, struct mbo *mbo) <nl>  		return -EIO; <nl>  	} <nl>   <nl> -	for (j = 1; j < num_frames; j++) { <nl> -		wr_addr = (num_frames - j) * USB_MTU; <nl> -		rd_addr = (num_frames - j) * frame_size; <nl> -		memmove(mbo->virt_address + wr_addr, <nl> -			mbo->virt_address + rd_addr, <nl> +	for (j = num_frames - 1; j > 0; j--) <nl> +		memmove(mbo->virt_address + j * USB_MTU, <nl> +			mbo->virt_address + j * frame_size, <nl>  			frame_size); <nl> -	} <nl>  	mbo->buffer_length = num_frames * USB_MTU; <nl>  	return 0; <nl>  }
@@ -177,6 +177,7 @@ static void rt6_free_pcpu(struct rt6_info *non_pcpu_rt) <nl>  		} <nl>  	} <nl>   <nl> +	free_percpu(non_pcpu_rt->rt6i_pcpu); <nl>  	non_pcpu_rt->rt6i_pcpu = NULL; <nl>  } <nl>  
@@ -182,7 +182,7 @@ static unsigned int get_max_cost(struct f2fs_sb_info *sbi, <nl>  	if (p->alloc_mode == SSR) <nl>  		return sbi->blocks_per_seg; <nl>  	if (p->gc_mode == GC_GREEDY) <nl> -		return sbi->blocks_per_seg * p->ofs_unit; <nl> +		return 2 * sbi->blocks_per_seg * p->ofs_unit; <nl>  	else if (p->gc_mode == GC_CB) <nl>  		return UINT_MAX; <nl>  	else /* No other gc_mode */
@@ -259,7 +259,7 @@ static int __inode_security_revalidate(struct inode *inode, <nl>   <nl>  	might_sleep_if(may_sleep); <nl>   <nl> -	if (isec->initialized != LABEL_INITIALIZED) { <nl> +	if (ss_initialized && isec->initialized != LABEL_INITIALIZED) { <nl>  		if (!may_sleep) <nl>  			return -ECHILD; <nl>  
@@ -98,7 +98,7 @@ struct avtab_node * <nl>  avtab_insert_nonunique(struct avtab *h, struct avtab_key *key, struct avtab_datum *datum) <nl>  { <nl>  	int hvalue; <nl> -	struct avtab_node *prev, *cur, *newnode; <nl> +	struct avtab_node *prev, *cur; <nl>  	u16 specified = key->specified & ~(AVTAB_ENABLED|AVTAB_ENABLED_OLD); <nl>   <nl>  	if (!h || !h->htable) <nl> @@ -122,9 +122,7 @@ avtab_insert_nonunique(struct avtab *h, struct avtab_key *key, struct avtab_datu <nl>  		    key->target_class < cur->key.target_class) <nl>  			break; <nl>  	} <nl> -	newnode = avtab_insert_node(h, hvalue, prev, cur, key, datum); <nl> - <nl> -	return newnode; <nl> +	return avtab_insert_node(h, hvalue, prev, cur, key, datum); <nl>  } <nl>   <nl>  struct avtab_datum *avtab_search(struct avtab *h, struct avtab_key *key)
@@ -923,7 +923,7 @@ static void tcp_init_metrics(struct sock *sk) <nl>  	} <nl>  	if (dst_metric(dst, RTAX_RTTVAR) > tp->mdev) { <nl>  		tp->mdev = dst_metric(dst, RTAX_RTTVAR); <nl> -		tp->mdev_max = tp->rttvar = max(tp->mdev, TCP_RTO_MIN); <nl> +		tp->mdev_max = tp->rttvar = max(tp->mdev, tcp_rto_min(sk)); <nl>  	} <nl>  	tcp_set_rto(sk); <nl>  	tcp_bound_rto(sk);
@@ -2358,6 +2358,8 @@ deinit: <nl>  		wl1271_free_ap_keys(wl, wlvif); <nl>  	} <nl>   <nl> +	dev_kfree_skb(wlvif->probereq); <nl> +	wlvif->probereq = NULL; <nl>  	wl12xx_tx_reset_wlvif(wl, wlvif); <nl>  	if (wl->last_wlvif == wlvif) <nl>  		wl->last_wlvif = NULL;
@@ -1618,9 +1618,8 @@ ath5k_rx_start(struct ath5k_softc *sc) <nl>  	ATH5K_DBG(sc, ATH5K_DEBUG_RESET, "cachelsz %u rxbufsize %u\n", <nl>  		sc->cachelsz, sc->rxbufsize); <nl>   <nl> -	sc->rxlink = NULL; <nl> - <nl>  	spin_lock_bh(&sc->rxbuflock); <nl> +	sc->rxlink = NULL; <nl>  	list_for_each_entry(bf, &sc->rxbuf, list) { <nl>  		ret = ath5k_rxbuf_setup(sc, bf); <nl>  		if (ret != 0) { <nl> @@ -1629,9 +1628,9 @@ ath5k_rx_start(struct ath5k_softc *sc) <nl>  		} <nl>  	} <nl>  	bf = list_first_entry(&sc->rxbuf, struct ath5k_buf, list); <nl> +	ath5k_hw_set_rxdp(ah, bf->daddr); <nl>  	spin_unlock_bh(&sc->rxbuflock); <nl>   <nl> -	ath5k_hw_set_rxdp(ah, bf->daddr); <nl>  	ath5k_hw_start_rx_dma(ah);	/* enable recv descriptors */ <nl>  	ath5k_mode_setup(sc);		/* set filters, etc. */ <nl>  	ath5k_hw_start_rx_pcu(ah);	/* re-enable PCU/DMA engine */
@@ -102,6 +102,7 @@ struct nfs_client_initdata { <nl>  	size_t addrlen; <nl>  	const struct nfs_rpc_ops *rpc_ops; <nl>  	int proto; <nl> +	u32 minorversion; <nl>  }; <nl>   <nl>  /* <nl> @@ -150,6 +151,7 @@ static struct nfs_client *nfs_alloc_client(const struct nfs_client_initdata *cl_ <nl>  	rpc_init_wait_queue(&clp->cl_rpcwaitq, "NFS client"); <nl>  	clp->cl_boot_time = CURRENT_TIME; <nl>  	clp->cl_state = 1 << NFS4CLNT_LEASE_EXPIRED; <nl> +	clp->cl_minorversion = cl_init->minorversion; <nl>  #endif <nl>  	cred = rpc_lookup_machine_cred(); <nl>  	if (!IS_ERR(cred)) <nl> @@ -420,7 +422,9 @@ static struct nfs_client *nfs_match_client(const struct nfs_client_initdata *dat <nl>   <nl>  		if (clp->cl_proto != data->proto) <nl>  			continue; <nl> - <nl> +		/* Match nfsv4 minorversion */ <nl> +		if (clp->cl_minorversion != data->minorversion) <nl> +			continue; <nl>  		/* Match the full socket address */ <nl>  		if (!nfs_sockaddr_cmp(sap, clap)) <nl>  			continue; <nl> @@ -1110,6 +1114,7 @@ static int nfs4_set_client(struct nfs_server *server, <nl>  		.addrlen = addrlen, <nl>  		.rpc_ops = &nfs_v4_clientops, <nl>  		.proto = proto, <nl> +		.minorversion = minorversion, <nl>  	}; <nl>  	struct nfs_client *clp; <nl>  	int error;
@@ -2240,7 +2240,9 @@ netxen_detach_work(struct work_struct *work) <nl>   <nl>  	netxen_nic_down(adapter, netdev); <nl>   <nl> +	rtnl_lock(); <nl>  	netxen_nic_detach(adapter); <nl> +	rtnl_unlock(); <nl>   <nl>  	status = NXRD32(adapter, NETXEN_PEG_HALT_STATUS1); <nl>  
@@ -971,13 +971,11 @@ int __fatal_signal_pending(struct task_struct *tsk) <nl>  } <nl>  EXPORT_SYMBOL(__fatal_signal_pending); <nl>   <nl> -/* <nl> - * Must be called under rcu_read_lock() or with tasklist_lock read-held. <nl> - */ <nl>  struct sighand_struct *lock_task_sighand(struct task_struct *tsk, unsigned long *flags) <nl>  { <nl>  	struct sighand_struct *sighand; <nl>   <nl> +	rcu_read_lock(); <nl>  	for (;;) { <nl>  		sighand = rcu_dereference(tsk->sighand); <nl>  		if (unlikely(sighand == NULL)) <nl> @@ -988,6 +986,7 @@ struct sighand_struct *lock_task_sighand(struct task_struct *tsk, unsigned long <nl>  			break; <nl>  		spin_unlock_irqrestore(&sighand->siglock, *flags); <nl>  	} <nl> +	rcu_read_unlock(); <nl>   <nl>  	return sighand; <nl>  }
@@ -993,7 +993,7 @@ static irqreturn_t sdhci_irq(int irq, void *dev_id) <nl>   <nl>  	intmask = readl(host->ioaddr + SDHCI_INT_STATUS); <nl>   <nl> -	if (!intmask) { <nl> +	if (!intmask || intmask == 0xffffffff) { <nl>  		result = IRQ_NONE; <nl>  		goto out; <nl>  	}
@@ -53,12 +53,19 @@ gt215_mc_intr[] = { <nl>  	{}, <nl>  }; <nl>   <nl> +static void <nl> +gt215_mc_intr_mask(struct nvkm_mc *mc, u32 mask, u32 stat) <nl> +{ <nl> +	nvkm_mask(mc->subdev.device, 0x000640, mask, stat); <nl> +} <nl> + <nl>  static const struct nvkm_mc_func <nl>  gt215_mc = { <nl>  	.init = nv50_mc_init, <nl>  	.intr = gt215_mc_intr, <nl>  	.intr_unarm = nv04_mc_intr_unarm, <nl>  	.intr_rearm = nv04_mc_intr_rearm, <nl> +	.intr_mask = gt215_mc_intr_mask, <nl>  	.intr_stat = nv04_mc_intr_stat, <nl>  	.reset = gt215_mc_reset, <nl>  };
@@ -580,6 +580,8 @@ int c4iw_register_device(struct c4iw_dev *dev) <nl>  	dev->ibdev.iwcm->add_ref = c4iw_qp_add_ref; <nl>  	dev->ibdev.iwcm->rem_ref = c4iw_qp_rem_ref; <nl>  	dev->ibdev.iwcm->get_qp = c4iw_get_qp; <nl> +	memcpy(dev->ibdev.iwcm->ifname, dev->rdev.lldi.ports[0]->name, <nl> +	       sizeof(dev->ibdev.iwcm->ifname)); <nl>   <nl>  	ret = ib_register_device(&dev->ibdev, NULL); <nl>  	if (ret)
@@ -112,7 +112,7 @@ int mwifiex_process_tx(struct mwifiex_private *priv, struct sk_buff *skb, <nl>   <nl>  	switch (ret) { <nl>  	case -ENOSR: <nl> -		dev_err(adapter->dev, "data: -ENOSR is returned\n"); <nl> +		dev_dbg(adapter->dev, "data: -ENOSR is returned\n"); <nl>  		break; <nl>  	case -EBUSY: <nl>  		if ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA) &&
@@ -211,11 +211,11 @@ struct dnode_of_data { <nl>  static inline void set_new_dnode(struct dnode_of_data *dn, struct inode *inode, <nl>  		struct page *ipage, struct page *npage, nid_t nid) <nl>  { <nl> +	memset(dn, 0, sizeof(*dn)); <nl>  	dn->inode = inode; <nl>  	dn->inode_page = ipage; <nl>  	dn->node_page = npage; <nl>  	dn->nid = nid; <nl> -	dn->inode_page_locked = 0; <nl>  } <nl>   <nl>  /*
@@ -1968,8 +1968,6 @@ static void tpacket_destruct_skb(struct sk_buff *skb) <nl>  	struct packet_sock *po = pkt_sk(skb->sk); <nl>  	void *ph; <nl>   <nl> -	BUG_ON(skb == NULL); <nl> - <nl>  	if (likely(po->tx_ring.pg_vec)) { <nl>  		ph = skb_shinfo(skb)->destructor_arg; <nl>  		BUG_ON(__packet_get_status(po, ph) != TP_STATUS_SENDING);
@@ -266,6 +266,9 @@ intel_dp_mode_valid(struct drm_connector *connector, <nl>  	if (mode->clock < 10000) <nl>  		return MODE_CLOCK_LOW; <nl>   <nl> +	if (mode->flags & DRM_MODE_FLAG_DBLCLK) <nl> +		return MODE_H_ILLEGAL; <nl> + <nl>  	return MODE_OK; <nl>  } <nl>   <nl> @@ -702,6 +705,9 @@ intel_dp_mode_fixup(struct drm_encoder *encoder, struct drm_display_mode *mode, <nl>  		mode->clock = intel_dp->panel_fixed_mode->clock; <nl>  	} <nl>   <nl> +	if (mode->flags & DRM_MODE_FLAG_DBLCLK) <nl> +		return false; <nl> + <nl>  	DRM_DEBUG_KMS("DP link computation with max lane count %i " <nl>  		      "max bw %02x pixel clock %iKHz\n", <nl>  		      max_lane_count, bws[max_clock], mode->clock);
@@ -1130,6 +1130,7 @@ static int cpmac_probe(struct platform_device *pdev) <nl>  		strncpy(mdio_bus_id, "fixed-0", MII_BUS_ID_SIZE); /* fixed phys bus */ <nl>  		phy_id = pdev->id; <nl>  	} <nl> +	mdio_bus_id[sizeof(mdio_bus_id) - 1] = '\0'; <nl>   <nl>  	dev = alloc_etherdev_mq(sizeof(*priv), CPMAC_QUEUES); <nl>  	if (!dev)
@@ -1297,9 +1297,9 @@ int snd_soc_dapm_device_event(struct snd_soc_device *socdev, int event) <nl>  	struct snd_soc_machine *machine = socdev->machine; <nl>   <nl>  	if (machine->dapm_event) <nl> -				machine->dapm_event(machine, event); <nl> +		machine->dapm_event(machine, event); <nl>  	if (codec->dapm_event) <nl> -				codec->dapm_event(codec, event); <nl> +		codec->dapm_event(codec, event); <nl>  	return 0; <nl>  } <nl>  EXPORT_SYMBOL_GPL(snd_soc_dapm_device_event);
@@ -318,8 +318,10 @@ checks: <nl>  	if (offset > si->highest_bit) <nl>  		scan_base = offset = si->lowest_bit; <nl>   <nl> -	/* reuse swap entry of cache-only swap if not busy. */ <nl> -	if (vm_swap_full() && si->swap_map[offset] == SWAP_HAS_CACHE) { <nl> +	/* reuse swap entry of cache-only swap if not hibernation. */ <nl> +	if (vm_swap_full() <nl> +		&& usage == SWAP_HAS_CACHE <nl> +		&& si->swap_map[offset] == SWAP_HAS_CACHE) { <nl>  		int swap_was_freed; <nl>  		spin_unlock(&swap_lock); <nl>  		swap_was_freed = __try_to_reclaim_swap(si, offset);
@@ -72,8 +72,10 @@ static void pic_clear_isr(struct kvm_kpic_state *s, int irq) <nl>  void kvm_pic_clear_isr_ack(struct kvm *kvm) <nl>  { <nl>  	struct kvm_pic *s = pic_irqchip(kvm); <nl> +	pic_lock(s); <nl>  	s->pics[0].isr_ack = 0xff; <nl>  	s->pics[1].isr_ack = 0xff; <nl> +	pic_unlock(s); <nl>  } <nl>   <nl>  /*
@@ -554,7 +554,7 @@ int cvm_oct_xmit_pow(struct sk_buff *skb, struct net_device *dev) <nl>  		printk_ratelimited("%s: Failed to allocate a work queue entry\n", <nl>  				   dev->name); <nl>  		priv->stats.tx_dropped++; <nl> -		dev_kfree_skb(skb); <nl> +		dev_kfree_skb_any(skb); <nl>  		return 0; <nl>  	} <nl>   <nl> @@ -565,7 +565,7 @@ int cvm_oct_xmit_pow(struct sk_buff *skb, struct net_device *dev) <nl>  				   dev->name); <nl>  		cvmx_fpa_free(work, CVMX_FPA_WQE_POOL, DONT_WRITEBACK(1)); <nl>  		priv->stats.tx_dropped++; <nl> -		dev_kfree_skb(skb); <nl> +		dev_kfree_skb_any(skb); <nl>  		return 0; <nl>  	} <nl>   <nl> @@ -682,7 +682,7 @@ int cvm_oct_xmit_pow(struct sk_buff *skb, struct net_device *dev) <nl>  			     work->grp); <nl>  	priv->stats.tx_packets++; <nl>  	priv->stats.tx_bytes += skb->len; <nl> -	dev_kfree_skb(skb); <nl> +	dev_consume_skb_any(skb); <nl>  	return 0; <nl>  } <nl>  
@@ -337,7 +337,7 @@ struct rxrpc_call *rxrpc_new_incoming_call(struct rxrpc_local *local, <nl>   <nl>  	/* Get the socket providing the service */ <nl>  	rx = rcu_dereference(local->service); <nl> -	if (service_id == rx->srx.srx_service) <nl> +	if (rx && service_id == rx->srx.srx_service) <nl>  		goto found_service; <nl>   <nl>  	trace_rxrpc_abort("INV", sp->hdr.cid, sp->hdr.callNumber, sp->hdr.seq,
@@ -604,7 +604,7 @@ int cvmx_usb_initialize(struct cvmx_usb_state *state, int usb_port_number, <nl>  			} <nl>  	} <nl>   <nl> -	memset(usb, 0, sizeof(usb)); <nl> +	memset(usb, 0, sizeof(*usb)); <nl>  	usb->init_flags = flags; <nl>   <nl>  	/* Initialize the USB state structure */
@@ -41,7 +41,8 @@ struct comedi_device *comedi_open(const char *filename) <nl>  	if (strncmp(filename, "/dev/comedi", 11) != 0) <nl>  		return NULL; <nl>   <nl> -	minor = simple_strtoul(filename + 11, NULL, 0); <nl> +	if (kstrtouint(filename + 11, 0, &minor)) <nl> +		return NULL; <nl>   <nl>  	if (minor >= COMEDI_NUM_BOARD_MINORS) <nl>  		return NULL;
@@ -322,11 +322,12 @@ static int gmap_alloc_table(struct gmap *gmap, unsigned long *table, <nl>  static unsigned long __gmap_segment_gaddr(unsigned long *entry) <nl>  { <nl>  	struct page *page; <nl> -	unsigned long offset; <nl> +	unsigned long offset, mask; <nl>   <nl>  	offset = (unsigned long) entry / sizeof(unsigned long); <nl>  	offset = (offset & (PTRS_PER_PMD - 1)) * PMD_SIZE; <nl> -	page = pmd_to_page((pmd_t *) entry); <nl> +	mask = ~(PTRS_PER_PMD * sizeof(pmd_t) - 1); <nl> +	page = virt_to_page((void *)((unsigned long) entry & mask)); <nl>  	return page->index + offset; <nl>  } <nl>  
@@ -753,7 +753,7 @@ int ttm_bo_pipeline_move(struct ttm_buffer_object *bo, <nl>  		 */ <nl>   <nl>  		spin_lock(&from->move_lock); <nl> -		if (!from->move || fence_is_later(from->move, fence)) { <nl> +		if (!from->move || fence_is_later(fence, from->move)) { <nl>  			fence_put(from->move); <nl>  			from->move = fence_get(fence); <nl>  		}
@@ -81,6 +81,9 @@ static u32 gart_unmapped_entry; <nl>  #define AGPEXTERN <nl>  #endif <nl>   <nl> +/* GART can only remap to physical addresses < 1TB */ <nl> +#define GART_MAX_PHYS_ADDR	(1ULL << 40) <nl> + <nl>  /* backdoor interface to AGP driver */ <nl>  AGPEXTERN int agp_memory_reserved; <nl>  AGPEXTERN __u32 *agp_gatt_table; <nl> @@ -212,9 +215,13 @@ static dma_addr_t dma_map_area(struct device *dev, dma_addr_t phys_mem, <nl>  				size_t size, int dir, unsigned long align_mask) <nl>  { <nl>  	unsigned long npages = iommu_num_pages(phys_mem, size, PAGE_SIZE); <nl> -	unsigned long iommu_page = alloc_iommu(dev, npages, align_mask); <nl> +	unsigned long iommu_page; <nl>  	int i; <nl>   <nl> +	if (unlikely(phys_mem + size > GART_MAX_PHYS_ADDR)) <nl> +		return bad_dma_addr; <nl> + <nl> +	iommu_page = alloc_iommu(dev, npages, align_mask); <nl>  	if (iommu_page == -1) { <nl>  		if (!nonforced_iommu(dev, phys_mem, size)) <nl>  			return phys_mem;
@@ -658,8 +658,11 @@ static enum hrtimer_restart dl_task_timer(struct hrtimer *timer) <nl>  	 * <nl>  	 * XXX figure out if select_task_rq_dl() deals with offline cpus. <nl>  	 */ <nl> -	if (unlikely(!rq->online)) <nl> +	if (unlikely(!rq->online)) { <nl> +		lockdep_unpin_lock(&rq->lock, rf.cookie); <nl>  		rq = dl_task_offline_migration(rq, p); <nl> +		rf.cookie = lockdep_pin_lock(&rq->lock); <nl> +	} <nl>   <nl>  	/* <nl>  	 * Queueing this task back might have overloaded rq, check if we need
@@ -651,8 +651,10 @@ void bpf_int_jit_compile(struct bpf_prog *prog) <nl>  	build_prologue(&ctx); <nl>   <nl>  	ctx.body_offset = ctx.idx; <nl> -	if (build_body(&ctx)) <nl> +	if (build_body(&ctx)) { <nl> +		module_free(NULL, ctx.image); <nl>  		goto out; <nl> +	} <nl>   <nl>  	build_epilogue(&ctx); <nl>  
@@ -233,6 +233,10 @@ static void setup_rt_frame(int sig, struct k_sigaction *ka, siginfo_t *info, <nl>   <nl>  	set_fs(USER_DS); <nl>   <nl> +	/* the tracer may want to single-step inside the handler */ <nl> +	if (test_thread_flag(TIF_SINGLESTEP)) <nl> +		ptrace_notify(SIGTRAP); <nl> + <nl>  #ifdef DEBUG_SIG <nl>  	printk(KERN_INFO "SIG deliver (%s:%d): sp=%p pc=%08lx\n", <nl>  		current->comm, current->pid, frame, regs->pc);
@@ -2487,6 +2487,7 @@ int sdhci_suspend_host(struct sdhci_host *host) <nl>  		return ret; <nl>  	} <nl>   <nl> +	sdhci_mask_irqs(host, SDHCI_INT_ALL_MASK); <nl>  	free_irq(host->irq, host); <nl>   <nl>  	return ret; <nl> @@ -3142,6 +3143,7 @@ int sdhci_add_host(struct sdhci_host *host) <nl>  #ifdef SDHCI_USE_LEDS_CLASS <nl>  reset: <nl>  	sdhci_reset(host, SDHCI_RESET_ALL); <nl> +	sdhci_mask_irqs(host, SDHCI_INT_ALL_MASK); <nl>  	free_irq(host->irq, host); <nl>  #endif <nl>  untasklet: <nl> @@ -3184,6 +3186,7 @@ void sdhci_remove_host(struct sdhci_host *host, int dead) <nl>  	if (!dead) <nl>  		sdhci_reset(host, SDHCI_RESET_ALL); <nl>   <nl> +	sdhci_mask_irqs(host, SDHCI_INT_ALL_MASK); <nl>  	free_irq(host->irq, host); <nl>   <nl>  	del_timer_sync(&host->timer);
@@ -1479,6 +1479,9 @@ int kvm_vcpu_ioctl_get_one_reg(struct kvm_vcpu *vcpu, struct kvm_one_reg *reg) <nl>  	case KVM_REG_PPC_DEBUG_INST: <nl>  		val = get_reg_val(reg->id, KVMPPC_INST_EHPRIV); <nl>  		break; <nl> +	case KVM_REG_PPC_VRSAVE: <nl> +		val = get_reg_val(reg->id, vcpu->arch.vrsave); <nl> +		break; <nl>  	default: <nl>  		r = kvmppc_get_one_reg(vcpu, reg->id, &val); <nl>  		break; <nl> @@ -1552,6 +1555,9 @@ int kvm_vcpu_ioctl_set_one_reg(struct kvm_vcpu *vcpu, struct kvm_one_reg *reg) <nl>  		kvmppc_set_tcr(vcpu, tcr); <nl>  		break; <nl>  	} <nl> +	case KVM_REG_PPC_VRSAVE: <nl> +		vcpu->arch.vrsave = set_reg_val(reg->id, val); <nl> +		break; <nl>  	default: <nl>  		r = kvmppc_set_one_reg(vcpu, reg->id, &val); <nl>  		break;
@@ -2990,7 +2990,7 @@ void kvm_mmu_slot_remove_write_access(struct kvm *kvm, int slot) <nl>  		pt = sp->spt; <nl>  		for (i = 0; i < PT64_ENT_PER_PAGE; ++i) <nl>  			/* avoid RMW */ <nl> -			if (pt[i] & PT_WRITABLE_MASK) <nl> +			if (is_writable_pte(pt[i])) <nl>  				pt[i] &= ~PT_WRITABLE_MASK; <nl>  	} <nl>  	kvm_flush_remote_tlbs(kvm); <nl> @@ -3425,7 +3425,7 @@ void inspect_spte_has_rmap(struct kvm *kvm, u64 *sptep) <nl>  	struct kvm_mmu_page *rev_sp; <nl>  	gfn_t gfn; <nl>   <nl> -	if (*sptep & PT_WRITABLE_MASK) { <nl> +	if (is_writable_pte(*sptep)) { <nl>  		rev_sp = page_header(__pa(sptep)); <nl>  		gfn = kvm_mmu_page_get_gfn(rev_sp, sptep - rev_sp->spt); <nl>   <nl> @@ -3474,7 +3474,7 @@ static void check_writable_mappings_rmap(struct kvm_vcpu *vcpu) <nl>   <nl>  			if (!(ent & PT_PRESENT_MASK)) <nl>  				continue; <nl> -			if (!(ent & PT_WRITABLE_MASK)) <nl> +			if (!is_writable_pte(ent)) <nl>  				continue; <nl>  			inspect_spte_has_rmap(vcpu->kvm, &pt[i]); <nl>  		} <nl> @@ -3508,7 +3508,7 @@ static void audit_write_protection(struct kvm_vcpu *vcpu) <nl>   <nl>  		spte = rmap_next(vcpu->kvm, rmapp, NULL); <nl>  		while (spte) { <nl> -			if (*spte & PT_WRITABLE_MASK) <nl> +			if (is_writable_pte(*spte)) <nl>  				printk(KERN_ERR "%s: (%s) shadow page has " <nl>  				"writable mappings: gfn %lx role %x\n", <nl>  			       __func__, audit_msg, sp->gfn,
@@ -549,7 +549,7 @@ static int s3c24xx_eint_init(struct samsung_pinctrl_drv_data *d) <nl>  		irq = bank->eint_offset; <nl>  		mask = bank->eint_mask; <nl>  		for (pin = 0; mask; ++pin, mask >>= 1) { <nl> -			if (irq > NUM_EINT) <nl> +			if (irq >= NUM_EINT) <nl>  				break; <nl>  			if (!(mask & 1)) <nl>  				continue;
@@ -215,7 +215,7 @@ int aix_partition(struct parsed_partitions *state) <nl>  		numlvs = be16_to_cpu(p->numlvs); <nl>  		put_dev_sector(sect); <nl>  	} <nl> -	lvip = kzalloc(sizeof(struct lv_info) * state->limit, GFP_KERNEL); <nl> +	lvip = kcalloc(state->limit, sizeof(struct lv_info), GFP_KERNEL); <nl>  	if (!lvip) <nl>  		return 0; <nl>  	if (numlvs && (d = read_part_sector(state, vgda_sector + 1, &sect))) {
@@ -64,7 +64,7 @@ <nl>  		     ::"a" (rw) : "memory") <nl>   <nl>  #define __build_write_lock_const(rw, helper) \ <nl> -	asm volatile(LOCK "subl $" RW_LOCK_BIAS_STR ",(%0)\n\t" \ <nl> +	asm volatile(LOCK "subl $" RW_LOCK_BIAS_STR ",%0\n\t" \ <nl>  		     "jnz 2f\n" \ <nl>  		     "1:\n" \ <nl>  		    LOCK_SECTION_START("") \
@@ -977,7 +977,10 @@ static void ieee80211_do_stop(struct ieee80211_sub_if_data *sdata, <nl>  	if (sdata->vif.txq) { <nl>  		struct txq_info *txqi = to_txq_info(sdata->vif.txq); <nl>   <nl> +		spin_lock_bh(&txqi->queue.lock); <nl>  		ieee80211_purge_tx_queue(&local->hw, &txqi->queue); <nl> +		spin_unlock_bh(&txqi->queue.lock); <nl> + <nl>  		atomic_set(&sdata->txqs_len[txqi->txq.ac], 0); <nl>  	} <nl>  
@@ -373,9 +373,10 @@ EXPORT_SYMBOL_GPL(of_irq_to_resource); <nl>   */ <nl>  int of_irq_count(struct device_node *dev) <nl>  { <nl> +	struct of_phandle_args irq; <nl>  	int nr = 0; <nl>   <nl> -	while (of_irq_to_resource(dev, nr, NULL)) <nl> +	while (of_irq_parse_one(dev, nr, &irq) == 0) <nl>  		nr++; <nl>   <nl>  	return nr;
@@ -142,6 +142,8 @@ static struct clk *cp110_register_gate(const char *name, <nl>  	if (!gate) <nl>  		return ERR_PTR(-ENOMEM); <nl>   <nl> +	memset(&init, 0, sizeof(init)); <nl> + <nl>  	init.name = name; <nl>  	init.ops = &cp110_gate_ops; <nl>  	init.parent_names = &parent_name;
@@ -509,6 +509,7 @@ int qed_resc_alloc(struct qed_dev *cdev) <nl>  			DP_ERR(p_hwfn, <nl>  			       "Cannot allocate 0x%x EQ elements. The maximum of a u16 chain is 0x%x\n", <nl>  			       n_eqes, 0xFFFF); <nl> +			rc = -EINVAL; <nl>  			goto alloc_err; <nl>  		} <nl>  
@@ -671,14 +671,12 @@ static ssize_t store_scaling_governor(struct cpufreq_policy *policy, <nl>  		return -EINVAL; <nl>   <nl>  	ret = cpufreq_set_policy(policy, &new_policy); <nl> +	if (ret) <nl> +		return ret; <nl>   <nl>  	policy->user_policy.policy = policy->policy; <nl>  	policy->user_policy.governor = policy->governor; <nl> - <nl> -	if (ret) <nl> -		return ret; <nl> -	else <nl> -		return count; <nl> +	return count; <nl>  } <nl>   <nl>  /**
@@ -2490,6 +2490,7 @@ static int tcp_ack_update_window(struct sock *sk, struct tcp_sock *tp, <nl>  static void tcp_conservative_spur_to_response(struct tcp_sock *tp) <nl>  { <nl>  	tp->snd_cwnd = min(tp->snd_cwnd, tp->snd_ssthresh); <nl> +	tp->snd_cwnd_cnt = 0; <nl>  	tcp_moderate_cwnd(tp); <nl>  } <nl>  
@@ -1549,6 +1549,9 @@ static long comedi_unlocked_ioctl(struct file *file, unsigned int cmd, <nl>  	if (cmd == COMEDI_DEVCONFIG) { <nl>  		rc = do_devconfig_ioctl(dev, <nl>  					(struct comedi_devconfig __user *)arg); <nl> +		if (rc == 0) <nl> +			/* Evade comedi_auto_unconfig(). */ <nl> +			dev_file_info->hardware_device = NULL; <nl>  		goto done; <nl>  	} <nl>  
@@ -96,6 +96,8 @@ static int nfnl_acct_new(struct net *net, struct sock *nfnl, <nl>  			return -EINVAL; <nl>  		if (flags & NFACCT_F_OVERQUOTA) <nl>  			return -EINVAL; <nl> +		if ((flags & NFACCT_F_QUOTA) && !tb[NFACCT_QUOTA]) <nl> +			return -EINVAL; <nl>   <nl>  		size += sizeof(u64); <nl>  	}
@@ -1914,8 +1914,10 @@ static int unix_dgram_recvmsg(struct socket *sock, struct msghdr *msg, <nl>  		goto out_unlock; <nl>  	} <nl>   <nl> -	wake_up_interruptible_sync_poll(&u->peer_wait, <nl> -					POLLOUT | POLLWRNORM | POLLWRBAND); <nl> +	if (wq_has_sleeper(&u->peer_wait)) <nl> +		wake_up_interruptible_sync_poll(&u->peer_wait, <nl> +						POLLOUT | POLLWRNORM | <nl> +						POLLWRBAND); <nl>   <nl>  	if (msg->msg_name) <nl>  		unix_copy_addr(msg, skb->sk);
@@ -557,6 +557,13 @@ duration: <nl>  	    usecs_to_jiffies(be32_to_cpu <nl>  			     (*((__be32 *) (data + <nl>  					    TPM_GET_CAP_RET_UINT32_1_IDX)))); <nl> +	/* The Broadcom BCM0102 chipset in a Dell Latitude D820 gets the above <nl> +	 * value wrong and apparently reports msecs rather than usecs. So we <nl> +	 * fix up the resulting too-small TPM_SHORT value to make things work. <nl> +	 */ <nl> +	if (chip->vendor.duration[TPM_SHORT] < (HZ/100)) <nl> +		chip->vendor.duration[TPM_SHORT] = HZ; <nl> + <nl>  	chip->vendor.duration[TPM_MEDIUM] = <nl>  	    usecs_to_jiffies(be32_to_cpu <nl>  			     (*((__be32 *) (data +
@@ -600,7 +600,8 @@ static int vmx_set_msr(struct kvm_vcpu *vcpu, u32 msr_index, u64 data) <nl>  		msr = find_msr_entry(vcpu, msr_index); <nl>  		if (msr) <nl>  			msr->data = data; <nl> -		load_msrs(vcpu->guest_msrs, NR_BAD_MSRS); <nl> +		if (vcpu->vmx_host_state.loaded) <nl> +			load_msrs(vcpu->guest_msrs, NR_BAD_MSRS); <nl>  		break; <nl>  #endif <nl>  	case MSR_IA32_SYSENTER_CS:
@@ -127,6 +127,7 @@ struct zx_dma_dev { <nl>  	struct dma_pool		*pool; <nl>  	u32			dma_channels; <nl>  	u32			dma_requests; <nl> +	int 			irq; <nl>  }; <nl>   <nl>  #define to_zx_dma(dmadev) container_of(dmadev, struct zx_dma_dev, slave) <nl> @@ -683,7 +684,7 @@ static int zx_dma_probe(struct platform_device *op) <nl>  { <nl>  	struct zx_dma_dev *d; <nl>  	struct resource *iores; <nl> -	int i, ret = 0, irq = 0; <nl> +	int i, ret = 0; <nl>   <nl>  	iores = platform_get_resource(op, IORESOURCE_MEM, 0); <nl>  	if (!iores) <nl> @@ -710,8 +711,8 @@ static int zx_dma_probe(struct platform_device *op) <nl>  		return PTR_ERR(d->clk); <nl>  	} <nl>   <nl> -	irq = platform_get_irq(op, 0); <nl> -	ret = devm_request_irq(&op->dev, irq, zx_dma_int_handler, <nl> +	d->irq = platform_get_irq(op, 0); <nl> +	ret = devm_request_irq(&op->dev, d->irq, zx_dma_int_handler, <nl>  			       0, DRIVER_NAME, d); <nl>  	if (ret) <nl>  		return ret; <nl> @@ -807,6 +808,9 @@ static int zx_dma_remove(struct platform_device *op) <nl>  	struct zx_dma_chan *c, *cn; <nl>  	struct zx_dma_dev *d = platform_get_drvdata(op); <nl>   <nl> +	/* explictly free the irq */ <nl> +	devm_free_irq(&op->dev, d->irq, d); <nl> + <nl>  	dma_async_device_unregister(&d->slave); <nl>  	of_dma_controller_free((&op->dev)->of_node); <nl>  
@@ -262,8 +262,10 @@ void __kvm_migrate_pit_timer(struct kvm_vcpu *vcpu) <nl>  		return; <nl>   <nl>  	timer = &pit->pit_state.timer; <nl> +	mutex_lock(&pit->pit_state.lock); <nl>  	if (hrtimer_cancel(timer)) <nl>  		hrtimer_start_expires(timer, HRTIMER_MODE_ABS); <nl> +	mutex_unlock(&pit->pit_state.lock); <nl>  } <nl>   <nl>  static void destroy_pit_timer(struct kvm_pit *pit)
@@ -411,9 +411,9 @@ static int tc3589x_keypad_probe(struct platform_device *pdev) <nl>   <nl>  	input_set_drvdata(input, keypad); <nl>   <nl> -	error = request_threaded_irq(irq, NULL, <nl> -			tc3589x_keypad_irq, plat->irqtype, <nl> -			"tc3589x-keypad", keypad); <nl> +	error = request_threaded_irq(irq, NULL, tc3589x_keypad_irq, <nl> +				     plat->irqtype | IRQF_ONESHOT, <nl> +				     "tc3589x-keypad", keypad); <nl>  	if (error < 0) { <nl>  		dev_err(&pdev->dev, <nl>  				"Could not allocate irq %d,error %d\n",
@@ -238,8 +238,7 @@ int poll_schedule_timeout(struct poll_wqueues *pwq, int state, <nl>   <nl>  	set_current_state(state); <nl>  	if (!pwq->triggered) <nl> -		rc = freezable_schedule_hrtimeout_range(expires, slack, <nl> -							HRTIMER_MODE_ABS); <nl> +		rc = schedule_hrtimeout_range(expires, slack, HRTIMER_MODE_ABS); <nl>  	__set_current_state(TASK_RUNNING); <nl>   <nl>  	/*
@@ -692,7 +692,7 @@ static void handle_stop_signal(int sig, struct task_struct *p) <nl>  { <nl>  	struct task_struct *t; <nl>   <nl> -	if (p->flags & SIGNAL_GROUP_EXIT) <nl> +	if (p->signal->flags & SIGNAL_GROUP_EXIT) <nl>  		/* <nl>  		 * The process is in the middle of dying already. <nl>  		 */
@@ -247,6 +247,7 @@ again: <nl>  	if (err < 0) <nl>  		return err; <nl>   <nl> +	page = compound_head(page); <nl>  	lock_page(page); <nl>  	if (!page->mapping) { <nl>  		unlock_page(page);
@@ -498,6 +498,11 @@ static void __of_changeset_entry_invert(struct of_changeset_entry *ce, <nl>  	case OF_RECONFIG_UPDATE_PROPERTY: <nl>  		rce->old_prop = ce->prop; <nl>  		rce->prop = ce->old_prop; <nl> +		/* update was used but original property did not exist */ <nl> +		if (!rce->prop) { <nl> +			rce->action = OF_RECONFIG_REMOVE_PROPERTY; <nl> +			rce->prop = ce->prop; <nl> +		} <nl>  		break; <nl>  	} <nl>  }
@@ -273,6 +273,8 @@ static int gb_loopback_transfer(struct gb_loopback *gb, u32 len) <nl>  		return -ENOMEM; <nl>  	} <nl>   <nl> +	memset(request->data, 0x5A, len); <nl> + <nl>  	request->len = cpu_to_le32(len); <nl>   <nl>  	do_gettimeofday(&ts);
@@ -32,9 +32,9 @@ static inline void rtsx_exclusive_enter_ss(struct rtsx_chip *chip) <nl>  { <nl>  	struct rtsx_dev *dev = chip->rtsx; <nl>   <nl> -	spin_lock(&(dev->reg_lock)); <nl> +	spin_lock(&dev->reg_lock); <nl>  	rtsx_enter_ss(chip); <nl> -	spin_unlock(&(dev->reg_lock)); <nl> +	spin_unlock(&dev->reg_lock); <nl>  } <nl>   <nl>  static inline void rtsx_reset_detected_cards(struct rtsx_chip *chip, int flag)
@@ -11489,6 +11489,10 @@ static int bnx2x_populate_ext_phy(struct bnx2x *bp, <nl>  		return -EINVAL; <nl>  	default: <nl>  		*phy = phy_null; <nl> +		/* In case external PHY wasn't found */ <nl> +		if ((phy_type != PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT) && <nl> +		    (phy_type != PORT_HW_CFG_XGXS_EXT_PHY_TYPE_NOT_CONN)) <nl> +			return -EINVAL; <nl>  		return 0; <nl>  	} <nl>  
@@ -53,9 +53,9 @@ static int imx_es8328_dai_init(struct snd_soc_pcm_runtime *rtd) <nl>   <nl>  	/* Headphone jack detection */ <nl>  	if (gpio_is_valid(data->jack_gpio)) { <nl> -		ret = snd_soc_jack_new(rtd->codec, "Headphone", <nl> -				       SND_JACK_HEADPHONE | SND_JACK_BTN_0, <nl> -				       &headset_jack); <nl> +		ret = snd_soc_card_jack_new(rtd->card, "Headphone", <nl> +					    SND_JACK_HEADPHONE | SND_JACK_BTN_0, <nl> +					    &headset_jack, NULL, 0); <nl>  		if (ret) <nl>  			return ret; <nl>  
@@ -972,13 +972,13 @@ fail: <nl>  			insert_pt = &gh2->gh_list; <nl>  	} <nl>  	set_bit(GLF_QUEUED, &gl->gl_flags); <nl> +	trace_gfs2_glock_queue(gh, 1); <nl>  	if (likely(insert_pt == NULL)) { <nl>  		list_add_tail(&gh->gh_list, &gl->gl_holders); <nl>  		if (unlikely(gh->gh_flags & LM_FLAG_PRIORITY)) <nl>  			goto do_cancel; <nl>  		return; <nl>  	} <nl> -	trace_gfs2_glock_queue(gh, 1); <nl>  	list_add_tail(&gh->gh_list, insert_pt); <nl>  do_cancel: <nl>  	gh = list_entry(gl->gl_holders.next, struct gfs2_holder, gh_list);
@@ -4545,19 +4545,22 @@ static void valleyview_set_cdclk(struct drm_device *dev, int cdclk) <nl>  static int valleyview_calc_cdclk(struct drm_i915_private *dev_priv, <nl>  				 int max_pixclk) <nl>  { <nl> +	int vco = valleyview_get_vco(dev_priv); <nl> +	int freq_320 = (vco <<  1) % 320000 != 0 ? 333333 : 320000; <nl> + <nl>  	/* <nl>  	 * Really only a few cases to deal with, as only 4 CDclks are supported: <nl>  	 *   200MHz <nl>  	 *   267MHz <nl> -	 *   320MHz <nl> +	 *   320/333MHz (depends on HPLL freq) <nl>  	 *   400MHz <nl>  	 * So we check to see whether we're above 90% of the lower bin and <nl>  	 * adjust if needed. <nl>  	 */ <nl> -	if (max_pixclk > 320000*9/10) <nl> +	if (max_pixclk > freq_320*9/10) <nl>  		return 400000; <nl>  	else if (max_pixclk > 266667*9/10) <nl> -		return 320000; <nl> +		return freq_320; <nl>  	else <nl>  		return 266667; <nl>  	/* Looks like the 200MHz CDclk freq doesn't work on some configs */
@@ -78,7 +78,9 @@ static int dax_pmem_probe(struct device *dev) <nl>  	nsio = to_nd_namespace_io(&ndns->dev); <nl>   <nl>  	/* parse the 'pfn' info block via ->rw_bytes */ <nl> -	devm_nsio_enable(dev, nsio); <nl> +	rc = devm_nsio_enable(dev, nsio); <nl> +	if (rc) <nl> +		return rc; <nl>  	altmap = nvdimm_setup_pfn(nd_pfn, &res, &__altmap); <nl>  	if (IS_ERR(altmap)) <nl>  		return PTR_ERR(altmap);
@@ -620,7 +620,7 @@ static int fsg_setup(struct usb_function *f, <nl>  		*(u8 *) req->buf = fsg->common->nluns - 1; <nl>   <nl>  		/* Respond with data/status */ <nl> -		req->length = min(1, w_length); <nl> +		req->length = min((u16)1, w_length); <nl>  		fsg->common->ep0req_name = <nl>  			ctrl->bRequestType & USB_DIR_IN ? "ep0-in" : "ep0-out"; <nl>  		return ep0_queue(fsg->common);
@@ -1729,6 +1729,7 @@ call_bind_status(struct rpc_task *task) <nl>  		return; <nl>  	case -ECONNREFUSED:		/* connection problems */ <nl>  	case -ECONNRESET: <nl> +	case -ECONNABORTED: <nl>  	case -ENOTCONN: <nl>  	case -EHOSTDOWN: <nl>  	case -EHOSTUNREACH: <nl> @@ -1799,7 +1800,9 @@ call_connect_status(struct rpc_task *task) <nl>  		return; <nl>  	case -ECONNREFUSED: <nl>  	case -ECONNRESET: <nl> +	case -ECONNABORTED: <nl>  	case -ENETUNREACH: <nl> +	case -EHOSTUNREACH: <nl>  		/* retry with existing socket, after a delay */ <nl>  		rpc_delay(task, 3*HZ); <nl>  		if (RPC_IS_SOFTCONN(task)) <nl> @@ -1902,6 +1905,7 @@ call_transmit_status(struct rpc_task *task) <nl>  			break; <nl>  		} <nl>  	case -ECONNRESET: <nl> +	case -ECONNABORTED: <nl>  	case -ENOTCONN: <nl>  	case -EPIPE: <nl>  		rpc_task_force_reencode(task); <nl> @@ -2011,8 +2015,9 @@ call_status(struct rpc_task *task) <nl>  			xprt_conditional_disconnect(req->rq_xprt, <nl>  					req->rq_connect_cookie); <nl>  		break; <nl> -	case -ECONNRESET: <nl>  	case -ECONNREFUSED: <nl> +	case -ECONNRESET: <nl> +	case -ECONNABORTED: <nl>  		rpc_force_rebind(clnt); <nl>  		rpc_delay(task, 3*HZ); <nl>  	case -EPIPE:
@@ -1025,7 +1025,8 @@ mwifiex_wmm_get_highest_priolist_ptr(struct mwifiex_adapter *adapter, <nl>  				list_for_each_entry(ptr, &tid_ptr->ra_list, <nl>  						    list) { <nl>   <nl> -					if (!skb_queue_empty(&ptr->skb_head)) <nl> +					if (!ptr->tx_paused && <nl> +					    !skb_queue_empty(&ptr->skb_head)) <nl>  						/* holds both locks */ <nl>  						goto found; <nl>  				}
@@ -943,6 +943,11 @@ static int dvb_register(struct cx23885_tsport *port) <nl>   <nl>  			fe = dvb_attach(xc4000_attach, fe0->dvb.frontend, <nl>  					&dev->i2c_bus[1].i2c_adap, &cfg); <nl> +			if (!fe) { <nl> +				printk(KERN_ERR "%s/2: xc4000 attach failed\n", <nl> +				       dev->name); <nl> +				goto frontend_detach; <nl> +			} <nl>  		} <nl>  		break; <nl>  	case CX23885_BOARD_TBS_6920:
@@ -389,7 +389,7 @@ static unsigned int xuartps_set_baud_rate(struct uart_port *port, <nl>  		unsigned int baud) <nl>  { <nl>  	unsigned int calc_baud; <nl> -	u32 cd, bdiv; <nl> +	u32 cd = 0, bdiv = 0; <nl>  	u32 mreg; <nl>  	int div8; <nl>  	struct xuartps *xuartps = port->private_data;
@@ -899,7 +899,7 @@ struct fib6_node * fib6_lookup(struct fib6_node *root, struct in6_addr *daddr, <nl>  		} <nl>  	}; <nl>   <nl> -	fn = fib6_lookup_1(root, args); <nl> +	fn = fib6_lookup_1(root, daddr ? args : args + 1); <nl>   <nl>  	if (fn == NULL || fn->fn_flags & RTN_TL_ROOT) <nl>  		fn = root;
@@ -74,7 +74,7 @@ static cpuidle_enter_t cpuidle_enter_ops; <nl>  /** <nl>   * cpuidle_play_dead - cpu off-lining <nl>   * <nl> - * Only returns in case of an error <nl> + * Returns in case of an error or no driver <nl>   */ <nl>  int cpuidle_play_dead(void) <nl>  { <nl> @@ -83,6 +83,9 @@ int cpuidle_play_dead(void) <nl>  	int i, dead_state = -1; <nl>  	int power_usage = -1; <nl>   <nl> +	if (!drv) <nl> +		return -ENODEV; <nl> + <nl>  	/* Find lowest-power state that supports long-term idle */ <nl>  	for (i = CPUIDLE_DRIVER_STATE_START; i < drv->state_count; i++) { <nl>  		struct cpuidle_state *s = &drv->states[i];
@@ -272,7 +272,7 @@ struct key *key_alloc(struct key_type *type, const char *desc, <nl>  	} <nl>   <nl>  	/* allocate and initialise the key and its description */ <nl> -	key = kmem_cache_alloc(key_jar, GFP_KERNEL); <nl> +	key = kmem_cache_zalloc(key_jar, GFP_KERNEL); <nl>  	if (!key) <nl>  		goto no_memory_2; <nl>   <nl> @@ -293,18 +293,12 @@ struct key *key_alloc(struct key_type *type, const char *desc, <nl>  	key->uid = uid; <nl>  	key->gid = gid; <nl>  	key->perm = perm; <nl> -	key->flags = 0; <nl> -	key->expiry = 0; <nl> -	key->payload.data = NULL; <nl> -	key->security = NULL; <nl>   <nl>  	if (!(flags & KEY_ALLOC_NOT_IN_QUOTA)) <nl>  		key->flags |= 1 << KEY_FLAG_IN_QUOTA; <nl>  	if (flags & KEY_ALLOC_TRUSTED) <nl>  		key->flags |= 1 << KEY_FLAG_TRUSTED; <nl>   <nl> -	memset(&key->type_data, 0, sizeof(key->type_data)); <nl> - <nl>  #ifdef KEY_DEBUGGING <nl>  	key->magic = KEY_DEBUG_MAGIC; <nl>  #endif
@@ -2766,6 +2766,9 @@ void tcp_get_info(struct sock *sk, struct tcp_info *info) <nl>  		info->tcpi_sacked = sk->sk_max_ack_backlog; <nl>  		return; <nl>  	} <nl> + <nl> +	slow = lock_sock_fast(sk); <nl> + <nl>  	info->tcpi_ca_state = icsk->icsk_ca_state; <nl>  	info->tcpi_retransmits = icsk->icsk_retransmits; <nl>  	info->tcpi_probes = icsk->icsk_probes_out; <nl> @@ -2816,15 +2819,11 @@ void tcp_get_info(struct sock *sk, struct tcp_info *info) <nl>   <nl>  	info->tcpi_total_retrans = tp->total_retrans; <nl>   <nl> -	slow = lock_sock_fast(sk); <nl> - <nl>  	info->tcpi_bytes_acked = tp->bytes_acked; <nl>  	info->tcpi_bytes_received = tp->bytes_received; <nl>  	info->tcpi_notsent_bytes = max_t(int, 0, tp->write_seq - tp->snd_nxt); <nl>  	tcp_get_info_chrono_stats(tp, info); <nl>   <nl> -	unlock_sock_fast(sk, slow); <nl> - <nl>  	info->tcpi_segs_out = tp->segs_out; <nl>  	info->tcpi_segs_in = tp->segs_in; <nl>   <nl> @@ -2840,6 +2839,7 @@ void tcp_get_info(struct sock *sk, struct tcp_info *info) <nl>  		do_div(rate64, intv); <nl>  		info->tcpi_delivery_rate = rate64; <nl>  	} <nl> +	unlock_sock_fast(sk, slow); <nl>  } <nl>  EXPORT_SYMBOL_GPL(tcp_get_info); <nl>  
@@ -1748,7 +1748,7 @@ ecryptfs_process_key_cipher(struct crypto_blkcipher **key_tfm, <nl>  			    char *cipher_name, size_t *key_size) <nl>  { <nl>  	char dummy_key[ECRYPTFS_MAX_KEY_BYTES]; <nl> -	char *full_alg_name; <nl> +	char *full_alg_name = NULL; <nl>  	int rc; <nl>   <nl>  	*key_tfm = NULL; <nl> @@ -1763,7 +1763,6 @@ ecryptfs_process_key_cipher(struct crypto_blkcipher **key_tfm, <nl>  	if (rc) <nl>  		goto out; <nl>  	*key_tfm = crypto_alloc_blkcipher(full_alg_name, 0, CRYPTO_ALG_ASYNC); <nl> -	kfree(full_alg_name); <nl>  	if (IS_ERR(*key_tfm)) { <nl>  		rc = PTR_ERR(*key_tfm); <nl>  		printk(KERN_ERR "Unable to allocate crypto cipher with name " <nl> @@ -1786,6 +1785,7 @@ ecryptfs_process_key_cipher(struct crypto_blkcipher **key_tfm, <nl>  		goto out; <nl>  	} <nl>  out: <nl> +	kfree(full_alg_name); <nl>  	return rc; <nl>  } <nl>  
@@ -536,7 +536,8 @@ i915_error_object_create_sized(struct drm_i915_private *dev_priv, <nl>  			goto unwind; <nl>   <nl>  		local_irq_save(flags); <nl> -		if (reloc_offset < dev_priv->gtt.mappable_end && <nl> +		if (src->cache_level == I915_CACHE_NONE && <nl> +		    reloc_offset < dev_priv->gtt.mappable_end && <nl>  		    src->has_global_gtt_mapping && <nl>  		    i915_is_ggtt(vm)) { <nl>  			void __iomem *s;
@@ -241,7 +241,7 @@ static int timblogiw_querycap(struct file *file, void  *priv, <nl>  	dev_dbg(&vdev->dev, "%s: Entry\n",  __func__); <nl>  	memset(cap, 0, sizeof(*cap)); <nl>  	strncpy(cap->card, TIMBLOGIWIN_NAME, sizeof(cap->card)-1); <nl> -	strncpy(cap->driver, DRIVER_NAME, sizeof(cap->card)-1); <nl> +	strncpy(cap->driver, DRIVER_NAME, sizeof(cap->driver) - 1); <nl>  	strlcpy(cap->bus_info, vdev->name, sizeof(cap->bus_info)); <nl>  	cap->version = TIMBLOGIW_VERSION_CODE; <nl>  	cap->capabilities = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING |
@@ -1256,14 +1256,14 @@ static int comp_oper(struct btrfs_qgroup_operation *oper1, <nl>  		return -1; <nl>  	if (oper1->bytenr > oper2->bytenr) <nl>  		return 1; <nl> -	if (oper1->seq < oper2->seq) <nl> -		return -1; <nl> -	if (oper1->seq > oper2->seq) <nl> -		return 1; <nl>  	if (oper1->ref_root < oper2->ref_root) <nl>  		return -1; <nl>  	if (oper1->ref_root > oper2->ref_root) <nl>  		return 1; <nl> +	if (oper1->seq < oper2->seq) <nl> +		return -1; <nl> +	if (oper1->seq > oper2->seq) <nl> +		return 1; <nl>  	if (oper1->type < oper2->type) <nl>  		return -1; <nl>  	if (oper1->type > oper2->type)
@@ -435,10 +435,10 @@ static int econet_sendmsg(struct kiocb *iocb, struct socket *sock, <nl>  		udpdest.sin_addr.s_addr = htonl(network | addr.station); <nl>  	} <nl>   <nl> +	memset(&ah, 0, sizeof(ah)); <nl>  	ah.port = port; <nl>  	ah.cb = cb & 0x7f; <nl>  	ah.code = 2;		/* magic */ <nl> -	ah.pad = 0; <nl>   <nl>  	/* tack our header on the front of the iovec */ <nl>  	size = sizeof(struct aunhdr);
@@ -62,8 +62,8 @@ static sint _init_mlme_priv(struct _adapter *padapter) <nl>  	_init_queue(&(pmlmepriv->scanned_queue)); <nl>  	set_scanned_network_val(pmlmepriv, 0); <nl>  	memset(&pmlmepriv->assoc_ssid, 0, sizeof(struct ndis_802_11_ssid)); <nl> -	pbuf = kmalloc(MAX_BSS_CNT * (sizeof(struct wlan_network)), <nl> -		       GFP_ATOMIC); <nl> +	pbuf = kmalloc_array(MAX_BSS_CNT, sizeof(struct wlan_network), <nl> +			     GFP_ATOMIC); <nl>  	if (pbuf == NULL) <nl>  		return _FAIL; <nl>  	pmlmepriv->free_bss_buf = pbuf;
@@ -199,6 +199,7 @@ static void rockchip_drm_unbind(struct device *dev) <nl>  	rockchip_drm_fbdev_fini(drm_dev); <nl>  	drm_kms_helper_poll_fini(drm_dev); <nl>   <nl> +	drm_atomic_helper_shutdown(drm_dev); <nl>  	drm_vblank_cleanup(drm_dev); <nl>  	component_unbind_all(dev, drm_dev); <nl>  	drm_mode_config_cleanup(drm_dev);
@@ -114,7 +114,7 @@ void sync_timeline_signal(struct sync_timeline *obj) <nl>  	list_for_each_entry_safe(pt, next, &obj->active_list_head, <nl>  				 active_list) { <nl>  		if (fence_is_signaled_locked(&pt->base)) <nl> -			list_del(&pt->active_list); <nl> +			list_del_init(&pt->active_list); <nl>  	} <nl>   <nl>  	spin_unlock_irqrestore(&obj->child_list_lock, flags);
@@ -1059,7 +1059,9 @@ static int __cpufreq_remove_dev(struct device *dev, struct subsys_interface *sif <nl>  	cpus = cpumask_weight(data->cpus); <nl>  	cpumask_clear_cpu(cpu, data->cpus); <nl>   <nl> -	if (unlikely((cpu == data->cpu) && (cpus > 1))) { <nl> +	if (cpu != data->cpu) { <nl> +		sysfs_remove_link(&dev->kobj, "cpufreq"); <nl> +	} else if (cpus > 1) { <nl>  		/* first sibling now owns the new sysfs dir */ <nl>  		cpu_dev = get_cpu_device(cpumask_first(data->cpus)); <nl>  		sysfs_remove_link(&cpu_dev->kobj, "cpufreq"); <nl> @@ -1084,7 +1086,6 @@ static int __cpufreq_remove_dev(struct device *dev, struct subsys_interface *sif <nl>  	pr_debug("%s: removing link, cpu: %d\n", __func__, cpu); <nl>  	cpufreq_cpu_put(data); <nl>  	unlock_policy_rwsem_write(cpu); <nl> -	sysfs_remove_link(&dev->kobj, "cpufreq"); <nl>   <nl>  	/* If cpu is last user of policy, free policy */ <nl>  	if (cpus == 1) {
@@ -991,13 +991,20 @@ static int read_eeprom(struct cx231xx *dev, u8 *eedata, int len) <nl>   <nl>  	/* start reading at offset 0 */ <nl>  	ret = i2c_transfer(&dev->i2c_bus[1].i2c_adap, &msg_write, 1); <nl> +	if (ret < 0) { <nl> +		cx231xx_err("Can't read eeprom\n"); <nl> +		return ret; <nl> +	} <nl>   <nl>  	while (len_todo > 0) { <nl>  		msg_read.len = (len_todo > 64) ? 64 : len_todo; <nl>  		msg_read.buf = eedata_cur; <nl>   <nl>  		ret = i2c_transfer(&dev->i2c_bus[1].i2c_adap, &msg_read, 1); <nl> - <nl> +		if (ret < 0) { <nl> +			cx231xx_err("Can't read eeprom\n"); <nl> +			return ret; <nl> +		} <nl>  		eedata_cur += msg_read.len; <nl>  		len_todo -= msg_read.len; <nl>  	}
@@ -512,6 +512,8 @@ static ssize_t sn2_ptc_proc_write(struct file *file, const char __user *user, si <nl>  	int cpu; <nl>  	char optstr[64]; <nl>   <nl> +	if (count > sizeof(optstr)) <nl> +		return -EINVAL; <nl>  	if (copy_from_user(optstr, user, count)) <nl>  		return -EFAULT; <nl>  	optstr[count - 1] = '\0';
@@ -1864,6 +1864,10 @@ LNetCtl(unsigned int cmd, void *arg) <nl>  	int rc; <nl>  	unsigned long secs_passed; <nl>   <nl> +	BUILD_BUG_ON(LIBCFS_IOC_DATA_MAX < <nl> +		     sizeof(struct lnet_ioctl_net_config) + <nl> +		     sizeof(struct lnet_ioctl_config_data)); <nl> + <nl>  	switch (cmd) { <nl>  	case IOC_LIBCFS_GET_NI: <nl>  		rc = LNetGetId(data->ioc_count, &id);
@@ -213,11 +213,15 @@ int kvm_set_irq_routing(struct kvm *kvm, <nl>  			goto out; <nl>   <nl>  		r = -EINVAL; <nl> -		if (ue->flags) <nl> +		if (ue->flags) { <nl> +			kfree(e); <nl>  			goto out; <nl> +		} <nl>  		r = setup_routing_entry(new, e, ue); <nl> -		if (r) <nl> +		if (r) { <nl> +			kfree(e); <nl>  			goto out; <nl> +		} <nl>  		++ue; <nl>  	} <nl>  
@@ -734,7 +734,9 @@ qla2xxx_queuecommand(struct Scsi_Host *host, struct scsi_cmnd *cmd) <nl>  	 * Return target busy if we've received a non-zero retry_delay_timer <nl>  	 * in a FCP_RSP. <nl>  	 */ <nl> -	if (time_after(jiffies, fcport->retry_delay_timestamp)) <nl> +	if (fcport->retry_delay_timestamp == 0) { <nl> +		/* retry delay not set */ <nl> +	} else if (time_after(jiffies, fcport->retry_delay_timestamp)) <nl>  		fcport->retry_delay_timestamp = 0; <nl>  	else <nl>  		goto qc24_target_busy;
@@ -144,6 +144,7 @@ static int misc_open(struct inode * inode, struct file * file) <nl>  	old_fops = file->f_op; <nl>  	file->f_op = new_fops; <nl>  	if (file->f_op->open) { <nl> +		file->private_data = c; <nl>  		err=file->f_op->open(inode,file); <nl>  		if (err) { <nl>  			fops_put(file->f_op);
@@ -3260,6 +3260,7 @@ static int vt_unbind(struct con_driver *con) <nl>  { <nl>  	const struct consw *csw = NULL; <nl>  	int i, more = 1, first = -1, last = -1, deflt = 0; <nl> +	int ret; <nl>   <nl>   	if (!con->con || !(con->flag & CON_DRIVER_FLAG_MODULE) || <nl>  	    con_is_graphics(con->con, con->first, con->last)) <nl> @@ -3285,8 +3286,10 @@ static int vt_unbind(struct con_driver *con) <nl>   <nl>  		if (first != -1) { <nl>  			console_lock(); <nl> -			do_unbind_con_driver(csw, first, last, deflt); <nl> +			ret = do_unbind_con_driver(csw, first, last, deflt); <nl>  			console_unlock(); <nl> +			if (ret != 0) <nl> +				return ret; <nl>  		} <nl>   <nl>  		first = -1;
@@ -129,7 +129,7 @@ s_vGenerateTxParameter( <nl>   <nl>  static unsigned int <nl>  s_cbFillTxBufHead(struct vnt_private *pDevice, unsigned char byPktType, <nl> -		  unsigned char *pbyTxBufferAddr, unsigned int cbFrameBodySize, <nl> +		  unsigned char *pbyTxBufferAddr, <nl>  		  unsigned int uDMAIdx, PSTxDesc pHeadTD, <nl>  		  unsigned int uNodeIndex); <nl>   <nl> @@ -1030,7 +1030,7 @@ s_vGenerateTxParameter( <nl>   <nl>  static unsigned int <nl>  s_cbFillTxBufHead(struct vnt_private *pDevice, unsigned char byPktType, <nl> -		  unsigned char *pbyTxBufferAddr, unsigned int cbFrameBodySize, <nl> +		  unsigned char *pbyTxBufferAddr, <nl>  		  unsigned int uDMAIdx, PSTxDesc pHeadTD, <nl>  		  unsigned int is_pspoll) <nl>  { <nl> @@ -1195,12 +1195,12 @@ s_cbFillTxBufHead(struct vnt_private *pDevice, unsigned char byPktType, <nl>   <nl>  	hdr->duration_id = uDuration; <nl>   <nl> -	cbReqCount = cbHeaderLength + uPadding + cbFrameBodySize; <nl> +	cbReqCount = cbHeaderLength + uPadding + skb->len; <nl>  	pbyBuffer = (unsigned char *)pHeadTD->pTDInfo->buf; <nl>  	uLength = cbHeaderLength + uPadding; <nl>   <nl>  	/* Copy the Packet into a tx Buffer */ <nl> -	memcpy((pbyBuffer + uLength), skb->data, cbFrameBodySize); <nl> +	memcpy((pbyBuffer + uLength), skb->data, skb->len); <nl>   <nl>  	ptdCurr = (PSTxDesc)pHeadTD; <nl>   <nl> @@ -1398,7 +1398,7 @@ int vnt_generate_fifo_header(struct vnt_private *priv, u32 dma_idx, <nl>   <nl>  	tx_buffer_head->frag_ctl |= cpu_to_le16(FRAGCTL_NONFRAG); <nl>   <nl> -	s_cbFillTxBufHead(priv, pkt_type, (u8 *)tx_buffer_head, skb->len, <nl> +	s_cbFillTxBufHead(priv, pkt_type, (u8 *)tx_buffer_head, <nl>  			  dma_idx, head_td, is_pspoll); <nl>   <nl>  	if (info->control.hw_key) {
@@ -496,6 +496,7 @@ static int tm6000_init_dev(struct tm6000_core *dev) <nl>  		} <nl>  #endif <nl>  	} <nl> +	mutex_unlock(&dev->lock); <nl>  	return 0; <nl>   <nl>  err2:
@@ -409,7 +409,7 @@ err1: <nl>   <nl>  static void treo680_irda_shutdown(struct device *dev) <nl>  { <nl> -	gpio_free(GPIO_NR_TREO680_AMP_EN); <nl> +	gpio_free(GPIO_NR_TREO680_IR_EN); <nl>  } <nl>   <nl>  static struct pxaficp_platform_data treo680_ficp_info = {
@@ -574,7 +574,7 @@ static ssize_t in_illuminance_lux_table_store(struct device *dev, <nl>  			__func__, TSL2583_MAX_LUX_INTS); <nl>  		goto done; <nl>  	} <nl> -	if ((value[(n - 2)] | value[(n - 1)] | value[n]) != 0) { <nl> +	if ((value[n - 2] | value[n - 1] | value[n]) != 0) { <nl>  		dev_err(dev, "%s: The last 3 entries in the lux table must be zeros.\n", <nl>  			__func__); <nl>  		goto done; <nl> @@ -582,7 +582,7 @@ static ssize_t in_illuminance_lux_table_store(struct device *dev, <nl>   <nl>  	/* Zero out the table */ <nl>  	memset(tsl2583_device_lux, 0, sizeof(tsl2583_device_lux)); <nl> -	memcpy(tsl2583_device_lux, &value[1], (value[0] * 4)); <nl> +	memcpy(tsl2583_device_lux, &value[1], value[0] * 4); <nl>   <nl>  	ret = len; <nl>  
@@ -171,7 +171,7 @@ int t4vf_wr_mbox_core(struct adapter *adapter, const void *cmd, int size, <nl>  	delay_idx = 0; <nl>  	ms = delay[0]; <nl>   <nl> -	for (i = 0; i < 500; i += ms) { <nl> +	for (i = 0; i < FW_CMD_MAX_TIMEOUT; i += ms) { <nl>  		if (sleep_ok) { <nl>  			ms = delay[delay_idx]; <nl>  			if (delay_idx < ARRAY_SIZE(delay) - 1)
@@ -149,7 +149,7 @@ static int __devinit lm70_probe(struct spi_device *spi) <nl>   <nl>  	/* NOTE:  we assume 8-bit words, and convert to 16 bits manually */ <nl>   <nl> -	p_lm70 = kzalloc(sizeof *p_lm70, GFP_KERNEL); <nl> +	p_lm70 = devm_kzalloc(&spi->dev, sizeof(*p_lm70), GFP_KERNEL); <nl>  	if (!p_lm70) <nl>  		return -ENOMEM; <nl>   <nl> @@ -181,7 +181,6 @@ out_dev_create_file_failed: <nl>  	device_remove_file(&spi->dev, &dev_attr_temp1_input); <nl>  out_dev_create_temp_file_failed: <nl>  	spi_set_drvdata(spi, NULL); <nl> -	kfree(p_lm70); <nl>  	return status; <nl>  } <nl>   <nl> @@ -193,7 +192,6 @@ static int __devexit lm70_remove(struct spi_device *spi) <nl>  	device_remove_file(&spi->dev, &dev_attr_temp1_input); <nl>  	device_remove_file(&spi->dev, &dev_attr_name); <nl>  	spi_set_drvdata(spi, NULL); <nl> -	kfree(p_lm70); <nl>   <nl>  	return 0; <nl>  }
@@ -62,6 +62,7 @@ void irq_gc_mask_set_bit(struct irq_data *d) <nl>  	irq_reg_writel(*ct->mask_cache, gc->reg_base + ct->regs.mask); <nl>  	irq_gc_unlock(gc); <nl>  } <nl> +EXPORT_SYMBOL_GPL(irq_gc_mask_set_bit); <nl>   <nl>  /** <nl>   * irq_gc_mask_set_mask_bit - Mask chip via clearing bit in mask register <nl> @@ -81,6 +82,7 @@ void irq_gc_mask_clr_bit(struct irq_data *d) <nl>  	irq_reg_writel(*ct->mask_cache, gc->reg_base + ct->regs.mask); <nl>  	irq_gc_unlock(gc); <nl>  } <nl> +EXPORT_SYMBOL_GPL(irq_gc_mask_clr_bit); <nl>   <nl>  /** <nl>   * irq_gc_unmask_enable_reg - Unmask chip via enable register <nl> @@ -115,6 +117,7 @@ void irq_gc_ack_set_bit(struct irq_data *d) <nl>  	irq_reg_writel(mask, gc->reg_base + ct->regs.ack); <nl>  	irq_gc_unlock(gc); <nl>  } <nl> +EXPORT_SYMBOL_GPL(irq_gc_ack_set_bit); <nl>   <nl>  /** <nl>   * irq_gc_ack_clr_bit - Ack pending interrupt via clearing bit
@@ -690,15 +690,16 @@ static int rcar_i2c_probe(struct platform_device *pdev) <nl>  		return ret; <nl>  	} <nl>   <nl> +	pm_runtime_enable(dev); <nl> +	platform_set_drvdata(pdev, priv); <nl> + <nl>  	ret = i2c_add_numbered_adapter(adap); <nl>  	if (ret < 0) { <nl>  		dev_err(dev, "reg adap failed: %d\n", ret); <nl> +		pm_runtime_disable(dev); <nl>  		return ret; <nl>  	} <nl>   <nl> -	pm_runtime_enable(dev); <nl> -	platform_set_drvdata(pdev, priv); <nl> - <nl>  	dev_info(dev, "probed\n"); <nl>   <nl>  	return 0;
@@ -145,6 +145,7 @@ int bcm2835_audio_start(struct bcm2835_alsa_stream *alsa_stream) <nl>  		work->alsa_stream = alsa_stream; <nl>  		work->cmd = BCM2835_AUDIO_START; <nl>  		if (!queue_work(alsa_stream->my_wq, &work->my_work)) { <nl> +			kfree(work); <nl>  			return -EBUSY; <nl>  		} <nl>  	} <nl> @@ -168,6 +169,7 @@ int bcm2835_audio_stop(struct bcm2835_alsa_stream *alsa_stream) <nl>  		work->alsa_stream = alsa_stream; <nl>  		work->cmd = BCM2835_AUDIO_STOP; <nl>  		if (!queue_work(alsa_stream->my_wq, &work->my_work)) { <nl> +			kfree(work); <nl>  			return -EBUSY; <nl>  		} <nl>  	} <nl> @@ -194,6 +196,7 @@ int bcm2835_audio_write(struct bcm2835_alsa_stream *alsa_stream, <nl>  		work->src = src; <nl>  		work->count = count; <nl>  		if (!queue_work(alsa_stream->my_wq, &work->my_work)) { <nl> +			kfree(work); <nl>  			return -EBUSY; <nl>  		} <nl>  	}
@@ -1504,7 +1504,7 @@ EXPORT_SYMBOL(snprintf); <nl>   * @...: Arguments for the format string <nl>   * <nl>   * The return value is the number of characters written into @buf not including <nl> - * the trailing '\0'. If @size is <= 0 the function returns 0. <nl> + * the trailing '\0'. If @size is == 0 the function returns 0. <nl>   */ <nl>   <nl>  int scnprintf(char *buf, size_t size, const char *fmt, ...) <nl> @@ -1516,7 +1516,11 @@ int scnprintf(char *buf, size_t size, const char *fmt, ...) <nl>  	i = vsnprintf(buf, size, fmt, args); <nl>  	va_end(args); <nl>   <nl> -	return (i >= size) ? (size - 1) : i; <nl> +	if (likely(i < size)) <nl> +		return i; <nl> +	if (size != 0) <nl> +		return size - 1; <nl> +	return 0; <nl>  } <nl>  EXPORT_SYMBOL(scnprintf); <nl>  
@@ -991,6 +991,8 @@ unapply_new_state: <nl>  				pinmux_enable_setting(setting); <nl>  		} <nl>  	} <nl> + <nl> +	p->state = old_state; <nl>  	return ret; <nl>  } <nl>  
@@ -103,8 +103,14 @@ static int sclhi(struct i2c_algo_bit_data *adap) <nl>  		 * chips may hold it low ("clock stretching") while they <nl>  		 * are processing data internally. <nl>  		 */ <nl> -		if (time_after(jiffies, start + adap->timeout)) <nl> +		if (time_after(jiffies, start + adap->timeout)) { <nl> +			/* Test one last time, as we may have been preempted <nl> +			 * between last check and timeout test. <nl> +			 */ <nl> +			if (getscl(adap)) <nl> +				break; <nl>  			return -ETIMEDOUT; <nl> +		} <nl>  		cond_resched(); <nl>  	} <nl>  #ifdef DEBUG
@@ -470,6 +470,7 @@ static void remove_event_file_dir(struct ftrace_event_file *file) <nl>   <nl>  	list_del(&file->list); <nl>  	remove_subsystem(file->system); <nl> +	free_event_filter(file->filter); <nl>  	kmem_cache_free(file_cachep, file); <nl>  } <nl>  
@@ -71,6 +71,13 @@ nouveau_therm_update_linear(struct nouveau_therm *therm) <nl>  	u8  temp = therm->temp_get(therm); <nl>  	u16 duty; <nl>   <nl> +	/* handle the non-linear part first */ <nl> +	if (temp < linear_min_temp) <nl> +		return priv->fan->bios.min_duty; <nl> +	else if (temp > linear_max_temp) <nl> +		return priv->fan->bios.max_duty; <nl> + <nl> +	/* we are in the linear zone */ <nl>  	duty  = (temp - linear_min_temp); <nl>  	duty *= (priv->fan->bios.max_duty - priv->fan->bios.min_duty); <nl>  	duty /= (linear_max_temp - linear_min_temp);
@@ -185,6 +185,16 @@ static int nvm_core_init(struct nvm_dev *dev) <nl>  	dev->plane_mode = NVM_PLANE_SINGLE; <nl>  	dev->max_rq_size = dev->ops->max_phys_sect * dev->sec_size; <nl>   <nl> +	if (grp->mtype != 0) { <nl> +		pr_err("nvm: memory type not supported\n"); <nl> +		return -EINVAL; <nl> +	} <nl> + <nl> +	if (grp->fmtype != 0 && grp->fmtype != 1) { <nl> +		pr_err("nvm: flash type not supported\n"); <nl> +		return -EINVAL; <nl> +	} <nl> + <nl>  	if (grp->mpos & 0x020202) <nl>  		dev->plane_mode = NVM_PLANE_DOUBLE; <nl>  	if (grp->mpos & 0x040404)
@@ -659,10 +659,10 @@ xfs_check_page_type( <nl>  			if (type == XFS_IO_UNWRITTEN) <nl>  				return true; <nl>  		} else if (buffer_delay(bh)) { <nl> -			if (type == XFS_IO_DELALLOC); <nl> +			if (type == XFS_IO_DELALLOC) <nl>  				return true; <nl>  		} else if (buffer_dirty(bh) && buffer_mapped(bh)) { <nl> -			if (type == XFS_IO_OVERWRITE); <nl> +			if (type == XFS_IO_OVERWRITE) <nl>  				return true; <nl>  		} <nl>  
@@ -415,7 +415,7 @@ int trace_get_user(struct trace_parser *parser, const char __user *ubuf, <nl>   <nl>  	/* read the non-space input */ <nl>  	while (cnt && !isspace(ch)) { <nl> -		if (parser->idx < parser->size) <nl> +		if (parser->idx < parser->size - 1) <nl>  			parser->buffer[parser->idx++] = ch; <nl>  		else { <nl>  			ret = -EINVAL;
@@ -180,7 +180,7 @@ static int s5h1420_send_master_cmd (struct dvb_frontend* fe, <nl>  	int result = 0; <nl>   <nl>  	dprintk("enter %s\n", __func__); <nl> -	if (cmd->msg_len > 8) <nl> +	if (cmd->msg_len > sizeof(cmd->msg)) <nl>  		return -EINVAL; <nl>   <nl>  	/* setup for DISEQC */
@@ -194,7 +194,7 @@ retry: <nl>  	} <nl>   <nl>  	/* Check info buffer */ <nl> -	info = (void *)&msg[1]; <nl> +	info = (void *)&bcdc->buf[0]; <nl>   <nl>  	/* Copy info buffer */ <nl>  	if (buf) {
@@ -881,7 +881,7 @@ int of_irq_map_one(struct device_node *device, int index, struct of_irq *out_irq <nl>  	intsize = *tmp; <nl>   <nl>  	/* Check index */ <nl> -	if (index * intsize >= intlen) <nl> +	if ((index + 1) * intsize > intlen) <nl>  		return -EINVAL; <nl>   <nl>  	/* Get new specifier and map it */
@@ -2941,10 +2941,16 @@ static inline int open_to_namei_flags(int flag) <nl>   <nl>  static int may_o_create(const struct path *dir, struct dentry *dentry, umode_t mode) <nl>  { <nl> +	struct user_namespace *s_user_ns; <nl>  	int error = security_path_mknod(dir, dentry, mode, 0); <nl>  	if (error) <nl>  		return error; <nl>   <nl> +	s_user_ns = dir->dentry->d_sb->s_user_ns; <nl> +	if (!kuid_has_mapping(s_user_ns, current_fsuid()) || <nl> +	    !kgid_has_mapping(s_user_ns, current_fsgid())) <nl> +		return -EOVERFLOW; <nl> + <nl>  	error = inode_permission(dir->dentry->d_inode, MAY_WRITE | MAY_EXEC); <nl>  	if (error) <nl>  		return error;
@@ -280,6 +280,7 @@ void blk_mq_free_request(struct request *rq) <nl>  	hctx = q->mq_ops->map_queue(q, ctx->cpu); <nl>  	__blk_mq_free_request(hctx, ctx, rq); <nl>  } <nl> +EXPORT_SYMBOL_GPL(blk_mq_free_request); <nl>   <nl>  inline void __blk_mq_end_request(struct request *rq, int error) <nl>  {
@@ -1322,7 +1322,9 @@ static int ibmvfc_map_sg_data(struct scsi_cmnd *scmd, <nl>  					       &evt->ext_list_token); <nl>   <nl>  		if (!evt->ext_list) { <nl> -			scmd_printk(KERN_ERR, scmd, "Can't allocate memory for scatterlist\n"); <nl> +			scsi_dma_unmap(scmd); <nl> +			if (vhost->log_level > IBMVFC_DEFAULT_LOG_LEVEL) <nl> +				scmd_printk(KERN_ERR, scmd, "Can't allocate memory for scatterlist\n"); <nl>  			return -ENOMEM; <nl>  		} <nl>  	}
@@ -1356,6 +1356,8 @@ static ssize_t tun_chr_aio_read(struct kiocb *iocb, const struct iovec *iv, <nl>  	ret = tun_do_read(tun, tfile, iocb, iv, len, <nl>  			  file->f_flags & O_NONBLOCK); <nl>  	ret = min_t(ssize_t, ret, len); <nl> +	if (ret > 0) <nl> +		iocb->ki_pos = ret; <nl>  out: <nl>  	tun_put(tun); <nl>  	return ret;
@@ -167,7 +167,7 @@ static void ixgbe_get_pauseparam(struct net_device *netdev, <nl>  	struct ixgbe_adapter *adapter = netdev_priv(netdev); <nl>  	struct ixgbe_hw *hw = &adapter->hw; <nl>   <nl> -	pause->autoneg = AUTONEG_DISABLE; <nl> +	pause->autoneg = (hw->fc.type == ixgbe_fc_full ? 1 : 0); <nl>   <nl>  	if (hw->fc.type == ixgbe_fc_rx_pause) { <nl>  		pause->rx_pause = 1; <nl> @@ -185,10 +185,8 @@ static int ixgbe_set_pauseparam(struct net_device *netdev, <nl>  	struct ixgbe_adapter *adapter = netdev_priv(netdev); <nl>  	struct ixgbe_hw *hw = &adapter->hw; <nl>   <nl> -	if (pause->autoneg == AUTONEG_ENABLE) <nl> -		return -EINVAL; <nl> - <nl> -	if (pause->rx_pause && pause->tx_pause) <nl> +	if ((pause->autoneg == AUTONEG_ENABLE) || <nl> +	    (pause->rx_pause && pause->tx_pause)) <nl>  		hw->fc.type = ixgbe_fc_full; <nl>  	else if (pause->rx_pause && !pause->tx_pause) <nl>  		hw->fc.type = ixgbe_fc_rx_pause; <nl> @@ -196,6 +194,8 @@ static int ixgbe_set_pauseparam(struct net_device *netdev, <nl>  		hw->fc.type = ixgbe_fc_tx_pause; <nl>  	else if (!pause->rx_pause && !pause->tx_pause) <nl>  		hw->fc.type = ixgbe_fc_none; <nl> +	else <nl> +		return -EINVAL; <nl>   <nl>  	hw->fc.original_type = hw->fc.type; <nl>  
@@ -1015,6 +1015,8 @@ ttm_dma_pool_shrink_scan(struct shrinker *shrink, struct shrink_control *sc) <nl>  		return SHRINK_STOP; <nl>   <nl>  	mutex_lock(&_manager->lock); <nl> +	if (!_manager->npools) <nl> +		goto out; <nl>  	pool_offset = pool_offset % _manager->npools; <nl>  	list_for_each_entry(p, &_manager->pools, pools) { <nl>  		unsigned nr_free; <nl> @@ -1034,6 +1036,7 @@ ttm_dma_pool_shrink_scan(struct shrinker *shrink, struct shrink_control *sc) <nl>  			 p->pool->dev_name, p->pool->name, current->pid, <nl>  			 nr_free, shrink_pages); <nl>  	} <nl> +out: <nl>  	mutex_unlock(&_manager->lock); <nl>  	return freed; <nl>  }
@@ -641,7 +641,8 @@ trace_print_graph_duration(unsigned long long duration, struct trace_seq *s) <nl>   <nl>  	/* Print nsecs (we don't want to exceed 7 numbers) */ <nl>  	if (len < 7) { <nl> -		snprintf(nsecs_str, 8 - len, "%03lu", nsecs_rem); <nl> +		snprintf(nsecs_str, min(sizeof(nsecs_str), 8UL - len), "%03lu", <nl> +			 nsecs_rem); <nl>  		ret = trace_seq_printf(s, ".%s", nsecs_str); <nl>  		if (!ret) <nl>  			return TRACE_TYPE_PARTIAL_LINE;
@@ -867,6 +867,8 @@ static int cipso_v4_map_cat_rbm_hton(const struct cipso_v4_doi *doi_def, <nl>  				return -EPERM; <nl>   <nl>  			net_spot = host_cat_array[host_spot]; <nl> +			if (net_spot >= CIPSO_V4_INV_CAT) <nl> +				return -EPERM; <nl>  			if (net_spot >= net_clen_bits) <nl>  				return -ENOSPC; <nl>  			cipso_v4_bitmap_setbit(net_cat, net_spot, 1); <nl> @@ -935,6 +937,8 @@ static int cipso_v4_map_cat_rbm_ntoh(const struct cipso_v4_doi *doi_def, <nl>  				return -EPERM; <nl>   <nl>  			host_spot = net_cat_array[net_spot]; <nl> +			if (host_spot >= CIPSO_V4_INV_CAT) <nl> +				return -EPERM; <nl>  			if (host_spot >= host_clen_bits) <nl>  				return -ENOSPC; <nl>  			cipso_v4_bitmap_setbit(host_cat, host_spot, 1);
@@ -803,10 +803,6 @@ static int __init nbd_init(void) <nl>  		return -EINVAL; <nl>  	} <nl>   <nl> -	nbd_dev = kcalloc(nbds_max, sizeof(*nbd_dev), GFP_KERNEL); <nl> -	if (!nbd_dev) <nl> -		return -ENOMEM; <nl> - <nl>  	part_shift = 0; <nl>  	if (max_part > 0) { <nl>  		part_shift = fls(max_part); <nl> @@ -828,6 +824,10 @@ static int __init nbd_init(void) <nl>  	if (nbds_max > 1UL << (MINORBITS - part_shift)) <nl>  		return -EINVAL; <nl>   <nl> +	nbd_dev = kcalloc(nbds_max, sizeof(*nbd_dev), GFP_KERNEL); <nl> +	if (!nbd_dev) <nl> +		return -ENOMEM; <nl> + <nl>  	for (i = 0; i < nbds_max; i++) { <nl>  		struct gendisk *disk = alloc_disk(1 << part_shift); <nl>  		if (!disk)
@@ -3424,6 +3424,7 @@ static void napi_reuse_skb(struct napi_struct *napi, struct sk_buff *skb) <nl>  	__skb_pull(skb, skb_headlen(skb)); <nl>  	skb_reserve(skb, NET_IP_ALIGN - skb_headroom(skb)); <nl>  	skb->vlan_tci = 0; <nl> +	skb->dev = napi->dev; <nl>   <nl>  	napi->skb = skb; <nl>  }
@@ -117,6 +117,9 @@ void usbip_stop_eh(struct usbip_device *ud) <nl>  { <nl>  	struct usbip_task *eh = &ud->eh; <nl>   <nl> +	if (eh->thread == current) <nl> +		return; /* do not wait for myself */ <nl> + <nl>  	wait_for_completion(&eh->thread_done); <nl>  	usbip_dbg_eh("usbip_eh has finished\n"); <nl>  }
@@ -218,8 +218,12 @@ static unsigned long clk_pllv3_av_recalc_rate(struct clk_hw *hw, <nl>  	u32 mfn = readl_relaxed(pll->base + PLL_NUM_OFFSET); <nl>  	u32 mfd = readl_relaxed(pll->base + PLL_DENOM_OFFSET); <nl>  	u32 div = readl_relaxed(pll->base) & pll->div_mask; <nl> +	u64 temp64 = (u64)parent_rate; <nl>   <nl> -	return (parent_rate * div) + ((parent_rate / mfd) * mfn); <nl> +	temp64 *= mfn; <nl> +	do_div(temp64, mfd); <nl> + <nl> +	return (parent_rate * div) + (u32)temp64; <nl>  } <nl>   <nl>  static long clk_pllv3_av_round_rate(struct clk_hw *hw, unsigned long rate, <nl> @@ -243,7 +247,7 @@ static long clk_pllv3_av_round_rate(struct clk_hw *hw, unsigned long rate, <nl>  	do_div(temp64, parent_rate); <nl>  	mfn = temp64; <nl>   <nl> -	return parent_rate * div + parent_rate / mfd * mfn; <nl> +	return parent_rate * div + parent_rate * mfn / mfd; <nl>  } <nl>   <nl>  static int clk_pllv3_av_set_rate(struct clk_hw *hw, unsigned long rate,
@@ -656,6 +656,8 @@ int rtc_irq_set_state(struct rtc_device *rtc, struct rtc_task *task, int enabled <nl>  		err = -EBUSY; <nl>  	if (rtc->irq_task != task) <nl>  		err = -EACCES; <nl> +	if (err) <nl> +		goto out; <nl>   <nl>  	if (enabled) { <nl>  		ktime_t period = ktime_set(0, NSEC_PER_SEC/rtc->irq_freq); <nl> @@ -664,6 +666,7 @@ int rtc_irq_set_state(struct rtc_device *rtc, struct rtc_task *task, int enabled <nl>  		hrtimer_cancel(&rtc->pie_timer); <nl>  	} <nl>  	rtc->pie_enabled = enabled; <nl> +out: <nl>  	spin_unlock_irqrestore(&rtc->irq_task_lock, flags); <nl>   <nl>  	return err;
@@ -1811,10 +1811,12 @@ static int zcache_comp_init(void) <nl>  #else <nl>  	if (*zcache_comp_name != '\0') { <nl>  		ret = crypto_has_comp(zcache_comp_name, 0, 0); <nl> -		if (!ret) <nl> +		if (!ret) { <nl>  			pr_info("zcache: %s not supported\n", <nl>  					zcache_comp_name); <nl> -		goto out; <nl> +			ret = 1; <nl> +			goto out; <nl> +		} <nl>  	} <nl>  	if (!ret) <nl>  		strcpy(zcache_comp_name, "lzo");
@@ -380,7 +380,7 @@ static int elm_probe(struct platform_device *pdev) <nl>  	} <nl>   <nl>  	pm_runtime_enable(&pdev->dev); <nl> -	if (pm_runtime_get_sync(&pdev->dev)) { <nl> +	if (pm_runtime_get_sync(&pdev->dev) < 0) { <nl>  		ret = -EINVAL; <nl>  		pm_runtime_disable(&pdev->dev); <nl>  		dev_err(&pdev->dev, "can't enable clock\n");
@@ -486,7 +486,7 @@ struct tally_counter { <nl>  	__le64	rx_broadcast; <nl>  	__le32	rx_multicast; <nl>  	__le16	tx_aborted; <nl> -	__le16	tx_underun; <nl> +	__le16	tx_underrun; <nl>  }; <nl>   <nl>  struct rx_desc { <nl> @@ -3420,7 +3420,7 @@ static void rtl8152_get_ethtool_stats(struct net_device *dev, <nl>  	data[9] = le64_to_cpu(tally.rx_broadcast); <nl>  	data[10] = le32_to_cpu(tally.rx_multicast); <nl>  	data[11] = le16_to_cpu(tally.tx_aborted); <nl> -	data[12] = le16_to_cpu(tally.tx_underun); <nl> +	data[12] = le16_to_cpu(tally.tx_underrun); <nl>  } <nl>   <nl>  static void rtl8152_get_strings(struct net_device *dev, u32 stringset, u8 *data)
@@ -756,6 +756,8 @@ void i40evf_virtchnl_completion(struct i40evf_adapter *adapter, <nl>  			  sizeof(struct i40e_virtchnl_vsi_resource); <nl>  		memcpy(adapter->vf_res, msg, min(msglen, len)); <nl>  		i40e_vf_parse_hw_config(&adapter->hw, adapter->vf_res); <nl> +		/* restore current mac address */ <nl> +		ether_addr_copy(adapter->hw.mac.addr, netdev->dev_addr); <nl>  		i40evf_process_config(adapter); <nl>  		} <nl>  		break;
@@ -1220,8 +1220,7 @@ static void mv_host_intr(struct ata_host_set *host_set, u32 relevant, <nl>  			handled++; <nl>  		} <nl>   <nl> -		if (ap && <nl> -		    (ap->flags & (ATA_FLAG_PORT_DISABLED | ATA_FLAG_NOINTR))) <nl> +		if (ap && (ap->flags & ATA_FLAG_PORT_DISABLED)) <nl>  			continue; <nl>   <nl>  		err_mask = ac_err_mask(ata_status); <nl> @@ -1242,7 +1241,7 @@ static void mv_host_intr(struct ata_host_set *host_set, u32 relevant, <nl>  				VPRINTK("port %u IRQ found for qc, " <nl>  					"ata_status 0x%x\n", port,ata_status); <nl>  				/* mark qc status appropriately */ <nl> -				if (!(qc->tf.ctl & ATA_NIEN)) <nl> +				if (!(qc->tf.flags & ATA_TFLAG_POLLING)) <nl>  					ata_qc_complete(qc, err_mask); <nl>  			} <nl>  		}
@@ -321,7 +321,8 @@ static void *slob_alloc(size_t size, gfp_t gfp, int align, int node) <nl>  		/* Improve fragment distribution and reduce our average <nl>  		 * search time by starting our next search here. (see <nl>  		 * Knuth vol 1, sec 2.5, pg 449) */ <nl> -		if (free_slob_pages.next != prev->next) <nl> +		if (prev != free_slob_pages.prev && <nl> +				free_slob_pages.next != prev->next) <nl>  			list_move_tail(&free_slob_pages, prev->next); <nl>  		break; <nl>  	}
@@ -50,7 +50,7 @@ nouveau_pwmfan_get(struct drm_device *dev) <nl>  	ret = nouveau_gpio_find(dev, 0, DCB_GPIO_PWM_FAN, 0xff, &gpio); <nl>  	if (ret == 0) { <nl>  		ret = pm->pwm_get(dev, gpio.line, &divs, &duty); <nl> -		if (ret == 0) { <nl> +		if (ret == 0 && divs) { <nl>  			divs = max(divs, duty); <nl>  			if (dev_priv->card_type <= NV_40 || (gpio.log[0] & 1)) <nl>  				duty = divs - duty;
@@ -199,7 +199,7 @@ static struct omap_dss_device beagle_dvi_device = { <nl>  	.name = "dvi", <nl>  	.driver_name = "generic_panel", <nl>  	.phy.dpi.data_lines = 24, <nl> -	.reset_gpio = 170, <nl> +	.reset_gpio = -EINVAL, <nl>  	.platform_enable = beagle_enable_dvi, <nl>  	.platform_disable = beagle_disable_dvi, <nl>  }; <nl> @@ -307,6 +307,12 @@ static int beagle_twl_gpio_setup(struct device *dev, <nl>  	else <nl>  		gpio_direction_output(gpio + TWL4030_GPIO_MAX, 0); <nl>   <nl> +	/* DVI reset GPIO is different between beagle revisions */ <nl> +	if (omap3_beagle_get_rev() == OMAP3BEAGLE_BOARD_XM) <nl> +		beagle_dvi_device.reset_gpio = 129; <nl> +	else <nl> +		beagle_dvi_device.reset_gpio = 170; <nl> + <nl>  	/* TWL4030_GPIO_MAX + 1 == ledB, PMU_STAT (out, active low LED) */ <nl>  	gpio_leds[2].gpio = gpio + TWL4030_GPIO_MAX + 1; <nl>  
@@ -273,7 +273,11 @@ static void usX2Y_clients_stop(struct usX2Ydev *usX2Y) <nl>  		struct snd_usX2Y_substream *subs = usX2Y->subs[s]; <nl>  		if (subs) { <nl>  			if (atomic_read(&subs->state) >= state_PRERUNNING) { <nl> +				unsigned long flags; <nl> + <nl> +				snd_pcm_stream_lock_irqsave(subs->pcm_substream, flags); <nl>  				snd_pcm_stop(subs->pcm_substream, SNDRV_PCM_STATE_XRUN); <nl> +				snd_pcm_stream_unlock_irqrestore(subs->pcm_substream, flags); <nl>  			} <nl>  			for (u = 0; u < NRURBS; u++) { <nl>  				struct urb *urb = subs->urb[u];
@@ -34,7 +34,9 @@ enum { <nl>  	POD_SYSEX_DUMPMEM   = 0x73, <nl>  	POD_SYSEX_DUMP      = 0x74, <nl>  	POD_SYSEX_DUMPREQ   = 0x75 <nl> -	/* POD_SYSEX_DUMPMEM2  = 0x76 */   /* dumps entire internal memory of PODxt Pro */ <nl> + <nl> +	/* dumps entire internal memory of PODxt Pro */ <nl> +	/* POD_SYSEX_DUMPMEM2  = 0x76 */ <nl>  }; <nl>   <nl>  enum { <nl> @@ -156,7 +158,8 @@ void line6_pod_process_message(struct usb_line6_pod *pod) <nl>   <nl>  	case LINE6_SYSEX_BEGIN | LINE6_CHANNEL_DEVICE: <nl>  	case LINE6_SYSEX_BEGIN | LINE6_CHANNEL_UNKNOWN: <nl> -		if (memcmp(buf + 1, line6_midi_id, sizeof(line6_midi_id)) == 0) { <nl> +		if (memcmp(buf + 1, line6_midi_id, <nl> +			   sizeof(line6_midi_id)) == 0) { <nl>  			switch (buf[5]) { <nl>  			case POD_SYSEX_DUMP: <nl>  				break;
@@ -321,7 +321,7 @@ get_matching_model_microcode(int cpu, unsigned long start, <nl>  	unsigned int mc_saved_count = mc_saved_data->mc_saved_count; <nl>  	int i; <nl>   <nl> -	while (leftover) { <nl> +	while (leftover && mc_saved_count < ARRAY_SIZE(mc_saved_tmp)) { <nl>  		mc_header = (struct microcode_header_intel *)ucode_ptr; <nl>   <nl>  		mc_size = get_totalsize(mc_header);
@@ -49,6 +49,8 @@ nfnl_acct_new(struct sock *nfnl, struct sk_buff *skb, <nl>  		return -EINVAL; <nl>   <nl>  	acct_name = nla_data(tb[NFACCT_NAME]); <nl> +	if (strlen(acct_name) == 0) <nl> +		return -EINVAL; <nl>   <nl>  	list_for_each_entry(nfacct, &nfnl_acct_list, head) { <nl>  		if (strncmp(nfacct->name, acct_name, NFACCT_NAME_MAX) != 0)
@@ -1295,7 +1295,7 @@ static inline void ide_dump_identify(u8 *id) <nl>  static inline int hwif_to_node(ide_hwif_t *hwif) <nl>  { <nl>  	struct pci_dev *dev = to_pci_dev(hwif->dev); <nl> -	return dev ? pcibus_to_node(dev->bus) : -1; <nl> +	return hwif->dev ? pcibus_to_node(dev->bus) : -1; <nl>  } <nl>   <nl>  static inline ide_drive_t *ide_get_paired_drive(ide_drive_t *drive)
@@ -829,12 +829,16 @@ int pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max, int pass) <nl>  			goto out; <nl>  		} <nl>   <nl> +		if (max >= bus->busn_res.end) { <nl> +			dev_warn(&dev->dev, "can't allocate child bus %02x from %pR\n", <nl> +				 max, &bus->busn_res); <nl> +			goto out; <nl> +		} <nl> + <nl>  		/* Clear errors */ <nl>  		pci_write_config_word(dev, PCI_STATUS, 0xffff); <nl>   <nl> -		/* Prevent assigning a bus number that already exists. <nl> -		 * This can happen when a bridge is hot-plugged, so in <nl> -		 * this case we only re-scan this bus. */ <nl> +		/* The bus will already exist if we are rescanning */ <nl>  		child = pci_find_bus(pci_domain_nr(bus), max+1); <nl>  		if (!child) { <nl>  			child = pci_add_new_bus(bus, dev, max+1);
@@ -1124,6 +1124,7 @@ static int get_info(struct net *net, void __user *user, <nl>  			private = &tmp; <nl>  		} <nl>  #endif <nl> +		memset(&info, 0, sizeof(info)); <nl>  		info.valid_hooks = t->valid_hooks; <nl>  		memcpy(info.hook_entry, private->hook_entry, <nl>  		       sizeof(info.hook_entry));
@@ -1306,7 +1306,12 @@ static int dpcm_add_paths(struct snd_soc_pcm_runtime *fe, int stream, <nl>   <nl>  		switch (list->widgets[i]->id) { <nl>  		case snd_soc_dapm_dai_in: <nl> +			if (stream != SNDRV_PCM_STREAM_PLAYBACK) <nl> +				continue; <nl> +			break; <nl>  		case snd_soc_dapm_dai_out: <nl> +			if (stream != SNDRV_PCM_STREAM_CAPTURE) <nl> +				continue; <nl>  			break; <nl>  		default: <nl>  			continue;
@@ -1527,6 +1527,8 @@ static int nvme_dev_add(struct nvme_dev *dev) <nl>   <nl>  	mem = dma_alloc_coherent(&dev->pci_dev->dev, 8192, &dma_addr, <nl>  								GFP_KERNEL); <nl> +	if (!mem) <nl> +		return -ENOMEM; <nl>   <nl>  	res = nvme_identify(dev, 0, 1, dma_addr); <nl>  	if (res) {
@@ -92,7 +92,7 @@ int cifs_sign_smb(struct smb_hdr *cifs_pdu, struct TCP_Server_Info *server, <nl>  		return rc; <nl>   <nl>  	if (!server->session_estab) { <nl> -		strncpy(cifs_pdu->Signature.SecuritySignature, "BSRSPYL", 8); <nl> +		memcpy(cifs_pdu->Signature.SecuritySignature, "BSRSPYL", 8); <nl>  		return rc; <nl>  	} <nl>   <nl> @@ -189,7 +189,7 @@ int cifs_sign_smb2(struct kvec *iov, int n_vec, struct TCP_Server_Info *server, <nl>  		return rc; <nl>   <nl>  	if (!server->session_estab) { <nl> -		strncpy(cifs_pdu->Signature.SecuritySignature, "BSRSPYL", 8); <nl> +		memcpy(cifs_pdu->Signature.SecuritySignature, "BSRSPYL", 8); <nl>  		return rc; <nl>  	} <nl>  
@@ -1251,6 +1251,12 @@ static void atl1_free_ring_resources(struct atl1_adapter *adapter) <nl>   <nl>  	rrd_ring->desc = NULL; <nl>  	rrd_ring->dma = 0; <nl> + <nl> +	adapter->cmb.dma = 0; <nl> +	adapter->cmb.cmb = NULL; <nl> + <nl> +	adapter->smb.dma = 0; <nl> +	adapter->smb.smb = NULL; <nl>  } <nl>   <nl>  static void atl1_setup_mac_ctrl(struct atl1_adapter *adapter)
@@ -283,8 +283,8 @@ static void rtl8225_rf_set_tx_power(struct ieee80211_hw *dev, int channel) <nl>  	u32 reg; <nl>  	int i; <nl>   <nl> -	cck_power = priv->channels[channel - 1].val & 0xFF; <nl> -	ofdm_power = priv->channels[channel - 1].val >> 8; <nl> +	cck_power = priv->channels[channel - 1].val & 0xF; <nl> +	ofdm_power = priv->channels[channel - 1].val >> 4; <nl>   <nl>  	cck_power = min(cck_power, (u8)11); <nl>  	ofdm_power = min(ofdm_power, (u8)35); <nl> @@ -500,8 +500,8 @@ static void rtl8225z2_rf_set_tx_power(struct ieee80211_hw *dev, int channel) <nl>  	u32 reg; <nl>  	int i; <nl>   <nl> -	cck_power = priv->channels[channel - 1].val & 0xFF; <nl> -	ofdm_power = priv->channels[channel - 1].val >> 8; <nl> +	cck_power = priv->channels[channel - 1].val & 0xF; <nl> +	ofdm_power = priv->channels[channel - 1].val >> 4; <nl>   <nl>  	cck_power = min(cck_power, (u8)15); <nl>  	cck_power += priv->txpwr_base & 0xF;
@@ -3944,6 +3944,8 @@ struct dvb_usb_device_properties dib0700_devices[] = { <nl>   <nl>  				DIB0700_DEFAULT_STREAMING_CONFIG(0x02), <nl>  			}}, <nl> +				.size_of_priv = sizeof(struct <nl> +						dib0700_adapter_state), <nl>  			}, { <nl>  			.num_frontends = 1, <nl>  			.fe = {{ <nl> @@ -3956,6 +3958,8 @@ struct dvb_usb_device_properties dib0700_devices[] = { <nl>   <nl>  				DIB0700_DEFAULT_STREAMING_CONFIG(0x03), <nl>  			}}, <nl> +				.size_of_priv = sizeof(struct <nl> +						dib0700_adapter_state), <nl>  			} <nl>  		}, <nl>   <nl> @@ -4009,6 +4013,8 @@ struct dvb_usb_device_properties dib0700_devices[] = { <nl>   <nl>  				DIB0700_DEFAULT_STREAMING_CONFIG(0x02), <nl>  			}}, <nl> +				.size_of_priv = sizeof(struct <nl> +						dib0700_adapter_state), <nl>  			}, <nl>  		}, <nl>  
@@ -4427,6 +4427,9 @@ static void alc269_fill_coef(struct hda_codec *codec) <nl>   <nl>  	if (spec->codec_variant != ALC269_TYPE_ALC269VB) <nl>  		return; <nl> +	/* ALC271X doesn't seem to support these COEFs (bko#52181) */ <nl> +	if (!strcmp(codec->chip_name, "ALC271X")) <nl> +		return; <nl>   <nl>  	if ((alc_get_coef0(codec) & 0x00ff) < 0x015) { <nl>  		alc_write_coef_idx(codec, 0xf, 0x960b);
@@ -37,9 +37,6 @@ MODULE_PARM_DESC(debug, "set debugging level" DVB_USB_DEBUG_STATUS); <nl>  static int dvb_usb_af9015_remote; <nl>  module_param_named(remote, dvb_usb_af9015_remote, int, 0644); <nl>  MODULE_PARM_DESC(remote, "select remote"); <nl> -static int dvb_usb_af9015_dual_mode; <nl> -module_param_named(dual_mode, dvb_usb_af9015_dual_mode, int, 0644); <nl> -MODULE_PARM_DESC(dual_mode, "enable dual mode"); <nl>  DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr); <nl>   <nl>  static DEFINE_MUTEX(af9015_usb_mutex); <nl> @@ -836,9 +833,6 @@ static int af9015_read_config(struct usb_device *udev) <nl>  		goto error; <nl>  	af9015_config.dual_mode = val; <nl>  	deb_info("%s: TS mode:%d\n", __func__, af9015_config.dual_mode); <nl> -	/* disable dual mode by default because it is buggy */ <nl> -	if (!dvb_usb_af9015_dual_mode) <nl> -		af9015_config.dual_mode = 0; <nl>   <nl>  	/* Set adapter0 buffer size according to USB port speed, adapter1 buffer <nl>  	   size can be static because it is enabled only USB2.0 */
@@ -1069,6 +1069,7 @@ static void passdown_endio(struct bio *bio) <nl>  	 * to unmap (we ignore err). <nl>  	 */ <nl>  	queue_passdown_pt2(bio->bi_private); <nl> +	bio_put(bio); <nl>  } <nl>   <nl>  static void process_prepared_discard_passdown_pt1(struct dm_thin_new_mapping *m)
@@ -1000,8 +1000,15 @@ EXPORT_SYMBOL(set_memory_array_uc); <nl>   <nl>  int _set_memory_wc(unsigned long addr, int numpages) <nl>  { <nl> -	return change_page_attr_set(&addr, numpages, <nl> +	int ret; <nl> +	ret = change_page_attr_set(&addr, numpages, <nl> +				    __pgprot(_PAGE_CACHE_UC_MINUS), 0); <nl> + <nl> +	if (!ret) { <nl> +		ret = change_page_attr_set(&addr, numpages, <nl>  				    __pgprot(_PAGE_CACHE_WC), 0); <nl> +	} <nl> +	return ret; <nl>  } <nl>   <nl>  int set_memory_wc(unsigned long addr, int numpages)
@@ -1109,8 +1109,7 @@ struct net_device * __init ltpc_probe(void) <nl>  	inb_p(io+1); <nl>  	inb_p(io+3); <nl>   <nl> -	set_current_state(TASK_UNINTERRUPTIBLE); <nl> -	schedule_timeout(2*HZ/100); <nl> +	msleep(20); <nl>   <nl>  	inb_p(io+0); <nl>  	inb_p(io+2); <nl> @@ -1120,8 +1119,7 @@ struct net_device * __init ltpc_probe(void) <nl>  	inb_p(io+5); /* enable dma */ <nl>  	inb_p(io+6); /* tri-state interrupt line */ <nl>   <nl> -	set_current_state(TASK_UNINTERRUPTIBLE); <nl> -	schedule_timeout(HZ); <nl> +	ssleep(1); <nl>  	 <nl>  	/* now, figure out which dma channel we're using, unless it's <nl>  	   already been specified */
@@ -363,7 +363,6 @@ void omap_sram_idle(void) <nl>  		printk(KERN_ERR "Invalid mpu state in sram_idle\n"); <nl>  		return; <nl>  	} <nl> -	pwrdm_pre_transition(); <nl>   <nl>  	/* NEON control */ <nl>  	if (pwrdm_read_pwrst(neon_pwrdm) == PWRDM_POWER_ON) <nl> @@ -386,6 +385,8 @@ void omap_sram_idle(void) <nl>  			if (!console_trylock()) <nl>  				goto console_still_active; <nl>   <nl> +	pwrdm_pre_transition(); <nl> + <nl>  	/* PER */ <nl>  	if (per_next_state < PWRDM_POWER_ON) { <nl>  		per_going_off = (per_next_state == PWRDM_POWER_OFF) ? 1 : 0; <nl> @@ -455,6 +456,8 @@ void omap_sram_idle(void) <nl>  	} <nl>  	omap3_intc_resume_idle(); <nl>   <nl> +	pwrdm_post_transition(); <nl> + <nl>  	/* PER */ <nl>  	if (per_next_state < PWRDM_POWER_ON) { <nl>  		per_prev_state = pwrdm_read_prev_pwrst(per_pwrdm); <nl> @@ -478,8 +481,6 @@ console_still_active: <nl>  		omap3_disable_io_chain(); <nl>  	} <nl>   <nl> -	pwrdm_post_transition(); <nl> - <nl>  	clkdm_allow_idle(mpu_pwrdm->pwrdm_clkdms[0]); <nl>  } <nl>  
@@ -1424,9 +1424,13 @@ int ath9k_hw_reset(struct ath_hw *ah, struct ath9k_channel *chan, <nl>  				"Setting CFG 0x%x\n", REG_READ(ah, AR_CFG)); <nl>  		} <nl>  	} else { <nl> -		/* Configure AR9271 target WLAN */ <nl> -                if (AR_SREV_9271(ah)) <nl> -			REG_WRITE(ah, AR_CFG, AR_CFG_SWRB | AR_CFG_SWTB); <nl> +		if (common->bus_ops->ath_bus_type == ATH_USB) { <nl> +			/* Configure AR9271 target WLAN */ <nl> +			if (AR_SREV_9271(ah)) <nl> +				REG_WRITE(ah, AR_CFG, AR_CFG_SWRB | AR_CFG_SWTB); <nl> +			else <nl> +				REG_WRITE(ah, AR_CFG, AR_CFG_SWTD | AR_CFG_SWRD); <nl> +		} <nl>  #ifdef __BIG_ENDIAN <nl>                  else <nl>  			REG_WRITE(ah, AR_CFG, AR_CFG_SWTD | AR_CFG_SWRD);
@@ -467,6 +467,8 @@ static int oom_kill_process(struct task_struct *p, gfp_t gfp_mask, int order, <nl>   <nl>  			if (child->mm == p->mm) <nl>  				continue; <nl> +			if (child->flags & PF_KTHREAD) <nl> +				continue; <nl>  			if (mem && !task_in_mem_cgroup(child, mem)) <nl>  				continue; <nl>  			if (!has_intersects_mems_allowed(child, nodemask))
@@ -232,7 +232,7 @@ static const struct icmp_control icmp_pointers[NR_ICMP_TYPES+1]; <nl>  static DEFINE_PER_CPU(struct socket *, __icmp_socket) = NULL; <nl>  #define icmp_socket	__get_cpu_var(__icmp_socket) <nl>   <nl> -static __inline__ int icmp_xmit_lock(void) <nl> +static inline int icmp_xmit_lock(void) <nl>  { <nl>  	local_bh_disable(); <nl>   <nl> @@ -246,7 +246,7 @@ static __inline__ int icmp_xmit_lock(void) <nl>  	return 0; <nl>  } <nl>   <nl> -static void icmp_xmit_unlock(void) <nl> +static inline void icmp_xmit_unlock(void) <nl>  { <nl>  	spin_unlock_bh(&icmp_socket->sk->sk_lock.slock); <nl>  }
@@ -188,7 +188,7 @@ static ssize_t bcm_char_read(struct file *filp, <nl>  	struct bcm_tarang_data *tarang = filp->private_data; <nl>  	struct bcm_mini_adapter *ad = tarang->Adapter; <nl>  	struct sk_buff *Packet = NULL; <nl> -	ssize_t PktLen = 0; <nl> +	ssize_t pkt_len = 0; <nl>  	int wait_ret_val = 0; <nl>  	unsigned long ret = 0; <nl>   <nl> @@ -224,9 +224,9 @@ static ssize_t bcm_char_read(struct file *filp, <nl>  	up(&ad->RxAppControlQueuelock); <nl>   <nl>  	if (Packet) { <nl> -		PktLen = Packet->len; <nl> +		pkt_len = Packet->len; <nl>  		ret = copy_to_user(buf, Packet->data, <nl> -				   min_t(size_t, PktLen, size)); <nl> +				   min_t(size_t, pkt_len, size)); <nl>  		if (ret) { <nl>  			dev_kfree_skb(Packet); <nl>  			BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0, <nl> @@ -235,12 +235,12 @@ static ssize_t bcm_char_read(struct file *filp, <nl>  		} <nl>  		BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, <nl>  				"Read %zd Bytes From Adapter packet = %p by process %d!\n", <nl> -				PktLen, Packet, current->pid); <nl> +				pkt_len, Packet, current->pid); <nl>  		dev_kfree_skb(Packet); <nl>  	} <nl>   <nl>  	BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, "<\n"); <nl> -	return PktLen; <nl> +	return pkt_len; <nl>  } <nl>   <nl>  static int bcm_char_ioctl_reg_read_private(void __user *argp,
@@ -143,14 +143,18 @@ static struct dentry *reconnect_one(struct vfsmount *mnt, <nl>  	if (err) <nl>  		goto out_err; <nl>  	dprintk("%s: found name: %s\n", __func__, nbuf); <nl> -	inode_lock(parent->d_inode); <nl> -	tmp = lookup_one_len(nbuf, parent, strlen(nbuf)); <nl> -	inode_unlock(parent->d_inode); <nl> +	tmp = lookup_one_len_unlocked(nbuf, parent, strlen(nbuf)); <nl>  	if (IS_ERR(tmp)) { <nl>  		dprintk("%s: lookup failed: %d\n", __func__, PTR_ERR(tmp)); <nl>  		goto out_err; <nl>  	} <nl>  	if (tmp != dentry) { <nl> +		/* <nl> +		 * Somebody has renamed it since exportfs_get_name(); <nl> +		 * great, since it could've only been renamed if it <nl> +		 * got looked up and thus connected, and it would <nl> +		 * remain connected afterwards.  We are done. <nl> +		 */ <nl>  		dput(tmp); <nl>  		goto out_reconnected; <nl>  	}
@@ -730,7 +730,8 @@ static void ttm_put_pages(struct page **pages, unsigned npages, int flags, <nl>  			} <nl>   <nl>  #ifdef CONFIG_TRANSPARENT_HUGEPAGE <nl> -			if (!(flags & TTM_PAGE_FLAG_DMA32)) { <nl> +			if (!(flags & TTM_PAGE_FLAG_DMA32) && <nl> +			    (npages - i) >= HPAGE_PMD_NR) { <nl>  				for (j = 0; j < HPAGE_PMD_NR; ++j) <nl>  					if (p++ != pages[i + j]) <nl>  					    break; <nl> @@ -759,7 +760,7 @@ static void ttm_put_pages(struct page **pages, unsigned npages, int flags, <nl>  		unsigned max_size, n2free; <nl>   <nl>  		spin_lock_irqsave(&huge->lock, irq_flags); <nl> -		while (i < npages) { <nl> +		while ((npages - i) >= HPAGE_PMD_NR) { <nl>  			struct page *p = pages[i]; <nl>  			unsigned j; <nl>  
@@ -485,6 +485,7 @@ static int load_firmware(struct dvb_frontend *fe, unsigned int type, <nl>  						  (*p) & 0x7f); <nl>  					return -EINVAL; <nl>  				} <nl> +				break; <nl>  			default: <nl>  				tuner_info("Invalid RESET code %d\n", <nl>  					   size & 0x7f);
@@ -59,9 +59,11 @@ int mem_check_range(struct rxe_mem *mem, u64 iova, size_t length) <nl>   <nl>  	case RXE_MEM_TYPE_MR: <nl>  	case RXE_MEM_TYPE_FMR: <nl> -		return ((iova < mem->iova) || <nl> -			((iova + length) > (mem->iova + mem->length))) ? <nl> -			-EFAULT : 0; <nl> +		if (iova < mem->iova || <nl> +		    length > mem->length || <nl> +		    iova > mem->iova + mem->length - length) <nl> +			return -EFAULT; <nl> +		return 0; <nl>   <nl>  	default: <nl>  		return -EFAULT;
@@ -922,7 +922,7 @@ static int ntfs_write_mst_block(struct page *page, <nl>  	ntfs_volume *vol = ni->vol; <nl>  	u8 *kaddr; <nl>  	unsigned int rec_size = ni->itype.index.block_size; <nl> -	ntfs_inode *locked_nis[PAGE_SIZE / rec_size]; <nl> +	ntfs_inode *locked_nis[PAGE_SIZE / NTFS_BLOCK_SIZE]; <nl>  	struct buffer_head *bh, *head, *tbh, *rec_start_bh; <nl>  	struct buffer_head *bhs[MAX_BUF_PER_PAGE]; <nl>  	runlist_element *rl; <nl> @@ -931,6 +931,9 @@ static int ntfs_write_mst_block(struct page *page, <nl>  	bool sync, is_mft, page_is_dirty, rec_is_dirty; <nl>  	unsigned char bh_size_bits; <nl>   <nl> +	if (WARN_ON(rec_size < NTFS_BLOCK_SIZE)) <nl> +		return -EINVAL; <nl> + <nl>  	ntfs_debug("Entering for inode 0x%lx, attribute type 0x%x, page index " <nl>  			"0x%lx.", vi->i_ino, ni->type, page->index); <nl>  	BUG_ON(!NInoNonResident(ni));
@@ -401,7 +401,7 @@ static int wl1271_prepare_tx_frame(struct wl1271 *wl, struct wl12xx_vif *wlvif, <nl>  		is_wep = (cipher == WLAN_CIPHER_SUITE_WEP40) || <nl>  			 (cipher == WLAN_CIPHER_SUITE_WEP104); <nl>   <nl> -		if (WARN_ON(is_wep && wlvif->default_key != idx)) { <nl> +		if (WARN_ON(is_wep && wlvif && wlvif->default_key != idx)) { <nl>  			ret = wl1271_set_default_wep_key(wl, wlvif, idx); <nl>  			if (ret < 0) <nl>  				return ret;
@@ -81,6 +81,7 @@ void free_user_ns(struct kref *kref) <nl>  	struct user_namespace *ns; <nl>   <nl>  	ns = container_of(kref, struct user_namespace, kref); <nl> +	free_uid(ns->root_user); <nl>  	kfree(ns); <nl>  } <nl>  
@@ -97,7 +97,6 @@ void __init paging_init(void) <nl>   <nl>  	mem_map = NODE_DATA(0)->node_mem_map; <nl>   <nl> -	memset(zero_page, 0, PAGE_SIZE); <nl>  	empty_zero_page = virt_to_page(zero_page); <nl>  	flush_dcache_page(empty_zero_page); <nl>  }
@@ -249,8 +249,8 @@ static noinline int cow_file_range_inline(struct btrfs_root *root, <nl>  		data_len = compressed_size; <nl>   <nl>  	if (start > 0 || <nl> -	    actual_end >= PAGE_CACHE_SIZE || <nl> -	    data_len >= BTRFS_MAX_INLINE_DATA_SIZE(root) || <nl> +	    actual_end > PAGE_CACHE_SIZE || <nl> +	    data_len > BTRFS_MAX_INLINE_DATA_SIZE(root) || <nl>  	    (!compressed_size && <nl>  	    (actual_end & (root->sectorsize - 1)) == 0) || <nl>  	    end + 1 < isize ||
@@ -1872,8 +1872,11 @@ static int __do_request(struct ceph_mds_client *mdsc, <nl>  	int mds = -1; <nl>  	int err = -EAGAIN; <nl>   <nl> -	if (req->r_err || req->r_got_result) <nl> +	if (req->r_err || req->r_got_result) { <nl> +		if (req->r_aborted) <nl> +			__unregister_request(mdsc, req); <nl>  		goto out; <nl> +	} <nl>   <nl>  	if (req->r_timeout && <nl>  	    time_after_eq(jiffies, req->r_started + req->r_timeout)) {
@@ -1057,6 +1057,7 @@ static int yam_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd) <nl>  		break; <nl>   <nl>  	case SIOCYAMGCFG: <nl> +		memset(&yi, 0, sizeof(yi)); <nl>  		yi.cfg.mask = 0xffffffff; <nl>  		yi.cfg.iobase = yp->iobase; <nl>  		yi.cfg.irq = yp->irq;
@@ -143,6 +143,8 @@ static inline int kvm_apic_id(struct kvm_lapic *apic) <nl>  	return (kvm_apic_get_reg(apic, APIC_ID) >> 24) & 0xff; <nl>  } <nl>   <nl> +#define KVM_X2APIC_CID_BITS 0 <nl> + <nl>  static void recalculate_apic_map(struct kvm *kvm) <nl>  { <nl>  	struct kvm_apic_map *new, *old = NULL; <nl> @@ -180,7 +182,8 @@ static void recalculate_apic_map(struct kvm *kvm) <nl>  		if (apic_x2apic_mode(apic)) { <nl>  			new->ldr_bits = 32; <nl>  			new->cid_shift = 16; <nl> -			new->cid_mask = new->lid_mask = 0xffff; <nl> +			new->cid_mask = (1 << KVM_X2APIC_CID_BITS) - 1; <nl> +			new->lid_mask = 0xffff; <nl>  		} else if (kvm_apic_sw_enabled(apic) && <nl>  				!new->cid_mask /* flat mode */ && <nl>  				kvm_apic_get_reg(apic, APIC_DFR) == APIC_DFR_CLUSTER) {
@@ -880,6 +880,8 @@ static void igmp_heard_query(struct in_device *in_dev, struct sk_buff *skb, <nl>  		 * to be intended in a v3 query. <nl>  		 */ <nl>  		max_delay = IGMPV3_MRC(ih3->code)*(HZ/IGMP_TIMER_SCALE); <nl> +		if (!max_delay) <nl> +			max_delay = 1;	/* can't mod w/ 0 */ <nl>  	} else { /* v3 */ <nl>  		if (!pskb_may_pull(skb, sizeof(struct igmpv3_query))) <nl>  			return;
@@ -73,8 +73,8 @@ static int vidioc_querycap(struct file *file, void *fh, <nl>  { <nl>  	struct capture_priv *priv = video_drvdata(file); <nl>   <nl> -	strncpy(cap->driver, "imx-media-capture", sizeof(cap->driver) - 1); <nl> -	strncpy(cap->card, "imx-media-capture", sizeof(cap->card) - 1); <nl> +	strlcpy(cap->driver, "imx-media-capture", sizeof(cap->driver)); <nl> +	strlcpy(cap->card, "imx-media-capture", sizeof(cap->card)); <nl>  	snprintf(cap->bus_info, sizeof(cap->bus_info), <nl>  		 "platform:%s", priv->src_sd->name); <nl>  
@@ -987,8 +987,8 @@ static int tridentfb_pan_display(struct fb_var_screeninfo *var, <nl>  	unsigned int offset; <nl>   <nl>  	debug("enter\n"); <nl> -	offset = (var->xoffset + (var->yoffset * var->xres_virtual)) <nl> -		* var->bits_per_pixel / 32; <nl> +	offset = (var->xoffset + (var->yoffset * info->var.xres_virtual)) <nl> +		* info->var.bits_per_pixel / 32; <nl>  	set_screen_start(par, offset); <nl>  	debug("exit\n"); <nl>  	return 0;
@@ -1560,7 +1560,7 @@ static int ext4_xattr_set_entry(struct ext4_xattr_info *i, <nl>  				handle_t *handle, struct inode *inode, <nl>  				bool is_block) <nl>  { <nl> -	struct ext4_xattr_entry *last; <nl> +	struct ext4_xattr_entry *last, *next; <nl>  	struct ext4_xattr_entry *here = s->here; <nl>  	size_t min_offs = s->end - s->base, name_len = strlen(i->name); <nl>  	int in_inode = i->in_inode; <nl> @@ -1595,7 +1595,13 @@ static int ext4_xattr_set_entry(struct ext4_xattr_info *i, <nl>   <nl>  	/* Compute min_offs and last. */ <nl>  	last = s->first; <nl> -	for (; !IS_LAST_ENTRY(last); last = EXT4_XATTR_NEXT(last)) { <nl> +	for (; !IS_LAST_ENTRY(last); last = next) { <nl> +		next = EXT4_XATTR_NEXT(last); <nl> +		if ((void *)next >= s->end) { <nl> +			EXT4_ERROR_INODE(inode, "corrupted xattr entries"); <nl> +			ret = -EFSCORRUPTED; <nl> +			goto out; <nl> +		} <nl>  		if (!last->e_value_inum && last->e_value_size) { <nl>  			size_t offs = le16_to_cpu(last->e_value_offs); <nl>  			if (offs < min_offs)
@@ -802,8 +802,10 @@ do_sigbus(struct pt_regs *regs, unsigned long error_code, unsigned long address, <nl>  	up_read(&mm->mmap_sem); <nl>   <nl>  	/* Kernel mode? Handle exceptions or die: */ <nl> -	if (!(error_code & PF_USER)) <nl> +	if (!(error_code & PF_USER)) { <nl>  		no_context(regs, error_code, address); <nl> +		return; <nl> +	} <nl>   <nl>  	/* User-space => ok to do another page fault: */ <nl>  	if (is_prefetch(regs, error_code, address))
@@ -348,6 +348,12 @@ static int is_gpt_valid(struct parsed_partitions *state, u64 lba, <nl>  		goto fail; <nl>  	} <nl>   <nl> +	/* Check that sizeof_partition_entry has the correct value */ <nl> +	if (le32_to_cpu((*gpt)->sizeof_partition_entry) != sizeof(gpt_entry)) { <nl> +		pr_debug("GUID Partitition Entry Size check failed.\n"); <nl> +		goto fail; <nl> +	} <nl> + <nl>  	if (!(*ptes = alloc_read_gpt_entries(state, *gpt))) <nl>  		goto fail; <nl>  
@@ -225,6 +225,9 @@ struct ehci_hcd {			/* one per controller */ <nl>  #ifdef DEBUG <nl>  	struct dentry		*debug_dir; <nl>  #endif <nl> + <nl> +	/* platform-specific data -- must come last */ <nl> +	unsigned long		priv[0] __aligned(sizeof(s64)); <nl>  }; <nl>   <nl>  /* convert between an HCD pointer and the corresponding EHCI_HCD */
@@ -1636,6 +1636,12 @@ static int emac_poll_rx(void *param, int budget) <nl>  			goto next; <nl>  		} <nl>   <nl> +		if (len < ETH_HLEN) { <nl> +			++dev->estats.rx_dropped_stack; <nl> +			emac_recycle_rx_skb(dev, slot, len); <nl> +			goto next; <nl> +		} <nl> + <nl>  		if (len && len < EMAC_RX_COPY_THRESH) { <nl>  			struct sk_buff *copy_skb = <nl>  			    alloc_skb(len + EMAC_RX_SKB_HEADROOM + 2, GFP_ATOMIC);
@@ -623,6 +623,7 @@ static int gs_can_open(struct net_device *netdev) <nl>  					   rc); <nl>   <nl>  				usb_unanchor_urb(urb); <nl> +				usb_free_urb(urb); <nl>  				break; <nl>  			} <nl>  
@@ -1514,6 +1514,7 @@ batadv_nc_skb_decode_packet(struct batadv_priv *bat_priv, struct sk_buff *skb, <nl>  	struct ethhdr *ethhdr, ethhdr_tmp; <nl>  	uint8_t *orig_dest, ttl, ttvn; <nl>  	unsigned int coding_len; <nl> +	int err; <nl>   <nl>  	/* Save headers temporarily */ <nl>  	memcpy(&coded_packet_tmp, skb->data, sizeof(coded_packet_tmp)); <nl> @@ -1568,8 +1569,11 @@ batadv_nc_skb_decode_packet(struct batadv_priv *bat_priv, struct sk_buff *skb, <nl>  			 coding_len); <nl>   <nl>  	/* Resize decoded skb if decoded with larger packet */ <nl> -	if (nc_packet->skb->len > coding_len + h_size) <nl> -		pskb_trim_rcsum(skb, coding_len + h_size); <nl> +	if (nc_packet->skb->len > coding_len + h_size) { <nl> +		err = pskb_trim_rcsum(skb, coding_len + h_size); <nl> +		if (err) <nl> +			return NULL; <nl> +	} <nl>   <nl>  	/* Create decoded unicast packet */ <nl>  	unicast_packet = (struct batadv_unicast_packet *)skb->data;
@@ -14,7 +14,7 @@ static ssize_t bundle_class_show(struct device *dev, <nl>  { <nl>  	struct gb_bundle *bundle = to_gb_bundle(dev); <nl>   <nl> -	return sprintf(buf, "%d\n", bundle->class); <nl> +	return sprintf(buf, "0x%02x\n", bundle->class); <nl>  } <nl>  static DEVICE_ATTR_RO(bundle_class); <nl>  
@@ -955,6 +955,7 @@ int rtl92ce_hw_init(struct ieee80211_hw *hw) <nl>  	local_save_flags(flags); <nl>  	local_irq_enable(); <nl>   <nl> +	rtlhal->fw_ready = false; <nl>  	rtlpriv->intf_ops->disable_aspm(hw); <nl>  	rtstatus = _rtl92ce_init_mac(hw); <nl>  	if (!rtstatus) { <nl> @@ -971,6 +972,7 @@ int rtl92ce_hw_init(struct ieee80211_hw *hw) <nl>  		goto exit; <nl>  	} <nl>   <nl> +	rtlhal->fw_ready = true; <nl>  	rtlhal->last_hmeboxnum = 0; <nl>  	rtl92c_phy_mac_config(hw); <nl>  	/* because last function modify RCR, so we update
@@ -298,6 +298,9 @@ static bool hist_browser__toggle_fold(struct hist_browser *browser) <nl>  	struct callchain_list *cl = container_of(ms, struct callchain_list, ms); <nl>  	bool has_children; <nl>   <nl> +	if (!he || !ms) <nl> +		return false; <nl> + <nl>  	if (ms == &he->ms) <nl>  		has_children = hist_entry__toggle_fold(he); <nl>  	else
@@ -899,6 +899,12 @@ static int i2c_pxa_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[], int num <nl>  	struct pxa_i2c *i2c = adap->algo_data; <nl>  	int ret, i; <nl>   <nl> +	/* If the I2C controller is disabled we need to reset it (probably due <nl> + 	   to a suspend/resume destroying state). We do this here as we can then <nl> + 	   avoid worrying about resuming the controller before its users. */ <nl> +	if (!(ICR & ICR_IUE)) <nl> +		i2c_pxa_reset(i2c); <nl> + <nl>  	for (i = adap->retries; i >= 0; i--) { <nl>  		ret = i2c_pxa_do_xfer(i2c, msgs, num); <nl>  		if (ret != I2C_RETRY) <nl> @@ -939,7 +945,9 @@ static struct pxa_i2c i2c_pxa = { <nl>  static int i2c_pxa_probe(struct platform_device *dev) <nl>  { <nl>  	struct pxa_i2c *i2c = &i2c_pxa; <nl> +#ifdef CONFIG_I2C_PXA_SLAVE <nl>  	struct i2c_pxa_platform_data *plat = dev->dev.platform_data; <nl> +#endif <nl>  	int ret; <nl>   <nl>  #ifdef CONFIG_PXA27x <nl> @@ -1024,5 +1032,7 @@ static void i2c_adap_pxa_exit(void) <nl>  	return platform_driver_unregister(&i2c_pxa_driver); <nl>  } <nl>   <nl> +MODULE_LICENSE("GPL"); <nl> + <nl>  module_init(i2c_adap_pxa_init); <nl>  module_exit(i2c_adap_pxa_exit);
@@ -4261,9 +4261,9 @@ static int svm_check_intercept(struct kvm_vcpu *vcpu, <nl>  		if (info->intercept == x86_intercept_in || <nl>  		    info->intercept == x86_intercept_ins) { <nl>  			exit_info |= SVM_IOIO_TYPE_MASK; <nl> -			bytes = info->src_bytes; <nl> -		} else { <nl>  			bytes = info->dst_bytes; <nl> +		} else { <nl> +			bytes = info->src_bytes; <nl>  		} <nl>   <nl>  		if (info->intercept == x86_intercept_outs ||
@@ -83,8 +83,16 @@ static inline unsigned long ppc_function_entry(void *func) <nl>  	 * On PPC64 ABIv1 the function pointer actually points to the <nl>  	 * function's descriptor. The first entry in the descriptor is the <nl>  	 * address of the function text. <nl> +	 * <nl> +	 * However, we may also receive pointer to an assembly symbol. To <nl> +	 * detect that, we first check if the function pointer we receive <nl> +	 * already points to kernel/module text and we only dereference it <nl> +	 * if it doesn't. <nl>  	 */ <nl> -	return ((func_descr_t *)func)->entry; <nl> +	if (kernel_text_address((unsigned long)func)) <nl> +		return (unsigned long)func; <nl> +	else <nl> +		return ((func_descr_t *)func)->entry; <nl>  #else <nl>  	return (unsigned long)func; <nl>  #endif
@@ -105,11 +105,6 @@ static void iwl_mvm_quota_iterator(void *_data, u8 *mac, <nl>  	if (WARN_ON_ONCE(id >= MAX_BINDINGS)) <nl>  		return; <nl>   <nl> -	if (data->colors[id] < 0) <nl> -		data->colors[id] = mvmvif->phy_ctxt->color; <nl> -	else <nl> -		WARN_ON_ONCE(data->colors[id] != mvmvif->phy_ctxt->color); <nl> - <nl>  	if (data->type == IWL_MVM_QUOTA_UPDATE_TYPE_DISABLED && <nl>  	    vif == data->vif) <nl>  		return; <nl> @@ -135,6 +130,11 @@ static void iwl_mvm_quota_iterator(void *_data, u8 *mac, <nl>  		return; <nl>  	} <nl>   <nl> +	if (data->colors[id] < 0) <nl> +		data->colors[id] = mvmvif->phy_ctxt->color; <nl> +	else <nl> +		WARN_ON_ONCE(data->colors[id] != mvmvif->phy_ctxt->color); <nl> + <nl>  	data->n_interfaces[id]++; <nl>   <nl>  	if (iwl_mvm_vif_low_latency(mvmvif) && !data->low_latency[id]) {
@@ -540,6 +540,8 @@ struct cfg80211_bss *cfg80211_get_bss(struct wiphy *wiphy, <nl>  			continue; <nl>  		if (channel && bss->pub.channel != channel) <nl>  			continue; <nl> +		if (!is_valid_ether_addr(bss->pub.bssid)) <nl> +			continue; <nl>  		/* Don't get expired BSS structs */ <nl>  		if (time_after(now, bss->ts + IEEE80211_SCAN_RESULT_EXPIRE) && <nl>  		    !atomic_read(&bss->hold))
@@ -590,6 +590,7 @@ int fb_find_mode(struct fb_var_screeninfo *var, <nl>  		    "", (margins) ? " with margins" : "", (interlace) ? <nl>  		    " interlaced" : ""); <nl>   <nl> +	    memset(&cvt_mode, 0, sizeof(cvt_mode)); <nl>  	    cvt_mode.xres = xres; <nl>  	    cvt_mode.yres = yres; <nl>  	    cvt_mode.refresh = (refresh) ? refresh : 60;
@@ -1663,8 +1663,10 @@ SYSCALL_DEFINE4(epoll_ctl, int, epfd, int, op, int, fd, <nl>  	if (op == EPOLL_CTL_ADD) { <nl>  		if (is_file_epoll(tfile)) { <nl>  			error = -ELOOP; <nl> -			if (ep_loop_check(ep, tfile) != 0) <nl> +			if (ep_loop_check(ep, tfile) != 0) { <nl> +				clear_tfile_check_list(); <nl>  				goto error_tgt_fput; <nl> +			} <nl>  		} else <nl>  			list_add(&tfile->f_tfile_llink, &tfile_check_list); <nl>  	}
@@ -28,7 +28,7 @@ static inline struct s3c_gpio_chip *s3c_gpiolib_getchip(unsigned int pin) <nl>  		return NULL; <nl>   <nl>  	chip = &s3c24xx_gpios[pin/32]; <nl> -	return (S3C2410_GPIO_OFFSET(pin) > chip->chip.ngpio) ? chip : NULL; <nl> +	return (S3C2410_GPIO_OFFSET(pin) < chip->chip.ngpio) ? chip : NULL; <nl>  } <nl>   <nl>  #endif /* __ASM_ARCH_GPIO_CORE_H */
@@ -477,7 +477,7 @@ static bool device_init_rings(struct vnt_private *priv) <nl>  					     CB_MAX_BUF_SIZE, <nl>  					     &priv->tx_bufs_dma0, <nl>  					     GFP_ATOMIC); <nl> -	if (priv->tx0_bufs == NULL) { <nl> +	if (!priv->tx0_bufs) { <nl>  		dev_err(&priv->pcid->dev, "allocate buf dma memory failed\n"); <nl>   <nl>  		dma_free_coherent(&priv->pcid->dev,
@@ -5020,6 +5020,8 @@ static int sky2_probe(struct pci_dev *pdev, const struct pci_device_id *ent) <nl>  		} <nl>   	} <nl>   <nl> +	netif_napi_add(dev, &hw->napi, sky2_poll, NAPI_WEIGHT); <nl> + <nl>  	err = register_netdev(dev); <nl>  	if (err) { <nl>  		dev_err(&pdev->dev, "cannot register net device\n"); <nl> @@ -5028,8 +5030,6 @@ static int sky2_probe(struct pci_dev *pdev, const struct pci_device_id *ent) <nl>   <nl>  	netif_carrier_off(dev); <nl>   <nl> -	netif_napi_add(dev, &hw->napi, sky2_poll, NAPI_WEIGHT); <nl> - <nl>  	sky2_show_addr(dev); <nl>   <nl>  	if (hw->ports > 1) {
@@ -2124,7 +2124,7 @@ static void smsc_ircc_sir_wait_hw_transmitter_finish(struct smsc_ircc_cb *self) <nl>  	while (count-- > 0 && !(inb(iobase + UART_LSR) & UART_LSR_TEMT)) <nl>  		udelay(1); <nl>   <nl> -	if (count == 0) <nl> +	if (count < 0) <nl>  		IRDA_DEBUG(0, "%s(): stuck transmitter\n", __func__); <nl>  } <nl>  
@@ -2535,13 +2535,14 @@ static void iwl3945_alive_start(struct iwl_priv *priv) <nl>  	/* Configure Bluetooth device coexistence support */ <nl>  	priv->cfg->ops->hcmd->send_bt_config(priv); <nl>   <nl> +	set_bit(STATUS_READY, &priv->status); <nl> + <nl>  	/* Configure the adapter for unassociated operation */ <nl>  	iwl3945_commit_rxon(priv, ctx); <nl>   <nl>  	iwl3945_reg_txpower_periodic(priv); <nl>   <nl>  	IWL_DEBUG_INFO(priv, "ALIVE processing complete.\n"); <nl> -	set_bit(STATUS_READY, &priv->status); <nl>  	wake_up_interruptible(&priv->wait_command_queue); <nl>   <nl>  	return;
@@ -543,8 +543,8 @@ static int gxt4500_pan_display(struct fb_var_screeninfo *var, <nl>   <nl>  	if (var->xoffset & 7) <nl>  		return -EINVAL; <nl> -	if (var->xoffset + var->xres > var->xres_virtual || <nl> -	    var->yoffset + var->yres > var->yres_virtual) <nl> +	if (var->xoffset + info->var.xres > info->var.xres_virtual || <nl> +	    var->yoffset + info->var.yres > info->var.yres_virtual) <nl>  		return -EINVAL; <nl>   <nl>  	writereg(par, REFRESH_START, (var->xoffset << 16) | var->yoffset);
@@ -1640,7 +1640,10 @@ static int cb_pcidas_attach(struct comedi_device *dev, <nl>   <nl>  	/* 8255 */ <nl>  	s = dev->subdevices + 2; <nl> -	subdev_8255_init(dev, s, NULL, devpriv->pacer_counter_dio + DIO_8255); <nl> +	ret = subdev_8255_init(dev, s, NULL, <nl> +			       devpriv->pacer_counter_dio + DIO_8255); <nl> +	if (ret) <nl> +		return ret; <nl>   <nl>  	/*  serial EEPROM, */ <nl>  	s = dev->subdevices + 3;
@@ -1403,11 +1403,12 @@ static int xc2028_set_config(struct dvb_frontend *fe, void *priv_cfg) <nl>  	 * in order to avoid troubles during device release. <nl>  	 */ <nl>  	kfree(priv->ctrl.fname); <nl> +	priv->ctrl.fname = NULL; <nl>  	memcpy(&priv->ctrl, p, sizeof(priv->ctrl)); <nl>  	if (p->fname) { <nl>  		priv->ctrl.fname = kstrdup(p->fname, GFP_KERNEL); <nl>  		if (priv->ctrl.fname == NULL) <nl> -			rc = -ENOMEM; <nl> +			return -ENOMEM; <nl>  	} <nl>   <nl>  	/*
@@ -310,7 +310,10 @@ static int atmel_ssc_set_dai_clkdiv(struct snd_soc_dai *cpu_dai, <nl>  		 * transmit and receive, so if a value has already <nl>  		 * been set, it must match this value. <nl>  		 */ <nl> -		if (ssc_p->cmr_div == 0) <nl> +		if (ssc_p->dir_mask != <nl> +			(SSC_DIR_MASK_PLAYBACK | SSC_DIR_MASK_CAPTURE)) <nl> +			ssc_p->cmr_div = div; <nl> +		else if (ssc_p->cmr_div == 0) <nl>  			ssc_p->cmr_div = div; <nl>  		else <nl>  			if (div != ssc_p->cmr_div)
@@ -300,6 +300,8 @@ int __init acpi_table_init(void) <nl>   <nl>  static int __init acpi_parse_apic_instance(char *str) <nl>  { <nl> +	if (!str) <nl> +		return -EINVAL; <nl>   <nl>  	acpi_apic_instance = simple_strtoul(str, NULL, 0); <nl>  
@@ -897,6 +897,10 @@ static void arm_ccn_pmu_xp_dt_config(struct perf_event *event, int enable) <nl>  	struct arm_ccn_component *xp; <nl>  	u32 val, dt_cfg; <nl>   <nl> +	/* Nothing to do for cycle counter */ <nl> +	if (hw->idx == CCN_IDX_PMU_CYCLE_COUNTER) <nl> +		return; <nl> + <nl>  	if (CCN_CONFIG_TYPE(event->attr.config) == CCN_TYPE_XP) <nl>  		xp = &ccn->xp[CCN_CONFIG_XP(event->attr.config)]; <nl>  	else
@@ -227,8 +227,10 @@ static ssize_t rpmsg_eptdev_write_iter(struct kiocb *iocb, <nl>  	if (!kbuf) <nl>  		return -ENOMEM; <nl>   <nl> -	if (!copy_from_iter_full(kbuf, len, from)) <nl> -		return -EFAULT; <nl> +	if (!copy_from_iter_full(kbuf, len, from)) { <nl> +		ret = -EFAULT; <nl> +		goto free_kbuf; <nl> +	} <nl>   <nl>  	if (mutex_lock_interruptible(&eptdev->ept_lock)) { <nl>  		ret = -ERESTARTSYS;
@@ -449,6 +449,10 @@ static void bcm_sysport_get_stats(struct net_device *dev, <nl>  			p = (char *)&dev->stats; <nl>  		else <nl>  			p = (char *)priv; <nl> + <nl> +		if (priv->is_lite && !bcm_sysport_lite_stat_valid(s->type)) <nl> +			continue; <nl> + <nl>  		p += s->stat_offset; <nl>  		data[j] = *(unsigned long *)p; <nl>  		j++;
@@ -2751,6 +2751,11 @@ static int ath5k_add_interface(struct ieee80211_hw *hw, <nl>  		ret = -EOPNOTSUPP; <nl>  		goto end; <nl>  	} <nl> + <nl> +	/* Set to a reasonable value. Note that this will <nl> +	 * be set to mac80211's value at ath5k_config(). */ <nl> +	sc->bintval = 1000; <nl> + <nl>  	ret = 0; <nl>  end: <nl>  	mutex_unlock(&sc->lock); <nl> @@ -2795,9 +2800,6 @@ ath5k_config_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif, <nl>  	struct ath5k_hw *ah = sc->ah; <nl>  	int ret; <nl>   <nl> -	/* Set to a reasonable value. Note that this will <nl> -	 * be set to mac80211's value at ath5k_config(). */ <nl> -	sc->bintval = 1000; <nl>  	mutex_lock(&sc->lock); <nl>  	if (sc->vif != vif) { <nl>  		ret = -EIO;
@@ -1,3 +1,4 @@ <nl> +// SPDX-License-Identifier: GPL-2.0 <nl>  /* <nl>   * Watchdog driver for IMX2 and later processors <nl>   * <nl> @@ -7,10 +8,6 @@ <nl>   * some parts adapted by similar drivers from Darius Augulis and Vladimir <nl>   * Zapolskiy, additional improvements by Wim Van Sebroeck. <nl>   * <nl> - * This program is free software; you can redistribute it and/or modify it <nl> - * under the terms of the GNU General Public License version 2 as published by <nl> - * the Free Software Foundation. <nl> - * <nl>   * NOTE: MX1 has a slightly different Watchdog than MX2 and later: <nl>   * <nl>   *			MX1:		MX2+:
@@ -143,7 +143,7 @@ int yama_task_prctl(int option, unsigned long arg2, unsigned long arg3, <nl>  		if (arg2 == 0) { <nl>  			yama_ptracer_del(NULL, myself); <nl>  			rc = 0; <nl> -		} else if (arg2 == PR_SET_PTRACER_ANY) { <nl> +		} else if (arg2 == PR_SET_PTRACER_ANY || (int)arg2 == -1) { <nl>  			rc = yama_ptracer_add(NULL, myself); <nl>  		} else { <nl>  			struct task_struct *tracer;
@@ -1241,10 +1241,20 @@ static void __devinit pnv_pci_ioda_setup_seg(void) <nl>  	} <nl>  } <nl>   <nl> +static void __devinit pnv_pci_ioda_setup_DMA(void) <nl> +{ <nl> +	struct pci_controller *hose, *tmp; <nl> + <nl> +	list_for_each_entry_safe(hose, tmp, &hose_list, list_node) { <nl> +		pnv_ioda_setup_dma(hose->private_data); <nl> +	} <nl> +} <nl> + <nl>  static void __devinit pnv_pci_ioda_fixup(void) <nl>  { <nl>  	pnv_pci_ioda_setup_PEs(); <nl>  	pnv_pci_ioda_setup_seg(); <nl> +	pnv_pci_ioda_setup_DMA(); <nl>  } <nl>   <nl>  /*
@@ -246,6 +246,8 @@ int vt_waitactive(int n) <nl>   * <nl>   * XXX It should at least call into the driver, fbdev's definitely need to <nl>   * restore their engine state. --BenH <nl> + * <nl> + * Called with the console lock held. <nl>   */ <nl>  static int vt_kdsetmode(struct vc_data *vc, unsigned long mode) <nl>  { <nl> @@ -262,7 +264,6 @@ static int vt_kdsetmode(struct vc_data *vc, unsigned long mode) <nl>  		return -EINVAL; <nl>  	} <nl>   <nl> -	/* FIXME: this needs the console lock extending */ <nl>  	if (vc->vc_mode == mode) <nl>  		return 0; <nl>   <nl> @@ -271,12 +272,10 @@ static int vt_kdsetmode(struct vc_data *vc, unsigned long mode) <nl>  		return 0; <nl>   <nl>  	/* explicitly blank/unblank the screen if switching modes */ <nl> -	console_lock(); <nl>  	if (mode == KD_TEXT) <nl>  		do_unblank_screen(1); <nl>  	else <nl>  		do_blank_screen(1); <nl> -	console_unlock(); <nl>   <nl>  	return 0; <nl>  } <nl> @@ -378,7 +377,10 @@ static int vt_k_ioctl(struct tty_struct *tty, unsigned int cmd, <nl>  		if (!perm) <nl>  			return -EPERM; <nl>   <nl> -		return vt_kdsetmode(vc, arg); <nl> +		console_lock(); <nl> +		ret = vt_kdsetmode(vc, arg); <nl> +		console_unlock(); <nl> +		return ret; <nl>   <nl>  	case KDGETMODE: <nl>  		return put_user(vc->vc_mode, (int __user *)arg);
@@ -1190,6 +1190,7 @@ int qed_dcbx_get_config_params(struct qed_hwfn *p_hwfn, <nl>  	if (!dcbx_info) <nl>  		return -ENOMEM; <nl>   <nl> +	memset(dcbx_info, 0, sizeof(*dcbx_info)); <nl>  	rc = qed_dcbx_query_params(p_hwfn, dcbx_info, QED_DCBX_OPERATIONAL_MIB); <nl>  	if (rc) { <nl>  		kfree(dcbx_info); <nl> @@ -1225,6 +1226,7 @@ static struct qed_dcbx_get *qed_dcbnl_get_dcbx(struct qed_hwfn *hwfn, <nl>  	if (!dcbx_info) <nl>  		return NULL; <nl>   <nl> +	memset(dcbx_info, 0, sizeof(*dcbx_info)); <nl>  	if (qed_dcbx_query_params(hwfn, dcbx_info, type)) { <nl>  		kfree(dcbx_info); <nl>  		return NULL;
@@ -59,7 +59,11 @@ void string_get_size(u64 size, u64 blk_size, const enum string_size_units units, <nl>  	} <nl>   <nl>  	exp = divisor[units] / (u32)blk_size; <nl> -	if (size >= exp) { <nl> +	/* <nl> +	 * size must be strictly greater than exp here to ensure that remainder <nl> +	 * is greater than divisor[units] coming out of the if below. <nl> +	 */ <nl> +	if (size > exp) { <nl>  		remainder = do_div(size, divisor[units]); <nl>  		remainder *= blk_size; <nl>  		i++;
@@ -20,7 +20,10 @@ int ceph_mdsmap_get_random_mds(struct ceph_mdsmap *m) <nl>  { <nl>  	int n = 0; <nl>  	int i; <nl> -	char r; <nl> + <nl> +	/* special case for one mds */ <nl> +	if (1 == m->m_max_mds && m->m_info[0].state > 0) <nl> +		return 0; <nl>   <nl>  	/* count */ <nl>  	for (i = 0; i < m->m_max_mds; i++) <nl> @@ -30,8 +33,7 @@ int ceph_mdsmap_get_random_mds(struct ceph_mdsmap *m) <nl>  		return -1; <nl>   <nl>  	/* pick */ <nl> -	get_random_bytes(&r, 1); <nl> -	n = r % n; <nl> +	n = prandom_u32() % n; <nl>  	i = 0; <nl>  	for (i = 0; n > 0; i++, n--) <nl>  		while (m->m_info[i].state <= 0)
@@ -458,7 +458,7 @@ static int set_group_key(struct rtw_adapter *padapter, struct key_params *parms, <nl>   <nl>  	pcmd->cmdcode = _SetKey_CMD_; <nl>  	pcmd->parmbuf = (u8 *) psetkeyparm; <nl> -	pcmd->cmdsz = (sizeof(struct setkey_parm)); <nl> +	pcmd->cmdsz = sizeof(struct setkey_parm); <nl>  	pcmd->rsp = NULL; <nl>  	pcmd->rspsz = 0; <nl>   <nl> @@ -2197,7 +2197,7 @@ static int cfg80211_rtw_get_txpower(struct wiphy *wiphy, <nl>  				    struct wireless_dev *wdev, int *dbm) <nl>  { <nl>  	DBG_8723A("%s\n", __func__); <nl> -	*dbm = (12); <nl> +	*dbm = 12; <nl>  	return 0; <nl>  } <nl>  
@@ -695,6 +695,7 @@ void iwl_clear_ucode_stations(struct iwl_priv *priv, <nl>  void iwl_restore_stations(struct iwl_priv *priv, struct iwl_rxon_context *ctx) <nl>  { <nl>  	struct iwl_addsta_cmd sta_cmd; <nl> +	static const struct iwl_link_quality_cmd zero_lq = {}; <nl>  	struct iwl_link_quality_cmd lq; <nl>  	int i; <nl>  	bool found = false; <nl> @@ -733,7 +734,9 @@ void iwl_restore_stations(struct iwl_priv *priv, struct iwl_rxon_context *ctx) <nl>  				else <nl>  					memcpy(&lq, priv->stations[i].lq, <nl>  					       sizeof(struct iwl_link_quality_cmd)); <nl> -				send_lq = true; <nl> + <nl> +				if (!memcmp(&lq, &zero_lq, sizeof(lq))) <nl> +					send_lq = true; <nl>  			} <nl>  			spin_unlock_bh(&priv->sta_lock); <nl>  			ret = iwl_send_add_sta(priv, &sta_cmd, CMD_SYNC);
@@ -154,6 +154,8 @@ static int apci3120_auto_attach(struct comedi_device *dev, <nl>  	devpriv->amcc = pci_resource_start(pcidev, 0); <nl>  	devpriv->addon = pci_resource_start(pcidev, 2); <nl>   <nl> +	apci3120_reset(dev); <nl> + <nl>  	if (pcidev->irq > 0) { <nl>  		ret = request_irq(pcidev->irq, apci3120_interrupt, IRQF_SHARED, <nl>  				  dev->board_name, dev); <nl> @@ -232,7 +234,6 @@ static int apci3120_auto_attach(struct comedi_device *dev, <nl>  	s->insn_read	= apci3120_read_insn_timer; <nl>  	s->insn_config	= apci3120_config_insn_timer; <nl>   <nl> -	apci3120_reset(dev); <nl>  	return 0; <nl>  } <nl>  
@@ -116,6 +116,10 @@ static ssize_t rng_dev_read(struct file *filp, char __user *buf, <nl>  		err = -EAGAIN; <nl>  		if (!bytes_read && (filp->f_flags & O_NONBLOCK)) <nl>  			goto out; <nl> +		if (bytes_read < 0) { <nl> +			err = bytes_read; <nl> +			goto out; <nl> +		} <nl>   <nl>  		err = -EFAULT; <nl>  		while (bytes_read && size) {
@@ -963,14 +963,16 @@ static int fsl_edma_probe(struct platform_device *pdev) <nl>   <nl>  	ret = dma_async_device_register(&fsl_edma->dma_dev); <nl>  	if (ret) { <nl> -		dev_err(&pdev->dev, "Can't register Freescale eDMA engine.\n"); <nl> +		dev_err(&pdev->dev, <nl> +			"Can't register Freescale eDMA engine. (%d)\n", ret); <nl>  		fsl_disable_clocks(fsl_edma); <nl>  		return ret; <nl>  	} <nl>   <nl>  	ret = of_dma_controller_register(np, fsl_edma_xlate, fsl_edma); <nl>  	if (ret) { <nl> -		dev_err(&pdev->dev, "Can't register Freescale eDMA of_dma.\n"); <nl> +		dev_err(&pdev->dev, <nl> +			"Can't register Freescale eDMA of_dma. (%d)\n", ret); <nl>  		dma_async_device_unregister(&fsl_edma->dma_dev); <nl>  		fsl_disable_clocks(fsl_edma); <nl>  		return ret;
@@ -2562,6 +2562,10 @@ static int rtl8192eu_parse_efuse(struct rtl8xxxu_priv *priv) <nl>  				 raw[i + 6], raw[i + 7]); <nl>  		} <nl>  	} <nl> +	/* <nl> +	 * Temporarily disable 8192eu support <nl> +	 */ <nl> +	return -EINVAL; <nl>  	return 0; <nl>  } <nl>  
@@ -284,6 +284,7 @@ static int iwl_store_ucode_sec(struct iwl_firmware_pieces *pieces, <nl>   <nl>  	sec->offset = le32_to_cpu(sec_parse->offset); <nl>  	sec->data = sec_parse->data; <nl> +	sec->size = size - sizeof(sec_parse->offset); <nl>   <nl>  	++img->sec_counter; <nl>  
@@ -3166,7 +3166,8 @@ static int hns_roce_v2_modify_qp(struct ib_qp *ibqp, <nl>  		   (cur_state == IB_QPS_RTR && new_state == IB_QPS_ERR) || <nl>  		   (cur_state == IB_QPS_RTS && new_state == IB_QPS_ERR) || <nl>  		   (cur_state == IB_QPS_SQD && new_state == IB_QPS_ERR) || <nl> -		   (cur_state == IB_QPS_SQE && new_state == IB_QPS_ERR)) { <nl> +		   (cur_state == IB_QPS_SQE && new_state == IB_QPS_ERR) || <nl> +		   (cur_state == IB_QPS_ERR && new_state == IB_QPS_ERR)) { <nl>  		/* Nothing */ <nl>  		; <nl>  	} else {
@@ -2373,7 +2373,7 @@ qla2x00_do_dpc(void *data) <nl>  					} else { <nl>  						fcport->login_retry = 0; <nl>  					} <nl> -					if (fcport->login_retry == 0) <nl> +					if (fcport->login_retry == 0 && status != QLA_SUCCESS) <nl>  						fcport->loop_id = FC_NO_LOOP_ID; <nl>  				} <nl>  				if (test_bit(LOOP_RESYNC_NEEDED, &ha->dpc_flags))
@@ -2193,8 +2193,8 @@ static int pl022_probe(struct amba_device *adev, const struct amba_id *id) <nl>  		status = -ENOMEM; <nl>  		goto err_no_ioremap; <nl>  	} <nl> -	printk(KERN_INFO "pl022: mapped registers from 0x%08x to %p\n", <nl> -	       adev->res.start, pl022->virtbase); <nl> +	printk(KERN_INFO "pl022: mapped registers from %pa to %p\n", <nl> +	       &adev->res.start, pl022->virtbase); <nl>   <nl>  	pl022->clk = devm_clk_get(&adev->dev, NULL); <nl>  	if (IS_ERR(pl022->clk)) {
@@ -2635,8 +2635,10 @@ static u32 Handle_ListenStateExpired(struct host_if_drv *hif_drv, <nl>  		wid.size = 2; <nl>  		wid.val = kmalloc(wid.size, GFP_KERNEL); <nl>   <nl> -		if (!wid.val) <nl> +		if (!wid.val) { <nl>  			PRINT_ER("Failed to allocate memory\n"); <nl> +			return -ENOMEM; <nl> +		} <nl>   <nl>  		wid.val[0] = u8remain_on_chan_flag; <nl>  		wid.val[1] = FALSE_FRMWR_CHANNEL;
@@ -87,6 +87,13 @@ static void ax25_kill_by_device(struct net_device *dev) <nl>  	ax25_for_each(s, &ax25_list) { <nl>  		if (s->ax25_dev == ax25_dev) { <nl>  			sk = s->sk; <nl> +			if (!sk) { <nl> +				spin_unlock_bh(&ax25_list_lock); <nl> +				s->ax25_dev = NULL; <nl> +				ax25_disconnect(s, ENETUNREACH); <nl> +				spin_lock_bh(&ax25_list_lock); <nl> +				goto again; <nl> +			} <nl>  			sock_hold(sk); <nl>  			spin_unlock_bh(&ax25_list_lock); <nl>  			lock_sock(sk);
@@ -1010,8 +1010,9 @@ int vt_ioctl(struct tty_struct *tty, struct file * file, <nl>  			if (ret) <nl>  				break; <nl>  			/* Commence switch and lock */ <nl> -			set_console(arg); <nl> +			set_console(vsa.console); <nl>  		} <nl> +		break; <nl>  	} <nl>   <nl>  	/*
@@ -885,11 +885,13 @@ static void pm8001_dev_gone_notify(struct domain_device *dev) <nl>  	u32 tag; <nl>  	struct pm8001_hba_info *pm8001_ha; <nl>  	struct pm8001_device *pm8001_dev = dev->lldd_dev; <nl> -	u32 device_id = pm8001_dev->device_id; <nl> + <nl>  	pm8001_ha = pm8001_find_ha_by_dev(dev); <nl>  	spin_lock_irqsave(&pm8001_ha->lock, flags); <nl>  	pm8001_tag_alloc(pm8001_ha, &tag); <nl>  	if (pm8001_dev) { <nl> +		u32 device_id = pm8001_dev->device_id; <nl> + <nl>  		PM8001_DISC_DBG(pm8001_ha, <nl>  			pm8001_printk("found dev[%d:%x] is gone.\n", <nl>  			pm8001_dev->device_id, pm8001_dev->dev_type));
@@ -484,6 +484,7 @@ static int btrfs_dev_replace_finishing(struct btrfs_fs_info *fs_info, <nl>  	WARN_ON(ret); <nl>   <nl>  	/* keep away write_all_supers() during the finishing procedure */ <nl> +	mutex_lock(&root->fs_info->chunk_mutex); <nl>  	mutex_lock(&root->fs_info->fs_devices->device_list_mutex); <nl>  	btrfs_dev_replace_lock(dev_replace); <nl>  	dev_replace->replace_state = <nl> @@ -503,6 +504,7 @@ static int btrfs_dev_replace_finishing(struct btrfs_fs_info *fs_info, <nl>  			      rcu_str_deref(tgt_device->name), scrub_ret); <nl>  		btrfs_dev_replace_unlock(dev_replace); <nl>  		mutex_unlock(&root->fs_info->fs_devices->device_list_mutex); <nl> +		mutex_unlock(&root->fs_info->chunk_mutex); <nl>  		if (tgt_device) <nl>  			btrfs_destroy_dev_replace_tgtdev(fs_info, tgt_device); <nl>  		mutex_unlock(&dev_replace->lock_finishing_cancel_unmount); <nl> @@ -543,6 +545,7 @@ static int btrfs_dev_replace_finishing(struct btrfs_fs_info *fs_info, <nl>  	 */ <nl>  	btrfs_dev_replace_unlock(dev_replace); <nl>  	mutex_unlock(&root->fs_info->fs_devices->device_list_mutex); <nl> +	mutex_unlock(&root->fs_info->chunk_mutex); <nl>   <nl>  	/* write back the superblocks */ <nl>  	trans = btrfs_start_transaction(root, 0);
@@ -955,6 +955,11 @@ asmlinkage long sys_migrate_pages(pid_t pid, unsigned long maxnode, <nl>  		goto out; <nl>  	} <nl>   <nl> +	if (!nodes_subset(new, node_online_map)) { <nl> +		err = -EINVAL; <nl> +		goto out; <nl> +	} <nl> + <nl>  	err = security_task_movememory(task); <nl>  	if (err) <nl>  		goto out;
@@ -3233,8 +3233,10 @@ static int set_geometry(unsigned int cmd, struct floppy_struct *g, <nl>  	int cnt; <nl>   <nl>  	/* sanity checking for parameters. */ <nl> -	if (g->sect <= 0 || <nl> -	    g->head <= 0 || <nl> +	if ((int)g->sect <= 0 || <nl> +	    (int)g->head <= 0 || <nl> +	    /* check for overflow in max_sector */ <nl> +	    (int)(g->sect * g->head) <= 0 || <nl>  	    /* check for zero in F_SECT_PER_TRACK */ <nl>  	    (unsigned char)((g->sect << 2) >> FD_SIZECODE(g)) == 0 || <nl>  	    g->track <= 0 || g->track > UDP->tracks >> STRETCH(g) ||
@@ -1920,6 +1920,11 @@ tracing_iter_ctrl_write(struct file *filp, const char __user *ubuf, <nl>  			break; <nl>  		} <nl>  	} <nl> +	/* <nl> +	 * If no option could be set, return an error: <nl> +	 */ <nl> +	if (!trace_options[i]) <nl> +		return -EINVAL; <nl>   <nl>  	filp->f_pos += cnt; <nl>  
@@ -495,8 +495,7 @@ void __init mem_init(void) <nl>   <nl>  	pci_iommu_alloc(); <nl>   <nl> -	/* clear the zero-page */ <nl> -	memset(empty_zero_page, 0, PAGE_SIZE); <nl> +	/* clear_bss() already clear the empty_zero_page */ <nl>   <nl>  	reservedpages = 0; <nl>  
@@ -2853,6 +2853,9 @@ int tipc_nl_publ_dump(struct sk_buff *skb, struct netlink_callback *cb) <nl>  		if (err) <nl>  			return err; <nl>   <nl> +		if (!attrs[TIPC_NLA_SOCK]) <nl> +			return -EINVAL; <nl> + <nl>  		err = nla_parse_nested(sock, TIPC_NLA_SOCK_MAX, <nl>  				       attrs[TIPC_NLA_SOCK], <nl>  				       tipc_nl_sock_policy);
@@ -1376,6 +1376,7 @@ static ssize_t fuse_dev_splice_read(struct file *in, loff_t *ppos, <nl>  		 * code can Oops if the buffer persists after module unload. <nl>  		 */ <nl>  		bufs[page_nr].ops = &nosteal_pipe_buf_ops; <nl> +		bufs[page_nr].flags = 0; <nl>  		ret = add_to_pipe(pipe, &bufs[page_nr++]); <nl>  		if (unlikely(ret < 0)) <nl>  			break;
@@ -736,11 +736,14 @@ static int getoptions(char *c, struct trusted_key_payload *pay, <nl>  	int res; <nl>  	unsigned long handle; <nl>  	unsigned long lock; <nl> +	unsigned long token_mask = 0; <nl>   <nl>  	while ((p = strsep(&c, " \t"))) { <nl>  		if (*p == '\0' || *p == ' ' || *p == '\t') <nl>  			continue; <nl>  		token = match_token(p, key_tokens, args); <nl> +		if (test_and_set_bit(token, &token_mask)) <nl> +			return -EINVAL; <nl>   <nl>  		switch (token) { <nl>  		case Opt_pcrinfo:
@@ -52,6 +52,7 @@ static inline pte_t huge_ptep_get_and_clear(struct mm_struct *mm, <nl>  static inline void huge_ptep_clear_flush(struct vm_area_struct *vma, <nl>  					 unsigned long addr, pte_t *ptep) <nl>  { <nl> +	ptep_clear_flush(vma, addr, ptep); <nl>  } <nl>   <nl>  static inline int huge_pte_none(pte_t pte)
@@ -202,12 +202,13 @@ get_endpoints(struct usbtest_dev *dev, struct usb_interface *intf) <nl>  			return tmp; <nl>  	} <nl>   <nl> -	if (in) { <nl> +	if (in) <nl>  		dev->in_pipe = usb_rcvbulkpipe(udev, <nl>  			in->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK); <nl> +	if (out) <nl>  		dev->out_pipe = usb_sndbulkpipe(udev, <nl>  			out->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK); <nl> -	} <nl> + <nl>  	if (iso_in) { <nl>  		dev->iso_in = &iso_in->desc; <nl>  		dev->in_iso_pipe = usb_rcvisocpipe(udev,
@@ -351,6 +351,16 @@ static int chap_server_compute_md5( <nl>  		pr_err("Unable to convert incoming challenge\n"); <nl>  		goto out; <nl>  	} <nl> +	/* <nl> +	 * During mutual authentication, the CHAP_C generated by the <nl> +	 * initiator must not match the original CHAP_C generated by <nl> +	 * the target. <nl> +	 */ <nl> +	if (!memcmp(challenge_binhex, chap->challenge, CHAP_CHALLENGE_LENGTH)) { <nl> +		pr_err("initiator CHAP_C matches target CHAP_C, failing" <nl> +		       " login attempt\n"); <nl> +		goto out; <nl> +	} <nl>  	/* <nl>  	 * Generate CHAP_N and CHAP_R for mutual authentication. <nl>  	 */
@@ -182,6 +182,8 @@ static enum io_status ccwreq_status(struct ccw_device *cdev, struct irb *lcirb) <nl>  		/* Ask the driver what to do */ <nl>  		if (cdev->drv && cdev->drv->uc_handler) { <nl>  			todo = cdev->drv->uc_handler(cdev, lcirb); <nl> +			CIO_TRACE_EVENT(2, "uc_response"); <nl> +			CIO_HEX_EVENT(2, &todo, sizeof(todo)); <nl>  			switch (todo) { <nl>  			case UC_TODO_RETRY: <nl>  				return IO_STATUS_ERROR;
@@ -70,7 +70,7 @@ static struct clk *rockchip_clk_register_branch(const char *name, <nl>  	if (gate_offset >= 0) { <nl>  		gate = kzalloc(sizeof(*gate), GFP_KERNEL); <nl>  		if (!gate) <nl> -			return ERR_PTR(-ENOMEM); <nl> +			goto err_gate; <nl>   <nl>  		gate->flags = gate_flags; <nl>  		gate->reg = base + gate_offset; <nl> @@ -82,7 +82,7 @@ static struct clk *rockchip_clk_register_branch(const char *name, <nl>  	if (div_width > 0) { <nl>  		div = kzalloc(sizeof(*div), GFP_KERNEL); <nl>  		if (!div) <nl> -			return ERR_PTR(-ENOMEM); <nl> +			goto err_div; <nl>   <nl>  		div->flags = div_flags; <nl>  		div->reg = base + muxdiv_offset; <nl> @@ -100,6 +100,11 @@ static struct clk *rockchip_clk_register_branch(const char *name, <nl>  				     flags); <nl>   <nl>  	return clk; <nl> +err_div: <nl> +	kfree(gate); <nl> +err_gate: <nl> +	kfree(mux); <nl> +	return ERR_PTR(-ENOMEM); <nl>  } <nl>   <nl>  struct rockchip_clk_frac {
@@ -828,13 +828,17 @@ static int dn_dev_get_first(struct net_device *dev, __le16 *addr) <nl>  	struct dn_dev *dn_db = (struct dn_dev *)dev->dn_ptr; <nl>  	struct dn_ifaddr *ifa; <nl>  	int rv = -ENODEV; <nl> + <nl>  	if (dn_db == NULL) <nl>  		goto out; <nl> + <nl> +	rtnl_lock(); <nl>  	ifa = dn_db->ifa_list; <nl>  	if (ifa != NULL) { <nl>  		*addr = ifa->ifa_local; <nl>  		rv = 0; <nl>  	} <nl> +	rtnl_unlock(); <nl>  out: <nl>  	return rv; <nl>  }
@@ -1007,7 +1007,7 @@ static int kenvctrld(void *__unused) <nl>  		return -ENODEV; <nl>  	} <nl>   <nl> -	poll_interval = 5 * HZ; /* TODO env_mon_interval */ <nl> +	poll_interval = 5000; /* TODO env_mon_interval */ <nl>   <nl>  	daemonize("kenvctrld"); <nl>  	allow_signal(SIGKILL); <nl> @@ -1016,10 +1016,7 @@ static int kenvctrld(void *__unused) <nl>   <nl>  	printk(KERN_INFO "envctrl: %s starting...\n", current->comm); <nl>  	for (;;) { <nl> -		current->state = TASK_INTERRUPTIBLE; <nl> -		schedule_timeout(poll_interval); <nl> - <nl> -		if(signal_pending(current)) <nl> +		if(msleep_interruptible(poll_interval)) <nl>  			break; <nl>   <nl>  		for (whichcpu = 0; whichcpu < ENVCTRL_MAX_CPU; ++whichcpu) {
@@ -3263,7 +3263,7 @@ static void alc_auto_init_extra_out(struct hda_codec *codec) <nl>  	int i; <nl>  	hda_nid_t pin, dac; <nl>   <nl> -	for (i = 0; i < spec->autocfg.speaker_outs; i++) { <nl> +	for (i = 0; i < spec->autocfg.hp_outs; i++) { <nl>  		pin = spec->autocfg.hp_pins[i]; <nl>  		if (!pin) <nl>  			break;
@@ -879,14 +879,9 @@ static void gdm_usb_disconnect(struct usb_interface *intf) <nl>  { <nl>  	struct phy_dev *phy_dev; <nl>  	struct lte_udev *udev; <nl> -	u16 idVendor, idProduct; <nl>  	struct usb_device *usbdev; <nl>   <nl>  	usbdev = interface_to_usbdev(intf); <nl> - <nl> -	idVendor = __le16_to_cpu(usbdev->descriptor.idVendor); <nl> -	idProduct = __le16_to_cpu(usbdev->descriptor.idProduct); <nl> - <nl>  	phy_dev = usb_get_intfdata(intf); <nl>   <nl>  	udev = phy_dev->priv_dev;
@@ -704,10 +704,12 @@ static int create_trace_probe(int argc, char **argv) <nl>  		ret = parse_probe_arg(arg, &tp->args[i].fetch, is_return); <nl>  		if (ret) { <nl>  			pr_info("Parse error at argument%d. (%d)\n", i, ret); <nl> +			kfree(tp->args[i].name); <nl>  			goto error; <nl>  		} <nl> + <nl> +		tp->nr_args++; <nl>  	} <nl> -	tp->nr_args = i; <nl>   <nl>  	ret = register_trace_probe(tp); <nl>  	if (ret)
@@ -258,11 +258,11 @@ static int __inet6_check_established(struct inet_timewait_death_row *death_row, <nl>   <nl>  	if (twp != NULL) { <nl>  		*twp = tw; <nl> -		NET_INC_STATS_BH(twsk_net(tw), LINUX_MIB_TIMEWAITRECYCLED); <nl> +		NET_INC_STATS_BH(net, LINUX_MIB_TIMEWAITRECYCLED); <nl>  	} else if (tw != NULL) { <nl>  		/* Silly. Should hash-dance instead... */ <nl>  		inet_twsk_deschedule(tw, death_row); <nl> -		NET_INC_STATS_BH(twsk_net(tw), LINUX_MIB_TIMEWAITRECYCLED); <nl> +		NET_INC_STATS_BH(net, LINUX_MIB_TIMEWAITRECYCLED); <nl>   <nl>  		inet_twsk_put(tw); <nl>  	}
@@ -4344,7 +4344,7 @@ hub_port_init(struct usb_hub *hub, struct usb_device *udev, int port1, <nl>  { <nl>  	struct usb_device	*hdev = hub->hdev; <nl>  	struct usb_hcd		*hcd = bus_to_hcd(hdev->bus); <nl> -	int			i, j, retval; <nl> +	int			retries, operations, retval, i; <nl>  	unsigned		delay = HUB_SHORT_RESET_TIME; <nl>  	enum usb_device_speed	oldspeed = udev->speed; <nl>  	const char		*speed; <nl> @@ -4449,7 +4449,7 @@ hub_port_init(struct usb_hub *hub, struct usb_device *udev, int port1, <nl>  	 * first 8 bytes of the device descriptor to get the ep0 maxpacket <nl>  	 * value. <nl>  	 */ <nl> -	for (i = 0; i < GET_DESCRIPTOR_TRIES; (++i, msleep(100))) { <nl> +	for (retries = 0; retries < GET_DESCRIPTOR_TRIES; (++retries, msleep(100))) { <nl>  		bool did_new_scheme = false; <nl>   <nl>  		if (use_new_scheme(udev, retry_counter)) { <nl> @@ -4476,7 +4476,7 @@ hub_port_init(struct usb_hub *hub, struct usb_device *udev, int port1, <nl>  			 * 255 is for WUSB devices, we actually need to use <nl>  			 * 512 (WUSB1.0[4.8.1]). <nl>  			 */ <nl> -			for (j = 0; j < 3; ++j) { <nl> +			for (operations = 0; operations < 3; ++operations) { <nl>  				buf->bMaxPacketSize0 = 0; <nl>  				r = usb_control_msg(udev, usb_rcvaddr0pipe(), <nl>  					USB_REQ_GET_DESCRIPTOR, USB_DIR_IN, <nl> @@ -4502,7 +4502,7 @@ hub_port_init(struct usb_hub *hub, struct usb_device *udev, int port1, <nl>  				 * reset. But only on the first attempt, <nl>  				 * lest we get into a time out/reset loop <nl>  				 */ <nl> -				if (r == 0  || (r == -ETIMEDOUT && j == 0)) <nl> +				if (r == 0  || (r == -ETIMEDOUT && retries == 0)) <nl>  					break; <nl>  			} <nl>  			udev->descriptor.bMaxPacketSize0 = <nl> @@ -4534,7 +4534,7 @@ hub_port_init(struct usb_hub *hub, struct usb_device *udev, int port1, <nl>  		 * authorization will assign the final address. <nl>  		 */ <nl>  		if (udev->wusb == 0) { <nl> -			for (j = 0; j < SET_ADDRESS_TRIES; ++j) { <nl> +			for (operations = 0; operations < SET_ADDRESS_TRIES; ++operations) { <nl>  				retval = hub_set_address(udev, devnum); <nl>  				if (retval >= 0) <nl>  					break;
@@ -124,6 +124,7 @@ dcb_outp_parse(struct nouveau_bios *bios, u8 idx, u8 *ver, u8 *len, <nl>  	       struct dcb_output *outp) <nl>  { <nl>  	u16 dcb = dcb_outp(bios, idx, ver, len); <nl> +	memset(outp, 0x00, sizeof(*outp)); <nl>  	if (dcb) { <nl>  		if (*ver >= 0x20) { <nl>  			u32 conn = nv_ro32(bios, dcb + 0x00);
@@ -297,7 +297,7 @@ static irqreturn_t handle_twl4030_pih(int irq, void *devid) <nl>  	ret = twl_i2c_read_u8(TWL_MODULE_PIH, &pih_isr, <nl>  			      REG_PIH_ISR_P1); <nl>  	if (ret) { <nl> -		pr_warning("twl4030: I2C error %d reading PIH ISR\n", ret); <nl> +		pr_warn("twl4030: I2C error %d reading PIH ISR\n", ret); <nl>  		return IRQ_NONE; <nl>  	} <nl>   <nl> @@ -338,7 +338,7 @@ static int twl4030_init_sih_modules(unsigned line) <nl>  	irq_line = line; <nl>   <nl>  	/* disable all interrupts on our line */ <nl> -	memset(buf, 0xff, sizeof buf); <nl> +	memset(buf, 0xff, sizeof(buf)); <nl>  	sih = sih_modules; <nl>  	for (i = 0; i < nr_sih_modules; i++, sih++) { <nl>  		/* skip USB -- it's funky */ <nl> @@ -646,7 +646,7 @@ int twl4030_sih_setup(struct device *dev, int module, int irq_base) <nl>  	if (status < 0) <nl>  		return status; <nl>   <nl> -	agent = kzalloc(sizeof *agent, GFP_KERNEL); <nl> +	agent = kzalloc(sizeof(*agent), GFP_KERNEL); <nl>  	if (!agent) <nl>  		return -ENOMEM; <nl>  
@@ -2019,7 +2019,12 @@ static ssize_t ath10k_write_pktlog_filter(struct file *file, <nl>  		goto out; <nl>  	} <nl>   <nl> -	if (filter && (filter != ar->debug.pktlog_filter)) { <nl> +	if (filter == ar->debug.pktlog_filter) { <nl> +		ret = count; <nl> +		goto out; <nl> +	} <nl> + <nl> +	if (filter) { <nl>  		ret = ath10k_wmi_pdev_pktlog_enable(ar, filter); <nl>  		if (ret) { <nl>  			ath10k_warn(ar, "failed to enable pktlog filter %x: %d\n",
@@ -4062,9 +4062,9 @@ int hugetlb_mcopy_atomic_pte(struct mm_struct *dst_mm, <nl>  	return ret; <nl>  out_release_unlock: <nl>  	spin_unlock(ptl); <nl> -out_release_nounlock: <nl>  	if (vm_shared) <nl>  		unlock_page(page); <nl> +out_release_nounlock: <nl>  	put_page(page); <nl>  	goto out; <nl>  }
@@ -1146,11 +1146,14 @@ static void uart_set_termios(struct tty_struct *tty, struct ktermios *old_termio <nl>   <nl>  	/* <nl>  	 * These are the bits that are used to setup various <nl> -	 * flags in the low level driver. <nl> +	 * flags in the low level driver. We can ignore the Bfoo <nl> +	 * bits in c_cflag; c_[io]speed will always be set <nl> +	 * appropriately by set_termios() in tty_ioctl.c <nl>  	 */ <nl>  #define RELEVANT_IFLAG(iflag)	((iflag) & (IGNBRK|BRKINT|IGNPAR|PARMRK|INPCK)) <nl> - <nl>  	if ((cflag ^ old_termios->c_cflag) == 0 && <nl> +	    tty->termios->c_ospeed == old_termios->c_ospeed && <nl> +	    tty->termios->c_ispeed == old_termios->c_ispeed && <nl>  	    RELEVANT_IFLAG(tty->termios->c_iflag ^ old_termios->c_iflag) == 0) <nl>  		return; <nl>  
@@ -513,6 +513,9 @@ static int dpi_check_timings(struct omap_dss_device *dssdev, <nl>  	struct dpi_clk_calc_ctx ctx; <nl>  	bool ok; <nl>   <nl> +	if (timings->x_res % 8 != 0) <nl> +		return -EINVAL; <nl> + <nl>  	if (mgr && !dispc_mgr_timings_ok(mgr->id, timings)) <nl>  		return -EINVAL; <nl>  
@@ -97,6 +97,9 @@ EXPORT_SYMBOL(clk_enable); <nl>   <nl>  void clk_disable(struct clk *clk) <nl>  { <nl> +	if (!clk) <nl> +		return; <nl> + <nl>  	if (clk->ops && clk->ops->disable) <nl>  		clk->ops->disable(clk); <nl>  }
@@ -529,7 +529,7 @@ static int list_devices(struct file *filp, struct dm_ioctl *param, size_t param_ <nl>  	 * Grab our output buffer. <nl>  	 */ <nl>  	nl = orig_nl = get_result_buffer(param, param_size, &len); <nl> -	if (len < needed) { <nl> +	if (len < needed || len < sizeof(nl->dev)) { <nl>  		param->flags |= DM_BUFFER_FULL_FLAG; <nl>  		goto out; <nl>  	}
@@ -893,6 +893,7 @@ static int multipath_ctr(struct dm_target *ti, unsigned int argc, <nl>  	} <nl>   <nl>  	ti->num_flush_requests = 1; <nl> +	ti->num_discard_requests = 1; <nl>   <nl>  	return 0; <nl>   <nl> @@ -1272,6 +1273,15 @@ static int do_end_io(struct multipath *m, struct request *clone, <nl>  	if (error == -EOPNOTSUPP) <nl>  		return error; <nl>   <nl> +	if (clone->cmd_flags & REQ_DISCARD) <nl> +		/* <nl> +		 * Pass all discard request failures up. <nl> +		 * FIXME: only fail_path if the discard failed due to a <nl> +		 * transport problem.  This requires precise understanding <nl> +		 * of the underlying failure (e.g. the SCSI sense). <nl> +		 */ <nl> +		return error; <nl> + <nl>  	if (mpio->pgpath) <nl>  		fail_path(mpio->pgpath); <nl>  
@@ -590,7 +590,7 @@ void mm_update_next_owner(struct mm_struct *mm) <nl>  	/* <nl>  	 * Search in the siblings <nl>  	 */ <nl> -	list_for_each_entry(c, &p->parent->children, sibling) { <nl> +	list_for_each_entry(c, &p->real_parent->children, sibling) { <nl>  		if (c->mm == mm) <nl>  			goto assign_new_owner; <nl>  	}
@@ -794,6 +794,8 @@ struct sock *inet_csk_clone_lock(const struct sock *sk, <nl>  		/* listeners have SOCK_RCU_FREE, not the children */ <nl>  		sock_reset_flag(newsk, SOCK_RCU_FREE); <nl>   <nl> +		inet_sk(newsk)->mc_list = NULL; <nl> + <nl>  		newsk->sk_mark = inet_rsk(req)->ir_mark; <nl>  		atomic64_set(&newsk->sk_cookie, <nl>  			     atomic64_read(&inet_rsk(req)->ir_cookie));
@@ -1385,6 +1385,9 @@ static void solo_enc_free(struct solo_enc_dev *solo_enc) <nl>  	if (solo_enc == NULL) <nl>  		return; <nl>   <nl> +	pci_free_consistent(solo_enc->solo_dev->pdev, <nl> +			sizeof(struct solo_p2m_desc) * solo_enc->desc_nelts, <nl> +			solo_enc->desc_items, solo_enc->desc_dma); <nl>  	video_unregister_device(solo_enc->vfd); <nl>  	v4l2_ctrl_handler_free(&solo_enc->hdl); <nl>  	kfree(solo_enc);
@@ -2551,13 +2551,13 @@ static void rtl_runtime_suspend_enable(struct r8152 *tp, bool enable) <nl>   <nl>  static void rtl8153_runtime_enable(struct r8152 *tp, bool enable) <nl>  { <nl> -	rtl_runtime_suspend_enable(tp, enable); <nl> - <nl>  	if (enable) { <nl>  		r8153_u1u2en(tp, false); <nl>  		r8153_u2p3en(tp, false); <nl>  		r8153_mac_clk_spd(tp, true); <nl> +		rtl_runtime_suspend_enable(tp, true); <nl>  	} else { <nl> +		rtl_runtime_suspend_enable(tp, false); <nl>  		r8153_mac_clk_spd(tp, false); <nl>  		r8153_u2p3en(tp, true); <nl>  		r8153_u1u2en(tp, true);
@@ -1238,7 +1238,14 @@ void ipv4_pktinfo_prepare(const struct sock *sk, struct sk_buff *skb) <nl>  		pktinfo->ipi_ifindex = 0; <nl>  		pktinfo->ipi_spec_dst.s_addr = 0; <nl>  	} <nl> -	skb_dst_drop(skb); <nl> +	/* We need to keep the dst for __ip_options_echo() <nl> +	 * We could restrict the test to opt.ts_needtime || opt.srr, <nl> +	 * but the following is good enough as IP options are not often used. <nl> +	 */ <nl> +	if (unlikely(IPCB(skb)->opt.optlen)) <nl> +		skb_dst_force(skb); <nl> +	else <nl> +		skb_dst_drop(skb); <nl>  } <nl>   <nl>  int ip_setsockopt(struct sock *sk, int level,
@@ -787,6 +787,12 @@ static int iowarrior_probe(struct usb_interface *interface, <nl>  	iface_desc = interface->cur_altsetting; <nl>  	dev->product_id = le16_to_cpu(udev->descriptor.idProduct); <nl>   <nl> +	if (iface_desc->desc.bNumEndpoints < 1) { <nl> +		dev_err(&interface->dev, "Invalid number of endpoints\n"); <nl> +		retval = -EINVAL; <nl> +		goto error; <nl> +	} <nl> + <nl>  	/* set up the endpoint information */ <nl>  	for (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) { <nl>  		endpoint = &iface_desc->endpoint[i].desc;
@@ -2989,6 +2989,7 @@ brcmf_notify_sched_scan_results(struct brcmf_if *ifp, <nl>  		} <nl>   <nl>  		set_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status); <nl> +		cfg->escan_info.run = brcmf_run_escan; <nl>  		err = brcmf_do_escan(cfg, wiphy, ifp, request); <nl>  		if (err) { <nl>  			clear_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status);
@@ -1238,7 +1238,7 @@ static int ibmveth_change_mtu(struct net_device *dev, int new_mtu) <nl>  		return -EINVAL; <nl>   <nl>  	for (i = 0; i < IBMVETH_NUM_BUFF_POOLS; i++) <nl> -		if (new_mtu_oh < adapter->rx_buff_pool[i].buff_size) <nl> +		if (new_mtu_oh <= adapter->rx_buff_pool[i].buff_size) <nl>  			break; <nl>   <nl>  	if (i == IBMVETH_NUM_BUFF_POOLS) <nl> @@ -1257,7 +1257,7 @@ static int ibmveth_change_mtu(struct net_device *dev, int new_mtu) <nl>  	for (i = 0; i < IBMVETH_NUM_BUFF_POOLS; i++) { <nl>  		adapter->rx_buff_pool[i].active = 1; <nl>   <nl> -		if (new_mtu_oh < adapter->rx_buff_pool[i].buff_size) { <nl> +		if (new_mtu_oh <= adapter->rx_buff_pool[i].buff_size) { <nl>  			dev->mtu = new_mtu; <nl>  			vio_cmo_set_dev_desired(viodev, <nl>  						ibmveth_get_desired_dma
@@ -505,6 +505,11 @@ int cap_bprm_set_creds(struct linux_binprm *bprm) <nl>  	} <nl>  skip: <nl>   <nl> +	/* if we have fs caps, clear dangerous personality flags */ <nl> +	if (!cap_issubset(new->cap_permitted, old->cap_permitted)) <nl> +		bprm->per_clear |= PER_CLEAR_ON_SETID; <nl> + <nl> + <nl>  	/* Don't let someone trace a set[ug]id/setpcap binary with the revised <nl>  	 * credentials unless they have the appropriate permit <nl>  	 */
@@ -700,6 +700,9 @@ static struct device_node *__of_get_next_child(const struct device_node *node, <nl>  { <nl>  	struct device_node *next; <nl>   <nl> +	if (!node) <nl> +		return NULL; <nl> + <nl>  	next = prev ? prev->sibling : node->child; <nl>  	for (; next; next = next->sibling) <nl>  		if (of_node_get(next)) <nl> @@ -746,6 +749,9 @@ struct device_node *of_get_next_available_child(const struct device_node *node, <nl>  	struct device_node *next; <nl>  	unsigned long flags; <nl>   <nl> +	if (!node) <nl> +		return NULL; <nl> + <nl>  	raw_spin_lock_irqsave(&devtree_lock, flags); <nl>  	next = prev ? prev->sibling : node->child; <nl>  	for (; next; next = next->sibling) {
@@ -678,7 +678,8 @@ static int __exit twl4030_usb_remove(struct platform_device *pdev) <nl>  	/* disable complete OTG block */ <nl>  	twl4030_usb_clear_bits(twl, POWER_CTRL, POWER_CTRL_OTG_ENAB); <nl>   <nl> -	twl4030_phy_power(twl, 0); <nl> +	if (!twl->asleep) <nl> +		twl4030_phy_power(twl, 0); <nl>  	regulator_put(twl->usb1v5); <nl>  	regulator_put(twl->usb1v8); <nl>  	regulator_put(twl->usb3v1);
@@ -211,13 +211,12 @@ static void card_cd_debounce(struct rts51x_chip *chip, u8 *need_reset, <nl>  				release_map |= MS_CARD; <nl>  		} <nl>  	} else { <nl> -		if (chip->card_status & XD_CD) { <nl> +		if (chip->card_status & XD_CD) <nl>  			reset_map |= XD_CARD; <nl> -		} else if (chip->card_status & SD_CD) { <nl> +		else if (chip->card_status & SD_CD) <nl>  			reset_map |= SD_CARD; <nl> -		} else if (chip->card_status & MS_CD) { <nl> +		else if (chip->card_status & MS_CD) <nl>  			reset_map |= MS_CARD; <nl> -		} <nl>  	} <nl>   <nl>  	if (CHECK_PKG(chip, QFN24) && reset_map) {
@@ -181,8 +181,8 @@ static int ext4_file_open(struct inode * inode, struct file * filp) <nl>  		path.dentry = mnt->mnt_root; <nl>  		cp = d_path(&path, buf, sizeof(buf)); <nl>  		if (!IS_ERR(cp)) { <nl> -			memcpy(sbi->s_es->s_last_mounted, cp, <nl> -			       sizeof(sbi->s_es->s_last_mounted)); <nl> +			strlcpy(sbi->s_es->s_last_mounted, cp, <nl> +				sizeof(sbi->s_es->s_last_mounted)); <nl>  			ext4_mark_super_dirty(sb); <nl>  		} <nl>  	}
@@ -2175,9 +2175,12 @@ static int cgroup_attach_proc(struct cgroup *cgrp, struct task_struct *leader) <nl>  		oldcg = tc->task->cgroups; <nl>   <nl>  		/* if we don't already have it in the list get a new one */ <nl> -		if (!css_set_check_fetched(cgrp, tc->task, oldcg, &newcg_list)) <nl> -			if (retval = css_set_prefetch(cgrp, oldcg, &newcg_list)) <nl> +		if (!css_set_check_fetched(cgrp, tc->task, oldcg, <nl> +					   &newcg_list)) { <nl> +			retval = css_set_prefetch(cgrp, oldcg, &newcg_list); <nl> +			if (retval) <nl>  				goto out_list_teardown; <nl> +		} <nl>  	} <nl>   <nl>  	/*
@@ -317,7 +317,7 @@ static void pcmuio_handle_intr_subdev(struct comedi_device *dev, <nl>  	struct pcmuio_private *devpriv = dev->private; <nl>  	int asic = pcmuio_subdevice_to_asic(s); <nl>  	struct pcmuio_asic *chip = &devpriv->asics[asic]; <nl> -	unsigned int len = s->async->cmd.chanlist_len; <nl> +	struct comedi_cmd *cmd = &s->async->cmd; <nl>  	unsigned oldevents = s->async->events; <nl>  	unsigned int val = 0; <nl>  	unsigned long flags; <nl> @@ -331,8 +331,8 @@ static void pcmuio_handle_intr_subdev(struct comedi_device *dev, <nl>  	if (!(triggered & chip->enabled_mask)) <nl>  		goto done; <nl>   <nl> -	for (i = 0; i < len; i++) { <nl> -		unsigned int chan = CR_CHAN(s->async->cmd.chanlist[i]); <nl> +	for (i = 0; i < cmd->chanlist_len; i++) { <nl> +		unsigned int chan = CR_CHAN(cmd->chanlist[i]); <nl>  		if (triggered & (1 << chan)) <nl>  			val |= (1 << i); <nl>  	}
@@ -3083,6 +3083,11 @@ void bnx2x_disable_sriov(struct bnx2x *bp) <nl>  static int bnx2x_vf_ndo_sanity(struct bnx2x *bp, int vfidx, <nl>  			       struct bnx2x_virtf *vf) <nl>  { <nl> +	if (bp->state != BNX2X_STATE_OPEN) { <nl> +		BNX2X_ERR("vf ndo called though PF is down\n"); <nl> +		return -EINVAL; <nl> +	} <nl> + <nl>  	if (!IS_SRIOV(bp)) { <nl>  		BNX2X_ERR("vf ndo called though sriov is disabled\n"); <nl>  		return -EINVAL;
@@ -338,7 +338,8 @@ static int rds_ib_laddr_check(__be32 addr) <nl>  	ret = rdma_bind_addr(cm_id, (struct sockaddr *)&sin); <nl>  	/* due to this, we will claim to support iWARP devices unless we <nl>  	   check node_type. */ <nl> -	if (ret || cm_id->device->node_type != RDMA_NODE_IB_CA) <nl> +	if (ret || !cm_id->device || <nl> +	    cm_id->device->node_type != RDMA_NODE_IB_CA) <nl>  		ret = -EADDRNOTAVAIL; <nl>   <nl>  	rdsdebug("addr %pI4 ret %d node type %d\n",
@@ -179,6 +179,7 @@ void gw_election(struct bat_priv *bat_priv) <nl>  { <nl>  	struct gw_node *curr_gw = NULL, *next_gw = NULL; <nl>  	struct neigh_node *router = NULL; <nl> +	char gw_addr[18] = { '\0' }; <nl>   <nl>  	/** <nl>  	 * The batman daemon checks here if we already passed a full originator <nl> @@ -200,6 +201,8 @@ void gw_election(struct bat_priv *bat_priv) <nl>  		goto out; <nl>   <nl>  	if (next_gw) { <nl> +		sprintf(gw_addr, "%pM", next_gw->orig_node->orig); <nl> + <nl>  		router = orig_node_get_router(next_gw->orig_node); <nl>  		if (!router) { <nl>  			gw_deselect(bat_priv); <nl> @@ -210,12 +213,14 @@ void gw_election(struct bat_priv *bat_priv) <nl>  	if ((curr_gw) && (!next_gw)) { <nl>  		bat_dbg(DBG_BATMAN, bat_priv, <nl>  			"Removing selected gateway - no gateway in range\n"); <nl> +		throw_uevent(bat_priv, UEV_GW, UEV_DEL, NULL); <nl>  	} else if ((!curr_gw) && (next_gw)) { <nl>  		bat_dbg(DBG_BATMAN, bat_priv, <nl>  			"Adding route to gateway %pM (gw_flags: %i, tq: %i)\n", <nl>  			next_gw->orig_node->orig, <nl>  			next_gw->orig_node->gw_flags, <nl>  			router->tq_avg); <nl> +		throw_uevent(bat_priv, UEV_GW, UEV_ADD, gw_addr); <nl>  	} else { <nl>  		bat_dbg(DBG_BATMAN, bat_priv, <nl>  			"Changing route to gateway %pM " <nl> @@ -223,6 +228,7 @@ void gw_election(struct bat_priv *bat_priv) <nl>  			next_gw->orig_node->orig, <nl>  			next_gw->orig_node->gw_flags, <nl>  			router->tq_avg); <nl> +		throw_uevent(bat_priv, UEV_GW, UEV_CHANGE, gw_addr); <nl>  	} <nl>   <nl>  	gw_select(bat_priv, next_gw);
@@ -399,6 +399,10 @@ parser_name_get(struct parser_context *ctx) <nl>  	struct spar_controlvm_parameters_header *phdr = NULL; <nl>   <nl>  	phdr = (struct spar_controlvm_parameters_header *)(ctx->data); <nl> + <nl> +	if (phdr->name_offset + phdr->name_length > ctx->param_bytes) <nl> +		return NULL; <nl> + <nl>  	ctx->curr = ctx->data + phdr->name_offset; <nl>  	ctx->bytes_remaining = phdr->name_length; <nl>  	return parser_string_get(ctx);
@@ -2932,6 +2932,13 @@ void b43_ntab_write_bulk(struct b43_wldev *dev, u32 offset, <nl>  	b43_phy_write(dev, B43_NPHY_TABLE_ADDR, offset); <nl>   <nl>  	for (i = 0; i < nr_elements; i++) { <nl> +		/* Auto increment broken + caching issue on BCM43224? */ <nl> +		if ((offset >> 10) == 9 && dev->dev->chip_id == 43224 && <nl> +		    dev->dev->chip_rev == 1) { <nl> +			b43_phy_read(dev, B43_NPHY_TABLE_DATALO); <nl> +			b43_phy_write(dev, B43_NPHY_TABLE_ADDR, offset + i); <nl> +		} <nl> + <nl>  		switch (type) { <nl>  		case B43_NTAB_8BIT: <nl>  			value = *data;
@@ -213,7 +213,7 @@ static int flush(struct driver_data *drv_data) <nl>  		while (read_SSSR(reg) & SSSR_RNE) { <nl>  			read_SSDR(reg); <nl>  		} <nl> -	} while ((read_SSSR(reg) & SSSR_BSY) && limit--); <nl> +	} while ((read_SSSR(reg) & SSSR_BSY) && --limit); <nl>  	write_SSSR(SSSR_ROR, reg); <nl>   <nl>  	return limit; <nl> @@ -484,7 +484,7 @@ static int wait_ssp_rx_stall(void const __iomem *ioaddr) <nl>  { <nl>  	unsigned long limit = loops_per_jiffy << 1; <nl>   <nl> -	while ((read_SSSR(ioaddr) & SSSR_BSY) && limit--) <nl> +	while ((read_SSSR(ioaddr) & SSSR_BSY) && --limit) <nl>  		cpu_relax(); <nl>   <nl>  	return limit; <nl> @@ -494,7 +494,7 @@ static int wait_dma_channel_stop(int channel) <nl>  { <nl>  	unsigned long limit = loops_per_jiffy << 1; <nl>   <nl> -	while (!(DCSR(channel) & DCSR_STOPSTATE) && limit--) <nl> +	while (!(DCSR(channel) & DCSR_STOPSTATE) && --limit) <nl>  		cpu_relax(); <nl>   <nl>  	return limit;
@@ -2899,7 +2899,7 @@ static int param_set_portnr(const char *val, const struct kernel_param *kp) <nl>  	if (!val) <nl>  		return -EINVAL; <nl>  	ret = kstrtoul(val, 0, &num); <nl> -	if (ret == -EINVAL || num > NFS_CALLBACK_MAXPORTNR) <nl> +	if (ret || num > NFS_CALLBACK_MAXPORTNR) <nl>  		return -EINVAL; <nl>  	*((unsigned int *)kp->arg) = num; <nl>  	return 0;
@@ -144,6 +144,7 @@ static int misc_open(struct inode * inode, struct file * file) <nl>  	old_fops = file->f_op; <nl>  	file->f_op = new_fops; <nl>  	if (file->f_op->open) { <nl> +		file->private_data = c; <nl>  		err=file->f_op->open(inode,file); <nl>  		if (err) { <nl>  			fops_put(file->f_op);
@@ -224,7 +224,7 @@ int frag_send_skb(struct sk_buff *skb, struct bat_priv *bat_priv, <nl>  	struct unicast_frag_packet *frag1, *frag2; <nl>  	int uc_hdr_len = sizeof(struct unicast_packet); <nl>  	int ucf_hdr_len = sizeof(struct unicast_frag_packet); <nl> -	int data_len = skb->len; <nl> +	int data_len = skb->len - uc_hdr_len; <nl>   <nl>  	if (!bat_priv->primary_if) <nl>  		goto dropped; <nl> @@ -232,10 +232,11 @@ int frag_send_skb(struct sk_buff *skb, struct bat_priv *bat_priv, <nl>  	frag_skb = dev_alloc_skb(data_len - (data_len / 2) + ucf_hdr_len); <nl>  	if (!frag_skb) <nl>  		goto dropped; <nl> +	skb_reserve(frag_skb, ucf_hdr_len); <nl>   <nl>  	unicast_packet = (struct unicast_packet *) skb->data; <nl>  	memcpy(&tmp_uc, unicast_packet, uc_hdr_len); <nl> -	skb_split(skb, frag_skb, data_len / 2); <nl> +	skb_split(skb, frag_skb, data_len / 2 + uc_hdr_len); <nl>   <nl>  	if (my_skb_head_push(skb, ucf_hdr_len - uc_hdr_len) < 0 || <nl>  	    my_skb_head_push(frag_skb, ucf_hdr_len) < 0)
@@ -80,6 +80,7 @@ static int br_mdb_fill_info(struct sk_buff *skb, struct netlink_callback *cb, <nl>  				port = p->port; <nl>  				if (port) { <nl>  					struct br_mdb_entry e; <nl> +					memset(&e, 0, sizeof(e)); <nl>  					e.ifindex = port->dev->ifindex; <nl>  					e.state = p->state; <nl>  					if (p->addr.proto == htons(ETH_P_IP)) <nl> @@ -136,6 +137,7 @@ static int br_mdb_dump(struct sk_buff *skb, struct netlink_callback *cb) <nl>  				break; <nl>   <nl>  			bpm = nlmsg_data(nlh); <nl> +			memset(bpm, 0, sizeof(*bpm)); <nl>  			bpm->ifindex = dev->ifindex; <nl>  			if (br_mdb_fill_info(skb, cb, dev) < 0) <nl>  				goto out; <nl> @@ -171,6 +173,7 @@ static int nlmsg_populate_mdb_fill(struct sk_buff *skb, <nl>  		return -EMSGSIZE; <nl>   <nl>  	bpm = nlmsg_data(nlh); <nl> +	memset(bpm, 0, sizeof(*bpm)); <nl>  	bpm->family  = AF_BRIDGE; <nl>  	bpm->ifindex = dev->ifindex; <nl>  	nest = nla_nest_start(skb, MDBA_MDB); <nl> @@ -228,6 +231,7 @@ void br_mdb_notify(struct net_device *dev, struct net_bridge_port *port, <nl>  { <nl>  	struct br_mdb_entry entry; <nl>   <nl> +	memset(&entry, 0, sizeof(entry)); <nl>  	entry.ifindex = port->dev->ifindex; <nl>  	entry.addr.proto = group->proto; <nl>  	entry.addr.u.ip4 = group->u.ip4;
@@ -4440,9 +4440,10 @@ bool i40e_dcb_need_reconfig(struct i40e_pf *pf, <nl>  	/* Check if APP Table has changed */ <nl>  	if (memcmp(&new_cfg->app, <nl>  		   &old_cfg->app, <nl> -		   sizeof(new_cfg->app))) <nl> +		   sizeof(new_cfg->app))) { <nl>  		need_reconfig = true; <nl>  		dev_info(&pf->pdev->dev, "APP Table change detected.\n"); <nl> +	} <nl>   <nl>  	return need_reconfig; <nl>  }
@@ -385,14 +385,14 @@ static bool elem_id_matches(const struct snd_kcontrol *kctl, <nl>  #define MULTIPLIER	37 <nl>  static unsigned long get_ctl_id_hash(const struct snd_ctl_elem_id *id) <nl>  { <nl> +	int i; <nl>  	unsigned long h; <nl> -	const unsigned char *p; <nl>   <nl>  	h = id->iface; <nl>  	h = MULTIPLIER * h + id->device; <nl>  	h = MULTIPLIER * h + id->subdevice; <nl> -	for (p = id->name; *p; p++) <nl> -		h = MULTIPLIER * h + *p; <nl> +	for (i = 0; id->name[i] && i < SNDRV_CTL_ELEM_ID_NAME_MAXLEN; i++) <nl> +		h = MULTIPLIER * h + id->name[i]; <nl>  	h = MULTIPLIER * h + id->index; <nl>  	h &= LONG_MAX; <nl>  	return h;
@@ -1504,7 +1504,7 @@ EXPORT_SYMBOL(snprintf); <nl>   * @...: Arguments for the format string <nl>   * <nl>   * The return value is the number of characters written into @buf not including <nl> - * the trailing '\0'. If @size is <= 0 the function returns 0. <nl> + * the trailing '\0'. If @size is == 0 the function returns 0. <nl>   */ <nl>   <nl>  int scnprintf(char *buf, size_t size, const char *fmt, ...) <nl> @@ -1516,7 +1516,11 @@ int scnprintf(char *buf, size_t size, const char *fmt, ...) <nl>  	i = vsnprintf(buf, size, fmt, args); <nl>  	va_end(args); <nl>   <nl> -	return (i >= size) ? (size - 1) : i; <nl> +	if (likely(i < size)) <nl> +		return i; <nl> +	if (size != 0) <nl> +		return size - 1; <nl> +	return 0; <nl>  } <nl>  EXPORT_SYMBOL(scnprintf); <nl>  
@@ -646,6 +646,7 @@ static struct scatterlist *alloc_sgtable(int size) <nl>  				if (new_page) <nl>  					__free_page(new_page); <nl>  			} <nl> +			kfree(table); <nl>  			return NULL; <nl>  		} <nl>  		alloc_size = min_t(int, size, PAGE_SIZE);
@@ -1400,7 +1400,6 @@ static int stk_camera_probe(struct usb_interface *interface, <nl>  	} <nl>   <nl>  	stk_create_sysfs_files(&dev->vdev); <nl> -	usb_autopm_enable(dev->interface); <nl>   <nl>  	return 0; <nl>  
@@ -294,6 +294,9 @@ static int llcp_sock_getname(struct socket *sock, struct sockaddr *uaddr, <nl>  	struct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk); <nl>  	DECLARE_SOCKADDR(struct sockaddr_nfc_llcp *, llcp_addr, uaddr); <nl>   <nl> +	if (llcp_sock == NULL || llcp_sock->dev == NULL) <nl> +		return -EBADFD; <nl> + <nl>  	pr_debug("%p %d %d %d\n", sk, llcp_sock->target_idx, <nl>  		 llcp_sock->dsap, llcp_sock->ssap); <nl>  
@@ -1487,6 +1487,7 @@ static int perf_sched__read_events(struct perf_sched *sched) <nl>  	struct perf_data_file file = { <nl>  		.path = input_name, <nl>  		.mode = PERF_DATA_MODE_READ, <nl> +		.force = sched->force, <nl>  	}; <nl>  	int rc = -1; <nl>  
@@ -57,6 +57,7 @@ static int led = 0; <nl>  static int disable = 0; <nl>  static int bt_coexist = 0; <nl>  static int hwcrypto = 1; <nl> +static int roaming = 1; <nl>  static const char ipw_modes[] = { <nl>  	'a', 'b', 'g', '?' <nl>  }; <nl> @@ -4187,8 +4188,9 @@ static void ipw_handle_missed_beacon(struct ipw_priv *priv, <nl>  		return; <nl>  	} <nl>   <nl> -	if (missed_count > priv->roaming_threshold && <nl> -	    missed_count <= priv->disassociate_threshold) { <nl> +	if (roaming && <nl> +	    (missed_count > priv->roaming_threshold && <nl> +	     missed_count <= priv->disassociate_threshold)) { <nl>  		/* If we are not already roaming, set the ROAM <nl>  		 * bit in the status and kick off a scan. <nl>  		 * This can happen several times before we reach <nl> @@ -4216,7 +4218,6 @@ static void ipw_handle_missed_beacon(struct ipw_priv *priv, <nl>  	} <nl>   <nl>  	IPW_DEBUG_NOTIF("Missed beacon: %d\n", missed_count); <nl> - <nl>  } <nl>   <nl>  /** <nl> @@ -11378,5 +11379,8 @@ module_param(cmdlog, int, 0444); <nl>  MODULE_PARM_DESC(cmdlog, <nl>  		 "allocate a ring buffer for logging firmware commands"); <nl>   <nl> +module_param(roaming, int, 0444); <nl> +MODULE_PARM_DESC(roaming, "enable roaming support (default on)"); <nl> + <nl>  module_exit(ipw_exit); <nl>  module_init(ipw_init);
@@ -3391,6 +3391,10 @@ static int ext4_fill_super(struct super_block *sb, void *data, int silent) <nl>  	get_random_bytes(&sbi->s_next_generation, sizeof(u32)); <nl>  	spin_lock_init(&sbi->s_next_gen_lock); <nl>   <nl> +	init_timer(&sbi->s_err_report); <nl> +	sbi->s_err_report.function = print_daily_error_info; <nl> +	sbi->s_err_report.data = (unsigned long) sb; <nl> + <nl>  	err = percpu_counter_init(&sbi->s_freeblocks_counter, <nl>  			ext4_count_free_blocks(sb)); <nl>  	if (!err) { <nl> @@ -3652,9 +3656,6 @@ static int ext4_fill_super(struct super_block *sb, void *data, int silent) <nl>  		 "Opts: %s%s%s", descr, sbi->s_es->s_mount_opts, <nl>  		 *sbi->s_es->s_mount_opts ? "; " : "", orig_data); <nl>   <nl> -	init_timer(&sbi->s_err_report); <nl> -	sbi->s_err_report.function = print_daily_error_info; <nl> -	sbi->s_err_report.data = (unsigned long) sb; <nl>  	if (es->s_error_count) <nl>  		mod_timer(&sbi->s_err_report, jiffies + 300*HZ); /* 5 minutes */ <nl>   <nl> @@ -3678,6 +3679,7 @@ static int ext4_fill_super(struct super_block *sb, void *data, int silent) <nl>  		sbi->s_journal = NULL; <nl>  	} <nl>  failed_mount3: <nl> +	del_timer(&sbi->s_err_report); <nl>  	if (sbi->s_flex_groups) { <nl>  		if (is_vmalloc_addr(sbi->s_flex_groups)) <nl>  			vfree(sbi->s_flex_groups);
@@ -2897,7 +2897,8 @@ static void _tcpm_cc_change(struct tcpm_port *port, enum typec_cc_status cc1, <nl>  		break; <nl>   <nl>  	case SRC_TRY: <nl> -		tcpm_set_state(port, SRC_TRY_DEBOUNCE, 0); <nl> +		if (tcpm_port_is_source(port)) <nl> +			tcpm_set_state(port, SRC_TRY_DEBOUNCE, 0); <nl>  		break; <nl>  	case SRC_TRY_DEBOUNCE: <nl>  		tcpm_set_state(port, SRC_TRY, 0);
@@ -5734,6 +5734,9 @@ int ext4_insert_range(struct inode *inode, loff_t offset, loff_t len) <nl>  			up_write(&EXT4_I(inode)->i_data_sem); <nl>  			goto out_stop; <nl>  		} <nl> +	} else { <nl> +		ext4_ext_drop_refs(path); <nl> +		kfree(path); <nl>  	} <nl>   <nl>  	ret = ext4_es_remove_extent(inode, offset_lblk,
@@ -1767,6 +1767,12 @@ static int set_multi_io(struct hda_codec *codec, int idx, bool output) <nl>  		snd_hda_activate_path(codec, path, false, true); <nl>  		set_pin_target(codec, nid, spec->multi_io[idx].ctl_in, true); <nl>  	} <nl> + <nl> +	/* update jack retasking in case it modifies any of them */ <nl> +	snd_hda_gen_hp_automute(codec, NULL); <nl> +	snd_hda_gen_line_automute(codec, NULL); <nl> +	snd_hda_gen_mic_autoswitch(codec, NULL); <nl> + <nl>  	return 0; <nl>  } <nl>  
@@ -766,6 +766,13 @@ static int rave_sp_probe(struct serdev_device *serdev) <nl>  		return ret; <nl>   <nl>  	serdev_device_set_baudrate(serdev, baud); <nl> +	serdev_device_set_flow_control(serdev, false); <nl> + <nl> +	ret = serdev_device_set_parity(serdev, SERDEV_PARITY_NONE); <nl> +	if (ret) { <nl> +		dev_err(dev, "Failed to set parity\n"); <nl> +		return ret; <nl> +	} <nl>   <nl>  	ret = rave_sp_get_status(sp); <nl>  	if (ret) {
@@ -942,11 +942,10 @@ static netdev_tx_t geneve_xmit(struct sk_buff *skb, struct net_device *dev) <nl>   <nl>  static int geneve_change_mtu(struct net_device *dev, int new_mtu) <nl>  { <nl> -	/* Only possible if called internally, ndo_change_mtu path's new_mtu <nl> -	 * is guaranteed to be between dev->min_mtu and dev->max_mtu. <nl> -	 */ <nl>  	if (new_mtu > dev->max_mtu) <nl>  		new_mtu = dev->max_mtu; <nl> +	else if (new_mtu < dev->min_mtu) <nl> +		new_mtu = dev->min_mtu; <nl>   <nl>  	dev->mtu = new_mtu; <nl>  	return 0;
@@ -99,13 +99,13 @@ static inline int access_ok(int type, const void __user *addr, <nl>  	if ((get_fs().seg < ((unsigned long)addr)) || <nl>  			(get_fs().seg < ((unsigned long)addr + size - 1))) { <nl>  		pr_debug("ACCESS fail: %s at 0x%08x (size 0x%x), seg 0x%08x\n", <nl> -			type ? "WRITE" : "READ ", (u32)addr, (u32)size, <nl> +			type ? "WRITE" : "READ ", (__force u32)addr, (u32)size, <nl>  			(u32)get_fs().seg); <nl>  		return 0; <nl>  	} <nl>  ok: <nl>  	pr_debug("ACCESS OK: %s at 0x%08x (size 0x%x), seg 0x%08x\n", <nl> -			type ? "WRITE" : "READ ", (u32)addr, (u32)size, <nl> +			type ? "WRITE" : "READ ", (__force u32)addr, (u32)size, <nl>  			(u32)get_fs().seg); <nl>  	return 1; <nl>  }
@@ -608,7 +608,7 @@ __hwmon_device_register(struct device *dev, const char *name, void *drvdata, <nl>  	if (err) <nl>  		goto free_hwmon; <nl>   <nl> -	if (chip && chip->ops->read && <nl> +	if (dev && chip && chip->ops->read && <nl>  	    chip->info[0]->type == hwmon_chip && <nl>  	    (chip->info[0]->config[0] & HWMON_C_REGISTER_TZ)) { <nl>  		const struct hwmon_channel_info **info = chip->info;
@@ -1725,8 +1725,12 @@ static int trace__read_syscall_info(struct trace *trace, int id) <nl>   <nl>  	sc->args = sc->tp_format->format.fields; <nl>  	sc->nr_args = sc->tp_format->format.nr_fields; <nl> -	/* drop nr field - not relevant here; does not exist on older kernels */ <nl> -	if (sc->args && strcmp(sc->args->name, "nr") == 0) { <nl> +	/* <nl> +	 * We need to check and discard the first variable '__syscall_nr' <nl> +	 * or 'nr' that mean the syscall number. It is needless here. <nl> +	 * So drop '__syscall_nr' or 'nr' field but does not exist on older kernels. <nl> +	 */ <nl> +	if (sc->args && (!strcmp(sc->args->name, "__syscall_nr") || !strcmp(sc->args->name, "nr"))) { <nl>  		sc->args = sc->args->next; <nl>  		--sc->nr_args; <nl>  	}
@@ -58,7 +58,6 @@ <nl>  #define MF6X4_DA7_R					0x2e <nl>  /* Map DAC cahnnel id to real HW-dependent offset value */ <nl>  #define MF6X4_DAC_R(x)					(0x20 + ((x) * 2)) <nl> -#define MF6X4_DA_M					0x3fff <nl>   <nl>  /* BAR2 registers */ <nl>  #define MF634_GPIOC_R					0x68 <nl> @@ -182,6 +181,7 @@ static int mf6x4_ao_insn_write(struct comedi_device *dev, <nl>  { <nl>  	struct mf6x4_private *devpriv = dev->private; <nl>  	unsigned int chan = CR_CHAN(insn->chanspec); <nl> +	unsigned int val = devpriv->ao_readback[chan]; <nl>  	uint32_t gpioc; <nl>  	int i; <nl>   <nl> @@ -191,10 +191,10 @@ static int mf6x4_ao_insn_write(struct comedi_device *dev, <nl>  		  devpriv->gpioc_R); <nl>   <nl>  	for (i = 0; i < insn->n; i++) { <nl> -		iowrite16(data[i] & MF6X4_DA_M, dev->mmio + MF6X4_DAC_R(chan)); <nl> - <nl> -		devpriv->ao_readback[chan] = data[i]; <nl> +		val = data[i]; <nl> +		iowrite16(val, dev->mmio + MF6X4_DAC_R(chan)); <nl>  	} <nl> +	devpriv->ao_readback[chan] = val; <nl>   <nl>  	return insn->n; <nl>  }
@@ -668,11 +668,11 @@ static void sixpack_close(struct tty_struct *tty) <nl>  	 */ <nl>  	netif_stop_queue(sp->dev); <nl>   <nl> +	unregister_netdev(sp->dev); <nl> + <nl>  	del_timer_sync(&sp->tx_t); <nl>  	del_timer_sync(&sp->resync_t); <nl>   <nl> -	unregister_netdev(sp->dev); <nl> - <nl>  	/* Free all 6pack frame buffers after unreg. */ <nl>  	kfree(sp->rbuff); <nl>  	kfree(sp->xbuff);
@@ -37,8 +37,6 @@ extern int of_irq_parse_one(struct device_node *device, int index, <nl>  extern unsigned int irq_create_of_mapping(struct of_phandle_args *irq_data); <nl>  extern int of_irq_to_resource(struct device_node *dev, int index, <nl>  			      struct resource *r); <nl> -extern int of_irq_to_resource_table(struct device_node *dev, <nl> -		struct resource *res, int nr_irqs); <nl>   <nl>  extern void of_irq_init(const struct of_device_id *matches); <nl>   <nl> @@ -46,6 +44,8 @@ extern void of_irq_init(const struct of_device_id *matches); <nl>  extern int of_irq_count(struct device_node *dev); <nl>  extern int of_irq_get(struct device_node *dev, int index); <nl>  extern int of_irq_get_byname(struct device_node *dev, const char *name); <nl> +extern int of_irq_to_resource_table(struct device_node *dev, <nl> +		struct resource *res, int nr_irqs); <nl>  #else <nl>  static inline int of_irq_count(struct device_node *dev) <nl>  { <nl> @@ -59,6 +59,11 @@ static inline int of_irq_get_byname(struct device_node *dev, const char *name) <nl>  { <nl>  	return 0; <nl>  } <nl> +static inline int of_irq_to_resource_table(struct device_node *dev, <nl> +					   struct resource *res, int nr_irqs) <nl> +{ <nl> +	return 0; <nl> +} <nl>  #endif <nl>   <nl>  #if defined(CONFIG_OF)
@@ -2339,11 +2339,19 @@ tracing_write_stub(struct file *filp, const char __user *ubuf, <nl>  	return count; <nl>  } <nl>   <nl> +static loff_t tracing_seek(struct file *file, loff_t offset, int origin) <nl> +{ <nl> +	if (file->f_mode & FMODE_READ) <nl> +		return seq_lseek(file, offset, origin); <nl> +	else <nl> +		return 0; <nl> +} <nl> + <nl>  static const struct file_operations tracing_fops = { <nl>  	.open		= tracing_open, <nl>  	.read		= seq_read, <nl>  	.write		= tracing_write_stub, <nl> -	.llseek		= seq_lseek, <nl> +	.llseek		= tracing_seek, <nl>  	.release	= tracing_release, <nl>  }; <nl>  
@@ -550,10 +550,13 @@ static int pl2303_tiocmset(struct tty_struct *tty, <nl>  	spin_unlock_irqrestore(&priv->lock, flags); <nl>   <nl>  	mutex_lock(&serial->disc_mutex); <nl> -	if (!serial->disconnected) <nl> +	if (!serial->disconnected) { <nl>  		ret = pl2303_set_control_lines(port, control); <nl> -	else <nl> +		if (ret) <nl> +			ret = usb_translate_errors(ret); <nl> +	} else { <nl>  		ret = -ENODEV; <nl> +	} <nl>  	mutex_unlock(&serial->disc_mutex); <nl>   <nl>  	return ret;
@@ -78,8 +78,7 @@ static int parse_redboot_partitions(struct mtd_info *master, <nl>   <nl>  	if ( directory < 0 ) { <nl>  		offset = master->size + directory * master->erasesize; <nl> -		while (mtd_can_have_bb(master) && <nl> -		       mtd_block_isbad(master, offset)) { <nl> +		while (mtd_block_isbad(master, offset)) { <nl>  			if (!offset) { <nl>  			nogood: <nl>  				printk(KERN_NOTICE "Failed to find a non-bad block to check for RedBoot partition table\n"); <nl> @@ -89,8 +88,7 @@ static int parse_redboot_partitions(struct mtd_info *master, <nl>  		} <nl>  	} else { <nl>  		offset = directory * master->erasesize; <nl> -		while (mtd_can_have_bb(master) && <nl> -		       mtd_block_isbad(master, offset)) { <nl> +		while (mtd_block_isbad(master, offset)) { <nl>  			offset += master->erasesize; <nl>  			if (offset == master->size) <nl>  				goto nogood;
@@ -554,6 +554,9 @@ static int ac100_rtc_probe(struct platform_device *pdev) <nl>  	int ret; <nl>   <nl>  	chip = devm_kzalloc(&pdev->dev, sizeof(*chip), GFP_KERNEL); <nl> +	if (!chip) <nl> +		return -ENOMEM; <nl> + <nl>  	platform_set_drvdata(pdev, chip); <nl>  	chip->dev = &pdev->dev; <nl>  	chip->regmap = ac100->regmap;
@@ -55,7 +55,7 @@ nf_nat_redirect_ipv4(struct sk_buff *skb, <nl>   <nl>  		rcu_read_lock(); <nl>  		indev = __in_dev_get_rcu(skb->dev); <nl> -		if (indev != NULL) { <nl> +		if (indev && indev->ifa_list) { <nl>  			ifa = indev->ifa_list; <nl>  			newdst = ifa->ifa_local; <nl>  		}
@@ -336,5 +336,7 @@ __append_chain(struct callchain_node *root, struct ip_callchain *chain, <nl>  void append_chain(struct callchain_node *root, struct ip_callchain *chain, <nl>  		  struct symbol **syms) <nl>  { <nl> +	if (!chain->nr) <nl> +		return; <nl>  	__append_chain_children(root, chain, syms, 0); <nl>  }
@@ -1179,6 +1179,13 @@ static void task_numa_compare(struct task_numa_env *env, <nl>  		cur = NULL; <nl>  	raw_spin_unlock_irq(&dst_rq->lock); <nl>   <nl> +	/* <nl> +	 * Because we have preemption enabled we can get migrated around and <nl> +	 * end try selecting ourselves (current == env->p) as a swap candidate. <nl> +	 */ <nl> +	if (cur == env->p) <nl> +		goto unlock; <nl> + <nl>  	/* <nl>  	 * "imp" is the fault differential for the source task between the <nl>  	 * source and destination node. Calculate the total differential for
@@ -1699,7 +1699,7 @@ static int pfkey_register(struct sock *sk, struct sk_buff *skb, const struct sad <nl>   <nl>  	xfrm_probe_algs(); <nl>   <nl> -	supp_skb = compose_sadb_supported(hdr, GFP_KERNEL); <nl> +	supp_skb = compose_sadb_supported(hdr, GFP_KERNEL | __GFP_ZERO); <nl>  	if (!supp_skb) { <nl>  		if (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC) <nl>  			pfk->registered &= ~(1<<hdr->sadb_msg_satype);
@@ -1000,7 +1000,8 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s) <nl>  	devpriv->write_byte(INTERVAL_LOAD_BITS, <nl>  			    dev->iobase + INTERVAL_LOAD_REG); <nl>   <nl> -	if (cmd->convert_src == TRIG_TIMER || cmd->scan_begin_src == TRIG_TIMER) { <nl> +	if (cmd->convert_src == TRIG_TIMER || <nl> +	    cmd->scan_begin_src == TRIG_TIMER) { <nl>  		/*  set up pacing */ <nl>  		labpc_adc_timing(dev, cmd, mode); <nl>  		/*  load counter b0 in mode 3 */
@@ -1736,6 +1736,8 @@ static int vmci_transport_dgram_dequeue(struct kiocb *kiocb, <nl>  	if (flags & MSG_OOB || flags & MSG_ERRQUEUE) <nl>  		return -EOPNOTSUPP; <nl>   <nl> +	msg->msg_namelen = 0; <nl> + <nl>  	/* Retrieve the head sk_buff from the socket's receive queue. */ <nl>  	err = 0; <nl>  	skb = skb_recv_datagram(&vsk->sk, flags, noblock, &err); <nl> @@ -1768,7 +1770,6 @@ static int vmci_transport_dgram_dequeue(struct kiocb *kiocb, <nl>  	if (err) <nl>  		goto out; <nl>   <nl> -	msg->msg_namelen = 0; <nl>  	if (msg->msg_name) { <nl>  		struct sockaddr_vm *vm_addr; <nl>  
@@ -593,6 +593,11 @@ static int arc_serial_probe(struct platform_device *pdev) <nl>  	if (dev_id < 0) <nl>  		dev_id = 0; <nl>   <nl> +	if (dev_id >= ARRAY_SIZE(arc_uart_ports)) { <nl> +		dev_err(&pdev->dev, "serial%d out of range\n", dev_id); <nl> +		return -EINVAL; <nl> +	} <nl> + <nl>  	uart = &arc_uart_ports[dev_id]; <nl>  	port = &uart->port; <nl>  
@@ -1832,7 +1832,7 @@ static u8 get_umr_flags(int acc) <nl>  	       (acc & IB_ACCESS_REMOTE_WRITE  ? MLX5_PERM_REMOTE_WRITE : 0) | <nl>  	       (acc & IB_ACCESS_REMOTE_READ   ? MLX5_PERM_REMOTE_READ  : 0) | <nl>  	       (acc & IB_ACCESS_LOCAL_WRITE   ? MLX5_PERM_LOCAL_WRITE  : 0) | <nl> -		MLX5_PERM_LOCAL_READ | MLX5_PERM_UMR_EN | MLX5_ACCESS_MODE_MTT; <nl> +		MLX5_PERM_LOCAL_READ | MLX5_PERM_UMR_EN; <nl>  } <nl>   <nl>  static void set_mkey_segment(struct mlx5_mkey_seg *seg, struct ib_send_wr *wr, <nl> @@ -1844,7 +1844,8 @@ static void set_mkey_segment(struct mlx5_mkey_seg *seg, struct ib_send_wr *wr, <nl>  		return; <nl>  	} <nl>   <nl> -	seg->flags = get_umr_flags(wr->wr.fast_reg.access_flags); <nl> +	seg->flags = get_umr_flags(wr->wr.fast_reg.access_flags) | <nl> +		     MLX5_ACCESS_MODE_MTT; <nl>  	*writ = seg->flags & (MLX5_PERM_LOCAL_WRITE | IB_ACCESS_REMOTE_WRITE); <nl>  	seg->qpn_mkey7_0 = cpu_to_be32((wr->wr.fast_reg.rkey & 0xff) | 0xffffff00); <nl>  	seg->flags_pd = cpu_to_be32(MLX5_MKEY_REMOTE_INVAL);
@@ -423,6 +423,8 @@ static void ssb_pmu_resources_init(struct ssb_chipcommon *cc) <nl>   <nl>  	switch (bus->chip_id) { <nl>  	case 0x4312: <nl> +		 min_msk = 0xCBB; <nl> +		 break; <nl>  	case 0x4322: <nl>  		/* We keep the default settings: <nl>  		 * min_msk = 0xCBB
@@ -113,7 +113,7 @@ static void pptp_expectfn(struct nf_conn *ct, <nl>   <nl>  	rcu_read_lock(); <nl>  	nf_nat_pptp_expectfn = rcu_dereference(nf_nat_pptp_hook_expectfn); <nl> -	if (nf_nat_pptp_expectfn && ct->status & IPS_NAT_MASK) <nl> +	if (nf_nat_pptp_expectfn && ct->master->status & IPS_NAT_MASK) <nl>  		nf_nat_pptp_expectfn(ct, exp); <nl>  	else { <nl>  		struct nf_conntrack_tuple inv_t;
@@ -24,6 +24,7 @@ <nl>  #include <linux/interrupt.h> <nl>  #include <linux/pci.h> <nl>  #include <linux/firmware.h> <nl> +#include <linux/vmalloc.h> <nl>  #include <asm/io.h> <nl>  #include <sound/core.h> <nl>  #include "mixart.h"
@@ -8462,6 +8462,12 @@ static int ipw2100_get_firmware(struct ipw2100_priv *priv, <nl>  	return 0; <nl>  } <nl>   <nl> +MODULE_FIRMWARE(IPW2100_FW_NAME("-i")); <nl> +#ifdef CONFIG_IPW2100_MONITOR <nl> +MODULE_FIRMWARE(IPW2100_FW_NAME("-p")); <nl> +#endif <nl> +MODULE_FIRMWARE(IPW2100_FW_NAME("")); <nl> + <nl>  static void ipw2100_release_firmware(struct ipw2100_priv *priv, <nl>  				     struct ipw2100_fw *fw) <nl>  {
@@ -387,6 +387,7 @@ xfs_attrlist_by_handle( <nl>  { <nl>  	int			error = -ENOMEM; <nl>  	attrlist_cursor_kern_t	*cursor; <nl> +	struct xfs_fsop_attrlist_handlereq __user	*p = arg; <nl>  	xfs_fsop_attrlist_handlereq_t al_hreq; <nl>  	struct dentry		*dentry; <nl>  	char			*kbuf; <nl> @@ -419,6 +420,11 @@ xfs_attrlist_by_handle( <nl>  	if (error) <nl>  		goto out_kfree; <nl>   <nl> +	if (copy_to_user(&p->pos, cursor, sizeof(attrlist_cursor_kern_t))) { <nl> +		error = -EFAULT; <nl> +		goto out_kfree; <nl> +	} <nl> + <nl>  	if (copy_to_user(al_hreq.buffer, kbuf, al_hreq.buflen)) <nl>  		error = -EFAULT; <nl>  
@@ -2833,13 +2833,15 @@ regulator_register(const struct regulator_desc *regulator_desc, <nl>  	const struct regulator_init_data *init_data; <nl>  	static atomic_t regulator_no = ATOMIC_INIT(0); <nl>  	struct regulator_dev *rdev; <nl> -	struct device *dev = config->dev; <nl> +	struct device *dev; <nl>  	int ret, i; <nl>  	const char *supply = NULL; <nl>   <nl>  	if (regulator_desc == NULL || config == NULL) <nl>  		return ERR_PTR(-EINVAL); <nl>   <nl> +	dev = config->dev; <nl> + <nl>  	if (regulator_desc->name == NULL || regulator_desc->ops == NULL) <nl>  		return ERR_PTR(-EINVAL); <nl>  
@@ -1000,7 +1000,7 @@ static long __write_once initfree = 1; <nl>  static int __init set_initfree(char *str) <nl>  { <nl>  	long val; <nl> -	if (strict_strtol(str, 0, &val)) { <nl> +	if (strict_strtol(str, 0, &val) == 0) { <nl>  		initfree = val; <nl>  		pr_info("initfree: %s free init pages\n", <nl>  			initfree ? "will" : "won't");
@@ -757,6 +757,16 @@ __setup_irq(unsigned int irq, struct irq_desc *desc, struct irqaction *new) <nl>  		if (new->flags & IRQF_ONESHOT) <nl>  			desc->status |= IRQ_ONESHOT; <nl>   <nl> +		/* <nl> +		 * Force MSI interrupts to run with interrupts <nl> +		 * disabled. The multi vector cards can cause stack <nl> +		 * overflows due to nested interrupts when enough of <nl> +		 * them are directed to a core and fire at the same <nl> +		 * time. <nl> +		 */ <nl> +		if (desc->msi_desc) <nl> +			new->flags |= IRQF_DISABLED; <nl> + <nl>  		if (!(desc->status & IRQ_NOAUTOEN)) { <nl>  			desc->depth = 0; <nl>  			desc->status &= ~IRQ_DISABLED;
@@ -1053,6 +1053,11 @@ static int ax25_release(struct socket *sock) <nl>  		ax25_destroy_socket(ax25); <nl>  	} <nl>  	if (ax25_dev) { <nl> +		del_timer_sync(&ax25->timer); <nl> +		del_timer_sync(&ax25->t1timer); <nl> +		del_timer_sync(&ax25->t2timer); <nl> +		del_timer_sync(&ax25->t3timer); <nl> +		del_timer_sync(&ax25->idletimer); <nl>  		dev_put_track(ax25_dev->dev, &ax25_dev->dev_tracker); <nl>  		ax25_dev_put(ax25_dev); <nl>  	}
@@ -323,8 +323,10 @@ static int ttm_mem_init_dma32_zone(struct ttm_mem_global *glob, <nl>  	 * No special dma32 zone needed. <nl>  	 */ <nl>   <nl> -	if (mem <= ((uint64_t) 1ULL << 32)) <nl> +	if (mem <= ((uint64_t) 1ULL << 32)) { <nl> +		kfree(zone); <nl>  		return 0; <nl> +	} <nl>   <nl>  	/* <nl>  	 * Limit max dma32 memory to 4GB for now
@@ -2059,6 +2059,7 @@ static int netlink_dump(struct sock *sk) <nl>  	struct netlink_callback *cb; <nl>  	struct sk_buff *skb = NULL; <nl>  	struct nlmsghdr *nlh; <nl> +	struct module *module; <nl>  	int len, err = -ENOBUFS; <nl>  	int alloc_min_size; <nl>  	int alloc_size; <nl> @@ -2134,9 +2135,11 @@ static int netlink_dump(struct sock *sk) <nl>  		cb->done(cb); <nl>   <nl>  	nlk->cb_running = false; <nl> +	module = cb->module; <nl> +	skb = cb->skb; <nl>  	mutex_unlock(nlk->cb_mutex); <nl> -	module_put(cb->module); <nl> -	consume_skb(cb->skb); <nl> +	module_put(module); <nl> +	consume_skb(skb); <nl>  	return 0; <nl>   <nl>  errout_skb:
@@ -813,7 +813,12 @@ static int i2c_check_addr(struct i2c_adapter *adapter, int addr) <nl>  int i2c_attach_client(struct i2c_client *client) <nl>  { <nl>  	struct i2c_adapter *adapter = client->adapter; <nl> -	int res = 0; <nl> +	int res; <nl> + <nl> +	/* Check for address business */ <nl> +	res = i2c_check_addr(adapter, client->addr); <nl> +	if (res) <nl> +		return res; <nl>   <nl>  	client->dev.parent = &client->adapter->dev; <nl>  	client->dev.bus = &i2c_bus_type;
@@ -2846,11 +2846,9 @@ int ocrdma_arm_cq(struct ib_cq *ibcq, enum ib_cq_notify_flags cq_flags) <nl>  	if (cq->first_arm) { <nl>  		ocrdma_ring_cq_db(dev, cq_id, arm_needed, sol_needed, 0); <nl>  		cq->first_arm = false; <nl> -		goto skip_defer; <nl>  	} <nl> -	cq->deferred_arm = true; <nl>   <nl> -skip_defer: <nl> +	cq->deferred_arm = true; <nl>  	cq->deferred_sol = sol_needed; <nl>  	spin_unlock_irqrestore(&cq->cq_lock, flags); <nl>  
@@ -136,10 +136,9 @@ static ssize_t bat_socket_read(struct file *file, char __user *buf, <nl>   <nl>  	spin_unlock_bh(&socket_client->lock); <nl>   <nl> -	error = copy_to_user(buf, &socket_packet->icmp_packet, <nl> -			     socket_packet->icmp_len); <nl> +	packet_len = min(count, socket_packet->icmp_len); <nl> +	error = copy_to_user(buf, &socket_packet->icmp_packet, packet_len); <nl>   <nl> -	packet_len = socket_packet->icmp_len; <nl>  	kfree(socket_packet); <nl>   <nl>  	if (error)
@@ -308,9 +308,17 @@ static const struct i2c_device_id retu_id[] = { <nl>  }; <nl>  MODULE_DEVICE_TABLE(i2c, retu_id); <nl>   <nl> +static const struct of_device_id retu_of_match[] = { <nl> +	{ .compatible = "nokia,retu" }, <nl> +	{ .compatible = "nokia,tahvo" }, <nl> +	{ } <nl> +}; <nl> +MODULE_DEVICE_TABLE(of, retu_of_match); <nl> + <nl>  static struct i2c_driver retu_driver = { <nl>  	.driver		= { <nl>  		.name = "retu-mfd", <nl> +		.of_match_table = retu_of_match, <nl>  	}, <nl>  	.probe		= retu_probe, <nl>  	.remove		= retu_remove,
@@ -1066,6 +1066,7 @@ bool dc_pre_update_surfaces_to_stream( <nl>  	int i, j; <nl>  	struct core_dc *core_dc = DC_TO_CORE(dc); <nl>  	uint32_t prev_disp_clk = core_dc->current_context->bw_results.dispclk_khz; <nl> +	int new_disp_clk; <nl>  	struct dc_stream_status *stream_status = NULL; <nl>  	struct validate_context *context; <nl>  	struct validate_context *temp_context; <nl> @@ -1150,6 +1151,7 @@ bool dc_pre_update_surfaces_to_stream( <nl>  		ret = false; <nl>  		goto unexpected_fail; <nl>  	} <nl> +	new_disp_clk = context->bw_results.dispclk_khz; <nl>   <nl>  	if (core_dc->res_pool->funcs->apply_clk_constraints) { <nl>  		temp_context = core_dc->res_pool->funcs->apply_clk_constraints( <nl> @@ -1166,7 +1168,7 @@ bool dc_pre_update_surfaces_to_stream( <nl>  		context = temp_context; <nl>  	} <nl>   <nl> -	if (prev_disp_clk < context->bw_results.dispclk_khz) { <nl> +	if (prev_disp_clk < new_disp_clk) { <nl>  		pplib_apply_display_requirements(core_dc, context, <nl>  						&context->pp_display_cfg); <nl>  		context->res_ctx.pool->display_clock->funcs->set_clock(
@@ -2310,6 +2310,7 @@ static int hpsa_ioctl32_passthru(struct scsi_device *dev, int cmd, void *arg) <nl>  	int err; <nl>  	u32 cp; <nl>   <nl> +	memset(&arg64, 0, sizeof(arg64)); <nl>  	err = 0; <nl>  	err |= copy_from_user(&arg64.LUN_info, &arg32->LUN_info, <nl>  			   sizeof(arg64.LUN_info)); <nl> @@ -2346,6 +2347,7 @@ static int hpsa_ioctl32_big_passthru(struct scsi_device *dev, <nl>  	int err; <nl>  	u32 cp; <nl>   <nl> +	memset(&arg64, 0, sizeof(arg64)); <nl>  	err = 0; <nl>  	err |= copy_from_user(&arg64.LUN_info, &arg32->LUN_info, <nl>  			   sizeof(arg64.LUN_info));
@@ -555,6 +555,8 @@ static int eql_g_master_cfg(struct net_device *dev, master_config_t __user *mcp) <nl>  	equalizer_t *eql; <nl>  	master_config_t mc; <nl>   <nl> +	memset(&mc, 0, sizeof(master_config_t)); <nl> + <nl>  	if (eql_is_master(dev)) { <nl>  		eql = netdev_priv(dev); <nl>  		mc.max_slaves = eql->max_slaves;
@@ -455,7 +455,7 @@ static void radeon_flip_work_func(struct work_struct *__work) <nl>  	 * In practice this won't execute very often unless on very fast <nl>  	 * machines because the time window for this to happen is very small. <nl>  	 */ <nl> -	while (radeon_crtc->enabled && repcnt--) { <nl> +	while (radeon_crtc->enabled && --repcnt) { <nl>  		/* GET_DISTANCE_TO_VBLANKSTART returns distance to real vblank <nl>  		 * start in hpos, and to the "fudged earlier" vblank start in <nl>  		 * vpos. <nl> @@ -471,13 +471,13 @@ static void radeon_flip_work_func(struct work_struct *__work) <nl>  			break; <nl>   <nl>  		/* Sleep at least until estimated real start of hw vblank */ <nl> -		spin_unlock_irqrestore(&crtc->dev->event_lock, flags); <nl>  		min_udelay = (-hpos + 1) * max(vblank->linedur_ns / 1000, 5); <nl>  		if (min_udelay > vblank->framedur_ns / 2000) { <nl>  			/* Don't wait ridiculously long - something is wrong */ <nl>  			repcnt = 0; <nl>  			break; <nl>  		} <nl> +		spin_unlock_irqrestore(&crtc->dev->event_lock, flags); <nl>  		usleep_range(min_udelay, 2 * min_udelay); <nl>  		spin_lock_irqsave(&crtc->dev->event_lock, flags); <nl>  	};
@@ -401,13 +401,15 @@ int hfi1_user_sdma_alloc_queues(struct hfi1_ctxtdata *uctxt, struct file *fp) <nl>  	if (!pq) <nl>  		goto pq_nomem; <nl>   <nl> -	memsize = sizeof(*pq->reqs) * hfi1_sdma_comp_ring_size; <nl> -	pq->reqs = kzalloc(memsize, GFP_KERNEL); <nl> +	pq->reqs = kcalloc(hfi1_sdma_comp_ring_size, <nl> +			   sizeof(*pq->reqs), <nl> +			   GFP_KERNEL); <nl>  	if (!pq->reqs) <nl>  		goto pq_reqs_nomem; <nl>   <nl> -	memsize = BITS_TO_LONGS(hfi1_sdma_comp_ring_size) * sizeof(long); <nl> -	pq->req_in_use = kzalloc(memsize, GFP_KERNEL); <nl> +	pq->req_in_use = kcalloc(BITS_TO_LONGS(hfi1_sdma_comp_ring_size), <nl> +				 sizeof(*pq->req_in_use), <nl> +				 GFP_KERNEL); <nl>  	if (!pq->req_in_use) <nl>  		goto pq_reqs_no_in_use; <nl>  
@@ -1151,8 +1151,10 @@ tda998x_encoder_init(struct i2c_client *client, <nl>   <nl>  	priv->current_page = 0xff; <nl>  	priv->cec = i2c_new_dummy(client->adapter, 0x34); <nl> -	if (!priv->cec) <nl> +	if (!priv->cec) { <nl> +		kfree(priv); <nl>  		return -ENODEV; <nl> +	} <nl>  	priv->dpms = DRM_MODE_DPMS_OFF; <nl>   <nl>  	encoder_slave->slave_priv = priv;
@@ -400,6 +400,7 @@ nfp_flower_spawn_vnic_reprs(struct nfp_app *app, <nl>  		repr_priv = kzalloc(sizeof(*repr_priv), GFP_KERNEL); <nl>  		if (!repr_priv) { <nl>  			err = -ENOMEM; <nl> +			nfp_repr_free(repr); <nl>  			goto err_reprs_clean; <nl>  		} <nl>   <nl> @@ -413,6 +414,7 @@ nfp_flower_spawn_vnic_reprs(struct nfp_app *app, <nl>  		port = nfp_port_alloc(app, port_type, repr); <nl>  		if (IS_ERR(port)) { <nl>  			err = PTR_ERR(port); <nl> +			kfree(repr_priv); <nl>  			nfp_repr_free(repr); <nl>  			goto err_reprs_clean; <nl>  		} <nl> @@ -433,6 +435,7 @@ nfp_flower_spawn_vnic_reprs(struct nfp_app *app, <nl>  		err = nfp_repr_init(app, repr, <nl>  				    port_id, port, priv->nn->dp.netdev); <nl>  		if (err) { <nl> +			kfree(repr_priv); <nl>  			nfp_port_free(port); <nl>  			nfp_repr_free(repr); <nl>  			goto err_reprs_clean;
@@ -541,7 +541,7 @@ int ieee80211_tx_frame(struct ieee80211_device *ieee, <nl>  	/* When we allocate the TXB we allocate enough space for the reserve <nl>  	 * and full fragment bytes (bytes_per_frag doesn't include prefix, <nl>  	 * postfix, header, FCS, etc.) */ <nl> -	txb = ieee80211_alloc_txb(1, len, GFP_ATOMIC); <nl> +	txb = ieee80211_alloc_txb(1, len, ieee->tx_headroom, GFP_ATOMIC); <nl>  	if (unlikely(!txb)) { <nl>  		printk(KERN_WARNING "%s: Could not allocate TXB\n", <nl>  		       ieee->dev->name);
@@ -142,6 +142,8 @@ int zfcp_unit_add(struct zfcp_port *port, u64 fcp_lun) <nl>  		return -ENOMEM; <nl>  	} <nl>   <nl> +	get_device(&port->dev); <nl> + <nl>  	if (device_register(&unit->dev)) { <nl>  		put_device(&unit->dev); <nl>  		return -ENOMEM; <nl> @@ -152,8 +154,6 @@ int zfcp_unit_add(struct zfcp_port *port, u64 fcp_lun) <nl>  		return -EINVAL; <nl>  	} <nl>   <nl> -	get_device(&port->dev); <nl> - <nl>  	write_lock_irq(&port->unit_list_lock); <nl>  	list_add_tail(&unit->list, &port->unit_list); <nl>  	write_unlock_irq(&port->unit_list_lock);
@@ -376,8 +376,8 @@ static void etb_update_buffer(struct coresight_device *csdev, <nl>   <nl>  	capacity = drvdata->buffer_depth * ETB_FRAME_SIZE_WORDS; <nl>   <nl> -	CS_UNLOCK(drvdata->base); <nl>  	etb_disable_hw(drvdata); <nl> +	CS_UNLOCK(drvdata->base); <nl>   <nl>  	/* unit is in words, not bytes */ <nl>  	read_ptr = readl_relaxed(drvdata->base + ETB_RAM_READ_POINTER);
@@ -126,7 +126,7 @@ static int create_in_format_blob(struct drm_device *dev, struct drm_plane *plane <nl>  							       plane->format_types[j], <nl>  							       plane->modifiers[i])) { <nl>   <nl> -				mod->formats |= 1 << j; <nl> +				mod->formats |= 1ULL << j; <nl>  			} <nl>  		} <nl>  
@@ -335,8 +335,6 @@ static int __devinit dwc3_core_init(struct dwc3 *dwc) <nl>  	} <nl>  	dwc->revision = reg; <nl>   <nl> -	dwc3_core_soft_reset(dwc); <nl> - <nl>  	/* issue device SoftReset too */ <nl>  	timeout = jiffies + msecs_to_jiffies(500); <nl>  	dwc3_writel(dwc->regs, DWC3_DCTL, DWC3_DCTL_CSFTRST); <nl> @@ -354,6 +352,8 @@ static int __devinit dwc3_core_init(struct dwc3 *dwc) <nl>  		cpu_relax(); <nl>  	} while (true); <nl>   <nl> +	dwc3_core_soft_reset(dwc); <nl> + <nl>  	dwc3_cache_hwparams(dwc); <nl>   <nl>  	reg = dwc3_readl(dwc->regs, DWC3_GCTL);
@@ -60,7 +60,7 @@ static u32 __init allocate_aperture(void) <nl>  		printk("Cannot allocate aperture memory hole (%p,%uK)\n", <nl>  		       p, aper_size>>10); <nl>  		if (p) <nl> -			free_bootmem_node(nd0, (unsigned long)p, aper_size);  <nl> +			free_bootmem_node(nd0, __pa(p), aper_size);  <nl>  		return 0; <nl>  	} <nl>  	printk("Mapping aperture over %d KB of RAM @ %lx\n",
@@ -190,6 +190,7 @@ static void tm6000_config_tuner (struct tm6000_core *dev) <nl>   <nl>  		ctl.mts   = 1; <nl>  		ctl.read_not_reliable = 1; <nl> +		ctl.msleep = 10; <nl>   <nl>  		xc2028_cfg.tuner = TUNER_XC2028; <nl>  		xc2028_cfg.priv  = &ctl;
@@ -90,7 +90,7 @@ static struct sk_buff *udp6_ufo_fragment(struct sk_buff *skb, <nl>   <nl>  		/* Check if there is enough headroom to insert fragment header. */ <nl>  		tnl_hlen = skb_tnl_header_len(skb); <nl> -		if (skb_headroom(skb) < (tnl_hlen + frag_hdr_sz)) { <nl> +		if (skb->mac_header < (tnl_hlen + frag_hdr_sz)) { <nl>  			if (gso_pskb_expand_head(skb, tnl_hlen + frag_hdr_sz)) <nl>  				goto out; <nl>  		}
@@ -155,6 +155,9 @@ static ssize_t oz_cdev_write(struct file *filp, const char __user *buf, <nl>  	struct oz_app_hdr *app_hdr; <nl>  	struct oz_serial_ctx *ctx; <nl>   <nl> +	if (count > sizeof(ei->data) - sizeof(*elt) - sizeof(*app_hdr)) <nl> +		return -EINVAL; <nl> + <nl>  	spin_lock_bh(&g_cdev.lock); <nl>  	pd = g_cdev.active_pd; <nl>  	if (pd)
@@ -1210,19 +1210,20 @@ static int __init intel_idle_init(void) <nl>  	if (retval) <nl>  		return retval; <nl>   <nl> +	intel_idle_cpuidle_devices = alloc_percpu(struct cpuidle_device); <nl> +	if (intel_idle_cpuidle_devices == NULL) <nl> +		return -ENOMEM; <nl> + <nl>  	intel_idle_cpuidle_driver_init(); <nl>  	retval = cpuidle_register_driver(&intel_idle_driver); <nl>  	if (retval) { <nl>  		struct cpuidle_driver *drv = cpuidle_get_driver(); <nl>  		printk(KERN_DEBUG PREFIX "intel_idle yielding to %s", <nl>  			drv ? drv->name : "none"); <nl> +		free_percpu(intel_idle_cpuidle_devices); <nl>  		return retval; <nl>  	} <nl>   <nl> -	intel_idle_cpuidle_devices = alloc_percpu(struct cpuidle_device); <nl> -	if (intel_idle_cpuidle_devices == NULL) <nl> -		return -ENOMEM; <nl> - <nl>  	cpu_notifier_register_begin(); <nl>   <nl>  	for_each_online_cpu(i) {
@@ -200,7 +200,7 @@ struct oz_pd *oz_pd_alloc(const u8 *mac_addr) <nl>  /* <nl>   * Context: softirq or process <nl>   */ <nl> -void oz_pd_free(struct work_struct *work) <nl> +static void oz_pd_free(struct work_struct *work) <nl>  { <nl>  	struct list_head *e; <nl>  	struct oz_tx_frame *f;
@@ -2244,6 +2244,10 @@ static noinline long btrfs_ioctl_clone(struct file *file, unsigned long srcfd, <nl>  		btrfs_wait_ordered_range(src, off, len); <nl>  	} <nl>   <nl> +	/* truncate page cache pages from target inode range */ <nl> +	truncate_inode_pages_range(&inode->i_data, off, <nl> +				   ALIGN(off + len, PAGE_CACHE_SIZE) - 1); <nl> + <nl>  	/* clone data */ <nl>  	key.objectid = btrfs_ino(src); <nl>  	key.type = BTRFS_EXTENT_DATA_KEY;
@@ -334,7 +334,7 @@ static int synpatics_rmi4_touchpad_report(struct synaptics_rmi4_data *pdata, <nl>  	 *	10 = finger present but data may not be accurate, <nl>  	 *	11 = reserved for product use. <nl>  	 */ <nl> -	finger_registers	= (fingers_supported + 3)/4; <nl> +	finger_registers	= (fingers_supported + 3) / 4; <nl>  	data_base_addr		= rfi->fn_desc.data_base_addr; <nl>  	retval = synaptics_rmi4_i2c_block_read(pdata, data_base_addr, values, <nl>  							finger_registers); <nl> @@ -350,7 +350,7 @@ static int synpatics_rmi4_touchpad_report(struct synaptics_rmi4_data *pdata, <nl>  	data_reg_blk_size = rfi->size_of_data_register_block; <nl>  	for (finger = 0; finger < fingers_supported; finger++) { <nl>  		/* determine which data byte the finger status is in */ <nl> -		reg = finger/4; <nl> +		reg = finger / 4; <nl>  		/* bit shift to get finger's status */ <nl>  		finger_shift	= (finger % 4) * 2; <nl>  		finger_status	= (values[reg] >> finger_shift) & 3; <nl> @@ -566,7 +566,7 @@ static int synpatics_rmi4_touchpad_detect(struct synaptics_rmi4_data *pdata, <nl>  	} <nl>  	pdata->fingers_supported = rfi->num_of_data_points; <nl>  	/* Need to get interrupt info for handling interrupts */ <nl> -	rfi->index_to_intr_reg = (interruptcount + 7)/8; <nl> +	rfi->index_to_intr_reg = (interruptcount + 7) / 8; <nl>  	if (rfi->index_to_intr_reg != 0) <nl>  		rfi->index_to_intr_reg -= 1; <nl>  	/*
@@ -423,6 +423,12 @@ static int qt1010_get_bandwidth(struct dvb_frontend *fe, u32 *bandwidth) <nl>  	return 0; <nl>  } <nl>   <nl> +static int qt1010_get_if_frequency(struct dvb_frontend *fe, u32 *frequency) <nl> +{ <nl> +	*frequency = 36125000; <nl> +	return 0; <nl> +} <nl> + <nl>  static const struct dvb_tuner_ops qt1010_tuner_ops = { <nl>  	.info = { <nl>  		.name           = "Quantek QT1010", <nl> @@ -437,7 +443,8 @@ static const struct dvb_tuner_ops qt1010_tuner_ops = { <nl>   <nl>  	.set_params    = qt1010_set_params, <nl>  	.get_frequency = qt1010_get_frequency, <nl> -	.get_bandwidth = qt1010_get_bandwidth <nl> +	.get_bandwidth = qt1010_get_bandwidth, <nl> +	.get_if_frequency = qt1010_get_if_frequency, <nl>  }; <nl>   <nl>  struct dvb_frontend * qt1010_attach(struct dvb_frontend *fe,
@@ -11,7 +11,6 @@ <nl>  #include <linux/mount.h> <nl>  #include <linux/time.h> <nl>  #include <linux/msdos_fs.h> <nl> -#include <linux/smp_lock.h> <nl>  #include <linux/buffer_head.h> <nl>  #include <linux/writeback.h> <nl>  #include <linux/backing-dev.h> <nl> @@ -229,8 +228,7 @@ static int fat_free(struct inode *inode, int skip) <nl>   <nl>  void fat_truncate(struct inode *inode) <nl>  { <nl> -	struct super_block *sb = inode->i_sb; <nl> -	struct msdos_sb_info *sbi = MSDOS_SB(sb); <nl> +	struct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb); <nl>  	const unsigned int cluster_size = sbi->cluster_size; <nl>  	int nr_clusters; <nl>   <nl> @@ -243,9 +241,7 @@ void fat_truncate(struct inode *inode) <nl>   <nl>  	nr_clusters = (inode->i_size + (cluster_size - 1)) >> sbi->cluster_bits; <nl>   <nl> -	lock_super(sb); <nl>  	fat_free(inode, nr_clusters); <nl> -	unlock_super(sb); <nl>  	fat_flush_inodes(inode->i_sb, inode, NULL); <nl>  } <nl>   <nl> @@ -298,14 +294,11 @@ static int fat_allow_set_time(struct msdos_sb_info *sbi, struct inode *inode) <nl>   <nl>  int fat_setattr(struct dentry *dentry, struct iattr *attr) <nl>  { <nl> -	struct super_block *sb = dentry->d_sb; <nl>  	struct msdos_sb_info *sbi = MSDOS_SB(dentry->d_sb); <nl>  	struct inode *inode = dentry->d_inode; <nl>  	int mask, error = 0; <nl>  	unsigned int ia_valid; <nl>   <nl> -	lock_super(sb); <nl> - <nl>  	/* <nl>  	 * Expand the file. Since inode_setattr() updates ->i_size <nl>  	 * before calling the ->truncate(), but FAT needs to fill the <nl> @@ -358,7 +351,6 @@ int fat_setattr(struct dentry *dentry, struct iattr *attr) <nl>  		mask = sbi->options.fs_fmask; <nl>  	inode->i_mode &= S_IFMT | (S_IRWXUGO & ~mask); <nl>  out: <nl> -	unlock_super(sb); <nl>  	return error; <nl>  } <nl>  EXPORT_SYMBOL_GPL(fat_setattr);
@@ -566,6 +566,9 @@ int create_flush_cmd_control(struct f2fs_sb_info *sbi) <nl>  	init_waitqueue_head(&fcc->flush_wait_queue); <nl>  	init_llist_head(&fcc->issue_list); <nl>  	SM_I(sbi)->fcc_info = fcc; <nl> +	if (!test_opt(sbi, FLUSH_MERGE)) <nl> +		return err; <nl> + <nl>  init_thread: <nl>  	fcc->f2fs_issue_flush = kthread_run(issue_flush_thread, sbi, <nl>  				"f2fs_flush-%u:%u", MAJOR(dev), MINOR(dev)); <nl> @@ -3240,7 +3243,7 @@ int build_segment_manager(struct f2fs_sb_info *sbi) <nl>   <nl>  	INIT_LIST_HEAD(&sm_info->sit_entry_set); <nl>   <nl> -	if (test_opt(sbi, FLUSH_MERGE) && !f2fs_readonly(sbi->sb)) { <nl> +	if (!f2fs_readonly(sbi->sb)) { <nl>  		err = create_flush_cmd_control(sbi); <nl>  		if (err) <nl>  			return err;
@@ -98,6 +98,15 @@ int arch_decode_instruction(struct elf *elf, struct section *sec, <nl>  			*type = INSN_FP_SETUP; <nl>  		break; <nl>   <nl> +	case 0x8d: <nl> +		if (insn.rex_prefix.bytes && <nl> +		    insn.rex_prefix.bytes[0] == 0x48 && <nl> +		    insn.modrm.nbytes && insn.modrm.bytes[0] == 0x2c && <nl> +		    insn.sib.nbytes && insn.sib.bytes[0] == 0x24) <nl> +			/* lea %(rsp), %rbp */ <nl> +			*type = INSN_FP_SETUP; <nl> +		break; <nl> + <nl>  	case 0x90: <nl>  		*type = INSN_NOP; <nl>  		break;
@@ -34,10 +34,14 @@ size_t syscall_arg__scnprintf_fcntl_cmd(char *bf, size_t size, struct syscall_ar <nl>  		syscall_arg__set_ret_scnprintf(arg, syscall_arg__scnprintf_fd); <nl>  		goto out; <nl>  	} <nl> +	if (arg->val == F_GETOWN) { <nl> +		syscall_arg__set_ret_scnprintf(arg, syscall_arg__scnprintf_pid); <nl> +		goto mask_arg; <nl> +	} <nl>  	/* <nl>  	 * Some commands ignore the third fcntl argument, "arg", so mask it <nl>  	 */ <nl> -	if (arg->val == F_GETOWN   || arg->val == F_GET_SEALS || <nl> +	if (arg->val == F_GET_SEALS || <nl>  	    arg->val == F_GETLEASE || arg->val == F_GETSIG) { <nl>  mask_arg: <nl>  		arg->mask |= (1 << 2); <nl> @@ -55,6 +59,9 @@ size_t syscall_arg__scnprintf_fcntl_arg(char *bf, size_t size, struct syscall_ar <nl>   <nl>  	if (cmd == F_SETFL) <nl>  		return open__scnprintf_flags(arg->val, bf, size); <nl> + <nl> +	if (cmd == F_SETOWN) <nl> +		return syscall_arg__scnprintf_pid(bf, size, arg); <nl>  	/* <nl>  	 * We still don't grab the contents of pointers on entry or exit, <nl>  	 * so just print them as hex numbers
@@ -1932,6 +1932,7 @@ static int intel_pt_walk_to_ip(struct intel_pt_decoder *decoder) <nl>  			break; <nl>   <nl>  		case INTEL_PT_PSB: <nl> +			intel_pt_clear_stack(&decoder->stack); <nl>  			err = intel_pt_walk_psb(decoder); <nl>  			if (err) <nl>  				return err;
@@ -2237,6 +2237,12 @@ static void mwifiex_recreate_adapter(struct sdio_mmc_card *card) <nl>  	mmc_hw_reset(func->card->host); <nl>  	sdio_release_host(func); <nl>   <nl> +	/* Previous save_adapter won't be valid after this. We will cancel <nl> +	 * pending work requests. <nl> +	 */ <nl> +	clear_bit(MWIFIEX_IFACE_WORK_DEVICE_DUMP, &iface_work_flags); <nl> +	clear_bit(MWIFIEX_IFACE_WORK_CARD_RESET, &iface_work_flags); <nl> + <nl>  	mwifiex_sdio_probe(func, device_id); <nl>  } <nl>  
@@ -726,9 +726,14 @@ static struct dma_chan *jz4780_of_dma_xlate(struct of_phandle_args *dma_spec, <nl>  				data.channel); <nl>  			return NULL; <nl>  		} <nl> -	} <nl>   <nl> -	return dma_request_channel(mask, jz4780_dma_filter_fn, &data); <nl> +		jzdma->chan[data.channel].transfer_type = data.transfer_type; <nl> + <nl> +		return dma_get_slave_channel( <nl> +			&jzdma->chan[data.channel].vchan.chan); <nl> +	} else { <nl> +		return dma_request_channel(mask, jz4780_dma_filter_fn, &data); <nl> +	} <nl>  } <nl>   <nl>  static int jz4780_dma_probe(struct platform_device *pdev)
@@ -75,6 +75,7 @@ enum { <nl>  	EC_FLAGS_WAIT_GPE = 0,		/* Don't check status until GPE arrives */ <nl>  	EC_FLAGS_QUERY_PENDING,		/* Query is pending */ <nl>  	EC_FLAGS_GPE_MODE,		/* Expect GPE to be sent for status change */ <nl> +	EC_FLAGS_ONLY_IBF_GPE,		/* Expect GPE only for IBF = 0 event */ <nl>  }; <nl>   <nl>  static int acpi_ec_remove(struct acpi_device *device, int type); <nl> @@ -172,7 +173,12 @@ static int acpi_ec_wait(struct acpi_ec *ec, enum ec_event event, int force_poll) <nl>  			return 0; <nl>  		clear_bit(EC_FLAGS_WAIT_GPE, &ec->flags); <nl>  		if (acpi_ec_check_status(ec, event)) { <nl> -			clear_bit(EC_FLAGS_GPE_MODE, &ec->flags); <nl> +			if (event == ACPI_EC_EVENT_OBF_1) <nl> +				/* miss OBF = 1 GPE, don't expect it anymore */ <nl> +				set_bit(EC_FLAGS_ONLY_IBF_GPE, &ec->flags); <nl> +			else <nl> +				/* missing GPEs, switch back to poll mode */ <nl> +				clear_bit(EC_FLAGS_GPE_MODE, &ec->flags); <nl>  			return 0; <nl>  		} <nl>  	} else { <nl> @@ -220,6 +226,8 @@ static int acpi_ec_transaction_unlocked(struct acpi_ec *ec, u8 command, <nl>  		clear_bit(EC_FLAGS_QUERY_PENDING, &ec->flags); <nl>   <nl>  	for (; rdata_len > 0; --rdata_len) { <nl> +		if (test_bit(EC_FLAGS_ONLY_IBF_GPE, &ec->flags)) <nl> +			force_poll = 1; <nl>  		result = acpi_ec_wait(ec, ACPI_EC_EVENT_OBF_1, force_poll); <nl>  		if (result) { <nl>  			printk(KERN_ERR PREFIX "read timeout, command = %d\n",
@@ -1046,6 +1046,7 @@ static int snd_mixer_oss_build_input(struct snd_mixer_oss *mixer, struct snd_mix <nl>  			 <nl>  		if (kctl->info(kctl, uinfo)) { <nl>  			up_read(&mixer->card->controls_rwsem); <nl> +			kfree(uinfo); <nl>  			return 0; <nl>  		} <nl>  		strcpy(str, ptr->name); <nl> @@ -1061,6 +1062,7 @@ static int snd_mixer_oss_build_input(struct snd_mixer_oss *mixer, struct snd_mix <nl>  				uinfo->value.enumerated.item = slot.capture_item; <nl>  				if (kctl->info(kctl, uinfo)) { <nl>  					up_read(&mixer->card->controls_rwsem); <nl> +					kfree(uinfo); <nl>  					return 0; <nl>  				} <nl>  				if (!strcmp(uinfo->value.enumerated.name, str)) {
@@ -405,6 +405,11 @@ int i915_gem_init_stolen(struct drm_i915_private *dev_priv) <nl>   <nl>  	mutex_init(&dev_priv->mm.stolen_lock); <nl>   <nl> +	if (intel_vgpu_active(dev_priv)) { <nl> +		DRM_INFO("iGVT-g active, disabling use of stolen memory\n"); <nl> +		return 0; <nl> +	} <nl> + <nl>  #ifdef CONFIG_INTEL_IOMMU <nl>  	if (intel_iommu_gfx_mapped && INTEL_GEN(dev_priv) < 8) { <nl>  		DRM_INFO("DMAR active, disabling use of stolen memory\n");
@@ -129,13 +129,13 @@ int kdbnearsym(unsigned long addr, kdb_symtab_t *symtab) <nl>  		} <nl>  		if (i >= ARRAY_SIZE(kdb_name_table)) { <nl>  			debug_kfree(kdb_name_table[0]); <nl> -			memcpy(kdb_name_table, kdb_name_table+1, <nl> +			memmove(kdb_name_table, kdb_name_table+1, <nl>  			       sizeof(kdb_name_table[0]) * <nl>  			       (ARRAY_SIZE(kdb_name_table)-1)); <nl>  		} else { <nl>  			debug_kfree(knt1); <nl>  			knt1 = kdb_name_table[i]; <nl> -			memcpy(kdb_name_table+i, kdb_name_table+i+1, <nl> +			memmove(kdb_name_table+i, kdb_name_table+i+1, <nl>  			       sizeof(kdb_name_table[0]) * <nl>  			       (ARRAY_SIZE(kdb_name_table)-i-1)); <nl>  		}
@@ -619,6 +619,8 @@ static int spi_map_buf(struct spi_master *master, struct device *dev, <nl>  	} <nl>   <nl>  	ret = dma_map_sg(dev, sgt->sgl, sgt->nents, dir); <nl> +	if (!ret) <nl> +		ret = -ENOMEM; <nl>  	if (ret < 0) { <nl>  		sg_free_table(sgt); <nl>  		return ret;
@@ -851,13 +851,15 @@ static void uli526x_rx_packet(struct net_device *dev, struct uli526x_board_info <nl>   <nl>  			if ( !(rdes0 & 0x8000) || <nl>  				((db->cr6_data & CR6_PM) && (rxlen>6)) ) { <nl> +				struct sk_buff *new_skb = NULL; <nl> + <nl>  				skb = rxptr->rx_skb_ptr; <nl>   <nl>  				/* Good packet, send to upper layer */ <nl>  				/* Shorst packet used new SKB */ <nl> -				if ( (rxlen < RX_COPY_SIZE) && <nl> -					( (skb = dev_alloc_skb(rxlen + 2) ) <nl> -					!= NULL) ) { <nl> +				if ((rxlen < RX_COPY_SIZE) && <nl> +				    ((new_skb = dev_alloc_skb(rxlen + 2) != NULL))) { <nl> +					skb = new_skb; <nl>  					/* size less than COPY_SIZE, allocate a rxlen SKB */ <nl>  					skb_reserve(skb, 2); /* 16byte align */ <nl>  					memcpy(skb_put(skb, rxlen),
@@ -276,6 +276,9 @@ static void __ieee80211_wake_queue(struct ieee80211_hw *hw, int queue, <nl>  	if (WARN_ON(queue >= hw->queues)) <nl>  		return; <nl>   <nl> +	if (!test_bit(reason, &local->queue_stop_reasons[queue])) <nl> +		return; <nl> + <nl>  	__clear_bit(reason, &local->queue_stop_reasons[queue]); <nl>   <nl>  	if (local->queue_stop_reasons[queue] != 0) <nl> @@ -323,6 +326,9 @@ static void __ieee80211_stop_queue(struct ieee80211_hw *hw, int queue, <nl>  	if (WARN_ON(queue >= hw->queues)) <nl>  		return; <nl>   <nl> +	if (test_bit(reason, &local->queue_stop_reasons[queue])) <nl> +		return; <nl> + <nl>  	__set_bit(reason, &local->queue_stop_reasons[queue]); <nl>   <nl>  	rcu_read_lock();
@@ -1567,6 +1567,13 @@ static int hists_evsel__init(struct perf_evsel *evsel) <nl>  	return 0; <nl>  } <nl>   <nl> +static void hists_evsel__exit(struct perf_evsel *evsel) <nl> +{ <nl> +	struct hists *hists = evsel__hists(evsel); <nl> + <nl> +	hists__delete_entries(hists); <nl> +} <nl> + <nl>  /* <nl>   * XXX We probably need a hists_evsel__exit() to free the hist_entries <nl>   * stored in the rbtree... <nl> @@ -1575,7 +1582,8 @@ static int hists_evsel__init(struct perf_evsel *evsel) <nl>  int hists__init(void) <nl>  { <nl>  	int err = perf_evsel__object_config(sizeof(struct hists_evsel), <nl> -					    hists_evsel__init, NULL); <nl> +					    hists_evsel__init, <nl> +					    hists_evsel__exit); <nl>  	if (err) <nl>  		fputs("FATAL ERROR: Couldn't setup hists class\n", stderr); <nl>  
@@ -759,6 +759,9 @@ static ssize_t iwl_dbgfs_fw_rx_stats_read(struct file *file, <nl>   <nl>  	mutex_lock(&mvm->mutex); <nl>   <nl> +	if (iwl_mvm_firmware_running(mvm)) <nl> +		iwl_mvm_request_statistics(mvm, false); <nl> + <nl>  	pos += scnprintf(buf + pos, bufsz - pos, fmt_header, <nl>  			 "Statistics_Rx - OFDM"); <nl>  	if (!iwl_mvm_has_new_rx_stats_api(mvm)) {
@@ -2486,6 +2486,7 @@ static int shmem_remount_fs(struct super_block *sb, int *flags, char *data) <nl>  	unsigned long inodes; <nl>  	int error = -EINVAL; <nl>   <nl> +	config.mpol = NULL; <nl>  	if (shmem_parse_options(data, &config, true)) <nl>  		return error; <nl>   <nl> @@ -2510,8 +2511,13 @@ static int shmem_remount_fs(struct super_block *sb, int *flags, char *data) <nl>  	sbinfo->max_inodes  = config.max_inodes; <nl>  	sbinfo->free_inodes = config.max_inodes - inodes; <nl>   <nl> -	mpol_put(sbinfo->mpol); <nl> -	sbinfo->mpol        = config.mpol;	/* transfers initial ref */ <nl> +	/* <nl> +	 * Preserve previous mempolicy unless mpol remount option was specified. <nl> +	 */ <nl> +	if (config.mpol) { <nl> +		mpol_put(sbinfo->mpol); <nl> +		sbinfo->mpol = config.mpol;	/* transfers initial ref */ <nl> +	} <nl>  out: <nl>  	spin_unlock(&sbinfo->stat_lock); <nl>  	return error;
@@ -226,7 +226,7 @@ ssize_t btrfs_listxattr(struct dentry *dentry, char *buffer, size_t size) <nl>   <nl>  		if (!buffer || (name_len + 1) > size_left) { <nl>  			ret = -ERANGE; <nl> -			break; <nl> +			goto err; <nl>  		} <nl>   <nl>  		name_ptr = (unsigned long)(di + 1);
@@ -1878,6 +1878,9 @@ static int futex_requeue(u32 __user *uaddr1, unsigned int flags, <nl>  	struct futex_q *this, *next; <nl>  	DEFINE_WAKE_Q(wake_q); <nl>   <nl> +	if (nr_wake < 0 || nr_requeue < 0) <nl> +		return -EINVAL; <nl> + <nl>  	/* <nl>  	 * When PI not supported: return -ENOSYS if requeue_pi is true, <nl>  	 * consequently the compiler knows requeue_pi is always false past
@@ -546,6 +546,7 @@ static void __init kvm_guest_init(void) <nl>  	} <nl>   <nl>  	if (kvm_para_has_feature(KVM_FEATURE_PV_TLB_FLUSH) && <nl> +	    !kvm_para_has_hint(KVM_HINTS_DEDICATED) && <nl>  	    !kvm_para_has_feature(KVM_FEATURE_STEAL_TIME)) <nl>  		pv_mmu_ops.flush_tlb_others = kvm_flush_tlb_others; <nl>   <nl> @@ -640,6 +641,7 @@ static __init int kvm_setup_pv_tlb_flush(void) <nl>  	int cpu; <nl>   <nl>  	if (kvm_para_has_feature(KVM_FEATURE_PV_TLB_FLUSH) && <nl> +	    !kvm_para_has_hint(KVM_HINTS_DEDICATED) && <nl>  	    !kvm_para_has_feature(KVM_FEATURE_STEAL_TIME)) { <nl>  		for_each_possible_cpu(cpu) { <nl>  			zalloc_cpumask_var_node(per_cpu_ptr(&__pv_tlb_mask, cpu),
@@ -99,8 +99,10 @@ aoenet_xmit(struct sk_buff_head *queue) <nl>  { <nl>  	struct sk_buff *skb, *tmp; <nl>   <nl> -	skb_queue_walk_safe(queue, skb, tmp) <nl> +	skb_queue_walk_safe(queue, skb, tmp) { <nl> +		__skb_unlink(skb, queue); <nl>  		dev_queue_xmit(skb); <nl> +	} <nl>  } <nl>   <nl>  /* 
@@ -5065,6 +5065,10 @@ static u16 ar9003_hw_get_max_edge_power(struct ar9300_eeprom *eep, <nl>  			break; <nl>  		} <nl>  	} <nl> + <nl> +	if (is2GHz && !twiceMaxEdgePower) <nl> +		twiceMaxEdgePower = 60; <nl> + <nl>  	return twiceMaxEdgePower; <nl>  } <nl>  
@@ -270,6 +270,7 @@ long keyctl_join_session_keyring(const char __user *_name) <nl>   <nl>  	/* join the session */ <nl>  	ret = join_session_keyring(name); <nl> +	kfree(name); <nl>   <nl>   error: <nl>  	return ret;
@@ -1650,6 +1650,8 @@ static int dwc3_gadget_init_hw_endpoints(struct dwc3 *dwc, <nl>   <nl>  		dep->endpoint.name = dep->name; <nl>   <nl> +		dev_vdbg(dwc->dev, "initializing %s\n", dep->name); <nl> + <nl>  		if (epnum == 0 || epnum == 1) { <nl>  			dep->endpoint.maxpacket = 512; <nl>  			dep->endpoint.maxburst = 1;
@@ -1264,6 +1264,8 @@ static bool svc_rqst_integrity_protected(struct svc_rqst *rqstp) <nl>  	struct svc_cred *cr = &rqstp->rq_cred; <nl>  	u32 service; <nl>   <nl> +	if (!cr->cr_gss_mech) <nl> +		return false; <nl>  	service = gss_pseudoflavor_to_service(cr->cr_gss_mech, cr->cr_flavor); <nl>  	return service == RPC_GSS_SVC_INTEGRITY || <nl>  	       service == RPC_GSS_SVC_PRIVACY;
@@ -1608,7 +1608,7 @@ static int pch_udc_pcd_queue(struct usb_ep *usbep, struct usb_request *usbreq, <nl>  		return -EINVAL; <nl>  	if (!dev->driver || (dev->gadget.speed == USB_SPEED_UNKNOWN)) <nl>  		return -ESHUTDOWN; <nl> -	spin_lock_irqsave(&ep->dev->lock, iflags); <nl> +	spin_lock_irqsave(&dev->lock, iflags); <nl>  	/* map the buffer for dma */ <nl>  	if (usbreq->length && <nl>  	    ((usbreq->dma == DMA_ADDR_INVALID) || !usbreq->dma)) { <nl> @@ -1625,8 +1625,10 @@ static int pch_udc_pcd_queue(struct usb_ep *usbep, struct usb_request *usbreq, <nl>  							     DMA_FROM_DEVICE); <nl>  		} else { <nl>  			req->buf = kzalloc(usbreq->length, GFP_ATOMIC); <nl> -			if (!req->buf) <nl> -				return -ENOMEM; <nl> +			if (!req->buf) { <nl> +				retval = -ENOMEM; <nl> +				goto probe_end; <nl> +			} <nl>  			if (ep->in) { <nl>  				memcpy(req->buf, usbreq->buf, usbreq->length); <nl>  				req->dma = dma_map_single(&dev->pdev->dev,
@@ -332,6 +332,9 @@ static int btrfs_ioctl_setflags(struct file *file, void __user *arg) <nl>  			goto out_drop; <nl>   <nl>  	} else { <nl> +		ret = btrfs_set_prop(inode, "btrfs.compression", NULL, 0, 0); <nl> +		if (ret && ret != -ENODATA) <nl> +			goto out_drop; <nl>  		ip->flags &= ~(BTRFS_INODE_COMPRESS | BTRFS_INODE_NOCOMPRESS); <nl>  	} <nl>  
@@ -756,7 +756,7 @@ cifs_lookup(struct inode *parent_dir_inode, struct dentry *direntry, <nl>  	/*	if it was once a directory (but how can we tell?) we could do <nl>  		shrink_dcache_parent(direntry); */ <nl>  	} else if (rc != -EACCES) { <nl> -		cifs_dbg(VFS, "Unexpected lookup error %d\n", rc); <nl> +		cifs_dbg(FYI, "Unexpected lookup error %d\n", rc); <nl>  		/* We special case check for Access Denied - since that <nl>  		is a common return code */ <nl>  	}
@@ -674,6 +674,14 @@ static void ath_beacon_config_adhoc(struct ath_softc *sc, <nl>   <nl>  	intval = conf->beacon_interval & ATH9K_BEACON_PERIOD; <nl>   <nl> +	/* <nl> +	 * It looks like mac80211 may end up using beacon interval of zero in <nl> +	 * some cases (at least for mesh point). Avoid getting into an <nl> +	 * infinite loop by using a bit safer value instead.. <nl> +	 */ <nl> +	if (intval == 0) <nl> +		intval = 100; <nl> + <nl>  	/* Pull nexttbtt forward to reflect the current TSF */ <nl>   <nl>  	nexttbtt = TSF_TO_TU(sc->beacon.bc_tstamp >> 32, sc->beacon.bc_tstamp);
@@ -137,7 +137,7 @@ int vty_init(const struct file_operations *console_fops); <nl>   <nl>  static inline bool vt_force_oops_output(struct vc_data *vc) <nl>  { <nl> -	if (oops_in_progress && vc->vc_panic_force_write) <nl> +	if (oops_in_progress && vc->vc_panic_force_write  && panic_timeout >= 0) <nl>  		return true; <nl>  	return false; <nl>  }
@@ -125,9 +125,6 @@ struct thread_struct { <nl>  	.pgdir = swapper_pg_dir, \ <nl>  } <nl>   <nl> -/* Do necessary setup to start up a newly executed thread.  */ <nl> -void start_thread(struct pt_regs *regs, <nl> -		unsigned long pc, unsigned long usp); <nl>   <nl>  /* Free all resources held by a thread. */ <nl>  extern inline void release_thread(struct task_struct *dead_task)
@@ -255,6 +255,7 @@ static long seccomp_attach_filter(struct sock_fprog *fprog) <nl>  		goto free_prog; <nl>   <nl>  	/* Allocate a new seccomp_filter */ <nl> +	ret = -ENOMEM; <nl>  	filter = kzalloc(sizeof(struct seccomp_filter) + <nl>  			 sizeof(struct sock_filter_int) * new_len, <nl>  			 GFP_KERNEL|__GFP_NOWARN); <nl> @@ -264,6 +265,7 @@ static long seccomp_attach_filter(struct sock_fprog *fprog) <nl>  	ret = sk_convert_filter(fp, fprog->len, filter->insnsi, &new_len); <nl>  	if (ret) <nl>  		goto free_filter; <nl> +	kfree(fp); <nl>   <nl>  	atomic_set(&filter->usage, 1); <nl>  	filter->len = new_len;
@@ -1385,9 +1385,11 @@ void ieee80211_beacon_connection_loss_work(struct work_struct *work) <nl>  	struct sta_info *sta; <nl>   <nl>  	if (ifmgd->associated) { <nl> +		rcu_read_lock(); <nl>  		sta = sta_info_get(sdata, ifmgd->bssid); <nl>  		if (sta) <nl>  			sta->beacon_loss_count++; <nl> +		rcu_read_unlock(); <nl>  	} <nl>   <nl>  	if (sdata->local->hw.flags & IEEE80211_HW_CONNECTION_MONITOR)
@@ -2196,7 +2196,7 @@ int mwifiex_ret_802_11_scan(struct mwifiex_private *priv, <nl>   <nl>  			pmatch = adapter->nd_info->matches[idx]; <nl>   <nl> -			if (!pmatch) { <nl> +			if (pmatch) { <nl>  				memset(pmatch, 0, sizeof(*pmatch)); <nl>  				if (chan_band_tlv) { <nl>  					pmatch->n_channels = 1;
@@ -2618,6 +2618,9 @@ static void proc_flush_task_mnt(struct vfsmount *mnt, pid_t pid, pid_t tgid) <nl>  		dput(dentry); <nl>  	} <nl>   <nl> +	if (pid == tgid) <nl> +		return; <nl> + <nl>  	name.name = buf; <nl>  	name.len = snprintf(buf, sizeof(buf), "%d", tgid); <nl>  	leader = d_hash_and_lookup(mnt->mnt_root, &name);
@@ -155,6 +155,7 @@ static int mxs_phy_probe(struct platform_device *pdev) <nl>  	mxs_phy->phy.set_suspend	= mxs_phy_suspend; <nl>  	mxs_phy->phy.notify_connect	= mxs_phy_on_connect; <nl>  	mxs_phy->phy.notify_disconnect	= mxs_phy_on_disconnect; <nl> +	mxs_phy->phy.type		= USB_PHY_TYPE_USB2; <nl>   <nl>  	ATOMIC_INIT_NOTIFIER_HEAD(&mxs_phy->phy.notifier); <nl>  
@@ -435,7 +435,7 @@ static int gart_map_sg(struct device *dev, struct scatterlist *sg, int nents, <nl>   <nl>  error: <nl>  	flush_gart(); <nl> -	gart_unmap_sg(dev, sg, nents, dir); <nl> +	gart_unmap_sg(dev, sg, out, dir); <nl>  	/* When it was forced or merged try again in a dumb way */ <nl>  	if (force_iommu || iommu_merge) { <nl>  		out = dma_map_sg_nonforce(dev, sg, nents, dir);
@@ -356,12 +356,14 @@ static int get_alternative_line_range(struct debuginfo *dinfo, <nl>  				      struct line_range *lr, <nl>  				      const char *target, bool user) <nl>  { <nl> -	struct perf_probe_point pp = { 0 }, result = { 0 }; <nl> +	struct perf_probe_point pp = { .function = lr->function, <nl> +				       .file = lr->file, <nl> +				       .line = lr->start }; <nl> +	struct perf_probe_point result; <nl>  	int ret, len = 0; <nl>   <nl> -	pp.function = lr->function; <nl> -	pp.file = lr->file; <nl> -	pp.line = lr->start; <nl> +	memset(&result, 0, sizeof(result)); <nl> + <nl>  	if (lr->end != INT_MAX) <nl>  		len = lr->end - lr->start; <nl>  	ret = find_alternative_probe_point(dinfo, &pp, &result,
@@ -635,8 +635,10 @@ static void dec_pending(struct dm_io *io, int error) <nl>  			if (!md->barrier_error && io_error != -EOPNOTSUPP) <nl>  				md->barrier_error = io_error; <nl>  			end_io_acct(io); <nl> +			free_io(md, io); <nl>  		} else { <nl>  			end_io_acct(io); <nl> +			free_io(md, io); <nl>   <nl>  			if (io_error != DM_ENDIO_REQUEUE) { <nl>  				trace_block_bio_complete(md->queue, bio); <nl> @@ -644,8 +646,6 @@ static void dec_pending(struct dm_io *io, int error) <nl>  				bio_endio(bio, io_error); <nl>  			} <nl>  		} <nl> - <nl> -		free_io(md, io); <nl>  	} <nl>  } <nl>  
@@ -742,6 +742,7 @@ static struct sk_buff *macsec_encrypt(struct sk_buff *skb, <nl>  	sg_init_table(sg, ret); <nl>  	ret = skb_to_sgvec(skb, sg, 0, skb->len); <nl>  	if (unlikely(ret < 0)) { <nl> +		aead_request_free(req); <nl>  		macsec_txsa_put(tx_sa); <nl>  		kfree_skb(skb); <nl>  		return ERR_PTR(ret); <nl> @@ -954,6 +955,7 @@ static struct sk_buff *macsec_decrypt(struct sk_buff *skb, <nl>  	sg_init_table(sg, ret); <nl>  	ret = skb_to_sgvec(skb, sg, 0, skb->len); <nl>  	if (unlikely(ret < 0)) { <nl> +		aead_request_free(req); <nl>  		kfree_skb(skb); <nl>  		return ERR_PTR(ret); <nl>  	}
@@ -1035,6 +1035,12 @@ static void igb_reset_q_vector(struct igb_adapter *adapter, int v_idx) <nl>  { <nl>  	struct igb_q_vector *q_vector = adapter->q_vector[v_idx]; <nl>   <nl> +	/* Coming from igb_set_interrupt_capability, the vectors are not yet <nl> +	 * allocated. So, q_vector is NULL so we should stop here. <nl> +	 */ <nl> +	if (!q_vector) <nl> +		return; <nl> + <nl>  	if (q_vector->tx.ring) <nl>  		adapter->tx_ring[q_vector->tx.ring->queue_index] = NULL; <nl>  
@@ -1306,7 +1306,11 @@ i915_gem_execbuffer2(struct drm_device *dev, void *data, <nl>  		return -EINVAL; <nl>  	} <nl>   <nl> -	exec2_list = drm_malloc_ab(sizeof(*exec2_list), args->buffer_count); <nl> +	exec2_list = kmalloc(sizeof(*exec2_list)*args->buffer_count, <nl> +			     GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY); <nl> +	if (exec2_list == NULL) <nl> +		exec2_list = drm_malloc_ab(sizeof(*exec2_list), <nl> +					   args->buffer_count); <nl>  	if (exec2_list == NULL) { <nl>  		DRM_ERROR("Failed to allocate exec list for %d buffers\n", <nl>  			  args->buffer_count);
@@ -5012,7 +5012,8 @@ static int igb_find_enabled_vfs(struct igb_adapter *adapter) <nl>  	vf_devfn = pdev->devfn + 0x80; <nl>  	pvfdev = pci_get_device(hw->vendor_id, device_id, NULL); <nl>  	while (pvfdev) { <nl> -		if (pvfdev->devfn == vf_devfn) <nl> +		if (pvfdev->devfn == vf_devfn && <nl> +		    (pvfdev->bus->number >= pdev->bus->number)) <nl>  			vfs_found++; <nl>  		vf_devfn += vf_stride; <nl>  		pvfdev = pci_get_device(hw->vendor_id,
@@ -819,8 +819,9 @@ static int vidioc_querycap(struct file *file, void  *priv, <nl>  	strcpy(cap->driver, "vivi"); <nl>  	strcpy(cap->card, "vivi"); <nl>  	strlcpy(cap->bus_info, dev->v4l2_dev.name, sizeof(cap->bus_info)); <nl> -	cap->capabilities = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING | \ <nl> -			    V4L2_CAP_READWRITE; <nl> +	cap->capabilities = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING | <nl> +			    V4L2_CAP_READWRITE | V4L2_CAP_DEVICE_CAPS; <nl> +	cap->device_caps = cap->capabilities; <nl>  	return 0; <nl>  } <nl>  
@@ -217,7 +217,8 @@ static int ti_cpufreq_init(void) <nl>  	opp_data->cpu_dev = get_cpu_device(0); <nl>  	if (!opp_data->cpu_dev) { <nl>  		pr_err("%s: Failed to get device for CPU0\n", __func__); <nl> -		return -ENODEV; <nl> +		ret = ENODEV; <nl> +		goto free_opp_data; <nl>  	} <nl>   <nl>  	opp_data->opp_node = dev_pm_opp_of_get_opp_desc_node(opp_data->cpu_dev); <nl> @@ -262,6 +263,8 @@ static int ti_cpufreq_init(void) <nl>   <nl>  fail_put_node: <nl>  	of_node_put(opp_data->opp_node); <nl> +free_opp_data: <nl> +	kfree(opp_data); <nl>   <nl>  	return ret; <nl>  }
@@ -1167,9 +1167,11 @@ static int aead_setkey(struct crypto_aead *tfm, const u8 *key, <nl>  	ctx->authkey_len = keys.authkeylen; <nl>  	ctx->enckey_len = keys.enckeylen; <nl>   <nl> +	memzero_explicit(&keys, sizeof(keys)); <nl>  	return aead_setup(tfm, crypto_aead_authsize(tfm)); <nl>  badkey: <nl>  	crypto_aead_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN); <nl> +	memzero_explicit(&keys, sizeof(keys)); <nl>  	return -EINVAL; <nl>  } <nl>  
@@ -679,7 +679,8 @@ void __init exynos5_init_irq(void) <nl>  	 * Theses parameters should be NULL and 0 because EXYNOS4 <nl>  	 * uses GIC instead of VIC. <nl>  	 */ <nl> -	s5p_init_irq(NULL, 0); <nl> +	if (!of_machine_is_compatible("samsung,exynos5440")) <nl> +		s5p_init_irq(NULL, 0); <nl>   <nl>  	gic_arch_extn.irq_set_wake = s3c_irq_wake; <nl>  }
@@ -1819,11 +1819,12 @@ static int s5p_mfc_queue_setup(struct vb2_queue *vq, <nl>  	struct s5p_mfc_ctx *ctx = fh_to_ctx(vq->drv_priv); <nl>  	struct s5p_mfc_dev *dev = ctx->dev; <nl>   <nl> -	if (ctx->state != MFCINST_GOT_INST) { <nl> -		mfc_err("inavlid state: %d\n", ctx->state); <nl> -		return -EINVAL; <nl> -	} <nl>  	if (vq->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) { <nl> +		if (ctx->state != MFCINST_GOT_INST) { <nl> +			mfc_err("inavlid state: %d\n", ctx->state); <nl> +			return -EINVAL; <nl> +		} <nl> + <nl>  		if (ctx->dst_fmt) <nl>  			*plane_count = ctx->dst_fmt->num_planes; <nl>  		else
@@ -597,8 +597,14 @@ static bool access_pmu_evcntr(struct kvm_vcpu *vcpu, <nl>   <nl>  			idx = ARMV8_PMU_CYCLE_IDX; <nl>  		} else { <nl> -			BUG(); <nl> +			return false; <nl>  		} <nl> +	} else if (r->CRn == 0 && r->CRm == 9) { <nl> +		/* PMCCNTR */ <nl> +		if (pmu_access_event_counter_el0_disabled(vcpu)) <nl> +			return false; <nl> + <nl> +		idx = ARMV8_PMU_CYCLE_IDX; <nl>  	} else if (r->CRn == 14 && (r->CRm & 12) == 8) { <nl>  		/* PMEVCNTRn_EL0 */ <nl>  		if (pmu_access_event_counter_el0_disabled(vcpu)) <nl> @@ -606,7 +612,7 @@ static bool access_pmu_evcntr(struct kvm_vcpu *vcpu, <nl>   <nl>  		idx = ((r->CRm & 3) << 3) | (r->Op2 & 7); <nl>  	} else { <nl> -		BUG(); <nl> +		return false; <nl>  	} <nl>   <nl>  	if (!pmu_counter_idx_valid(vcpu, idx))
@@ -27,8 +27,8 @@ static int sis_fetch_size(void) <nl>  	values = A_SIZE_8(agp_bridge->driver->aperture_sizes); <nl>  	for (i = 0; i < agp_bridge->driver->num_aperture_sizes; i++) { <nl>  		if ((temp_size == values[i].size_value) || <nl> -		    ((temp_size & ~(0x03)) == <nl> -		     (values[i].size_value & ~(0x03)))) { <nl> +		    ((temp_size & ~(0x07)) == <nl> +		     (values[i].size_value & ~(0x07)))) { <nl>  			agp_bridge->previous_size = <nl>  			    agp_bridge->current_size = (void *) (values + i); <nl>  
@@ -223,7 +223,7 @@ static int ip_recent_ctrl(struct file *file, const char __user *input, unsigned <nl>  			curr_table->table[count].last_seen = 0; <nl>  			curr_table->table[count].addr = 0; <nl>  			curr_table->table[count].ttl = 0; <nl> -			memset(curr_table->table[count].last_pkts,0,ip_pkt_list_tot*sizeof(u_int32_t)); <nl> +			memset(curr_table->table[count].last_pkts,0,ip_pkt_list_tot*sizeof(unsigned long)); <nl>  			curr_table->table[count].oldest_pkt = 0; <nl>  			curr_table->table[count].time_pos = 0; <nl>  			curr_table->time_info[count].position = count; <nl> @@ -502,7 +502,7 @@ match(const struct sk_buff *skb, <nl>  		location = time_info[curr_table->time_pos].position; <nl>  		hash_table[r_list[location].hash_entry] = -1; <nl>  		hash_table[hash_result] = location; <nl> -		memset(r_list[location].last_pkts,0,ip_pkt_list_tot*sizeof(u_int32_t)); <nl> +		memset(r_list[location].last_pkts,0,ip_pkt_list_tot*sizeof(unsigned long)); <nl>  		r_list[location].time_pos = curr_table->time_pos; <nl>  		r_list[location].addr = addr; <nl>  		r_list[location].ttl = ttl; <nl> @@ -631,7 +631,7 @@ match(const struct sk_buff *skb, <nl>  			r_list[location].last_seen = 0; <nl>  			r_list[location].addr = 0; <nl>  			r_list[location].ttl = 0; <nl> -			memset(r_list[location].last_pkts,0,ip_pkt_list_tot*sizeof(u_int32_t)); <nl> +			memset(r_list[location].last_pkts,0,ip_pkt_list_tot*sizeof(unsigned long)); <nl>  			r_list[location].oldest_pkt = 0; <nl>  			ans = !info->invert; <nl>  		} <nl> @@ -734,10 +734,10 @@ checkentry(const char *tablename, <nl>  	memset(curr_table->table,0,sizeof(struct recent_ip_list)*ip_list_tot); <nl>  #ifdef DEBUG <nl>  	if(debug) printk(KERN_INFO RECENT_NAME ": checkentry: Allocating %d for pkt_list.\n", <nl> -			sizeof(u_int32_t)*ip_pkt_list_tot*ip_list_tot); <nl> +			sizeof(unsigned long)*ip_pkt_list_tot*ip_list_tot); <nl>  #endif <nl>   <nl> -	hold = vmalloc(sizeof(u_int32_t)*ip_pkt_list_tot*ip_list_tot); <nl> +	hold = vmalloc(sizeof(unsigned long)*ip_pkt_list_tot*ip_list_tot); <nl>  #ifdef DEBUG <nl>  	if(debug) printk(KERN_INFO RECENT_NAME ": checkentry: After pkt_list allocation.\n"); <nl>  #endif
@@ -510,6 +510,8 @@ static int disable_periodic (struct ehci_hcd *ehci) <nl>  	ehci_writel(ehci, cmd, &ehci->regs->command); <nl>  	/* posted write ... */ <nl>   <nl> +	free_cached_itd_list(ehci); <nl> + <nl>  	ehci->next_uframe = -1; <nl>  	return 0; <nl>  }
@@ -312,6 +312,8 @@ static int sd_start(struct gspca_dev *gspca_dev) <nl>   <nl>  	/* create the JPEG header */ <nl>  	dev->jpeg_hdr = kmalloc(JPEG_HDR_SZ, GFP_KERNEL); <nl> +	if (dev->jpeg_hdr == NULL) <nl> +		return -ENOMEM; <nl>  	jpeg_define(dev->jpeg_hdr, gspca_dev->height, gspca_dev->width, <nl>  			0x21);          /* JPEG 422 */ <nl>  	jpeg_set_qual(dev->jpeg_hdr, dev->quality);
@@ -527,7 +527,7 @@ int acpi_bus_generate_proc_event4(const char *device_class, const char *bus_id, <nl>  	if (!event_is_open) <nl>  		return 0; <nl>   <nl> -	event = kmalloc(sizeof(struct acpi_bus_event), GFP_ATOMIC); <nl> +	event = kzalloc(sizeof(struct acpi_bus_event), GFP_ATOMIC); <nl>  	if (!event) <nl>  		return -ENOMEM; <nl>  
@@ -196,7 +196,7 @@ static int wm_adsp_fw_put(struct snd_kcontrol *kcontrol, <nl>  	if (adsp[e->shift_l].running) <nl>  		return -EBUSY; <nl>   <nl> -	adsp->fw = ucontrol->value.integer.value[0]; <nl> +	adsp[e->shift_l].fw = ucontrol->value.integer.value[0]; <nl>   <nl>  	return 0; <nl>  }
@@ -2007,7 +2007,7 @@ static int em28xx_v4l2_suspend(struct em28xx *dev) <nl>  	if (!dev->has_video) <nl>  		return 0; <nl>   <nl> -	em28xx_info("Suspending video extension"); <nl> +	em28xx_info("Suspending video extension\n"); <nl>  	em28xx_stop_urbs(dev); <nl>  	return 0; <nl>  } <nl> @@ -2020,7 +2020,7 @@ static int em28xx_v4l2_resume(struct em28xx *dev) <nl>  	if (!dev->has_video) <nl>  		return 0; <nl>   <nl> -	em28xx_info("Resuming video extension"); <nl> +	em28xx_info("Resuming video extension\n"); <nl>  	/* what do we do here */ <nl>  	return 0; <nl>  }
@@ -1955,12 +1955,17 @@ int fixup_user_fault(struct task_struct *tsk, struct mm_struct *mm, <nl>  		     unsigned long address, unsigned int fault_flags) <nl>  { <nl>  	struct vm_area_struct *vma; <nl> +	vm_flags_t vm_flags; <nl>  	int ret; <nl>   <nl>  	vma = find_extend_vma(mm, address); <nl>  	if (!vma || address < vma->vm_start) <nl>  		return -EFAULT; <nl>   <nl> +	vm_flags = (fault_flags & FAULT_FLAG_WRITE) ? VM_WRITE : VM_READ; <nl> +	if (!(vm_flags & vma->vm_flags)) <nl> +		return -EFAULT; <nl> + <nl>  	ret = handle_mm_fault(mm, vma, address, fault_flags); <nl>  	if (ret & VM_FAULT_ERROR) { <nl>  		if (ret & VM_FAULT_OOM)
@@ -1444,6 +1444,10 @@ static irqreturn_t cyy_interrupt(int irq, void *dev_id) <nl>  	card_base_addr = cinfo->base_addr; <nl>  	index = cinfo->bus_index; <nl>   <nl> +	/* card was not initialized yet (e.g. DEBUG_SHIRQ) */ <nl> +	if (unlikely(card_base_addr == NULL)) <nl> +		return IRQ_HANDLED; <nl> + <nl>  	/* This loop checks all chips in the card.  Make a note whenever <nl>  	   _any_ chip had some work to do, as this is considered an <nl>  	   indication that there will be more to do.  Only when no chip
@@ -2767,11 +2767,15 @@ static struct vfsmount *nfs_do_root_mount(struct file_system_type *fs_type, <nl>  	char *root_devname; <nl>  	size_t len; <nl>   <nl> -	len = strlen(hostname) + 3; <nl> +	len = strlen(hostname) + 5; <nl>  	root_devname = kmalloc(len, GFP_KERNEL); <nl>  	if (root_devname == NULL) <nl>  		return ERR_PTR(-ENOMEM); <nl> -	snprintf(root_devname, len, "%s:/", hostname); <nl> +	/* Does hostname needs to be enclosed in brackets? */ <nl> +	if (strchr(hostname, ':')) <nl> +		snprintf(root_devname, len, "[%s]:/", hostname); <nl> +	else <nl> +		snprintf(root_devname, len, "%s:/", hostname); <nl>  	root_mnt = vfs_kern_mount(fs_type, flags, root_devname, data); <nl>  	kfree(root_devname); <nl>  	return root_mnt;
@@ -2165,6 +2165,9 @@ static int addrconf_notify(struct notifier_block *this, unsigned long event, <nl>  					dev->name); <nl>  				break; <nl>  			} <nl> + <nl> +			if (idev) <nl> +				idev->if_flags |= IF_READY; <nl>  		} else { <nl>  			if (!netif_carrier_ok(dev)) { <nl>  				/* device is still not ready. */
@@ -668,7 +668,7 @@ qla2x00_sysfs_write_edc(struct file *filp, struct kobject *kobj, <nl>  	    dev, adr, len, opt); <nl>  	if (rval != QLA_SUCCESS) { <nl>  		ql_log(ql_log_warn, vha, 0x7074, <nl> -		    "Unable to write EDC (%x) %02x:%04x:%02x:%02x:%02hhx\n", <nl> +		    "Unable to write EDC (%x) %02x:%02x:%04x:%02x:%02hhx\n", <nl>  		    rval, dev, adr, opt, len, buf[8]); <nl>  		return -EIO; <nl>  	} <nl> @@ -725,7 +725,7 @@ qla2x00_sysfs_write_edc_status(struct file *filp, struct kobject *kobj, <nl>  			dev, adr, len, opt); <nl>  	if (rval != QLA_SUCCESS) { <nl>  		ql_log(ql_log_info, vha, 0x7075, <nl> -		    "Unable to write EDC status (%x) %02x:%04x:%02x:%02x.\n", <nl> +		    "Unable to write EDC status (%x) %02x:%02x:%04x:%02x.\n", <nl>  		    rval, dev, adr, opt, len); <nl>  		return -EIO; <nl>  	}
@@ -650,13 +650,13 @@ static int mlx5_ib_mmap(struct ib_ucontext *ibcontext, struct vm_area_struct *vm <nl>  			return -EINVAL; <nl>   <nl>  		idx = get_index(vma->vm_pgoff); <nl> +		if (idx >= uuari->num_uars) <nl> +			return -EINVAL; <nl> + <nl>  		pfn = uar_index2pfn(dev, uuari->uars[idx].index); <nl>  		mlx5_ib_dbg(dev, "uar idx 0x%lx, pfn 0x%llx\n", idx, <nl>  			    (unsigned long long)pfn); <nl>   <nl> -		if (idx >= uuari->num_uars) <nl> -			return -EINVAL; <nl> - <nl>  		vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot); <nl>  		if (io_remap_pfn_range(vma, vma->vm_start, pfn, <nl>  				       PAGE_SIZE, vma->vm_page_prot))
@@ -411,7 +411,7 @@ static struct platform_driver wm8505fb_driver = { <nl>  	.driver		= { <nl>  		.owner	= THIS_MODULE, <nl>  		.name	= DRIVER_NAME, <nl> -		.of_match_table = of_match_ptr(wmt_dt_ids), <nl> +		.of_match_table = wmt_dt_ids, <nl>  	}, <nl>  }; <nl>  
@@ -428,7 +428,7 @@ static bool dccp_new(struct nf_conn *ct, const struct sk_buff *skb, <nl>  	const char *msg; <nl>  	u_int8_t state; <nl>   <nl> -	dh = skb_header_pointer(skb, dataoff, sizeof(_dh), &dh); <nl> +	dh = skb_header_pointer(skb, dataoff, sizeof(_dh), &_dh); <nl>  	BUG_ON(dh == NULL); <nl>   <nl>  	state = dccp_state_table[CT_DCCP_ROLE_CLIENT][dh->dccph_type][CT_DCCP_NONE]; <nl> @@ -486,7 +486,7 @@ static int dccp_packet(struct nf_conn *ct, const struct sk_buff *skb, <nl>  	u_int8_t type, old_state, new_state; <nl>  	enum ct_dccp_roles role; <nl>   <nl> -	dh = skb_header_pointer(skb, dataoff, sizeof(_dh), &dh); <nl> +	dh = skb_header_pointer(skb, dataoff, sizeof(_dh), &_dh); <nl>  	BUG_ON(dh == NULL); <nl>  	type = dh->dccph_type; <nl>   <nl> @@ -577,7 +577,7 @@ static int dccp_error(struct net *net, struct nf_conn *tmpl, <nl>  	unsigned int cscov; <nl>  	const char *msg; <nl>   <nl> -	dh = skb_header_pointer(skb, dataoff, sizeof(_dh), &dh); <nl> +	dh = skb_header_pointer(skb, dataoff, sizeof(_dh), &_dh); <nl>  	if (dh == NULL) { <nl>  		msg = "nf_ct_dccp: short packet "; <nl>  		goto out_invalid;
@@ -965,6 +965,10 @@ static inline bool is_pci_p2pdma_page(const struct page *page) <nl>  } <nl>  #endif /* CONFIG_DEV_PAGEMAP_OPS */ <nl>   <nl> +/* 127: arbitrary random number, small enough to assemble well */ <nl> +#define page_ref_zero_or_close_to_overflow(page) \ <nl> +	((unsigned int) page_ref_count(page) + 127u <= 127u) <nl> + <nl>  static inline void get_page(struct page *page) <nl>  { <nl>  	page = compound_head(page); <nl> @@ -972,7 +976,7 @@ static inline void get_page(struct page *page) <nl>  	 * Getting a normal page or the head of a compound page <nl>  	 * requires to already have an elevated page->_refcount. <nl>  	 */ <nl> -	VM_BUG_ON_PAGE(page_ref_count(page) <= 0, page); <nl> +	VM_BUG_ON_PAGE(page_ref_zero_or_close_to_overflow(page), page); <nl>  	page_ref_inc(page); <nl>  } <nl>  
@@ -1356,6 +1356,8 @@ static int do_umount(struct mount *mnt, int flags) <nl>  		 * Special case for "unmounting" root ... <nl>  		 * we just try to remount it readonly. <nl>  		 */ <nl> +		if (!capable(CAP_SYS_ADMIN)) <nl> +			return -EPERM; <nl>  		down_write(&sb->s_umount); <nl>  		if (!(sb->s_flags & MS_RDONLY)) <nl>  			retval = do_remount_sb(sb, MS_RDONLY, NULL, 0);
@@ -371,8 +371,10 @@ static int spi_gpio_probe(struct platform_device *pdev) <nl>  		return -ENOMEM; <nl>   <nl>  	status = devm_add_action_or_reset(&pdev->dev, spi_gpio_put, master); <nl> -	if (status) <nl> +	if (status) { <nl> +		spi_master_put(master); <nl>  		return status; <nl> +	} <nl>   <nl>  	if (of_id) <nl>  		status = spi_gpio_probe_dt(pdev, master);
@@ -4467,8 +4467,10 @@ int i915_gem_init(struct drm_device *dev) <nl>  	i915_gem_init_global_gtt(dev); <nl>   <nl>  	ret = i915_gem_context_init(dev); <nl> -	if (ret) <nl> +	if (ret) { <nl> +		mutex_unlock(&dev->struct_mutex); <nl>  		return ret; <nl> +	} <nl>   <nl>  	ret = i915_gem_init_hw(dev); <nl>  	mutex_unlock(&dev->struct_mutex);
@@ -637,14 +637,17 @@ static int rndis_set_response(struct rndis_params *params, <nl>  	rndis_set_cmplt_type *resp; <nl>  	rndis_resp_t *r; <nl>   <nl> +	BufLength = le32_to_cpu(buf->InformationBufferLength); <nl> +	BufOffset = le32_to_cpu(buf->InformationBufferOffset); <nl> +	if ((BufLength > RNDIS_MAX_TOTAL_SIZE) || <nl> +	    (BufOffset + 8 >= RNDIS_MAX_TOTAL_SIZE)) <nl> +		    return -EINVAL; <nl> + <nl>  	r = rndis_add_response(params, sizeof(rndis_set_cmplt_type)); <nl>  	if (!r) <nl>  		return -ENOMEM; <nl>  	resp = (rndis_set_cmplt_type *)r->buf; <nl>   <nl> -	BufLength = le32_to_cpu(buf->InformationBufferLength); <nl> -	BufOffset = le32_to_cpu(buf->InformationBufferOffset); <nl> - <nl>  #ifdef	VERBOSE_DEBUG <nl>  	pr_debug("%s: Length: %d\n", __func__, BufLength); <nl>  	pr_debug("%s: Offset: %d\n", __func__, BufOffset);
@@ -235,6 +235,7 @@ int arm_pmu_acpi_probe(armpmu_init_fn init_fn) <nl>  		ret = armpmu_register(pmu); <nl>  		if (ret) { <nl>  			pr_warn("Failed to register PMU for CPU%d\n", cpu); <nl> +			kfree(pmu->name); <nl>  			return ret; <nl>  		} <nl>  	}
@@ -338,7 +338,6 @@ static int gfs2_lock_fs_check_clean(struct gfs2_sbd *sdp, <nl>  				    struct gfs2_holder *t_gh) <nl>  { <nl>  	struct gfs2_inode *ip; <nl> -	struct gfs2_holder ji_gh; <nl>  	struct gfs2_jdesc *jd; <nl>  	struct lfcc *lfcc; <nl>  	LIST_HEAD(list); <nl> @@ -386,7 +385,6 @@ static int gfs2_lock_fs_check_clean(struct gfs2_sbd *sdp, <nl>  		gfs2_glock_dq_uninit(&lfcc->gh); <nl>  		kfree(lfcc); <nl>  	} <nl> -	gfs2_glock_dq_uninit(&ji_gh); <nl>  	return error; <nl>  } <nl>  
@@ -156,17 +156,18 @@ int ping_hash(struct sock *sk) <nl>  void ping_unhash(struct sock *sk) <nl>  { <nl>  	struct inet_sock *isk = inet_sk(sk); <nl> + <nl>  	pr_debug("ping_unhash(isk=%p,isk->num=%u)\n", isk, isk->inet_num); <nl> +	write_lock_bh(&ping_table.lock); <nl>  	if (sk_hashed(sk)) { <nl> -		write_lock_bh(&ping_table.lock); <nl>  		hlist_nulls_del(&sk->sk_nulls_node); <nl>  		sk_nulls_node_init(&sk->sk_nulls_node); <nl>  		sock_put(sk); <nl>  		isk->inet_num = 0; <nl>  		isk->inet_sport = 0; <nl>  		sock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1); <nl> -		write_unlock_bh(&ping_table.lock); <nl>  	} <nl> +	write_unlock_bh(&ping_table.lock); <nl>  } <nl>  EXPORT_SYMBOL_GPL(ping_unhash); <nl>  
@@ -627,6 +627,11 @@ static void ar5008_hw_init_bb(struct ath_hw *ah, <nl>  	else <nl>  		synthDelay /= 10; <nl>   <nl> +	if (IS_CHAN_HALF_RATE(chan)) <nl> +		synthDelay *= 2; <nl> +	else if (IS_CHAN_QUARTER_RATE(chan)) <nl> +		synthDelay *= 4; <nl> + <nl>  	REG_WRITE(ah, AR_PHY_ACTIVE, AR_PHY_ACTIVE_EN); <nl>   <nl>  	udelay(synthDelay + BASE_ACTIVATE_DELAY);
@@ -3092,6 +3092,7 @@ int ath10k_wmi_beacon_send_nowait(struct ath10k *ar, <nl>  { <nl>  	struct wmi_bcn_tx_cmd *cmd; <nl>  	struct sk_buff *skb; <nl> +	int ret; <nl>   <nl>  	skb = ath10k_wmi_alloc_skb(sizeof(*cmd) + arg->bcn_len); <nl>  	if (!skb) <nl> @@ -3104,7 +3105,11 @@ int ath10k_wmi_beacon_send_nowait(struct ath10k *ar, <nl>  	cmd->hdr.bcn_len  = __cpu_to_le32(arg->bcn_len); <nl>  	memcpy(cmd->bcn, arg->bcn, arg->bcn_len); <nl>   <nl> -	return ath10k_wmi_cmd_send_nowait(ar, skb, ar->wmi.cmd->bcn_tx_cmdid); <nl> +	ret = ath10k_wmi_cmd_send_nowait(ar, skb, ar->wmi.cmd->bcn_tx_cmdid); <nl> +	if (ret) <nl> +		dev_kfree_skb(skb); <nl> + <nl> +	return ret; <nl>  } <nl>   <nl>  static void ath10k_wmi_pdev_set_wmm_param(struct wmi_wmm_params *params,
@@ -516,13 +516,13 @@ static noinline int hiddev_ioctl_usage(struct hiddev *hiddev, unsigned int cmd, <nl>  					goto inval; <nl>  			} else if (uref->usage_index >= field->report_count) <nl>  				goto inval; <nl> - <nl> -			else if ((cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES) && <nl> -				 (uref_multi->num_values > HID_MAX_MULTI_USAGES || <nl> -				  uref->usage_index + uref_multi->num_values > field->report_count)) <nl> -				goto inval; <nl>  		} <nl>   <nl> +		if ((cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES) && <nl> +		    (uref_multi->num_values > HID_MAX_MULTI_USAGES || <nl> +		     uref->usage_index + uref_multi->num_values > field->report_count)) <nl> +			goto inval; <nl> + <nl>  		switch (cmd) { <nl>  		case HIDIOCGUSAGE: <nl>  			uref->value = field->value[uref->usage_index];
@@ -832,6 +832,7 @@ static int video_open(struct file *file) <nl>   <nl>         if (NULL == dev) { <nl>  		mutex_unlock(&cx25821_devlist_mutex); <nl> +		kfree(fh); <nl>  		return -ENODEV; <nl>         } <nl>  
@@ -1211,6 +1211,8 @@ static int alsa_device_init(struct saa7134_dev *dev) <nl>   <nl>  static int alsa_device_exit(struct saa7134_dev *dev) <nl>  { <nl> +	if (!snd_saa7134_cards[dev->nr]) <nl> +		return 1; <nl>   <nl>  	snd_card_free(snd_saa7134_cards[dev->nr]); <nl>  	snd_saa7134_cards[dev->nr] = NULL; <nl> @@ -1260,7 +1262,8 @@ static void saa7134_alsa_exit(void) <nl>  	int idx; <nl>   <nl>  	for (idx = 0; idx < SNDRV_CARDS; idx++) { <nl> -		snd_card_free(snd_saa7134_cards[idx]); <nl> +		if (snd_saa7134_cards[idx]) <nl> +			snd_card_free(snd_saa7134_cards[idx]); <nl>  	} <nl>   <nl>  	saa7134_dmasound_init = NULL;
@@ -456,7 +456,7 @@ static int sr_init_command(struct scsi_cmnd * SCpnt) <nl>  static int sr_block_open(struct inode *inode, struct file *file) <nl>  { <nl>  	struct gendisk *disk = inode->i_bdev->bd_disk; <nl> -	struct scsi_cd *cd = scsi_cd(inode->i_bdev->bd_disk); <nl> +	struct scsi_cd *cd; <nl>  	int ret = 0; <nl>   <nl>  	if(!(cd = scsi_cd_get(disk)))
@@ -930,6 +930,7 @@ struct ib_cq *c4iw_create_cq(struct ib_device *ibdev, int entries, <nl>  		if (!mm2) <nl>  			goto err4; <nl>   <nl> +		memset(&uresp, 0, sizeof(uresp)); <nl>  		uresp.qid_mask = rhp->rdev.cqmask; <nl>  		uresp.cqid = chp->cq.cqid; <nl>  		uresp.size = chp->cq.size;
@@ -500,7 +500,7 @@ SOC_SINGLE_TLV("LINEOUT2 Volume", WM8993_LINE_OUTPUTS_VOLUME, 0, 1, 1, <nl>  static int hp_supply_event(struct snd_soc_dapm_widget *w, <nl>  			   struct snd_kcontrol *kcontrol, int event) <nl>  { <nl> -	struct snd_soc_codec *codec = w->codec; <nl> +	struct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm); <nl>  	struct wm_hubs_data *hubs = snd_soc_codec_get_drvdata(codec); <nl>   <nl>  	switch (event) { <nl> @@ -542,7 +542,7 @@ static int hp_supply_event(struct snd_soc_dapm_widget *w, <nl>  static int hp_event(struct snd_soc_dapm_widget *w, <nl>  		    struct snd_kcontrol *kcontrol, int event) <nl>  { <nl> -	struct snd_soc_codec *codec = w->codec; <nl> +	struct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm); <nl>  	unsigned int reg = snd_soc_read(codec, WM8993_ANALOGUE_HP_0); <nl>   <nl>  	switch (event) { <nl> @@ -594,7 +594,7 @@ static int hp_event(struct snd_soc_dapm_widget *w, <nl>  static int earpiece_event(struct snd_soc_dapm_widget *w, <nl>  			  struct snd_kcontrol *control, int event) <nl>  { <nl> -	struct snd_soc_codec *codec = w->codec; <nl> +	struct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm); <nl>  	u16 reg = snd_soc_read(codec, WM8993_ANTIPOP1) & ~WM8993_HPOUT2_IN_ENA; <nl>   <nl>  	switch (event) { <nl> @@ -619,7 +619,7 @@ static int earpiece_event(struct snd_soc_dapm_widget *w, <nl>  static int lineout_event(struct snd_soc_dapm_widget *w, <nl>  			 struct snd_kcontrol *control, int event) <nl>  { <nl> -	struct snd_soc_codec *codec = w->codec; <nl> +	struct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm); <nl>  	struct wm_hubs_data *hubs = snd_soc_codec_get_drvdata(codec); <nl>  	bool *flag; <nl>   <nl> @@ -649,7 +649,7 @@ static int lineout_event(struct snd_soc_dapm_widget *w, <nl>  static int micbias_event(struct snd_soc_dapm_widget *w, <nl>  			 struct snd_kcontrol *kcontrol, int event) <nl>  { <nl> -	struct snd_soc_codec *codec = w->codec; <nl> +	struct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm); <nl>  	struct wm_hubs_data *hubs = snd_soc_codec_get_drvdata(codec); <nl>   <nl>  	switch (w->shift) {
@@ -659,6 +659,7 @@ static struct elevator_type mq_deadline = { <nl>  	.elevator_name = "mq-deadline", <nl>  	.elevator_owner = THIS_MODULE, <nl>  }; <nl> +MODULE_ALIAS("mq-deadline-iosched"); <nl>   <nl>  static int __init deadline_init(void) <nl>  {
@@ -429,7 +429,8 @@ void brcmf_fweh_process_event(struct brcmf_pub *drvr, <nl>  	if (code != BRCMF_E_IF && !fweh->evt_handler[code]) <nl>  		return; <nl>   <nl> -	if (datalen > BRCMF_DCMD_MAXLEN) <nl> +	if (datalen > BRCMF_DCMD_MAXLEN || <nl> +	    datalen + sizeof(*event_packet) > packet_len) <nl>  		return; <nl>   <nl>  	if (in_interrupt())
@@ -391,6 +391,7 @@ static int psbfb_create(struct psb_fbdev *fbdev, <nl>  	mode_cmd.width = sizes->surface_width; <nl>  	mode_cmd.height = sizes->surface_height; <nl>  	bpp = sizes->surface_bpp; <nl> +	depth = sizes->surface_depth; <nl>   <nl>  	/* No 24bit packed */ <nl>  	if (bpp == 24) <nl> @@ -403,7 +404,6 @@ static int psbfb_create(struct psb_fbdev *fbdev, <nl>  		 * is ok with some fonts <nl>  		 */ <nl>          	mode_cmd.pitches[0] =  ALIGN(mode_cmd.width * ((bpp + 7) / 8), 4096 >> pitch_lines); <nl> -        	depth = sizes->surface_depth; <nl>   <nl>          	size = mode_cmd.pitches[0] * mode_cmd.height; <nl>          	size = ALIGN(size, PAGE_SIZE);
@@ -267,7 +267,10 @@ static void ath_tx_complete_aggr(struct ath_softc *sc, struct ath_txq *txq, <nl>  	struct ath_node *an = NULL; <nl>  	struct sk_buff *skb; <nl>  	struct ieee80211_sta *sta; <nl> +	struct ieee80211_hw *hw; <nl>  	struct ieee80211_hdr *hdr; <nl> +	struct ieee80211_tx_info *tx_info; <nl> +	struct ath_tx_info_priv *tx_info_priv; <nl>  	struct ath_atx_tid *tid = NULL; <nl>  	struct ath_buf *bf_next, *bf_last = bf->bf_lastbf; <nl>  	struct ath_desc *ds = bf_last->bf_desc; <nl> @@ -280,10 +283,14 @@ static void ath_tx_complete_aggr(struct ath_softc *sc, struct ath_txq *txq, <nl>  	skb = bf->bf_mpdu; <nl>  	hdr = (struct ieee80211_hdr *)skb->data; <nl>   <nl> +	tx_info = IEEE80211_SKB_CB(skb); <nl> +	tx_info_priv = (struct ath_tx_info_priv *) tx_info->rate_driver_data[0]; <nl> +	hw = tx_info_priv->aphy->hw; <nl> + <nl>  	rcu_read_lock(); <nl>   <nl>  	/* XXX: use ieee80211_find_sta! */ <nl> -	sta = ieee80211_find_sta_by_hw(sc->hw, hdr->addr1); <nl> +	sta = ieee80211_find_sta_by_hw(hw, hdr->addr1); <nl>  	if (!sta) { <nl>  		rcu_read_unlock(); <nl>  		return;
@@ -334,6 +334,9 @@ static __init int q40_add_kbd_device(void) <nl>  { <nl>  	struct platform_device *pdev; <nl>   <nl> +	if (!MACH_IS_Q40) <nl> +		return -ENODEV; <nl> + <nl>  	pdev = platform_device_register_simple("q40kbd", -1, NULL, 0); <nl>  	if (IS_ERR(pdev)) <nl>  		return PTR_ERR(pdev);
@@ -131,6 +131,9 @@ struct mmc_host_ops { <nl>   <nl>  	int	(*start_signal_voltage_switch)(struct mmc_host *host, struct mmc_ios *ios); <nl>   <nl> +	/* Check if the card is pulling dat[0:3] low */ <nl> +	int	(*card_busy)(struct mmc_host *host); <nl> + <nl>  	/* The tuning command opcode value is different for SD and eMMC cards */ <nl>  	int	(*execute_tuning)(struct mmc_host *host, u32 opcode); <nl>  	void	(*enable_preset_value)(struct mmc_host *host, bool enable);
@@ -4158,7 +4158,7 @@ static long cgroup_create(struct cgroup *parent, struct dentry *dentry, <nl>  	struct cgroup *cgrp; <nl>  	struct cgroup_name *name; <nl>  	struct cgroupfs_root *root = parent->root; <nl> -	int ssid, err = 0; <nl> +	int ssid, err; <nl>  	struct cgroup_subsys *ss; <nl>  	struct super_block *sb = root->sb; <nl>   <nl> @@ -4168,8 +4168,10 @@ static long cgroup_create(struct cgroup *parent, struct dentry *dentry, <nl>  		return -ENOMEM; <nl>   <nl>  	name = cgroup_alloc_name(dentry); <nl> -	if (!name) <nl> +	if (!name) { <nl> +		err = -ENOMEM; <nl>  		goto err_free_cgrp; <nl> +	} <nl>  	rcu_assign_pointer(cgrp->name, name); <nl>   <nl>  	/* <nl> @@ -4177,8 +4179,10 @@ static long cgroup_create(struct cgroup *parent, struct dentry *dentry, <nl>  	 * a half-baked cgroup. <nl>  	 */ <nl>  	cgrp->id = idr_alloc(&root->cgroup_idr, NULL, 1, 0, GFP_KERNEL); <nl> -	if (cgrp->id < 0) <nl> +	if (cgrp->id < 0) { <nl> +		err = -ENOMEM; <nl>  		goto err_free_name; <nl> +	} <nl>   <nl>  	/* <nl>  	 * Only live parents can have children.  Note that the liveliness
@@ -2911,6 +2911,8 @@ static ssize_t f2fs_file_write_iter(struct kiocb *iocb, struct iov_iter *from) <nl>   <nl>  	ret = generic_write_checks(iocb, from); <nl>  	if (ret > 0) { <nl> +		bool preallocated = false; <nl> +		size_t target_size = 0; <nl>  		int err; <nl>   <nl>  		if (iov_iter_fault_in_readable(from, iov_iter_count(from))) <nl> @@ -2927,6 +2929,9 @@ static ssize_t f2fs_file_write_iter(struct kiocb *iocb, struct iov_iter *from) <nl>  				} <nl>   <nl>  		} else { <nl> +			preallocated = true; <nl> +			target_size = iocb->ki_pos + iov_iter_count(from); <nl> + <nl>  			err = f2fs_preallocate_blocks(iocb, from); <nl>  			if (err) { <nl>  				clear_inode_flag(inode, FI_NO_PREALLOC); <nl> @@ -2939,6 +2944,10 @@ static ssize_t f2fs_file_write_iter(struct kiocb *iocb, struct iov_iter *from) <nl>  		blk_finish_plug(&plug); <nl>  		clear_inode_flag(inode, FI_NO_PREALLOC); <nl>   <nl> +		/* if we couldn't write data, we should deallocate blocks. */ <nl> +		if (preallocated && i_size_read(inode) < target_size) <nl> +			f2fs_truncate(inode); <nl> + <nl>  		if (ret > 0) <nl>  			f2fs_update_iostat(F2FS_I_SB(inode), APP_WRITE_IO, ret); <nl>  	}
@@ -1325,8 +1325,11 @@ int do_huge_pmd_numa_page(struct mm_struct *mm, struct vm_area_struct *vma, <nl>   <nl>  check_same: <nl>  	spin_lock(&mm->page_table_lock); <nl> -	if (unlikely(!pmd_same(pmd, *pmdp))) <nl> +	if (unlikely(!pmd_same(pmd, *pmdp))) { <nl> +		/* Someone else took our fault */ <nl> +		current_nid = -1; <nl>  		goto out_unlock; <nl> +	} <nl>  clear_pmdnuma: <nl>  	pmd = pmd_mknonnuma(pmd); <nl>  	set_pmd_at(mm, haddr, pmdp, pmd);
@@ -779,8 +779,9 @@ static int he_init_group(struct he_dev *he_dev, int group) <nl>  		  G0_RBPS_BS + (group * 32)); <nl>   <nl>  	/* bitmap table */ <nl> -	he_dev->rbpl_table = kmalloc(BITS_TO_LONGS(RBPL_TABLE_SIZE) <nl> -				     * sizeof(unsigned long), GFP_KERNEL); <nl> +	he_dev->rbpl_table = kmalloc_array(BITS_TO_LONGS(RBPL_TABLE_SIZE), <nl> +					   sizeof(*he_dev->rbpl_table), <nl> +					   GFP_KERNEL); <nl>  	if (!he_dev->rbpl_table) { <nl>  		hprintk("unable to allocate rbpl bitmap table\n"); <nl>  		return -ENOMEM; <nl> @@ -788,8 +789,9 @@ static int he_init_group(struct he_dev *he_dev, int group) <nl>  	bitmap_zero(he_dev->rbpl_table, RBPL_TABLE_SIZE); <nl>   <nl>  	/* rbpl_virt 64-bit pointers */ <nl> -	he_dev->rbpl_virt = kmalloc(RBPL_TABLE_SIZE <nl> -				    * sizeof(struct he_buff *), GFP_KERNEL); <nl> +	he_dev->rbpl_virt = kmalloc_array(RBPL_TABLE_SIZE, <nl> +					  sizeof(*he_dev->rbpl_virt), <nl> +					  GFP_KERNEL); <nl>  	if (!he_dev->rbpl_virt) { <nl>  		hprintk("unable to allocate rbpl virt table\n"); <nl>  		goto out_free_rbpl_table;
@@ -2500,9 +2500,9 @@ static const struct snd_soc_dapm_widget rt5659_dapm_widgets[] = { <nl>  		RT5659_PWR_ADC_L1_BIT, 0, NULL, 0), <nl>  	SND_SOC_DAPM_SUPPLY("ADC1 R Power", RT5659_PWR_DIG_1, <nl>  		RT5659_PWR_ADC_R1_BIT, 0, NULL, 0), <nl> -	SND_SOC_DAPM_SUPPLY("ADC2 L Power", RT5659_PWR_DIG_2, <nl> +	SND_SOC_DAPM_SUPPLY("ADC2 L Power", RT5659_PWR_DIG_1, <nl>  		RT5659_PWR_ADC_L2_BIT, 0, NULL, 0), <nl> -	SND_SOC_DAPM_SUPPLY("ADC2 R Power", RT5659_PWR_DIG_2, <nl> +	SND_SOC_DAPM_SUPPLY("ADC2 R Power", RT5659_PWR_DIG_1, <nl>  		RT5659_PWR_ADC_R2_BIT, 0, NULL, 0), <nl>  	SND_SOC_DAPM_SUPPLY("ADC1 clock", SND_SOC_NOPM, 0, 0, set_adc_clk, <nl>  		SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
@@ -3072,7 +3072,9 @@ int snd_soc_register_dais(struct device *dev, <nl>  		pr_debug("Registered DAI '%s'\n", dai->name); <nl>  	} <nl>   <nl> +	mutex_lock(&client_mutex); <nl>  	snd_soc_instantiate_cards(); <nl> +	mutex_unlock(&client_mutex); <nl>  	return 0; <nl>   <nl>  err:
@@ -1220,7 +1220,12 @@ static void conf_message_callback(const char *fmt, va_list ap) <nl>   <nl>  static void show_help(struct menu *menu) <nl>  { <nl> -	struct gstr help = str_new(); <nl> +	struct gstr help; <nl> + <nl> +	if (!menu) <nl> +		return; <nl> + <nl> +	help = str_new(); <nl>  	menu_get_ext_help(menu, &help); <nl>  	show_scroll_win(main_window, _(menu_get_prompt(menu)), str_get(&help)); <nl>  	str_free(&help);
@@ -201,6 +201,7 @@ extern int vdso_enabled; <nl>   <nl>  #endif /* !CONFIG_X86_32 */ <nl>   <nl> +#define CORE_DUMP_USE_REGSET <nl>  #define USE_ELF_CORE_DUMP <nl>  #define ELF_EXEC_PAGESIZE	4096 <nl>  
@@ -397,11 +397,11 @@ static int con_close_socket(struct ceph_connection *con) <nl>  	dout("con_close_socket on %p sock %p\n", con, con->sock); <nl>  	if (!con->sock) <nl>  		return 0; <nl> -	set_bit(SOCK_CLOSED, &con->state); <nl> +	set_bit(SOCK_CLOSED, &con->flags); <nl>  	rc = con->sock->ops->shutdown(con->sock, SHUT_RDWR); <nl>  	sock_release(con->sock); <nl>  	con->sock = NULL; <nl> -	clear_bit(SOCK_CLOSED, &con->state); <nl> +	clear_bit(SOCK_CLOSED, &con->flags); <nl>  	con_sock_state_closed(con); <nl>  	return rc; <nl>  }
@@ -144,7 +144,7 @@ static int _c4iw_write_mem_inline(struct c4iw_rdev *rdev, u32 addr, u32 len, <nl>  		if (i == (num_wqe-1)) { <nl>  			req->wr.wr_hi = cpu_to_be32(FW_WR_OP_V(FW_ULPTX_WR) | <nl>  						    FW_WR_COMPL_F); <nl> -			req->wr.wr_lo = (__force __be64)&wr_wait; <nl> +			req->wr.wr_lo = (__force __be64)(unsigned long)&wr_wait; <nl>  		} else <nl>  			req->wr.wr_hi = cpu_to_be32(FW_WR_OP_V(FW_ULPTX_WR)); <nl>  		req->wr.wr_mid = cpu_to_be32(
@@ -97,8 +97,10 @@ <nl>   <nl>  #define DAS08JR_DI_REG		0x03	/* (R) digital inputs ("JR" boards) */ <nl>  #define DAS08JR_DO_REG		0x03	/* (W) digital outputs ("JR" boards) */ <nl> -#define DAS08JR_AO_LSB(x)	((x) ? 6 : 4) <nl> -#define DAS08JR_AO_MSB(x)	((x) ? 7 : 5) <nl> +/* (W) analog output l.s.b. registers for 2 channels ("JR" boards) */ <nl> +#define DAS08JR_AO_LSB_REG(x)	((x) ? 0x06 : 0x04) <nl> +/* (W) analog output m.s.b. registers for 2 channels ("JR" boards) */ <nl> +#define DAS08JR_AO_MSB_REG(x)	((x) ? 0x07 : 0x05) <nl>   <nl>  /* <nl>      cio-das08_aox.pdf <nl> @@ -353,8 +355,8 @@ static void das08_ao_set_data(struct comedi_device *dev, <nl>  	lsb = data & 0xff; <nl>  	msb = (data >> 8) & 0xff; <nl>  	if (thisboard->is_jr) { <nl> -		outb(lsb, dev->iobase + DAS08JR_AO_LSB(chan)); <nl> -		outb(msb, dev->iobase + DAS08JR_AO_MSB(chan)); <nl> +		outb(lsb, dev->iobase + DAS08JR_AO_LSB_REG(chan)); <nl> +		outb(msb, dev->iobase + DAS08JR_AO_MSB_REG(chan)); <nl>  		/* load DACs */ <nl>  		inb(dev->iobase + DAS08JR_DI_REG); <nl>  	} else {
@@ -758,6 +758,8 @@ static int m41t80_probe(struct i2c_client *client, <nl>  			m41t80_rtc_ops.read_alarm = m41t80_read_alarm; <nl>  			m41t80_rtc_ops.set_alarm = m41t80_set_alarm; <nl>  			m41t80_rtc_ops.alarm_irq_enable = m41t80_alarm_irq_enable; <nl> +			/* Enable the wakealarm */ <nl> +			device_init_wakeup(&client->dev, true); <nl>  		} <nl>  	} <nl>  
@@ -337,10 +337,10 @@ static int wcn36xx_start(struct ieee80211_hw *hw) <nl>  	wcn36xx_smd_stop(wcn); <nl>  out_free_smd_buf: <nl>  	kfree(wcn->hal_buf); <nl> -out_free_dxe_pool: <nl> -	wcn36xx_dxe_free_mem_pools(wcn); <nl>  out_free_dxe_ctl: <nl>  	wcn36xx_dxe_free_ctl_blks(wcn); <nl> +out_free_dxe_pool: <nl> +	wcn36xx_dxe_free_mem_pools(wcn); <nl>  out_smd_close: <nl>  	wcn36xx_smd_close(wcn); <nl>  out_err:
@@ -1704,7 +1704,7 @@ static int stmmac_open(struct net_device *dev) <nl>  		if (ret) { <nl>  			pr_err("%s: Cannot attach to PHY (error: %d)\n", <nl>  			       __func__, ret); <nl> -			goto phy_error; <nl> +			return ret; <nl>  		} <nl>  	} <nl>   <nl> @@ -1779,8 +1779,6 @@ static int stmmac_open(struct net_device *dev) <nl>  dma_desc_error: <nl>  	if (priv->phydev) <nl>  		phy_disconnect(priv->phydev); <nl> -phy_error: <nl> -	clk_disable_unprepare(priv->stmmac_clk); <nl>   <nl>  	return ret; <nl>  }
@@ -170,7 +170,7 @@ static int r600_cs_packet_next_reloc_nomm(struct radeon_cs_parser *p, <nl>  			  idx, relocs_chunk->length_dw); <nl>  		return -EINVAL; <nl>  	} <nl> -	*cs_reloc = &p->relocs[0]; <nl> +	*cs_reloc = p->relocs; <nl>  	(*cs_reloc)->lobj.gpu_offset = (u64)relocs_chunk->kdata[idx + 3] << 32; <nl>  	(*cs_reloc)->lobj.gpu_offset |= relocs_chunk->kdata[idx + 0]; <nl>  	return 0; <nl> @@ -717,7 +717,7 @@ static int r600_cs_parser_relocs_legacy(struct radeon_cs_parser *p) <nl>  	if (p->chunk_relocs_idx == -1) { <nl>  		return 0; <nl>  	} <nl> -	p->relocs = kcalloc(1, sizeof(struct radeon_cs_reloc), GFP_KERNEL); <nl> +	p->relocs = kzalloc(sizeof(struct radeon_cs_reloc), GFP_KERNEL); <nl>  	if (p->relocs == NULL) { <nl>  		return -ENOMEM; <nl>  	}
@@ -364,6 +364,8 @@ static struct hardwall_info *hardwall_create( <nl>  	/* Allocate a new rectangle optimistically. */ <nl>  	rect = kmalloc(sizeof(struct hardwall_info), <nl>  			GFP_KERNEL | __GFP_ZERO); <nl> +	if (rect == NULL) <nl> +		return ERR_PTR(-ENOMEM); <nl>  	INIT_LIST_HEAD(&rect->task_head); <nl>   <nl>  	/* Compute the rectangle size and validate that it's plausible. */
@@ -5045,7 +5045,7 @@ int x86_decode_insn(struct x86_emulate_ctxt *ctxt, void *insn, int insn_len) <nl>  	/* Decode and fetch the destination operand: register or memory. */ <nl>  	rc = decode_operand(ctxt, &ctxt->dst, (ctxt->d >> DstShift) & OpMask); <nl>   <nl> -	if (ctxt->rip_relative) <nl> +	if (ctxt->rip_relative && likely(ctxt->memopp)) <nl>  		ctxt->memopp->addr.mem.ea = address_mask(ctxt, <nl>  					ctxt->memopp->addr.mem.ea + ctxt->_eip); <nl>  
@@ -80,7 +80,7 @@ struct device *driver_find_device(struct device_driver *drv, <nl>  	struct klist_iter i; <nl>  	struct device *dev; <nl>   <nl> -	if (!drv) <nl> +	if (!drv || !drv->p) <nl>  		return NULL; <nl>   <nl>  	klist_iter_init_node(&drv->p->klist_devices, &i,
@@ -3707,7 +3707,7 @@ void __init kmem_cache_init(void) <nl>  	/* Allocate two kmem_caches from the page allocator */ <nl>  	kmalloc_size = ALIGN(kmem_size, cache_line_size()); <nl>  	order = get_order(2 * kmalloc_size); <nl> -	kmem_cache = (void *)__get_free_pages(GFP_NOWAIT, order); <nl> +	kmem_cache = (void *)__get_free_pages(GFP_NOWAIT | __GFP_ZERO, order); <nl>   <nl>  	/* <nl>  	 * Must first have the slab cache available for the allocations of the
@@ -45,6 +45,7 @@ struct crypto_rfc4309_req_ctx { <nl>   <nl>  struct crypto_ccm_req_priv_ctx { <nl>  	u8 odata[16]; <nl> +	u8 idata[16]; <nl>  	u8 auth_tag[16]; <nl>  	u32 flags; <nl>  	struct scatterlist src[3]; <nl> @@ -183,8 +184,8 @@ static int crypto_ccm_auth(struct aead_request *req, struct scatterlist *plain, <nl>  	AHASH_REQUEST_ON_STACK(ahreq, ctx->mac); <nl>  	unsigned int assoclen = req->assoclen; <nl>  	struct scatterlist sg[3]; <nl> -	u8 odata[16]; <nl> -	u8 idata[16]; <nl> +	u8 *odata = pctx->odata; <nl> +	u8 *idata = pctx->idata; <nl>  	int ilen, err; <nl>   <nl>  	/* format control data for input */
@@ -551,7 +551,8 @@ int dn_fib_dump(struct sk_buff *skb, struct netlink_callback *cb) <nl>  		if (t < s_t) <nl>  			continue; <nl>  		if (t > s_t) <nl> -			memset(&cb->args[1], 0, sizeof(cb->args)-sizeof(int)); <nl> +			memset(&cb->args[1], 0, <nl> +			       sizeof(cb->args) - sizeof(cb->args[0])); <nl>  		tb = dn_fib_get_table(t, 0); <nl>  		if (tb == NULL) <nl>  			continue;
@@ -1230,10 +1230,9 @@ static unsigned int xdr_set_page_base(struct xdr_stream *xdr, <nl>  	void *kaddr; <nl>   <nl>  	maxlen = xdr->buf->page_len; <nl> -	if (base >= maxlen) { <nl> -		base = maxlen; <nl> -		maxlen = 0; <nl> -	} else <nl> +	if (base >= maxlen) <nl> +		return 0; <nl> +	else <nl>  		maxlen -= base; <nl>  	if (len > maxlen) <nl>  		len = maxlen;
@@ -1096,6 +1096,7 @@ lba_legacy_resources(struct parisc_device *pa_dev, struct lba_device *lba_dev) <nl>  	r->name = "LBA PCI Busses"; <nl>  	r->start = lba_num & 0xff; <nl>  	r->end = (lba_num>>8) & 0xff; <nl> +	r->flags = IORESOURCE_BUS; <nl>   <nl>  	/* Set up local PCI Bus resources - we don't need them for <nl>  	** Legacy boxes but it's nice to see in /proc/iomem.
@@ -419,8 +419,6 @@ static void sh_mmcif_request_dma(struct sh_mmcif_host *host, <nl>  	if (ret < 0) <nl>  		goto ecfgrx; <nl>   <nl> -	init_completion(&host->dma_complete); <nl> - <nl>  	return; <nl>   <nl>  ecfgrx: <nl> @@ -1061,6 +1059,12 @@ static bool sh_mmcif_end_cmd(struct sh_mmcif_host *host) <nl>  	if (!data) <nl>  		return false; <nl>   <nl> +	/* <nl> +	 * Completion can be signalled from DMA callback and error, so, have to <nl> +	 * reset here, before setting .dma_active <nl> +	 */ <nl> +	init_completion(&host->dma_complete); <nl> + <nl>  	if (data->flags & MMC_DATA_READ) { <nl>  		if (host->chan_rx) <nl>  			sh_mmcif_start_dma_rx(host);
@@ -7451,6 +7451,13 @@ lpfc_els_flush_cmd(struct lpfc_vport *vport) <nl>  	 */ <nl>  	spin_lock_irq(&phba->hbalock); <nl>  	pring = lpfc_phba_elsring(phba); <nl> + <nl> +	/* Bail out if we've no ELS wq, like in PCI error recovery case. */ <nl> +	if (unlikely(!pring)) { <nl> +		spin_unlock_irq(&phba->hbalock); <nl> +		return; <nl> +	} <nl> + <nl>  	if (phba->sli_rev == LPFC_SLI_REV4) <nl>  		spin_lock(&pring->ring_lock); <nl>  
@@ -3172,7 +3172,7 @@ static enum stv090x_signal_state stv090x_algo(struct stv090x_state *state) <nl>  	enum stv090x_signal_state signal_state = STV090x_NOCARRIER; <nl>  	u32 reg; <nl>  	s32 agc1_power, power_iq = 0, i; <nl> -	int lock = 0, low_sr = 0, no_signal = 0; <nl> +	int lock = 0, low_sr = 0; <nl>   <nl>  	reg = STV090x_READ_DEMOD(state, TSCFGH); <nl>  	STV090x_SETFIELD_Px(reg, RST_HWARE_FIELD, 1); /* Stop path 1 stream merger */ <nl> @@ -3411,10 +3411,9 @@ static enum stv090x_signal_state stv090x_algo(struct stv090x_state *state) <nl>  			/* Reset the packet Error counter2 */ <nl>  			if (STV090x_WRITE_DEMOD(state, ERRCTRL2, 0xc1) < 0) <nl>  				goto err; <nl> -		} else { <nl> +		} else <nl>  			signal_state = STV090x_NODATA; <nl> -			no_signal = stv090x_chk_signal(state); <nl> -		} <nl> + <nl>  	} <nl>  	return signal_state; <nl>  
@@ -105,16 +105,19 @@ static int ath_max_4ms_framelen[4][32] = { <nl>  /*********************/ <nl>   <nl>  static void ath_txq_lock(struct ath_softc *sc, struct ath_txq *txq) <nl> +	__acquires(&txq->axq_lock) <nl>  { <nl>  	spin_lock_bh(&txq->axq_lock); <nl>  } <nl>   <nl>  static void ath_txq_unlock(struct ath_softc *sc, struct ath_txq *txq) <nl> +	__releases(&txq->axq_lock) <nl>  { <nl>  	spin_unlock_bh(&txq->axq_lock); <nl>  } <nl>   <nl>  static void ath_txq_unlock_complete(struct ath_softc *sc, struct ath_txq *txq) <nl> +	__releases(&txq->axq_lock) <nl>  { <nl>  	struct sk_buff_head q; <nl>  	struct sk_buff *skb;
@@ -1684,6 +1684,7 @@ static int ibmvscsi_probe(struct vio_dev *vdev, const struct vio_device_id *id) <nl>  	host->max_lun = 8; <nl>  	host->max_id = max_id; <nl>  	host->max_channel = max_channel; <nl> +	host->max_cmd_len = 16; <nl>   <nl>  	if (scsi_add_host(hostdata->host, hostdata->dev)) <nl>  		goto add_host_failed;
@@ -1597,7 +1597,7 @@ static int ir_probe(struct i2c_client *client, const struct i2c_device_id *id) <nl>  			i2c_set_clientdata(client, NULL); <nl>  			put_ir_rx(rx, true); <nl>  			ir->l.features &= ~LIRC_CAN_REC_LIRCCODE; <nl> -			goto out_put_xx; <nl> +			goto out_put_tx; <nl>  		} <nl>   <nl>  		/* Proceed only if the Tx client is also ready */ <nl> @@ -1637,6 +1637,7 @@ static int ir_probe(struct i2c_client *client, const struct i2c_device_id *id) <nl>  out_put_xx: <nl>  	if (rx != NULL) <nl>  		put_ir_rx(rx, true); <nl> +out_put_tx: <nl>  	if (tx != NULL) <nl>  		put_ir_tx(tx, true); <nl>  out_put_ir:
@@ -2032,7 +2032,7 @@ int vt_do_kdskled(int console, int cmd, unsigned long arg, int perm) <nl>  		kbd->default_ledflagstate = ((arg >> 4) & 7); <nl>  		set_leds(); <nl>                  spin_unlock_irqrestore(&kbd_event_lock, flags); <nl> -		break; <nl> +		return 0; <nl>   <nl>  	/* the ioctls below only set the lights, not the functions */ <nl>  	/* for those, see KDGKBLED and KDSKBLED above */
@@ -302,6 +302,9 @@ static int alc_mux_select(struct hda_codec *codec, unsigned int adc_idx, <nl>  	int i, type, num_conns; <nl>  	hda_nid_t nid; <nl>   <nl> +	if (!spec->input_mux) <nl> +		return 0; <nl> + <nl>  	mux_idx = adc_idx >= spec->num_mux_defs ? 0 : adc_idx; <nl>  	imux = &spec->input_mux[mux_idx]; <nl>  	if (!imux->num_items && mux_idx > 0)
@@ -2053,6 +2053,8 @@ static int do_proc_dointvec_jiffies_conv(int *negp, unsigned long *lvalp, <nl>  					 int write, void *data) <nl>  { <nl>  	if (write) { <nl> +		if (*lvalp > LONG_MAX / HZ) <nl> +			return 1; <nl>  		*valp = *negp ? -(*lvalp*HZ) : (*lvalp*HZ); <nl>  	} else { <nl>  		int val = *valp; <nl> @@ -2074,6 +2076,8 @@ static int do_proc_dointvec_userhz_jiffies_conv(int *negp, unsigned long *lvalp, <nl>  						int write, void *data) <nl>  { <nl>  	if (write) { <nl> +		if (USER_HZ < HZ && *lvalp > (LONG_MAX / HZ) * USER_HZ) <nl> +			return 1; <nl>  		*valp = clock_t_to_jiffies(*negp ? -*lvalp : *lvalp); <nl>  	} else { <nl>  		int val = *valp;
@@ -191,7 +191,7 @@ enum ep_state { <nl>  struct ep_data { <nl>  	struct mutex			lock; <nl>  	enum ep_state			state; <nl> -	atomic_t			count; <nl> +	refcount_t			count; <nl>  	struct dev_data			*dev; <nl>  	/* must hold dev->lock before accessing ep or req */ <nl>  	struct usb_ep			*ep; <nl> @@ -206,12 +206,12 @@ struct ep_data { <nl>   <nl>  static inline void get_ep (struct ep_data *data) <nl>  { <nl> -	atomic_inc (&data->count); <nl> +	refcount_inc (&data->count); <nl>  } <nl>   <nl>  static void put_ep (struct ep_data *data) <nl>  { <nl> -	if (likely (!atomic_dec_and_test (&data->count))) <nl> +	if (likely (!refcount_dec_and_test (&data->count))) <nl>  		return; <nl>  	put_dev (data->dev); <nl>  	/* needs no more cleanup */ <nl> @@ -1562,7 +1562,7 @@ static int activate_ep_files (struct dev_data *dev) <nl>  		init_waitqueue_head (&data->wait); <nl>   <nl>  		strncpy (data->name, ep->name, sizeof (data->name) - 1); <nl> -		atomic_set (&data->count, 1); <nl> +		refcount_set (&data->count, 1); <nl>  		data->dev = dev; <nl>  		get_dev (dev); <nl>  
@@ -46,7 +46,7 @@ uint16_t fixed_point_to_int_frac( <nl>  			arg)); <nl>   <nl>  	if (d <= (uint16_t)(1 << integer_bits) - (1 / (uint16_t)divisor)) <nl> -		numerator = (uint16_t)dal_fixed31_32_floor( <nl> +		numerator = (uint16_t)dal_fixed31_32_round( <nl>  			dal_fixed31_32_mul_int( <nl>  				arg, <nl>  				divisor));
@@ -2056,6 +2056,8 @@ sg_unlink_reserve(Sg_fd * sfp, Sg_request * srp) <nl>  	req_schp->page_order = 0; <nl>  	req_schp->sglist_len = 0; <nl>  	srp->res_used = 0; <nl> +	/* Called without mutex lock to avoid deadlock */ <nl> +	sfp->res_in_use = 0; <nl>  } <nl>   <nl>  static Sg_request *
@@ -527,6 +527,10 @@ static int imx_ssi_probe(struct platform_device *pdev) <nl>  	} <nl>   <nl>  	ssi->irq = platform_get_irq(pdev, 0); <nl> +	if (ssi->irq < 0) { <nl> +		dev_err(&pdev->dev, "Failed to get IRQ: %d\n", ssi->irq); <nl> +		return ssi->irq; <nl> +	} <nl>   <nl>  	ssi->clk = devm_clk_get(&pdev->dev, NULL); <nl>  	if (IS_ERR(ssi->clk)) {
@@ -320,7 +320,7 @@ static struct config_group *target_fabric_make_mappedlun( <nl>  			struct se_node_acl, acl_group); <nl>  	struct se_portal_group *se_tpg = se_nacl->se_tpg; <nl>  	struct target_fabric_configfs *tf = se_tpg->se_tpg_wwn->wwn_tf; <nl> -	struct se_lun_acl *lacl; <nl> +	struct se_lun_acl *lacl = NULL; <nl>  	struct config_item *acl_ci; <nl>  	struct config_group *lacl_cg = NULL, *ml_stat_grp = NULL; <nl>  	char *buf; <nl> @@ -406,6 +406,7 @@ static struct config_group *target_fabric_make_mappedlun( <nl>  out: <nl>  	if (lacl_cg) <nl>  		kfree(lacl_cg->default_groups); <nl> +	kfree(lacl); <nl>  	kfree(buf); <nl>  	return ERR_PTR(ret); <nl>  }
@@ -349,6 +349,10 @@ struct perf_evsel *perf_evlist__id2evsel(struct perf_evlist *evlist, u64 id) <nl>  	hlist_for_each_entry(sid, pos, head, node) <nl>  		if (sid->id == id) <nl>  			return sid->evsel; <nl> + <nl> +	if (!perf_evlist__sample_id_all(evlist)) <nl> +		return list_entry(evlist->entries.next, struct perf_evsel, node); <nl> + <nl>  	return NULL; <nl>  } <nl>  
@@ -413,6 +413,7 @@ i915_gem_execbuffer_reserve(struct intel_ring_buffer *ring, <nl>   <nl>  		obj->base.pending_read_domains = 0; <nl>  		obj->base.pending_write_domain = 0; <nl> +		obj->pending_fenced_gpu_access = false; <nl>  	} <nl>  	list_splice(&ordered_objects, objects); <nl>  
@@ -3022,7 +3022,7 @@ static int nested_vmx_check_guest_state(struct kvm_vcpu *vcpu, <nl>  					struct vmcs12 *vmcs12, <nl>  					enum vm_entry_failure_code *entry_failure_code) <nl>  { <nl> -	bool ia32e; <nl> +	bool ia32e = !!(vmcs12->vm_entry_controls & VM_ENTRY_IA32E_MODE); <nl>   <nl>  	*entry_failure_code = ENTRY_FAIL_DEFAULT; <nl>   <nl> @@ -3048,6 +3048,13 @@ static int nested_vmx_check_guest_state(struct kvm_vcpu *vcpu, <nl>  					   vmcs12->guest_ia32_perf_global_ctrl))) <nl>  		return -EINVAL; <nl>   <nl> +	if (CC((vmcs12->guest_cr0 & (X86_CR0_PG | X86_CR0_PE)) == X86_CR0_PG)) <nl> +		return -EINVAL; <nl> + <nl> +	if (CC(ia32e && !(vmcs12->guest_cr4 & X86_CR4_PAE)) || <nl> +	    CC(ia32e && !(vmcs12->guest_cr0 & X86_CR0_PG))) <nl> +		return -EINVAL; <nl> + <nl>  	/* <nl>  	 * If the load IA32_EFER VM-entry control is 1, the following checks <nl>  	 * are performed on the field for the IA32_EFER MSR: <nl> @@ -3059,7 +3066,6 @@ static int nested_vmx_check_guest_state(struct kvm_vcpu *vcpu, <nl>  	 */ <nl>  	if (to_vmx(vcpu)->nested.nested_run_pending && <nl>  	    (vmcs12->vm_entry_controls & VM_ENTRY_LOAD_IA32_EFER)) { <nl> -		ia32e = (vmcs12->vm_entry_controls & VM_ENTRY_IA32E_MODE) != 0; <nl>  		if (CC(!kvm_valid_efer(vcpu, vmcs12->guest_ia32_efer)) || <nl>  		    CC(ia32e != !!(vmcs12->guest_ia32_efer & EFER_LMA)) || <nl>  		    CC(((vmcs12->guest_cr0 & X86_CR0_PG) &&
@@ -1196,7 +1196,7 @@ static int mv_udc_get_frame(struct usb_gadget *gadget) <nl>   <nl>  	udc = container_of(gadget, struct mv_udc, gadget); <nl>   <nl> -	retval = readl(udc->op_regs->frindex) & USB_FRINDEX_MASKS; <nl> +	retval = readl(&udc->op_regs->frindex) & USB_FRINDEX_MASKS; <nl>   <nl>  	return retval; <nl>  }
@@ -739,10 +739,16 @@ static struct hash_cell *__find_device_hash_cell(struct dm_ioctl *param) <nl>  	struct hash_cell *hc = NULL; <nl>   <nl>  	if (*param->uuid) { <nl> +		if (*param->name || param->dev) <nl> +			return NULL; <nl> + <nl>  		hc = __get_uuid_cell(param->uuid); <nl>  		if (!hc) <nl>  			return NULL; <nl>  	} else if (*param->name) { <nl> +		if (param->dev) <nl> +			return NULL; <nl> + <nl>  		hc = __get_name_cell(param->name); <nl>  		if (!hc) <nl>  			return NULL;
@@ -1237,6 +1237,7 @@ static int s2255_set_mode(struct s2255_dev *dev, unsigned long chn, <nl>  	buffer[1] = (u32) chn_rev; <nl>  	buffer[2] = CMD_SET_MODE; <nl>  	memcpy(&buffer[3], &dev->mode[chn], sizeof(struct s2255_mode)); <nl> +	dev->setmode_ready[chn] = 0; <nl>  	res = s2255_write_config(dev->udev, (unsigned char *)buffer, 512); <nl>  	if (debug) <nl>  		dump_verify_mode(dev, mode); <nl> @@ -1245,7 +1246,6 @@ static int s2255_set_mode(struct s2255_dev *dev, unsigned long chn, <nl>   <nl>  	/* wait at least 3 frames before continuing */ <nl>  	if (mode->restart) { <nl> -		dev->setmode_ready[chn] = 0; <nl>  		wait_event_timeout(dev->wait_setmode[chn], <nl>  				   (dev->setmode_ready[chn] != 0), <nl>  				   msecs_to_jiffies(S2255_SETMODE_TIMEOUT));
@@ -2254,10 +2254,10 @@ static int sh_mdio_init(struct net_device *ndev, int id, <nl>  	/* bitbang init */ <nl>  	bitbang->addr = mdp->addr + mdp->reg_offset[PIR]; <nl>  	bitbang->set_gate = pd->set_mdio_gate; <nl> -	bitbang->mdi_msk = 0x08; <nl> -	bitbang->mdo_msk = 0x04; <nl> -	bitbang->mmd_msk = 0x02;/* MMD */ <nl> -	bitbang->mdc_msk = 0x01; <nl> +	bitbang->mdi_msk = PIR_MDI; <nl> +	bitbang->mdo_msk = PIR_MDO; <nl> +	bitbang->mmd_msk = PIR_MMD; <nl> +	bitbang->mdc_msk = PIR_MDC; <nl>  	bitbang->ctrl.ops = &bb_ops; <nl>   <nl>  	/* MII controller setting */
@@ -1398,7 +1398,7 @@ int bnxt_re_create_srq(struct ib_srq *ib_srq, <nl>  			dev_err(rdev_to_dev(rdev), "SRQ copy to udata failed!"); <nl>  			bnxt_qplib_destroy_srq(&rdev->qplib_res, <nl>  					       &srq->qplib_srq); <nl> -			goto exit; <nl> +			goto fail; <nl>  		} <nl>  	} <nl>  	if (nq)
@@ -3279,8 +3279,8 @@ build_unc_path_to_root(const struct smb_vol *vol, <nl>  	pos = full_path + unc_len; <nl>   <nl>  	if (pplen) { <nl> -		*pos++ = CIFS_DIR_SEP(cifs_sb); <nl> -		strncpy(pos, vol->prepath, pplen); <nl> +		*pos = CIFS_DIR_SEP(cifs_sb); <nl> +		strncpy(pos + 1, vol->prepath, pplen); <nl>  		pos += pplen; <nl>  	} <nl>  
@@ -47,12 +47,12 @@ static int net_ctl_permissions(struct ctl_table_header *head, <nl>   <nl>  	/* Allow network administrator to have same access as root. */ <nl>  	if (ns_capable(net->user_ns, CAP_NET_ADMIN) || <nl> -	    uid_eq(root_uid, current_uid())) { <nl> +	    uid_eq(root_uid, current_euid())) { <nl>  		int mode = (table->mode >> 6) & 7; <nl>  		return (mode << 6) | (mode << 3) | mode; <nl>  	} <nl>  	/* Allow netns root group to have the same access as the root group */ <nl> -	if (gid_eq(root_gid, current_gid())) { <nl> +	if (in_egroup_p(root_gid)) { <nl>  		int mode = (table->mode >> 3) & 7; <nl>  		return (mode << 3) | mode; <nl>  	}
@@ -4266,10 +4266,11 @@ static inline void nfs4_stateid_downgrade(struct nfs4_ol_stateid *stp, u32 to_ac <nl>  } <nl>   <nl>  static void <nl> -reset_union_bmap_deny(unsigned long deny, struct nfs4_ol_stateid *stp) <nl> +reset_union_bmap_deny(u32 deny, struct nfs4_ol_stateid *stp) <nl>  { <nl>  	int i; <nl> -	for (i = 0; i < 4; i++) { <nl> + <nl> +	for (i = 1; i < 4; i++) { <nl>  		if ((i & deny) != i) <nl>  			clear_deny(i, stp); <nl>  	}
@@ -715,7 +715,7 @@ static enum page_references page_check_references(struct page *page, <nl>  		 */ <nl>  		SetPageReferenced(page); <nl>   <nl> -		if (referenced_page) <nl> +		if (referenced_page || referenced_ptes > 1) <nl>  			return PAGEREF_ACTIVATE; <nl>   <nl>  		return PAGEREF_KEEP;
@@ -258,10 +258,9 @@ static void tk_setup_internals(struct timekeeper *tk, struct clocksource *clock) <nl>  	tk->cycle_interval = interval; <nl>   <nl>  	/* Go back from cycles -> shifted ns */ <nl> -	tk->xtime_interval = (u64) interval * clock->mult; <nl> +	tk->xtime_interval = interval * clock->mult; <nl>  	tk->xtime_remainder = ntpinterval - tk->xtime_interval; <nl> -	tk->raw_interval = <nl> -		((u64) interval * clock->mult) >> clock->shift; <nl> +	tk->raw_interval = (interval * clock->mult) >> clock->shift; <nl>   <nl>  	 /* if changing clocks, convert xtime_nsec shift units */ <nl>  	if (old_clock) {
@@ -35,7 +35,6 @@ int __init pci_legacy_init(void) <nl>   <nl>  	return 0; <nl>  } <nl> -EXPORT_SYMBOL_GPL(pci_legacy_init); <nl>   <nl>  void pcibios_scan_specific_bus(int busn) <nl>  {
@@ -2697,7 +2697,7 @@ static int transport_generic_cmd_sequencer( <nl>  			cmd->se_cmd_flags |= SCF_SCSI_CONTROL_SG_IO_CDB; <nl>   <nl>  			if (target_check_write_same_discard(&cdb[10], dev) < 0) <nl> -				goto out_invalid_cdb_field; <nl> +				goto out_unsupported_cdb; <nl>  			if (!passthrough) <nl>  				cmd->execute_task = target_emulate_write_same; <nl>  			break; <nl> @@ -2980,7 +2980,7 @@ static int transport_generic_cmd_sequencer( <nl>  		cmd->se_cmd_flags |= SCF_SCSI_CONTROL_SG_IO_CDB; <nl>   <nl>  		if (target_check_write_same_discard(&cdb[1], dev) < 0) <nl> -			goto out_invalid_cdb_field; <nl> +			goto out_unsupported_cdb; <nl>  		if (!passthrough) <nl>  			cmd->execute_task = target_emulate_write_same; <nl>  		break; <nl> @@ -3003,7 +3003,7 @@ static int transport_generic_cmd_sequencer( <nl>  		 * of byte 1 bit 3 UNMAP instead of original reserved field <nl>  		 */ <nl>  		if (target_check_write_same_discard(&cdb[1], dev) < 0) <nl> -			goto out_invalid_cdb_field; <nl> +			goto out_unsupported_cdb; <nl>  		if (!passthrough) <nl>  			cmd->execute_task = target_emulate_write_same; <nl>  		break;
@@ -499,7 +499,10 @@ static inline int do_rom_fast_write_words(struct netxen_adapter *adapter, <nl>  		while(1) { <nl>  			int data1; <nl>   <nl> -			do_rom_fast_read(adapter, addridx, &data1); <nl> +			ret = do_rom_fast_read(adapter, addridx, &data1); <nl> +			if (ret < 0) <nl> +				return ret; <nl> + <nl>  			if (data1 == data) <nl>  				break; <nl>  
@@ -103,7 +103,7 @@ unsigned int solo_eeprom_ewen(struct solo_dev *solo_dev, int w_en) <nl>  __be16 solo_eeprom_read(struct solo_dev *solo_dev, int loc) <nl>  { <nl>  	int read_cmd = loc | (EE_READ_CMD << ADDR_LEN); <nl> -	unsigned short retval = 0; <nl> +	u16 retval = 0; <nl>  	int i; <nl>   <nl>  	solo_eeprom_cmd(solo_dev, read_cmd);
@@ -1527,6 +1527,9 @@ static int sgtl5000_i2c_probe(struct i2c_client *client, <nl>  	if (IS_ERR(sgtl5000->mclk)) { <nl>  		ret = PTR_ERR(sgtl5000->mclk); <nl>  		dev_err(&client->dev, "Failed to get mclock: %d\n", ret); <nl> +		/* Defer the probe to see if the clk will be provided later */ <nl> +		if (ret == -ENOENT) <nl> +			return -EPROBE_DEFER; <nl>  		return ret; <nl>  	} <nl>  
@@ -780,8 +780,10 @@ s32 ixgbe_blink_led_start_X540(struct ixgbe_hw *hw, u32 index) <nl>  	ixgbe_link_speed speed; <nl>  	bool link_up; <nl>   <nl> -	/* <nl> -	 * Link should be up in order for the blink bit in the LED control <nl> +	if (index > 3) <nl> +		return IXGBE_ERR_PARAM; <nl> + <nl> +	/* Link should be up in order for the blink bit in the LED control <nl>  	 * register to work. Force link and speed in the MAC if link is down. <nl>  	 * This will be reversed when we stop the blinking. <nl>  	 */ <nl> @@ -814,6 +816,9 @@ s32 ixgbe_blink_led_stop_X540(struct ixgbe_hw *hw, u32 index) <nl>  	u32 macc_reg; <nl>  	u32 ledctl_reg; <nl>   <nl> +	if (index > 3) <nl> +		return IXGBE_ERR_PARAM; <nl> + <nl>  	/* Restore the LED to its default value. */ <nl>  	ledctl_reg = IXGBE_READ_REG(hw, IXGBE_LEDCTL); <nl>  	ledctl_reg &= ~IXGBE_LED_MODE_MASK(index);
@@ -1167,8 +1167,11 @@ int cx23888_ir_probe(struct cx23885_dev *dev) <nl>  		return -ENOMEM; <nl>   <nl>  	spin_lock_init(&state->rx_kfifo_lock); <nl> -	if (kfifo_alloc(&state->rx_kfifo, CX23888_IR_RX_KFIFO_SIZE, GFP_KERNEL)) <nl> +	if (kfifo_alloc(&state->rx_kfifo, CX23888_IR_RX_KFIFO_SIZE, <nl> +			GFP_KERNEL)) { <nl> +		kfree(state); <nl>  		return -ENOMEM; <nl> +	} <nl>   <nl>  	state->dev = dev; <nl>  	sd = &state->sd;
@@ -3751,8 +3751,11 @@ static void task_fork_fair(struct task_struct *p) <nl>   <nl>  	update_rq_clock(rq); <nl>   <nl> -	if (unlikely(task_cpu(p) != this_cpu)) <nl> +	if (unlikely(task_cpu(p) != this_cpu)) { <nl> +		rcu_read_lock(); <nl>  		__set_task_cpu(p, this_cpu); <nl> +		rcu_read_unlock(); <nl> +	} <nl>   <nl>  	update_curr(cfs_rq); <nl>  
@@ -1698,6 +1698,9 @@ static int i915_context_status(struct seq_file *m, void *unused) <nl>  	} <nl>   <nl>  	list_for_each_entry(ctx, &dev_priv->context_list, link) { <nl> +		if (ctx->obj == NULL) <nl> +			continue; <nl> + <nl>  		seq_puts(m, "HW context "); <nl>  		describe_ctx(m, ctx); <nl>  		for_each_ring(ring, dev_priv, i)
@@ -1039,8 +1039,8 @@ static int fusb302_pd_send_message(struct fusb302_chip *chip, <nl>  	} <nl>  	/* packsym tells the FUSB302 chip that the next X bytes are payload */ <nl>  	buf[pos++] = FUSB302_TKN_PACKSYM | (len & 0x1F); <nl> -	buf[pos++] = msg->header & 0xFF; <nl> -	buf[pos++] = (msg->header >> 8) & 0xFF; <nl> +	memcpy(&buf[pos], &msg->header, sizeof(msg->header)); <nl> +	pos += sizeof(msg->header); <nl>   <nl>  	len -= 2; <nl>  	memcpy(&buf[pos], msg->payload, len);
@@ -556,6 +556,9 @@ void pcie_aspm_init_link_state(struct pci_dev *pdev) <nl>  	struct pcie_link_state *link; <nl>  	int blacklist = !!pcie_aspm_sanity_check(pdev); <nl>   <nl> +	if (!aspm_support_enabled) <nl> +		return; <nl> + <nl>  	if (!pci_is_pcie(pdev) || pdev->link_state) <nl>  		return; <nl>  	if (pci_pcie_type(pdev) != PCI_EXP_TYPE_ROOT_PORT &&
@@ -59,6 +59,12 @@ static int nft_range_init(const struct nft_ctx *ctx, const struct nft_expr *expr <nl>  	int err; <nl>  	u32 op; <nl>   <nl> +	if (!tb[NFTA_RANGE_SREG]      || <nl> +	    !tb[NFTA_RANGE_OP]	      || <nl> +	    !tb[NFTA_RANGE_FROM_DATA] || <nl> +	    !tb[NFTA_RANGE_TO_DATA]) <nl> +		return -EINVAL; <nl> + <nl>  	err = nft_data_init(NULL, &priv->data_from, sizeof(priv->data_from), <nl>  			    &desc_from, tb[NFTA_RANGE_FROM_DATA]); <nl>  	if (err < 0)
@@ -213,6 +213,11 @@ struct kvm_vcpu *kvm_arch_vcpu_create(struct kvm *kvm, unsigned int id) <nl>  	int err; <nl>  	struct kvm_vcpu *vcpu; <nl>   <nl> +	if (irqchip_in_kernel(kvm) && vgic_initialized(kvm)) { <nl> +		err = -EBUSY; <nl> +		goto out; <nl> +	} <nl> + <nl>  	vcpu = kmem_cache_zalloc(kvm_vcpu_cache, GFP_KERNEL); <nl>  	if (!vcpu) { <nl>  		err = -ENOMEM;
@@ -172,21 +172,25 @@ int dccp_parse_options(struct sock *sk, struct sk_buff *skb) <nl>  			opt_recv->dccpor_timestamp_echo = ntohl(*(__be32 *)value); <nl>   <nl>  			dccp_pr_debug("%s rx opt: TIMESTAMP_ECHO=%u, len=%d, " <nl> -				      "ackno=%llu, ",  dccp_role(sk), <nl> +				      "ackno=%llu", dccp_role(sk), <nl>  				      opt_recv->dccpor_timestamp_echo, <nl>  				      len + 2, <nl>  				      (unsigned long long) <nl>  				      DCCP_SKB_CB(skb)->dccpd_ack_seq); <nl>   <nl>   <nl> -			if (len == 4) <nl> +			if (len == 4) { <nl> +				dccp_pr_debug_cat("\n"); <nl>  				break; <nl> +			} <nl>   <nl>  			if (len == 6) <nl>  				elapsed_time = ntohs(*(__be16 *)(value + 4)); <nl>  			else <nl>  				elapsed_time = ntohl(*(__be32 *)(value + 4)); <nl>   <nl> +			dccp_pr_debug_cat(", ELAPSED_TIME=%d\n", elapsed_time); <nl> + <nl>  			/* Give precedence to the biggest ELAPSED_TIME */ <nl>  			if (elapsed_time > opt_recv->dccpor_elapsed_time) <nl>  				opt_recv->dccpor_elapsed_time = elapsed_time;
@@ -188,7 +188,7 @@ int ubi_io_read(const struct ubi_device *ubi, void *buf, int pnum, int offset, <nl>  			return UBI_IO_BITFLIPS; <nl>  		} <nl>   <nl> -		if (read != len && retries++ < UBI_IO_RETRIES) { <nl> +		if (retries++ < UBI_IO_RETRIES) { <nl>  			dbg_io("error %d%s while reading %d bytes from PEB %d:%d," <nl>  			       " read only %zd bytes, retry", <nl>  			       err, errstr, len, pnum, offset, read);
@@ -3469,6 +3469,10 @@ fec_probe(struct platform_device *pdev) <nl>  			goto failed_regulator; <nl>  		} <nl>  	} else { <nl> +		if (PTR_ERR(fep->reg_phy) == -EPROBE_DEFER) { <nl> +			ret = -EPROBE_DEFER; <nl> +			goto failed_regulator; <nl> +		} <nl>  		fep->reg_phy = NULL; <nl>  	} <nl>  
@@ -1393,6 +1393,9 @@ static int iommu_map_page(struct protection_domain *dom, <nl>  	count     = PAGE_SIZE_PTE_COUNT(page_size); <nl>  	pte       = alloc_pte(dom, bus_addr, page_size, NULL, GFP_KERNEL); <nl>   <nl> +	if (!pte) <nl> +		return -ENOMEM; <nl> + <nl>  	for (i = 0; i < count; ++i) <nl>  		if (IOMMU_PTE_PRESENT(pte[i])) <nl>  			return -EBUSY;
@@ -1063,7 +1063,7 @@ static int mp_wait_modem_status(struct sb_uart_state *state, unsigned long arg) <nl>   <nl>  static int mp_get_count(struct sb_uart_state *state, struct serial_icounter_struct *icnt) <nl>  { <nl> -	struct serial_icounter_struct icount; <nl> +	struct serial_icounter_struct icount = {}; <nl>  	struct sb_uart_icount cnow; <nl>  	struct sb_uart_port *port = state->port; <nl>  
@@ -713,6 +713,7 @@ static int gbaudio_codec_probe(struct gb_connection *connection) <nl>  	kfree(topology); <nl>  base_error: <nl>  	gbcodec->mgmt_connection = NULL; <nl> +	gbaudio_free_codec(dev, gbcodec); <nl>  	return ret; <nl>  } <nl>  
@@ -878,6 +878,7 @@ static struct sk_buff *xfrm_state_netlink(struct sk_buff *in_skb, <nl>  { <nl>  	struct xfrm_dump_info info; <nl>  	struct sk_buff *skb; <nl> +	int err; <nl>   <nl>  	skb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC); <nl>  	if (!skb) <nl> @@ -888,9 +889,10 @@ static struct sk_buff *xfrm_state_netlink(struct sk_buff *in_skb, <nl>  	info.nlmsg_seq = seq; <nl>  	info.nlmsg_flags = 0; <nl>   <nl> -	if (dump_one_state(x, 0, &info)) { <nl> +	err = dump_one_state(x, 0, &info); <nl> +	if (err) { <nl>  		kfree_skb(skb); <nl> -		return NULL; <nl> +		return ERR_PTR(err); <nl>  	} <nl>   <nl>  	return skb;
@@ -173,7 +173,11 @@ static int davinci_wdt_probe(struct platform_device *pdev) <nl>  		return PTR_ERR(davinci_wdt->clk); <nl>  	} <nl>   <nl> -	clk_prepare_enable(davinci_wdt->clk); <nl> +	ret = clk_prepare_enable(davinci_wdt->clk); <nl> +	if (ret) { <nl> +		dev_err(&pdev->dev, "failed to prepare clock\n"); <nl> +		return ret; <nl> +	} <nl>   <nl>  	platform_set_drvdata(pdev, davinci_wdt); <nl>  
@@ -199,10 +199,8 @@ EXPORT_SYMBOL(vio_unregister_driver); <nl>  /* vio_dev refcount hit 0 */ <nl>  static void __devinit vio_dev_release(struct device *dev) <nl>  { <nl> -	if (dev->archdata.of_node) { <nl> -		/* XXX should free TCE table */ <nl> -		of_node_put(dev->archdata.of_node); <nl> -	} <nl> +	/* XXX should free TCE table */ <nl> +	of_node_put(dev->archdata.of_node); <nl>  	kfree(to_vio_dev(dev)); <nl>  } <nl>  
@@ -1002,8 +1002,14 @@ static int ironlake_do_reset(struct drm_device *dev) <nl>   <nl>  	I915_WRITE(MCHBAR_MIRROR_BASE + ILK_GDSR, <nl>  		   ILK_GRDOM_MEDIA | ILK_GRDOM_RESET_ENABLE); <nl> -	return wait_for((I915_READ(MCHBAR_MIRROR_BASE + ILK_GDSR) & <nl> -			 ILK_GRDOM_RESET_ENABLE) == 0, 500); <nl> +	ret = wait_for((I915_READ(MCHBAR_MIRROR_BASE + ILK_GDSR) & <nl> +			ILK_GRDOM_RESET_ENABLE) == 0, 500); <nl> +	if (ret) <nl> +		return ret; <nl> + <nl> +	I915_WRITE(MCHBAR_MIRROR_BASE + ILK_GDSR, 0); <nl> + <nl> +	return 0; <nl>  } <nl>   <nl>  static int gen6_do_reset(struct drm_device *dev)
@@ -7676,6 +7676,7 @@ static int __build_sched_domains(const cpumask_t *cpu_map, <nl>  error: <nl>  	free_sched_groups(cpu_map, tmpmask); <nl>  	SCHED_CPUMASK_FREE((void *)allmasks); <nl> +	kfree(rd); <nl>  	return -ENOMEM; <nl>  #endif <nl>  }
@@ -1821,7 +1821,7 @@ rcu_torture_init(void) <nl>  		if (firsterr) <nl>  			goto unwind; <nl>  	} <nl> -	if (test_no_idle_hz) { <nl> +	if (test_no_idle_hz && shuffle_interval > 0) { <nl>  		firsterr = torture_shuffle_init(shuffle_interval * HZ); <nl>  		if (firsterr) <nl>  			goto unwind;
@@ -317,7 +317,7 @@ static int camif_media_dev_init(struct camif_dev *camif) <nl>  		 ip_rev == S3C6410_CAMIF_IP_REV ? "6410" : "244X"); <nl>  	strlcpy(md->bus_info, "platform", sizeof(md->bus_info)); <nl>  	md->hw_revision = ip_rev; <nl> -	md->driver_version = KERNEL_VERSION(1, 0, 0); <nl> +	md->driver_version = LINUX_VERSION_CODE; <nl>   <nl>  	md->dev = camif->dev; <nl>  
@@ -1184,6 +1184,7 @@ static void snd_hda_codec_free(struct hda_codec *codec) <nl>  { <nl>  	if (!codec) <nl>  		return; <nl> +	snd_hda_jack_tbl_clear(codec); <nl>  	restore_init_pincfgs(codec); <nl>  #ifdef CONFIG_SND_HDA_POWER_SAVE <nl>  	cancel_delayed_work(&codec->power_work); <nl> @@ -1192,6 +1193,7 @@ static void snd_hda_codec_free(struct hda_codec *codec) <nl>  	list_del(&codec->list); <nl>  	snd_array_free(&codec->mixers); <nl>  	snd_array_free(&codec->nids); <nl> +	snd_array_free(&codec->cvt_setups); <nl>  	snd_array_free(&codec->conn_lists); <nl>  	snd_array_free(&codec->spdif_out); <nl>  	codec->bus->caddr_tbl[codec->addr] = NULL;
@@ -170,7 +170,10 @@ static int scmi_hwmon_probe(struct scmi_device *sdev) <nl>  	scmi_chip_info.info = ptr_scmi_ci; <nl>  	chip_info = &scmi_chip_info; <nl>   <nl> -	for (type = 0; type < hwmon_max && nr_count[type]; type++) { <nl> +	for (type = 0; type < hwmon_max; type++) { <nl> +		if (!nr_count[type]) <nl> +			continue; <nl> + <nl>  		scmi_hwmon_add_chan_info(scmi_hwmon_chan, dev, nr_count[type], <nl>  					 type, hwmon_attributes[type]); <nl>  		*ptr_scmi_ci++ = scmi_hwmon_chan++;
@@ -1513,10 +1513,16 @@ int vfs_quota_on_mount(struct super_block *sb, char *qf_name, <nl>  	if (IS_ERR(dentry)) <nl>  		return PTR_ERR(dentry); <nl>   <nl> +	if (!dentry->d_inode) { <nl> +		error = -ENOENT; <nl> +		goto out; <nl> +	} <nl> + <nl>  	error = security_quota_on(dentry); <nl>  	if (!error) <nl>  		error = vfs_quota_on_inode(dentry->d_inode, type, format_id); <nl>   <nl> +out: <nl>  	dput(dentry); <nl>  	return error; <nl>  }
@@ -225,9 +225,9 @@ snd_emux_load_patch_seq_oss(struct snd_seq_oss_arg *arg, int format, <nl>  	else if (format == SNDRV_OSS_SOUNDFONT_PATCH) { <nl>  		struct soundfont_patch_info patch; <nl>  		if (count < (int)sizeof(patch)) <nl> -			rc = -EINVAL; <nl> +			return -EINVAL; <nl>  		if (copy_from_user(&patch, buf, sizeof(patch))) <nl> -			rc = -EFAULT; <nl> +			return -EFAULT; <nl>  		if (patch.type >= SNDRV_SFNT_LOAD_INFO && <nl>  		    patch.type <= SNDRV_SFNT_PROBE_DATA) <nl>  			rc = snd_soundfont_load(emu->sflist, buf, count, SF_CLIENT_NO(p->chset.port));
@@ -37,6 +37,10 @@ void __init scu_enable(void __iomem *scu_base) <nl>  	u32 scu_ctrl; <nl>   <nl>  	scu_ctrl = __raw_readl(scu_base + SCU_CTRL); <nl> +	/* already enabled? */ <nl> +	if (scu_ctrl & 1) <nl> +		return; <nl> + <nl>  	scu_ctrl |= 1; <nl>  	__raw_writel(scu_ctrl, scu_base + SCU_CTRL); <nl>  
@@ -113,7 +113,8 @@ static int exynos_cpufreq_scale(unsigned int target_freq) <nl>  		if (ret) { <nl>  			pr_err("%s: failed to set cpu voltage to %d\n", <nl>  				__func__, arm_volt); <nl> -			goto out; <nl> +			freqs.new = freqs.old; <nl> +			goto post_notify; <nl>  		} <nl>  	} <nl>   <nl> @@ -123,14 +124,19 @@ static int exynos_cpufreq_scale(unsigned int target_freq) <nl>  		if (ret) { <nl>  			pr_err("%s: failed to set cpu voltage to %d\n", <nl>  				__func__, safe_arm_volt); <nl> -			goto out; <nl> +			freqs.new = freqs.old; <nl> +			goto post_notify; <nl>  		} <nl>  	} <nl>   <nl>  	exynos_info->set_freq(old_index, index); <nl>   <nl> +post_notify: <nl>  	cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE); <nl>   <nl> +	if (ret) <nl> +		goto out; <nl> + <nl>  	/* When the new frequency is lower than current frequency */ <nl>  	if ((freqs.new < freqs.old) || <nl>  	   ((freqs.new > freqs.old) && safe_arm_volt)) {
@@ -1927,7 +1927,9 @@ int sst_hsw_dsp_runtime_resume(struct sst_hsw *hsw) <nl>  	ret = wait_event_timeout(hsw->boot_wait, hsw->boot_complete, <nl>  		msecs_to_jiffies(IPC_BOOT_MSECS)); <nl>  	if (ret == 0) { <nl> -		dev_err(hsw->dev, "error: audio DSP boot timeout\n"); <nl> +		dev_err(hsw->dev, "error: audio DSP boot timeout IPCD 0x%x IPCX 0x%x\n", <nl> +			sst_dsp_shim_read_unlocked(hsw->dsp, SST_IPCD), <nl> +			sst_dsp_shim_read_unlocked(hsw->dsp, SST_IPCX)); <nl>  		return -EIO; <nl>  	} <nl>   <nl> @@ -2038,7 +2040,9 @@ int sst_hsw_dsp_init(struct device *dev, struct sst_pdata *pdata) <nl>  		msecs_to_jiffies(IPC_BOOT_MSECS)); <nl>  	if (ret == 0) { <nl>  		ret = -EIO; <nl> -		dev_err(hsw->dev, "error: ADSP boot timeout\n"); <nl> +		dev_err(hsw->dev, "error: audio DSP boot timeout IPCD 0x%x IPCX 0x%x\n", <nl> +			sst_dsp_shim_read_unlocked(hsw->dsp, SST_IPCD), <nl> +			sst_dsp_shim_read_unlocked(hsw->dsp, SST_IPCX)); <nl>  		goto boot_err; <nl>  	} <nl>  
@@ -2660,6 +2660,7 @@ struct hid_device *hid_allocate_device(void) <nl>  	device_initialize(&hdev->dev); <nl>  	hdev->dev.release = hid_device_release; <nl>  	hdev->dev.bus = &hid_bus_type; <nl> +	device_enable_async_suspend(&hdev->dev); <nl>   <nl>  	hid_close_report(hdev); <nl>  
@@ -1048,6 +1048,15 @@ int arch_dup_task_struct(struct task_struct *dst, struct task_struct *src) <nl>  	flush_altivec_to_thread(src); <nl>  	flush_vsx_to_thread(src); <nl>  	flush_spe_to_thread(src); <nl> +	/* <nl> +	 * Flush TM state out so we can copy it.  __switch_to_tm() does this <nl> +	 * flush but it removes the checkpointed state from the current CPU and <nl> +	 * transitions the CPU out of TM mode.  Hence we need to call <nl> +	 * tm_recheckpoint_new_task() (on the same task) to restore the <nl> +	 * checkpointed state back and the TM mode. <nl> +	 */ <nl> +	__switch_to_tm(src); <nl> +	tm_recheckpoint_new_task(src); <nl>   <nl>  	*dst = *src; <nl>  
@@ -107,8 +107,8 @@ static struct irq_desc *__real_move_irq_desc(struct irq_desc *old_desc, <nl>   <nl>  struct irq_desc *move_irq_desc(struct irq_desc *desc, int node) <nl>  { <nl> -	/* those all static, do move them */ <nl> -	if (desc->irq < NR_IRQS_LEGACY) <nl> +	/* those static or target node is -1, do not move them */ <nl> +	if (desc->irq < NR_IRQS_LEGACY || node == -1) <nl>  		return desc; <nl>   <nl>  	if (desc->node != node)
@@ -182,8 +182,10 @@ static int ntb_netdev_open(struct net_device *ndev) <nl>   <nl>  		rc = ntb_transport_rx_enqueue(dev->qp, skb, skb->data, <nl>  					      ndev->mtu + ETH_HLEN); <nl> -		if (rc == -EINVAL) <nl> +		if (rc == -EINVAL) { <nl> +			dev_kfree_skb(skb); <nl>  			goto err; <nl> +		} <nl>  	} <nl>   <nl>  	netif_carrier_off(ndev);
@@ -388,7 +388,7 @@ static int pulse8_cec_adap_transmit(struct cec_adapter *adap, u8 attempts, <nl>  	int err; <nl>   <nl>  	cmd[0] = MSGCODE_TRANSMIT_IDLETIME; <nl> -	cmd[1] = 3; <nl> +	cmd[1] = signal_free_time; <nl>  	err = pulse8_send_and_wait(pulse8, cmd, 2, <nl>  				   MSGCODE_COMMAND_ACCEPTED, 1); <nl>  	cmd[0] = MSGCODE_TRANSMIT_ACK_POLARITY;
@@ -3711,6 +3711,14 @@ int handle_mm_fault(struct mm_struct *mm, struct vm_area_struct *vma, <nl>  		if (pmd_trans_huge(orig_pmd)) { <nl>  			unsigned int dirty = flags & FAULT_FLAG_WRITE; <nl>   <nl> +			/* <nl> +			 * If the pmd is splitting, return and retry the <nl> +			 * the fault.  Alternative: wait until the split <nl> +			 * is done, and goto retry. <nl> +			 */ <nl> +			if (pmd_trans_splitting(orig_pmd)) <nl> +				return 0; <nl> + <nl>  			if (pmd_numa(orig_pmd)) <nl>  				return do_huge_pmd_numa_page(mm, vma, address, <nl>  							     orig_pmd, pmd);
@@ -50,7 +50,7 @@ int aer_osc_setup(struct pcie_device *pciedev) <nl>  	} <nl>   <nl>  	if (handle) { <nl> -		pci_osc_support_set(OSC_EXT_PCI_CONFIG_SUPPORT); <nl> +		pcie_osc_support_set(OSC_EXT_PCI_CONFIG_SUPPORT); <nl>  		status = pci_osc_control_set(handle, <nl>  					OSC_PCI_EXPRESS_AER_CONTROL | <nl>  					OSC_PCI_EXPRESS_CAP_STRUCTURE_CONTROL);
@@ -93,6 +93,7 @@ static long media_device_enum_entities(struct media_device *mdev, <nl>  	struct media_entity *ent; <nl>  	struct media_entity_desc u_ent; <nl>   <nl> +	memset(&u_ent, 0, sizeof(u_ent)); <nl>  	if (copy_from_user(&u_ent.id, &uent->id, sizeof(u_ent.id))) <nl>  		return -EFAULT; <nl>  
@@ -1636,7 +1636,7 @@ int brcmf_fws_hdrpull(struct brcmf_pub *drvr, int ifidx, s16 signal_len, <nl>  	if (!signal_len) <nl>  		return 0; <nl>  	/* if flow control disabled, skip to packet data and leave */ <nl> -	if (!fws->fw_signals) { <nl> +	if ((!fws) || (!fws->fw_signals)) { <nl>  		skb_pull(skb, signal_len); <nl>  		return 0; <nl>  	}
@@ -931,8 +931,11 @@ static struct dma_async_tx_descriptor *sdma_prep_slave_sg( <nl>   <nl>  		param = BD_DONE | BD_EXTD | BD_CONT; <nl>   <nl> -		if (i + 1 == sg_len) <nl> +		if (i + 1 == sg_len) { <nl>  			param |= BD_INTR; <nl> +			param |= BD_LAST; <nl> +			param &= ~BD_CONT; <nl> +		} <nl>   <nl>  		dev_dbg(sdma->dev, "entry %d: count: %d dma: 0x%08x %s%s\n", <nl>  				i, count, sg->dma_address,
@@ -89,7 +89,7 @@ void ovs_flow_stats_update(struct sw_flow *flow, __be16 tcp_flags, <nl>  			 * allocated stats as we have already locked them. <nl>  			 */ <nl>  			if (likely(flow->stats_last_writer != NUMA_NO_NODE) <nl> -			    && likely(!rcu_dereference(flow->stats[node]))) { <nl> +			    && likely(!rcu_access_pointer(flow->stats[node]))) { <nl>  				/* Try to allocate node-specific stats. */ <nl>  				struct flow_stats *new_stats; <nl>  
@@ -120,7 +120,7 @@ void __init tegra_super_clk_gen4_init(void __iomem *clk_base, <nl>  					ARRAY_SIZE(cclk_lp_parents), <nl>  					CLK_SET_RATE_PARENT, <nl>  					clk_base + CCLKLP_BURST_POLICY, <nl> -					0, 4, 8, 9, NULL); <nl> +					TEGRA_DIVIDER_2, 4, 8, 9, NULL); <nl>  		*dt_clk = clk; <nl>  	} <nl>  
@@ -251,7 +251,7 @@ static inline void dst_hold(struct dst_entry *dst) <nl>  	 * __pad_to_align_refcnt declaration in struct dst_entry <nl>  	 */ <nl>  	BUILD_BUG_ON(offsetof(struct dst_entry, __refcnt) & 63); <nl> -	atomic_inc(&dst->__refcnt); <nl> +	WARN_ON(atomic_inc_not_zero(&dst->__refcnt) == 0); <nl>  } <nl>   <nl>  static inline void dst_use(struct dst_entry *dst, unsigned long time)
@@ -64,6 +64,7 @@ <nl>  void drm_modeset_acquire_init(struct drm_modeset_acquire_ctx *ctx, <nl>  		uint32_t flags) <nl>  { <nl> +	memset(ctx, 0, sizeof(*ctx)); <nl>  	ww_acquire_init(&ctx->ww_ctx, &crtc_ww_class); <nl>  	INIT_LIST_HEAD(&ctx->locked); <nl>  }
@@ -1920,6 +1920,7 @@ int bond_enslave(struct net_device *bond_dev, struct net_device *slave_dev) <nl>  		write_unlock_bh(&bond->curr_slave_lock); <nl>  		read_unlock(&bond->lock); <nl>  	} <nl> +	slave_disable_netpoll(new_slave); <nl>   <nl>  err_close: <nl>  	slave_dev->priv_flags &= ~IFF_BONDING;
@@ -804,7 +804,7 @@ EXPORT_SYMBOL(omap_mcbsp_set_spi_mode); <nl>   * McBSP1 and McBSP3 are directly mapped on 1610 and 1510. <nl>   * 730 has only 2 McBSP, and both of them are MPU peripherals. <nl>   */ <nl> -static int __init omap_mcbsp_probe(struct platform_device *pdev) <nl> +static int __devinit omap_mcbsp_probe(struct platform_device *pdev) <nl>  { <nl>  	struct omap_mcbsp_platform_data *pdata = pdev->dev.platform_data; <nl>  	int id = pdev->id - 1; <nl> @@ -868,7 +868,7 @@ static int __init omap_mcbsp_probe(struct platform_device *pdev) <nl>  	return ret; <nl>  } <nl>   <nl> -static int omap_mcbsp_remove(struct platform_device *pdev) <nl> +static int __devexit omap_mcbsp_remove(struct platform_device *pdev) <nl>  { <nl>  	struct omap_mcbsp *mcbsp = platform_get_drvdata(pdev); <nl>   <nl> @@ -894,7 +894,7 @@ static int omap_mcbsp_remove(struct platform_device *pdev) <nl>   <nl>  static struct platform_driver omap_mcbsp_driver = { <nl>  	.probe		= omap_mcbsp_probe, <nl> -	.remove		= omap_mcbsp_remove, <nl> +	.remove		= __devexit_p(omap_mcbsp_remove), <nl>  	.driver		= { <nl>  		.name	= "omap-mcbsp", <nl>  	},
@@ -2408,7 +2408,13 @@ static int check_alu_op(struct bpf_verifier_env *env, struct bpf_insn *insn) <nl>  			 * remember the value we stored into this reg <nl>  			 */ <nl>  			regs[insn->dst_reg].type = SCALAR_VALUE; <nl> -			__mark_reg_known(regs + insn->dst_reg, insn->imm); <nl> +			if (BPF_CLASS(insn->code) == BPF_ALU64) { <nl> +				__mark_reg_known(regs + insn->dst_reg, <nl> +						 insn->imm); <nl> +			} else { <nl> +				__mark_reg_known(regs + insn->dst_reg, <nl> +						 (u32)insn->imm); <nl> +			} <nl>  		} <nl>   <nl>  	} else if (opcode > BPF_END) {
@@ -225,6 +225,9 @@ static int64_t _sort__sym_cmp(struct symbol *sym_l, struct symbol *sym_r) <nl>  	if (sym_l == sym_r) <nl>  		return 0; <nl>   <nl> +	if (sym_l->inlined || sym_r->inlined) <nl> +		return strcmp(sym_l->name, sym_r->name); <nl> + <nl>  	if (sym_l->start != sym_r->start) <nl>  		return (int64_t)(sym_r->start - sym_l->start); <nl>  
@@ -595,15 +595,15 @@ int g_audio_setup(struct g_audio *g_audio, const char *pcm_name, <nl>  	if (err < 0) <nl>  		goto snd_fail; <nl>   <nl> -	strcpy(pcm->name, pcm_name); <nl> +	strlcpy(pcm->name, pcm_name, sizeof(pcm->name)); <nl>  	pcm->private_data = uac; <nl>  	uac->pcm = pcm; <nl>   <nl>  	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &uac_pcm_ops); <nl>  	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &uac_pcm_ops); <nl>   <nl> -	strcpy(card->driver, card_name); <nl> -	strcpy(card->shortname, card_name); <nl> +	strlcpy(card->driver, card_name, sizeof(card->driver)); <nl> +	strlcpy(card->shortname, card_name, sizeof(card->shortname)); <nl>  	sprintf(card->longname, "%s %i", card_name, card->dev->id); <nl>   <nl>  	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_CONTINUOUS,
@@ -208,7 +208,7 @@ long sys_pciconfig_iobase(long which, unsigned long in_bus, <nl>  			  unsigned long in_devfn) <nl>  { <nl>  	struct pci_controller* hose; <nl> -	struct pci_bus *bus = NULL; <nl> +	struct pci_bus *tmp_bus, *bus = NULL; <nl>  	struct device_node *hose_node; <nl>   <nl>  	/* Argh ! Please forgive me for that hack, but that's the <nl> @@ -229,10 +229,12 @@ long sys_pciconfig_iobase(long which, unsigned long in_bus, <nl>  	 * used on pre-domains setup. We return the first match <nl>  	 */ <nl>   <nl> -	list_for_each_entry(bus, &pci_root_buses, node) { <nl> -		if (in_bus >= bus->number && in_bus <= bus->busn_res.end) <nl> +	list_for_each_entry(tmp_bus, &pci_root_buses, node) { <nl> +		if (in_bus >= tmp_bus->number && <nl> +		    in_bus <= tmp_bus->busn_res.end) { <nl> +			bus = tmp_bus; <nl>  			break; <nl> -		bus = NULL; <nl> +		} <nl>  	} <nl>  	if (bus == NULL || bus->dev.of_node == NULL) <nl>  		return -ENODEV;
@@ -1759,6 +1759,7 @@ static int did_overwrite_first_ref(struct send_ctx *sctx, u64 ino, u64 gen) <nl>   * Insert a name cache entry. On 32bit kernels the radix tree index is 32bit, <nl>   * so we need to do some special handling in case we have clashes. This function <nl>   * takes care of this with the help of name_cache_entry::radix_list. <nl> + * In case of error, nce is kfreed. <nl>   */ <nl>  static int name_cache_insert(struct send_ctx *sctx, <nl>  			     struct name_cache_entry *nce) <nl> @@ -1775,8 +1776,11 @@ static int name_cache_insert(struct send_ctx *sctx, <nl>  		INIT_LIST_HEAD(nce_head); <nl>   <nl>  		ret = radix_tree_insert(&sctx->name_cache, nce->ino, nce_head); <nl> -		if (ret < 0) <nl> +		if (ret < 0) { <nl> +			kfree(nce_head); <nl> +			kfree(nce); <nl>  			return ret; <nl> +		} <nl>  	} <nl>  	list_add_tail(&nce->radix_list, nce_head); <nl>  	list_add_tail(&nce->list, &sctx->name_cache_list);
@@ -62,8 +62,10 @@ static int __cpu_find_by(int (*compare)(int, int, void *), void *compare_arg, <nl>  		int err = check_cpu_node(dp->node, &cur_inst, <nl>  					 compare, compare_arg, <nl>  					 prom_node, mid); <nl> -		if (!err) <nl> +		if (!err) { <nl> +			of_node_put(dp); <nl>  			return 0; <nl> +		} <nl>  	} <nl>   <nl>  	return -ENODEV;
@@ -451,7 +451,6 @@ static void acpi_processor_remove(struct acpi_device *device) <nl>  	/* Clean up. */ <nl>  	per_cpu(processor_device_array, pr->id) = NULL; <nl>  	per_cpu(processors, pr->id) = NULL; <nl> -	try_offline_node(cpu_to_node(pr->id)); <nl>   <nl>  	/* Remove the CPU. */ <nl>  	get_online_cpus(); <nl> @@ -459,6 +458,8 @@ static void acpi_processor_remove(struct acpi_device *device) <nl>  	acpi_unmap_lsapic(pr->id); <nl>  	put_online_cpus(); <nl>   <nl> +	try_offline_node(cpu_to_node(pr->id)); <nl> + <nl>   out: <nl>  	free_cpumask_var(pr->throttling.shared_cpu_map); <nl>  	kfree(pr);
@@ -881,6 +881,9 @@ static void execlists_submission_tasklet(unsigned long data) <nl>  				trace_i915_request_out(rq); <nl>  				i915_request_put(rq); <nl>   <nl> +				GEM_TRACE("%s completed ctx=%d\n", <nl> +					  engine->name, port->context_id); <nl> + <nl>  				execlists_port_complete(execlists, port); <nl>  			} else { <nl>  				port_set(port, port_pack(rq, count));
@@ -1607,7 +1607,7 @@ static int create_qp_common(struct mlx5_ib_dev *dev, struct ib_pd *pd, <nl>  	struct mlx5_ib_resources *devr = &dev->devr; <nl>  	int inlen = MLX5_ST_SZ_BYTES(create_qp_in); <nl>  	struct mlx5_core_dev *mdev = dev->mdev; <nl> -	struct mlx5_ib_create_qp_resp resp; <nl> +	struct mlx5_ib_create_qp_resp resp = {}; <nl>  	struct mlx5_ib_cq *send_cq; <nl>  	struct mlx5_ib_cq *recv_cq; <nl>  	unsigned long flags;
@@ -599,11 +599,10 @@ static inline int pmd_none_or_trans_huge_or_clear_bad(pmd_t *pmd) <nl>  #ifdef CONFIG_TRANSPARENT_HUGEPAGE <nl>  	barrier(); <nl>  #endif <nl> -	if (pmd_none(pmdval)) <nl> +	if (pmd_none(pmdval) || pmd_trans_huge(pmdval)) <nl>  		return 1; <nl>  	if (unlikely(pmd_bad(pmdval))) { <nl> -		if (!pmd_trans_huge(pmdval)) <nl> -			pmd_clear_bad(pmd); <nl> +		pmd_clear_bad(pmd); <nl>  		return 1; <nl>  	} <nl>  	return 0;
@@ -305,6 +305,8 @@ static struct sk_buff *codel_dequeue(struct Qdisc *sch, <nl>  			} <nl>  		} <nl>  	} else if (drop) { <nl> +		u32 delta; <nl> + <nl>  		if (params->ecn && INET_ECN_set_ce(skb)) { <nl>  			stats->ecn_mark++; <nl>  		} else { <nl> @@ -320,9 +322,11 @@ static struct sk_buff *codel_dequeue(struct Qdisc *sch, <nl>  		 * assume that the drop rate that controlled the queue on the <nl>  		 * last cycle is a good starting point to control it now. <nl>  		 */ <nl> -		if (codel_time_before(now - vars->drop_next, <nl> +		delta = vars->count - vars->lastcount; <nl> +		if (delta > 1 && <nl> +		    codel_time_before(now - vars->drop_next, <nl>  				      16 * params->interval)) { <nl> -			vars->count = (vars->count - vars->lastcount) | 1; <nl> +			vars->count = delta; <nl>  			/* we dont care if rec_inv_sqrt approximation <nl>  			 * is not very precise : <nl>  			 * Next Newton steps will correct it quadratically.
@@ -146,6 +146,7 @@ static int doc_ecc_decode(struct rs_control *rs, uint8_t *data, uint8_t *ecc) <nl>  	uint8_t parity; <nl>  	uint16_t ds[4], s[5], tmp, errval[8], syn[4]; <nl>   <nl> +	memset(syn, 0, sizeof(syn)); <nl>  	/* Convert the ecc bytes into words */ <nl>  	ds[0] = ((ecc[4] & 0xff) >> 0) | ((ecc[5] & 0x03) << 8); <nl>  	ds[1] = ((ecc[5] & 0xfc) >> 2) | ((ecc[2] & 0x0f) << 6); <nl> @@ -169,9 +170,9 @@ static int doc_ecc_decode(struct rs_control *rs, uint8_t *data, uint8_t *ecc) <nl>  			s[i] ^= rs->alpha_to[rs_modnn(rs, tmp + (FCR + i) * j)]; <nl>  	} <nl>   <nl> -	/* Calc s[i] = s[i] / alpha^(v + i) */ <nl> +	/* Calc syn[i] = s[i] / alpha^(v + i) */ <nl>  	for (i = 0; i < NROOTS; i++) { <nl> -		if (syn[i]) <nl> +		if (s[i]) <nl>  			syn[i] = rs_modnn(rs, rs->index_of[s[i]] + (NN - FCR - i)); <nl>  	} <nl>  	/* Call the decoder library */
@@ -140,9 +140,7 @@ static inline int init_new_context(struct task_struct *tsk, <nl>  		mm->context.execute_only_pkey = -1; <nl>  	} <nl>  	#endif <nl> -	init_new_context_ldt(tsk, mm); <nl> - <nl> -	return 0; <nl> +	return init_new_context_ldt(tsk, mm); <nl>  } <nl>  static inline void destroy_context(struct mm_struct *mm) <nl>  {
@@ -2170,8 +2170,7 @@ intel_sdvo_tv_init(struct intel_sdvo *intel_sdvo, int type) <nl>          return true; <nl>   <nl>  err: <nl> -	intel_sdvo_destroy_enhance_property(connector); <nl> -	kfree(intel_sdvo_connector); <nl> +	intel_sdvo_destroy(connector); <nl>  	return false; <nl>  } <nl>   <nl> @@ -2243,8 +2242,7 @@ intel_sdvo_lvds_init(struct intel_sdvo *intel_sdvo, int device) <nl>  	return true; <nl>   <nl>  err: <nl> -	intel_sdvo_destroy_enhance_property(connector); <nl> -	kfree(intel_sdvo_connector); <nl> +	intel_sdvo_destroy(connector); <nl>  	return false; <nl>  } <nl>  
@@ -512,7 +512,7 @@ static int pinconf_dbg_config_write(struct file *file, <nl>  	int i; <nl>   <nl>  	/* Get userspace string and assure termination */ <nl> -	buf_size = min(count, (sizeof(buf)-1)); <nl> +	buf_size = min(count, (size_t)(sizeof(buf)-1)); <nl>  	if (copy_from_user(buf, user_buf, buf_size)) <nl>  		return -EFAULT; <nl>  	buf[buf_size] = 0;
@@ -2641,6 +2641,8 @@ static int nf_tables_getset(struct net *net, struct sock *nlsk, <nl>  	/* Only accept unspec with dump */ <nl>  	if (nfmsg->nfgen_family == NFPROTO_UNSPEC) <nl>  		return -EAFNOSUPPORT; <nl> +	if (!nla[NFTA_SET_TABLE]) <nl> +		return -EINVAL; <nl>   <nl>  	set = nf_tables_set_lookup(ctx.table, nla[NFTA_SET_NAME]); <nl>  	if (IS_ERR(set))
@@ -1782,6 +1782,7 @@ enum { <nl>  	ALC889_FIXUP_IMAC91_VREF, <nl>  	ALC882_FIXUP_INV_DMIC, <nl>  	ALC882_FIXUP_NO_PRIMARY_HP, <nl> +	ALC887_FIXUP_ASUS_BASS, <nl>  }; <nl>   <nl>  static void alc889_fixup_coef(struct hda_codec *codec, <nl> @@ -2105,6 +2106,13 @@ static const struct hda_fixup alc882_fixups[] = { <nl>  		.type = HDA_FIXUP_FUNC, <nl>  		.v.func = alc882_fixup_no_primary_hp, <nl>  	}, <nl> +	[ALC887_FIXUP_ASUS_BASS] = { <nl> +		.type = HDA_FIXUP_PINS, <nl> +		.v.pins = (const struct hda_pintbl[]) { <nl> +			{0x16, 0x99130130}, /* bass speaker */ <nl> +			{} <nl> +		}, <nl> +	}, <nl>  }; <nl>   <nl>  static const struct snd_pci_quirk alc882_fixup_tbl[] = { <nl> @@ -2138,6 +2146,7 @@ static const struct snd_pci_quirk alc882_fixup_tbl[] = { <nl>  	SND_PCI_QUIRK(0x1043, 0x1873, "ASUS W90V", ALC882_FIXUP_ASUS_W90V), <nl>  	SND_PCI_QUIRK(0x1043, 0x1971, "Asus W2JC", ALC882_FIXUP_ASUS_W2JC), <nl>  	SND_PCI_QUIRK(0x1043, 0x835f, "Asus Eee 1601", ALC888_FIXUP_EEE1601), <nl> +	SND_PCI_QUIRK(0x1043, 0x84bc, "ASUS ET2700", ALC887_FIXUP_ASUS_BASS), <nl>  	SND_PCI_QUIRK(0x104d, 0x9047, "Sony Vaio TT", ALC889_FIXUP_VAIO_TT), <nl>  	SND_PCI_QUIRK(0x104d, 0x905a, "Sony Vaio Z", ALC882_FIXUP_NO_PRIMARY_HP), <nl>  	SND_PCI_QUIRK(0x104d, 0x9043, "Sony Vaio VGC-LN51JGB", ALC882_FIXUP_NO_PRIMARY_HP),
@@ -813,10 +813,9 @@ static void __br_multicast_send_query(struct net_bridge *br, <nl>  		return; <nl>   <nl>  	if (port) { <nl> -		__skb_push(skb, sizeof(struct ethhdr)); <nl>  		skb->dev = port->dev; <nl>  		NF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_OUT, skb, NULL, skb->dev, <nl> -			dev_queue_xmit); <nl> +			br_dev_queue_push_xmit); <nl>  	} else { <nl>  		br_multicast_select_own_querier(br, ip, skb); <nl>  		netif_rx(skb);
@@ -1373,6 +1373,9 @@ static void cache_set_flush(struct closure *cl) <nl>  	struct btree *b; <nl>  	unsigned i; <nl>   <nl> +	if (!c) <nl> +		closure_return(cl); <nl> + <nl>  	bch_cache_accounting_destroy(&c->accounting); <nl>   <nl>  	kobject_put(&c->internal);
@@ -556,7 +556,9 @@ void intel_lrc_irq_handler(struct intel_engine_cs *ring) <nl>   <nl>  	spin_unlock(&ring->execlist_lock); <nl>   <nl> -	WARN(submit_contexts > 2, "More than two context complete events?\n"); <nl> +	if (unlikely(submit_contexts > 2)) <nl> +		DRM_ERROR("More than two context complete events?\n"); <nl> + <nl>  	ring->next_context_status_buffer = write_pointer % GEN8_CSB_ENTRIES; <nl>   <nl>  	/* Update the read pointer to the old write pointer. Manual ringbuffer
@@ -694,6 +694,7 @@ static int hci_sock_getname(struct socket *sock, struct sockaddr *addr, <nl>  	*addr_len = sizeof(*haddr); <nl>  	haddr->hci_family = AF_BLUETOOTH; <nl>  	haddr->hci_dev    = hdev->id; <nl> +	haddr->hci_channel= 0; <nl>   <nl>  	release_sock(sk); <nl>  	return 0;
@@ -52,9 +52,10 @@ static struct drbd_request *drbd_req_new(struct drbd_device *device, <nl>  { <nl>  	struct drbd_request *req; <nl>   <nl> -	req = mempool_alloc(drbd_request_mempool, GFP_NOIO | __GFP_ZERO); <nl> +	req = mempool_alloc(drbd_request_mempool, GFP_NOIO); <nl>  	if (!req) <nl>  		return NULL; <nl> +	memset(req, 0, sizeof(*req)); <nl>   <nl>  	drbd_req_make_private_bio(req, bio_src); <nl>  	req->rq_state    = bio_data_dir(bio_src) == WRITE ? RQ_WRITE : 0;
@@ -111,6 +111,9 @@ xfs_qm_dquot_walk( <nl>  			skipped = 0; <nl>  			break; <nl>  		} <nl> +		/* we're done if id overflows back to zero */ <nl> +		if (!next_index) <nl> +			break; <nl>  	} <nl>   <nl>  	if (skipped) {
@@ -536,7 +536,7 @@ static bool is_fullscreen(struct drm_crtc_state *cstate, <nl>  		((pstate->crtc_y + pstate->crtc_h) >= cstate->mode.vdisplay); <nl>  } <nl>   <nl> -enum mdp_mixer_stage_id get_start_stage(struct drm_crtc *crtc, <nl> +static enum mdp_mixer_stage_id get_start_stage(struct drm_crtc *crtc, <nl>  					struct drm_crtc_state *new_crtc_state, <nl>  					struct drm_plane_state *bpstate) <nl>  {
@@ -1304,7 +1304,7 @@ static void atmci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios) <nl>   <nl>  	if (ios->clock) { <nl>  		unsigned int clock_min = ~0U; <nl> -		u32 clkdiv; <nl> +		int clkdiv; <nl>   <nl>  		spin_lock_bh(&host->lock); <nl>  		if (!host->mode_reg) { <nl> @@ -1328,7 +1328,12 @@ static void atmci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios) <nl>  		/* Calculate clock divider */ <nl>  		if (host->caps.has_odd_clk_div) { <nl>  			clkdiv = DIV_ROUND_UP(host->bus_hz, clock_min) - 2; <nl> -			if (clkdiv > 511) { <nl> +			if (clkdiv < 0) { <nl> +				dev_warn(&mmc->class_dev, <nl> +					 "clock %u too fast; using %lu\n", <nl> +					 clock_min, host->bus_hz / 2); <nl> +				clkdiv = 0; <nl> +			} else if (clkdiv > 511) { <nl>  				dev_warn(&mmc->class_dev, <nl>  				         "clock %u too slow; using %lu\n", <nl>  				         clock_min, host->bus_hz / (511 + 2));
@@ -1179,6 +1179,9 @@ static int acm_probe(struct usb_interface *intf, <nl>  	if (quirks == NO_UNION_NORMAL) { <nl>  		data_interface = usb_ifnum_to_if(usb_dev, 1); <nl>  		control_interface = usb_ifnum_to_if(usb_dev, 0); <nl> +		/* we would crash */ <nl> +		if (!data_interface || !control_interface) <nl> +			return -ENODEV; <nl>  		goto skip_normal_probe; <nl>  	} <nl>  
@@ -884,11 +884,17 @@ bool smp_sufficient_security(struct hci_conn *hcon, u8 sec_level) <nl>  int smp_conn_security(struct hci_conn *hcon, __u8 sec_level) <nl>  { <nl>  	struct l2cap_conn *conn = hcon->l2cap_data; <nl> -	struct smp_chan *smp = conn->smp_chan; <nl> +	struct smp_chan *smp; <nl>  	__u8 authreq; <nl>   <nl>  	BT_DBG("conn %p hcon %p level 0x%2.2x", conn, hcon, sec_level); <nl>   <nl> +	/* This may be NULL if there's an unexpected disconnection */ <nl> +	if (!conn) <nl> +		return 1; <nl> + <nl> +	smp = conn->smp_chan; <nl> + <nl>  	if (!test_bit(HCI_LE_ENABLED, &hcon->hdev->dev_flags)) <nl>  		return 1; <nl>  
@@ -516,6 +516,13 @@ static void do_fault(struct work_struct *work) <nl>  		goto out; <nl>  	} <nl>   <nl> +	if (!(vma->vm_flags & (VM_READ | VM_EXEC | VM_WRITE))) { <nl> +		/* handle_mm_fault would BUG_ON() */ <nl> +		up_read(&mm->mmap_sem); <nl> +		handle_fault_error(fault); <nl> +		goto out; <nl> +	} <nl> + <nl>  	ret = handle_mm_fault(mm, vma, address, write); <nl>  	if (ret & VM_FAULT_ERROR) { <nl>  		/* failed to service fault */
@@ -696,8 +696,10 @@ static netdev_tx_t reg_vif_xmit(struct sk_buff *skb, <nl>  	int err; <nl>   <nl>  	err = ip6mr_fib_lookup(net, &fl6, &mrt); <nl> -	if (err < 0) <nl> +	if (err < 0) { <nl> +		kfree_skb(skb); <nl>  		return err; <nl> +	} <nl>   <nl>  	read_lock(&mrt_lock); <nl>  	dev->stats.tx_bytes += skb->len;
@@ -186,6 +186,7 @@ static int usb_console_setup(struct console *co, char *options) <nl>  	tty_kref_put(tty); <nl>   reset_open_count: <nl>  	port->port.count = 0; <nl> +	info->port = NULL; <nl>  	usb_autopm_put_interface(serial->interface); <nl>   error_get_interface: <nl>  	usb_serial_put(serial);
@@ -284,11 +284,11 @@ int snd_timer_open(struct snd_timer_instance **ti, <nl>  		goto unlock; <nl>  	} <nl>  	if (!list_empty(&timer->open_list_head)) { <nl> -		timeri = list_entry(timer->open_list_head.next, <nl> +		struct snd_timer_instance *t = <nl> +			list_entry(timer->open_list_head.next, <nl>  				    struct snd_timer_instance, open_list); <nl> -		if (timeri->flags & SNDRV_TIMER_IFLG_EXCLUSIVE) { <nl> +		if (t->flags & SNDRV_TIMER_IFLG_EXCLUSIVE) { <nl>  			err = -EBUSY; <nl> -			timeri = NULL; <nl>  			goto unlock; <nl>  		} <nl>  	}
@@ -467,6 +467,9 @@ static int pit_ioport_read(struct kvm_io_device *this, <nl>  		return -EOPNOTSUPP; <nl>   <nl>  	addr &= KVM_PIT_CHANNEL_MASK; <nl> +	if (addr == 3) <nl> +		return 0; <nl> + <nl>  	s = &pit_state->channels[addr]; <nl>   <nl>  	mutex_lock(&pit_state->lock);
@@ -41,7 +41,7 @@ unx_create(struct rpc_clnt *clnt, rpc_authflavor_t flavor) <nl>  { <nl>  	dprintk("RPC:       creating UNIX authenticator for client %p\n", <nl>  			clnt); <nl> -	if (atomic_inc_return(&unix_auth.au_count) == 0) <nl> +	if (atomic_inc_return(&unix_auth.au_count) == 1) <nl>  		unix_cred_cache.nextgc = jiffies + (unix_cred_cache.expire >> 1); <nl>  	return &unix_auth; <nl>  }
@@ -4348,11 +4348,10 @@ static int b43_wireless_core_init(struct b43_wldev *dev) <nl>  	b43_set_phytxctl_defaults(dev); <nl>   <nl>  	/* Minimum Contention Window */ <nl> -	if (phy->type == B43_PHYTYPE_B) { <nl> +	if (phy->type == B43_PHYTYPE_B) <nl>  		b43_shm_write16(dev, B43_SHM_SCRATCH, B43_SHM_SC_MINCONT, 0x1F); <nl> -	} else { <nl> +	else <nl>  		b43_shm_write16(dev, B43_SHM_SCRATCH, B43_SHM_SC_MINCONT, 0xF); <nl> -	} <nl>  	/* Maximum Contention Window */ <nl>  	b43_shm_write16(dev, B43_SHM_SCRATCH, B43_SHM_SC_MAXCONT, 0x3FF); <nl>  
@@ -1338,6 +1338,7 @@ static int pid_revalidate(struct dentry *dentry, struct nameidata *nd) <nl>  		} else { <nl>  			inode->i_uid = 0; <nl>  			inode->i_gid = 0; <nl> +			inode->i_mode = 0; <nl>  		} <nl>  		security_task_to_inode(task, inode); <nl>  		put_task_struct(task);
@@ -313,7 +313,7 @@ static void ftrace_syscall_enter(void *data, struct pt_regs *regs, long id) <nl>  	int size; <nl>   <nl>  	syscall_nr = trace_get_syscall_nr(current, regs); <nl> -	if (syscall_nr < 0) <nl> +	if (syscall_nr < 0 || syscall_nr >= NR_syscalls) <nl>  		return; <nl>   <nl>  	/* Here we're inside tp handler's rcu_read_lock_sched (__DO_TRACE) */ <nl> @@ -360,7 +360,7 @@ static void ftrace_syscall_exit(void *data, struct pt_regs *regs, long ret) <nl>  	int syscall_nr; <nl>   <nl>  	syscall_nr = trace_get_syscall_nr(current, regs); <nl> -	if (syscall_nr < 0) <nl> +	if (syscall_nr < 0 || syscall_nr >= NR_syscalls) <nl>  		return; <nl>   <nl>  	/* Here we're inside tp handler's rcu_read_lock_sched (__DO_TRACE()) */ <nl> @@ -567,7 +567,7 @@ static void perf_syscall_enter(void *ignore, struct pt_regs *regs, long id) <nl>  	int size; <nl>   <nl>  	syscall_nr = trace_get_syscall_nr(current, regs); <nl> -	if (syscall_nr < 0) <nl> +	if (syscall_nr < 0 || syscall_nr >= NR_syscalls) <nl>  		return; <nl>  	if (!test_bit(syscall_nr, enabled_perf_enter_syscalls)) <nl>  		return; <nl> @@ -641,7 +641,7 @@ static void perf_syscall_exit(void *ignore, struct pt_regs *regs, long ret) <nl>  	int size; <nl>   <nl>  	syscall_nr = trace_get_syscall_nr(current, regs); <nl> -	if (syscall_nr < 0) <nl> +	if (syscall_nr < 0 || syscall_nr >= NR_syscalls) <nl>  		return; <nl>  	if (!test_bit(syscall_nr, enabled_perf_exit_syscalls)) <nl>  		return;
@@ -1033,6 +1033,12 @@ void ieee80211_sta_rx_notify(struct ieee80211_sub_if_data *sdata, <nl>  	if (is_multicast_ether_addr(hdr->addr1)) <nl>  		return; <nl>   <nl> +	/* <nl> +	 * In case we receive frames after disassociation. <nl> +	 */ <nl> +	if (!sdata->u.mgd.associated) <nl> +		return; <nl> + <nl>  	ieee80211_sta_reset_conn_monitor(sdata); <nl>  } <nl>  
@@ -501,9 +501,8 @@ static int __devinit twl6040_probe(struct platform_device *pdev) <nl>  	if (pdata->codec) { <nl>  		cell = &twl6040->cells[children]; <nl>  		cell->name = "twl6040-codec"; <nl> -		/* The codec expects the twl4030_audio_data as platform data */ <nl> -		cell->platform_data = pdata; <nl> -		cell->pdata_size = sizeof(*pdata); <nl> +		cell->platform_data = pdata->codec; <nl> +		cell->pdata_size = sizeof(*pdata->codec); <nl>  		children++; <nl>  	} <nl>  
@@ -1515,6 +1515,7 @@ isdn_ioctl(struct inode *inode, struct file *file, uint cmd, ulong arg) <nl>  					if (copy_from_user(&iocts, argp, <nl>  					     sizeof(isdn_ioctl_struct))) <nl>  						return -EFAULT; <nl> +					iocts.drvid[sizeof(iocts.drvid)-1] = 0; <nl>  					if (strlen(iocts.drvid)) { <nl>  						if ((p = strchr(iocts.drvid, ','))) <nl>  							*p = 0; <nl> @@ -1599,6 +1600,7 @@ isdn_ioctl(struct inode *inode, struct file *file, uint cmd, ulong arg) <nl>  					if (copy_from_user(&iocts, argp, <nl>  					     sizeof(isdn_ioctl_struct))) <nl>  						return -EFAULT; <nl> +					iocts.drvid[sizeof(iocts.drvid)-1] = 0; <nl>  					if (strlen(iocts.drvid)) { <nl>  						drvidx = -1; <nl>  						for (i = 0; i < ISDN_MAX_DRIVERS; i++) <nl> @@ -1643,7 +1645,7 @@ isdn_ioctl(struct inode *inode, struct file *file, uint cmd, ulong arg) <nl>  					} else { <nl>  						p = (char __user *) iocts.arg; <nl>  						for (i = 0; i < 10; i++) { <nl> -							sprintf(bname, "%s%s", <nl> +							snprintf(bname, sizeof(bname), "%s%s", <nl>  								strlen(dev->drv[drvidx]->msn2eaz[i]) ? <nl>  								dev->drv[drvidx]->msn2eaz[i] : "_", <nl>  								(i < 9) ? "," : "\0"); <nl> @@ -1673,6 +1675,7 @@ isdn_ioctl(struct inode *inode, struct file *file, uint cmd, ulong arg) <nl>  					char *p; <nl>  					if (copy_from_user(&iocts, argp, sizeof(isdn_ioctl_struct))) <nl>  						return -EFAULT; <nl> +					iocts.drvid[sizeof(iocts.drvid)-1] = 0; <nl>  					if (strlen(iocts.drvid)) { <nl>  						if ((p = strchr(iocts.drvid, ','))) <nl>  							*p = 0;
@@ -1198,6 +1198,9 @@ static inline int _loop(unsigned dry_run, u8 buf[], <nl>  	unsigned lcnt0, lcnt1, ljmp0, ljmp1; <nl>  	struct _arg_LPEND lpend; <nl>   <nl> +	if (*bursts == 1) <nl> +		return _bursts(dry_run, buf, pxs, 1); <nl> + <nl>  	/* Max iterations possible in DMALP is 256 */ <nl>  	if (*bursts >= 256*256) { <nl>  		lcnt1 = 256;
@@ -152,8 +152,10 @@ static ssize_t sof_dfsentry_write(struct file *file, const char __user *buffer, <nl>  	 */ <nl>  	dentry = file->f_path.dentry; <nl>  	if (strcmp(dentry->d_name.name, "ipc_flood_count") && <nl> -	    strcmp(dentry->d_name.name, "ipc_flood_duration_ms")) <nl> -		return -EINVAL; <nl> +	    strcmp(dentry->d_name.name, "ipc_flood_duration_ms")) { <nl> +		ret = -EINVAL; <nl> +		goto out; <nl> +	} <nl>   <nl>  	if (!strcmp(dentry->d_name.name, "ipc_flood_duration_ms")) <nl>  		flood_duration_test = true;
@@ -5653,6 +5653,9 @@ static int sctp_getsockopt_assoc_stats(struct sock *sk, int len, <nl>  	if (len < sizeof(sctp_assoc_t)) <nl>  		return -EINVAL; <nl>   <nl> +	/* Allow the struct to grow and fill in as much as possible */ <nl> +	len = min_t(size_t, len, sizeof(sas)); <nl> + <nl>  	if (copy_from_user(&sas, optval, len)) <nl>  		return -EFAULT; <nl>   <nl> @@ -5686,9 +5689,6 @@ static int sctp_getsockopt_assoc_stats(struct sock *sk, int len, <nl>  	/* Mark beginning of a new observation period */ <nl>  	asoc->stats.max_obs_rto = asoc->rto_min; <nl>   <nl> -	/* Allow the struct to grow and fill in as much as possible */ <nl> -	len = min_t(size_t, len, sizeof(sas)); <nl> - <nl>  	if (put_user(len, optlen)) <nl>  		return -EFAULT; <nl>  
@@ -285,6 +285,9 @@ int iio_buffer_register(struct iio_dev *indio_dev, <nl>  	if (channels) { <nl>  		/* new magic */ <nl>  		for (i = 0; i < num_channels; i++) { <nl> +			if (channels[i].scan_index < 0) <nl> +				continue; <nl> + <nl>  			/* Establish necessary mask length */ <nl>  			if (channels[i].scan_index > <nl>  			    (int)indio_dev->masklength - 1)
@@ -3937,8 +3937,13 @@ static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t bu <nl>  		goto out_free; <nl>  	} <nl>  	nfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len); <nl> -	if (buf) <nl> +	if (buf) { <nl> +		if (res.acl_len > buflen) { <nl> +			ret = -ERANGE; <nl> +			goto out_free; <nl> +		} <nl>  		_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len); <nl> +	} <nl>  out_ok: <nl>  	ret = res.acl_len; <nl>  out_free:
@@ -134,10 +134,16 @@ struct scsi_cmnd { <nl>   <nl>  static inline struct scsi_driver *scsi_cmd_to_driver(struct scsi_cmnd *cmd) <nl>  { <nl> +	struct scsi_driver **sdp; <nl> + <nl>  	if (!cmd->request->rq_disk) <nl>  		return NULL; <nl>   <nl> -	return *(struct scsi_driver **)cmd->request->rq_disk->private_data; <nl> +	sdp = (struct scsi_driver **)cmd->request->rq_disk->private_data; <nl> +	if (!sdp) <nl> +		return NULL; <nl> + <nl> +	return *sdp; <nl>  } <nl>   <nl>  extern struct scsi_cmnd *scsi_get_command(struct scsi_device *, gfp_t);
@@ -37,7 +37,7 @@ <nl>  #ifndef HPSB_DEBUG_TLABELS <nl>  static <nl>  #endif <nl> -spinlock_t hpsb_tlabel_lock = SPIN_LOCK_UNLOCKED; <nl> +DEFINE_SPINLOCK(hpsb_tlabel_lock); <nl>   <nl>  static DECLARE_WAIT_QUEUE_HEAD(tlabel_wq); <nl>  
@@ -1910,7 +1910,8 @@ bool wb_over_bg_thresh(struct bdi_writeback *wb) <nl>  	if (gdtc->dirty > gdtc->bg_thresh) <nl>  		return true; <nl>   <nl> -	if (wb_stat(wb, WB_RECLAIMABLE) > __wb_calc_thresh(gdtc)) <nl> +	if (wb_stat(wb, WB_RECLAIMABLE) > <nl> +	    wb_calc_thresh(gdtc->wb, gdtc->bg_thresh)) <nl>  		return true; <nl>   <nl>  	if (mdtc) { <nl> @@ -1924,7 +1925,8 @@ bool wb_over_bg_thresh(struct bdi_writeback *wb) <nl>  		if (mdtc->dirty > mdtc->bg_thresh) <nl>  			return true; <nl>   <nl> -		if (wb_stat(wb, WB_RECLAIMABLE) > __wb_calc_thresh(mdtc)) <nl> +		if (wb_stat(wb, WB_RECLAIMABLE) > <nl> +		    wb_calc_thresh(mdtc->wb, mdtc->bg_thresh)) <nl>  			return true; <nl>  	} <nl>  
@@ -172,6 +172,11 @@ int jffs2_reserve_space_gc(struct jffs2_sb_info *c, uint32_t minsize, <nl>  static void jffs2_close_nextblock(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb) <nl>  { <nl>   <nl> +	if (c->nextblock == NULL) { <nl> +		D1(printk(KERN_DEBUG "jffs2_close_nextblock: Erase block at 0x%08x has already been placed in a list\n", <nl> +		  jeb->offset)); <nl> +		return; <nl> +	} <nl>  	/* Check, if we have a dirty block now, or if it was dirty already */ <nl>  	if (ISDIRTY (jeb->wasted_size + jeb->dirty_size)) { <nl>  		c->dirty_size += jeb->wasted_size;
@@ -953,7 +953,7 @@ static int ov7740_init_controls(struct ov7740 *ov7740) <nl>  	struct v4l2_ctrl_handler *ctrl_hdlr = &ov7740->ctrl_handler; <nl>  	int ret; <nl>   <nl> -	ret = v4l2_ctrl_handler_init(ctrl_hdlr, 2); <nl> +	ret = v4l2_ctrl_handler_init(ctrl_hdlr, 12); <nl>  	if (ret < 0) <nl>  		return ret; <nl>  
@@ -399,6 +399,10 @@ static int ethoc_rx(struct net_device *dev, int limit) <nl>  		if (ethoc_update_rx_stats(priv, &bd) == 0) { <nl>  			int size = bd.stat >> 16; <nl>  			struct sk_buff *skb = netdev_alloc_skb(dev, size); <nl> + <nl> +			size -= 4; /* strip the CRC */ <nl> +			skb_reserve(skb, 2); /* align TCP/IP header */ <nl> + <nl>  			if (likely(skb)) { <nl>  				void *src = phys_to_virt(bd.addr); <nl>  				memcpy_fromio(skb_put(skb, size), src, size);
@@ -33,6 +33,11 @@ <nl>  static void bat_iv_ogm_iface_enable(struct hard_iface *hard_iface) <nl>  { <nl>  	struct batman_ogm_packet *batman_ogm_packet; <nl> +	uint32_t random_seqno; <nl> + <nl> +	/* randomize initial seqno to avoid collision */ <nl> +	get_random_bytes(&random_seqno, sizeof(random_seqno)); <nl> +	atomic_set(&hard_iface->seqno, random_seqno); <nl>   <nl>  	hard_iface->packet_len = BATMAN_OGM_LEN; <nl>  	hard_iface->packet_buff = kmalloc(hard_iface->packet_len, GFP_ATOMIC);
@@ -644,7 +644,8 @@ static int e1000_set_ringparam(struct net_device *netdev, <nl>  err_alloc_rx: <nl>  	kfree(txdr); <nl>  err_alloc_tx: <nl> -	e1000_up(adapter); <nl> +	if (netif_running(adapter->netdev)) <nl> +		e1000_up(adapter); <nl>  err_setup: <nl>  	clear_bit(__E1000_RESETTING, &adapter->flags); <nl>  	return err;
@@ -3020,8 +3020,11 @@ static int __ipmi_bmc_register(struct ipmi_smi *intf, <nl>  		bmc->pdev.name = "ipmi_bmc"; <nl>   <nl>  		rv = ida_simple_get(&ipmi_bmc_ida, 0, 0, GFP_KERNEL); <nl> -		if (rv < 0) <nl> +		if (rv < 0) { <nl> +			kfree(bmc); <nl>  			goto out; <nl> +		} <nl> + <nl>  		bmc->pdev.dev.driver = &ipmidriver.driver; <nl>  		bmc->pdev.id = rv; <nl>  		bmc->pdev.dev.release = release_bmc_device;
@@ -1241,7 +1241,7 @@ int tcp_sendmsg(struct sock *sk, struct msghdr *msg, size_t size) <nl>   <nl>  			if (!skb_can_coalesce(skb, i, pfrag->page, <nl>  					      pfrag->offset)) { <nl> -				if (i == sysctl_max_skb_frags || !sg) { <nl> +				if (i >= sysctl_max_skb_frags || !sg) { <nl>  					tcp_mark_push(tp, skb); <nl>  					goto new_segment; <nl>  				}
@@ -1614,10 +1614,10 @@ ath10k_wmi_tlv_op_gen_start_scan(struct ath10k *ar, <nl>  	bssid_len = arg->n_bssids * sizeof(struct wmi_mac_addr); <nl>  	ie_len = roundup(arg->ie_len, 4); <nl>  	len = (sizeof(*tlv) + sizeof(*cmd)) + <nl> -	      (arg->n_channels ? sizeof(*tlv) + chan_len : 0) + <nl> -	      (arg->n_ssids ? sizeof(*tlv) + ssid_len : 0) + <nl> -	      (arg->n_bssids ? sizeof(*tlv) + bssid_len : 0) + <nl> -	      (arg->ie_len ? sizeof(*tlv) + ie_len : 0); <nl> +	      sizeof(*tlv) + chan_len + <nl> +	      sizeof(*tlv) + ssid_len + <nl> +	      sizeof(*tlv) + bssid_len + <nl> +	      sizeof(*tlv) + ie_len; <nl>   <nl>  	skb = ath10k_wmi_alloc_skb(ar, len); <nl>  	if (!skb)
@@ -770,14 +770,14 @@ static void yellowfin_init_ring(struct net_device *dev) <nl>  		/* Branch on Tx error. */ <nl>  		yp->tx_ring[j].dbdma_cmd = cpu_to_le32(CMD_STOP); <nl>  		yp->tx_ring[j].branch_addr = cpu_to_le32(yp->tx_ring_dma + <nl> -			(j+1)*sizeof(struct yellowfin_desc); <nl> +			(j+1)*sizeof(struct yellowfin_desc)); <nl>  		j++; <nl>  		if (yp->flags & FullTxStatus) { <nl>  			yp->tx_ring[j].dbdma_cmd = <nl>  				cpu_to_le32(CMD_TXSTATUS | sizeof(*yp->tx_status)); <nl>  			yp->tx_ring[j].request_cnt = sizeof(*yp->tx_status); <nl>  			yp->tx_ring[j].addr = cpu_to_le32(yp->tx_status_dma + <nl> -				i*sizeof(struct tx_status_words); <nl> +				i*sizeof(struct tx_status_words)); <nl>  		} else { <nl>  			/* Symbios chips write only tx_errs word. */ <nl>  			yp->tx_ring[j].dbdma_cmd =
@@ -593,10 +593,10 @@ static int snd_nativeinstruments_control_get(struct snd_kcontrol *kcontrol, <nl>  	if (mixer->chip->shutdown) <nl>  		ret = -ENODEV; <nl>  	else <nl> -		ret = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0), bRequest, <nl> +		ret = snd_usb_ctl_msg(dev, usb_rcvctrlpipe(dev, 0), bRequest, <nl>  				  USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN, <nl>  				  0, wIndex, <nl> -				  &tmp, sizeof(tmp), 1000); <nl> +				  &tmp, sizeof(tmp)); <nl>  	up_read(&mixer->chip->shutdown_rwsem); <nl>   <nl>  	if (ret < 0) {
@@ -943,8 +943,10 @@ static void perf_top__start_counters(struct perf_top *top) <nl>  			 * based cpu-clock-tick sw counter, which <nl>  			 * is always available even if no PMU support: <nl>  			 */ <nl> -			if (attr->type == PERF_TYPE_HARDWARE && <nl> -			    attr->config == PERF_COUNT_HW_CPU_CYCLES) { <nl> +			if ((err == ENOENT || err == ENXIO) && <nl> +			    (attr->type == PERF_TYPE_HARDWARE) && <nl> +			    (attr->config == PERF_COUNT_HW_CPU_CYCLES)) { <nl> + <nl>  				if (verbose) <nl>  					ui__warning("Cycles event not supported,\n" <nl>  						    "trying to fall back to cpu-clock-ticks\n");
@@ -249,6 +249,15 @@ int x509_note_signature(void *context, size_t hdrlen, <nl>  		return -EINVAL; <nl>  	} <nl>   <nl> +	if (strcmp(ctx->cert->sig->pkey_algo, "rsa") == 0) { <nl> +		/* Discard the BIT STRING metadata */ <nl> +		if (vlen < 1 || *(const u8 *)value != 0) <nl> +			return -EBADMSG; <nl> + <nl> +		value++; <nl> +		vlen--; <nl> +	} <nl> + <nl>  	ctx->cert->raw_sig = value; <nl>  	ctx->cert->raw_sig_size = vlen; <nl>  	return 0;
@@ -61,6 +61,8 @@ int __kprobes arch_prepare_kprobe(struct kprobe *p) <nl>  	if (!ret) { <nl>  		memcpy(p->ainsn.insn, p->addr, MAX_INSN_SIZE * sizeof(kprobe_opcode_t)); <nl>  		p->opcode = *p->addr; <nl> +		flush_icache_range((unsigned long)p->ainsn.insn, <nl> +			(unsigned long)p->ainsn.insn + sizeof(kprobe_opcode_t)); <nl>  	} <nl>   <nl>  	return ret;
@@ -85,6 +85,7 @@ static int vivid_fb_ioctl(struct fb_info *info, unsigned cmd, unsigned long arg) <nl>  	case FBIOGET_VBLANK: { <nl>  		struct fb_vblank vblank; <nl>   <nl> +		memset(&vblank, 0, sizeof(vblank)); <nl>  		vblank.flags = FB_VBLANK_HAVE_COUNT | FB_VBLANK_HAVE_VCOUNT | <nl>  			FB_VBLANK_HAVE_VSYNC; <nl>  		vblank.count = 0;
@@ -462,8 +462,10 @@ static int meson_sar_adc_lock(struct iio_dev *indio_dev) <nl>  			regmap_read(priv->regmap, MESON_SAR_ADC_DELAY, &val); <nl>  		} while (val & MESON_SAR_ADC_DELAY_BL30_BUSY && timeout--); <nl>   <nl> -		if (timeout < 0) <nl> +		if (timeout < 0) { <nl> +			mutex_unlock(&indio_dev->mlock); <nl>  			return -ETIMEDOUT; <nl> +		} <nl>  	} <nl>   <nl>  	return 0;
@@ -57,7 +57,7 @@ int install_user_keyrings(void) <nl>   <nl>  	kenter("%p{%u}", user, uid); <nl>   <nl> -	if (user->uid_keyring) { <nl> +	if (user->uid_keyring && user->session_keyring) { <nl>  		kleave(" = 0 [exist]"); <nl>  		return 0; <nl>  	}
@@ -687,8 +687,11 @@ static int mwifiex_pcie_init_evt_ring(struct mwifiex_adapter *adapter) <nl>  		skb_put(skb, MAX_EVENT_SIZE); <nl>   <nl>  		if (mwifiex_map_pci_memory(adapter, skb, MAX_EVENT_SIZE, <nl> -					   PCI_DMA_FROMDEVICE)) <nl> +					   PCI_DMA_FROMDEVICE)) { <nl> +			kfree_skb(skb); <nl> +			kfree(card->evtbd_ring_vbase); <nl>  			return -1; <nl> +		} <nl>   <nl>  		buf_pa = MWIFIEX_SKB_DMA_ADDR(skb); <nl>  
@@ -341,11 +341,11 @@ int sock_setsockopt(struct socket *sock, int level, int optname, <nl>  				sock_reset_flag(sk, SOCK_LINGER); <nl>  			else { <nl>  #if (BITS_PER_LONG == 32) <nl> -				if (ling.l_linger >= MAX_SCHEDULE_TIMEOUT/HZ) <nl> +				if ((unsigned int)ling.l_linger >= MAX_SCHEDULE_TIMEOUT/HZ) <nl>  					sk->sk_lingertime = MAX_SCHEDULE_TIMEOUT; <nl>  				else <nl>  #endif <nl> -					sk->sk_lingertime = ling.l_linger * HZ; <nl> +					sk->sk_lingertime = (unsigned int)ling.l_linger * HZ; <nl>  				sock_set_flag(sk, SOCK_LINGER); <nl>  			} <nl>  			break;
@@ -42,7 +42,8 @@ static long __validate_layout(struct ceph_mds_client *mdsc, <nl>  	/* validate striping parameters */ <nl>  	if ((l->object_size & ~PAGE_MASK) || <nl>  	    (l->stripe_unit & ~PAGE_MASK) || <nl> -	    ((unsigned)l->object_size % (unsigned)l->stripe_unit)) <nl> +	    (l->stripe_unit != 0 && <nl> +	     ((unsigned)l->object_size % (unsigned)l->stripe_unit))) <nl>  		return -EINVAL; <nl>   <nl>  	/* make sure it's a valid data pool */
@@ -858,8 +858,7 @@ static int mmp_pdma_chan_init(struct mmp_pdma_device *pdev, int idx, int irq) <nl>  	struct mmp_pdma_chan *chan; <nl>  	int ret; <nl>   <nl> -	chan = devm_kzalloc(pdev->dev, sizeof(struct mmp_pdma_chan), <nl> -			    GFP_KERNEL); <nl> +	chan = devm_kzalloc(pdev->dev, sizeof(*chan), GFP_KERNEL); <nl>  	if (chan == NULL) <nl>  		return -ENOMEM; <nl>   <nl> @@ -946,8 +945,7 @@ static int mmp_pdma_probe(struct platform_device *op) <nl>  			irq_num++; <nl>  	} <nl>   <nl> -	pdev->phy = devm_kcalloc(pdev->dev, <nl> -				 dma_channels, sizeof(struct mmp_pdma_chan), <nl> +	pdev->phy = devm_kcalloc(pdev->dev, dma_channels, sizeof(*pdev->phy), <nl>  				 GFP_KERNEL); <nl>  	if (pdev->phy == NULL) <nl>  		return -ENOMEM;
@@ -2708,6 +2708,9 @@ static int do_io_accounting(struct task_struct *task, char *buffer, int whole) <nl>  	struct task_io_accounting acct = task->ioac; <nl>  	unsigned long flags; <nl>   <nl> +	if (!ptrace_may_access(task, PTRACE_MODE_READ)) <nl> +		return -EACCES; <nl> + <nl>  	if (whole && lock_task_sighand(task, &flags)) { <nl>  		struct task_struct *t = task; <nl>   <nl> @@ -2839,7 +2842,7 @@ static const struct pid_entry tgid_base_stuff[] = { <nl>  	REG("coredump_filter", S_IRUGO|S_IWUSR, proc_coredump_filter_operations), <nl>  #endif <nl>  #ifdef CONFIG_TASK_IO_ACCOUNTING <nl> -	INF("io",	S_IRUGO, proc_tgid_io_accounting), <nl> +	INF("io",	S_IRUSR, proc_tgid_io_accounting), <nl>  #endif <nl>  #ifdef CONFIG_HARDWALL <nl>  	INF("hardwall",   S_IRUGO, proc_pid_hardwall), <nl> @@ -3181,7 +3184,7 @@ static const struct pid_entry tid_base_stuff[] = { <nl>  	REG("make-it-fail", S_IRUGO|S_IWUSR, proc_fault_inject_operations), <nl>  #endif <nl>  #ifdef CONFIG_TASK_IO_ACCOUNTING <nl> -	INF("io",	S_IRUGO, proc_tid_io_accounting), <nl> +	INF("io",	S_IRUSR, proc_tid_io_accounting), <nl>  #endif <nl>  #ifdef CONFIG_HARDWALL <nl>  	INF("hardwall",   S_IRUGO, proc_pid_hardwall),
@@ -435,6 +435,7 @@ static int ath10k_usb_hif_tx_sg(struct ath10k *ar, u8 pipe_id, <nl>  			ath10k_dbg(ar, ATH10K_DBG_USB_BULK, <nl>  				   "usb bulk transmit failed: %d\n", ret); <nl>  			usb_unanchor_urb(urb); <nl> +			usb_free_urb(urb); <nl>  			ret = -EINVAL; <nl>  			goto err_free_urb_to_pipe; <nl>  		}
@@ -752,7 +752,7 @@ static void f2fs_submit_discard_endio(struct bio *bio) <nl>   <nl>  	dc->error = bio->bi_error; <nl>  	dc->state = D_DONE; <nl> -	complete(&dc->wait); <nl> +	complete_all(&dc->wait); <nl>  	bio_put(bio); <nl>  } <nl>  
@@ -285,6 +285,8 @@ static int annotate_browser__run(struct annotate_browser *self, int evidx, <nl>  						     timer, arg, delay_secs); <nl>  			} <nl>  			break; <nl> +		case NEWT_KEY_LEFT: <nl> +		case NEWT_KEY_ESCAPE: <nl>  		case 'q': <nl>  		case CTRL('c'): <nl>  			goto out;
@@ -976,6 +976,13 @@ int svc_register(const struct svc_serv *serv, struct net *net, <nl>  			if (vers->vs_hidden) <nl>  				continue; <nl>   <nl> +			/* <nl> +			 * Don't register a UDP port if we need congestion <nl> +			 * control. <nl> +			 */ <nl> +			if (vers->vs_need_cong_ctrl && proto == IPPROTO_UDP) <nl> +				continue; <nl> + <nl>  			error = __svc_register(net, progp->pg_name, progp->pg_prog, <nl>  						i, family, proto, port); <nl>  
@@ -1827,9 +1827,11 @@ static void <nl>  iscsi_tcp_conn_stop(struct iscsi_cls_conn *cls_conn, int flag) <nl>  { <nl>  	struct iscsi_conn *conn = cls_conn->dd_data; <nl> +	struct iscsi_tcp_conn *tcp_conn = conn->dd_data; <nl>   <nl>  	iscsi_conn_stop(cls_conn, flag); <nl>  	iscsi_tcp_release_conn(conn); <nl> +	tcp_conn->hdr_size = sizeof(struct iscsi_hdr); <nl>  } <nl>   <nl>  static int
@@ -706,9 +706,11 @@ static int __devinit max17042_probe(struct i2c_client *client, <nl>  			reg |= CONFIG_ALRT_BIT_ENBL; <nl>  			max17042_write_reg(client, MAX17042_CONFIG, reg); <nl>  			max17042_set_soc_threshold(chip, 1); <nl> -		} else <nl> +		} else { <nl> +			client->irq = 0; <nl>  			dev_err(&client->dev, "%s(): cannot get IRQ\n", <nl>  				__func__); <nl> +		} <nl>  	} <nl>   <nl>  	reg = max17042_read_reg(chip->client, MAX17042_STATUS);
@@ -105,7 +105,7 @@ radeon_dp_aux_transfer_native(struct drm_dp_aux *aux, struct drm_dp_aux_msg *msg <nl>   <nl>  	tmp &= AUX_HPD_SEL(0x7); <nl>  	tmp |= AUX_HPD_SEL(chan->rec.hpd); <nl> -	tmp |= AUX_EN | AUX_LS_READ_EN | AUX_HPD_DISCON(0x1); <nl> +	tmp |= AUX_EN | AUX_LS_READ_EN; <nl>   <nl>  	WREG32(AUX_CONTROL + aux_offset[instance], tmp); <nl>  
@@ -2391,6 +2391,7 @@ static struct ethtool_ops e100_ethtool_ops = { <nl>  	.phys_id		= e100_phys_id, <nl>  	.get_stats_count	= e100_get_stats_count, <nl>  	.get_ethtool_stats	= e100_get_ethtool_stats, <nl> +	.get_perm_addr		= ethtool_op_get_perm_addr, <nl>  }; <nl>   <nl>  static int e100_do_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd) <nl> @@ -2541,7 +2542,8 @@ static int __devinit e100_probe(struct pci_dev *pdev, <nl>  	e100_phy_init(nic); <nl>   <nl>  	memcpy(netdev->dev_addr, nic->eeprom, ETH_ALEN); <nl> -	if(!is_valid_ether_addr(netdev->dev_addr)) { <nl> +	memcpy(netdev->perm_addr, nic->eeprom, ETH_ALEN); <nl> +	if(!is_valid_ether_addr(netdev->perm_addr)) { <nl>  		DPRINTK(PROBE, ERR, "Invalid MAC address from " <nl>  			"EEPROM, aborting.\n"); <nl>  		err = -EAGAIN;
@@ -72,6 +72,9 @@ int ext3_sync_file(struct file * file, struct dentry *dentry, int datasync) <nl>  		goto out; <nl>  	} <nl>   <nl> +	if (datasync && !(inode->i_state & I_DIRTY_DATASYNC)) <nl> +		goto out; <nl> + <nl>  	/* <nl>  	 * The VFS has written the file data.  If the inode is unaltered <nl>  	 * then we need not start a commit.
@@ -885,6 +885,11 @@ static int snd_ftu_eff_switch_put(struct snd_kcontrol *kctl, <nl>  	return changed; <nl>  } <nl>   <nl> +static void kctl_private_value_free(struct snd_kcontrol *kctl) <nl> +{ <nl> +	kfree((void *)kctl->private_value); <nl> +} <nl> + <nl>  static int snd_ftu_create_effect_switch(struct usb_mixer_interface *mixer, <nl>  	int validx, int bUnitID) <nl>  { <nl> @@ -919,6 +924,7 @@ static int snd_ftu_create_effect_switch(struct usb_mixer_interface *mixer, <nl>  		return -ENOMEM; <nl>  	} <nl>   <nl> +	kctl->private_free = kctl_private_value_free; <nl>  	err = snd_ctl_add(mixer->chip->card, kctl); <nl>  	if (err < 0) <nl>  		return err;
@@ -508,6 +508,7 @@ static int whiteheat_attach (struct usb_serial *serial) <nl>  	err("%s: Unable to retrieve firmware version, try replugging\n", serial->type->description); <nl>  	err("%s: If the firmware is not running (status led not blinking)\n", serial->type->description); <nl>  	err("%s: please contact support@connecttech.com\n", serial->type->description); <nl> +	kfree(result); <nl>  	return -ENODEV; <nl>   <nl>  no_command_private:
@@ -88,7 +88,7 @@ int extract_param( <nl>  	if (len < 0) <nl>  		return -1; <nl>   <nl> -	if (len > max_length) { <nl> +	if (len >= max_length) { <nl>  		pr_err("Length of input: %d exceeds max_length:" <nl>  			" %d\n", len, max_length); <nl>  		return -1;
@@ -170,6 +170,10 @@ static void fcopy_send_data(struct work_struct *dummy) <nl>  		out_src = smsg_out; <nl>  		break; <nl>   <nl> +	case WRITE_TO_FILE: <nl> +		out_src = fcopy_transaction.fcopy_msg; <nl> +		out_len = sizeof(struct hv_do_fcopy); <nl> +		break; <nl>  	default: <nl>  		out_src = fcopy_transaction.fcopy_msg; <nl>  		out_len = fcopy_transaction.recv_len;
@@ -1476,6 +1476,10 @@ int __cpufreq_driver_target(struct cpufreq_policy *policy, <nl>   <nl>  	pr_debug("target for CPU %u: %u kHz, relation %u\n", policy->cpu, <nl>  		target_freq, relation); <nl> + <nl> +	if (target_freq == policy->cur) <nl> +		return 0; <nl> + <nl>  	if (cpu_online(policy->cpu) && cpufreq_driver->target) <nl>  		retval = cpufreq_driver->target(policy, target_freq, relation); <nl>  
@@ -1398,6 +1398,11 @@ fb_mmap(struct file *file, struct vm_area_struct * vma) <nl>  	len = info->fix.smem_len; <nl>  	mmio_pgoff = PAGE_ALIGN((start & ~PAGE_MASK) + len) >> PAGE_SHIFT; <nl>  	if (vma->vm_pgoff >= mmio_pgoff) { <nl> +		if (info->var.accel_flags) { <nl> +			mutex_unlock(&info->mm_lock); <nl> +			return -EINVAL; <nl> +		} <nl> + <nl>  		vma->vm_pgoff -= mmio_pgoff; <nl>  		start = info->fix.mmio_start; <nl>  		len = info->fix.mmio_len;
@@ -94,8 +94,7 @@ static void __init pcibios_allocate_bus_resources(struct list_head *bus_list) <nl>  				r = &dev->resource[idx]; <nl>  				if (!r->start) <nl>  					continue; <nl> -				if (pci_claim_resource(dev, idx) < 0) <nl> -					printk(KERN_ERR "PCI: Cannot allocate resource region %d of bridge %s\n", idx, pci_name(dev)); <nl> +				pci_claim_resource(dev, idx); <nl>  			} <nl>  		} <nl>  		pcibios_allocate_bus_resources(&bus->children); <nl> @@ -125,7 +124,6 @@ static void __init pcibios_allocate_resources(int pass) <nl>  				DBG("PCI: Resource %08lx-%08lx (f=%lx, d=%d, p=%d)\n", <nl>  				    r->start, r->end, r->flags, disabled, pass); <nl>  				if (pci_claim_resource(dev, idx) < 0) { <nl> -					printk(KERN_ERR "PCI: Cannot allocate resource region %d of device %s\n", idx, pci_name(dev)); <nl>  					/* We'll assign a new address later */ <nl>  					r->end -= r->start; <nl>  					r->start = 0;
@@ -1068,8 +1068,10 @@ static void fec_enet_work(struct work_struct *work) <nl>   <nl>  	if (fep->delay_work.timeout) { <nl>  		fep->delay_work.timeout = false; <nl> +		rtnl_lock(); <nl>  		fec_restart(fep->netdev, fep->full_duplex); <nl>  		netif_wake_queue(fep->netdev); <nl> +		rtnl_unlock(); <nl>  	} <nl>   <nl>  	if (fep->delay_work.trig_tx) { <nl> @@ -2680,11 +2682,14 @@ fec_suspend(struct device *dev) <nl>  	struct net_device *ndev = dev_get_drvdata(dev); <nl>  	struct fec_enet_private *fep = netdev_priv(ndev); <nl>   <nl> +	rtnl_lock(); <nl>  	if (netif_running(ndev)) { <nl>  		phy_stop(fep->phy_dev); <nl>  		fec_stop(ndev); <nl>  		netif_device_detach(ndev); <nl>  	} <nl> +	rtnl_unlock(); <nl> + <nl>  	fec_enet_clk_enable(ndev, false); <nl>  	pinctrl_pm_select_sleep_state(&fep->pdev->dev); <nl>   <nl> @@ -2712,11 +2717,13 @@ fec_resume(struct device *dev) <nl>  	if (ret) <nl>  		goto failed_clk; <nl>   <nl> +	rtnl_lock(); <nl>  	if (netif_running(ndev)) { <nl>  		fec_restart(ndev, fep->full_duplex); <nl>  		netif_device_attach(ndev); <nl>  		phy_start(fep->phy_dev); <nl>  	} <nl> +	rtnl_unlock(); <nl>   <nl>  	return 0; <nl>  
@@ -80,9 +80,12 @@ static inline struct page *pte_alloc_one(struct mm_struct *mm, <nl>  	struct page *pte; <nl>   <nl>  	pte = alloc_pages(GFP_KERNEL | __GFP_REPEAT, PTE_ORDER); <nl> -	if (pte) { <nl> -		clear_highpage(pte); <nl> -		pgtable_page_ctor(pte); <nl> +	if (!pte) <nl> +		return NULL; <nl> +	clear_highpage(pte); <nl> +	if (!pgtable_page_ctor(pte)) { <nl> +		__free_page(pte); <nl> +		return NULL; <nl>  	} <nl>  	return pte; <nl>  }
@@ -321,7 +321,7 @@ static int proc_reg_open(struct inode *inode, struct file *file) <nl>  	 * by hand in remove_proc_entry(). For this, save opener's credentials <nl>  	 * for later. <nl>  	 */ <nl> -	pdeo = kzalloc(sizeof(struct pde_opener), GFP_KERNEL); <nl> +	pdeo = kmalloc(sizeof(struct pde_opener), GFP_KERNEL); <nl>  	if (!pdeo) <nl>  		return -ENOMEM; <nl>   <nl> @@ -338,6 +338,8 @@ static int proc_reg_open(struct inode *inode, struct file *file) <nl>  	if (rv == 0 && release) { <nl>  		/* To know what to release. */ <nl>  		pdeo->file = file; <nl> +		pdeo->closing = false; <nl> +		pdeo->c = NULL; <nl>  		/* Strictly for "too late" ->release in proc_reg_release(). */ <nl>  		spin_lock(&pde->pde_unload_lock); <nl>  		list_add(&pdeo->lh, &pde->pde_openers);
@@ -373,7 +373,6 @@ static void mem_cgroup_put(struct mem_cgroup *memcg); <nl>   <nl>  /* Writing them here to avoid exposing memcg's inner layout */ <nl>  #ifdef CONFIG_CGROUP_MEM_RES_CTLR_KMEM <nl> -#ifdef CONFIG_INET <nl>  #include <net/sock.h> <nl>  #include <net/ip.h> <nl>   <nl> @@ -420,6 +419,7 @@ void sock_release_memcg(struct sock *sk) <nl>  	} <nl>  } <nl>   <nl> +#ifdef CONFIG_INET <nl>  struct cg_proto *tcp_proto_cgroup(struct mem_cgroup *memcg) <nl>  { <nl>  	if (!memcg || mem_cgroup_is_root(memcg))
@@ -7240,6 +7240,10 @@ static bool ironlake_get_pipe_config(struct intel_crtc *crtc, <nl>  	struct drm_i915_private *dev_priv = dev->dev_private; <nl>  	uint32_t tmp; <nl>   <nl> +	if (!intel_display_power_enabled(dev_priv, <nl> +					 POWER_DOMAIN_PIPE(crtc->pipe))) <nl> +		return false; <nl> + <nl>  	pipe_config->cpu_transcoder = (enum transcoder) crtc->pipe; <nl>  	pipe_config->shared_dpll = DPLL_ID_PRIVATE; <nl>  
@@ -1480,7 +1480,7 @@ void cs46xx_dsp_destroy_pcm_channel (struct snd_cs46xx * chip, <nl>  	if (!pcm_channel->src_scb->ref_count) { <nl>  		cs46xx_dsp_remove_scb(chip,pcm_channel->src_scb); <nl>   <nl> -		snd_assert (pcm_channel->src_slot >= 0 && pcm_channel->src_slot <= DSP_MAX_SRC_NR, <nl> +		snd_assert (pcm_channel->src_slot >= 0 && pcm_channel->src_slot < DSP_MAX_SRC_NR, <nl>  			    return ); <nl>   <nl>  		ins->src_scb_slots[pcm_channel->src_slot] = 0;
@@ -145,7 +145,7 @@ static int sw_sync_open(struct inode *inode, struct file *file) <nl>  	get_task_comm(task_comm, current); <nl>   <nl>  	obj = sw_sync_timeline_create(task_comm); <nl> -	if (obj == NULL) <nl> +	if (!obj) <nl>  		return -ENOMEM; <nl>   <nl>  	file->private_data = obj; <nl> @@ -179,14 +179,14 @@ static long sw_sync_ioctl_create_fence(struct sw_sync_timeline *obj, <nl>  	} <nl>   <nl>  	pt = sw_sync_pt_create(obj, data.value); <nl> -	if (pt == NULL) { <nl> +	if (!pt) { <nl>  		err = -ENOMEM; <nl>  		goto err; <nl>  	} <nl>   <nl>  	data.name[sizeof(data.name) - 1] = '\0'; <nl>  	fence = sync_fence_create(data.name, pt); <nl> -	if (fence == NULL) { <nl> +	if (!fence) { <nl>  		sync_pt_free(pt); <nl>  		err = -ENOMEM; <nl>  		goto err;
@@ -802,13 +802,13 @@ void do_exit(long code) <nl>   <nl>  	module_put(task_thread_info(tsk)->exec_domain->module); <nl>   <nl> -	proc_exit_connector(tsk); <nl>  	/* <nl>  	 * FIXME: do that only when needed, using sched_exit tracepoint <nl>  	 */ <nl>  	flush_ptrace_hw_breakpoint(tsk); <nl>   <nl>  	exit_notify(tsk, group_dead); <nl> +	proc_exit_connector(tsk); <nl>  #ifdef CONFIG_NUMA <nl>  	task_lock(tsk); <nl>  	mpol_put(tsk->mempolicy);
@@ -739,7 +739,7 @@ static void audit_log_feature_change(int which, u32 old_feature, u32 new_feature <nl>   <nl>  	ab = audit_log_start(NULL, GFP_KERNEL, AUDIT_FEATURE_CHANGE); <nl>  	audit_log_task_info(ab, current); <nl> -	audit_log_format(ab, "feature=%s old=%u new=%u old_lock=%u new_lock=%u res=%d", <nl> +	audit_log_format(ab, " feature=%s old=%u new=%u old_lock=%u new_lock=%u res=%d", <nl>  			 audit_feature_names[which], !!old_feature, !!new_feature, <nl>  			 !!old_lock, !!new_lock, res); <nl>  	audit_log_end(ab);
@@ -122,6 +122,7 @@ struct g2d_runqueue_node { <nl>  	struct list_head	list; <nl>  	struct list_head	run_cmdlist; <nl>  	struct list_head	event_list; <nl> +	pid_t			pid; <nl>  	struct completion	complete; <nl>  	int			async; <nl>  }; <nl> @@ -679,6 +680,7 @@ int exynos_g2d_exec_ioctl(struct drm_device *drm_dev, void *data, <nl>  	} <nl>   <nl>  	mutex_lock(&g2d->runqueue_mutex); <nl> +	runqueue_node->pid = current->pid; <nl>  	list_add_tail(&runqueue_node->list, &g2d->runqueue); <nl>  	if (!g2d->runqueue_node) <nl>  		g2d_exec_runqueue(g2d);
@@ -474,8 +474,6 @@ static int vt8500lcd_remove(struct platform_device *pdev) <nl>  	res = platform_get_resource(pdev, IORESOURCE_MEM, 0); <nl>  	release_mem_region(res->start, resource_size(res)); <nl>   <nl> -	kfree(fbi); <nl> - <nl>  	return 0; <nl>  } <nl>  
@@ -244,7 +244,7 @@ struct btrfs_block_group_cache *btrfs_find_block_group(struct btrfs_root *root, <nl>  	if (search_start) { <nl>  		struct btrfs_block_group_cache *shint; <nl>  		shint = btrfs_lookup_block_group(info, search_start); <nl> -		if (shint->data == data) { <nl> +		if (shint && shint->data == data) { <nl>  			used = btrfs_block_group_used(&shint->item); <nl>  			if (used + shint->pinned < <nl>  			    div_factor(shint->key.offset, factor)) { <nl> @@ -1255,8 +1255,7 @@ struct buffer_head *btrfs_alloc_free_block(struct btrfs_trans_handle *trans, <nl>  	struct buffer_head *buf; <nl>   <nl>  	ret = btrfs_alloc_extent(trans, root, root->root_key.objectid, <nl> -				 1, empty_size, hint, <nl> -				 (unsigned long)-1, &ins, 0); <nl> +				 1, empty_size, hint, (u64)-1, &ins, 0); <nl>  	if (ret) { <nl>  		BUG_ON(ret > 0); <nl>  		return ERR_PTR(ret);
@@ -773,7 +773,7 @@ int hists__browse(struct hists *self, const char *helpline, const char *ev_name) <nl>   <nl>  			switch (key) { <nl>  			case 'a': <nl> -				if (browser->selection->map == NULL && <nl> +				if (browser->selection->map == NULL || <nl>  				    browser->selection->map->dso->annotate_warned) <nl>  					continue; <nl>  				goto do_annotate;
@@ -1770,6 +1770,15 @@ void bio_endio(struct bio *bio, int error) <nl>  		} else { <nl>  			if (bio->bi_end_io) <nl>  				bio->bi_end_io(bio, error); <nl> +			else { <nl> +				char dev_name[BDEVNAME_SIZE]; <nl> + <nl> +				WARN(1, "bio_endio: bio for %s without endio\n", <nl> +					bio->bi_bdev ? bdevname(bio->bi_bdev, <nl> +					dev_name) : "(unknown)"); <nl> +				bio_put(bio); <nl> +			} <nl> + <nl>  			bio = NULL; <nl>  		} <nl>  	}
@@ -42,7 +42,6 @@ struct ndfc_controller { <nl>  	struct nand_chip chip; <nl>  	int chip_select; <nl>  	struct nand_hw_control ndfc_control; <nl> -	struct mtd_partition *parts; <nl>  }; <nl>   <nl>  static struct ndfc_controller ndfc_ctrl[NDFC_MAX_CS]; <nl> @@ -201,11 +200,7 @@ static int ndfc_chip_init(struct ndfc_controller *ndfc, <nl>  	if (ret) <nl>  		goto err; <nl>   <nl> -	ret = parse_mtd_partitions(&ndfc->mtd, NULL, &ndfc->parts, &ppdata); <nl> -	if (ret < 0) <nl> -		goto err; <nl> - <nl> -	ret = mtd_device_register(&ndfc->mtd, ndfc->parts, ret); <nl> +	ret = mtd_device_parse_register(&ndfc->mtd, NULL, &ppdata, NULL, 0); <nl>   <nl>  err: <nl>  	of_node_put(flash_np);
@@ -1603,8 +1603,11 @@ static void fail_all_commands(struct iscsi_conn *conn, unsigned lun, <nl>  { <nl>  	struct iscsi_task *task, *tmp; <nl>   <nl> -	if (conn->task && (conn->task->sc->device->lun == lun || lun == -1)) <nl> -		conn->task = NULL; <nl> +	if (conn->task) { <nl> +		if (lun == -1 || <nl> +		    (conn->task->sc && conn->task->sc->device->lun == lun)) <nl> +			conn->task = NULL; <nl> +	} <nl>   <nl>  	/* flush pending */ <nl>  	list_for_each_entry_safe(task, tmp, &conn->xmitqueue, running) {
@@ -53,7 +53,7 @@ <nl>  #define IS_DIGITAL(c) (c->output_flag & (SDVO_TMDS_MASK | SDVO_LVDS_MASK)) <nl>   <nl>   <nl> -static const char *tv_format_names[] = { <nl> +static const char * const tv_format_names[] = { <nl>  	"NTSC_M"   , "NTSC_J"  , "NTSC_443", <nl>  	"PAL_B"    , "PAL_D"   , "PAL_G"   , <nl>  	"PAL_H"    , "PAL_I"   , "PAL_M"   , <nl> @@ -452,7 +452,7 @@ static void intel_sdvo_debug_write(struct intel_sdvo *intel_sdvo, u8 cmd, <nl>  	DRM_DEBUG_KMS("%s: W: %02X %s\n", SDVO_NAME(intel_sdvo), cmd, buffer); <nl>  } <nl>   <nl> -static const char *cmd_status_names[] = { <nl> +static const char * const cmd_status_names[] = { <nl>  	"Power on", <nl>  	"Success", <nl>  	"Not supported",
@@ -775,9 +775,12 @@ static int dwc3_qcom_probe(struct platform_device *pdev) <nl>   <nl>  		if (qcom->acpi_pdata->is_urs) { <nl>  			qcom->urs_usb = dwc3_qcom_create_urs_usb_platdev(dev); <nl> -			if (!qcom->urs_usb) { <nl> +			if (IS_ERR_OR_NULL(qcom->urs_usb)) { <nl>  				dev_err(dev, "failed to create URS USB platdev\n"); <nl> -				return -ENODEV; <nl> +				if (!qcom->urs_usb) <nl> +					return -ENODEV; <nl> +				else <nl> +					return PTR_ERR(qcom->urs_usb); <nl>  			} <nl>  		} <nl>  	}
@@ -346,6 +346,7 @@ static int iscsi_login_zero_tsih_s1( <nl>  	if (IS_ERR(sess->se_sess)) { <nl>  		iscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR, <nl>  				ISCSI_LOGIN_STATUS_NO_RESOURCES); <nl> +		kfree(sess->sess_ops); <nl>  		kfree(sess); <nl>  		return -ENOMEM; <nl>  	}
@@ -472,8 +472,8 @@ int hfi1_user_sdma_free_queues(struct hfi1_filedata *fd) <nl>  	hfi1_cdbg(SDMA, "[%u:%u:%u] Freeing user SDMA queues", uctxt->dd->unit, <nl>  		  uctxt->ctxt, fd->subctxt); <nl>  	pq = fd->pq; <nl> -	hfi1_mmu_rb_unregister(&pq->sdma_rb_root); <nl>  	if (pq) { <nl> +		hfi1_mmu_rb_unregister(&pq->sdma_rb_root); <nl>  		spin_lock_irqsave(&uctxt->sdma_qlock, flags); <nl>  		if (!list_empty(&pq->list)) <nl>  			list_del_init(&pq->list);
@@ -392,6 +392,13 @@ static const struct regmap_config ssbi_regmap_config = { <nl>  	.reg_write = ssbi_reg_write <nl>  }; <nl>   <nl> +static const struct of_device_id pm8921_id_table[] = { <nl> +	{ .compatible = "qcom,pm8058", }, <nl> +	{ .compatible = "qcom,pm8921", }, <nl> +	{ } <nl> +}; <nl> +MODULE_DEVICE_TABLE(of, pm8921_id_table); <nl> + <nl>  static int pm8921_probe(struct platform_device *pdev) <nl>  { <nl>  	struct pm8921 *pmic; <nl> @@ -501,6 +508,7 @@ static struct platform_driver pm8921_driver = { <nl>  	.driver		= { <nl>  		.name	= "pm8921-core", <nl>  		.owner	= THIS_MODULE, <nl> +		.of_match_table = pm8921_id_table, <nl>  	}, <nl>  }; <nl>  
@@ -3017,10 +3017,12 @@ int i40e_ndo_set_vf_port_vlan(struct net_device *netdev, int vf_id, <nl>  					   VLAN_VID_MASK)); <nl>  	} <nl>   <nl> +	spin_unlock_bh(&vsi->mac_filter_hash_lock); <nl>  	if (vlan_id || qos) <nl>  		ret = i40e_vsi_add_pvid(vsi, vlanprio); <nl>  	else <nl>  		i40e_vsi_remove_pvid(vsi); <nl> +	spin_lock_bh(&vsi->mac_filter_hash_lock); <nl>   <nl>  	if (vlan_id) { <nl>  		dev_info(&pf->pdev->dev, "Setting VLAN %d, QOS 0x%x on VF %d\n",
@@ -2926,6 +2926,13 @@ static int prepend_path(const struct path *path, <nl>   <nl>  		if (dentry == vfsmnt->mnt_root || IS_ROOT(dentry)) { <nl>  			struct mount *parent = ACCESS_ONCE(mnt->mnt_parent); <nl> +			/* Escaped? */ <nl> +			if (dentry != vfsmnt->mnt_root) { <nl> +				bptr = *buffer; <nl> +				blen = *buflen; <nl> +				error = 3; <nl> +				break; <nl> +			} <nl>  			/* Global root? */ <nl>  			if (mnt != parent) { <nl>  				dentry = ACCESS_ONCE(mnt->mnt_mountpoint);
@@ -428,6 +428,15 @@ static int ath10k_htt_rx_amsdu_pop(struct ath10k_htt *htt, <nl>  		while (msdu_chained--) { <nl>  			struct sk_buff *next = ath10k_htt_rx_netbuf_pop(htt); <nl>   <nl> +			if (!next) { <nl> +				ath10k_warn(ar, "failed to pop chained msdu\n"); <nl> +				ath10k_htt_rx_free_msdu_chain(*head_msdu); <nl> +				*head_msdu = NULL; <nl> +				msdu = NULL; <nl> +				htt->rx_confused = true; <nl> +				break; <nl> +			} <nl> + <nl>  			skb_trim(next, 0); <nl>  			skb_put(next, min(msdu_len, HTT_RX_BUF_SIZE)); <nl>  			msdu_len -= next->len;
@@ -130,13 +130,18 @@ static struct rc_map_list empty_map = { <nl>  static int ir_create_table(struct rc_map *rc_map, <nl>  			   const char *name, u64 rc_type, size_t size) <nl>  { <nl> -	rc_map->name = name; <nl> +	rc_map->name = kstrdup(name, GFP_KERNEL); <nl> +	if (!rc_map->name) <nl> +		return -ENOMEM; <nl>  	rc_map->rc_type = rc_type; <nl>  	rc_map->alloc = roundup_pow_of_two(size * sizeof(struct rc_map_table)); <nl>  	rc_map->size = rc_map->alloc / sizeof(struct rc_map_table); <nl>  	rc_map->scan = kmalloc(rc_map->alloc, GFP_KERNEL); <nl> -	if (!rc_map->scan) <nl> +	if (!rc_map->scan) { <nl> +		kfree(rc_map->name); <nl> +		rc_map->name = NULL; <nl>  		return -ENOMEM; <nl> +	} <nl>   <nl>  	IR_dprintk(1, "Allocated space for %u keycode entries (%u bytes)\n", <nl>  		   rc_map->size, rc_map->alloc); <nl> @@ -153,6 +158,7 @@ static int ir_create_table(struct rc_map *rc_map, <nl>  static void ir_free_table(struct rc_map *rc_map) <nl>  { <nl>  	rc_map->size = 0; <nl> +	kfree(rc_map->name); <nl>  	kfree(rc_map->scan); <nl>  	rc_map->scan = NULL; <nl>  }
@@ -1222,6 +1222,9 @@ static acpi_status WMID_set_capabilities(void) <nl>  			devices = *((u32 *) obj->buffer.pointer); <nl>  		} else if (obj->type == ACPI_TYPE_INTEGER) { <nl>  			devices = (u32) obj->integer.value; <nl> +		} else { <nl> +			kfree(out.pointer); <nl> +			return AE_ERROR; <nl>  		} <nl>  	} else { <nl>  		kfree(out.pointer);
@@ -234,6 +234,15 @@ static int uverbs_validate_kernel_mandatory(const struct uverbs_method_spec *met <nl>  			return -EINVAL; <nl>  	} <nl>   <nl> +	for (; i < method_spec->num_buckets; i++) { <nl> +		struct uverbs_attr_spec_hash *attr_spec_bucket = <nl> +			method_spec->attr_buckets[i]; <nl> + <nl> +		if (!bitmap_empty(attr_spec_bucket->mandatory_attrs_bitmask, <nl> +				  attr_spec_bucket->num_attrs)) <nl> +			return -EINVAL; <nl> +	} <nl> + <nl>  	return 0; <nl>  } <nl>  
@@ -565,6 +565,7 @@ static int wake_futex_pi(u32 __user *uaddr, u32 uval, struct futex_q *this) <nl>  	if (!pi_state) <nl>  		return -EINVAL; <nl>   <nl> +	spin_lock(&pi_state->pi_mutex.wait_lock); <nl>  	new_owner = rt_mutex_next_owner(&pi_state->pi_mutex); <nl>   <nl>  	/* <nl> @@ -604,6 +605,7 @@ static int wake_futex_pi(u32 __user *uaddr, u32 uval, struct futex_q *this) <nl>  	pi_state->owner = new_owner; <nl>  	spin_unlock_irq(&new_owner->pi_lock); <nl>   <nl> +	spin_unlock(&pi_state->pi_mutex.wait_lock); <nl>  	rt_mutex_unlock(&pi_state->pi_mutex); <nl>   <nl>  	return 0;
@@ -2023,6 +2023,8 @@ static void __init atmci_get_cap(struct atmel_mci *host) <nl>  	/* keep only major version number */ <nl>  	switch (version & 0xf00) { <nl>  	case 0x100: <nl> +		host->caps.has_pdc = 1; <nl> +		break; <nl>  	case 0x200: <nl>  		host->caps.has_pdc = 1; <nl>  		host->caps.has_rwproof = 1;
@@ -5913,6 +5913,7 @@ inherit_event(struct perf_event *parent_event, <nl>  	      struct perf_event_context *child_ctx) <nl>  { <nl>  	struct perf_event *child_event; <nl> +	unsigned long flags; <nl>   <nl>  	/* <nl>  	 * Instead of creating recursive hierarchies of events, <nl> @@ -5957,7 +5958,9 @@ inherit_event(struct perf_event *parent_event, <nl>  	/* <nl>  	 * Link it up in the child's context: <nl>  	 */ <nl> +	raw_spin_lock_irqsave(&child_ctx->lock, flags); <nl>  	add_event_to_ctx(child_event, child_ctx); <nl> +	raw_spin_unlock_irqrestore(&child_ctx->lock, flags); <nl>   <nl>  	/* <nl>  	 * Get a reference to the parent filp - we will fput it
@@ -112,6 +112,8 @@ static int usbtv_probe(struct usb_interface *intf, <nl>  	return 0; <nl>   <nl>  usbtv_audio_fail: <nl> +	/* we must not free at this point */ <nl> +	usb_get_dev(usbtv->udev); <nl>  	usbtv_video_free(usbtv); <nl>   <nl>  usbtv_video_fail:
@@ -473,11 +473,13 @@ int cpdma_ctlr_int_ctrl(struct cpdma_ctlr *ctlr, bool enable) <nl>  	spin_unlock_irqrestore(&ctlr->lock, flags); <nl>  	return 0; <nl>  } <nl> +EXPORT_SYMBOL_GPL(cpdma_ctlr_int_ctrl); <nl>   <nl>  void cpdma_ctlr_eoi(struct cpdma_ctlr *ctlr) <nl>  { <nl>  	dma_reg_write(ctlr, CPDMA_MACEOIVECTOR, 0); <nl>  } <nl> +EXPORT_SYMBOL_GPL(cpdma_ctlr_eoi); <nl>   <nl>  struct cpdma_chan *cpdma_chan_create(struct cpdma_ctlr *ctlr, int chan_num, <nl>  				     cpdma_handler_fn handler) <nl> @@ -984,3 +986,4 @@ int cpdma_control_set(struct cpdma_ctlr *ctlr, int control, int value) <nl>  	spin_unlock_irqrestore(&ctlr->lock, flags); <nl>  	return ret; <nl>  } <nl> +EXPORT_SYMBOL_GPL(cpdma_control_set);
@@ -961,6 +961,8 @@ void dma_run_dependencies(struct dma_async_tx_descriptor *tx) <nl>  	if (!dep) <nl>  		return; <nl>   <nl> +	/* we'll submit tx->next now, so clear the link */ <nl> +	tx->next = NULL; <nl>  	chan = dep->chan; <nl>   <nl>  	/* keep submitting up until a channel switch is detected
@@ -301,7 +301,7 @@ __update_curr(struct cfs_rq *cfs_rq, struct sched_entity *curr, <nl>  	schedstat_set(curr->exec_max, max((u64)delta_exec, curr->exec_max)); <nl>   <nl>  	curr->sum_exec_runtime += delta_exec; <nl> -	cfs_rq->exec_clock += delta_exec; <nl> +	schedstat_add(cfs_rq, exec_clock, delta_exec); <nl>  	delta_exec_weighted = delta_exec; <nl>  	if (unlikely(curr->load.weight != NICE_0_LOAD)) { <nl>  		delta_exec_weighted = calc_delta_fair(delta_exec_weighted,
@@ -525,6 +525,9 @@ int rds_rdma_extra_size(struct rds_rdma_args *args) <nl>   <nl>  	local_vec = (struct rds_iovec __user *)(unsigned long) args->local_vec_addr; <nl>   <nl> +	if (args->nr_local == 0) <nl> +		return -EINVAL; <nl> + <nl>  	/* figure out the number of pages in the vector */ <nl>  	for (i = 0; i < args->nr_local; i++) { <nl>  		if (copy_from_user(&vec, &local_vec[i],
@@ -1744,6 +1744,9 @@ sg_start_req(Sg_request *srp, unsigned char *cmd) <nl>  			md->from_user = 0; <nl>  	} <nl>   <nl> +	if (unlikely(iov_count > MAX_UIOVEC)) <nl> +		return -EINVAL; <nl> + <nl>  	if (iov_count) { <nl>  		int size = sizeof(struct iovec) * iov_count; <nl>  		struct iovec *iov;
@@ -161,10 +161,15 @@ static int via_pre_reset(struct ata_port *ap) <nl>  			return -ENOENT; <nl>  	} <nl>   <nl> -	if ((config->flags & VIA_UDMA) >= VIA_UDMA_66) <nl> +	if ((config->flags & VIA_UDMA) >= VIA_UDMA_100) <nl>  		ap->cbl = via_cable_detect(ap); <nl> -	else <nl> +	/* The UDMA66 series has no cable detect so do drive side detect */ <nl> +	else if ((config->flags & VIA_UDMA) < VIA_UDMA_66) <nl>  		ap->cbl = ATA_CBL_PATA40; <nl> +	else <nl> +		ap->cbl = ATA_CBL_PATA_UNK; <nl> +		 <nl> + <nl>  	return ata_std_prereset(ap); <nl>  } <nl>  
@@ -37,6 +37,7 @@ <nl>  #include <linux/in6.h> <nl>  #include <net/ipv6.h> <nl>  #include <linux/nfs_xdr.h> <nl> +#include <linux/sunrpc/bc_xprt.h> <nl>   <nl>  #include <asm/system.h> <nl>   <nl> @@ -1096,6 +1097,14 @@ static int nfs4_init_callback(struct nfs_client *clp) <nl>  	int error; <nl>   <nl>  	if (clp->rpc_ops->version == 4) { <nl> +		if (nfs4_has_session(clp)) { <nl> +			error = xprt_setup_backchannel( <nl> +						clp->cl_rpcclient->cl_xprt, <nl> +						NFS41_BC_MIN_CALLBACKS); <nl> +			if (error < 0) <nl> +				return error; <nl> +		} <nl> + <nl>  		error = nfs_callback_up(clp->cl_minorversion, <nl>  					clp->cl_rpcclient->cl_xprt); <nl>  		if (error < 0) {
@@ -1824,6 +1824,7 @@ int ath6kl_debug_init_fs(struct ath6kl *ar) <nl>  void ath6kl_debug_cleanup(struct ath6kl *ar) <nl>  { <nl>  	skb_queue_purge(&ar->debug.fwlog_queue); <nl> +	complete(&ar->debug.fwlog_completion); <nl>  	kfree(ar->debug.roam_tbl); <nl>  } <nl>  
@@ -664,8 +664,10 @@ int add_mtd_partitions(struct mtd_info *master, <nl>   <nl>  	for (i = 0; i < nbparts; i++) { <nl>  		slave = allocate_partition(master, parts + i, i, cur_offset); <nl> -		if (IS_ERR(slave)) <nl> +		if (IS_ERR(slave)) { <nl> +			del_mtd_partitions(master); <nl>  			return PTR_ERR(slave); <nl> +		} <nl>   <nl>  		mutex_lock(&mtd_partitions_mutex); <nl>  		list_add(&slave->list, &mtd_partitions);
@@ -136,7 +136,9 @@ static int bcm7038_wdt_probe(struct platform_device *pdev) <nl>  	wdt->clk = devm_clk_get(dev, NULL); <nl>  	/* If unable to get clock, use default frequency */ <nl>  	if (!IS_ERR(wdt->clk)) { <nl> -		clk_prepare_enable(wdt->clk); <nl> +		err = clk_prepare_enable(wdt->clk); <nl> +		if (err) <nl> +			return err; <nl>  		wdt->rate = clk_get_rate(wdt->clk); <nl>  		/* Prevent divide-by-zero exception */ <nl>  		if (!wdt->rate)
@@ -2609,6 +2609,9 @@ static int sctp_process_param(struct sctp_association *asoc, <nl>  		addr_param = param.v + sizeof(sctp_addip_param_t); <nl>   <nl>  		af = sctp_get_af_specific(param_type2af(param.p->type)); <nl> +		if (af == NULL) <nl> +			break; <nl> + <nl>  		af->from_addr_param(&addr, addr_param, <nl>  				    htons(asoc->peer.port), 0); <nl>  
@@ -106,11 +106,14 @@ int rds_tcp_conn_connect(struct rds_connection *conn) <nl>  	rds_tcp_set_callbacks(sock, conn); <nl>  	ret = sock->ops->connect(sock, (struct sockaddr *)&dest, sizeof(dest), <nl>  				 O_NONBLOCK); <nl> -	sock = NULL; <nl>   <nl>  	rdsdebug("connect to address %pI4 returned %d\n", &conn->c_faddr, ret); <nl>  	if (ret == -EINPROGRESS) <nl>  		ret = 0; <nl> +	if (ret == 0) <nl> +		sock = NULL; <nl> +	else <nl> +		rds_tcp_restore_callbacks(sock, conn->c_transport_data); <nl>   <nl>  out: <nl>  	if (sock)
@@ -590,6 +590,7 @@ static long ioctl_file_dedupe_range(struct file *file, void __user *arg) <nl>  		goto out; <nl>  	} <nl>   <nl> +	same->dest_count = count; <nl>  	ret = vfs_dedupe_file_range(file, same); <nl>  	if (ret) <nl>  		goto out;
@@ -192,10 +192,11 @@ static int klsi_105_get_line_state(struct usb_serial_port *port, <nl>  			     status_buf, KLSI_STATUSBUF_LEN, <nl>  			     10000 <nl>  			     ); <nl> -	if (rc < 0) <nl> -		dev_err(&port->dev, "Reading line status failed (error = %d)\n", <nl> -			rc); <nl> -	else { <nl> +	if (rc != KLSI_STATUSBUF_LEN) { <nl> +		dev_err(&port->dev, "reading line status failed: %d\n", rc); <nl> +		if (rc >= 0) <nl> +			rc = -EIO; <nl> +	} else { <nl>  		status = get_unaligned_le16(status_buf); <nl>   <nl>  		dev_info(&port->serial->dev->dev, "read status %x %x\n",
@@ -152,6 +152,9 @@ static int parse_addr(const struct nf_conn *ct, const char *cp, <nl>  	const char *end; <nl>  	int ret = 0; <nl>   <nl> +	if (!ct) <nl> +		return 0; <nl> + <nl>  	memset(addr, 0, sizeof(*addr)); <nl>  	switch (nf_ct_l3num(ct)) { <nl>  	case AF_INET:
@@ -501,8 +501,8 @@ static int uvc_v4l2_open(struct file *file) <nl>  	if (atomic_inc_return(&stream->dev->users) == 1) { <nl>  		ret = uvc_status_start(stream->dev); <nl>  		if (ret < 0) { <nl> -			usb_autopm_put_interface(stream->dev->intf); <nl>  			atomic_dec(&stream->dev->users); <nl> +			usb_autopm_put_interface(stream->dev->intf); <nl>  			kfree(handle); <nl>  			return ret; <nl>  		}
@@ -606,6 +606,8 @@ static int mem_cgroup_hierarchical_reclaim(struct mem_cgroup *root_mem, <nl>  	ret = try_to_free_mem_cgroup_pages(root_mem, gfp_mask, noswap); <nl>  	if (mem_cgroup_check_under_limit(root_mem)) <nl>  		return 0; <nl> +	if (!root_mem->use_hierarchy) <nl> +		return ret; <nl>   <nl>  	next_mem = mem_cgroup_get_first_node(root_mem); <nl>  
@@ -328,7 +328,6 @@ static int vimc_probe(struct platform_device *pdev) <nl>  	if (ret) { <nl>  		media_device_cleanup(&vimc->mdev); <nl>  		vimc_rm_subdevs(vimc); <nl> -		kfree(vimc); <nl>  		return ret; <nl>  	} <nl>  
@@ -159,8 +159,11 @@ static int pn_recvmsg(struct kiocb *iocb, struct sock *sk, <nl>  static int pn_backlog_rcv(struct sock *sk, struct sk_buff *skb) <nl>  { <nl>  	int err = sock_queue_rcv_skb(sk, skb); <nl> -	if (err < 0) <nl> +	if (err < 0) { <nl>  		kfree_skb(skb); <nl> +		if (err == -ENOMEM) <nl> +			atomic_inc(&sk->sk_drops); <nl> +	} <nl>  	return err ? NET_RX_DROP : NET_RX_SUCCESS; <nl>  } <nl>  
@@ -1147,7 +1147,7 @@ int ip6_append_data(struct sock *sk, int getfrag(void *from, char *to, <nl>  			if (WARN_ON(np->cork.opt)) <nl>  				return -EINVAL; <nl>   <nl> -			np->cork.opt = kmalloc(opt->tot_len, sk->sk_allocation); <nl> +			np->cork.opt = kzalloc(opt->tot_len, sk->sk_allocation); <nl>  			if (unlikely(np->cork.opt == NULL)) <nl>  				return -ENOBUFS; <nl>  
@@ -902,6 +902,7 @@ int wpa_ioctl(PSDevice pDevice, struct iw_point *p) <nl>  	default: <nl>  		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "wpa_ioctl: unknown cmd=%d\n", <nl>  			param->cmd); <nl> +		kfree(param); <nl>  		return -EOPNOTSUPP; <nl>  	} <nl>  
@@ -1031,6 +1031,7 @@ static struct pernet_operations dccp_v4_ops = { <nl>  	.init	= dccp_v4_init_net, <nl>  	.exit	= dccp_v4_exit_net, <nl>  	.exit_batch = dccp_v4_exit_batch, <nl> +	.async	= true, <nl>  }; <nl>   <nl>  static int __init dccp_v4_init(void)
@@ -436,7 +436,8 @@ static int bcm_sysport_set_wol(struct net_device *dev, <nl>  	/* Flag the device and relevant IRQ as wakeup capable */ <nl>  	if (wol->wolopts) { <nl>  		device_set_wakeup_enable(kdev, 1); <nl> -		enable_irq_wake(priv->wol_irq); <nl> +		if (priv->wol_irq_disabled) <nl> +			enable_irq_wake(priv->wol_irq); <nl>  		priv->wol_irq_disabled = 0; <nl>  	} else { <nl>  		device_set_wakeup_enable(kdev, 0);
@@ -169,6 +169,16 @@ void radix__mark_rodata_ro(void) <nl>  { <nl>  	unsigned long start, end; <nl>   <nl> +	/* <nl> +	 * mark_rodata_ro() will mark itself as !writable at some point. <nl> +	 * Due to DD1 workaround in radix__pte_update(), we'll end up with <nl> +	 * an invalid pte and the system will crash quite severly. <nl> +	 */ <nl> +	if (cpu_has_feature(CPU_FTR_POWER9_DD1)) { <nl> +		pr_warn("Warning: Unable to mark rodata read only on P9 DD1\n"); <nl> +		return; <nl> +	} <nl> + <nl>  	start = (unsigned long)_stext; <nl>  	end = (unsigned long)__init_begin; <nl>  
@@ -1411,9 +1411,9 @@ void __init pnv_pci_init_ioda1_phb(struct device_node *np) <nl>  	/* Allocate aux data & arrays */ <nl>  	size = _ALIGN_UP(phb->ioda.total_pe / 8, sizeof(unsigned long)); <nl>  	m32map_off = size; <nl> -	size += phb->ioda.total_pe; <nl> +	size += phb->ioda.total_pe * sizeof(phb->ioda.m32_segmap[0]); <nl>  	iomap_off = size; <nl> -	size += phb->ioda.total_pe; <nl> +	size += phb->ioda.total_pe * sizeof(phb->ioda.io_segmap[0]); <nl>  	pemap_off = size; <nl>  	size += phb->ioda.total_pe * sizeof(struct pnv_ioda_pe); <nl>  	aux = alloc_bootmem(size);
@@ -110,6 +110,8 @@ nfp_fl_output(struct nfp_fl_output *output, const struct tc_action *action, <nl>  	 */ <nl>  	if (!switchdev_port_same_parent_id(in_dev, out_dev)) <nl>  		return -EOPNOTSUPP; <nl> +	if (!nfp_netdev_is_nfp_repr(out_dev)) <nl> +		return -EOPNOTSUPP; <nl>   <nl>  	output->port = cpu_to_be32(nfp_repr_get_port_id(out_dev)); <nl>  	if (!output->port)
@@ -272,11 +272,14 @@ static const struct omap_video_timings tpo_td043_timings = { <nl>  static int tpo_td043_power_on(struct tpo_td043_device *tpo_td043) <nl>  { <nl>  	int nreset_gpio = tpo_td043->nreset_gpio; <nl> +	int r; <nl>   <nl>  	if (tpo_td043->powered_on) <nl>  		return 0; <nl>   <nl> -	regulator_enable(tpo_td043->vcc_reg); <nl> +	r = regulator_enable(tpo_td043->vcc_reg); <nl> +	if (r != 0) <nl> +		return r; <nl>   <nl>  	/* wait for regulator to stabilize */ <nl>  	msleep(160);
@@ -1740,7 +1740,10 @@ static int sd_config(struct gspca_dev *gspca_dev, <nl>  		break; <nl>  	} <nl>  	sd->brightness = BRIGHTNESS_DEF; <nl> -	sd->contrast = CONTRAST_DEF; <nl> +	if (sd->sensor == SEN_OV6630 || sd->sensor == SEN_OV66308AF) <nl> +		sd->contrast = 200; /* The default is too low for the ov6630 */ <nl> +	else <nl> +		sd->contrast = CONTRAST_DEF; <nl>  	sd->colors = COLOR_DEF; <nl>  	sd->hflip = HFLIP_DEF; <nl>  	sd->vflip = VFLIP_DEF;
@@ -7054,6 +7054,8 @@ static struct snd_pci_quirk alc883_cfg_tbl[] = { <nl>  	SND_PCI_QUIRK(0x17c0, 0x4071, "MEDION MD2", ALC883_MEDION_MD2), <nl>  	SND_PCI_QUIRK(0x1991, 0x5625, "Haier W66", ALC883_HAIER_W66), <nl>  	SND_PCI_QUIRK(0x17aa, 0x3bfc, "Lenovo NB0763", ALC883_LENOVO_NB0763), <nl> +	SND_PCI_QUIRK(0x1043, 0x8249, "Asus M2A-VM HDMI", ALC883_3ST_6ch_DIG), <nl> +	SND_PCI_QUIRK(0x147b, 0x1083, "Abit IP35-PRO", ALC883_6ST_DIG), <nl>  	{} <nl>  }; <nl>  
@@ -143,7 +143,7 @@ static bool event_compare(struct fsnotify_event *old, struct fsnotify_event *new <nl>  			/* remember, after old was put on the wait_q we aren't <nl>  			 * allowed to look at the inode any more, only thing <nl>  			 * left to check was if the file_name is the same */ <nl> -			if (old->name_len && <nl> +			if (!old->name_len || <nl>  			    !strcmp(old->file_name, new->file_name)) <nl>  				return true; <nl>  			break;
@@ -446,6 +446,11 @@ int iwl_run_init_mvm_ucode(struct iwl_mvm *mvm, bool read_nvm) <nl>  	ret = iwl_nvm_check_version(mvm->nvm_data, mvm->trans); <nl>  	WARN_ON(ret); <nl>   <nl> +	/* Send TX valid antennas before triggering calibrations */ <nl> +	ret = iwl_send_tx_ant_cfg(mvm, mvm->nvm_data->valid_tx_ant); <nl> +	if (ret) <nl> +		goto error; <nl> + <nl>  	/* Override the calibrations from TLV and the const of fw */ <nl>  	iwl_set_default_calib_trigger(mvm); <nl>  
@@ -122,6 +122,8 @@ static const struct mssr_mod_clk r8a7795_mod_clks[] __initconst = { <nl>  	DEF_MOD("scif2",		 310,	R8A7795_CLK_S3D4), <nl>  	DEF_MOD("pcie1",		 318,	R8A7795_CLK_S3D1), <nl>  	DEF_MOD("pcie0",		 319,	R8A7795_CLK_S3D1), <nl> +	DEF_MOD("usb3-if1",		 327,	R8A7795_CLK_S3D1), <nl> +	DEF_MOD("usb3-if0",		 328,	R8A7795_CLK_S3D1), <nl>  	DEF_MOD("intc-ap",		 408,	R8A7795_CLK_S3D1), <nl>  	DEF_MOD("audmac0",		 502,	R8A7795_CLK_S3D4), <nl>  	DEF_MOD("audmac1",		 501,	R8A7795_CLK_S3D4),
@@ -976,6 +976,7 @@ static enum print_line_t trace_ctxwake_bin(struct trace_iterator *iter, <nl>  	SEQ_PUT_FIELD_RET(s, field->prev_pid); <nl>  	SEQ_PUT_FIELD_RET(s, field->prev_prio); <nl>  	SEQ_PUT_FIELD_RET(s, field->prev_state); <nl> +	SEQ_PUT_FIELD_RET(s, field->next_cpu); <nl>  	SEQ_PUT_FIELD_RET(s, field->next_pid); <nl>  	SEQ_PUT_FIELD_RET(s, field->next_prio); <nl>  	SEQ_PUT_FIELD_RET(s, field->next_state);
@@ -792,6 +792,12 @@ int netpoll_setup(struct netpoll *np) <nl>  		return -ENODEV; <nl>  	} <nl>   <nl> +	if (ndev->master) { <nl> +		printk(KERN_ERR "%s: %s is a slave device, aborting.\n", <nl> +		       np->name, np->dev_name); <nl> +		return -EBUSY; <nl> +	} <nl> + <nl>  	if (!netif_running(ndev)) { <nl>  		unsigned long atmost, atleast; <nl>  
@@ -30,6 +30,7 @@ <nl>  #include <linux/ratelimit.h> <nl>  #include <linux/uuid.h> <nl>  #include <linux/semaphore.h> <nl> +#include <linux/bpf.h> <nl>  #include <asm/unaligned.h> <nl>  #include "ctree.h" <nl>  #include "disk-io.h" <nl> @@ -3123,6 +3124,7 @@ int open_ctree(struct super_block *sb, <nl>  		goto fail_block_groups; <nl>  	goto retry_root_backup; <nl>  } <nl> +BPF_ALLOW_ERROR_INJECTION(open_ctree); <nl>   <nl>  static void btrfs_end_buffer_write_sync(struct buffer_head *bh, int uptodate) <nl>  {
@@ -61,7 +61,10 @@ static int mn88472_set_frontend(struct dvb_frontend *fe) <nl>  	switch (c->delivery_system) { <nl>  	case SYS_DVBT: <nl>  	case SYS_DVBT2: <nl> -		if (c->bandwidth_hz <= 6000000) { <nl> +		if (c->bandwidth_hz <= 5000000) { <nl> +			memcpy(bw_val, "\xe5\x99\x9a\x1b\xa9\x1b\xa9", 7); <nl> +			bw_val2 = 0x03; <nl> +		} else if (c->bandwidth_hz <= 6000000) { <nl>  			/* IF 3570000 Hz, BW 6000000 Hz */ <nl>  			memcpy(bw_val, "\xbf\x55\x55\x15\x6b\x15\x6b", 7); <nl>  			bw_val2 = 0x02;
@@ -166,6 +166,9 @@ static int rsi_usb_reg_read(struct usb_device *usbdev, <nl>  	if (!buf) <nl>  		return status; <nl>   <nl> +	if (len > RSI_USB_CTRL_BUF_SIZE) <nl> +		return -EINVAL; <nl> + <nl>  	status = usb_control_msg(usbdev, <nl>  				 usb_rcvctrlpipe(usbdev, 0), <nl>  				 USB_VENDOR_REGISTER_READ, <nl> @@ -208,6 +211,9 @@ static int rsi_usb_reg_write(struct usb_device *usbdev, <nl>  	if (!usb_reg_buf) <nl>  		return status; <nl>   <nl> +	if (len > RSI_USB_CTRL_BUF_SIZE) <nl> +		return -EINVAL; <nl> + <nl>  	usb_reg_buf[0] = (value & 0x00ff); <nl>  	usb_reg_buf[1] = (value & 0xff00) >> 8; <nl>  	usb_reg_buf[2] = 0x0;
@@ -4314,6 +4314,13 @@ int x86_decode_insn(struct x86_emulate_ctxt *ctxt, void *insn, int insn_len) <nl>  	if (ctxt->d & ModRM) <nl>  		ctxt->modrm = insn_fetch(u8, ctxt); <nl>   <nl> +	/* vex-prefix instructions are not implemented */ <nl> +	if (ctxt->opcode_len == 1 && (ctxt->b == 0xc5 || ctxt->b == 0xc4) && <nl> +	    (mode == X86EMUL_MODE_PROT64 || <nl> +	    (mode >= X86EMUL_MODE_PROT16 && (ctxt->modrm & 0x80)))) { <nl> +		ctxt->d = NotImpl; <nl> +	} <nl> + <nl>  	while (ctxt->d & GroupMask) { <nl>  		switch (ctxt->d & GroupMask) { <nl>  		case Group:
@@ -529,7 +529,7 @@ int ttpci_budget_init(struct budget *budget, struct saa7146_dev *dev, <nl>  	if (bi->type != BUDGET_FS_ACTIVY) <nl>  		saa7146_setgpio(dev, 2, SAA7146_GPIO_OUTHI); <nl>   <nl> -	if (budget_register(budget) == 0) <nl> +	if ((ret = budget_register(budget)) == 0) <nl>  		return 0; /* Everything OK */ <nl>   <nl>  	/* An error occurred, cleanup resources */
@@ -218,6 +218,8 @@ static int atmci_regs_show(struct seq_file *s, void *v) <nl>  	atmci_show_status_reg(s, "SR", buf[MCI_SR / 4]); <nl>  	atmci_show_status_reg(s, "IMR", buf[MCI_IMR / 4]); <nl>   <nl> +	kfree(buf); <nl> + <nl>  	return 0; <nl>  } <nl>  
@@ -107,6 +107,7 @@ static void scsi_disk_release(struct device *cdev); <nl>  static void sd_print_sense_hdr(struct scsi_disk *, struct scsi_sense_hdr *); <nl>  static void sd_print_result(struct scsi_disk *, int); <nl>   <nl> +static DEFINE_SPINLOCK(sd_index_lock); <nl>  static DEFINE_IDA(sd_index_ida); <nl>   <nl>  /* This semaphore is used to mediate the 0->1 reference get in the <nl> @@ -1914,7 +1915,9 @@ static int sd_probe(struct device *dev) <nl>  		if (!ida_pre_get(&sd_index_ida, GFP_KERNEL)) <nl>  			goto out_put; <nl>   <nl> +		spin_lock(&sd_index_lock); <nl>  		error = ida_get_new(&sd_index_ida, &index); <nl> +		spin_unlock(&sd_index_lock); <nl>  	} while (error == -EAGAIN); <nl>   <nl>  	if (error) <nl> @@ -1936,7 +1939,9 @@ static int sd_probe(struct device *dev) <nl>  	return 0; <nl>   <nl>   out_free_index: <nl> +	spin_lock(&sd_index_lock); <nl>  	ida_remove(&sd_index_ida, index); <nl> +	spin_unlock(&sd_index_lock); <nl>   out_put: <nl>  	put_disk(gd); <nl>   out_free: <nl> @@ -1986,7 +1991,9 @@ static void scsi_disk_release(struct device *dev) <nl>  	struct scsi_disk *sdkp = to_scsi_disk(dev); <nl>  	struct gendisk *disk = sdkp->disk; <nl>  	 <nl> +	spin_lock(&sd_index_lock); <nl>  	ida_remove(&sd_index_ida, sdkp->index); <nl> +	spin_unlock(&sd_index_lock); <nl>   <nl>  	disk->private_data = NULL; <nl>  	put_disk(disk);
@@ -230,8 +230,8 @@ static void cpu_ready_for_interrupts(void) <nl>  	 * If we are not in hypervisor mode the job is done once for <nl>  	 * the whole partition in configure_exceptions(). <nl>  	 */ <nl> -	if (early_cpu_has_feature(CPU_FTR_HVMODE) && <nl> -	    early_cpu_has_feature(CPU_FTR_ARCH_207S)) { <nl> +	if (cpu_has_feature(CPU_FTR_HVMODE) && <nl> +	    cpu_has_feature(CPU_FTR_ARCH_207S)) { <nl>  		unsigned long lpcr = mfspr(SPRN_LPCR); <nl>  		mtspr(SPRN_LPCR, lpcr | LPCR_AIL_3); <nl>  	}
@@ -77,6 +77,9 @@ bool ieee80211_set_channel_type(struct ieee80211_local *local, <nl>  		switch (tmp->vif.bss_conf.channel_type) { <nl>  		case NL80211_CHAN_NO_HT: <nl>  		case NL80211_CHAN_HT20: <nl> +			if (superchan > tmp->vif.bss_conf.channel_type) <nl> +				break; <nl> + <nl>  			superchan = tmp->vif.bss_conf.channel_type; <nl>  			break; <nl>  		case NL80211_CHAN_HT40PLUS:
@@ -1590,6 +1590,10 @@ static int ath10k_abort_scan(struct ath10k *ar) <nl>  	ret = ath10k_wmi_stop_scan(ar, &arg); <nl>  	if (ret) { <nl>  		ath10k_warn("could not submit wmi stop scan (%d)\n", ret); <nl> +		spin_lock_bh(&ar->data_lock); <nl> +		ar->scan.in_progress = false; <nl> +		ath10k_offchan_tx_purge(ar); <nl> +		spin_unlock_bh(&ar->data_lock); <nl>  		return -EIO; <nl>  	} <nl>  
@@ -90,6 +90,12 @@ masquerade_target(struct sk_buff **pskb, <nl>  	IP_NF_ASSERT(ct && (ctinfo == IP_CT_NEW || ctinfo == IP_CT_RELATED <nl>  	                    || ctinfo == IP_CT_RELATED + IP_CT_IS_REPLY)); <nl>   <nl> +	/* Source address is 0.0.0.0 - locally generated packet that is <nl> +	 * probably not supposed to be masqueraded. <nl> +	 */ <nl> +	if (ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.ip == 0) <nl> +		return NF_ACCEPT; <nl> + <nl>  	mr = targinfo; <nl>  	rt = (struct rtable *)(*pskb)->dst; <nl>  	newsrc = inet_select_addr(out, rt->rt_gateway, RT_SCOPE_UNIVERSE);
@@ -211,6 +211,7 @@ void unregister_shrinker(struct shrinker *shrinker) <nl>  	down_write(&shrinker_rwsem); <nl>  	list_del(&shrinker->list); <nl>  	up_write(&shrinker_rwsem); <nl> +	kfree(shrinker->nr_deferred); <nl>  } <nl>  EXPORT_SYMBOL(unregister_shrinker); <nl>  
@@ -80,8 +80,8 @@ void exit_io_context(void) <nl>  			ioc->aic->exit(ioc->aic); <nl>  		cfq_exit(ioc); <nl>   <nl> -		put_io_context(ioc); <nl>  	} <nl> +	put_io_context(ioc); <nl>  } <nl>   <nl>  struct io_context *alloc_io_context(gfp_t gfp_flags, int node)
@@ -2884,6 +2884,13 @@ mwifiex_cmd_append_vsie_tlv(struct mwifiex_private *priv, <nl>  			vs_param_set->header.len = <nl>  				cpu_to_le16((((u16) priv->vs_ie[id].ie[1]) <nl>  				& 0x00FF) + 2); <nl> +			if (le16_to_cpu(vs_param_set->header.len) > <nl> +				MWIFIEX_MAX_VSIE_LEN) { <nl> +				mwifiex_dbg(priv->adapter, ERROR, <nl> +					    "Invalid param length!\n"); <nl> +				break; <nl> +			} <nl> + <nl>  			memcpy(vs_param_set->ie, priv->vs_ie[id].ie, <nl>  			       le16_to_cpu(vs_param_set->header.len)); <nl>  			*buffer += le16_to_cpu(vs_param_set->header.len) +
@@ -447,8 +447,10 @@ static void icmp6_send(struct sk_buff *skb, u8 type, u8 code, __u32 info, <nl>   <nl>  	if (__ipv6_addr_needs_scope_id(addr_type)) <nl>  		iif = skb->dev->ifindex; <nl> -	else <nl> -		iif = l3mdev_master_ifindex(skb_dst(skb)->dev); <nl> +	else { <nl> +		dst = skb_dst(skb); <nl> +		iif = l3mdev_master_ifindex(dst ? dst->dev : skb->dev); <nl> +	} <nl>   <nl>  	/* <nl>  	 *	Must not send error if the source does not uniquely
@@ -411,9 +411,7 @@ static inline struct dentry *ovl_lookup_real(struct dentry *dir, <nl>  { <nl>  	struct dentry *dentry; <nl>   <nl> -	inode_lock(dir->d_inode); <nl> -	dentry = lookup_one_len(name->name, dir, name->len); <nl> -	inode_unlock(dir->d_inode); <nl> +	dentry = lookup_hash(name, dir); <nl>   <nl>  	if (IS_ERR(dentry)) { <nl>  		if (PTR_ERR(dentry) == -ENOENT)
@@ -416,7 +416,10 @@ int ip_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt, <nl>  		goto inhdr_error; <nl>   <nl>  	len = ntohs(iph->tot_len); <nl> -	if (skb->len < len || len < (iph->ihl*4)) <nl> +	if (skb->len < len) { <nl> +		IP_INC_STATS_BH(IPSTATS_MIB_INTRUNCATEDPKTS); <nl> +		goto drop; <nl> +	} else if (len < (iph->ihl*4)) <nl>  		goto inhdr_error; <nl>   <nl>  	/* Our transport medium may have padded the buffer out. Now we know it
@@ -1257,6 +1257,7 @@ static void iwl_req_fw_callback(const struct firmware *ucode_raw, void *context) <nl>  				op->name, err); <nl>  #endif <nl>  	} <nl> +	kfree(pieces); <nl>  	return; <nl>   <nl>   try_again:
@@ -226,7 +226,7 @@ static ssize_t gt_max_freq_mhz_show(struct device *kdev, struct device_attribute <nl>  	int ret; <nl>   <nl>  	mutex_lock(&dev_priv->rps.hw_lock); <nl> -	ret = dev_priv->rps.hw_max * GT_FREQUENCY_MULTIPLIER; <nl> +	ret = dev_priv->rps.max_delay * GT_FREQUENCY_MULTIPLIER; <nl>  	mutex_unlock(&dev_priv->rps.hw_lock); <nl>   <nl>  	return snprintf(buf, PAGE_SIZE, "%d\n", ret);
@@ -1442,6 +1442,8 @@ static int do_prlimit(struct task_struct *tsk, unsigned int resource, <nl>   <nl>  	if (resource >= RLIM_NLIMITS) <nl>  		return -EINVAL; <nl> +	resource = array_index_nospec(resource, RLIM_NLIMITS); <nl> + <nl>  	if (new_rlim) { <nl>  		if (new_rlim->rlim_cur > new_rlim->rlim_max) <nl>  			return -EINVAL;
@@ -552,6 +552,7 @@ struct block_device *bdget(dev_t dev) <nl>   <nl>  	if (inode->i_state & I_NEW) { <nl>  		bdev->bd_contains = NULL; <nl> +		bdev->bd_super = NULL; <nl>  		bdev->bd_inode = inode; <nl>  		bdev->bd_block_size = (1 << inode->i_blkbits); <nl>  		bdev->bd_part_count = 0;
@@ -6518,7 +6518,7 @@ static int __devinit snd_hdspm_create(struct snd_card *card, <nl>  			hdspm->io_type = AES32; <nl>  			hdspm->card_name = "RME AES32"; <nl>  			hdspm->midiPorts = 2; <nl> -		} else if ((hdspm->firmware_rev == 0xd5) || <nl> +		} else if ((hdspm->firmware_rev == 0xd2) || <nl>  			((hdspm->firmware_rev >= 0xc8)  && <nl>  				(hdspm->firmware_rev <= 0xcf))) { <nl>  			hdspm->io_type = MADI;
@@ -134,9 +134,9 @@ static void set_truncation( <nl>  	REG_UPDATE_3(FMT_BIT_DEPTH_CONTROL, <nl>  				FMT_TRUNCATE_EN, 1, <nl>  				FMT_TRUNCATE_DEPTH, <nl> -				params->flags.TRUNCATE_MODE, <nl> +				params->flags.TRUNCATE_DEPTH, <nl>  				FMT_TRUNCATE_MODE, <nl> -				params->flags.TRUNCATE_DEPTH); <nl> +				params->flags.TRUNCATE_MODE); <nl>  } <nl>   <nl>  
@@ -37,7 +37,7 @@ struct vm_area_struct *vb2_get_vma(struct vm_area_struct *vma) <nl>  { <nl>  	struct vm_area_struct *vma_copy; <nl>   <nl> -	vma_copy = kmalloc(sizeof(*vma_copy), GFP_KERNEL); <nl> +	vma_copy = kmem_cache_alloc(vm_area_cachep, GFP_KERNEL); <nl>  	if (vma_copy == NULL) <nl>  		return NULL; <nl>   <nl> @@ -75,7 +75,7 @@ void vb2_put_vma(struct vm_area_struct *vma) <nl>  	if (vma->vm_file) <nl>  		fput(vma->vm_file); <nl>   <nl> -	kfree(vma); <nl> +	kmem_cache_free(vm_area_cachep, vma); <nl>  } <nl>  EXPORT_SYMBOL_GPL(vb2_put_vma); <nl>  
@@ -1618,6 +1618,7 @@ static int snd_timer_user_tselect(struct file *file, <nl>  	if (err < 0) <nl>  		goto __err; <nl>   <nl> +	tu->qhead = tu->qtail = tu->qused = 0; <nl>  	kfree(tu->queue); <nl>  	tu->queue = NULL; <nl>  	kfree(tu->tqueue);
@@ -178,6 +178,7 @@ static void nvmet_execute_identify_ctrl(struct nvmet_req *req) <nl>  	id->vid = 0; <nl>  	id->ssvid = 0; <nl>   <nl> +	memset(id->sn, ' ', sizeof(id->sn)); <nl>  	bin2hex(id->sn, &ctrl->subsys->serial, <nl>  		min(sizeof(ctrl->subsys->serial), sizeof(id->sn) / 2)); <nl>  	memcpy_and_pad(id->mn, sizeof(id->mn), model, sizeof(model) - 1, ' ');
@@ -207,6 +207,7 @@ void * ulfius_uri_logger (void * cls, const char * uri) { <nl>    UNUSED(cls); <nl>   <nl>    if (con_info != NULL) { <nl> +    memset(con_info, 0, sizeof(struct connection_info_struct)); <nl>      con_info->callback_first_iteration = 1; <nl>      con_info->u_instance = NULL; <nl>      u_map_init(&con_info->map_url_initial); <nl> @@ -217,7 +218,8 @@ void * ulfius_uri_logger (void * cls, const char * uri) { <nl>        return NULL; <nl>      } <nl>   <nl> -    if (NULL == con_info->request || ulfius_init_request(con_info->request) != U_OK) { <nl> +    if (ulfius_init_request(con_info->request) != U_OK) { <nl> +      y_log_message(Y_LOG_LEVEL_ERROR, "Ulfius - Error initializing con_info->request"); <nl>        ulfius_clean_request_full(con_info->request); <nl>        o_free(con_info); <nl>        return NULL; <nl> @@ -433,7 +435,6 @@ static int ulfius_webservice_dispatcher (void * cls, <nl>                                           size_t * upload_data_size, <nl>                                           void ** con_cls) { <nl>  #endif <nl> - <nl>    struct _u_endpoint * endpoint_list = ((struct _u_instance *)cls)->endpoint_list, ** current_endpoint_list = NULL, * current_endpoint = NULL; <nl>    struct connection_info_struct * con_info = * con_cls; <nl>    int mhd_ret = MHD_NO, callback_ret = U_OK, i, close_loop = 0, inner_error = U_OK, mhd_response_flag;
@@ -510,8 +510,8 @@ void mobi_buffer_move(MOBIBuffer *buf, const int offset, const size_t len) { <nl>          } <nl>          source += aoffset; <nl>      } else { <nl> -        if (buf->offset < aoffset) { <nl> -            debug_print("%s", "End of buffer\n"); <nl> +        if ( (buf->offset < aoffset) || (buf->offset + len > buf->maxlen) ) { <nl> +            debug_print("%s", "Beyond start/end of buffer\n"); <nl>              buf->error = MOBI_BUFFER_END; <nl>              return; <nl>          }
@@ -289,8 +289,9 @@ bool CPlayListASX::LoadData(std::istream& stream) <nl>    } <nl>    else <nl>    { <nl> +    std::string asxstream(std::istreambuf_iterator<char>(stream), {}); <nl>      CXBMCTinyXML xmlDoc; <nl> -    stream >> xmlDoc; <nl> +    xmlDoc.Parse(asxstream, TIXML_DEFAULT_ENCODING); <nl>   <nl>      if (xmlDoc.Error()) <nl>      { <nl> @@ -300,6 +301,9 @@ bool CPlayListASX::LoadData(std::istream& stream) <nl>   <nl>      TiXmlElement *pRootElement = xmlDoc.RootElement(); <nl>   <nl> +    if (!pRootElement) <nl> +      return false; <nl> + <nl>      // lowercase every element <nl>      TiXmlNode *pNode = pRootElement; <nl>      TiXmlNode *pChild = NULL;
@@ -747,7 +747,9 @@ fribidi_get_par_embedding_levels_ex ( <nl>              } <nl>   <nl>  	  RL_LEVEL (pp) = level; <nl> -          RL_ISOLATE_LEVEL (pp) = isolate_level++; <nl> +          RL_ISOLATE_LEVEL (pp) = isolate_level; <nl> +          if (isolate_level < FRIBIDI_BIDI_MAX_EXPLICIT_LEVEL-1) <nl> +              isolate_level++; <nl>            base_level_per_iso_level[isolate_level] = new_level; <nl>   <nl>  	  if (!FRIBIDI_IS_NEUTRAL (override))
@@ -469,6 +469,7 @@ _gnutls_x509_dn_to_string(const char *oid, void *value, <nl>  		if (ret < 0) { <nl>  			gnutls_assert(); <nl>  			gnutls_free(str->data); <nl> +			str->data = NULL; <nl>  			return ret; <nl>  		} <nl>  		str->size = size;
@@ -518,6 +518,7 @@ u32 cdk_pk_get_keyid(cdk_pubkey_t pk, u32 * keyid) <nl>  { <nl>  	u32 lowbits = 0; <nl>  	byte buf[24]; <nl> +	int rc; <nl>   <nl>  	if (pk && (!pk->keyid[0] || !pk->keyid[1])) { <nl>  		if (pk->version < 4 && is_RSA(pk->pubkey_algo)) { <nl> @@ -525,7 +526,12 @@ u32 cdk_pk_get_keyid(cdk_pubkey_t pk, u32 * keyid) <nl>  			size_t n; <nl>   <nl>  			n = MAX_MPI_BYTES; <nl> -			_gnutls_mpi_print(pk->mpi[0], p, &n); <nl> +			rc = _gnutls_mpi_print(pk->mpi[0], p, &n); <nl> +			if (rc < 0 || n < 8) { <nl> +				keyid[0] = keyid[1] = (u32)-1; <nl> +				return (u32)-1; <nl> +			} <nl> + <nl>  			pk->keyid[0] = <nl>  			    p[n - 8] << 24 | p[n - 7] << 16 | p[n - <nl>  								6] << 8 |
@@ -104,11 +104,12 @@ void *UntrustedCacheMalloc::GetBuffer() { <nl>        buffers = <nl>            primitives::AllocateUntrustedBuffers(kPoolIncrement, kPoolEntrySize); <nl>        for (int i = 0; i < kPoolIncrement; i++) { <nl> -        if (!buffers[i] || <nl> -            !TrustedPrimitives::IsOutsideEnclave(buffers[i], kPoolEntrySize)) { <nl> -          abort(); <nl> +        void *buf = buffers[i]; <nl> +        if (!buf || !TrustedPrimitives::IsOutsideEnclave(buf, kPoolEntrySize)) { <nl> +          TrustedPrimitives::BestEffortAbort( <nl> +              "Cached buffer is not outside the enclave"); <nl>          } <nl> -        buffer_pool_.push(buffers[i]); <nl> +        buffer_pool_.push(buf); <nl>        } <nl>      } <nl>      buffer = buffer_pool_.top();
@@ -822,6 +822,11 @@ ssize_t enc_untrusted_recvmsg(int sockfd, struct msghdr *msg, int flags) { <nl>      return result; <nl>    } <nl>   <nl> +  if (result > total_buffer_size) { <nl> +    ::asylo::primitives::TrustedPrimitives::BestEffortAbort( <nl> +        "enc_untrusted_recvmsg: result exceeds requested"); <nl> +  } <nl> + <nl>    auto msg_name_extent = output.next(); <nl>    // The returned |msg_namelen| should not exceed the buffer size. <nl>    if (msg_name_extent.size() <= msg->msg_namelen) {
@@ -2011,9 +2011,14 @@ static char txt_no_note[] = "No note in voice overlay"; <nl>  			error(1, s, "Erroneous end of voice overlap"); <nl>  			return; <nl>  		} <nl> -		if (p_voice->time != over_mxtime) <nl> -			error(1, s, tx_wrong_dur); <nl>  		curvoice = &voice_tb[over_voice]; <nl> +		if (p_voice->time != over_mxtime) { <nl> +			error(1, s, tx_wrong_dur); <nl> +			if (p_voice->time > over_mxtime) <nl> +				curvoice->time = p_voice->time; <nl> +			else <nl> +				p_voice->time = curvoice->time; <nl> +		} <nl>  		over_mxtime = 0; <nl>  		over_voice = -1; <nl>  		over_time = -1;
@@ -342,6 +342,8 @@ Status DecodeImageAPNG(Span<const uint8_t> bytes, ThreadPool* pool, <nl>            dop = chunk.p[32]; <nl>            bop = chunk.p[33]; <nl>   <nl> +          if (!delay_den) delay_den = 100; <nl> + <nl>            if (w0 > cMaxPNGSize || h0 > cMaxPNGSize || x0 > cMaxPNGSize || <nl>                y0 > cMaxPNGSize || x0 + w0 > w || y0 + h0 > h || dop > 2 || <nl>                bop > 1) {
@@ -1169,6 +1169,11 @@ SWFShape_setLeftFillStyle(SWFShape shape, SWFFillStyle fill) <nl>  			return;		 <nl>  		idx = getFillIdx(shape, fill); <nl>  	} <nl> +	else if (idx >= 255 && shape->useVersion == SWF_SHAPE1) <nl> +	{ <nl> +		SWF_error("Too many fills for SWFShape V1.\n"  <nl> +			  "Use a higher SWFShape version\n"); <nl> +	} <nl>  				 <nl>  	record = addStyleRecord(shape); <nl>  	record.record.stateChange->leftFill = idx;
@@ -245,13 +245,12 @@ static int stackinuse (lua_State *L) { <nl>   <nl>  void luaD_shrinkstack (lua_State *L) { <nl>    int inuse = stackinuse(L); <nl> -  int goodsize = inuse + (inuse / 8) + 2*EXTRA_STACK; <nl> +  int goodsize = inuse + BASIC_STACK_SIZE; <nl>    if (goodsize > LUAI_MAXSTACK) <nl>      goodsize = LUAI_MAXSTACK;  /* respect stack limit */ <nl>    /* if thread is currently not handling a stack overflow and its <nl>       good size is smaller than current size, shrink its stack */ <nl> -  if (inuse <= (LUAI_MAXSTACK - EXTRA_STACK) && <nl> -      goodsize < L->stacksize) <nl> +  if (inuse <= (LUAI_MAXSTACK - EXTRA_STACK) && goodsize < L->stacksize) <nl>      luaD_reallocstack(L, goodsize, 0);  /* ok if that fails */ <nl>    else  /* don't change stack */ <nl>      condmovestack(L,{},{});  /* (change only for debugging) */
@@ -1131,16 +1131,14 @@ static void finishgencycle (lua_State *L, global_State *g) { <nl>   <nl>   <nl>  /* <nl> -** Does a young collection. First, mark 'OLD1' objects.  (Only survival <nl> -** and "recent old" lists can contain 'OLD1' objects. New lists cannot <nl> -** contain 'OLD1' objects, at most 'OLD0' objects that were already <nl> -** visited when marked old.) Then does the atomic step. Then, <nl> -** sweep all lists and advance pointers. Finally, finish the collection. <nl> +** Does a young collection. First, mark 'OLD1' objects. Then does the <nl> +** atomic step. Then, sweep all lists and advance pointers. Finally, <nl> +** finish the collection. <nl>  */ <nl>  static void youngcollection (lua_State *L, global_State *g) { <nl>    GCObject **psurvival;  /* to point to first non-dead survival object */ <nl>    lua_assert(g->gcstate == GCSpropagate); <nl> -  markold(g, g->survival, g->reallyold); <nl> +  markold(g, g->allgc, g->reallyold); <nl>    markold(g, g->finobj, g->finobjrold); <nl>    atomic(L); <nl>  
@@ -464,14 +464,17 @@ static bool checkreturn decode_static_field(pb_istream_t *stream, pb_wire_type_t <nl>              } <nl>   <nl>          case PB_HTYPE_ONEOF: <nl> -            *(pb_size_t*)iter->pSize = iter->pos->tag; <nl> -            if (PB_LTYPE(type) == PB_LTYPE_SUBMESSAGE) <nl> +            if (PB_LTYPE(type) == PB_LTYPE_SUBMESSAGE && <nl> +                *(pb_size_t*)iter->pSize != iter->pos->tag) <nl>              { <nl>                  /* We memset to zero so that any callbacks are set to NULL. <nl> -                 * Then set any default values. */ <nl> +                 * This is because the callbacks might otherwise have values <nl> +                 * from some other union field. */ <nl>                  memset(iter->pData, 0, iter->pos->data_size); <nl>                  pb_message_set_to_defaults((const pb_field_t*)iter->pos->ptr, iter->pData); <nl>              } <nl> +            *(pb_size_t*)iter->pSize = iter->pos->tag; <nl> + <nl>              return func(stream, iter->pos, iter->pData); <nl>   <nl>          default:
@@ -169,6 +169,11 @@ static inline void handle_socket_receive_known( <nl>   <nl>  	case PACKET_HANDSHAKE: <nl>  		fastd_handshake_handle(sock, local_addr, remote_addr, peer, buffer); <nl> +		break; <nl> + <nl> +	default: <nl> +		fastd_buffer_free(buffer); <nl> +		pr_debug("received packet with invalid type from %P[%I]", peer, remote_addr); <nl>  	} <nl>  } <nl>   <nl> @@ -195,6 +200,11 @@ static inline void handle_socket_receive_unknown( <nl>   <nl>  	case PACKET_HANDSHAKE: <nl>  		fastd_handshake_handle(sock, local_addr, remote_addr, NULL, buffer); <nl> +		break; <nl> + <nl> +	default: <nl> +		fastd_buffer_free(buffer); <nl> +		pr_debug("received packet with invalid type from unknown address %I", remote_addr); <nl>  	} <nl>  } <nl>  
@@ -623,6 +623,12 @@ ngx_http_send_error_page(ngx_http_request_t *r, ngx_http_err_page_t *err_page) <nl>          return ngx_http_named_location(r, &uri); <nl>      } <nl>   <nl> +    r->expect_tested = 1; <nl> + <nl> +    if (ngx_http_discard_request_body(r) != NGX_OK) { <nl> +        r->keepalive = 0; <nl> +    } <nl> + <nl>      location = ngx_list_push(&r->headers_out.headers); <nl>   <nl>      if (location == NULL) {
@@ -4807,29 +4807,34 @@ u_int32_t ndpi_bytestream_to_ipv4(const u_int8_t *str, u_int16_t max_chars_to_re <nl>    u_int16_t read = 0; <nl>    u_int16_t oldread; <nl>    u_int32_t c; <nl> + <nl>    /* ip address must be X.X.X.X with each X between 0 and 255 */ <nl>    oldread = read; <nl>    c = ndpi_bytestream_to_number(str, max_chars_to_read, &read); <nl>    if(c > 255 || oldread == read || max_chars_to_read == read || str[read] != '.') <nl>      return(0); <nl> +   <nl>    read++; <nl>    val = c << 24; <nl>    oldread = read; <nl>    c = ndpi_bytestream_to_number(&str[read], max_chars_to_read - read, &read); <nl>    if(c > 255 || oldread == read || max_chars_to_read == read || str[read] != '.') <nl>      return(0); <nl> +   <nl>    read++; <nl>    val = val + (c << 16); <nl>    oldread = read; <nl>    c = ndpi_bytestream_to_number(&str[read], max_chars_to_read - read, &read); <nl>    if(c > 255 || oldread == read || max_chars_to_read == read || str[read] != '.') <nl>      return(0); <nl> +   <nl>    read++; <nl>    val = val + (c << 8); <nl>    oldread = read; <nl>    c = ndpi_bytestream_to_number(&str[read], max_chars_to_read - read, &read); <nl>    if(c > 255 || oldread == read || max_chars_to_read == read) <nl>      return(0); <nl> +   <nl>    val = val + c; <nl>   <nl>    *bytes_read = *bytes_read + read; <nl> @@ -4869,9 +4874,10 @@ void ndpi_parse_packet_line_info(struct ndpi_detection_module_struct *ndpi_str, <nl>  	int diff; /* No unsigned ! */ <nl>  	u_int32_t a1 = a + 4; <nl>   <nl> -	diff = ndpi_min(packet->payload_packet_len-a1, sizeof(flow->initial_binary_bytes)); <nl> +	diff = packet->payload_packet_len - a1; <nl>   <nl>  	if(diff > 0) { <nl> +	  diff = ndpi_min(diff, sizeof(flow->initial_binary_bytes)); <nl>  	  memcpy(&flow->initial_binary_bytes, &packet->payload[a1], diff); <nl>  	  flow->initial_binary_bytes_len = diff; <nl>  	}
@@ -302,6 +302,15 @@ static int SetupSavePath(const DetectEngineCtx *de_ctx, <nl>  { <nl>      SCLogDebug("save %s", save); <nl>   <nl> +    int allow_save = 1; <nl> +    if (ConfGetBool("datasets.rules.allow-write", &allow_save)) { <nl> +        if (!allow_save) { <nl> +            SCLogError(SC_ERR_INVALID_SIGNATURE, <nl> +                    "Rules containing save/state datasets have been disabled"); <nl> +            return -1; <nl> +        } <nl> +    } <nl> + <nl>      int allow_absolute = 0; <nl>      (void)ConfGetBool("datasets.rules.allow-absolute-filenames", &allow_absolute); <nl>      if (allow_absolute) {
@@ -366,7 +366,8 @@ int delete_sdp_line( struct sip_msg * msg, char * s, struct sdp_stream_cell *str <nl>   <nl>  	while(*end != '\n' && end < (stream->body.s+stream->body.len) ) <nl>  		end++; <nl> -	end++; <nl> +	if ( *end == '\n') <nl> +		end++; <nl>   <nl>  	/* delete the entry */ <nl>  	if( del_lump(msg, start - msg->buf, end - start,0) == NULL )
@@ -559,7 +559,7 @@ static int stream_process(struct sip_msg * msg, struct sdp_stream_cell *cell, <nl>  					/* when trimming the very last payload, avoid trailing ws */ <nl>  					if (cur == lmp->u.value + lmp->len) { <nl>  						tmp = found.s; <nl> -						while (*(--tmp) == ' ') { <nl> +						while (tmp>lmp->u.value && *(--tmp) == ' ') { <nl>  							found.s--; <nl>  							found.len++; <nl>  						}
@@ -211,11 +211,13 @@ repodata_schema2id(Repodata *data, Id *schema, int create) <nl>    cid = schematahash[h]; <nl>    if (cid) <nl>      { <nl> -      if (!memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id))) <nl> +      if ((data->schemata[cid] + len <= data->schemadatalen) && <nl> +			  !memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id))) <nl>          return cid; <nl>        /* cache conflict, do a slow search */ <nl>        for (cid = 1; cid < data->nschemata; cid++) <nl> -        if (!memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id))) <nl> +        if ((data->schemata[cid] + len <= data->schemadatalen) && <nl> +				!memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id))) <nl>            return cid; <nl>      } <nl>    /* a new one */
@@ -6844,9 +6844,9 @@ while ((c = *p++) != 0) <nl>        } <nl>   <nl>      i = (int32_t)li; <nl> -    if (i-- == 0) <nl> +    if (i-- <= 0) <nl>        { <nl> -      fprintf(outfile, "** Zero repeat not allowed\n"); <nl> +      fprintf(outfile, "** Zero or negative repeat not allowed\n"); <nl>        return PR_OK; <nl>        } <nl>  
@@ -614,7 +614,7 @@ static void ProcessExifDir(unsigned char * DirStart, unsigned char * OffsetBase, <nl>              unsigned OffsetVal; <nl>              OffsetVal = Get32u(DirEntry+8); <nl>              // If its bigger than 4 bytes, the dir entry contains an offset. <nl> -            if (OffsetVal+ByteCount > ExifLength){ <nl> +            if (OffsetVal > UINT32_MAX - ByteCount || OffsetVal+ByteCount > ExifLength){ <nl>                  // Bogus pointer offset and / or bytecount value <nl>                  ErrNonfatal("Illegal value pointer for tag %04x", Tag,0); <nl>                  continue;
@@ -757,8 +757,15 @@ static void parse_rtcp_bye(pjmedia_rtcp_session *sess, <nl>   <nl>      /* Check and get BYE reason */ <nl>      if (size > 8) { <nl> +    	/* Make sure the BYE reason does not exceed: <nl> +    	 * - the size of the available buffer <nl> +    	 * - the declared reason's length <nl> +    	 * - the actual packet size <nl> +    	 */ <nl>  	reason.slen = PJ_MIN(sizeof(sess->stat.peer_sdes_buf_), <nl>                               *((pj_uint8_t*)pkt+8)); <nl> +        reason.slen = PJ_MIN(reason.slen, size-9); <nl> + <nl>  	pj_memcpy(sess->stat.peer_sdes_buf_, ((pj_uint8_t*)pkt+9), <nl>  		  reason.slen); <nl>  	reason.ptr = sess->stat.peer_sdes_buf_;
@@ -438,7 +438,7 @@ typedef struct { <nl>      int (*init)(bt_callbacks_t* callbacks ); <nl>   <nl>      /** Enable Bluetooth. */ <nl> -    int (*enable)(void); <nl> +    int (*enable)(bool guest_mode); <nl>   <nl>      /** Disable Bluetooth. */ <nl>      int (*disable)(void);
@@ -1377,7 +1377,13 @@ native_handle* Parcel::readNativeHandle() const <nl>   <nl>      for (int i=0 ; err==NO_ERROR && i<numFds ; i++) { <nl>          h->data[i] = dup(readFileDescriptor()); <nl> -        if (h->data[i] < 0) err = BAD_VALUE; <nl> +        if (h->data[i] < 0) { <nl> +            for (int j = 0; j < i; j++) { <nl> +                close(h->data[j]); <nl> +            } <nl> +            native_handle_delete(h); <nl> +            return 0; <nl> +        } <nl>      } <nl>      err = read(h->data + numFds, sizeof(int)*numInts); <nl>      if (err != NO_ERROR) {
@@ -100,10 +100,11 @@ out: <nl>  static void print_maps(struct pid_info_t* info) <nl>  { <nl>      FILE *maps; <nl> + <nl>      size_t offset; <nl>      char device[10]; <nl>      long int inode; <nl> -    char file[PATH_MAX]; <nl> +    char file[1024]; <nl>   <nl>      strlcat(info->path, "maps", sizeof(info->path)); <nl>   <nl> @@ -111,8 +112,8 @@ static void print_maps(struct pid_info_t* info) <nl>      if (!maps) <nl>          goto out; <nl>   <nl> -    while (fscanf(maps, "%*x-%*x %*s %zx %s %ld %s\n", &offset, device, &inode, <nl> -            file) == 4) { <nl> +    while (fscanf(maps, "%*x-%*x %*s %zx %5s %ld %1023s\n", <nl> +                  &offset, device, &inode, file) == 4) { <nl>          // We don't care about non-file maps <nl>          if (inode == 0 || !strcmp(device, "00:00")) <nl>              continue;
@@ -63,10 +63,10 @@ static bool get_build_id( <nl>          if (nhdr.n_type == NT_GNU_BUILD_ID) { <nl>            // Skip the name (which is the owner and should be "GNU"). <nl>            addr += NOTE_ALIGN(nhdr.n_namesz); <nl> -          uint8_t build_id_data[128]; <nl> -          if (nhdr.n_namesz > sizeof(build_id_data)) { <nl> -            ALOGE("Possible corrupted note, name size value is too large: %u", <nl> -                  nhdr.n_namesz); <nl> +          uint8_t build_id_data[160]; <nl> +          if (nhdr.n_descsz > sizeof(build_id_data)) { <nl> +            ALOGE("Possible corrupted note, desc size value is too large: %u", <nl> +                  nhdr.n_descsz); <nl>              return false; <nl>            } <nl>            if (backtrace->Read(addr, build_id_data, nhdr.n_descsz) != nhdr.n_descsz) {
@@ -929,6 +929,14 @@ void smp_proc_master_id(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) { <nl>    tBTM_LE_PENC_KEYS le_key; <nl>   <nl>    SMP_TRACE_DEBUG("%s", __func__); <nl> + <nl> +  if (p_cb->rcvd_cmd_len < 11) {  // 1(Code) + 2(EDIV) + 8(Rand) <nl> +    android_errorWriteLog(0x534e4554, "111937027"); <nl> +    SMP_TRACE_ERROR("%s: Invalid command length: %d, should be at least 11", <nl> +                    __func__, p_cb->rcvd_cmd_len); <nl> +    return; <nl> +  } <nl> + <nl>    smp_update_key_mask(p_cb, SMP_SEC_KEY_TYPE_ENC, true); <nl>   <nl>    STREAM_TO_UINT16(le_key.ediv, p);
@@ -381,6 +381,7 @@ void NuPlayer::GenericSource::notifyPreparedAndCleanup(status_t err) { <nl>              { <nl>                  Mutex::Autolock _l(mDisconnectLock); <nl>                  mDataSource.clear(); <nl> +                mDrmManagerClient = NULL; <nl>                  mCachedSource.clear(); <nl>                  mHttpSource.clear(); <nl>              }
@@ -1893,7 +1893,11 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) { <nl>                  size = 0; <nl>              } <nl>   <nl> -            uint8_t *buffer = new (std::nothrow) uint8_t[size + chunk_size]; <nl> +            if (SIZE_MAX - chunk_size <= size) { <nl> +                return ERROR_MALFORMED; <nl> +            } <nl> + <nl> +            uint8_t *buffer = new uint8_t[size + chunk_size]; <nl>              if (buffer == NULL) { <nl>                  return ERROR_MALFORMED; <nl>              }
@@ -1932,6 +1932,10 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) { <nl>              if (mFileMetaData != NULL) { <nl>                  ALOGV("chunk_data_size = %lld and data_offset = %lld", <nl>                          chunk_data_size, data_offset); <nl> + <nl> +                if (chunk_data_size >= SIZE_MAX - 1) { <nl> +                    return ERROR_MALFORMED; <nl> +                } <nl>                  sp<ABuffer> buffer = new ABuffer(chunk_data_size + 1); <nl>                  if (mDataSource->readAt( <nl>                      data_offset, buffer->data(), chunk_data_size) != (ssize_t)chunk_data_size) {
@@ -136,6 +136,8 @@ status_t ESDS::parseESDescriptor(size_t offset, size_t size) { <nl>      --size; <nl>   <nl>      if (streamDependenceFlag) { <nl> +        if (size < 2) <nl> +            return ERROR_MALFORMED; <nl>          offset += 2; <nl>          size -= 2; <nl>      } <nl> @@ -145,11 +147,15 @@ status_t ESDS::parseESDescriptor(size_t offset, size_t size) { <nl>              return ERROR_MALFORMED; <nl>          } <nl>          unsigned URLlength = mData[offset]; <nl> +        if (URLlength >= size) <nl> +            return ERROR_MALFORMED; <nl>          offset += URLlength + 1; <nl>          size -= URLlength + 1; <nl>      } <nl>   <nl>      if (OCRstreamFlag) { <nl> +        if (size < 2) <nl> +            return ERROR_MALFORMED; <nl>          offset += 2; <nl>          size -= 2; <nl>  
@@ -213,8 +213,8 @@ void SoftMPEG4::onQueueFilled(OMX_U32 /* portIndex */) { <nl>              OMX_U32 yFrameSize = sizeof(uint8) * mHandle->size; <nl>              if ((outHeader->nAllocLen < yFrameSize) || <nl>                      (outHeader->nAllocLen - yFrameSize < yFrameSize / 2)) { <nl> -                ALOGE("Too small output buffer for reference frame: %zu bytes", <nl> -                        outHeader->nAllocLen); <nl> +                ALOGE("Too small output buffer for reference frame: %lu bytes", <nl> +                        (unsigned long)outHeader->nAllocLen); <nl>                  android_errorWriteLog(0x534e4554, "30033990"); <nl>                  notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL); <nl>                  mSignalledError = true;
@@ -426,7 +426,7 @@ void QPaintEngineEx::stroke(const QVectorPath &path, const QPen &inPen) <nl>              patternLength *= pen.widthF(); <nl>          if (qFuzzyIsNull(patternLength)) { <nl>              pen.setStyle(Qt::NoPen); <nl> -        } else if (extent / patternLength > 10000) { <nl> +        } else if (qFuzzyIsNull(extent) || extent / patternLength > 10000) { <nl>              // approximate stream of tiny dashes with semi-transparent solid line <nl>              pen.setStyle(Qt::SolidLine); <nl>              QColor color(pen.color());
@@ -401,7 +401,7 @@ void streamGetEdgeID(stream *s, int first, int skip_tombstones, streamID *edge_i <nl>          streamID min_id = {0, 0}, max_id = {UINT64_MAX, UINT64_MAX}; <nl>          *edge_id = first ? max_id : min_id; <nl>      } <nl> - <nl> +    streamIteratorStop(&si); <nl>  } <nl>   <nl>  /* Adds a new item into the stream 's' having the specified number of
@@ -22,6 +22,7 @@ <nl>  #include <errno.h> <nl>  #include <module.h> <nl>  #include <linux/err.h> <nl> +#include <crypto.h> <nl>  #include <crypto/internal.h> <nl>   <nl>  static LIST_HEAD(digests); <nl> @@ -47,8 +48,10 @@ int digest_generic_verify(struct digest *d, const unsigned char *md) <nl>  	if (ret) <nl>  		goto end; <nl>   <nl> -	ret = memcmp(md, tmp, len); <nl> -	ret = ret ? -EINVAL : 0; <nl> +	if (crypto_memneq(md, tmp, len)) <nl> +		ret = -EINVAL; <nl> +	else <nl> +		ret = 0; <nl>  end: <nl>  	free(tmp); <nl>  	return ret;
@@ -258,7 +258,7 @@ static bool MR_primality_test(UnsignedBigInteger n, const Vector<UnsignedBigInte <nl>          return n == 2; <nl>      } <nl>   <nl> -    for (auto a : tests) { <nl> +    for (auto& a : tests) { <nl>          // Technically: ASSERT(2 <= a && a <= n - 2) <nl>          ASSERT(a < n); <nl>          auto x = ModularPower(a, d, n);
@@ -505,11 +505,13 @@ static RList *patch_relocs(RBin *b) { <nl>   <nl>  	size_t nimports = 0; <nl>  	int i; <nl> -	for (i = 0; i < bin->hdr.f_nsyms; i++) { <nl> -		if (is_imported_symbol (&bin->symbols[i])) { <nl> -			nimports++; <nl> +	if (bin->symbols) { <nl> +		for (i = 0; i < bin->hdr.f_nsyms; i++) { <nl> +			if (is_imported_symbol (&bin->symbols[i])) { <nl> +				nimports++; <nl> +			} <nl> +			i += bin->symbols[i].n_numaux; <nl>  		} <nl> -		i += bin->symbols[i].n_numaux; <nl>  	} <nl>  	ut64 m_vaddr = UT64_MAX; <nl>  	if (nimports) {
@@ -138,9 +138,9 @@ R_API bool r_crbtree_insert(RRBTree *tree, void *data, RRBComparator cmp, void * <nl>  	r_return_val_if_fail (tree && data && cmp, false); <nl>  	bool inserted = false; <nl>   <nl> -	if (tree->root == NULL) { <nl> +	if (!tree->root) { <nl>  		tree->root = _node_new (data, NULL); <nl> -		if (tree->root == NULL) { <nl> +		if (!tree->root) { <nl>  			return false; <nl>  		} <nl>  		inserted = true;
@@ -4580,6 +4580,9 @@ void MACH0_(iterate_chained_fixups)(struct MACH0_(obj_t) *bin, ut64 limit_start, <nl>  				if (page_idx >= bin->chained_starts[i]->page_count) { <nl>  					break; <nl>  				} <nl> +				if (!bin->chained_starts[i]->page_start) { <nl> +					break; <nl> +				} <nl>  				ut16 page_start = bin->chained_starts[i]->page_start[page_idx]; <nl>  				if (page_start == DYLD_CHAINED_PTR_START_NONE) { <nl>  					continue;
@@ -3733,6 +3733,10 @@ R_API RBinJavaAttrInfo *r_bin_java_inner_classes_attr_new(RBinJavaObj *bin, ut8 <nl>  	ut64 offset = 0, curpos; <nl>  	attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset); <nl>  	offset += 6; <nl> +	if (buf_offset + offset + 8 > sz) { <nl> +		eprintf ("Invalid amount of inner classes\n"); <nl> +		return NULL; <nl> +	} <nl>  	if (attr == NULL) { <nl>  		// TODO eprintf <nl>  		return attr; <nl> @@ -3743,7 +3747,7 @@ R_API RBinJavaAttrInfo *r_bin_java_inner_classes_attr_new(RBinJavaObj *bin, ut8 <nl>  	attr->info.inner_classes_attr.classes = r_list_newf (r_bin_java_inner_classes_attr_entry_free); <nl>  	for (i = 0; i < attr->info.inner_classes_attr.number_of_classes; i++) { <nl>  		curpos = buf_offset + offset; <nl> -		if (offset + 8 > sz) { <nl> +		if (buf_offset + offset + 8 > sz) { <nl>  			eprintf ("Invalid amount of inner classes\n"); <nl>  			break; <nl>  		}
@@ -5295,10 +5295,6 @@ R_API void r_core_anal_esil(RCore *core, const char *str, const char *target) { <nl>  		arch = R2_ARCH_MIPS; <nl>  	} <nl>   <nl> -	const char *sn = r_reg_get_name (core->anal->reg, R_REG_NAME_SN); <nl> -	if (!sn) { <nl> -		eprintf ("Warning: No SN reg alias for current architecture.\n"); <nl> -	} <nl>  	r_reg_arena_push (core->anal->reg); <nl>   <nl>  	IterCtx ictx = { start, end, fcn, NULL }; <nl> @@ -5409,6 +5405,10 @@ R_API void r_core_anal_esil(RCore *core, const char *str, const char *target) { <nl>  				goto repeat; <nl>  			} <nl>  		} <nl> +		const char *sn = r_reg_get_name (core->anal->reg, R_REG_NAME_SN); <nl> +		if (!sn) { <nl> +			eprintf ("Warning: No SN reg alias for current architecture.\n"); <nl> +		} <nl>  		if (sn && op.type == R_ANAL_OP_TYPE_SWI) { <nl>  			r_strf_buffer (64); <nl>  			r_flag_space_set (core->flags, R_FLAGS_FS_SYSCALLS);
@@ -6933,6 +6933,10 @@ R_API RBinJavaAttrInfo *r_bin_java_bootstrap_methods_attr_new(RBinJavaObj *bin, <nl>  	offset += 6; <nl>  	if (attr) { <nl>  		attr->type = R_BIN_JAVA_ATTR_TYPE_BOOTSTRAP_METHODS_ATTR; <nl> +		if (offset + 8 > sz)  { <nl> +			free (attr); <nl> +			return NULL; <nl> +		} <nl>  		attr->info.bootstrap_methods_attr.num_bootstrap_methods = R_BIN_JAVA_USHORT (buffer, offset); <nl>  		offset += 2; <nl>  		attr->info.bootstrap_methods_attr.bootstrap_methods = r_list_newf (r_bin_java_bootstrap_method_free);
@@ -756,7 +756,7 @@ static int vidioc_querycap(struct file *file, void *priv, <nl>  	__u32 capabilities = V4L2_CAP_STREAMING | V4L2_CAP_READWRITE; <nl>   <nl>  	strlcpy(cap->driver, "v4l2 loopback", sizeof(cap->driver)); <nl> -	snprintf(cap->card, labellen, dev->card_label); <nl> +	snprintf(cap->card, labellen, "%s", dev->card_label); <nl>  	snprintf(cap->bus_info, sizeof(cap->bus_info), <nl>  		 "platform:v4l2loopback-%03d", device_nr); <nl>   <nl> @@ -2494,7 +2494,7 @@ static int v4l2_loopback_add(struct v4l2_loopback_config *conf, int *ret_nr) <nl>  	} <nl>   <nl>  	MARK(); <nl> -	snprintf(dev->vdev->name, sizeof(dev->vdev->name), dev->card_label); <nl> +	snprintf(dev->vdev->name, sizeof(dev->vdev->name), "%s", dev->card_label); <nl>   <nl>  	vdev_priv->device_nr = nr; <nl>  
@@ -2858,6 +2858,9 @@ static int MP4_ReadBox_String( stream_t *p_stream, MP4_Box_t *p_box ) <nl>  { <nl>      MP4_READBOX_ENTER( MP4_Box_data_string_t ); <nl>   <nl> +    if( p_box->i_size < 8 || p_box->i_size > SIZE_MAX ) <nl> +        MP4_READBOX_EXIT( 0 ); <nl> + <nl>      p_box->data.p_string->psz_text = malloc( p_box->i_size + 1 - 8 ); /* +\0, -name, -size */ <nl>      if( p_box->data.p_string->psz_text == NULL ) <nl>          MP4_READBOX_EXIT( 0 );
@@ -3106,7 +3106,7 @@ static int oidc_handle_session_management_iframe_rp(request_rec *r, oidc_cfg *c, <nl>  			"\n" <nl>  			"      function setTimer() {\n" <nl>  			"        checkSession();\n" <nl> -			"        timerID = setInterval('checkSession()', %s);\n" <nl> +			"        timerID = setInterval('checkSession()', %d);\n" <nl>  			"      }\n" <nl>  			"\n" <nl>  			"      function receiveMessage(e) {\n" <nl> @@ -3149,12 +3149,13 @@ static int oidc_handle_session_management_iframe_rp(request_rec *r, oidc_cfg *c, <nl>   <nl>  	char *s_poll_interval = NULL; <nl>  	oidc_util_get_request_parameter(r, "poll", &s_poll_interval); <nl> -	if (s_poll_interval == NULL) <nl> -		s_poll_interval = "3000"; <nl> +	int poll_interval = s_poll_interval ? strtol(s_poll_interval, NULL, 10) : 0; <nl> +	if ((poll_interval <= 0) || (poll_interval > 3600 * 24)) <nl> +		poll_interval = 3000; <nl>   <nl>  	const char *redirect_uri = oidc_get_redirect_uri(r, c); <nl>  	java_script = apr_psprintf(r->pool, java_script, origin, client_id, <nl> -			session_state, op_iframe_id, s_poll_interval, redirect_uri, <nl> +			session_state, op_iframe_id, poll_interval, redirect_uri, <nl>  			redirect_uri); <nl>   <nl>  	return oidc_util_html_send(r, NULL, java_script, "setTimer", NULL, DONE);
@@ -55,7 +55,8 @@ int init_result(RESULT & result, void*& data) { <nl>  	log_messages.printf(MSG_DEBUG, "Check result\n"); <nl>   <nl>  	char buff[256]; <nl> -	n = fscanf(f, "%s", buff); <nl> +	//n = fscanf(f, "%s", buff); <nl> +	fgets(buff, 256, f); <nl>  	char * pch; <nl>  	pch = strtok(buff, " ,"); <nl>  	if (pch != NULL) {
@@ -327,7 +327,7 @@ bool DatabaseName::read(StarZone &zone) <nl>          } <nl>          data.m_name=libstoff::getString(text); <nl>          int positions[2]; <nl> -        for (int j=0; j<2; ++j) positions[i]=int(input->readULong(4)); <nl> +        for (int j=0; j<2; ++j) positions[j]=int(input->readULong(4)); <nl>          data.m_selection=STOFFVec2i(positions[0],positions[1]); <nl>          m_dataList.push_back(data); <nl>        }
@@ -54,6 +54,8 @@ class EncodePngOp : public OpKernel { <nl>      OP_REQUIRES(context, image.dims() == 3, <nl>                  errors::InvalidArgument("image must be 3-dimensional", <nl>                                          image.shape().DebugString())); <nl> +    OP_REQUIRES(context, image.NumElements() > 0, <nl> +                errors::Internal("Invalid image provided.")); <nl>      OP_REQUIRES( <nl>          context, <nl>          FastBoundsCheck(image.NumElements(), std::numeric_limits<int32>::max()),
@@ -61,6 +61,7 @@ TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) { <nl>    TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type); <nl>   <nl>    const int block_size = params->block_size; <nl> +  TF_LITE_ENSURE(context, block_size > 0); <nl>    const int input_height = input->dims->data[1]; <nl>    const int input_width = input->dims->data[2]; <nl>    int output_height = input_height / block_size;
@@ -60,6 +60,7 @@ TfLiteStatus ResizeOutputTensors(TfLiteContext* context, TfLiteNode* node, <nl>    TF_LITE_ENSURE(context, axis_value < NumDimensions(input)); <nl>   <nl>    const int input_size = SizeOfDimension(input, axis_value); <nl> +  TF_LITE_ENSURE(context, num_splits != 0); <nl>    TF_LITE_ENSURE_MSG(context, input_size % num_splits == 0, <nl>                       "Not an even split"); <nl>    const int slice_size = input_size / num_splits;
@@ -80,8 +80,9 @@ Status GetTensorArray(OpKernelContext* ctx, TensorArray** tensor_array) { <nl>      TF_RETURN_IF_ERROR(GetHandle(ctx, &container, &ta_handle)); <nl>      ResourceMgr* rm = ctx->resource_manager(); <nl>      if (rm == nullptr) return errors::Internal("No resource manager."); <nl> -    TF_RETURN_IF_ERROR( <nl> -        ctx->step_container()->Lookup(rm, container + ta_handle, tensor_array)); <nl> +    ScopedStepContainer* sc = ctx->step_container(); <nl> +    if (sc == nullptr) return errors::Internal("No step container."); <nl> +    TF_RETURN_IF_ERROR(sc->Lookup(rm, container + ta_handle, tensor_array)); <nl>      return OkStatus(); <nl>    } else { <nl>      return LookupResource(ctx, HandleFromInput(ctx, 0), tensor_array);
@@ -405,6 +405,16 @@ class SparseBincountOp : public OpKernel { <nl>        for (int64_t i = 0; i < indices_mat.dimension(0); ++i) { <nl>          const int64_t batch = indices_mat(i, 0); <nl>          const Tidx bin = values(i); <nl> +        OP_REQUIRES( <nl> +            ctx, batch < out.dimension(0), <nl> +            errors::InvalidArgument("Index out of bound. `batch` (", batch, <nl> +                                    ") must be less than the dimension size (", <nl> +                                    out.dimension(0), ").")); <nl> +        OP_REQUIRES( <nl> +            ctx, bin < out.dimension(1), <nl> +            errors::InvalidArgument("Index out ouf bound. `bin` (", bin, <nl> +                                    ") must be less then the dimension size (", <nl> +                                    out.dimension(1), ").")); <nl>          if (bin < size) { <nl>            if (binary_output_) { <nl>              out(batch, bin) = T(1);
@@ -159,6 +159,7 @@ TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) { <nl>    TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 3, &weights)); <nl>    const TfLiteTensor* value; <nl>    TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 4, &value)); <nl> +  const size_t values_size = NumElements(value); <nl>   <nl>    const int lookup_rank = SizeOfDimension(indices, 1); <nl>    const int embedding_rank = NumDimensions(value); <nl> @@ -253,6 +254,11 @@ TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) { <nl>      current_squares_weight += w * w; <nl>      current_total_weight += w; <nl>      for (int k = 0; k < embedding_size; k++) { <nl> +      // only index if indices are valid <nl> +      if (current_output_offset + k < 0) continue; <nl> +      if (current_output_offset + k >= output_size) continue; <nl> +      if (example_embedding_offset + k < 0) continue; <nl> +      if (example_embedding_offset + k >= values_size) continue; <nl>        output_ptr[current_output_offset + k] += <nl>            value_ptr[example_embedding_offset + k] * w; <nl>      }
@@ -345,6 +345,11 @@ class RaggedTensorToTensorBaseOp : public OpKernel { <nl>   <nl>    void Compute(OpKernelContext* context) override { <nl>      INDEX_TYPE first_dimension; <nl> +    const Tensor first_partition_tensor = <nl> +        context->input(kFirstPartitionInputIndex); <nl> +    OP_REQUIRES(context, first_partition_tensor.NumElements() > 0, <nl> +                errors::InvalidArgument("Invalid first partition input. Tensor " <nl> +                                        "requires at least one element.")); <nl>      OP_REQUIRES_OK(context, GetFirstDimensionSize(context, &first_dimension)); <nl>      vector<INDEX_TYPE> output_size; <nl>      OP_REQUIRES_OK(context,
@@ -13,6 +13,7 @@ See the License for the specific language governing permissions and <nl>  limitations under the License. <nl>  ==============================================================================*/ <nl>   <nl> +#include "tensorflow/core/framework/op_requires.h" <nl>  #define EIGEN_USE_THREADS <nl>   <nl>  #if (defined(GOOGLE_CUDA) && GOOGLE_CUDA) || \ <nl> @@ -234,6 +235,10 @@ class QuantizeAndDequantizeV3Op : public OpKernel { <nl>   <nl>    void Compute(OpKernelContext* ctx) override { <nl>      const Tensor& input = ctx->input(0); <nl> +    OP_REQUIRES(ctx, axis_ < input.dims(), <nl> +                errors::InvalidArgument( <nl> +                    "Axis requested is larger than input dimensions. Axis: ", <nl> +                    axis_, " Input Dimensions: ", input.dims())); <nl>      const int depth = (axis_ == -1) ? 1 : input.dim_size(axis_); <nl>      Tensor* output = nullptr; <nl>      OP_REQUIRES_OK(ctx, ctx->allocate_output(0, input.shape(), &output));
@@ -44,6 +44,7 @@ limitations under the License. <nl>  #include "tensorflow/core/framework/types.h" <nl>  #include "tensorflow/core/kernels/conv_2d.h" <nl>  #include "tensorflow/core/kernels/deep_conv2d.h" <nl> +#include "tensorflow/core/kernels/fill_functor.h" <nl>  #include "tensorflow/core/kernels/ops_util.h" <nl>  #include "tensorflow/core/lib/core/errors.h" <nl>  #include "tensorflow/core/lib/gtl/array_slice.h" <nl> @@ -701,6 +702,15 @@ class Conv2DOp : public BinaryOp<T> { <nl>        return; <nl>      } <nl>   <nl> +    // If the input is empty, result can only be due to padding. <nl> +    if (input.NumElements() == 0) { <nl> +      // Zero-out output and return. <nl> +      functor::SetZeroFunctor<Device, T>()(context->eigen_device<Device>(), <nl> +                                           output->template flat<T>()); <nl> + <nl> +      return; <nl> +    } <nl> + <nl>  #ifdef TENSORFLOW_USE_LIBXSMM_CONVOLUTIONS <nl>      if (params_.padding != EXPLICIT && <nl>          LaunchXsmmConvOp<Device, T>::Run(
@@ -170,7 +170,10 @@ void InferenceContext::PreInputInit( <nl>      const std::vector<ShapeHandle>& input_tensors_as_shapes) { <nl>    // TODO(mdan): This is also done at graph construction. Run only here instead? <nl>    const auto ret = full_type::SpecializeType(attrs_, op_def); <nl> -  DCHECK(ret.status().ok()) << "while instantiating types: " << ret.status(); <nl> +  if (!ret.status().ok()) { <nl> +    construction_status_ = ret.status(); <nl> +    return; <nl> +  } <nl>    ret_types_ = ret.ValueOrDie(); <nl>   <nl>    input_tensors_ = input_tensors;
@@ -304,6 +304,9 @@ Status GetDeviceForInput(const EagerOperation& op, const EagerContext& ctx, <nl>      const Tensor* tensor; <nl>      // TODO(fishx): Avoid blocking here. <nl>      TF_RETURN_IF_ERROR(tensor_handle->Tensor(&tensor)); <nl> +    if (tensor->NumElements() == 0) { <nl> +      return errors::InvalidArgument("Empty resource handle"); <nl> +    } <nl>      const ResourceHandle& handle = tensor->flat<ResourceHandle>()(0); <nl>      device_name = handle.device(); <nl>  
@@ -2559,6 +2559,9 @@ Status QuantizeV2Shape(InferenceContext* c) { <nl>    if (!s.ok() && s.code() != error::NOT_FOUND) { <nl>      return s; <nl>    } <nl> +  if (axis < -1) { <nl> +    return errors::InvalidArgument("axis should be at least -1, got ", axis); <nl> +  } <nl>    const int minmax_rank = (axis == -1) ? 0 : 1; <nl>    TF_RETURN_IF_ERROR(shape_inference::UnchangedShape(c)); <nl>    ShapeHandle minmax;
@@ -79,6 +79,7 @@ TfLiteStatus ResizeOutputTensor(TfLiteContext* context, <nl>    for (int dim = 0; dim < spatial_dims_num; ++dim) { <nl>      int final_dim_size = (input_size->data[dim + 1] + paddings_data[dim * 2] + <nl>                            paddings_data[dim * 2 + 1]); <nl> +    TF_LITE_ENSURE(context, block_shape[dim] != 0); <nl>      TF_LITE_ENSURE_EQ(context, final_dim_size % block_shape[dim], 0); <nl>      output_size->data[dim + 1] = final_dim_size / block_shape[dim]; <nl>      output_batch_size *= block_shape[dim];
@@ -53,6 +53,7 @@ class BoostedTreesCreateEnsembleOp : public OpKernel { <nl>      if (!result->InitFromSerialized( <nl>              tree_ensemble_serialized_t->scalar<tstring>()(), stamp_token)) { <nl>        result->Unref(); <nl> +      result.release();  // Needed due to the `->Unref` above, to prevent UAF <nl>        OP_REQUIRES( <nl>            context, false, <nl>            errors::InvalidArgument("Unable to parse tree ensemble proto."));
@@ -1297,6 +1297,9 @@ template <> <nl>  string SummarizeArray<bool>(int64_t limit, int64_t num_elts, <nl>                              const TensorShape& tensor_shape, const char* data, <nl>                              const bool print_v2) { <nl> +  if (data == nullptr) { <nl> +    return strings::StrCat("");  // we already print type and shape <nl> +  } <nl>    // We first convert all chars to be 0/1 to not get InvalidEnumValue sanitizer <nl>    // error <nl>    auto mutable_data = std::unique_ptr<char[]>(new char[num_elts]);
@@ -94,8 +94,10 @@ class UnsortedSegmentJoinOp : public OpKernel { <nl>                  errors::InvalidArgument("Number of segments cannot be empty.")); <nl>      auto num_segments = num_segments_tensor.scalar<NUM_SEGMENTS_TYPE>()(); <nl>   <nl> -    OP_REQUIRES(context, num_segments > 0, <nl> -                errors::InvalidArgument("Number of segments must be positive")); <nl> +    OP_REQUIRES( <nl> +        context, num_segments >= 0, <nl> +        errors::InvalidArgument( <nl> +            "Number of segments must be non-negative but got ", num_segments)); <nl>      OP_REQUIRES(context, segment_dims != 0, <nl>                  errors::InvalidArgument("Segment_id cannot have rank 0")); <nl>  
@@ -188,6 +188,10 @@ class RaggedTensorToVariantOp : public OpKernel { <nl>      batched_ragged_input.mutable_nested_splits()->reserve( <nl>          ragged_nested_splits_len); <nl>      for (int i = 0; i < ragged_nested_splits_len; i++) { <nl> +      OP_REQUIRES(context, ragged_nested_splits_in[i].dims() == 1, <nl> +                  errors::InvalidArgument("Requires nested_row_splits[", i, "]", <nl> +                                          " to be rank 1 but is rank ", <nl> +                                          ragged_nested_splits_in[i].dims())); <nl>        batched_ragged_input.append_splits(ragged_nested_splits_in[i]); <nl>      } <nl>  
@@ -73,6 +73,14 @@ class BaseCandidateSamplerOp : public OpKernel { <nl>   <nl>      gtl::ArraySlice<int64_t> true_candidate( <nl>          true_classes.matrix<int64_t>().data(), batch_size * num_true_); <nl> + <nl> +    for (const auto& candidate : true_candidate) { <nl> +      OP_REQUIRES(context, candidate >= 0 && candidate < sampler_->range(), <nl> +                  errors::InvalidArgument("`true_candidate` out of range [", 0, <nl> +                                          ", ", sampler_->range(), <nl> +                                          "), received ", candidate)); <nl> +    } <nl> + <nl>      gtl::MutableArraySlice<int64_t> sampled_candidate( <nl>          out_sampled_candidates->vec<int64_t>().data(), num_sampled_); <nl>      gtl::MutableArraySlice<float> true_expected_count(
@@ -109,6 +109,9 @@ class CTCLossOp : public OpKernel { <nl>   <nl>      const TensorShape& inputs_shape = inputs->shape(); <nl>      const int64 max_time = inputs_shape.dim_size(0); <nl> +    OP_REQUIRES(ctx, max_time != 0, <nl> +                errors::InvalidArgument( <nl> +                    "Max time or first dimension of input cannot be 0.")); <nl>      const int64 batch_size = inputs_shape.dim_size(1); <nl>      const int64 num_classes_raw = inputs_shape.dim_size(2); <nl>      OP_REQUIRES(
@@ -70,8 +70,12 @@ Status SparseTensorFromContext(OpKernelContext* ctx, const int32_t base_index, <nl>                                 sparse::SparseTensor* tensor) { <nl>    // Assume row-major order. <nl>    TensorShape shape; <nl> -  TF_RETURN_IF_ERROR(TensorShape::BuildTensorShape( <nl> -      ctx->input(base_index + 2).vec<int64_t>(), &shape)); <nl> +  const Tensor& shape_tensor = ctx->input(base_index + 2); <nl> +  if (shape_tensor.dims() != 1) { <nl> +    return errors::InvalidArgument("Shape must be a 1D tensor."); <nl> +  } <nl> +  TF_RETURN_IF_ERROR( <nl> +      TensorShape::BuildTensorShape(shape_tensor.vec<int64_t>(), &shape)); <nl>    CheckRankAtLeast2(ctx, shape); <nl>    std::vector<int64_t> order(shape.dims()); <nl>    std::iota(order.begin(), order.end(), 0);
@@ -348,6 +348,9 @@ class RaggedTensorToTensorBaseOp : public OpKernel { <nl>    Status GetFirstDimensionSize(OpKernelContext* context, INDEX_TYPE* result) { <nl>      const Tensor first_partition_tensor = <nl>          context->input(kFirstPartitionInputIndex); <nl> +    if (row_partition_types_.empty()) { <nl> +      return errors::InvalidArgument("No row_partition_types given."); <nl> +    } <nl>      const RowPartitionType first_partition_type = row_partition_types_[0]; <nl>      switch (first_partition_type) { <nl>        case RowPartitionType::FIRST_DIM_SIZE:
@@ -395,6 +395,12 @@ class SvdOpGpu : public AsyncOpKernel { <nl>      OP_REQUIRES_OK_ASYNC(context, context->allocate_output(2, shapeV, &outputV), <nl>                           done); <nl>   <nl> +    // If there are zero batches, we are done. <nl> +    if (shapeRaw.num_elements() == 0) { <nl> +      done(); <nl> +      return; <nl> +    } <nl> + <nl>      if (n == 0 || m == 0) { <nl>        if (n == m || !compute_uv_ || !full_matrices_) { <nl>          // S, U, and V are all empty. Nothing to do.
@@ -169,6 +169,8 @@ void DoNonMaxSuppressionOp(OpKernelContext* context, const Tensor& scores, <nl>                             bool pad_to_max_output_size = false, <nl>                             int* ptr_num_valid_outputs = nullptr) { <nl>    const int output_size = max_output_size.scalar<int>()(); <nl> +  OP_REQUIRES(context, output_size >= 0, <nl> +              errors::InvalidArgument("output size must be non-negative")); <nl>   <nl>    std::vector<T> scores_data(num_boxes); <nl>    std::copy_n(scores.flat<T>().data(), num_boxes, scores_data.begin()); <nl> @@ -768,6 +770,9 @@ class NonMaxSuppressionV4Op : public OpKernel { <nl>          context, scores, num_boxes, max_output_size, iou_threshold_val, <nl>          score_threshold_val, dummy_soft_nms_sigma, similarity_fn, <nl>          return_scores_tensor_, pad_to_max_output_size_, &num_valid_outputs); <nl> +    if (!context->status().ok()) { <nl> +      return; <nl> +    } <nl>   <nl>      // Allocate scalar output tensor for number of indices computed. <nl>      Tensor* num_outputs_t = nullptr; <nl> @@ -845,6 +850,9 @@ class NonMaxSuppressionV5Op : public OpKernel { <nl>          context, scores, num_boxes, max_output_size, iou_threshold_val, <nl>          score_threshold_val, soft_nms_sigma_val, similarity_fn, <nl>          return_scores_tensor_, pad_to_max_output_size_, &num_valid_outputs); <nl> +    if (!context->status().ok()) { <nl> +      return; <nl> +    } <nl>   <nl>      // Allocate scalar output tensor for number of indices computed. <nl>      Tensor* num_outputs_t = nullptr;
@@ -527,6 +527,10 @@ inline Status SparseTensor::Split(const SparseTensor& input_tensor, <nl>    for (int i = 0; i < input_tensor.indices().dim_size(0); ++i) { <nl>      const int dim = input_tensor.indices().matrix<int64>()(i, split_dim); <nl>      int slice_index = GetSliceIndex(dim, split_size, residual); <nl> +    if (slice_index >= num_values.size()) { <nl> +      return errors::InvalidArgument("Slice index ", slice_index, <nl> +                                     " is larger than num_split."); <nl> +    } <nl>      num_values[slice_index]++; <nl>    } <nl>  
@@ -1741,14 +1741,16 @@ Status ConstantFolding::IsSimplifiableReshape( <nl>        int32_t dim = outputs[0]->flat<int32>()(i); <nl>        shp.push_back(dim); <nl>      } <nl> -    TF_CHECK_OK(TensorShapeUtils::MakeShape(shp, &new_dims)); <nl> +    s = TensorShapeUtils::MakeShape(shp, &new_dims); <nl> +    if (!s.ok()) return s; <nl>    } else { <nl>      std::vector<int64_t> shp; <nl>      for (int i = 0; i < outputs[0]->NumElements(); ++i) { <nl>        int64_t dim = outputs[0]->flat<int64_t>()(i); <nl>        shp.push_back(dim); <nl>      } <nl> -    TF_CHECK_OK(TensorShapeUtils::MakeShape(shp, &new_dims)); <nl> +    s = TensorShapeUtils::MakeShape(shp, &new_dims); <nl> +    if (!s.ok()) return s; <nl>    } <nl>   <nl>    if (!shape.IsCompatibleWith(new_dims)) {
@@ -44,6 +44,11 @@ inline int ComputePaddingWithOffset(int stride, int dilation_rate, int in_size, <nl>  inline int ComputeOutSize(TfLitePadding padding, int image_size, <nl>                            int filter_size, int stride, int dilation_rate = 1) { <nl>    int effective_filter_size = (filter_size - 1) * dilation_rate + 1; <nl> + <nl> +  // TODO(b/186448822): This uses 0 since the function has no other way to <nl> +  // report error case <nl> +  if (stride == 0) return 0; <nl> + <nl>    switch (padding) { <nl>      case kTfLitePaddingSame: <nl>        return (image_size + stride - 1) / stride;
@@ -28,7 +28,7 @@ limitations under the License. <nl>  // <nl>  // Input: <nl>  //   Tensor[0]: Hash functions. Dim.size == 2, DataType: Float. <nl> -//              Tensor[0].Dim[0]: Num of hash functions. <nl> +//              Tensor[0].Dim[0]: Num of hash functions. Must be at least 1. <nl>  //              Tensor[0].Dim[1]: Num of projected output bits generated by <nl>  //                                each hash function. <nl>  //   In sparse case, Tensor[0].Dim[1] + ceil( log2(Tensor[0].Dim[0] )) <= 32. <nl> @@ -82,6 +82,7 @@ TfLiteStatus Resize(TfLiteContext* context, TfLiteNode* node) { <nl>    const TfLiteTensor* input; <nl>    TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 1, &input)); <nl>    TF_LITE_ENSURE(context, NumDimensions(input) >= 1); <nl> +  TF_LITE_ENSURE(context, SizeOfDimension(input, 0) >= 1); <nl>   <nl>    if (NumInputs(node) == 3) { <nl>      const TfLiteTensor* weight;
@@ -73,6 +73,9 @@ class MatrixDiagPartOp : public OpKernel { <nl>                    errors::InvalidArgument( <nl>                        "diag_index must be a scalar or vector, received shape: ", <nl>                        diag_index.shape().DebugString())); <nl> +      OP_REQUIRES(context, diag_index.NumElements() > 0, <nl> +                  errors::InvalidArgument( <nl> +                      "Expected diag_index to have at least 1 element")); <nl>        lower_diag_index = diag_index.flat<int32>()(0); <nl>        upper_diag_index = lower_diag_index; <nl>        if (TensorShapeUtils::IsVector(diag_index.shape())) { <nl> @@ -179,6 +182,9 @@ class MatrixDiagOp : public OpKernel { <nl>                    errors::InvalidArgument( <nl>                        "diag_index must be a scalar or vector, received shape: ", <nl>                        diag_index.shape().DebugString())); <nl> +      OP_REQUIRES(context, diag_index.NumElements() > 0, <nl> +                  errors::InvalidArgument( <nl> +                      "Expected diag_index to have at least 1 element")); <nl>        lower_diag_index = diag_index.flat<int32>()(0); <nl>        upper_diag_index = lower_diag_index; <nl>        if (TensorShapeUtils::IsVector(diag_index.shape())) {
@@ -333,6 +333,8 @@ Status ImportGenericFunction( <nl>    // Import the function attributes with a `tf.` prefix to match the current <nl>    // infrastructure expectations. <nl>    for (const auto& namedAttr : func.attr()) { <nl> +    if (namedAttr.first.empty()) <nl> +      return InvalidArgument("Invalid function attribute name"); <nl>      const std::string& name = "tf." + namedAttr.first; <nl>      const AttrValue& tf_attr = namedAttr.second; <nl>      TF_ASSIGN_OR_RETURN(Attribute attr,
@@ -202,7 +202,7 @@ class RandomGammaOp : public OpKernel { <nl>      // avoid a couple flops which can be done on a per-alpha basis. <nl>   <nl>      auto DoWork = [samples_per_alpha, num_alphas, &rng, samples_flat, <nl> -                   alpha_flat](int start_output, int limit_output) { <nl> +                   alpha_flat](int64 start_output, int64 limit_output) { <nl>        using Eigen::numext::exp; <nl>        using Eigen::numext::log; <nl>        using Eigen::numext::log1p;
@@ -223,6 +223,7 @@ TfLiteStatus PrepareImpl(TfLiteContext* context, TfLiteNode* node) { <nl>    } <nl>   <nl>    TF_LITE_ENSURE_EQ(context, NumDimensions(filter), 2); <nl> +  TF_LITE_ENSURE(context, filter->dims->data[1] != 0); <nl>    const int batch_size = input_size / filter->dims->data[1]; <nl>    const int num_units = filter->dims->data[0]; <nl>  
@@ -559,7 +559,10 @@ vi_pci_read(UNUSED int vcpu, struct pci_devinst *pi, int baridx, <nl>  		max = vc->vc_cfgsize ? vc->vc_cfgsize : 0x100000000; <nl>  		if ((newoff + ((unsigned) size)) > max) <nl>  			goto bad; <nl> -		error = (*vc->vc_cfgread)(DEV_SOFTC(vs), ((int) newoff), size, &value); <nl> +		if (vc->vc_cfgread != NULL) <nl> +			error = (*vc->vc_cfgread)(DEV_SOFTC(vs), ((int) newoff), size, &value); <nl> +		else <nl> +			error = 0; <nl>  		if (!error) <nl>  			goto done; <nl>  	}
@@ -1121,6 +1121,11 @@ static void pci_vtsock_proc_tx(struct pci_vtsock_softc *sc, <nl>  	size_t pulled; <nl>   <nl>  	iovec_len = vq_getchain(vq, &idx, iov, VTSOCK_MAXSEGS, flags); <nl> +	if (iovec_len < 0) { <nl> +		fprintf(stderr, "TX: failed to get chain at idx %"PRIx16"\n", idx); <nl> +		return; <nl> +	} <nl> + <nl>  	assert(iovec_len <= VTSOCK_MAXSEGS); <nl>   <nl>  	DPRINTF(("TX: chain with %d buffers at idx %"PRIx16"\n",
@@ -113,7 +113,6 @@ static char ** split(const char *arg, const char *delim) { <nl>  	free(result[--i]); <nl>        } <nl>        free(result); <nl> -      free(copy); <nl>        return NULL; <nl>      } <nl>      result = tmp;
@@ -352,6 +352,12 @@ EStatusCode PDFParser::ParseLastXrefPosition() <nl>  		mObjectParser.ResetReadState(); <nl>  		RefCountPtr<PDFObject> anObject(mObjectParser.ParseNewObject()); <nl>   <nl> +		if (!anObject) { <nl> +			status = PDFHummus::eFailure; <nl> +			TRACE_LOG("PDFParser::ParseXrefPosition: Unable to find any object"); <nl> +			break; <nl> +		} <nl> + <nl>  		if(anObject->GetType() == PDFObject::ePDFObjectInteger) <nl>  		{ <nl>  			mLastXrefPosition = (LongFilePositionType)((PDFInteger*)anObject.GetPtr())->GetValue();
@@ -352,6 +352,12 @@ EStatusCode PDFParser::ParseLastXrefPosition() <nl>  		mObjectParser.ResetReadState(); <nl>  		RefCountPtr<PDFObject> anObject(mObjectParser.ParseNewObject()); <nl>   <nl> +		if (!anObject) { <nl> +			status = PDFHummus::eFailure; <nl> +			TRACE_LOG("PDFParser::ParseXrefPosition: Unable to find any object"); <nl> +			break; <nl> +		} <nl> + <nl>  		if(anObject->GetType() == PDFObject::ePDFObjectInteger) <nl>  		{ <nl>  			mLastXrefPosition = (LongFilePositionType)((PDFInteger*)anObject.GetPtr())->GetValue();
@@ -583,7 +583,8 @@ int ksmbd_decode_ntlmssp_auth_blob(struct authenticate_message *authblob, <nl>  	dn_off = le32_to_cpu(authblob->DomainName.BufferOffset); <nl>  	dn_len = le16_to_cpu(authblob->DomainName.Length); <nl>   <nl> -	if (blob_len < (u64)dn_off + dn_len || blob_len < (u64)nt_off + nt_len) <nl> +	if (blob_len < (u64)dn_off + dn_len || blob_len < (u64)nt_off + nt_len || <nl> +	    nt_len < CIFS_ENCPWD_SIZE) <nl>  		return -EINVAL; <nl>   <nl>  #ifdef CONFIG_SMB_INSECURE_SERVER
@@ -731,8 +731,6 @@ int ntlm_decode_target_info(struct ntlm_ctx *ctx, struct ntlm_buffer *buffer, <nl>   <nl>  done: <nl>      if (ret) { <nl> -        ntlm_free_buffer_data(&sh); <nl> -        ntlm_free_buffer_data(&cb); <nl>          safefree(nb_computer); <nl>          safefree(nb_domain); <nl>          safefree(dns_computer);
@@ -205,7 +205,6 @@ static int ntlm_str_convert(iconv_t cd, <nl>      return 0; <nl>  } <nl>   <nl> - <nl>  uint8_t ntlmssp_sig[8] = {'N', 'T', 'L', 'M', 'S', 'S', 'P', 0}; <nl>   <nl>  static void ntlm_encode_header(struct wire_msg_hdr *hdr, uint32_t msg_type) <nl> @@ -256,6 +255,7 @@ static int ntlm_decode_oem_str(struct wire_field_hdr *str_hdr, <nl>      str_offs = le32toh(str_hdr->offset); <nl>      if ((str_offs < payload_offs) || <nl>          (str_offs > buffer->length) || <nl> +        (UINT32_MAX - str_offs < str_len) || <nl>          (str_offs + str_len > buffer->length)) { <nl>          return ERR_DECODE; <nl>      } <nl> @@ -308,6 +308,7 @@ static int ntlm_decode_u16l_str_hdr(struct ntlm_ctx *ctx, <nl>      str_offs = le32toh(str_hdr->offset); <nl>      if ((str_offs < payload_offs) || <nl>          (str_offs > buffer->length) || <nl> +        (UINT32_MAX - str_offs < str_len) || <nl>          (str_offs + str_len > buffer->length)) { <nl>          return ERR_DECODE; <nl>      } <nl> @@ -393,6 +394,7 @@ static int ntlm_decode_field(struct wire_field_hdr *hdr, <nl>      offs = le32toh(hdr->offset); <nl>      if ((offs < payload_offs) || <nl>          (offs > buffer->length) || <nl> +        (UINT32_MAX - offs < len) || <nl>          (offs + len > buffer->length)) { <nl>          return ERR_DECODE; <nl>      }
@@ -1,4 +1,4 @@ <nl> -/* $OpenBSD: s3_lib.c,v 1.242 2022/11/26 16:08:55 tb Exp $ */ <nl> +/* $OpenBSD: s3_lib.c,v 1.242.4.1 2023/05/26 08:49:20 tb Exp $ */ <nl>  /* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com) <nl>   * All rights reserved. <nl>   * <nl> @@ -1580,6 +1580,7 @@ ssl3_free(SSL *s) <nl>   <nl>  	sk_X509_NAME_pop_free(s->s3->hs.tls12.ca_names, X509_NAME_free); <nl>  	sk_X509_pop_free(s->verified_chain, X509_free); <nl> +	s->verified_chain = NULL; <nl>   <nl>  	tls1_transcript_free(s); <nl>  	tls1_transcript_hash_free(s);
@@ -376,10 +376,10 @@ retry_un_dir: <nl>   <nl>          if (ec) <nl>          { <nl> -          // Delete previous uninstaller <nl> -          if (DeleteFile(unexe)) <nl> +          // Delete previous uninstaller (if it is safe to do so) <nl> +          if (!(GetFileAttributes(unexe) & FILE_ATTRIBUTE_REPARSE_POINT) && DeleteFile(unexe)) <nl>            { <nl> -            myDelete(state_temp_dir, DEL_DIR|DEL_RECURSE); <nl> +            myDelete(state_temp_dir, DEL_DIR); <nl>              if (!retry++) goto retry_un_dir; <nl>            } <nl>          }
@@ -125,6 +125,7 @@ IN_PROC_BROWSER_TEST_F(WebUIResourceBrowserTest, ListTest) { <nl>    LoadFile(base::FilePath(FILE_PATH_LITERAL("list_test.html"))); <nl>  } <nl>   <nl> +#if defined(OS_CHROMEOS) <nl>  IN_PROC_BROWSER_TEST_F(WebUIResourceBrowserTest, GridTest) { <nl>    AddLibrary(IDR_WEBUI_JS_CR); <nl>    AddLibrary(IDR_WEBUI_JS_CR_EVENT_TARGET); <nl> @@ -138,6 +139,7 @@ IN_PROC_BROWSER_TEST_F(WebUIResourceBrowserTest, GridTest) { <nl>    AddLibrary(IDR_WEBUI_JS_CR_UI_GRID); <nl>    LoadFile(base::FilePath(FILE_PATH_LITERAL("grid_test.html"))); <nl>  } <nl> +#endif <nl>   <nl>  IN_PROC_BROWSER_TEST_F(WebUIResourceBrowserTest, ListSelectionModelTest) { <nl>    AddLibrary(IDR_WEBUI_JS_CR);
@@ -768,8 +768,12 @@ bool PasswordAutofillAgent::IsUsernameOrPasswordField( <nl>  bool PasswordAutofillAgent::TryToShowTouchToFill( <nl>      const WebFormControlElement& control_element) { <nl>    const WebInputElement* element = ToWebInputElement(&control_element); <nl> -  if (!element || (!base::Contains(web_input_to_password_info_, *element) && <nl> -                   !base::Contains(password_to_username_, *element))) { <nl> +  WebInputElement username_element; <nl> +  WebInputElement password_element; <nl> +  PasswordInfo* password_info = nullptr; <nl> +  if (!element || <nl> +      !FindPasswordInfoForElement(*element, &username_element, <nl> +                                  &password_element, &password_info)) { <nl>      return false; <nl>    } <nl>    if (was_touch_to_fill_ui_shown_)
@@ -21,10 +21,11 @@ PerformanceNavigationTiming::PerformanceNavigationTiming( <nl>      ResourceTimingInfo* info, <nl>      TimeTicks time_origin, <nl>      const WebVector<WebServerTimingInfo>& server_timing) <nl> -    : PerformanceResourceTiming(info ? info->InitialURL().GetString() : "", <nl> -                                "navigation", <nl> -                                time_origin, <nl> -                                server_timing), <nl> +    : PerformanceResourceTiming( <nl> +          info ? info->FinalResponse().Url().GetString() : "", <nl> +          "navigation", <nl> +          time_origin, <nl> +          server_timing), <nl>        ContextClient(frame), <nl>        resource_timing_info_(info) { <nl>    DCHECK(frame);
@@ -23,6 +23,8 @@ <nl>  #include "core/loader/ImageLoader.h" <nl>   <nl>  #include <memory> <nl> +#include <utility> <nl> + <nl>  #include "bindings/core/v8/ExceptionState.h" <nl>  #include "bindings/core/v8/ScriptController.h" <nl>  #include "bindings/core/v8/V8BindingForCore.h" <nl> @@ -391,10 +393,16 @@ void ImageLoader::DoUpdateFromElement(BypassMainWorldBehavior bypass_behavior, <nl>            referrer_policy, url, document.OutgoingReferrer())); <nl>      } <nl>   <nl> +    // Correct the RequestContext if necessary. <nl>      if (IsHTMLPictureElement(GetElement()->parentNode()) || <nl> -        !GetElement()->FastGetAttribute(HTMLNames::srcsetAttr).IsNull()) <nl> +        !GetElement()->FastGetAttribute(HTMLNames::srcsetAttr).IsNull()) { <nl>        resource_request.SetRequestContext( <nl>            WebURLRequest::kRequestContextImageSet); <nl> +    } else if (IsHTMLObjectElement(GetElement())) { <nl> +      resource_request.SetRequestContext(WebURLRequest::kRequestContextObject); <nl> +    } else if (IsHTMLEmbedElement(GetElement())) { <nl> +      resource_request.SetRequestContext(WebURLRequest::kRequestContextEmbed); <nl> +    } <nl>   <nl>      bool page_is_being_dismissed = <nl>          document.PageDismissalEventBeingDispatched() != Document::kNoDismissal;
@@ -385,6 +385,7 @@ HarfBuzzShaper::HarfBuzzShaper(const Font* font, const TextRun& run, const Glyph <nl>      , m_expansionOpportunityCount(0) <nl>      , m_fromIndex(0) <nl>      , m_toIndex(m_run.length()) <nl> +    , m_totalWidth(0) <nl>  { <nl>      m_normalizedBuffer = adoptArrayPtr(new UChar[m_run.length() + 1]); <nl>      normalizeCharacters(m_run, m_run.length(), m_normalizedBuffer.get(), &m_normalizedBufferLength); <nl> @@ -541,7 +542,6 @@ bool HarfBuzzShaper::shape(GlyphBuffer* glyphBuffer) <nl>      if (!createHarfBuzzRuns()) <nl>          return false; <nl>   <nl> -    m_totalWidth = 0; <nl>      if (!shapeHarfBuzzRuns()) <nl>          return false; <nl>  
@@ -59,6 +59,10 @@ std::string ProcessRawBytesWithSeparators(const unsigned char* data, <nl>    // except for the last byte. <nl>    std::string ret; <nl>    size_t kMin = 0U; <nl> + <nl> +  if (!data_length) <nl> +    return ""; <nl> + <nl>    ret.reserve(std::max(kMin, data_length * 3 - 1)); <nl>   <nl>    for (size_t i = 0; i < data_length; ++i) {
@@ -129,7 +129,7 @@ void CompileFromResponseCallback( <nl>                                   "WebAssembly", "compile"); <nl>    ExceptionToRejectPromiseScope reject_promise_scope(args, exception_state); <nl>   <nl> -  ScriptState* script_state = ScriptState::ForRelevantRealm(args); <nl> +  ScriptState* script_state = ScriptState::ForCurrentRealm(args); <nl>    if (!ExecutionContext::From(script_state)) { <nl>      V8SetReturnValue(args, ScriptPromise().V8Value()); <nl>      return; <nl> @@ -142,7 +142,7 @@ void CompileFromResponseCallback( <nl>          ScriptPromise::Reject( <nl>              script_state, V8ThrowException::CreateTypeError( <nl>                                script_state->GetIsolate(), <nl> -                              "An argument must be provided, which must be a" <nl> +                              "An argument must be provided, which must be a " <nl>                                "Response or Promise<Response> object")) <nl>              .V8Value()); <nl>      return; <nl> @@ -189,7 +189,7 @@ void CompileFromResponseCallback( <nl>  // See https://crbug.com/708238 for tracking avoiding the hand-generated code. <nl>  void WasmCompileStreamingImpl(const v8::FunctionCallbackInfo<v8::Value>& args) { <nl>    v8::Isolate* isolate = args.GetIsolate(); <nl> -  ScriptState* script_state = ScriptState::ForRelevantRealm(args); <nl> +  ScriptState* script_state = ScriptState::ForCurrentRealm(args); <nl>   <nl>    v8::Local<v8::Function> compile_callback = <nl>        v8::Function::New(isolate, CompileFromResponseCallback);
@@ -139,11 +139,11 @@ void RenderSVGImage::paint(PaintInfo& paintInfo, const LayoutPoint&) <nl>          GraphicsContextStateSaver stateSaver(*childPaintInfo.context); <nl>          childPaintInfo.applyTransform(m_localTransform); <nl>   <nl> -        if (childPaintInfo.phase == PaintPhaseForeground) { <nl> +        if (childPaintInfo.phase == PaintPhaseForeground && !m_objectBoundingBox.isEmpty()) { <nl>              SVGRenderingContext renderingContext(this, childPaintInfo); <nl>   <nl>              if (renderingContext.isRenderingPrepared()) { <nl> -                if (style()->svgStyle()->bufferedRendering() == BR_STATIC  && renderingContext.bufferForeground(m_bufferedForeground)) <nl> +                if (style()->svgStyle()->bufferedRendering() == BR_STATIC && renderingContext.bufferForeground(m_bufferedForeground)) <nl>                      return; <nl>   <nl>                  paintForeground(childPaintInfo);
@@ -2373,7 +2373,7 @@ void Document::open() <nl>   <nl>      if (m_frame) <nl>          m_frame->loader().didExplicitOpen(); <nl> -    if (m_loadEventProgress != LoadEventInProgress && m_loadEventProgress != UnloadEventInProgress) <nl> +    if (m_loadEventProgress != LoadEventInProgress && pageDismissalEventBeingDispatched() == NoDismissal) <nl>          m_loadEventProgress = LoadEventNotRun; <nl>  } <nl>  
@@ -482,7 +482,7 @@ void FileSystemOperation::GetUsageAndQuotaThenRunTask( <nl>        origin, <nl>        FileSystemTypeToQuotaStorageType(type), <nl>        base::Bind(&FileSystemOperation::DidGetUsageAndQuotaAndRunTask, <nl> -                 base::Unretained(this), params)); <nl> +                 weak_factory_.GetWeakPtr(), params)); <nl>  } <nl>   <nl>  void FileSystemOperation::DidGetUsageAndQuotaAndRunTask(
@@ -229,14 +229,10 @@ void ContentSettingsStore::ClearContentSettingsForExtension( <nl>    { <nl>      base::AutoLock lock(lock_); <nl>      OriginIdentifierValueMap* map = GetValueMap(ext_id, scope); <nl> -    // TODO(bauerb): This is for debugging http://crbug.com/128652. <nl> -    // Remove once the bug is fixed. <nl>      if (!map) { <nl> -      char ext_id_buffer[33]; <nl> -      base::strlcpy(ext_id_buffer, ext_id.c_str(), sizeof(ext_id_buffer)); <nl> -      base::debug::Alias(ext_id_buffer); <nl> -      // Do a clean crash. <nl> -      CHECK(false); <nl> +      // Fail gracefully in Release builds. <nl> +      NOTREACHED(); <nl> +      return; <nl>      } <nl>      notify = !map->empty(); <nl>      map->clear();
@@ -157,6 +157,7 @@ void RuntimeCustomBindings::GetExtensionViews( <nl>    std::vector<content::RenderFrame*> frames = <nl>        ExtensionFrameHelper::GetExtensionFrames(extension_id, browser_window_id, <nl>                                                 view_type); <nl> +  v8::Local<v8::Context> v8_context = args.GetIsolate()->GetCurrentContext(); <nl>    v8::Local<v8::Array> v8_views = v8::Array::New(args.GetIsolate()); <nl>    int v8_index = 0; <nl>    for (content::RenderFrame* frame : frames) { <nl> @@ -172,7 +173,9 @@ void RuntimeCustomBindings::GetExtensionViews( <nl>      if (!context.IsEmpty()) { <nl>        v8::Local<v8::Value> window = context->Global(); <nl>        DCHECK(!window.IsEmpty()); <nl> -      v8_views->Set(v8::Integer::New(args.GetIsolate(), v8_index++), window); <nl> +      v8::Maybe<bool> maybe = <nl> +        v8_views->CreateDataProperty(v8_context, v8_index++, window); <nl> +      DCHECK(maybe.IsJust() && maybe.FromJust()); <nl>      } <nl>    } <nl>  
@@ -14,6 +14,7 @@ <nl>  #include "chrome/browser/ui/views/frame/browser_non_client_frame_view.h" <nl>  #include "chrome/browser/ui/views/frame/browser_view.h" <nl>  #include "ui/gfx/font.h" <nl> +#include "views/views_delegate.h" <nl>  #include "views/widget/root_view.h" <nl>  #include "views/widget/widget.h" <nl>  #include "views/window/hit_test.h" <nl> @@ -91,7 +92,8 @@ gboolean BrowserFrameGtk::OnConfigureEvent(GtkWidget* widget, <nl>  NativeBrowserFrame* NativeBrowserFrame::CreateNativeBrowserFrame( <nl>      BrowserFrame* browser_frame, <nl>      BrowserView* browser_view) { <nl> -  if (views::Widget::IsPureViews()) <nl> +  if (views::Widget::IsPureViews() && <nl> +      views::ViewsDelegate::views_delegate->GetDefaultParentView()) <nl>      return new BrowserFrameViews(browser_frame, browser_view); <nl>    return new BrowserFrameGtk(browser_frame, browser_view); <nl>  }
@@ -261,6 +261,9 @@ class HostProcess <nl>    void CreateAuthenticatorFactory() { <nl>      DCHECK(context_->network_task_runner()->BelongsToCurrentThread()); <nl>   <nl> +    if (!host_ || shutting_down_) <nl> +      return; <nl> + <nl>      std::string local_certificate = key_pair_.GenerateCertificate(); <nl>      if (local_certificate.empty()) { <nl>        LOG(ERROR) << "Failed to generate host certificate.";
@@ -281,6 +281,13 @@ class DriveFsHost::MountState <nl>      token_fetch_attempted_ = true; <nl>    } <nl>   <nl> +  void OnHeartbeat() override { <nl> +    DCHECK_CALLED_ON_VALID_SEQUENCE(host_->sequence_checker_); <nl> +    if (host_->timer_->IsRunning()) { <nl> +      host_->timer_->Reset(); <nl> +    } <nl> +  } <nl> + <nl>    void OnMounted() override { <nl>      DCHECK_CALLED_ON_VALID_SEQUENCE(host_->sequence_checker_); <nl>      drivefs_has_mounted_ = true;
@@ -16,6 +16,7 @@ <nl>  #include "base/metrics/histogram_macros.h" <nl>  #include "base/pickle.h" <nl>  #include "base/strings/stringprintf.h" <nl> +#include "base/trace_event/trace_event.h" <nl>  #include "components/sync/base/time.h" <nl>  #include "components/sync/device_info/device_info.h" <nl>  #include "components/sync/device_info/device_info_util.h" <nl> @@ -172,6 +173,8 @@ class FactoryImpl : public base::SupportsWeakPtr<FactoryImpl> { <nl>        std::unique_ptr<ModelTypeStore::RecordList> record_list, <nl>        const base::Optional<syncer::ModelError>& error, <nl>        std::unique_ptr<syncer::MetadataBatch> metadata_batch) { <nl> +    // Remove after fixing https://crbug.com/902203. <nl> +    TRACE_EVENT0("browser", "FactoryImpl::OnReadAllMetadata"); <nl>      if (error) { <nl>        std::move(callback).Run(error, /*store=*/nullptr, <nl>                                /*metadata_batch=*/nullptr);
